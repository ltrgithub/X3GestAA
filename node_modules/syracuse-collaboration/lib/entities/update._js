"use strict";

var globals = require('streamline/lib/globals');
var mongodb = require('streamline-mongodb');
var unzip = require('streamline-zip/lib/unzip/unzip');
var ez = require('ez-streams');

var locale = require("syracuse-core/lib/locale");
var date = require("syracuse-core/lib/types/date");
var datetime = require("syracuse-core/lib/types/datetime");
var sadFsq = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient');
var SadFsqClient = sadFsq.SadFsqClient;

var scheduler = require("syracuse-event/lib/scheduler");
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var tracer = require('syracuse-trace/lib/helper').getTracer('patch');

var config = require('config'); // must be first syracuse require

exports.$exported = true;

function _normalizeDiag(diag) {
	return {
		$severity: diag.$severity || diag.severity,
		$message: diag.$message || diag.message,
		$stackTrace: diag.$stackTrace
	};
}

function trackMessage(context, severity, message) {
	switch (severity) {
		case "error":
			tracer.error && tracer.error(message);
			break;
		case "info":
			tracer.info && tracer.info(message);
			break;
		default:
			tracer.debug && tracer.debug(message);
			break;
	}

	var t = context && context.tracker;
	if (t) {
		//t.phaseDetail = t.phaseDetail;
		t.$diagnoses = t.$diagnoses || [];
		t.$diagnoses.push({
			$severity: severity,
			$message: message
		});
	}
}

function copyPatch(_, context, update, endpoint, patch) {
	var path = "PATCH/" + patch.path(_);
	trackMessage(context, "info", locale.format(module, "copyPatchTo", path));

	var sadfs = new SadFsqClient(_, endpoint, null, null, false);
	var x3Files = [];
	var refFiles = [];
	try {
		var lsadx = sadfs.readdir(_, {
			folder: endpoint.x3ServerFolder(_),
			path: path,
		});

		lsadx.forEach(function(file) {
			x3Files.push(file);
		});
	} catch (e) {

	}

	var store = update.file(_);

	if (store.fileExists(_)) {
		var props = store.getProperties(_);
		var root = (props.fileName.substring(0, props.fileName.lastIndexOf('.')) + "/" + patch.path(_) + "/").toUpperCase();

		var zip = store.createReadableStream(_).readAll(_);
		var total = 0;

		var firstMaintenance = 0;
		var lastMaintenance = 0;

		var patchFiles = new unzip.Unzip(
			zip,
			function(filename, filecontent, headers, _) {
				var fname = filename.substring(filename.lastIndexOf('/') + 1);
				var fileOptions = {
					folder: endpoint.x3ServerFolder(_),
					path: options.path + fname
				};
				trackMessage(context, "info", locale.format(module, "copyFile", fname));

				for (var i = 0; i < 3; i++) {
					try {
						sadfs.writeFile(_, fileOptions, filecontent, {
							flag: "w+"
						});
						if (sadfs.stat(_, fileOptions, ["size"]).size > 0) break;
						// Retry a copy if the previous ended with a o size file:
						tracer.error && tracer.error("sadfs.writeFile(" + fileOptions.path + ") failed");
					} catch (e) {
						tracer.error && tracer.error("exception in sadfs.writeFile:" + e.stack);
					}
					try {
						sadfs.unlink(_, fileOptions);
					} catch (e) {
						tracer.error && tracer.error("exception in sadfs.unlink:" + e.stack);
					}
				}
			}, {
				filter: function(filename, headers, _) {
					var keep = (filename.toUpperCase().substring(0, root.length) === root);
					if (keep) {

						var file = filename.toUpperCase().substring(1 + filename.lastIndexOf('/'));
						if (file.length) {
							var match = file.match(/[A-Z]*_(\d*)_\d*\.\w{3}/);
							if (match) {
								var maintenance = parseInt(match[1]);
								firstMaintenance = (firstMaintenance) ? Math.min(maintenance, firstMaintenance) : maintenance;
								lastMaintenance = (lastMaintenance) ? Math.max(maintenance, lastMaintenance) : maintenance;
							}

							// Doesn't copy file present on the X3 folder :
							refFiles.push(file);
							keep = !x3Files.some(function(x3File) {
								return x3File.toUpperCase() === file;
							});
						} else {
							keep = false;
						}
					}
					return keep;
				}
			});

		var zipFiles = patchFiles.list(_);
		total = zipFiles.length;

		// Remove files which aren't supposed to be there :
		trackMessage(context, "info", locale.format(module, "cleanUp"));
		x3Files
			.filter(function(file) {
				var uFile = file.toUpperCase();
				return !refFiles.some(function(refFile) {
					return refFile === uFile;
				});
			})
			.forEach_(_, function(_, file) {
				try {
					trackMessage(context, "info", locale.format(module, "unlinkFile", path, file));
					sadfs.unlink(_, {
						folder: endpoint.x3ServerFolder(_),
						path: path,
						name: file,
					});
				} catch (e) {}
			});


		trackMessage(context, "info", locale.format(module, "copyFilesTo", path));
		var options = {
			folder: endpoint.x3ServerFolder(_),
			path: "",
		};
		path.split('/').forEach_(_, function(_, subdir) {
			options.path += subdir;
			trackMessage(context, "info", locale.format(module, "mkdir", options.path));
			var rep = sadfs.mkdir(_, options);
			options.path += "/";
		});

		patchFiles.unzip(_);

		patch.firstMaintenance(_, firstMaintenance);
		patch.lastMaintenance(_, lastMaintenance);
		return path;
	}
}

function applyUpdate(integrate) {
	return function(_, context, instance) {
		tracer.debug && tracer.debug("applyUpdate(" + integrate + ")");
		instance.updateInProgress = true;
		var endpoints = instance.endpoints(_);
		var patches = instance.patches(_).toArray(_, true);
		var fcts = [];

		if (context && context.tracker) context.tracker.phaseDetail = locale.format(module, "phase" + (integrate ? "Apply" : "Test"));

		endpoints.toArray(_, true).forEach_(_, function(_, epToUpdate) {
			fcts.push(updateEndpoint(!_, context, integrate, instance, epToUpdate, patches));
		});

		// Wait for the execution of all futures :
		fcts.forEach_(_, function(_, fct) {
			fct(_);
		});

		instance.updateInProgress = false;
		tracer.debug && tracer.debug("applyUpdate(" + integrate + ") end");
	};
}

var htmlMap = {
	"&": "amp",
	"<": "lt",
	">": "gt",
	'"': 'quot',
	"'": '#39',
	"/": '#x2F',
	"à": "agrave",
	"â": "acirc",
	"é": "eacute",
	"è": "egrave",
	"ê": "ecirc",
	"ë": "euml",
	"î": "icirc",
	"ï": "iuml",
	"ô": "ocirc",
	"ù": "ugrave",
	"û": "ucirc",
	"ç": "ccedil",
	"€": "euro"
};

var regHtmlChars = new RegExp("[" + Object.keys(htmlMap).join('') + "]", "g");


function escapeHtml(string) {
	return String(string.replace(/\s+$/, "")).replace(regHtmlChars, function(s) {
		return '&' + htmlMap[s] + ';';
	});
}


function log2Html(_, log) {
	var src = ez.devices.buffer.reader(log);
	var lines = ez.transforms.lines;
	var errors = [];

	var html = '<!DOCTYPE HTML>' + '\n';
	html += '<HTML>' + '\n';
	html += '      <META HTTP-EQUIV="X-UA-Compatible" CONTENT="IE=9">' + '\n';
	html += '    <HEAD>' + '\n';
	html += '        <TITLE>log</TITLE>' + '\n';
	html += '            <META CHARSET="utf-8" />' + '\n';
	html += '            <META HTTP-EQUIV="X-UA-Compatible" CONTENT="IE=9">' + '\n';
	html += '            <Link REL="icon" HREF="/syracuse-ui/themes/desktop/images/site/favicon.ico" />' + '\n';
	html += '            <Link HREF="/syracuse-ui/themes/desktop/trace.css" REL="stylesheet"/>' + '\n';
	html += '      </HEAD>' + '\n';
	html += '    <BODY>' + '\n';
	var body = src.transform(lines.parser())
		.map(function() {
			var table;
			return function(_, log) {
				var html = "";
				if (/^#\<AdxVL\>@\(#\)%I%/.test(log) || /^=1000/.test(log)) {
					html = "";
				} else if (/^=0000 /.test(log)) {
					html = escapeHtml(log.substring(6));
				} else if (/^>/.test(log)) {
					html = '<p class="t-p-G' + log.substring(1, 5) + '">' + escapeHtml(log.substring(6));
				} else if (/^</.test(log)) {
					var error = escapeHtml(log.substring(6));
					errors.push(error);
					html = '<a id="error' + (errors.length) + '"><p class="t-p-L' + log.substring(1, 5) + '">' + error + ' </a><a href="#error' + (errors.length + 1) + '">' + locale.format(module, "nextError") + '</a></p><br/>';
				} else if (/^\+/.test(log)) {
					if (table === undefined) {
						table = "<table>";
						html = table;
					}
					//html += '<tr></tr>';
				} else if (/^[!\-\s]+$/.test(log)) {
					html = "";
				} else if (/^!/.test(log)) {
					html = "<tr>" + log.substring(1, log.length - 2).replace(/-/g, '').split('!').map(function(td) {
						return "<td>" + escapeHtml(td) + "</td>";
					}).join('') + "</tr>";
				} else {
					if (table !== undefined) {
						html += "</table>\n";
						table = undefined;
					}
					var paragraph = escapeHtml(log);
					html += (paragraph.length) ? '<p>' + paragraph + '</p>' : '<br/>';
				}
				return html;
			};
		}()).toArray(_).join('\n');

	html += '<p><h1>' + locale.format(module, "summary") + '</h1></p>' + '\n';
	if (errors.length) {
		for (var i = 0; i < errors.length; i++) {
			html += '<p><a href="#error' + (i + 1) + '">' + locale.format(module, "errorNo", (i + 1), errors[i]) + '</a></p>' + '\n';
		}
	}

	html += '<p><a href="#eof">' + locale.format(module, "eof") + '</a></p>' + '\n';
	html += body;
	html += '<a id="eof">' + locale.format(module, "eof") + '</a><br/>\n</BODY>\n</HTML>\n';
	return html;
}

var patchTypes = {
	X3: function(_, context, integrate, update, epToUpdate, patch) {
		var patchName = patch.name(_).toUpperCase();
		trackMessage(context, "info", locale.format(module, "applyX3Patch", patchName));


		function updateFolder(_, context, integrate, update, epToUpdate, patch, path, folder) {
			var updateChildren = true;
			var dependency = update.dependency(_);

			var applyPatch = false;

			if (dependency === folder.release(_)) {
				applyPatch = {
					version: update.version(_),
					folder: folder.name(_),
					directory: path,
					name: patch.name(_),
					integrate: integrate
				};
			} else if ((update.version(_) === folder.release(_)) && patch.mandatory(_) && (folder.patch(_) < patch.lastMaintenance(_))) {
				applyPatch = {
					version: update.version(_),
					folder: folder.name(_),
					directory: path,
					name: patch.name(_),
					integrate: integrate,
					statusMaintenance: 3,
					maintenance: folder.patch(_)
				};
			} else if ((update.version(_) === folder.release(_)) && !patch.mandatory(_)) {
				applyPatch = {
					version: update.version(_),
					folder: folder.name(_),
					directory: path,
					name: patch.name(_),
					integrate: integrate
				};
			} else {
				trackMessage(context, "warning", locale.format(module, "dependencyWarning", update.version(_), folder.name(_), folder.release(_)));
			}

			if (applyPatch) {
				updateChildren = false;
				trackMessage(context, "info", locale.format(module, "applyX3PatchTo", folder.name(_)));
				// Start the batch server in reserved mode (for patch only)
				startBatchServer(_, context, epToUpdate, true);


				var r = epToUpdate.endpoint(_).postService(_, "patch", applyPatch);

				if (r.head.status === 200) {
					var requestId = r.body.requestId;
					updateChildren = true;
					for (var i = 0; i < 36000; i++) {
						setTimeout(~_, 1000);

						var r = epToUpdate.endpoint(_).getService(_, "patch", {
							requestId: requestId,
							version: update.version(_),
							folder: folder.name(_),
							name: patch.name(_),
						});
						if (r && r.$diagnoses) {
							var done;
							r.$diagnoses.forEach(function(diag) {
								if (["success", "error"].indexOf(diag.$severity) >= 0) {
									done = diag;
									updateChildren = updateChildren && (diag.$severity === "success");
								}

								trackMessage(context, "info", diag.$message);
							});
							if (done) {
								tracer.debug && tracer.debug("done:" + done.$message);

								folder.status(_, done.$message);
								if (done.$severity === "success") folder.release(_, update.version(_));
								folder.updated(_, date.today());

								var sadfs = new SadFsqClient(_, epToUpdate.endpoint(_), null, null, false);
								var traceContents = sadfs.readFile(_, {
									path: r.trace
								}, {
									flag: "r",
									encoding: "utf-8"
								});

								traceContents = log2Html(_, traceContents);

								var writer = folder.trace(_).createWritableStream(_, {
									contentType: "x-trace",
									fileName: r.trace,
								});

								writer.write(_, traceContents, "binary");
								writer.write(_, null);

								// Save changes :
								update.save(_);
								break;
							}
						}
					}
				}
			}
			if (updateChildren) {
				tracer.debug && tracer.debug("updateChildren");
				updateFolders(_, context, integrate, update, epToUpdate, patch, path, folder.name(_));
			}
		}

		function updateFolders(_, context, integrate, update, epToUpdate, patch, path, parent) {
			parent = parent || "";
			tracer.debug && tracer.debug("updateFolders");
			var folders = epToUpdate.folders(_).toArray(_, true);

			var fcts = [];
			folders.forEach_(_, function(_, folder) {
				if (!folder.history(_) && parent === folder.parent(_)) {
					// Execute the update as a future
					fcts.push(updateFolder(!_, context, integrate, update, epToUpdate, patch, path, folder));
				}
			});
			// Wait for the execution of all futures :
			fcts.forEach_(_, function(_, fct) {
				fct(_);
			});
		}

		// First copy the patch on the server :
		var path = copyPatch(_, context, update, epToUpdate.endpoint(_), patch);
		//var path = "PATCH/X3V7_P3/FILPATCH";

		// Apply the patch
		updateFolders(_, context, integrate, update, epToUpdate, patch, path);

		// Save changes :
		update.save(_);

		// Start the batch server
		startBatchServer(_, context, epToUpdate);
		//tracer.debug &&  tracer.debug(JSON.stringify(res));  
	},
	IND: function(_, context, integrate, update, epToUpdate, patch) {
		var patchName = patch.name(_).toUpperCase();
		trackMessage(context, "info", locale.format(module, "applyIndPatch", patchName));

		// First copy the patch on the server :
		var path = copyPatch(_, context, update, epToUpdate.endpoint(_), patch);

		// Save changes :
		update.save(_);
		//tracer.debug &&  tracer.debug(JSON.stringify(res));  
	}
};

function findFolder(folder, name) {
	if (folder.name === name) return folder;
	if (folder.folders) {
		for (var i = 0; i < folder.folders.length; i++) {
			var found = findFolder(folder.folders[i], name);
			if (found) return found;
		}
	}
}

function startBatchServer(_, context, epToUpdate, reserved) {
	var endpoint = epToUpdate.endpoint(_);
	var status = endpoint.getService(_, "servBatch");
	tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));

	if (status.STOP === 1 && ((reserved && status.FLGPATCH === 2) || (!reserved && status.FLGPATCH === 1))) return;

	// Stop the server:
	trackMessage(context, "info", locale.format(module, "stopBatchServer"));
	tracer.debug && tracer.debug("stopBatch");
	endpoint.deleteService(_, "stopBatch");

	// Wait for the complete stop :
	for (var i = 0; i < 600; i++) {
		setTimeout(~_, 100);
		status = endpoint.getService(_, "servBatch");
		tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));
		if (status.STOP === 0) break;
		trackMessage(context, "info", locale.format(module, "batchServerStopping"));
	}

	// Start the server in the expected mode
	tracer.debug && tracer.debug("startBatch");
	trackMessage(context, "info", locale.format(module, "startBatchServer"));
	endpoint.postService(_, "startBatch", {
		flgpatch: (reserved || false)
	});

	status = endpoint.getService(_, "servBatch");
	trackMessage(context, "info", locale.format(module, "batchServerStarted"));
	tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));
}

// Update folders' information : 
function updateFoldersDesc(_, update, epToUpdate) {
	tracer.debug && tracer.debug("updateFoldersDesc");
	var foldersTree = epToUpdate.endpoint(_).getService(_, "foldersTree");
	tracer.debug && tracer.debug("updateFoldersDesc foldersTree:", foldersTree);

	epToUpdate.folders(_).toArray(_, true).forEach_(_, function(_, folder) {
		var found = findFolder(foldersTree, folder.name(_));
		if (found) {
			if (found.nump !== folder.patch(_)) {
				var folderDate = (found.dat === "00/00/0000") ? "01/01/1970" : found.dat;
				folder.updated(_, date.parse(folderDate, "dd/MM/yyyy"));
				folder.patch(_, found.nump);
				update.save(_);
			}
		}
	});
}


function updateEndpoint(_, context, integrate, update, epToUpdate, patches) {
	trackMessage(context, "info", locale.format(module, "updateEndpoint", epToUpdate.endpoint(_).description(_)));
	if (epToUpdate.folders(_).isEmpty()) return;

	// Get folders' descriptions before update
	updateFoldersDesc(_, update, epToUpdate);

	patches.forEach_(_, function(_, patch) {
		if (patch.apply(_)) {
			var type = patch.type(_);
			type && patchTypes[type] && patchTypes[type](_, context, integrate, update, epToUpdate, patch);
		} else {
			trackMessage(context, "info", locale.format(module, "doesntApplyPatch", patch.name(_).toUpperCase()));
		}
	});

	// Get folders' descriptions after update
	updateFoldersDesc(_, update, epToUpdate);
}

function scheduled(_, instance) {
	var db = adminHelper.getCollaborationOrm(_);
	return db.fetchInstances(_, db.getEntity(_, "eventTime"), {
		jsonWhere: {
			"parameters.update": instance.$uuid
		}
	});
}

function unschedule(_, instance) {
	var db = adminHelper.getCollaborationOrm(_);
	scheduled(_, instance).forEach_(_, function(_, evt) {
		db.deleteInstance(_, evt);
	});
	instance.scheduled(_, "");
	instance.save(_);
}

exports.entity = {
	$isPersistent: true,
	$canSave: true,
	$titleTemplate: "Update management",
	$descriptionTemplate: "Update management",
	$helpPage: "Administration-reference_Updates",
	$valueTemplate: "{name}",
	$properties: {
		file: {
			$title: "Update",
			$type: "binary",
			$storage: "db_file",
			$propagate: function(_, instance, file) {
				instance.fsName(_, file.fsName);
			},
			$uploadDone: function(_, instance) {
				var store = instance.file(_);

				if (store.fileExists(_)) {
					var props = store.getProperties(_);

					var root = props.fileName.substring(0, props.fileName.lastIndexOf('.')) + "/";

					var zip = store.createReadableStream(_).readAll(_);
					new unzip.Unzip(
						zip,
						function(filename, filecontent, headers, _) {
							try {
								var contents = JSON.parse(filecontent.toString('utf8'));
								instance.name(_, contents.name);
								instance.version(_, contents.version);
								instance.dependency(_, contents.dependency);
								instance.description(_, contents.description);
								instance.patches(_).reset(_);
								contents.patches.forEach_(_, function(_, p) {
									var patch = instance.patches(_).add(_);
									patch.name(_, p.name);
									patch.type(_, p.type);
									patch.description(_, p.description);
									patch.path(_, p.path);
									patch.mandatory(_, p.mandatory || false);
									patch.firstMaintenance(_, 0);
									patch.lastMaintenance(_, 0);
									patch.apply(_, true);
								});
							} catch (e) {}
						}, {
							filter: function(filename, headers, _) {
								return filename.toLowerCase().substring(root.length) == "update.json";
							}
						}).unzip(_);
				}
			}
		},
		name: {
			$title: "Name",
			$isDisabled: true
		},
		version: {
			$title: "Version",
			$isDisabled: true
		},
		dependency: {
			$title: "Dependency",
			$isDisabled: true
		},
		description: {
			$title: "description",
			$isDisabled: true
		},
		fsName: {
			$title: "fsName",
			$isDisabled: true,
			$isHidden: true,
		},
		scheduled: {
			$title: "Scheduled",
			$isDisabled: true
		}
	},
	$relations: {
		patches: {
			$title: "Patches",
			$type: "updatePatches",
			$inv: "update",
			$isChild: true,
			$isDisabled: true,
			$capabilities: ""
		},
		endpoints: {
			$title: "Apply to endpoints",
			$type: "epToUpdates",
			$inv: "update",
			$isChild: true,
			$isDisabled: false,
			$capabilities: "delete",
			$select: {
				$title: "Endpoints",
				$type: "endPoint", // "lookupRepresentation",
				$fieldMap: {
					endpoint: "$uuid"
				}
			},

		}
	},
	$functions: {
		isDisabled: function(_, instance) {
			return instance.name(_) === undefined || instance.endpoints(_).isEmpty();
		},
		fire: function(_, key, parameters) {
			tracer.debug && tracer.debug("event start");

			var session = globals.context.session;
			if (!session) {
				var db = adminHelper.getCollaborationOrm(_);
				var user = db.fetchInstance(_, db.getEntity(_, "user"), parameters.user);
				var role = db.fetchInstance(_, db.getEntity(_, "role"), parameters.role);
				var locale = db.fetchInstance(_, db.getEntity(_, "localePreference"), parameters.locale);

				if (user && role && locale) {
					var diagnoses = [];
					tracer.debug && tracer.debug("createBatchSession");
					session = sessionManager.createBatchSession(_, user, role, locale, diagnoses);
				}
			}

			if (session) applyUpdate(true)(_, null, this);
			tracer.debug && tracer.debug("event end");
		}
	},
	$services: {
		test: {
			$method: "POST",
			$title: "Test update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$isDisabled: function(_, instance) {
				return instance.isDisabled(_, instance);
			},
			$execute: applyUpdate(false)
		},
		apply: {
			$method: "POST",
			$title: "Apply update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$isDisabled: function(_, instance) {
				return instance.isDisabled(_, instance);
			},
			$execute: applyUpdate(true)
		},
		refresh: {
			$method: "POST",
			$isMethod: true,
			$title: "refresh",
			$execute: function(_, context, instance) {}
		},
		schedule: {
			$method: "POST",
			$title: "Schedule update",
			$isMethod: true,
			$parameters: {
				//executionDate: null,
				$properties: {
					executionDate: {
						$title: "Execution date",
						$description: "Desired patch application date",
						$type: "application/x-date"
					},
					executionTime: {
						$title: "Execution time",
						$description: "Desired patch application time",
						$type: "application/x-time"
					}
				}
			},
			//			$urlParameters: "scheduler={schedulerId}",
			$execute: function(_, context, instance, parameters) {
				if (!parameters.executionDate || !parameters.executionTime) {
					instance.$addError(locale.format(module, "scheduleParameters"));
					return;
				}

				var dtm = datetime.parse(parameters.executionDate + "T" + parameters.executionTime);
				//console.log("execution date:"+dtm);
				var up = context.getUserProfile(_);
				if (up) {
					// First delete any task that could have been scheduled for this update
					unschedule(_, instance);

					instance.scheduled(_, locale.format(module, "scheduleAt", parameters.executionDate, parameters.executionTime));
					instance.save(_);

					scheduler.schedule(_, instance, instance.$uuid, dtm, {
						"user": up.user(_) && up.user(_).$uuid,
						"role": up.selectedRole(_) && up.selectedRole(_).$uuid,
						"locale": up.selectedLocale(_) && up.selectedLocale(_).$uuid,
						"update": instance.$uuid
					}, "db");
				}
			}
		},
		unschedule: {
			$method: "POST",
			$isMethod: true,
			$title: "Unschedule update",

			$isDisabled: function(_, instance) {
				return !scheduled(_, instance).length;
			},

			$execute: function(_, context, instance) {
				unschedule(_, instance);
			}
		},
	}
};