"use strict";

var globals = require('streamline/lib/globals');
var mongodb = require('streamline-mongodb');
var unzip = require('streamline-zip/lib/unzip/unzip');
var ez = require('ez-streams');


var locale = require("syracuse-core/lib/locale");
var sadFsq = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient');
var SadFsqClient = sadFsq.SadFsqClient;

var tracer = require('syracuse-trace/lib/helper').getTracer('patch');

var config = require('config'); // must be first syracuse require

function track(t, msg) {
	t.phaseDetail = msg;
	tracer.debug && tracer.debug(msg);
}

function copyPatch(_, context, update, endpoint, patch) {
	var t = context && context.tracker;
	var x3server = endpoint.x3server(_);

	var sadfs = new SadFsqClient(_, x3server.serverHost(_), x3server.serverPort(_), null, null, false);

	var path = "PATCH/" + patch.path(_);
	track(t, "Copy patch to " + path);


	track(t, "Clean-up " + path);
	var rep = sadfs.rmdir(_, {
		folder: endpoint.x3ServerFolder(_),
		path: path,
	});

	track(t, "Copy files to " + path);

	var options = {
		folder: endpoint.x3ServerFolder(_),
		path: "",
	};
	path.split('/').forEach_(_, function(_, subdir) {
		options.path += subdir;
		track(t, "mkdir " + options.path);
		var rep = sadfs.mkdir(_, options);
		track(t, "rep " + rep);
		options.path += "/";
	});

	var store = update.update(_);

	if (store.fileExists(_)) {
		var props = store.getProperties(_);
		var root = (props.fileName.substring(0, props.fileName.indexOf('.')) + "/" + patch.path(_) + "/").toUpperCase();

		var zip = store.createReadableStream(_).readAll(_);
		new unzip.Unzip(
			zip,
			function(filename, filecontent, headers, _) {
				try {
					var fname = filename.substring(filename.lastIndexOf('/') + 1);
					var fileOptions = {
						folder: endpoint.x3ServerFolder(_),
						path: options.path + fname
					};
					track(t, "Copy file " + fname);

					sadfs.writeFile(_, fileOptions, filecontent, {
						flag: "w"
					});
				} catch (e) {}
			}, {
				filter: function(filename, headers, _) {
					return filename.toUpperCase().substring(0, root.length) == root;
				}
			}).unzip(_);
	}
}

var patchTypes = {
	X3: function(_, context, update, endpoint, patch) {
		var t = context && context.tracker;
		var patchName = patch.name(_).toUpperCase();
		track(t, "Apply X3 patch " + patchName);

		// First copy the patch on the server :
		copyPatch(_, context, update, endpoint, patch);
	},
	IND: function(_, context, update, endpoint, patch) {
		var t = context && context.tracker;
		var patchName = patch.name(_).toUpperCase();
		track(t, "Apply IND patch " + patchName);

		// First copy the patch on the server :
		copyPatch(_, context, update, endpoint, patch);
	}
};

function updateEndpoint(_, context, update, endpoint, patches) {
	var t = context && context.tracker;
	if (t) {
		t.phase = "Update " + endpoint.description(_);
		track(t, "Update " + endpoint.description(_));

		patches.forEach_(_, function(_, patch) {
			if (patch.apply(_)) {
				var type = patch.type(_);
				type && patchTypes[type] && patchTypes[type](_, context, update, endpoint, patch);
			} else {
				track(t, "Don't apply patch " + patch.name(_).toUpperCase());
			}
		});
	}
}

exports.entity = {
	$isPersistent: true,
	$canSave: true,
	$titleTemplate: "Update management",
	$descriptionTemplate: "Update management",
	$helpPage: "Update_management",
	$properties: {
		update: {
			$title: "Update",
			$type: "binary",
			$storage: "db_file",
			$propagate: function(_, instance, file) {
				instance.fsName(_, file.fsName);
			},
			$uploadDone: function(_, instance) {
				var store = instance.update(_);

				if (store.fileExists(_)) {
					var props = store.getProperties(_);

					var root = props.fileName.substring(0, props.fileName.indexOf('.')) + "/";

					var zip = store.createReadableStream(_).readAll(_);
					new unzip.Unzip(
						zip,
						function(filename, filecontent, headers, _) {
							try {
								var contents = JSON.parse(filecontent.toString('utf8'));
								instance.name(_, contents.name);
								instance.version(_, contents.version);
								instance.description(_, contents.description);
								contents.patches.forEach_(_, function(_, p) {
									var patch = instance.patches(_).add(_);
									patch.name(_, p.name);
									patch.type(_, p.type);
									patch.description(_, p.description);
									patch.path(_, p.path);
									patch.mandatory(_, p.mandatory || false);
									patch.apply(_, true);
								});
							} catch (e) {}
						}, {
							filter: function(filename, headers, _) {
								return filename.toLowerCase().substring(root.length) == "update.json";
							}
						}).unzip(_);
				}
			}
		},
		name: {
			$title: "Name",
			$isDisabled: true
		},
		version: {
			$title: "Version",
			$isDisabled: true
		},
		description: {
			$title: "description",
			$isDisabled: true
		},
		fsName: {
			$title: "fsName",
			$isDisabled: true,
			$isHidden: true,
		},

	},
	$relations: {
		patches: {
			$title: "Patches",
			$type: "updatePatches",
			$inv: "update",
			$isChild: true,
			$isDisabled: true
		},
		endpoints: {
			$title: "Apply to endpoints",
			$type: "epToUpdates",
			$inv: "update",
			$isChild: true,
			$isDisabled: false
		}
	},
	$init: function(_, instance) {},
	$functions: {
		apply: function(_, diags, tracker) {},

	},
	$services: {
		apply: {
			$method: "POST",
			$title: "Apply update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$isDisabled: function(_, instance) {
				return false; //instance.updateInProgress;
			},
			$execute: function(_, context, instance) {
				instance.updateInProgress = true;

				var endpoints = instance.endpoints(_);
				var patches = instance.patches(_).toArray(_, true);
				endpoints.toArray(_, true).forEach_(_, function(_, iep) {
					updateEndpoint(_, context, instance, iep.endpoint(_), patches);
				});
				instance.updateInProgress = false;
			}
		},
	}
};