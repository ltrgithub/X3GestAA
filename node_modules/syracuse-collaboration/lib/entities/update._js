"use strict";

var globals = require('streamline/lib/globals');
var mongodb = require('streamline-mongodb');
var unzip = require('streamline-zip/lib/unzip/unzip');
var ez = require('ez-streams');


var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var sadFsq = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient');
var SadFsqClient = sadFsq.SadFsqClient;

var tracer = require('syracuse-trace/lib/helper').getTracer('patch');

var config = require('config'); // must be first syracuse require

function track(context, phaseDetail, message) {
	var t = context.tracker;
	if (t) {
		t.phaseDetail = phaseDetail;
		tracer.debug && tracer.debug(phaseDetail + (message ? " - " + message : ""));
		if (message) {
			t.$diagnoses = t.$diagnoses || [];
			t.$diagnoses.push({
				$severity: "info",
				$message: message
			});
		}
	}
}

function copyPatch(_, context, update, endpoint, patch) {
	var x3server = endpoint.x3server(_);
	var path = "PATCH/" + patch.path(_);
	track(context, "Copy patch to " + path);

	var sadfs = new SadFsqClient(_, x3server.serverHost(_), x3server.serverPort(_), null, null, false);
	var x3Files = [];
	var refFiles = [];
	try {
		var lsadx = sadfs.readdir(_, {
			folder: endpoint.x3ServerFolder(_),
			path: path,
		});

		lsadx.forEach(function(file) {
			x3Files.push(file);
			//dbg:console.log("x3 file:"+file);
		});
	} catch (e) {

	}

	var store = update.update(_);

	if (store.fileExists(_)) {
		var props = store.getProperties(_);
		var root = (props.fileName.substring(0, props.fileName.indexOf('.')) + "/" + patch.path(_) + "/").toUpperCase();

		var zip = store.createReadableStream(_).readAll(_);
		var total = 0;

		var patchFiles = new unzip.Unzip(
			zip,
			function(filename, filecontent, headers, _) {
				try {
					var fname = filename.substring(filename.lastIndexOf('/') + 1);
					var fileOptions = {
						folder: endpoint.x3ServerFolder(_),
						path: options.path + fname
					};
					track(context, "Files copy", "Copy file " + fname);

					sadfs.writeFile(_, fileOptions, filecontent, {
						flag: "w"
					});
				} catch (e) {}
			}, {
				filter: function(filename, headers, _) {
					var keep = (filename.toUpperCase().substring(0, root.length) === root);
					if (keep) {
						var file = filename.toUpperCase().substring(1 + filename.lastIndexOf('/'));
						if (file.length) {
							// Doesn't copy file present on the X3 folder :
							refFiles.push(file);
							keep = !x3Files.some(function(x3File) {
								return x3File.toUpperCase() === file;
							});
							//dbg:if(!keep) console.log("doesn't copy "+file);
						} else {
							keep = false;
						}
					}
					return keep;
				}
			});
		var zipFiles = patchFiles.list(_);
		total = zipFiles.length;

		// Remove files which aren't supposed to be there :
		track(context, "Clean up");
		x3Files
			.filter(function(file) {
				var uFile = file.toUpperCase();
				return !refFiles.some(function(refFile) {
					return refFile === uFile;
				});
			})
			.forEach_(_, function(_, file) {
				track(context, "unlink file '" + (path + "/" + file) + "'");
				sadfs.unlink(_, {
					folder: endpoint.x3ServerFolder(_),
					path: path,
					name: file,
				});
			});


		track(context, "Copy files to " + path);
		var options = {
			folder: endpoint.x3ServerFolder(_),
			path: "",
		};
		path.split('/').forEach_(_, function(_, subdir) {
			options.path += subdir;
			track(context, "mkdir " + options.path);
			var rep = sadfs.mkdir(_, options);
			track(context, "rep " + rep);
			options.path += "/";
		});

		patchFiles.unzip(_);

		return path;
	}
}

function applyUpdate(integrate) {
	return function(_, context, instance) {
		instance.updateInProgress = true;
		var endpoints = instance.endpoints(_);
		var patches = instance.patches(_).toArray(_, true);
		endpoints.toArray(_, true).forEach_(_, function(_, epToUpdate) {
			updateEndpoint(_, context, integrate, instance, epToUpdate, patches);
		});
		instance.updateInProgress = false;
	};
}


var patchTypes = {
	X3: function(_, context, integrate, update, epToUpdate, patch) {
		var patchName = patch.name(_).toUpperCase();
		track(context, "Apply X3 patch " + patchName);


		function updateFolder(_, context, integrate, update, epToUpdate, patchName, path, folder) {
			var updateChildren = true;
			var dependency = update.dependency(_);

			if (dependency === folder.update(_)) {
				updateChildren = false;
				track(context, "Apply X3 patch to " + folder.name(_));

				var r = epToUpdate.endpoint(_).postService(_, "patch", {
					version: update.version(_),
					folder: folder.name(_),
					directory: path,
					name: patchName,
					integrate: integrate
				});

				if (r.head.status === 200) {
					updateChildren = true;
					for (var i = 0; i < 36000; i++) {
						setTimeout(~_, 1000);
						var r = epToUpdate.endpoint(_).getService(_, "patch", {
							version: update.version(_),
							folder: folder.name(_),
							name: patchName,
						});
						if (r && r.diagnoses) {
							var done;
							r.diagnoses.forEach(function(diag) {
								if (["success", "error"].indexOf(diag.$severity) >= 0) {
									done = diag;
								}
								updateChildren = updateChildren && (diag.$severity === "success");
								track(context, diag.$message);
							});
							if (done) {
								folder.status(_, done.$severity);
								folder.update(_, r.update);
								folder.updated(_, datetime.now());
								console.log(JSON.stringify(done.$links.$trace));
								if (done.$links && done.$links.$trace) {
									console.log("URL:" + done.$links.$trace.$url);
									folder.trace(_, done.$links.$trace.$url);
								}
								break;
							}
						}
					}
				}
			}
			if (updateChildren) {
				updateFolders(_, context, integrate, update, epToUpdate, patchName, path, folder.name(_));
			}
		}

		function updateFolders(_, context, integrate, update, epToUpdate, patchName, path, parent) {
			parent = parent || "";

			var folders = epToUpdate.folders(_).toArray(_, true);
			var fcts = [];
			folders.forEach_(_, function(_, folder) {
				if (!folder.history(_) && parent === folder.parent(_)) {
					// Execute the update as a future
					fcts.push(updateFolder(!_, context, integrate, update, epToUpdate, patchName, path, folder));
				}
			});
			// Wait for the execution of all futures :
			fcts.forEach_(_, function(_, fct) {
				fct(_);
			});
		}

		// First copy the patch on the server :
		var path = copyPatch(_, context, update, epToUpdate.endpoint(_), patch);
		//var path = "PATCH/X3V7_P3/FILPATCH";

		// Apply the patch
		updateFolders(_, context, integrate, update, epToUpdate, patch.name(_), path);

		// Save changes :
		update.save(_);

	},
	IND: function(_, context, integrate, update, epToUpdate, patch) {
		var patchName = patch.name(_).toUpperCase();
		track(context, "Apply IND patch " + patchName);

		// First copy the patch on the server :
		var path = copyPatch(_, context, update, epToUpdate.endpoint(_), patch);

		// Save changes :
		update.save(_);
	}
};

function updateEndpoint(_, context, integrate, update, epToUpdate, patches) {
	var t = context && context.tracker;
	if (t) {
		t.phase = "Update " + epToUpdate.endpoint(_).description(_);
		track(context, t.phase);

		patches.forEach_(_, function(_, patch) {
			if (patch.apply(_)) {
				var type = patch.type(_);
				type && patchTypes[type] && patchTypes[type](_, context, integrate, update, epToUpdate, patch);
			} else {
				track(context, "Don't apply patch " + patch.name(_).toUpperCase());
			}
		});
	}
}

exports.entity = {
	$isPersistent: true,
	$canSave: true,
	$titleTemplate: "Update management",
	$descriptionTemplate: "Update management",
	$helpPage: "Update_management",
	$properties: {
		update: {
			$title: "Update",
			$type: "binary",
			$storage: "db_file",
			$propagate: function(_, instance, file) {
				instance.fsName(_, file.fsName);
			},
			$uploadDone: function(_, instance) {
				var store = instance.update(_);

				if (store.fileExists(_)) {
					var props = store.getProperties(_);

					var root = props.fileName.substring(0, props.fileName.indexOf('.')) + "/";

					var zip = store.createReadableStream(_).readAll(_);
					new unzip.Unzip(
						zip,
						function(filename, filecontent, headers, _) {
							try {
								var contents = JSON.parse(filecontent.toString('utf8'));
								instance.name(_, contents.name);
								instance.version(_, contents.version);
								instance.dependency(_, contents.dependency);
								instance.description(_, contents.description);
								contents.patches.forEach_(_, function(_, p) {
									var patch = instance.patches(_).add(_);
									patch.name(_, p.name);
									patch.type(_, p.type);
									patch.description(_, p.description);
									patch.path(_, p.path);
									patch.mandatory(_, p.mandatory || false);
									patch.apply(_, true);
								});
							} catch (e) {}
						}, {
							filter: function(filename, headers, _) {
								return filename.toLowerCase().substring(root.length) == "update.json";
							}
						}).unzip(_);
				}
			}
		},
		name: {
			$title: "Name",
			$isDisabled: true
		},
		version: {
			$title: "Version",
			$isDisabled: true
		},
		dependency: {
			$title: "Dependency",
			$isDisabled: true
		},
		description: {
			$title: "description",
			$isDisabled: true
		},
		fsName: {
			$title: "fsName",
			$isDisabled: true,
			$isHidden: true,
		},

	},
	$relations: {
		patches: {
			$title: "Patches",
			$type: "updatePatches",
			$inv: "update",
			$isChild: true,
			$isDisabled: true
		},
		endpoints: {
			$title: "Apply to endpoints",
			$type: "epToUpdates",
			$inv: "update",
			$isChild: true,
			$isDisabled: false
		}
	},
	$init: function(_, instance) {},
	$functions: {
		apply: function(_, diags, tracker) {},

	},
	$services: {
		test: {
			$method: "POST",
			$title: "Test update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$isDisabled: function(_, instance) {
				return false; //instance.updateInProgress;
			},
			$execute: applyUpdate(false)
		},
		apply: {
			$method: "POST",
			$title: "Apply update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$isDisabled: function(_, instance) {
				return false; //instance.updateInProgress;
			},
			$execute: applyUpdate(true)
		},
		refresh: {
			$method: "POST",
			$isMethod: true,
			$title: "refresh",
			$execute: function(_, context, instance) {}
		},
	}
};