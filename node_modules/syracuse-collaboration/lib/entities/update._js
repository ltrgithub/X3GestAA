"use strict";

var globals = require('streamline/lib/globals');

var unzip = require('streamline-zip/lib/unzip/unzip');
var ez = require('ez-streams');
var fs = require('streamline-fs');

var locale = require("syracuse-core/lib/locale");
var date = require("syracuse-core/lib/types/date");
var datetime = require("syracuse-core/lib/types/datetime");
var uuid = require("syracuse-core/lib/uuid");
var scheduler = require("syracuse-event/lib/scheduler");

var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var sadFsq = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient');
var SadFsqClient = sadFsq.SadFsqClient;

var scheduler = require("syracuse-event/lib/scheduler");
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var tracer = require('syracuse-trace/lib/helper').getTracer('patch');

var config = require('config'); // must be first syracuse require

exports.$exported = true;

function trackMessage(context, severity, message) {
	switch (severity) {
		case "error":
			tracer.error && tracer.error(message);
			break;
		case "info":
			tracer.info && tracer.info(message);
			break;
		default:
			tracer.debug && tracer.debug(message);
			break;
	}

	var t = context && context.tracker;
	if (t) {
		//t.phaseDetail = t.phaseDetail;
		t.$diagnoses = t.$diagnoses || [];
		t.$diagnoses.push({
			$severity: severity,
			$message: message
		});
	}
}

function copyPatch(_, context, update, endpoint, patch) {
	var path = "PATCH/" + patch.path(_);
	trackMessage(context, "info", locale.format(module, "copyPatchTo", path));

	var sadfs = new SadFsqClient(_, endpoint, null, null, false);
	var x3Files = [];
	var refFiles = [];
	try {
		var lsadx = sadfs.readdir(_, {
			folder: endpoint.x3ServerFolder(_),
			path: path,
		});

		lsadx.forEach(function(file) {
			if (!/Error 20$/.test(file)) x3Files.push(file);
		});
	} catch (e) {

	}

	var store = update.file(_);

	if (store.fileExists(_)) {
		var props = store.getProperties(_);
		var root = (props.fileName.substring(0, props.fileName.lastIndexOf('.')) + "/" + patch.path(_) + "/").toUpperCase();

		var zip = store.createReadableStream(_).readAll(_);
		var total = 0;

		var firstMaintenance = 0;
		var lastMaintenance = 0;

		var patchFiles = new unzip.Unzip(
			zip,
			function(filename, filecontent, headers, _) {
				var fname = filename.substring(filename.lastIndexOf('/') + 1);
				var fileOptions = {
					folder: endpoint.x3ServerFolder(_),
					path: options.path + fname
				};
				trackMessage(context, "info", locale.format(module, "copyFile", fname));

				for (var i = 0; i < 3; i++) {
					try {
						sadfs.writeFile(_, fileOptions, filecontent, {
							flag: "w+"
						});
						if (sadfs.stat(_, fileOptions, ["size"]).size > 0) break;
						// Retry a copy if the previous ended with a o size file:
						tracer.error && tracer.error("sadfs.writeFile(" + fileOptions.path + ") failed");
					} catch (e) {
						tracer.error && tracer.error("exception in sadfs.writeFile:" + e.stack);
					}
					try {
						sadfs.unlink(_, fileOptions);
					} catch (e) {
						tracer.error && tracer.error("exception in sadfs.unlink:" + e.stack);
					}
				}
			}, {
				filter: function(filename, headers, _) {
					var keep = (filename.toUpperCase().substring(0, root.length) === root);
					if (keep) {

						var file = filename.toUpperCase().substring(1 + filename.lastIndexOf('/'));
						if (file.length) {
							var match = file.match(/[A-Z]*_(\d*)_\d*\.\w{3}/);
							if (match) {
								var maintenance = parseInt(match[1]);
								firstMaintenance = (firstMaintenance) ? Math.min(maintenance, firstMaintenance) : maintenance;
								lastMaintenance = (lastMaintenance) ? Math.max(maintenance, lastMaintenance) : maintenance;
							}

							// Doesn't copy file present on the X3 folder :
							refFiles.push(file);
							keep = !x3Files.some(function(x3File) {
								return x3File.toUpperCase() === file;
							});
						} else {
							keep = false;
						}
					}
					return keep;
				}
			});

		var zipFiles = patchFiles.list(_);
		total = zipFiles.length;

		// Remove files which aren't supposed to be there :
		trackMessage(context, "info", locale.format(module, "cleanUp"));
		x3Files
			.filter(function(file) {
				var uFile = file.toUpperCase();
				return !refFiles.some(function(refFile) {
					return refFile === uFile;
				});
			})
			.forEach_(_, function(_, file) {
				try {
					trackMessage(context, "info", locale.format(module, "unlinkFile", path, file));
					sadfs.unlink(_, {
						folder: endpoint.x3ServerFolder(_),
						path: path,
						name: file,
					});
				} catch (e) {}
			});


		trackMessage(context, "info", locale.format(module, "copyFilesTo", path));
		var options = {
			folder: endpoint.x3ServerFolder(_),
			path: "",
		};
		path.split('/').forEach_(_, function(_, subdir) {
			options.path += subdir;
			trackMessage(context, "info", locale.format(module, "mkdir", options.path));
			var rep = sadfs.mkdir(_, options);
			options.path += "/";
		});

		patchFiles.unzip(_);

		patch.firstMaintenance(_, firstMaintenance);
		patch.lastMaintenance(_, lastMaintenance);
		return path;
	}
}

function applyUpdate(integrate) {
	return function(_, context, instance) {
		tracer.debug && tracer.debug("applyUpdate(" + integrate + ")");
		instance.updateInProgress = true;
		var endpoints = instance.endpoints(_);
		var patches = instance.patches(_).toArray(_, true);
		var fcts = [];

		if (context && context.tracker) context.tracker.phaseDetail = locale.format(module, "phase" + (integrate ? "Apply" : "Test"));

		instance.status(_, "");


		endpoints.toArray(_, true).forEach_(_, function(_, epToUpdate) {
			fcts.push(updateEndpoint(!_, context, integrate, instance, epToUpdate, patches));
		});

		// Wait for the execution of all futures :
		fcts.forEach_(_, function(_, fct) {
			fct(_);
		});

		// Set a global status:
		var status = "updateSuccess";
		endpoints.toArray(_, true).forEach_(_, function(_, epToUpdate) {
			var folders = epToUpdate.folders(_).toArray(_, true);
			folders.forEach_(_, function(_, folder) {
				var folderStatus = folder.status(_);
				if (folderStatus !== "success") {
					status = "updateFailed";
				}
			});
		});
		instance.status(_, locale.format(module, status));
		trackMessage(context, (status === "updateSuccess" ? "success" : "error"), locale.format(module, status));
		instance.save(_);

		instance.updateInProgress = false;
		tracer.debug && tracer.debug("applyUpdate(" + integrate + ") end");
	};
}

var htmlMap = {
	"&": "amp",
	"<": "lt",
	">": "gt",
	'"': 'quot',
	"'": '#39',
	"/": '#x2F',
	"à": "agrave",
	"â": "acirc",
	"é": "eacute",
	"è": "egrave",
	"ê": "ecirc",
	"ë": "euml",
	"î": "icirc",
	"ï": "iuml",
	"ô": "ocirc",
	"ù": "ugrave",
	"û": "ucirc",
	"ç": "ccedil",
	"€": "euro"
};

var regHtmlChars = new RegExp("[" + Object.keys(htmlMap).join('') + "]", "g");


function escapeHtml(string) {
	return String(string.replace(/\s+$/, "").replace(/^\s+/, "")).replace(regHtmlChars, function(s) {
		return '&' + htmlMap[s] + ';';
	});
}


function log2Html(_, title, log, html, diagnoses) {
	var src = ez.devices.buffer.reader(log);
	var lines = ez.transforms.lines;
	var errors = [];

	var nextError = "";

	if (html) {
		html = html.substring(0, html.lastIndexOf("</BODY>"));
	} else {
		html = '<!DOCTYPE HTML>' + '\n';
		html += '<HTML>' + '\n';
		html += '      <META HTTP-EQUIV="X-UA-Compatible" CONTENT="IE=9"/>' + '\n';
		html += '    <HEAD>' + '\n';
		html += '        <TITLE>log</TITLE>' + '\n';
		html += '            <META CHARSET="utf-8" />' + '\n';
		html += '            <META HTTP-EQUIV="X-UA-Compatible" CONTENT="IE=9"/>' + '\n';
		html += '            <Link REL="icon" HREF="/syracuse-ui/themes/desktop/images/site/favicon.ico" />' + '\n';
		html += '            <Link HREF="/syracuse-ui/themes/desktop/trace.css" REL="stylesheet"/>' + '\n';
		html += '      </HEAD>' + '\n';
		html += '    <BODY>' + '\n';
	}
	var isFile = (log.indexOf('\n') !== -1);

	var body = src.transform(lines.parser())
		.map(function() {
			var table;
			return function(_, log) {
				var html = "";
				if (/^#\<AdxVL\>@\(#\)%I%/.test(log) || /^=1000/.test(log)) {
					html = "";
				} else if (/^=0000 /.test(log)) {
					html = "<p>" + escapeHtml(log.substring(6)) + "</p>";
				} else if (/^>/.test(log)) {
					html = '<p class="t-p-G' + log.substring(1, 5) + '">' + escapeHtml(log.substring(6));
				} else if (/^</.test(log)) {
					var error = log.substring(6);
					diagnoses.push({
						$severity: "error",
						$message: error
					});
					error = escapeHtml(log.substring(6));
					errors.push(error);

					if (isFile) html = '<a id="error' + nextError + '">';
					html += '<p class="t-p-L' + log.substring(1, 5) + '">' + error;
					if (isFile) {
						html += '</a>';
						nextError = uuid.generate('').toString();
						html += '<a href="#error' + nextError + '">' + locale.format(module, "nextError") + '</a>';
					}
					html += '</p><br/>';
				} else if (/^\+-\w+/.test(log)) {
					var match = log.match(/^\+-(\w+)/);
					if (match && match[1]) html = "<b>" + match[1] + "</b><br/>";

					html += table ? "</table>\n<br/>\n" : "";
					table = "<table>";
					html += table;
				} else if (/^\+-/.test(log)) {
					html = table ? "</table>\n<br/>\n" : "";
					table = undefined;
				} else if (/^[!\-\s]+$/.test(log)) {
					html = "";
				} else if (/^!/.test(log)) {
					html = "";
					if (!table) {
						table = "<table>";
						html = table;
					}
					log = log.substring(1, log.length - 2);
					var lastI = log.lastIndexOf('!');
					if (lastI > 0) log = log.substring(0, lastI);
					html += "<tr>" + log.replace(/-/g, '').split('!').map(function(td) {
						return "<td>" + escapeHtml(td) + "</td>";
					}).join('') + "</tr>";
				} else {
					if (table) {
						html += "</table>\n";
						table = undefined;
					}
					var paragraph = escapeHtml(log);
					html += (paragraph.length) ? '<p>' + paragraph + '</p>' : '<br/>';
				}
				return html;
			};
		}()).toArray(_).join('\n');

	//html += '<p><h1>' + locale.format(module, "summary") + '</h1></p>' + '\n';
	html += '<p><h1>' + title + ' - ' + (new Date()).toLocaleString() + '</h1></p>' + '\n';
	if (errors.length && isFile) {
		for (var i = 0; i < errors.length; i++) {
			html += '<p><a href="#error' + (i + 1) + '">' + locale.format(module, "errorNo", (i + 1), errors[i]) + '</a></p>' + '\n';
		}
	}

	if (isFile) {
		var eof = uuid.generate('').toString();
		html += '<p><a href="#' + eof + '">' + locale.format(module, "eof") + '</a></p>\n';
	}
	html += body;
	if (isFile) {
		html += '<a id="' + eof + '">' + locale.format(module, "eof") + '</a><br/>\n';
	}
	html += '\n</BODY>\n</HTML>\n';
	return html;
}

function updateTrace(_, context, folder, title, contents) {
	var htmlContents = "";
	var trace = folder.trace(_);
	if (trace.fileExists(_)) {
		htmlContents = trace.createReadableStream(_).readAll(_).toString("utf8");
	}
	var diagnoses = [];
	htmlContents += log2Html(_, title, contents, htmlContents, diagnoses);

	diagnoses.forEach_(_, function(_, diagnose) {
		trackMessage(context, diagnose.$severity, diagnose.$message);
	});

	var writer = folder.trace(_).createWritableStream(_, {
		contentType: "x-trace",
		fileName: title,
	});
	writer.write(_, htmlContents, "binary");
	writer.write(_, null);
}

function updateFolder(_, context, integrate, update, epToUpdate, patch, path, folder) {
	var updateChildren = true;
	var traceTitle = patch.name(_);
	var dependency = update.dependency(_);

	var applyPatch = false;

	if (dependency === folder.release(_)) {
		applyPatch = {
			version: update.version(_),
			folder: folder.name(_),
			directory: path,
			name: patch.name(_),
			integrate: integrate
		};
	} else if ((update.version(_) === folder.release(_)) && patch.mandatory(_) && (folder.patch(_) < patch.lastMaintenance(_))) {
		applyPatch = {
			version: update.version(_),
			folder: folder.name(_),
			directory: path,


			name: patch.name(_),
			integrate: integrate,
			statusMaintenance: 3,
			maintenance: folder.patch(_)
		};
	} else if ((update.version(_) === folder.release(_)) && !patch.mandatory(_)) {
		applyPatch = {
			version: update.version(_),
			folder: folder.name(_),
			directory: path,
			name: patch.name(_),
			integrate: integrate
		};
	} else {
		var warning = locale.format(module, "dependencyWarning", update.version(_), folder.name(_), folder.release(_));
		trackMessage(context, "warning", warning);
		updateTrace(_, context, folder, traceTitle, "<0003>" + warning);
	}

	if (applyPatch) {
		updateChildren = false;
		trackMessage(context, "info", locale.format(module, "applyX3PatchTo", folder.name(_)));
		// Start the batch server in reserved mode (for patch only)
		startBatchServer(_, context, epToUpdate, true);


		var r = epToUpdate.endpoint(_).postService(_, "patch", applyPatch);

		if (r.head.status === 200) {
			var requestId = r.body.requestId;
			var lastMessage = "";
			updateChildren = true;
			for (var i = 0; i < 36000; i++) {
				setTimeout(~_, 1000);

				var r = epToUpdate.endpoint(_).getService(_, "patch", {
					requestId: requestId,
					version: update.version(_),
					folder: folder.name(_),
					name: patch.name(_),
				});
				if (r && r.$diagnoses) {
					var done;
					r.$diagnoses.forEach(function(diag) {
						if (["success", "error"].indexOf(diag.$severity) >= 0) {
							done = diag;
							updateChildren = updateChildren && (diag.$severity === "success");
						}
						if (lastMessage !== diag.$message)
							trackMessage(context, "info", diag.$message);
						lastMessage = diag.$message;
					});
					if (done) {
						tracer.debug && tracer.debug("done:" + done.$message);

						folder.status(_, done.$message);
						if (done.$severity === "success") folder.release(_, update.version(_));
						folder.updated(_, date.today());

						var sadfs = new SadFsqClient(_, epToUpdate.endpoint(_), null, null, false);
						var traceContents = sadfs.readFile(_, {
							path: r.trace
						}, {
							flag: "r",
							encoding: "utf-8"
						});

						updateTrace(_, context, folder, traceTitle, traceContents);
						trackMessage(context, updateChildren ? "success" : "error", done.$message);
						folder.status(_, done.$severity);
						folder.detailedStatus(_, done.$message);
						break;
					}
				}
			}
		}
	}
	if (updateChildren) {
		tracer.debug && tracer.debug("updateChildren");
		updateFolders(_, context, integrate, update, epToUpdate, patch, path, folder.name(_));
	}
}

function updateFolders(_, context, integrate, update, epToUpdate, patch, path, parent) {
	parent = parent || "";
	tracer.debug && tracer.debug("updateFolders");
	var folders = epToUpdate.folders(_).toArray(_, true);

	var fcts = [];
	folders.forEach_(_, function(_, folder) {
		if (!folder.history(_) && parent === folder.parent(_)) {
			// Execute the update as a future
			fcts.push(updateFolder(!_, context, integrate, update, epToUpdate, patch, path, folder));
		}
	});
	// Wait for the execution of all futures :
	fcts.forEach_(_, function(_, fct) {
		fct(_);
	});
}

function patchStandard(_, context, integrate, update, epToUpdate, patch) {
	var patchName = patch.name(_).toUpperCase();

	trackMessage(context, "info", locale.format(module, "applyX3Patch", patchName));

	// First copy the patch on the server :
	var path = copyPatch(_, context, update, epToUpdate.endpoint(_), patch);
	//var path = "PATCH/X3V7_P3/FILPATCH";

	// Apply the patch
	updateFolders(_, context, integrate, update, epToUpdate, patch, path);

	// Save changes :
	update.save(_);

	// Start the batch server
	startBatchServer(_, context, epToUpdate);
	//tracer.debug &&  tracer.debug(JSON.stringify(res));  
}

function patchNothing(_, context, integrate, update, epToUpdate, patch) {
	var patchName = patch.name(_).toUpperCase();

	trackMessage(context, "info", locale.format(module, "applyX3Patch", patchName));

}

var patchTypes = {
	X3: patchStandard,
	HR: patchStandard,
	GX: patchStandard,
	IND: patchStandard,
	DIV: patchStandard,
	HRH: patchStandard,
	HRO: patchStandard,
	DOC: patchNothing
};

function findFolder(folder, name) {
	if (folder.name === name) return folder;
	if (folder.folders) {
		for (var i = 0; i < folder.folders.length; i++) {
			var found = findFolder(folder.folders[i], name);
			if (found) return found;
		}
	}
}

function startBatchServer(_, context, epToUpdate, reserved) {
	tracer.debug && tracer.debug("startBatchServer:" + reserved);
	var endpoint = epToUpdate.endpoint(_);
	var status = endpoint.getService(_, "servBatch");
	tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));

	if (status.STOP === 1 && ((reserved && status.FLGPATCH === 2) || (!reserved && status.FLGPATCH === 1))) return;

	// Stop the server:
	trackMessage(context, "info", locale.format(module, "stopBatchServer"));
	tracer.debug && tracer.debug("stopBatch");
	endpoint.deleteService(_, "stopBatch");

	// Wait for the complete stop :
	for (var i = 0; i < 600; i++) {
		setTimeout(~_, 100);
		status = endpoint.getService(_, "servBatch");
		tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));
		if (status.STOP === 0) break;
		//trackMessage(context, "info", locale.format(module, "batchServerStopping"));
	}

	// Start the server in the expected mode
	tracer.debug && tracer.debug("startBatch");
	trackMessage(context, "info", locale.format(module, "startBatchServer"));
	endpoint.postService(_, "startBatch", {
		flgpatch: (reserved || false)
	});

	status = endpoint.getService(_, "servBatch");
	trackMessage(context, "info", locale.format(module, "batchServerStarted"));
	tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));
}

// Update folders' information : 
function updateFoldersDesc(_, update, epToUpdate) {
	tracer.debug && tracer.debug("updateFoldersDesc");
	var foldersTree = epToUpdate.endpoint(_).getService(_, "foldersTree");
	tracer.debug && tracer.debug("updateFoldersDesc foldersTree:", foldersTree);

	epToUpdate.folders(_).toArray(_, true).forEach_(_, function(_, folder) {
		var found = findFolder(foldersTree, folder.name(_));
		if (found) {
			if (found.nump !== folder.patch(_)) {
				var folderDate = (found.dat === "00/00/0000") ? "01/01/1970" : found.dat;
				folder.updated(_, date.parse(folderDate, "dd/MM/yyyy"));
				folder.patch(_, found.nump);
				update.save(_);
			}
		}
	});
}


function updateEndpoint(_, context, integrate, update, epToUpdate, patches) {
	trackMessage(context, "info", locale.format(module, "updateEndpoint", epToUpdate.endpoint(_).description(_)));
	if (epToUpdate.folders(_).isEmpty()) return;

	// Get folders' descriptions before update
	updateFoldersDesc(_, update, epToUpdate);

	var folders = epToUpdate.folders(_).toArray(_, true);
	folders.forEach_(_, function(_, folder) {
		// Reset folder's status:
		folder.status(_, "info");
		folder.detailedStatus(_, locale.format(module, "notUpdated"));

		// Reset folder's trace:
		var trace = folder.trace(_);
		if (trace.fileExists(_)) trace.deleteFile(_);
	});

	patches.forEach_(_, function(_, patch) {
		if (patch.apply(_)) {
			var type = patch.type(_).toUpperCase();
			type && patchTypes[type] && patchTypes[type](_, context, integrate, update, epToUpdate, patch);
		} else {
			trackMessage(context, "info", locale.format(module, "doesntApplyPatch", patch.name(_).toUpperCase()));
		}
	});

	// Get folders' descriptions after update
	updateFoldersDesc(_, update, epToUpdate);
}

function scheduled(_, instance) {
	var db = adminHelper.getCollaborationOrm(_);
	return db.fetchInstances(_, db.getEntity(_, "eventTime"), {
		jsonWhere: {
			"parameters.update": instance.$uuid
		}
	});
}

function unschedule(_, instance) {
	var db = adminHelper.getCollaborationOrm(_);
	scheduled(_, instance).forEach_(_, function(_, evt) {
		db.deleteInstance(_, evt);
	});
	instance.scheduled(_, "");
	instance.save(_);
}

exports.entity = {
	$isPersistent: true,
	$canSave: true,
	$titleTemplate: "Update management",
	$descriptionTemplate: "Update management",
	$helpPage: "Administration-reference_Updates",
	$valueTemplate: "{name}",
	$properties: {
		file: {
			$title: "Update",
			$type: "binary",
			$storage: "db_file",
			$propagate: function(_, instance, file) {
				instance.fsName(_, file.fsName);
			},
			$uploadDone: function(_, instance) {
				var store = instance.file(_);

				if (store.fileExists(_)) {
					var props = store.getProperties(_);

					var root = props.fileName.substring(0, props.fileName.lastIndexOf('.')) + "/";

					var zip = store.createReadableStream(_).readAll(_);
					new unzip.Unzip(
						zip,
						function(filename, filecontent, headers, _) {
							try {
								var contents = JSON.parse(filecontent.toString('utf8'));
								instance.name(_, contents.name);
								instance.version(_, contents.version);
								instance.dependency(_, contents.dependency);
								instance.description(_, contents.description);
								instance.patches(_).reset(_);
								contents.patches.forEach_(_, function(_, p) {
									var patch = instance.patches(_).add(_);
									patch.name(_, p.name);
									patch.type(_, p.type);
									patch.description(_, p.description);
									patch.path(_, p.path);
									patch.mandatory(_, p.mandatory || false);
									patch.firstMaintenance(_, 0);
									patch.lastMaintenance(_, 0);
									patch.apply(_, true);
								});
							} catch (e) {}
						}, {
							filter: function(filename, headers, _) {
								return filename.toLowerCase().substring(root.length) == "update.json";
							}
						}).unzip(_);
				}
			}
		},
		name: {
			$title: "Name",
			$isDisabled: true
		},
		version: {
			$title: "Version",
			$isDisabled: true
		},
		dependency: {
			$title: "Dependency",
			$isDisabled: true
		},
		description: {
			$title: "description",
			$isDisabled: true
		},
		fsName: {
			$title: "fsName",
			$isDisabled: true,
			$isHidden: true,
		},
		scheduled: {
			$title: "Scheduled",
			$isDisabled: true
		},
		status: {
			$title: "Status",
			$isDisabled: true
		},
		releaseNote: {
			$title: "releaseNote",
			$isDisabled: true,
			$isHidden: true,
		}
	},
	$links: function(_, instance) {
		return {
			releaseNote: {
				$title: "Release Note",
				$method: "GET",
				$url: "/help/new-features",
				$type: "text/html",
				$target: "help"
			}
		};
	},

	$relations: {
		patches: {
			$title: "Patches",
			$type: "updatePatches",
			$inv: "update",
			$isChild: true,
			$isDisabled: true,
			$capabilities: ""
		},
		endpoints: {
			$title: "Apply to endpoints",
			$type: "epToUpdates",
			$inv: "update",
			$isChild: true,
			$isDisabled: false,
			$capabilities: "delete",
			$select: {
				$title: "Endpoints",
				$type: "endPoint", // "lookupRepresentation",
				$fieldMap: {
					endpoint: "$uuid"
				}
			},

		}
	},
	$functions: {
		isDisabled: function(_, instance) {
			if (instance.name(_) === undefined || instance.endpoints(_).isEmpty()) {
				// is there a patch for Syracuse
				var patches = instance.patches(_).toArray(_, true);

				for (var i = 0; i < patches.length; i++) {
					if (patches[i].type(_).toUpperCase() === "SYRACUSE")
						return false;
				}
				return true;
			}
			return false;
		},
		fire: function(_, key, parameters) {
			tracer.debug && tracer.debug("event start");

			var session = globals.context.session;
			if (!session) {
				var db = adminHelper.getCollaborationOrm(_);
				var user = db.fetchInstance(_, db.getEntity(_, "user"), parameters.user);
				var role = db.fetchInstance(_, db.getEntity(_, "role"), parameters.role);
				var locale = db.fetchInstance(_, db.getEntity(_, "localePreference"), parameters.locale);

				if (user && role && locale) {
					var diagnoses = [];
					tracer.debug && tracer.debug("createBatchSession");
					session = sessionManager.createBatchSession(_, user, role, locale, diagnoses);
				}
			}

			if (session) applyUpdate(true)(_, null, this);
			tracer.debug && tracer.debug("event end");
		}
	},
	$services: {
		test: {
			$method: "POST",
			$title: "Test update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$facets: ["$details"],
			$isDisabled: function(_, instance) {
				return instance.isDisabled(_, instance);
			},
			$execute: applyUpdate(false)
		},
		apply: {
			$method: "POST",
			$title: "Apply update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$facets: ["$details"],
			$isDisabled: function(_, instance) {
				return instance.isDisabled(_, instance);
			},
			$execute: applyUpdate(true)
		},
		refresh: {
			$method: "POST",
			$isMethod: true,
			$title: "refresh",
			$execute: function(_, context, instance) {}
		},
		schedule: {
			$title: "Schedule update",
			$method: "POST",
			$isMethod: true,
			$facets: ["$details"],
			$isDisabled: function(_, instance) {
				return instance.isDisabled(_, instance);
			},
			$parameters: {
				executionDate: null,
				executionTime: null,
				$properties: {
					executionDate: {
						$title: "Execution date",
						$description: "Desired patch application date",
						$type: "application/x-date"
					},
					executionTime: {
						$title: "Execution time",
						$description: "Desired patch application time",
						$type: "application/x-time"
					}
				}
			},
			$execute: function(_, context, instance, parameters) {
				if (!parameters.executionDate || !parameters.executionTime) {
					instance.$addError(locale.format(module, "scheduleParameters"));
					return;
				}

				var dtm = datetime.parse(parameters.executionDate + "T" + parameters.executionTime);
				//console.log("execution date:"+dtm);
				var up = context.getUserProfile(_);
				if (up) {
					// First delete any task that could have been scheduled for this update
					unschedule(_, instance);

					instance.scheduled(_, locale.format(module, "scheduleAt", parameters.executionDate, parameters.executionTime));
					instance.save(_);

					scheduler.schedule(_, instance, instance.$uuid, dtm, {
						"user": up.user(_) && up.user(_).$uuid,
						"role": up.selectedRole(_) && up.selectedRole(_).$uuid,
						"locale": up.selectedLocale(_) && up.selectedLocale(_).$uuid,
						"update": instance.$uuid
					}, "db");
				}
			}
		},
		unschedule: {
			$method: "POST",
			$isMethod: true,
			$title: "Unschedule update",

			$isDisabled: function(_, instance) {
				return !scheduled(_, instance).length;
			},

			$execute: function(_, context, instance) {
				unschedule(_, instance);
			}
		},
	}
};