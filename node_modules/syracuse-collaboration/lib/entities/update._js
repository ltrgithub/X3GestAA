"use strict";

var globals = require('streamline/lib/globals');
var mongodb = require('ez-mongodb');
var zip = require('streamline-zip');
var unzip = require('streamline-zip');
var ez = require('ez-streams');
var fs = require('streamline-fs');

var locale = require("streamline-locale");
var date = require("syracuse-core").types.date;
var datetime = require('syracuse-core').types.datetime;
var scheduler = require("syracuse-event/lib/scheduler");

var sadFsq = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient');
var SadFsqClient = sadFsq.SadFsqClient;

var tracer = require('syracuse-trace/lib/helper').getTracer('patch');

var config = require('config'); // must be first syracuse require

exports.$exported = true;

function trackMessage(context, severity, message) {
	var t = context.tracker;
	if (t) {
		//t.phaseDetail = t.phaseDetail;
		tracer.debug && tracer.debug(severity + ":" + message);
		t.$diagnoses = t.$diagnoses || [];
		t.$diagnoses.push({
			$severity: severity,
			$message: message
		});
	}
}

function copyPatch(_, context, update, endpoint, patch) {
	var path = "PATCH/" + patch.path(_);
	trackMessage(context, "info", locale.format(module, "copyPatchTo", path));

	var sadfs = new SadFsqClient(_, endpoint, null, null, false);
	var x3Files = [];
	var refFiles = [];
	try {
		var lsadx = sadfs.readdir(_, {
			folder: endpoint.x3ServerFolder(_),
			path: path,
		});

		lsadx.forEach(function(file) {
			x3Files.push(file);
		});
	} catch (e) {

	}

	var store = update.file(_);

	if (store.fileExists(_)) {
		var props = store.getProperties(_);
		var root = (props.fileName.substring(0, props.fileName.lastIndexOf('.')) + "/" + patch.path(_) + "/").toUpperCase();

		var zip = store.createReadableStream(_).readAll(_);
		var total = 0;

		var firstMaintenance = 0;
		var lastMaintenance = 0;

		var patchFiles = new unzip.Unzip(
			zip,
			function(filename, filecontent, headers, _) {
				var fname = filename.substring(filename.lastIndexOf('/') + 1);
				var fileOptions = {
					folder: endpoint.x3ServerFolder(_),
					path: options.path + fname
				};
				trackMessage(context, "info", locale.format(module, "copyFile", fname));

				for (var i = 0; i < 3; i++) {
					try {
						sadfs.writeFile(_, fileOptions, filecontent, {
							flag: "w+"
						});
						if (sadfs.stat(_, fileOptions, ["size"]).size > 0) break;
						// Retry a copy if the previous ended with a o size file:
						tracer.error && tracer.error("sadfs.writeFile(" + fileOptions.path + ") failed");
					} catch (e) {
						tracer.error && tracer.error("exception in sadfs.writeFile:" + e.stack);
					}
					try {
						sadfs.unlink(_, fileOptions);
					} catch (e) {
						tracer.error && tracer.error("exception in sadfs.unlink:" + e.stack);
					}
				}
			}, {
				filter: function(filename, headers, _) {
					var keep = (filename.toUpperCase().substring(0, root.length) === root);
					if (keep) {

						var file = filename.toUpperCase().substring(1 + filename.lastIndexOf('/'));
						if (file.length) {
							var match = file.match(/[A-Z]*_(\d*)_\d*\.\w{3}/);
							if (match) {
								var maintenance = parseInt(match[1]);
								firstMaintenance = (firstMaintenance) ? Math.min(maintenance, firstMaintenance) : maintenance;
								lastMaintenance = (lastMaintenance) ? Math.max(maintenance, lastMaintenance) : maintenance;
							}

							// Doesn't copy file present on the X3 folder :
							refFiles.push(file);
							keep = !x3Files.some(function(x3File) {
								return x3File.toUpperCase() === file;
							});
						} else {
							keep = false;
						}
					}
					return keep;
				}
			});

		var zipFiles = patchFiles.list(_);
		total = zipFiles.length;

		// Remove files which aren't supposed to be there :
		trackMessage(context, "info", locale.format(module, "cleanUp"));
		x3Files
			.filter(function(file) {
				var uFile = file.toUpperCase();
				return !refFiles.some(function(refFile) {
					return refFile === uFile;
				});
			})
			.forEach_(_, function(_, file) {
				try {
					trackMessage(context, "info", locale.format(module, "unlinkFile", path, file));
					sadfs.unlink(_, {
						folder: endpoint.x3ServerFolder(_),
						path: path,
						name: file,
					});
				} catch (e) {}
			});


		trackMessage(context, "info", locale.format(module, "copyFilesTo", path));
		var options = {
			folder: endpoint.x3ServerFolder(_),
			path: "",
		};
		path.split('/').forEach_(_, function(_, subdir) {
			options.path += subdir;
			trackMessage(context, "info", locale.format(module, "mkdir", options.path));
			var rep = sadfs.mkdir(_, options);
			options.path += "/";
		});

		patchFiles.unzip(_);

		patch.firstMaintenance(_, firstMaintenance);
		patch.lastMaintenance(_, lastMaintenance);
		return path;
	}
}

function applyUpdate(integrate) {
	return function(_, context, instance) {
		instance.updateInProgress = true;
		var endpoints = instance.endpoints(_);
		var patches = instance.patches(_).toArray(_, true);
		var fcts = [];

		if (context.tracker) context.tracker.phaseDetail = locale.format(module, "phase" + (integrate ? "Apply" : "Test"));

		endpoints.toArray(_, true).forEach_(_, function(_, epToUpdate) {
			fcts.push(updateEndpoint(!_, context, integrate, instance, epToUpdate, patches));
		});

		// Wait for the execution of all futures :
		fcts.forEach_(_, function(_, fct) {
			fct(_);
		});

		instance.updateInProgress = false;
	};
}

var htmlMap = {
	"&": "amp",
	"<": "lt",
	">": "gt",
	'"': 'quot',
	"'": '#39',
	"/": '#x2F',
	"à": "agrave",
	"â": "acirc",
	"é": "eacute",
	"è": "egrave",
	"ê": "ecirc",
	"ë": "euml",
	"î": "icirc",
	"ï": "iuml",
	"ô": "ocirc",
	"ù": "ugrave",
	"û": "ucirc",
	"ç": "ccedil",
	"€": "euro"
};

var regHtmlChars = new RegExp("[" + Object.keys(htmlMap).join('') + "]", "g");


function escapeHtml(string) {
	return String(string.replace(/\s+$/, "").replace(/^\s+/, "")).replace(regHtmlChars, function(s) {
		return '&' + htmlMap[s] + ';';
	});
}


function log2Html(_, title, log, html) {
	var src = ez.devices.buffer.reader(log);
	var lines = ez.transforms.lines;
	var errors = [];

	var nextError = "";

	if (html) {
		html = html.substring(0, html.lastIndexOf("</BODY>"));
	} else {
		html = '<!DOCTYPE HTML>' + '\n';
		html += '<HTML>' + '\n';
		html += '      <META HTTP-EQUIV="X-UA-Compatible" CONTENT="IE=9"/>' + '\n';
		html += '    <HEAD>' + '\n';
		html += '        <TITLE>log</TITLE>' + '\n';
		html += '            <META CHARSET="utf-8" />' + '\n';
		html += '            <META HTTP-EQUIV="X-UA-Compatible" CONTENT="IE=9"/>' + '\n';
		html += '            <Link REL="icon" HREF="/syracuse-ui/themes/desktop/images/site/favicon.ico" />' + '\n';
		html += '            <Link HREF="/syracuse-ui/themes/desktop/trace.css" REL="stylesheet"/>' + '\n';
		html += '      </HEAD>' + '\n';
		html += '    <BODY>' + '\n';
	}
	var isFile = (log.indexOf('\n') !== -1);

	var body = src.transform(lines.parser())
		.map(function() {
			var table;
			return function(_, log) {
				var html = "";
				if (/^#\<AdxVL\>@\(#\)%I%/.test(log) || /^=1000/.test(log)) {
					html = "";
				} else if (/^=0000 /.test(log)) {
					html = "<p>" + escapeHtml(log.substring(6)) + "</p>";
				} else if (/^>/.test(log)) {
					html = '<p class="t-p-G' + log.substring(1, 5) + '">' + escapeHtml(log.substring(6));
				} else if (/^</.test(log)) {
					var error = escapeHtml(log.substring(6));
					errors.push(error);

					if (isFile) html = '<a id="error' + nextError + '">';
					html += '<p class="t-p-L' + log.substring(1, 5) + '">' + error;
					if (isFile) {
						html += '</a>';
						nextError = require('syracuse-core').uuid.generate('').toString();
						html += '<a href="#error' + nextError + '">' + locale.format(module, "nextError") + '</a>';
					}
					html += '</p><br/>';
				} else if (/^\+-\w+/.test(log)) {
					var match = log.match(/^\+-(\w+)/);
					if (match && match[1]) html = "<b>" + match[1] + "</b><br/>";

					html += table ? "</table>\n<br/>\n" : "";
					table = "<table>";
					html += table;
				} else if (/^\+-/.test(log)) {
					html = table ? "</table>\n<br/>\n" : "";
					table = undefined;
				} else if (/^[!\-\s]+$/.test(log)) {
					html = "";
				} else if (/^!/.test(log)) {
					html = "";
					if (!table) {
						table = "<table>";
						html = table;
					}
					log = log.substring(1, log.length - 2);
					var lastI = log.lastIndexOf('!');
					if (lastI > 0) log = log.substring(0, lastI);
					html += "<tr>" + log.replace(/-/g, '').split('!').map(function(td) {
						return "<td>" + escapeHtml(td) + "</td>";
					}).join('') + "</tr>";
				} else {
					if (table) {
						html += "</table>\n";
						table = undefined;
					}
					var paragraph = escapeHtml(log);
					html += (paragraph.length) ? '<p>' + paragraph + '</p>' : '<br/>';
				}
				return html;
			};
		}()).toArray(_).join('\n');

	//html += '<p><h1>' + locale.format(module, "summary") + '</h1></p>' + '\n';
	html += '<p><h1>' + title + ' - ' + (new Date()).toLocaleString() + '</h1></p>' + '\n';
	if (errors.length && isFile) {
		for (var i = 0; i < errors.length; i++) {
			html += '<p><a href="#error' + (i + 1) + '">' + locale.format(module, "errorNo", (i + 1), errors[i]) + '</a></p>' + '\n';
		}
	}

	if (isFile) {
		var eof = require('syracuse-core').uuid.generate('').toString();
		html += '<p><a href="#' + eof + '">' + locale.format(module, "eof") + '</a></p>\n';
	}
	html += body;
	if (isFile) {
		html += '<a id="' + eof + '">' + locale.format(module, "eof") + '</a><br/>\n';
	}
	html += '\n</BODY>\n</HTML>\n';
	return html;
}

function updateTrace(_, folder, title, contents) {
	var htmlContents = "";
	var trace = folder.trace(_);
	if (trace.fileExists(_)) {
		htmlContents = trace.createReadableStream(_).readAll(_).toString("utf8");
	}
	htmlContents += log2Html(_, title, contents, htmlContents);

	var writer = folder.trace(_).createWritableStream(_, {
		contentType: "x-trace",
		fileName: title,
	});
	writer.write(_, htmlContents, "binary");
	writer.write(_, null);
}

function updateFolder(_, context, integrate, update, epToUpdate, patch, path, folder) {
	var updateChildren = true;
	var traceTitle = patch.name(_);
	var dependency = update.dependency(_);

	var legislation = patch.legislation(_);
	var legislations = folder.legislations(_);
	if (legislations) legislations = legislations.split(',');
	var applyPatch = false;

	if (legislation && (!legislations || legislations.indexOf(legislation) < 0)) {
		updateChildren = true;
		var warning = locale.format(module, "legislationWarning", patch.legislation(_), folder.name(_));
		trackMessage(context, "warning", warning);
		updateTrace(_, folder, traceTitle, "<0003>" + warning);

	} else if (dependency === folder.release(_)) {
		applyPatch = {
			version: update.version(_),
			folder: folder.name(_),
			directory: path,
			name: patch.name(_),
			integrate: integrate
		};
	} else if ((update.version(_) === folder.release(_)) && patch.mandatory(_) && (folder.patch(_) < patch.lastMaintenance(_))) {
		applyPatch = {
			version: update.version(_),
			folder: folder.name(_),
			directory: path,
			name: patch.name(_),
			integrate: integrate,
			statusMaintenance: 3,
			maintenance: folder.patch(_)
		};
	} else if ((update.version(_) === folder.release(_)) && !patch.mandatory(_)) {
		applyPatch = {
			version: update.version(_),
			folder: folder.name(_),
			directory: path,
			name: patch.name(_),
			integrate: integrate
		};
	} else {
		var warning = locale.format(module, "dependencyWarning", update.version(_), folder.name(_), folder.release(_));
		trackMessage(context, "warning", warning);
		updateTrace(_, folder, traceTitle, "<0003>" + warning);
	}

	if (applyPatch) {
		updateChildren = false;
		trackMessage(context, "info", locale.format(module, "applyX3PatchTo", folder.name(_)));
		// Start the batch server in reserved mode (for patch only)
		startBatchServer(_, context, epToUpdate, true);


		var r = epToUpdate.endpoint(_).postService(_, "patch", applyPatch);

		if (r.head.status === 200) {
			var requestId = r.body.requestId;
			updateChildren = true;
			for (var i = 0; i < 36000; i++) {
				setTimeout(_, 1000);

				var r = epToUpdate.endpoint(_).getService(_, "patch", {
					requestId: requestId,
					version: update.version(_),
					folder: folder.name(_),
					name: patch.name(_),
				});
				if (r && r.$diagnoses) {
					var done;
					r.$diagnoses.forEach(function(diag) {
						if (["success", "error"].indexOf(diag.$severity) >= 0) {
							done = diag;
							updateChildren = updateChildren && (diag.$severity === "success");
						}

						trackMessage(context, "info", diag.$message);
					});
					if (done) {
						folder.status(_, done.$message);
						if (done.$severity === "success") folder.release(_, update.version(_));
						folder.updated(_, date.today());

						var sadfs = new SadFsqClient(_, epToUpdate.endpoint(_), null, null, false);
						var traceContents = sadfs.readFile(_, {
							path: r.trace
						}, {
							flag: "r",
							encoding: "utf-8"
						});

						updateTrace(_, folder, traceTitle, traceContents);

						var t = context && context.tracker;
						t.$diagnoses = t.$diagnoses || [];
						t.$diagnoses.push(done);
						break;
					}
				}
			}
		}
	}
	if (updateChildren) {
		updateFolders(_, context, integrate, update, epToUpdate, patch, path, folder.name(_));
	}
}

function updateFolders(_, context, integrate, update, epToUpdate, patch, path, parent) {
	parent = parent || "";
	var folders = epToUpdate.folders(_).toArray(_, true);


	var fcts = [];
	folders.forEach_(_, function(_, folder) {
		if (!folder.history(_) && parent === folder.parent(_)) {
			// Execute the update as a future
			fcts.push(updateFolder(!_, context, integrate, update, epToUpdate, patch, path, folder));
		}
	});
	// Wait for the execution of all futures :
	fcts.forEach_(_, function(_, fct) {
		fct(_);
	});
}

function patchStandard(_, context, integrate, update, epToUpdate, patch) {
	var patchName = patch.name(_).toUpperCase();

	trackMessage(context, "info", locale.format(module, "applyX3Patch", patchName));

	// First copy the patch on the server :
	var path = copyPatch(_, context, update, epToUpdate.endpoint(_), patch);
	//var path = "PATCH/X3V7_P3/FILPATCH";

	// Apply the patch
	updateFolders(_, context, integrate, update, epToUpdate, patch, path);

	// Start the batch server
	startBatchServer(_, context, epToUpdate);

	// Save changes :
	update.save(_);
	//tracer.debug &&  tracer.debug(JSON.stringify(res));  
}

function patchNothing(_, context, integrate, update, epToUpdate, patch) {
	var patchName = patch.name(_).toUpperCase();

	trackMessage(context, "info", locale.format(module, "applyX3Patch", patchName));

}

var patchTypes = {
	X3: patchStandard,
	HR: patchStandard,
	GX: patchStandard,
	IND: patchStandard,
	DIV: patchStandard,
	HRH: patchStandard,
	HRO: patchStandard,
	DOC: patchNothing
};

function findFolder(folder, name) {
	if (folder.name === name) return folder;
	if (folder.folders) {
		for (var i = 0; i < folder.folders.length; i++) {
			var found = findFolder(folder.folders[i], name);
			if (found) return found;
		}
	}
}

function startBatchServer(_, context, epToUpdate, reserved) {
	var endpoint = epToUpdate.endpoint(_);
	var status = endpoint.getService(_, "servBatch");
	tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));

	if (status.STOP === 1 && ((reserved && status.FLGPATCH === 2) || (!reserved && status.FLGPATCH === 1))) return;

	// Stop the server:
	trackMessage(context, "info", locale.format(module, "stopBatchServer"));
	tracer.debug && tracer.debug("stopBatch");
	endpoint.deleteService(_, "stopBatch");

	// Wait for the complete stop :
	for (var i = 0; i < 60; i++) {
		setTimeout(_, 1000);
		status = endpoint.getService(_, "servBatch");
		tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));
		if (status.STOP === 0) break;
		trackMessage(context, "info", locale.format(module, "batchServerStopping"));
	}

	// Start the server in the expected mode
	tracer.debug && tracer.debug("startBatch");
	trackMessage(context, "info", locale.format(module, "startBatchServer"));
	endpoint.postService(_, "startBatch", {
		flgpatch: (reserved || false)
	});

	status = endpoint.getService(_, "servBatch");
	trackMessage(context, "info", locale.format(module, "batchServerStarted"));
	tracer.debug && tracer.debug("servBatch:" + JSON.stringify(status));
}

// Update folders' information : 
function updateFoldersDesc(_, update, epToUpdate) {
	var foldersTree = epToUpdate.endpoint(_).getService(_, "foldersTree");
	epToUpdate.folders(_).toArray(_, true).forEach_(_, function(_, folder) {
		var found = findFolder(foldersTree, folder.name(_));
		if (found) {
			if (found.nump !== folder.patch(_)) {
				var folderDate = (found.dat === "00/00/0000") ? "01/01/1970" : found.dat;
				folder.updated(_, date.parse(folderDate, "dd/MM/yyyy"));
				folder.patch(_, found.nump);
				folder.legislations(_, found.legislations || "");
				update.save(_);
			}
		}
	});
}


function updateEndpoint(_, context, integrate, update, epToUpdate, patches) {
	trackMessage(context, "info", locale.format(module, "updateEndpoint", epToUpdate.endpoint(_).description(_)));
	if (epToUpdate.folders(_).isEmpty()) return;

	// Get folders' descriptions before update
	updateFoldersDesc(_, update, epToUpdate);

	patches.forEach_(_, function(_, patch) {
		if (patch.apply(_)) {
			var type = patch.type(_);
			type && patchTypes[type] && patchTypes[type](_, context, integrate, update, epToUpdate, patch);
		} else {
			trackMessage(context, "info", locale.format(module, "doesntApplyPatch", patch.name(_).toUpperCase()));
		}
	});

	// Get folders' descriptions after update
	updateFoldersDesc(_, update, epToUpdate);
}

exports.entity = {
	$isPersistent: true,
	$canSave: true,
	$titleTemplate: "Update management",
	$descriptionTemplate: "Update management",
	$helpPage: "Update_management",
	$valueTemplate: "{name}",
	$lockType: "noLock",
	$properties: {
		file: {
			$title: "Update",
			$type: "binary",
			$storage: "db_file",
			$propagate: function(_, instance, file) {
				instance.fsName(_, file.fsName);
			},
			$uploadDone: function(_, instance) {
				var store = instance.file(_);

				if (store.fileExists(_)) {
					var props = store.getProperties(_);

					var root = props.fileName.substring(0, props.fileName.lastIndexOf('.')) + "/";

					var zip = store.createReadableStream(_).readAll(_);
					new unzip.Unzip(
						zip,
						function(filename, filecontent, headers, _) {
							try {
								var contents = JSON.parse(filecontent.toString('utf8'));
								instance.name(_, contents.name);
								instance.version(_, contents.version);
								instance.dependency(_, contents.dependency);
								instance.description(_, contents.description);
								instance.releaseNote(_, contents.releaseNote);
								instance.patches(_).reset(_);
								contents.patches.forEach_(_, function(_, p) {
									var patch = instance.patches(_).add(_);
									patch.name(_, p.name);
									patch.type(_, p.type);
									patch.description(_, p.description);
									patch.path(_, p.path);
									patch.mandatory(_, p.mandatory || false);
									patch.firstMaintenance(_, 0);
									patch.lastMaintenance(_, 0);
									patch.legislation(_, p.legislation || "");
									patch.apply(_, true);
								});
							} catch (e) {}
						}, {
							filter: function(filename, headers, _) {
								return filename.toLowerCase().substring(root.length) == "update.json";
							}
						}).unzip(_);
				}
			}
		},
		name: {
			$title: "Name",
			$isDisabled: true
		},
		version: {
			$title: "Version",
			$isDisabled: true
		},
		dependency: {
			$title: "Dependency",
			$isDisabled: true
		},
		description: {
			$title: "description",
			$isDisabled: true
		},
		fsName: {
			$title: "fsName",
			$isDisabled: true,
			$isHidden: true,
		},
		releaseNote: {
			$title: "releaseNote",
			$isDisabled: true,
			$isHidden: true,
		},

	},
	$links: function(_, instance) {
		return {
			releaseNote: {
				$title: "Release Note",
				$url: instance.releaseNote(_),
				$method: "GET"
			}
		};
	},
	$relations: {
		patches: {
			$title: "Patches",
			$type: "updatePatches",
			$inv: "update",
			$isChild: true,
			$isDisabled: true,
			$capabilities: ""
		},
		endpoints: {
			$title: "Apply to endpoints",
			$type: "epToUpdates",
			$inv: "update",
			$isChild: true,
			$isDisabled: false,
			$capabilities: "delete",
			$select: {
				$title: "Endpoints",
				$type: "endPoint", // "lookupRepresentation",
				$fieldMap: {
					endpoint: "$uuid"
				}
			},

		}
	},
	$functions: {
		isDisabled: function(_, instance) {
			return instance.name(_) === undefined || instance.endpoints(_).isEmpty();
		},
		scheduledExecute: function(_, diags) {
			var execute = applyUpdate(true);
			var context = {
				tracker: {
					$diagnoses: diags
				}
			};
			execute(_, context, this);
		}
	},
	$services: {
		test: {
			$method: "POST",
			$title: "Test update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$isDisabled: function(_, instance) {
				return instance.isDisabled(_, instance);
			},
			$execute: applyUpdate(false)
		},
		apply: {
			$method: "POST",
			$title: "Apply update",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$isDisabled: function(_, instance) {
				return instance.isDisabled(_, instance);
			},
			$execute: applyUpdate(true)
		},
		refresh: {
			$method: "POST",
			$isMethod: true,
			$title: "refresh",
			$execute: function(_, context, instance) {}
		},
		schedule: {
			$method: "POST",
			$title: "Schedule update",
			$isMethod: true,
			$facets: ["$edit"],
			$parameters: {
				$actions: {
					$select: {
						$url: "{$baseUrl}/automates?representation=automate.$select"
					}
				}
			},
			//			$urlParameters: "scheduler={schedulerId}",
			$execute: function(_, context, instance, parameters) {
				if (!parameters || !parameters.$select) {
					return;
				}
				parameters.$select.forEach_(_, function(_, s) {
					var a = instance._db.fetchInstance(_, instance._db.getEntity(_, "automate"), s.$uuid);
					if (!a) {
						return;
					}
					var t = a.automateTasks(_).add(_);
					t.description(_, locale.format(module, "phaseApply"));
					if (tracer.debug) t.logLevel(_, "debug");
					else t.logLevel(_, "error");
					t.process(_, instance);
					a.save(_);
					var diag = [];
					a.getAllDiagnoses(_, diag, {
						addPropName: true,
						addEntityName: true
					});
					if (diag.some(function(d) {
						d = _normalizeDiag(d);
						return d.$severity === "error";
					})) {
						diag.forEach(function(d) {
							d = _normalizeDiag(d);
							instance.$addDiagnose(d.$severity, d.$message);
						});
					} else {
						instance.$addDiagnose("success", locale.format(module, "taskCreated", a.description(_)));
					}
				});
			}
		}

	}
};