"use strict";

var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var entity;
var db;
var testOutput;
var timeoutFunction = null;
var nextRead;
var nextEvents = [];
var util = require('util');
var config = require('syracuse-main/lib/nodeconfig').config;
var mock = require('syracuse-load/lib/mock');

var tracer = null;
// var tracer = console.log

/// !doc


// for unit tests: testing scheduler without real event and with test database
exports._setTestData = function(db1, output1) {
	db = db1;
	testOutput = output1;
};

// Insert item into array so that array remains sorted and does not contain duplicate items

function _insert(array, item) {
	var up = array.length;
	if (up === 0) {
		array[0] = item;
		return array;
	}
	var low = 0;
	var middle = array[0];
	while (up - low > 1) {
		var mid = ((up + low) >> 1);
		middle = array[mid];
		if (middle === item) return array;
		if (middle > item) up = mid;
		else low = mid + 1;
	}
	middle = array[low];
	if (middle === item) return array;
	if (middle > item) array.splice(low, 0, item);
	else array.splice(up, 0, item);
	return array;
}

// for unit tests
exports._insert = _insert;



/// -------------
/// ## schedule function 
/// 
/// ``` javascript
/// notificationTime.schedule(_, event, key, executionTime, parameters, mode);
/// ```
/// 
/// Schedule one instance of the given event.
/// 
/// 
/// * The `event` parameter represents the corresponding event (e. g. sending a certain email with a content template)
/// * The `key` parameter represents a key value for this instance. Scheduling a new event with the same key will replace 
///   the previously scheduled event
/// * The `executionTime` parameter contains the execution time. This can be a date string in ISO format or the number of milliseconds since 1 January 1970.
/// * The `parameters` parameter contains a JSON structure which serves for placeholders within the event text
/// * The `mode` parameter denotes how the event should be scheduled: 0 without database change, 1 with database change, 2 schedule also on other servers in cluster.
///  
exports.schedule = function(_, event, key, executionTime, parameters, mode) {
	var ts;
	var now = Date.now();
	if (executionTime) {
		executionTime = new Date(executionTime).getTime();
	}
	if (!executionTime || (executionTime - now < 500)) {
		// execute it directly
		_execute(!_, event, key, parameters);
		return;
	}
	// console.log("Weiter"+mode);
	if (mode > 0) {
		// insert into database
		var fullKey = event ? event.description(_) + "_" + key : key;
		var instances = _getInstances(_, undefined, fullKey); // search for key
		if (instances.length > 0) {
			// console.log("Aendern")
			instances[0].timestamp(_, "" + executionTime);
			instances[0].parameters(_, parameters);
			instances[0].save(_);
			for (var i = 1; i < instances.length; i++) {
				instances[i].deleteSelf(_);
			}
		} else {
			var instance = entity.createInstance(_, db, null);
			instance.timestamp(_, "" + executionTime);
			if (event) instance.notificationEvent(_, event);
			instance.key(_, fullKey);
			instance.parameters(_, parameters);
			instance.save(_);
			var diagnoses = [];
			instance.getAllDiagnoses(_, diagnoses);
		}
	}
	// insert it into the array
	if (nextEvents.length === 0) {
		nextEvents.push(executionTime);
		timeoutFunction = setTimeout(_ << function(_) {
			_read(_);
		}, executionTime - now);
		tracer && tracer("Next execution1 " + new Date(+executionTime));
	} else {
		// console.log("length "+nextEvents.length)
		if (nextEvents[0] > executionTime) {
			clearTimeout(timeoutFunction);
			timeoutFunction = setTimeout(_ << function(_) {
				_read(_);
			}, executionTime - now);
			nextEvents.unshift(executionTime);
		} else {
			_insert(nextEvents, +executionTime);
		}
		tracer && tracer("Next execution2 " + new Date(+nextEvents[0]));
	}
	if (mode > 1) _notifyOthers(_);
	// console.log("TIMEOUT "+util.format(timeoutFunction)+" "+util.format(nextEvents))
};

/// -------------
/// ## scheduleAll function 
/// 
/// ``` javascript
/// notificationTime.scheduleAll(_, event, data, mode);
/// ```
/// 
/// Replace all scheduled instances for this event
/// 
/// * The `event` parameter represents the corresponding event (e. g. sending a certain email with a content template)
/// * The `data` parameter contains an array of triples `[key, executionTime, parameters]`, where `key`, `executionTime`,
///   `parameters` have the same meaning as in the `schedule` function. Elements in this list with same key will replace
///   scheduled events. Scheduled events whose key does not appear any more in this list will be deleted. If the parameter
///   is empty (really empty, not just empty array), the scheduler will just be initialized.
/// * The `mode` parameter denotes how the event should be scheduled: 0 without database change, 1 with database change, 2 schedule also on other servers in cluster.
///
exports.scheduleAll = function(_, event, data, mode) {
	tracer && tracer("Schedule all");
	var ts;
	var now = Date.now();
	nextEvents.length = 0; // no execution of pending events
	if (timeoutFunction) clearTimeout(timeoutFunction);
	var tasks = {};
	var executeImmediately = [];
	var description = event ? event.code(_) + "_" : "";
	// decide which tasks can be executed immediately	
	if (data) {
		data.forEach(function(item) {
			var fullKey = description + item[0];
			if (item[0] && fullKey in tasks) throw new Error(locale.format(module, "doubleKey"));
			var executionTime = item[1];
			tracer && tracer("Ex time " + executionTime + " now " + now);
			if (executionTime) {
				if (!(executionTime instanceof Date)) executionTime = new Date(executionTime);
				executionTime = executionTime.getTime();
			}
			if (!executionTime || executionTime - now < 500) {
				// 	execute it directly
				tracer && tracer("Execute immediately " + fullKey + " " + executionTime);
				executeImmediately.push(item);
				tasks[fullKey] = null;
			} else {
				item = [item[0], executionTime, item[2]];
				tasks[fullKey] = item;
			}
		});
		executeImmediately.forEach(function(item) {
			_execute(!_, event, item[0], item[2]);
		});
	};
	var instances = _getInstances(_); // search for all instances
	instances.forEach_(_, function(_, instance) {
		var key = instance.key(_);
		// only look for correct instances
		var instanceEvent = instance.notificationEvent(_);
		var instanceDescription = instanceEvent ? instanceEvent.code(_) + "_" : "";
		if (instanceDescription !== description) {
			_insert(nextEvents, +instance.timestamp(_));
			return;
		}
		var item = tasks[key];
		if (data) {
			if (!item) { // task with same key does not exist any more or has just been executed
				if (mode > 0) instance.deleteSelf(_);
				return;
			}
			// update instance
			if (mode > 0) {
				instance.timestamp(_, "" + item[1]);
				instance.parameters(_, item[2]);
				instance.save(_);
			}
		}
		_insert(nextEvents, +item[1]);
		tasks[key] = null;
		return;
	});
	// new tasks for database
	Object.keys(tasks).forEach_(_, function(_, key) {
		var item = tasks[key];
		if (!item) return;
		if (mode > 0) {
			var instance = entity.createInstance(_, db, null);
			instance.timestamp(_, "" + item[1]);
			if (event) instance.notificationEvent(_, event);
			instance.key(_, key);
			instance.parameters(_, item[2]);
			instance.save(_);
		}
		_insert(nextEvents, +item[1]);
	});
	if (nextEvents.length > 0) {
		var nextExecution = nextEvents[0] - Date.now();
		if (nextExecution < 500) {
			_read(!_);
		} else {
			timeoutFunction = setTimeout(_ << function(_) {
				_read(_);
			}, nextExecution);
		}
		tracer && tracer("Next execution " + new Date(+nextEvents[0]));
	}
	if (mode > 1) _notifyOthers(_);
};

function _notifyOthers(_) {
	if ("mockServer" in config) {
		var options = {
			path: "/nannyCommand/notifyAll/notificationAll",
			method: "PUT",
			hostname: "",
			port: 0,
			headers: {}
		};
		options.headers[mock.BALANCER_HEADER] = config.port;
		try {
			config.mockServer.mockClient.simpleRequest(options, "OK", _);
		} catch (e) {
			tracer && tracer("Error " + e);
		}
	}
}


// read all instances from database or all with a given time

function _getInstances(_, time, key) {
	if (!db) {
		db = adminHelper.getCollaborationOrm(_);
	}
	if (!entity) {
		entity = db.model.getEntity(_, "notificationTime");
	}
	// fetch user
	var whereClause;
	if (time) {
		whereClause = '(timestamp eq "' + time + '")';
	} else if (key) {
		whereClause = '(key eq "' + key + '")';
	}
	return db.fetchInstances(_, entity, {
		sdataWhere: whereClause
	});
}

// read list of future events, lock the corresponding instances in the database

function _read(_) {
	var now = Date.now();
	timeoutFunction = null;
	while (nextEvents.length > 0) {
		if (nextEvents[0] - now > 500) break;
		var nextEvent = nextEvents.shift();
		var instances = _getInstances(_, nextEvent);
		instances.forEach_(_, function(_, instance) {
			try {
				tracer && tracer("Before lock " + new Date());
				instance.lockInstance(_);
				try {
					var event = instance.notificationEvent(_);
					_execute(!_, event, instance.key(_), instance.parameters(_));
					instance.deleteSelf(_);
				} catch (e) {
					console.error("Error in execution " + e);
				} finally {
					tracer && tracer("Before unlock " + new Date());
					instance.unlockInstance(_);
				}
			} catch (e1) {
				tracer && tracer("Instance locked: " + e1);
			}
		});
	}
	if (nextEvents.length > 0) {
		timeoutFunction = setTimeout(_ << function(_) {
			_read(_);
		}, nextEvents[0] - now);
	}
}

// execute a single event

function _execute(_, event, key, parameters) {
	tracer && tracer("Execute " + key);
	if (testOutput) {
		testOutput.push(parameters.test);
		return;
	}
	event.fire(_, key, parameters);
}









exports.entity = {
	$titleTemplate: "Notification time",
	$lockType: "pessimist",
	$valueTemplate: "{key}",
	$properties: {
		timestamp: {
			$title: "TS",
			$isMandatory: true
		},
		key: {
			$title: "Key"
		},
		parameters: {
			$title: "Parameters",
			$type: "json"
		}
	},
	$relations: {
		notificationEvent: {
			$title: "Notification event",
			$type: "notificationEvent"
		}
	}
};