"use strict";

var sys = require("util");
var integrate = require("syracuse-patch/lib/patch");
var write = require("syracuse-patch/lib/write");
var fs = require('fs');
var os = require('os');
// semaphore file
var sem = "semaphore.bbb"


			
exports.entity = {
	$isPersistent: false,
	$autoRecreateWorkingCopy: true,
	$properties: {
		data: {
			$title: "Patch data",
		},
		patchFile: {
			$title: "Patch file name",
			$default: os.tmpDir()+"/patch.dat"
		}		
	},
	$titleTemplate: "Patch integration",
    $valueTemplate: "Patch integration",
    $descriptionTemplate: "Patch integration",
    $functions: {
    },
	$services: {
	    $integratePatch: {
			$method : "PUT",
			$isMethod : true,
			$title : "Integrate patch",
			$execute : function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || {};
				if (!fs.existsSync(sem)) {
					fs.appendFile(sem, "A", _);
					try {
						integrate.patch(".", instance.patchFile(_), _);
						instance.$diagnoses.push({severity: "info", message: "OK"});
					} catch (e) {
						console.log("Error "+e);
						instance.$diagnoses.push({severity: "error", message: ""+e})
					} finally {
						write.unlink(sem, _);
					}
					console.log("End");
				} else {
					instance.$diagnoses.push({severity: "error", message: "Semaphore exists - parallel invocation"});
					console.log("Parallel");
				}
			}
		},
	    $integrityCheck: {
			$method : "PUT",
			$isMethod : true,
			$title : "Check integrity",
			$execute : function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || {};
				if (!fs.existsSync(sem)) {
					fs.appendFile(sem, "A", _);
					try {
						var errors = write.checkChecksumsV(".", _);
						if (errors.length > 0) {
							for (var i = 0; i < errors.length; i++) {
								instance.$diagnoses.push({severity: "error", message: errors[i]});
							}
						} else
							instance.$diagnoses.push({severity: "info", message: "OK"});
					} finally {
						write.unlink(sem, _);
					}
				} else {
					instance.$diagnoses.push({severity: "error", message: "Semaphore exists - parallel invocation"});
					console.log("Parallel");
				}
			}
		},
	    $metaData: {
			$method : "PUT",
			$isMethod : true,
			$title : "Get version metadata",
			$execute : function(_, context) {
				instance.$diagnoses = instance.$diagnoses || {};
				if (!fs.existsSync(sem)) {
					fs.appendFile(sem, "A", _);
					try {
						var version = JSON.parse(fs.readFile(path + "/" + write.VERSION_FILE, "utf8", _));
						for (var key in version)
							instance.$diagnoses.push({severity: "info", message: key+": "+version[key]});
					} catch (e) {
						instance.$diagnoses.push({severity: "error", message: "Cannot read version information "+e});						
					} finally {
						write.unlink(sem, _);
					}
				} else {
					instance.$diagnoses.push({severity: "error", message: "Semaphore exists - parallel invocation"});
					console.log("Parallel");
				}
			}
		},
		$deleteSemaphore: {
			$method : "PUT",
			$isMethod : true,
			$title : "Delete Semaphore",
			$execute : function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || {};
				try {
					write.unlink(sem, _);
					instance.$diagnoses.push({severity: "info", message: "OK1"});					
				} catch (e) {
					instance.$diagnoses.push({severity: "error", message: e})
					console.log("Error when deleting semaphore "+e)
				}
				console.log("Deleted2");
			}
		}
	},
};