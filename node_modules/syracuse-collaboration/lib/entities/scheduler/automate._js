"use strict";

var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");

// this object has the UUID's of the scheduled instances as keys and the corresponding timers as values. So it is possible to
// detect whether an instance has already been scheduled, and it will not be executed twice. When an automate is saved (and therefore
// scheduled) and it is already in a timer, the first timer will be deleted.
// This is some kind of workaround - the final solution should be to delegate all scheduling to the scheduler and just compute the
// new scheduling times (and not use setTimeout here). This will require also changes in objectActionsRunner and other code.
// This is necessary in spite of _timerId, because when an instance is changed and saved again, it will be a new object, and _timerId
// is not available any more, but it will still be available in the global object scheduledInstances.
var scheduledInstances = {};


function _automateRun(automate) {
	// I'm here because of the timer event so remove the id
	automate._timerId = null;
	//
	automate.run(!_);
}

exports.entity = {
	//	_tracer: console.log,
	$titleTemplate: "Automate",
	$valueTemplate: "{description}",
	$helpPage: "Administration-reference_Scheduler",
	$properties: {
		description: {
			$title: "Automate",
			$isMandatory: true,
			$linksToDetails: true,
			$isLocalized: true
		},
		lastStart: {
			$title: "Last started",
			$type: "datetime",

			$isNullable: true,
			$isDisabled: true
		},
		lastEnd: {
			$title: "Last ended",
			$type: "datetime",

			$isNullable: true,
			$isDisabled: true
		},
		status: {
			$title: "Status",
			$enum: [{
				$value: "inactive",
				$title: "Planned"
			}, {
				$value: "running",
				$title: "Running"
			}, {
				$value: "error",
				$title: "Error"
			}, ],
			$default: "inactive",
			$isDisabled: true
		}
	},
	$relations: {
		automateEvents: {
			$title: "Events",
			$type: "automateEvents",
			$isChild: true
		},
		automateTasks: {
			$title: "Tasks",
			$type: "automateTasks",
			$isChild: true
		}
	},
	$functions: {
		scheduleNextRun: function(_) {
			var tracer = this.getEntity(_)._tracer;
			if (this._timerId) {
				tracer && tracer("automate.scheduleNextRun: clearing timer");
				this.clearTimer();
			}
			// min
			var nextRun = this.automateEvents(_).toArray(_).map_(_, function(_, e) {
				return e.suspended(_) ? null : e.nextRun(_);
			}).reduce_(_, function(_, prev, e) {
				return (!e || (prev && (prev.compare(e) < 0)) ? prev : e);
			}, null);
			//
			tracer && tracer("automate.scheduleNextRun: computed next run: " + (nextRun ? nextRun.toString() : "null"));
			var diff = nextRun && nextRun.millisDiff(datetime.now());
			if (this.$uuid in scheduledInstances) {
				clearTimeout(scheduledInstances[this.$uuid]);
				scheduledInstances[this.$uuid] = this._timerId = undefined; // do not delete key - new value will be assigned very soon
			}
			if (diff) {
				if (diff > 0) this._timerId = setTimeout(_automateRun, diff, this);
				else
				// small timer to be sure that the next run won't be computed the same ms
					this._timerId = setTimeout(_automateRun, 100, this);
				//this.run(_);
				tracer && tracer("automate.scheduleNextRun: timer delay: " + diff);
			}
			scheduledInstances[this.$uuid] = this._timerId;
		},
		clearTimer: function() {
			this._timerId && clearTimeout(this._timerId);
			delete scheduledInstances[this.$uuid];
			//
			delete this._timerId;
		},
		run: function(_, diagnoses, track) { // track: track some information. If there is an error during automate execution, the error is returned
			var tracer = this.getEntity(_)._tracer;
			var error;
			var self = this;
			tracer && tracer("Scheduler running: start");
			self.status(_, "running");
			self.lastStart(_, datetime.now());
			self.save(_);
			track && track(locale.format(module, "trackRun"), 1);
			//
			try {
				self.automateTasks(_).toArray(_).forEach_(_, function(_, t) {
					if (!t.suspended(_)) t.run(_, diagnoses);
				});
				//
				track && track(locale.format(module, "trackOK"), 99);
				self.status(_, "inactive");
			} catch (e) {
				track && track(locale.format(module, "trackError"), 99);
				self.status(_, "error");
				error = e;
				diagnoses && diagnoses.push({
					$severity: "error",
					$message: e.message,
					$stackTrace: e.safeStack
				});
			}
			self.lastEnd(_, datetime.now());
			// update next run 
			self.automateEvents(_).toArray(_).forEach_(_, function(_, e) {
				e.nextRun(_, e.getNextRun(_));
			});
			self.save(_);
			self.getAllDiagnoses(_, diagnoses);
			track && track(locale.format(module, "trackFinished", self.status(_)), 100);
			// aftersave will schedule next run so commented here
			// scheduling at the end of the function will accumulate events for long executions: ok
			//self.scheduleNextRun(_);
			tracer && tracer("Scheduler running: end");
			return error;
		}
	},
	$events: {
		$afterSave: [

			function(_, instance) {
				// reschedule as timer events might have changed
				// don't reschedule running schedulers as next run of timer events might not have been computed yet -> errorneous schedule
				if (instance.status(_) !== "running") instance.scheduleNextRun(_);
			}
		]
	},
	$services: {
		executeNow: {
			$title: "Execute now",
			$method: "POST",
			$isMethod: true,
			$invocationMode: "async",
			$overridesReply: true,
			$execute: function(_, context, instance) {
				var t = context && context.tracker;

				function _track(phase, progress) {
					if (t) {
						t.phase = phase;
						t.progress = progress;
					}
				}
				if (t) {
					t.phaseDetail = "-";
				}
				var diags = [];
				var diags = t ? (t.$diagnoses = t.$diagnoses || []) : (instance.$diagnoses = instance.$diagnoses || []);
				var diags2 = [];
				_track(locale.format(module, "trackStart"), 0);
				var error = instance.run(_, diags2, _track);
				diags2.forEach(function(diag) {
					diags.push(diag);
				});
				if (error) throw error;
				return instance;
			}
		}
	}
};