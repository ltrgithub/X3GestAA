"use strict"

var datetime = require("syracuse-core/lib/types/datetime");

function _automateRun(automate) {
	// I'm here because of the timer event so remove the id
	delete automate._timerId;
	//
	automate.run();
}

exports.entity = {
	$titleTemplate: "Automate",
	$valueTemplate: "{description}",
	$properties: {
		description: {
			$title: "Automate",
			$isMandatory: true,
			$linksToDetails: true
		},
		lastStart: {
			$title: "Last started",
			$type: "datetime",
			
				$isNullable: true
			,
			$isDisabled: true
		},
		lastEnd: {
			$title: "Last ended",
			$type: "datetime",
			
				$isNullable: true
			,
			$isDisabled: true
		},
		status: {
			$title: "Status",
			$enum: [{
				$value: "inactive",
				$title: "Planned"
			},{
				$value: "running",
				$title: "Running"
			},{
				$value: "error",
				$title: "Error"
			},],
			$default: "inactive",
			$isDisabled: true
		}
	},
	$relations: {
		automateEvents: {
			$title: "Events",
			$type: "automateEvents",
			$isChild: true
		},
		automateTasks: {
			$title: "Tasks",
			$type: "automateTasks",
			$isChild: true
		}
	},
	$functions: {
		scheduleNextRun: function(_) {
			if(this._timerId)
				this.clearTimer();
			// min
			var nextRun = this.automateEvents(_).toArray(_).map_(_, function(_, e) {
//				return e.suspended(_) ? null : e.getNextRun(_);
				return e.suspended(_) ? null : e.nextRun(_);
			}).reduce_(_, function(_, prev, e) {
				return (!e || (prev && (prev.compare(e) < 0)) ? prev : e);
			});
			//console.log("will run at (56): " + nextRun.toString());
			//
			var diff = nextRun && nextRun.millisDiff(datetime.now());
			if(diff) {
				if(diff > 0)
					this._timerId = setTimeout(_automateRun, nextRun.millisDiff(datetime.now()), this);
				else
					// small timer to be sure that the next run won't be computed the same ms
					this._timerId = setTimeout(_automateRun, 100, this);
					//this.run(_);
			}
		},
		clearTimer: function() {
			this._timerId && clearTimeout(this._timerId);
			//
			delete this._timerId;
		},
		run: function(_) {
			var self = this;
			self.status(_, "running");
			self.lastStart(_, datetime.now());
			self.save(_);
			//
			try {
				self.automateTasks(_).toArray(_).forEach_(_, function(_, t) {
					if(!t.suspended(_))
						t.run(_);
				});
				//
				self.status(_, "inactive");
			} catch(e) {
				self.status(_, "error");
			}
			self.lastEnd(_, datetime.now());
			// update next run
			self.automateEvents(_).toArray(_).forEach_(_, function(_, e) {
				e.nextRun(_, e.getNextRun(_));
			});
			self.save(_);
			// scheduling at the end of the function will accumulate events for long executions: ok
			//self.scheduleNextRun(_);
		}
	},
	$events: {
		$afterSave: [function(_, instance) {
			// reschedule as timer events might have changed
			instance.scheduleNextRun(_);
		}]
	}
}