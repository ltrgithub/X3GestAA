"use strict";

var datetime = require("syracuse-core/lib/types/datetime");

function _automateRun(automate) {
	// I'm here because of the timer event so remove the id
	automate._timerId = null;
	//
	automate.run(!_);
}

exports.entity = {
	//	_tracer: console.log,
	$titleTemplate: "Automate",
	$valueTemplate: "{description}",
	$helpPage: "Workbench-reference-Scheduler",
	$properties: {
		description: {
			$title: "Automate",
			$isMandatory: true,
			$linksToDetails: true,
			$isLocalized: true
		},
		lastStart: {
			$title: "Last started",
			$type: "datetime",

			$isNullable: true,
			$isDisabled: true
		},
		lastEnd: {
			$title: "Last ended",
			$type: "datetime",

			$isNullable: true,
			$isDisabled: true
		},
		status: {
			$title: "Status",
			$enum: [{
				$value: "inactive",
				$title: "Planned"
			}, {
				$value: "running",
				$title: "Running"
			}, {
				$value: "error",
				$title: "Error"
			}, ],
			$default: "inactive",
			$isDisabled: true
		}
	},
	$relations: {
		automateEvents: {
			$title: "Events",
			$type: "automateEvents",
			$isChild: true
		},
		automateTasks: {
			$title: "Tasks",
			$type: "automateTasks",
			$isChild: true
		}
	},
	$functions: {
		scheduleNextRun: function(_) {
			var tracer = this.getEntity(_)._tracer;
			if (this._timerId) {
				tracer && tracer("automate.scheduleNextRun: clearing timer");
				this.clearTimer();
			}
			// min
			var nextRun = this.automateEvents(_).toArray(_).map_(_, function(_, e) {
				return e.suspended(_) ? null : e.nextRun(_);
			}).reduce_(_, function(_, prev, e) {
				return (!e || (prev && (prev.compare(e) < 0)) ? prev : e);
			}, null);
			//
			tracer && tracer("automate.scheduleNextRun: computed next run: " + (nextRun ? nextRun.toString() : "null"));
			var diff = nextRun && nextRun.millisDiff(datetime.now());
			if (diff) {
				if (diff > 0) this._timerId = setTimeout(_automateRun, diff, this);
				else
				// small timer to be sure that the next run won't be computed the same ms
					this._timerId = setTimeout(_automateRun, 100, this);
				//this.run(_);
				tracer && tracer("automate.scheduleNextRun: timer delay: " + diff);
			}
		},
		clearTimer: function() {
			this._timerId && clearTimeout(this._timerId);
			//
			delete this._timerId;
		},
		run: function(_, diagnoses) {
			var tracer = this.getEntity(_)._tracer;
			var self = this;
			tracer && tracer("Scheduler running: start");
			self.status(_, "running");
			self.lastStart(_, datetime.now());
			self.save(_);
			//
			try {
				self.automateTasks(_).toArray(_).forEach_(_, function(_, t) {
					if (!t.suspended(_)) t.run(_, diagnoses);
				});
				//
				self.status(_, "inactive");
			} catch (e) {
				self.status(_, "error");
				diagnoses && diagnoses.push({
					severity: "error",
					message: e.message + "\n" + e.stack
				});
			}
			self.lastEnd(_, datetime.now());
			// update next run
			self.automateEvents(_).toArray(_).forEach_(_, function(_, e) {
				e.nextRun(_, e.getNextRun(_));
			});
			self.save(_);
			// aftersave will schedule next run so commented here
			// scheduling at the end of the function will accumulate events for long executions: ok
			//self.scheduleNextRun(_);
			tracer && tracer("Scheduler running: end");
		}
	},
	$events: {
		$afterSave: [
			function(_, instance) {
				// reschedule as timer events might have changed
				// don't reschedule running schedulers as next run of timer events might not have been computed yet -> errorneous schedule
				if (instance.status(_) !== "running") instance.scheduleNextRun(_);
			}
		]
	},
	$services: {
		executeNow: {
			$title: "Execute now",
			$method: "POST",
			$isMethod: true,
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				instance.run(_, instance.$diagnoses);
			}
		}
	}
};