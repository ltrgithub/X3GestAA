"use strict";
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var util = require('util');
var config = require('syracuse-main/lib/nodeconfig').config;
var Certificate = require("jsx509").Certificate;
var integrity = require("jsx509").integrity;
var mock = require('syracuse-load/lib/mock');
var certTools = require('syracuse-load/lib/certTools')
var crypto = require('crypto');
var os = require('os');
var tracer = null;
// write the changes to the certificate directory - either via the nannies or directly using parseRequestCert
function _doChange(ca, server, data, _) {
	if (!config.collaboration.certdir) throw new Error(locale.format(module, "noCertdir"));
	if (config.mockServer) {
		var options = { path: "/nannyCommand/updateCertificate", method: "POST", headers: {}};
		options.headers[mock.BALANCER_HEADER] = server ? server.hostname(_) : "*"; // notify all servers
		try {
			var result = mock.simpleRequest(config.mockServer.mockClient, options, JSON.stringify(data), _)		
		} catch (e) {
			if (e instanceof Error) throw e;
			else
				throw new Error(e);
		}
	} else {
		// write directly into certificate directory
		if (server) {
			var targetHost = server.hostname(_)
			if (targetHost && targetHost !== os.hostname()) throw new Error(locale.format(module, "wrongHost", targetHost));			
		}
		certTools.parseRequestCert(_, data, null, null, config.collaboration.certdir+"/"+os.hostname().toLowerCase()+"/", null);
	} 

}

function deleteData(instance, ca, _) {
	if (instance.internal(_)) {
		throw new Error(locale.format(module, "deleteInternal"))
		return;
	}
	var data = [{name: instance.name(_), ca: ca, del: true}];
	var server;
	if (!ca) {
		server = instance.server(_);
	}
	_doChange(ca, server, data, _);
}


/// fillInstance: reads PEM certificate information and fills in the distinguished name of issuer and subject to the instance
/// ca: do not treat key and passphrase (for CA Certificates)
function fillInstance(instance, ca, _) {
	var pemCertificate;
	var pemKey;
	var passphrase;
	var cert = instance.certificate(_);
	if (cert.fileExists(_)) {
		pemCertificate = cert.createReadableStream(_).read(_, -1).toString();
		var hash = crypto.createHash('md5');
		hash.update(pemCertificate, "utf8");
		instance.certificateHash(_, hash.digest('hex'));			
	} else {
		if (!instance.certificateHash(_))
			throw new locale.format(module, "noCert");
	}
	if (!ca) {
		var key = instance.key(_);
		if (key.fileExists(_)) {
			pemKey = key.createReadableStream(_).read(_, -1).toString();
			instance.keyExists(_, true);
		}
		passphrase = instance.pass(_);
		
	}
	// Do not check CA certificates because they may not be there		
	var result = integrity(pemCertificate, pemKey, passphrase)
	if (result.error) {
		throw new Error(result.error);
	}		
	var certificate = result.cert;
	instance.subjectDn(_, certificate ? certificate.subjectDn: "");
	instance.issuerDn(_, certificate ? certificate.issuerDn: "");
	if (certificate) {
		instance.notBefore(_, new datetime.Datetime(certificate.notBefore))
		instance.notAfter(_, new datetime.Datetime(certificate.notAfter))		
	}	
	if (pemCertificate) {
		cert.deleteFile(_);
	}
	var server;
	var data = {name: instance.name(_), ca: ca, cert: pemCertificate, key: pemKey};
	if (!ca) {
		server = instance.server(_);
		data.pass = instance.pass(_);
		tracer && tracer("Certificate for server "+server)
	}
	// transmit data only when either certificate or key is available
	if (data.cert || data.key) _doChange(ca, server, [data], _);
	if (!ca) {
		if (pemKey) key.deleteFile(_);		
		instance.pass(_, "");
	}
}

exports.fillInstance = fillInstance;
exports.deleteData = deleteData;


exports.entity = {
		$properties: {
			name: {
				$title: "Name",
				$isMandatory: true,
				$isUnique: true,
				$isReadOnly: function(_, instance) {
					return !instance.$created;
				},
				$pattern: /^[a-z_.]+$/
			},
			internal: {
				$title: "internal",
				$isReadOnly: true,
				$type: "boolean"				
			},
			certificate: {
				$title: "Certificate",
				$type: "binary",
				$storage: "db_file",
				$isReadOnly: function(_, instance) {
					return instance.internal(_);
				},
				$isMandatory: function(_, instance) {
					return instance.$created;
				}
			},
			keyExists: {
				$title: "Private key exists",
				$type: "boolean",
				$isReadOnly: true
			},
			key: {
				$title: "Private key",
				$type: "binary",
				$storage: "db_file", 
				$isReadOnly: function(_, instance) {
					return instance.internal(_);
				}
			},
			pass: {
				$title: "Passphrase",
				$isReadOnly: function(_, instance) {
					return instance.internal(_);
				}
			},
			subjectDn: {
				$title: "Distinguished name",
				$isReadOnly: true
			},
			issuerDn: {
				$title: "Issuer distinguished name",
				$isReadOnly: true
			},
			notBefore: {
				$title: "Valid from",
				$isReadOnly: true,
				$type: "datetime"
			},
			notAfter: {
				$title: "Valid until",
				$isReadOnly: true,
				$type: "datetime"
			},
			certificateHash: {
				$title: "Hash of certificate",
				$isReadOnly: true,
				$isHidden: true
			}
		},
		$titleTemplate: "Certificates",
		$valueTemplate: "{name}",
		$events: {
			$beforeSave: [function(_, instance) {
				fillInstance(instance, false, _);
			}],
			$afterSave: [function(_, instance) { // update nanny processes unless special marker property has been set
				if (config.mockServer) {
					var options = { path: "/nannyCommand/notifyNannies/update", method: "PUT", hostname: "", port: 0};
					try {
						console.log(mock.simpleRequest(config.mockServer.mockClient, options, null, _));			
					} catch (e) {
						console.log("Error "+e);
					}
				}
			}]
		},
		$searchIndex: {
			$fields: ["name"]
		},
		$functions: {
			$onDelete: function(_) {
				// delete contents in file system
				deleteData(this, false, _);
			}
		},
		$defaultOrder: [["name", true]],
		$services: {
		},
		$relations: {
			caCertificates: {
				$title: "CA Certificates",
				$type: "caCertificates",
				$inv: "certificate",
				$isReadOnly: function(_, instance) {
					return true;
					// return instance.internal(_);
				}
			},
			server: {
				$title: "Server",
				$type: "host",
				$isReadOnly: function(_, instance) {
					return instance.internal(_) || !instance.$created;
				}
			}	
		},
		$actions: {
			$save: function(_, instance) {
				var r = {};
				if (config.mockServer && instance.$snapshot && !instance.$created) r.$confirm = locale.format(module, "maybeRestart")
				return r;
			}
		}
}