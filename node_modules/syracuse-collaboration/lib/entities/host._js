"use strict";
var config = require('syracuse-main/lib/nodeconfig').config;
var mock = require('syracuse-load/lib/mock');
var util = require('util');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var clusterData;

// collect up-to-date status information from servers including ping times to child processes
exports.collectClusterData = function(_) {
	if (config.mockServer) {
		var options = { path: "/nannyCommand/notifyNannies/children", method: "GET"};
		try {
			var text = mock.simpleRequest(config.mockServer.mockClient, options, null, _)
			console.log("TEXT from notifyNannies: "+text)
			var lines = text.split(/[\r\n]+/);
			lines.forEach(function(line) {
				if (line.charAt(0) === '[') {
					clusterData = JSON.parse(line);
				}
			})
			lines.forEach(function(line) {
				if (line.charAt(0) === '{') {
					var childData = JSON.parse(line);
					var hostname = childData.hostname;
					clusterData.forEach(function(host) {
						if (host.hostname === hostname && childData.port) {
							var info = childData.port+" requests "+ childData.requests+" ping "+childData.message+"ms; ";
							host.childInformation = (host.childInformation || "") + info
						}
					});
				}
			})
			// clusterData = JSON.parse(text);
			console.log("RES1 "+util.format(clusterData))
			return clusterData;
		} catch (e) {				
			console.error("Error "+e);
			return null;
		}
	}
	return null;	
}

exports.entity = {
	$canDelete: false,
	$canCreate: false,
	$properties: {
		hostname: {
			$title: "Host name",
			$isMandatory: true,
			$isUnique: true
		},
		children: {
			$title: "Number of child processes",
			$isMandatory: true,
			$type: "integer" 			
		},
		deactivated: {
			$title: "deactivated",
			$type: "boolean",
			$default: false
		},
		started: {
			$title: "started",
			$type: "boolean",
			$default: false,
			$isReadOnly: true,
		},
		status: {
			$title: "Status",
			$isReadOnly: true,
			$type: "integer",
			$default: -1000,
			$enum: [{
				$value: 4,
				$title: "finishing"
			}, {
				$value: 3,
				$title: "OK"
			}, {
				$value: 2,
				$title: "starting"
			}, {
				$value: 1,
				$title: "init"
			}, {
				$value: 0,
				$title: "inactive"
			}, {
				$value: -1,
				$title: "low version"
			}, {
				$value: -2,
				$title: "wrong version"
			}, {
				$value: -3,
				$title: "time difference"
			}, {
				$value: -4,
				$title: "respawn limit"
			}, {
				$value: -5,
				$title: "unknown"
			}, {
				$value: -6,
				$title: "unreachable"
			}, {
				$value: -7,
				$title: "not started"
			}, {
				$value: -1000,
				$title: "-"
			}],
			$compute: function(_, instance) {
				return -1000;
			}

		},
		tcpHostName: {
			$title: "TCP host name"
		},
		version: {
			$title: "code version",
			$isReadOnly: true,
			$default: "-"
		},
		pid: {
			$title: "PID",
			$type: "integer",
			$default: 0,
			$isReadOnly: true
		},
		respawnCount: {
			$title: "Respawn limit",
			$type: "integer",
			$default: 10,			
		},
		respawnTime: {
			$title: "Respawn time",
			$type: "integer",
			$default: 120
		},
		returnRequestTimeout: {
			$title: "Return request timeout",
			$type: "integer",
			$default: 20
		},
		childInformation: {
			$title: "Child process information",
			$isReadOnly: true,
			$compute: function(_, instance) {
				return "";
			}
		},
		patchStatus: {
			$title: "Patch status",
			$isReadOnly: true,
			$isHidden: true
		},
	},
	$titleTemplate: "Syracuse Hosts",
    $valueTemplate: "{hostname}",
    $relations: {
    	connectionData: {
   			$title: "Connections",
    		$type: "connectionDatas",
    		$isChild: true,
    		$isMandatory: true
    	}
    },
	$fetchInstances: function(_, context, parameters) {
		var self = this;
		var db = adminHelper.getCollaborationOrm(_);
		var hosts = db.fetchInstances(_, db.model.getEntity("host"), {});
		if (config.mockServer) {
			var options = { path: "/nannyCommand/infojson", method: "GET", hostname: "", port: 0};
			try {
				var text = mock.simpleRequest(config.mockServer.mockClient, options, null, _)
				clusterData = JSON.parse(text);
				console.log("RES "+util.format(clusterData))
			} catch (e) {				
				console.error("Error "+e);
			}
		}
		return hosts;
	},
    $functions: {
    	$setId: function(_, context, id) {
    		console.log("SETID "+id)
    	},
    	$serialize: function(_) {
			// dynamicaly define the $select link
			var self = this;
			var res = self._internalSerialize(_);
			// console.log("SERIALIZE "+("mockDataChange" in self))			
			if (clusterData) {
				var currentHosts = clusterData;
				var j = currentHosts.length;
				while (--j >= 0) {
					if (currentHosts[j].hostname === res.hostname) {
						console.log("SET")
						var current = currentHosts[j]; 
						res.version = current.version;
						res.status = current.status;
						if (current.childInformation) res.childInformation = current.childInformation;
						break;
					}
				}
			} else {
				res.status = -1000; // dummy value
				res.childInformation = "";
			}
			// console.log("SER "+util.format(res))			
			return res;
    	}
    },
	$services: {
		runtime: {
			$method: "post",
			$title: "Runtime information",
			$isMethod: true,
			$execute: function(_, context, instance) {
				clusterData = exports.collectClusterData(_);
			}
		},
		details: {
			$method: "post",
			$title: "Detail information",
			$isMethod: true,
			$execute: function(_, context, instance) {
				if (config.mockServer) {
					var options = { path: "/nannyCommand/notifyNannies/details", method: "GET", hostname: "", port: 0};
					try {
						var text = mock.simpleRequest(config.mockServer.mockClient, options, null, _)
						console.log("TEXT "+text)
						var lines = text.split(/[\r\n]+/);
						lines.forEach(function(line) {
							if (line.charAt(0) === '[') {
								clusterData = JSON.parse(line);
							}
						})
						lines.forEach(function(line) {
							if (line.charAt(0) === '{') {
								var childData = JSON.parse(line);
								var hostname = childData.hostname;
								clusterData.forEach(function(host) {
									if (host.hostname === hostname && childData.port) {
										var info = childData.port+" data "+childData.message+"; ";
									host.childInformation = (host.childInformation || "") + info
									}
								});
							}
						})
						// clusterData = JSON.parse(text);
						console.log("RES2 "+util.format(clusterData))
					} catch (e) {				
						console.error("Error "+e);
					}
				}
			}
		}
	},
	$events: {
		$beforeSave: [function(_, instance) {
			// there must be at least one active connection
			var connectionData = instance.connectionData(_).toArray(_, true);
			if (connectionData.length === 0) {
				instance.$addError("noConnection$#$No connection data");
				return;
			}
			if (!connectionData[0].active(_)) {
				instance.$addError("firstConnActive$#$First connection must be active");
				return;
			}
			var ports = [];
			connectionData.forEach_(_, function(_, conn) {
				var port = conn.port(_);
				if (ports.indexOf(port) >= 0) {
					instance.$addError("doublePort$#$Two connections with same port "+port);
					return;
				};
				ports.push(port);
				
			});
		}],
		$afterSave: [function(_, instance) { // update nanny processes unless special marker property has been set
			if (instance.getAllDiagnoses(_).some(function(d) {
				return d.severity === "error";
			})) {
				return; // no action in case of errors
			}
			if (config.mockServer && !instance.syracuseNoNotifyMarker) {
				var options = { path: "/nannyCommand/notifyNannies/update", method: "PUT", hostname: "", port: 0};
				try {
					console.log(mock.simpleRequest(config.mockServer.mockClient, options, null, _));			
				} catch (e) {
					console.log("Error "+e);
				}

			}
		}]
	},
	$searchIndex: {
		$fields: ["hostname"]
	},
	$defaultOrder: [["hostname", true]],
};
