"use strict";

var sys = require("util");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

// dummy key for LDAP user data to indicate that they have already been used to update at least one instance of the user entity
// and therefore are not for adding a new user to the user entity.
var USED = "##########";
 
 
/// obtain translation table from standard translation table and syncTranslationTable attribute
function getTranslationTable(_, instance) {
	var translateTable = { "authenticationName": "sAMAccountName", "firstName": "givenName", "lastName": "sn", email: "mail" };
	var instanceTranslationTable = instance.syncTranslationTable(_) || "";
	// split into key:value parts
	var parts = instanceTranslationTable.split(/\s*,\s*/);
	for (var i=parts.length-1; i>= 0; i--) {
	    // split a key:value part
	    var details = /(\w+)\s*\:\s*(\w+)/.exec(parts[i]);
	    if (details) {
			translateTable[details[1]] = details[2];
		}
	}
	return translateTable;
};
		
exports.getTranslationTable = getTranslationTable;
	
/// get all users from LDAP.
/// Arguments: ldap entity instance, translateTable obtained from getTranslationTable
function getAllUsers(instance, translateTable, _) {
	var ldapjs = require("syracuse-ldap").ldapjs;
	var clientOpts = {url: instance.url(_)}; 
	// console.log("URL"+instance.url(_));
	var ldapClient = ldapjs.createClient(clientOpts);
	// console.log("Client created");
	ldapClient.bind(instance.adminDn(_), instance.adminPassword(_), _);
	// console.log("bound");
	try {
	    // !!! _data is not OK
		var res = _ldapSearch(ldapClient, translateTable, instance._data, _);
		return res;
	} finally {
		ldapClient.unbind(_);
	}
}
 
/// function with necessary callbacks to collect the search data
function _ldapSearch(ldapClient, translateTable, config,  cb) {
		// search result: 
		var userEntries = {};
		var loginKey = translateTable.authenticationName; 
		var opts = {filter: config.syncSearchFilter, scope: 'sub'};
		// console.log("OPTIONS"+sys.format(opts));
		ldapClient.search(config.searchBase, opts, function(error, res) {
			if (error) return cb(error);
			res.on('searchEntry', function(entry) {
				var key = entry.object[loginKey];
				userEntries[key] = entry.object; 
			});
			res.on('error', function(err1) {
				return cb(err1); 
			});
			res.on('end', function(result) {
				if (result.status !== 0) {
					return cb("non-zero status from LDAP search: " + result.status);
				}
				return cb(null, userEntries); 
			});
		});
	}


/// update user table from LDAP 
/// Arguments: ldap entity instance, 
/// translateTable obtained from getTranslationTable
/// users: an object with authentication names as keys and LDAP user entries as values
/// diagnoses: warning and error messages
/// del: delete users which are not in LDAP any more (true) or just deactivate them (false)
function updateUsers(_, instance, translateTable, users, diagnoses, del) {
	var l = instance.users(_).toArray(_);
	var cloned = {};
	for (var key in users) 
		cloned[key] = users[key];
	var i;
	for (i=0; i < l.length; i++) {
		var user = l[i];
		var name = user.authenticationName(_) || user.login(_);
		var newValues = cloned[name];
		if (!newValues) { // LDAP entry does not exist any more
			if (del) {
				// console.log("Delete "+name);
				user.deleteSelf(_);
			} else { // just mark the user as inactive
				// console.log("Inactive "+name);
				user.active(_, false);
				user.save(_);
				user.getAllDiagnoses(_, diagnoses);
			}
		} else { // update from LDAP entry
			// console.log("Update "+name);
			for (var key in translateTable) {
				var newValue = newValues[translateTable[key]] || "";
				try {
					if (user[key](_) !== newValue) {
						// console.log(key+"="+newValue);
						user[key](_, newValue);
					}
				} catch (e) {
				if (e instanceof TypeError) {
					delete translateTable[key];
					diagnoses.push({severity: "warning", message: "wrong attribute "+key});
				} else 
					throw e;
					}
				user.active(_, true);
				user.save(_);
				user.getAllDiagnoses(_, diagnoses);
			}
			cloned[name][USED] = 1;
		}
	}	
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity("user");
	// add users which are in LDAP but not yet in user table
	for (var authenticationName in cloned) {
	    if (cloned[authenticationName][USED]) {
			continue;
		}
		var inst = entity.createInstance(_, db, null);
		// console.log("---New instance "+login);
		for (var key in translateTable) {
			try {
				var newValue = cloned[authenticationName][translateTable[key]] || "";
				// console.log(key+"/"+translateTable[key] + "="+newValue);
				inst[key](_, newValue);			
			} catch (e) {
				if (e instanceof TypeError) {
					delete translateTable[key];
					diagnoses.push({severity: "warning", message: "wrong attribute '"+key+"' will be ignored"});
				} else 
					throw e;
			}
		}
		inst.ldap(_, instance);		
		inst.authentication(_, "ldap");
		inst.active(_, true);
		// are there users with the same name as the new user?
		var disturbingUsers = entity.fetchInstances(_, db, { jsonWhere: { login: { $regex: "^"+authenticationName } }});
		var disturbingNames = {};
		// put the names as keys in object
		for (var i = 0; i < disturbingUsers.length; i++) {
			// console.log("DistUser"+disturbingUsers[i].login(_));
			disturbingNames[disturbingUsers[i].login(_)] = 1;
		}		
		if (authenticationName in disturbingNames) {
			// generate new user name
			// this loop is large enough because there can be at most disturbingUsers.length entries
			for (var i = 1; i <= disturbingUsers.length+1; i++) {
				if ((authenticationName+i) in disturbingNames)
					continue;
				inst.login(_, authenticationName+i);
				diagnoses.push({severity: "warning", message: "User name changed from "+authenticationName+" to "+(authenticationName+i)});
				// console.log(sys.format(diagnoses));
				break;
			}
		} else {
			// console.log("Normal User"+authenticationName);
			inst.login(_, authenticationName);
		}
		inst.save(_);
		inst.getAllDiagnoses(_, diagnoses);
	}

};
			
exports.updateUsers = updateUsers;

exports.entity = {
	$properties: {
		name: {
			$title: "Name",
			$isMandatory: true,
            $default: "LDAP",
			$constraints: {
				$isUnique: true,
				$pattern: /^[a-zA-Z]\w*$/
			},
		},
		displayName: {
			$title: "Display Name",
		},
        active: {
           $type: "boolean",
           $title: "Active",
           $default: true
        },
        url: {
           $title: "URL",
           $isMandatory: true
        },
        adminDn: {
           $title: "DN for searching"
        },
        adminPassword: {
           $title: "Password for search DN"
        },
        searchBase: {
           $title: "Search base"
        },
        searchFilter: {
           $title: "Search filter"
        },
        syncSearchFilter: {
           $title: "Sync search filter"
        },
		syncTranslationTable: {
			$title: "Mapping from user attributes to LDAP attributes",
			$constraints: {
				$pattern: /^\s*(?:\w+\s*\:\s*\w+\s*(?:,\s*|$))*$/
			},
		},			
		image: {
			$title: "Image",
			$type: "image",
			$storage: "db_file",
			$capabilities: ""
		}
		
	},
	$titleTemplate: "LDAP",
    $valueTemplate: "{name} {url}",
    $descriptionTemplate: "LDAP {name}",
    $relations: {
        users: {
           $title: "Users",
           $type: "users",
           $inv: "ldap",
           $isComputed: true
        }
    },
	$services: {
		    usersFromLdap : {
			$method : "POST",
			$isMethod : true,
			$title : "Update users from LDAP",
			$execute : function(_, context, instance) {
			var translateTable = getTranslationTable(_, instance);
			var allUsers = getAllUsers(instance, translateTable, _);
			var diagnoses = [];
			updateUsers(_, instance, translateTable, allUsers, diagnoses, false);
			if (diagnoses.length == 0)
			   diagnoses.push({severity: "info", message: "OK"});
			// !!! location should not be necessary, remove it when issue #48 will be resolved
			context.reply(_, 200, {"$diagnoses": diagnoses}, {location: context.baseUrl + "/ldaps?representation=ldap.$query"});
			}
		}
	},
	$defaultOrder: [["name", true]]
    
};