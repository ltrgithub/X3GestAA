"use strict";

var util = require("util");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var ldapjs; 

//dummy key for LDAP user data to indicate that they have already been used to update at least one instance of the user entity
//and therefore are not for adding a new user to the user entity.
var USED = "##########";


/// obtain translation table (user entity attributes to LDAP attributes) from standard translation table and the instance's syncTranslationTable attribute
/// Remark: when the LDAP attribute starts with a single quotation mark, it will be put as text value and not attribute name, and the text will be put literally
///         into the user entity attribute.
function getTranslationTable(_, instance) {
	// no closing quotation mark for title!
	var translateTable = { "authenticationName": "sAMAccountName", "firstName": "givenName", "lastName": "sn", email: "mail", title: "'mr"  };
	var instanceTranslationTable = instance.syncTranslationTable(_) || "";
	// split into key:value parts
	var regex = /(\w+)\s*\:\s*(\w+|'[^']*')/g;
	var r;
	while (r = regex.exec(instanceTranslationTable)) {
		translateTable[r[1]] = r[2].replace(/'$/, ""); // remove trailing quotation mark
	}
	return translateTable;
};

exports.getTranslationTable = getTranslationTable;

/// get all users from LDAP.
/// Arguments: ldap entity instance, translateTable obtained from getTranslationTable
///  translateTable: object which translates user entity attributes into LDAP attributes
///    when this is null, only data of first user will be returned
function getAllUsers(instance, translateTable, _) {
	ldapjs = ldapjs || require("syracuse-ldap").ldapjs;
	var clientOpts = {url: instance.url(_)}; 
	// console.log("URL"+instance.url(_));
	var ldapClient = ldapjs.createClient(clientOpts);
	var filter;
	if (translateTable) {
		filter = instance.syncSearchFilter(_);
	} else {
///   and the search filter is the sync search filter (if available) or the search filter with {{username}} replaced by "*"
		filter = instance.syncSearchFilter(_) || instance.searchFilter(_).replace("{{username}}", "*");
	}
	// console.log("Client created");
	ldapClient.bind(instance.adminDn(_), instance.adminPassword(_), _);
	// console.log("bound");
	try {
		var res = _ldapSearch(ldapClient, translateTable, {filter: filter, base: instance.searchBase(_)}, translateTable ? 0 : 1, _);
		return res;
	} finally {
		ldapClient.unbind(_);
	}
}

/// ## Function getLdapAttributes
/// returns a list of all LDAP attributes for the first user which is searched using the sync search filter (if available) or the search filter
/// Parameters: instance: instance of the LDAP entity of which the data will be taken
function getLdapAttributes(instance, _) {
	var res = getAllUsers(instance, null, _);
	for (var k in res) { // dummy loop: there can only be one key
		return Object.keys(res[k]);
	}
	return [];
}

exports.getLdapAttributes = getLdapAttributes;

/// perform an LDAP search with paged data and limit of results
///  translateTable: translates user entity attributes into LDAP attributes
///  config: has attributes `filter` for search filter, `base` for base DN
///  limit: maximal number of hits which will be retrieved from the server or 0 when there is no limit
function _ldapSearch(ldapClient, translateTable, config, limit, _) {
	var remaining = limit;
/// Remark: the users will be taken with paged results of maximal 50 hits per search
	var MAX_REQUEST = 50;
	var b = new Buffer(0);
	var userEntries = {};
	while (b) {
		b = _ldapSearchInt(userEntries, ldapClient, translateTable, config, b, (limit && remaining < MAX_REQUEST) ? remaining : MAX_REQUEST, _);
		if (b && b.length === 0) return userEntries;
		if (limit) {
			remaining -= MAX_REQUEST;
			if (remaining < 0) remaining = 0;
		}
	}
}


// internal function which performs a single paged LDAP query and provides the Streamline callback
//  parameters (except for parameters of _ldapSearch): 
//   cookie: Buffer which must be empty buffer for first search and buffer returned by previous search for each subsequent search
//           When the returned buffer is empty, there are no more results
//   size: maximal number of hits for this paged search. Value 0 means: stop paged search
function _ldapSearchInt(userEntries, ldapClient, translateTable, config,  cookie, size, cb) {
	// search result: 
	var loginKey = (translateTable ? translateTable.authenticationName : null); 
	var opts = {filter: config.filter, scope: 'sub'};
	var control = new ldapjs.PagedResultsControl({criticality: true, value: {
		size: size,
		cookie: cookie
	}
	});
	ldapClient.search(config.base, opts, control, function(error, res) {
		if (error) return cb(error);
		res.on('searchEntry', function(entry) {
			if (loginKey) {
				var key = entry.object[loginKey];
				userEntries[key] = entry.object; 					
			} else {
				userEntries[""] = entry.object;
			}
		});
		res.on('error', function(err1) {
			return cb(err1); 
		});
		res.on('end', function(result) {
			if (result.status !== 0) {
				return cb(locale.format(module, "statusCode", result.status));
			}
			if (Array.isArray(result.controls)) {
				var l = result.controls.length;
				while (--l >= 0) {
					if (result.controls[l].type === ldapjs.PagedResultsControl.OID) {
						return cb(null, result.controls[l].value.cookie);
					}
				}
			}
			return cb(null, null); 
		});
	});
}



// translates an user entity attribute to the LDAP attribute value
function _newValue(translated, values) {
	if (translated.charAt(0) === "'")
		return translated.substr(1);
	return values[translated] || "";
}


/// update user table from LDAP 
/// Arguments: ldap entity instance, 
/// translateTable obtained from getTranslationTable
/// users: an object with authentication names as keys and LDAP user entries as values
/// diagnoses: warning and error messages
/// del: delete users which are not in LDAP any more (true) or just deactivate them (false)
function updateUsers(_, instance, translateTable, users, diagnoses, del) {
	var l = instance.users(_).toArray(_);
	var cloned = {};
	for (var key in users) 
		cloned[key] = users[key];
	var i;
	for (i=0; i < l.length; i++) {
		var user = l[i];
		var name = user.authenticationName(_) || user.login(_);
		var newValues = cloned[name];
		if (!newValues) { // LDAP entry does not exist any more
			if (del) {
				// console.log("Delete "+name);
				user.deleteSelf(_);
			} else { // just mark the user as inactive
				// console.log("Inactive "+name);
				user.active(_, false);
				user.save(_);
				user.getAllDiagnoses(_, diagnoses);
			}
		} else { // update from LDAP entry
			// console.log("Update "+name);
			for (var key in translateTable) {
				var newValue = _newValue(translateTable[key], newValues);
				try {
					if (user[key](_) !== newValue) {
						// console.log(key+"="+newValue);
						user[key](_, newValue);
					}
				} catch (e) {
					if (e instanceof TypeError) {
						delete translateTable[key];
						diagnoses.push({severity: "warning", message: locale.format(module, "wrongAttribute", key)});
					} else throw e;
				}
				user.active(_, true);
				user.save(_);
				user.getAllDiagnoses(_, diagnoses);
			}
			cloned[name][USED] = 1;
		}
	}	
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity("user");
	// add users which are in LDAP but not yet in user table
	for (var authenticationName in cloned) {
		if (cloned[authenticationName][USED]) {
			continue;
		}
		var inst = entity.createInstance(_, db, null);
		// console.log("---New instance "+login);
		for (var key in translateTable) {
			try {
				var newValue = _newValue(translateTable[key], cloned[authenticationName]);
				// console.log(key+"/"+translateTable[key] + "="+newValue);
				inst[key](_, newValue);			
			} catch (e) {
				if (e instanceof TypeError) {
					delete translateTable[key];
					diagnoses.push({severity: "warning", message: locale.format(module, "wrongAttributeIgnored", key)});
				} else 
					throw e;
			}
		}
		inst.ldap(_, instance);		
		inst.authentication(_, "ldap");
		inst.active(_, true);
		// are there users with the same name as the new user?
		var disturbingUsers = entity.fetchInstances(_, db, { jsonWhere: { login: { $regex: "^"+authenticationName } }});
		var disturbingNames = {};
		// put the names as keys in object
		for (var i = 0; i < disturbingUsers.length; i++) {
			// console.log("DistUser"+disturbingUsers[i].login(_));
			disturbingNames[disturbingUsers[i].login(_)] = 1;
		}		
		if (authenticationName in disturbingNames) {
			// generate new user name
			// this loop is large enough because there can be at most disturbingUsers.length entries
			for (var i = 1; i <= disturbingUsers.length+1; i++) {
				if ((authenticationName+i) in disturbingNames)
					continue;
				inst.login(_, authenticationName+i);
				diagnoses.push({severity: "warning", message: locale.format(module, "userNameChange",authenticationName,(authenticationName+i))});
				// console.log(util.format(diagnoses));
				break;
			}
		} else {
			// console.log("Normal User"+authenticationName);
			inst.login(_, authenticationName);
		}
		inst.save(_);
		inst.getAllDiagnoses(_, diagnoses);
	}

};

exports.updateUsers = updateUsers;

exports.entity = {
		$properties: {
			name: {
				$title: "Name",
				$isMandatory: true,
				$default: "LDAP",

				$isUnique: true,
				$pattern: /^[a-zA-Z]\w*$/
				,
			},
			displayName: {
				$title: "Display Name",
			},
			active: {
				$type: "boolean",
				$title: "Active",
				$default: true
			},
			url: {
				$title: "URL",
				$isMandatory: true
			},
			adminDn: {
				$title: "DN for searching"
			},
			adminPassword: {
				$title: "Password for search DN"
			},
			searchBase: {
				$title: "Search base"
			},
			searchFilter: {
				$title: "Search filter"
			},
			syncSearchFilter: {
				$title: "Sync search filter"
			},
			syncTranslationTable: {
				$title: "Mapping from user attributes to LDAP attributes",

				$pattern: /^\s*(?:\w+\s*\:\s*\w+\s*(?:,\s*|$))*$/
				,
			},			
			image: {
				$title: "Image",
				$type: "image",
				$storage: "db_file",
				$capabilities: ""
			}

		},
		$titleTemplate: "LDAP",
		$valueTemplate: "{name} {url}",
		$descriptionTemplate: "LDAP {name}",
		$relations: {
			users: {
				$title: "Users",
				$type: "users",
				$inv: "ldap",
				$isComputed: true
			}
		},
		$services: {
			usersFromLdap : {
				$method : "PUT",
				$isMethod : true,
				$title : "Update users from LDAP",
				$execute : function(_, context, instance) {
					instance.$diagnoses = instance.$diagnoses || {};
					var translateTable = getTranslationTable(_, instance);
					var allUsers = getAllUsers(instance, translateTable, _);
					updateUsers(_, instance, translateTable, allUsers, instance.$diagnoses, false);
					if (instance.$diagnoses.length == 0) {
						instance.$diagnoses.push({severity: "info", message: locale.format(module, "OK")});
					}
				}
			}
		},
		$searchIndex: {
			$fields: ["name", "displayName"]
		},
		$events: {
			$beforeSave: [function(_, instance) { // named user check
				console.log("LDAP before save")
			}],

			$afterSave: [function(_, instance) { // named user check
				console.log("LDAP after save")
			}]
		},		$defaultOrder: [["name", true]],
		

};