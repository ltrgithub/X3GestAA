"use strict";
const locale = require('streamline-locale');
const globals = require('streamline-runtime').globals;
const helpers = require('syracuse-core').helpers;
const datetime = require('syracuse-core').types.datetime;
const uuid = require('syracuse-core').helpers.uuid;
const yaml = require('js-yaml');
const url = require('url');
const jwt = require('jsonwebtoken');
const ms = require('ms');

exports.entity = {
	$titleTemplate: "Connected applications",
	$descriptionTemplate: "Connected application",
	$helpPage: "Administration-reference_Connected-Applications",
	$valueTemplate: "{name}",
	$createActionTitle: "New connected application",
	$listTitle: "List of connected applications",
	$properties: {
		name: {
			$title: "Name",
			$linksToDetails: true,
			$isMandatory: true,
			$isUnique: true
		},
		url: {
			$title: "Url",
			$format: "$url",
			$isMandatory: true
		},
		clientId: {
			$title: "Client ID",
			$isReadOnly: true
		},
		secret: {
			$title: "Secret",
			$type: "password",
			$salt: "",
			$encrypt: true,
			$isReadOnly: true,
			$isHidden: true
		},
		secretCreated: {
			$title: "Secret to keep",
			$description: "Please store your secret somewhere safe because it will never be displayed again !",
			$compute: function(_, instance, value) {
				return getSecretInSession(instance.$uuid);
			},
			$isDefined: function(_, instance) {
				return getSecretInSession(instance.$uuid) != null;

			},
			$isHidden: function(_, instance) {
				return !getSecretInSession(instance.$uuid);
			}
		},
		active: {
			$title: "Active",
			$default: true,
			$type: "boolean"
		},
		expiration: {
			$title: "Tokens validity",
			$description: 'expressed in seconds or a string describing a time span. Eg: "60", "2 days", "10h" "2.5 hrs", "7d", "1m", "5s"',
			$isMandatory: true,
			$default: "60"
		}
	},
	$relations: {
		tokenInfos: {
			$type: "tokenInfos",
			$inv: "app",
			$isComputed: true,
			$cascadeDelete: true
		},
		payloads: {
			$type: "tokenPayloads",
			$isChild: true,
			$isComputed: true
		}
	},
	$functions: {
		$serialize: function(_) {
			let res = this._internalSerialize(_);
			if (!this._showSecret && getSecretInSession(this.$uuid) != null) {
				delete globals.context.session.connectedAppSecrets[this.$uuid];
			}

			this.tokenInfos(_).toArray(_).forEach_(_, function(_, ti) {
				res.payloads = res.payloads || [];
				let info = helpers.object.clone(ti.info(_));
				if (info) {
					let curr = {
						jti: info.jti,
						iat: new Date(info.iat * 1000),
						exp: new Date(info.exp * 1000),
						sub: info.sub
					};
					delete info.jti;
					delete info.iat;
					delete info.exp;
					delete info.sub;
					delete info.iss;
					delete info.locale;
					curr.info = JSON.stringify(info);
					res.payloads.push(curr);
				}
			});

			return res;
		},
		generateSecret: function(_, secret) {
			this._showSecret = true;
			this.secret(_, generateSecret(32, '#Aa'));
			setSecretInSession(this.$uuid, this.secret(_));
			this.tokenInfos(_).toArray(_).forEach_(_, function(_, ti) {
				ti.deleteSelf(_);
			});
			this.tokenInfos(_).reset(_);
		},
		generateToken: function(_, params) {
			var up = globals.context && globals.context.session && globals.context.session.getUserProfile(_);
			//
			params = params || "";
			let info = yaml.safeLoad(params) || {};
			let tokenEntity = this._db.model.getEntity(_, "tokenInfo");
			let tokenInst = tokenEntity.createInstance(_, this._db);

			tokenInst.jti(_, uuid.generate(''));

			tokenInst.app(_, this);
			//
			let time = new Date().getTime();
			let exp = this.expiration(_);
			try {
				// if define in seconds
				exp = parseInt(exp, 10);
				exp = (time / 1000) + exp;
			} catch (e) {
				// else define with time span
				exp = (time + ms(exp)) / 1000;
				// do nothing, exp is a string
			}
			tokenInst.expiration(_, datetime.fromJsDate(new Date(exp * 1000)));
			info.jti = tokenInst.jti(_);
			info.iat = Math.floor(time / 1000); // convert in seconds
			info.exp = Math.floor(exp); // already in seconds
			info.sub = up && up.user(_).login(_);
			info.iss = globals.context && globals.context.session && globals.context.session.host;
			info.locale = up && up.selectedLocale(_) && up.selectedLocale(_).code(_);
			tokenInst.info(_, info);
			tokenInst.save(_);
			// for deletion by ttl
			tokenInst.schedule(_);
			// create and return the token
			return jwt.sign(info, this.secret(_));
		},
		generateFormattedUrl: function(_, path, params) {
			return `${url.resolve(this.url(_) + "/", path)}?token=${this.generateToken(_, params)}`;
		}
	},
	$services: {
		generateSecret: {
			$method: "get",
			$title: "Regenerate secret",
			$isMethod: true,
			$facets: ["$details"],
			$execute: function(_, context, instance, parameters) {
				instance.generateSecret(_);
				return instance.save(_);
			}
		},
	},
	$events: {
		$beforeSave: [
			function(_, instance, params) {
				if (instance.$created) {
					instance.clientId(_, uuid.generate(''));
					instance.generateSecret(_);
				}
			}
		]
	},
	$searchIndex: {
		$fields: ["name"]
	}
};

exports.entityPayload = {
	$titleTemplate: "Token informations",
	$descriptionTemplate: "Token information",
	$valueTemplate: "{description}",
	$listTitle: "List of Token informations",
	$isPersistent: false,
	$properties: {
		jti: {
			$title: "Token ID"
		},
		iat: {
			$title: "Issued at",
			$type: "datetime"
		},
		exp: {
			$title: "Expires in",
			$type: "datetime"
		},
		sub: {
			$title: "Subject"
		},
		info: {
			$title: "Information"
		}
	}
};

function generateSecret(length, chars) {
	let mask = '';
	if (chars.indexOf('a') > -1) mask += 'abcdefghijklmnopqrstuvwxyz';
	if (chars.indexOf('A') > -1) mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	if (chars.indexOf('#') > -1) mask += '0123456789';
	if (chars.indexOf('!') > -1) mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
	let result = '';
	for (let i = length; i > 0; --i) result += mask[Math.floor(Math.random() * mask.length)];
	return result;
}

function setSecretInSession(uuid, secret) {
	globals.context.session.connectedAppSecrets = globals.context.session.connectedAppSecrets || {};
	globals.context.session.connectedAppSecrets[uuid] = secret;
}

function getSecretInSession(uuid) {
	return globals.context.session.connectedAppSecrets && globals.context.session.connectedAppSecrets[uuid];
}