"use strict";

var sys = require("util");
var integrate = require("syracuse-patch/lib/integrate");
var write = require("syracuse-patch/lib/write");
var fs = require('fs');
var os = require('os');



function output(instance, future, directory, _) {
    if (future) {
        var errors = future(_);
		if (errors.length > 0) {
			instance.$diagnoses.push({severity: "error", message: "Inconsistencies in "+directory+" directory"});
			for (var i = 0; i < errors.length; i++) {
				instance.$diagnoses.push({severity: "error", message: errors[i]});
			}
		} else
			instance.$diagnoses.push({severity: "info", message: directory+" directory OK"});
    } else    
		instance.$diagnoses.push({severity: "info", message: directory+" directory does not exist"});														
}
			
exports.entity = {
	$isPersistent: false,
	$autoRecreateWorkingCopy: true,
	$properties: {
		patchFile: {
			$title: "Patch file name",
			$default: os.tmpDir()+"/patch.dat"
		},		
		restart: {
			$title: "Automatically restart",
			$type: "boolean",
			$default: true
		}		
	},
	$titleTemplate: "Patch integration",
    $valueTemplate: "Patch integration",
    $descriptionTemplate: "Patch integration",
    $functions: {
    },
	$services: {
	    $integratePatch: {
			$method : "PUT",
			$isMethod : true,
			$title : "Integrate patch",
			$execute : function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || {};
				if (!write.exists(write.SEMAPHORE, _)) {
					var result = null;
					fs.appendFile(write.SEMAPHORE, "A", _);
					try {
						result = integrate.patch(".", instance.patchFile(_), {restart: instance.restart(_), tryagain:true}, _);
						if ("versionerror" in result) {
							if (result.versionerror === null)
								instance.$diagnoses.push({severity: "info", message: "Patch already applied"});
							else
								instance.$diagnoses.push({severity: "error", message: ""+result.versionerror});
						} else
							instance.$diagnoses.push({severity: "info", message: "OK"});
					} catch (e) {
						console.log("Error "+e);
						delete result.kill;
						instance.$diagnoses.push({severity: "error", message: ""+e})
					} finally {
						fs.unlink(write.SEMAPHORE, _);
					}
					if (result.kill) {
						// kill node process
						instance.$diagnoses.push({severity: "warning", message: "node will be finished shortly ..."});
						context.kill = result.kill;
					}
					console.log("End");
				} else {
					instance.$diagnoses.push({severity: "error", message: "System is already locked by another call"});
					console.log("Parallel");
				}
			}
		},
	    $integrityCheck: {
			$method : "PUT",
			$isMethod : true,
			$title : "Check integrity",
			$execute : function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || {};
				if (!write.exists(write.SEMAPHORE, _)) {
					fs.appendFile(write.SEMAPHORE, "A", _);
					try {
                        var future = [];
                        future[0] = write.checkChecksumsV(".", null);                        
						if (write.exists(write.RELEASE_DIRECTORY, _))
                            future[1] = write.checkChecksumsV(write.RELEASE_DIRECTORY, null);
						if (write.exists(write.TEMP_DIRECTORY, _))
                            future[2] = write.checkChecksumsV(write.TEMP_DIRECTORY, null);
                        output(instance, future[0], 'working', _);
                        output(instance, future[1], 'release', _);
                        output(instance, future[2], 'temp', _);
					} finally {
						fs.unlink(write.SEMAPHORE, _);
					}
				} else {
					instance.$diagnoses.push({severity: "error", message: "System is already locked by another call"});
					console.log("Parallel");
				}
			}
		},
	    $metaData: {
			$method : "PUT",
			$isMethod : true,
			$title : "Get version metadata",
			$execute : function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || {};
				if (!fs.existsSync(write.SEMAPHORE)) {
					fs.appendFile(write.SEMAPHORE, "A", _);
					try {
						var version = write.readVersionFile(".", _);
						for (var key in version)
							instance.$diagnoses.push({severity: "info", message: key+": "+version[key]});
						if (write.exists(write.RELEASE_DIRECTORY, _)) {
							var relVersion = write.readVersionFile(write.RELEASE_DIRECTORY, _);
							instance.$diagnoses.push({severity: "info", message: "Release directory version: "+relVersion["relNumber"]});
						} else {
							instance.$diagnoses.push({severity: "info", message: "Release directory does not exist"});														
						}							
					} catch (e) {
						kill = false;
						instance.$diagnoses.push({severity: "error", message: "Cannot read version information "+e});						
					} finally {
						fs.unlink(write.SEMAPHORE, _);
					}
				} else {
					instance.$diagnoses.push({severity: "error", message: "System is already locked by another call"});
					console.log("Parallel");
				}
			}
		},
		$deleteSemaphore: {
			$method : "PUT",
			$isMethod : true,
			$title : "Unlock system",
			$execute : function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || {};
				if (!write.exists(write.SEMAPHORE, _))
					instance.$diagnoses.push({severity: "warning", message: "System already unlocked"});
				else {
					try {
						fs.unlink(write.SEMAPHORE, _);
						instance.$diagnoses.push({severity: "info", message: "OK"});					
					} catch (e) {
						instance.$diagnoses.push({severity: "error", message: e})
						console.log("Error when deleting semaphore file "+e)
					}					
				}
				console.log("Deleted2");
			}
		}
	},
};