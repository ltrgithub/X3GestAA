"use strict";

var util = require("util");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var ldapjs;
var fs = require('streamline-fs');
var userEntity = require('./user');

//dummy key for LDAP user data to indicate that they have already been used to update at least one instance of the user entity
//and therefore are not for adding a new user to the user entity.
var USED = "##########";

/// get all users from LDAP.
/// Arguments: ldap entity instance, 
///  all: retrieve all users? If false, retrieve only one user (using searchFilter if syncSearchFilter is not set; do not use authenticationNameMapping)

function getAllUsers(instance, all, _) {
	ldapjs = ldapjs || require("syracuse-ldap").ldapjs;
	var clientOpts = {
		url: instance.url(_)
	};
	// console.log("URL"+instance.url(_));
	var ldapClient = ldapjs.createClient(clientOpts);
	var filter;
	if (all) {
		filter = instance.syncSearchFilter(_);
	} else {
		///   and the search filter is the sync search filter (if available) or the search filter with {{username}} replaced by "*"
		filter = instance.syncSearchFilter(_) || instance.searchFilter(_).replace("{{username}}", "*");
	}
	// console.log("Client created");
	ldapClient.bind(instance.adminDn(_), instance.adminPassword(_), ~_);
	// console.log("bound");
	try {
		var authNameMapping;
		if (all) {
			authNameMapping = instance.authenticationNameMapping(_);
			if (!authNameMapping) {
				instance.$addError(locale.format(module, "noAuthName"));
				return null;
			}
		}
		var res = _ldapSearch(ldapClient, authNameMapping, {
			filter: filter,
			base: instance.searchBase(_)
		}, all ? 0 : 1, _);
		return res;
	} finally {
		ldapClient.unbind(~_);
	}
}

/// ## Function getLdapAttributes
/// returns a list of all LDAP attributes for the first user which is searched using the sync search filter (if available) or the search filter

function getLdapAttributes(instance, _) {
	var res = getAllUsers(instance, false, _);
	for (var k in res) { // dummy loop: there can only be one key
		return Object.keys(res[k]);
	}
	return [];
}

exports.getLdapAttributes = getLdapAttributes;

/// perform an LDAP search with paged data and limit of results
///  loginKey: name of LDAP attribute whose contents will be used for the key field of the result (otherwise just the "" key will be used)
///  config: has attributes `filter` for search filter, `base` for base DN
///  limit: maximal number of hits which will be retrieved from the server or 0 when there is no limit

function _ldapSearch(ldapClient, loginKey, config, limit, _) {
	var remaining = limit;
	/// Remark: the users will be taken with paged results of maximal 50 hits per search
	var MAX_REQUEST = 50;
	var b = new Buffer(0);
	var userEntries = {};
	while (b) {
		b = _ldapSearchInt(userEntries, ldapClient, loginKey, config, b, (limit && remaining < MAX_REQUEST) ? remaining : MAX_REQUEST, _);
		if (b && b.length === 0) return userEntries;
		if (limit) {
			remaining -= MAX_REQUEST;
			if (remaining < 0) remaining = 0;
		}
	}
}

// returns binary values for the attributes

function _convert(entry) {
	var obj = {
		dn: entry.dn.toString(),
		controls: []
	};
	entry.attributes.forEach(function(a) {
		var item = a.buffers;
		if (item && item.length) {
			if (item.length > 1) {
				obj[a.type] = item.slice();
			} else {
				obj[a.type] = item[0];
			}
		} else {
			obj[a.type] = [];
		}
	});
	entry.controls.forEach(function(element, index, array) {
		obj.controls.push(element.json);
	});
	return obj;
}

// internal function which performs a single paged LDAP query and provides the Streamline callback
//  parameters (except for parameters of _ldapSearch): 
//   cookie: Buffer which must be empty buffer for first search and buffer returned by previous search for each subsequent search
//           When the returned buffer is empty, there are no more results
//   size: maximal number of hits for this paged search. Value 0 means: stop paged search
var _ldapSearchInt = _(function(userEntries, ldapClient, loginKey, config, cookie, size, cb) {
	var opts = {
		filter: config.filter,
		scope: 'sub'
	};
	var control = new ldapjs.PagedResultsControl({
		criticality: true,
		value: {
			size: size,
			cookie: cookie
		}
	});
	ldapClient.search(config.base, opts, control, function(error, res) {
		var finished = false;
		if (error) return cb(error);
		res.on('searchEntry', function(entry) {
			var obj = _convert(entry);
			if (loginKey) {
				var key = obj[loginKey];
				if (key) key = key.toString("utf8");
				if (!key) {
					if (!finished) {
						finished = true;
						return cb(new Error(locale.format(module, "noContentForAuthName")));
					}
				}
				userEntries[key] = obj;
			} else {
				userEntries[""] = obj;
			}
		});
		res.on('error', function(err1) {
			if (!finished) {
				finished = true;
				return cb(err1);
			}
		});
		res.on('end', function(result) {
			if (result.status !== 0 && !finished) {
				finished = true;
				return cb(locale.format(module, "statusCode", result.status));
			}
			if (Array.isArray(result.controls)) {
				var l = result.controls.length;
				while (--l >= 0) {
					if (result.controls[l].type === ldapjs.PagedResultsControl.OID && !finished) {
						finished = true;
						return cb(null, result.controls[l].value.cookie);
					}
				}
			}
			if (!finished) {
				finished = true;
				return cb(null, null);
			}
		});
	});
}, 6);

// translates an user entity attribute to the LDAP attribute value

function _newValue(translated, values) {
	if (translated.charAt(0) === "'") return translated.substr(1);
	return values[translated];
}

/// update user table from LDAP 
/// Arguments: ldap entity instance, 
/// users: an object with authentication names as keys and LDAP user entries as values
/// diagnoses: warning and error messages
/// del: delete users which are not in LDAP any more (true) or just deactivate them (false)

function updateUsers(_, instance, users, diagnoses, del) {
	var l = instance.users(_).toArray(_);
	var diag = diagnoses.length;
	// mapping from user entity attributes to LDAP attributes
	var translateTable = {
		authenticationName: instance.authenticationNameMapping(_),
		firstName: instance.firstNameMapping(_),
		lastName: instance.lastNameMapping(_),
		email: instance.emailMapping(_),
		photo: instance.photoMapping(_)
	};
	var cloned = {};
	for (var key in users)
		cloned[key] = users[key];
	var i;
	for (i = 0; i < l.length; i++) {
		// do not continue when there are already messages
		if (diagnoses.length > diag) break;
		var user = l[i];
		var name = user.authenticationName(_) || user.login(_);
		var newValues = cloned[name];
		if (!newValues) { // LDAP entry does not exist any more
			if (del) {
				// console.log("Delete "+name);
				user.deleteSelf(_);
			} else { // just mark the user as inactive
				// console.log("Inactive "+name);
				user.active(_, false);
				user.save(_);
				user.getAllDiagnoses(_, diagnoses);
			}
		} else { // update from LDAP entry
			// console.log("Update "+name);

			for (var key in translateTable) {
				if (!translateTable[key]) continue;
				var newValue = _newValue(translateTable[key], newValues);
				if (key === "photo") { // set binary property
					if (newValue) {
						var stream = user.photo(_).createWritableStream(_);
						stream.write(_, newValue);
						stream.write(_, null);
					} else {
						user.photo(_).deleteFile(_);
					}
					continue;
				}
				if (!newValue) {
					newValue = "";
				} else {
					newValue = newValue.toString("utf8");
				}
				if (user[key](_) !== newValue) {
					// console.log(key+"="+newValue);
					user[key](_, newValue);
				}
			}
			user.active(_, true);
			user.save(_);
			user.getAllDiagnoses(_, diagnoses);
			cloned[name][USED] = 1;
		}
	}
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "user");
	// add users which are in LDAP but not yet in user table
	for (var authenticationName in cloned) {
		if (cloned[authenticationName][USED]) {
			continue;
		}
		var inst = entity.createInstance(_, db, null);
		for (var key in translateTable) {
			if (!translateTable[key]) continue;
			var newValue = _newValue(translateTable[key], cloned[authenticationName]);
			if (key === "photo") { // set binary property
				if (newValue) {
					var stream = inst.photo(_).createWritableStream(_);
					stream.write(_, newValue);
					stream.write(_, null);
				}
				continue;
			}
			if (newValue) {
				inst[key](_, newValue.toString("utf8"));
			}

		}
		inst.ldap(_, instance);
		inst.authentication(_, "ldap");
		inst.active(_, true);
		// are there users with the same name as the new user?
		var disturbingUsers = entity.fetchInstances(_, db, {
			jsonWhere: {
				login: {
					$regex: "^" + authenticationName
				}
			}
		});
		var disturbingNames = {};
		// put the names as keys in object
		for (var i = 0; i < disturbingUsers.length; i++) {
			// console.log("DistUser"+disturbingUsers[i].login(_));
			disturbingNames[disturbingUsers[i].login(_)] = 1;
		}
		if (authenticationName in disturbingNames) {
			// generate new user name
			// this loop is large enough because there can be at most disturbingUsers.length entries
			for (var i = 1; i <= disturbingUsers.length + 1; i++) {
				if ((authenticationName + i) in disturbingNames) continue;
				inst.login(_, authenticationName + i);
				diagnoses.push({
					severity: "warning",
					message: locale.format(module, "userNameChange", authenticationName, (authenticationName + i))
				});
				// console.log(util.format(diagnoses));
				break;
			}
		} else {
			// console.log("Normal User"+authenticationName);
			inst.login(_, authenticationName);
		}
		inst.save(_);
		inst.getAllDiagnoses(_, diagnoses);
	}

};

exports.updateUsers = updateUsers;

exports.entity = {
	$properties: {
		name: {
			$title: "Name",
			$isMandatory: true,
			$default: "LDAP",

			$isUnique: true,
			$pattern: /^[a-zA-Z]\w*$/,
		},
		displayName: {
			$title: "Display Name",
		},
		active: {
			$type: "boolean",
			$title: "Active",
			$default: true
		},
		url: {
			$title: "URL",
			$isMandatory: true
		},
		adminDn: {
			$title: "DN for searching"
		},
		adminPassword: {
			$title: "Password for search DN"
		},
		searchBase: {
			$title: "Search base"
		},
		searchFilter: {
			$title: "Search filter"
		},
		syncSearchFilter: {
			$title: "Sync search filter"
		},
		image: {
			$title: "Image",
			$type: "image",
			$storage: "db_file",
			$capabilities: ""
		},
		authenticationNameMapping: {
			$title: "Mapping for authentication name",
			$lookup: {
				entity: "ldapAttributeName",
				field: "attrName",
				parameters: "name={name}"
			}
		},
		firstNameMapping: {
			$title: "Mapping for first name",
			$lookup: {
				entity: "ldapAttributeName",
				field: "attrName",
				parameters: "name={name}"
			}
		},
		lastNameMapping: {
			$title: "Mapping for last name",
			$lookup: {
				entity: "ldapAttributeName",
				field: "attrName",
				parameters: "name={name}"
			}
		},
		emailMapping: {
			$title: "Mapping for email",
			$lookup: {
				entity: "ldapAttributeName",
				field: "attrName",
				parameters: "name={name}"
			}
		},
		photoMapping: {
			$title: "Mapping for photo",
			$lookup: {
				entity: "ldapAttributeName",
				field: "attrName",
				parameters: "name={name}"
			}
		},

	},
	$titleTemplate: "LDAP",
	$valueTemplate: "{name} {url}",
	$descriptionTemplate: "LDAP {name}",
	$helpPage: "Workbench-reference-LDAP",
	$relations: {
		users: {
			$title: "Users",
			$type: "users",
			$inv: "ldap",
			$isComputed: true
		}
	},
	$services: {
		connectionTest: {
			$method: "POST",
			$isMethod: true,
			$title: "Connection test",
			$execute: function(_, context, instance) {
				ldapjs = ldapjs || require("syracuse-ldap").ldapjs;
				var clientOpts = {
					url: instance.url(_)
				};
				// console.log("URL"+instance.url(_));
				var ldapClient = ldapjs.createClient(clientOpts);
				// console.log("Client created");
				try {
					ldapClient.bind(instance.adminDn(_), instance.adminPassword(_), ~_);
				} catch (e) {
					instance.$addError(locale.format(module, "connError", e));
					return;
				} finally {
					ldapClient.unbind(~_);
				}
				instance.$addDiagnose("success", locale.format(module, "ConnOK"));
			}

		},
		usersFromLdap: {
			$method: "POST",
			$isMethod: true,
			$title: "Update users from LDAP",
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if (userEntity.noAdmin(_)) {
					instance.$addError(locale.format(module, "noAdmin"));
					return;
				}
				var allUsers = getAllUsers(instance, true, _);
				updateUsers(_, instance, allUsers, instance.$diagnoses, false);
				if (instance.$diagnoses.length == 0) {
					instance.$addDiagnose("success", locale.format(module, "OK"));
				}
				return;
			}
		}
	},
	$searchIndex: {
		$fields: ["name", "displayName"]
	},
	$events: {},
	$defaultOrder: [
		["name", true]
	],

};