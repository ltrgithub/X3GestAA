"use strict";
var child_process = require("child_process");
var streams = require("streamline/lib/streams/server/streams");
var time = require("syracuse-core/lib/types/time");
var elastic = require('syracuse-search/lib/elasticSearch');

function sh(_, cmd, args) {
	try {
		var child = child_process.spawn(cmd, args);
		child.stdout.setEncoding("utf8");
		child.stderr.setEncoding("utf8");
		var resF = new streams.ReadableStream(child.stdout).readAll();
		var errF = new streams.ReadableStream(child.stderr).readAll();
		return (resF(_) || '') + (errF(_) || '');
	} catch (ex) {
		return ex.message;
	}
}

var entity = exports.entity = {
	$titleTemplate: "System Information",
	$key: "1",
	$isPersistent: false,
	$canEdit: false,
	$canDelete: false,
	$keyPager: true,
	$isProxyClass: true,
	$properties: {
		syracuse_version: {
			$title: "version",
			$compute: function(_, instance) {
				return require("syracuse-main/package.json").version;
			},
		},
		syracuse_branch: {
			$title: "branch",
			$compute: function(_, instance) {
				return sh(_, 'git', ['rev-parse', '--abbrev-ref', 'HEAD']);
			},
		},
		syracuse_sha1: {
			$title: "sha1",
			$compute: function(_, instance) {
				return sh(_, 'git', ['rev-parse', 'HEAD']);
			},
		},
		syracuse_git_url: {
			$title: "git url",
			$format: "$url",
			$compute: function(_, instance) {
				return "https://github.com/Sage-ERP-X3/Syracuse/commit/" + instance.syracuse_sha1(_);
			},
		},
	},
	$relations: {},
	$functions: {
		$setId: function(_, context, id) {

		}
	},
};

//   db.admin().serverInfo(function(err, result){
['version', 'arch', 'platform', 'pid'].forEach(function(key) {
	entity.$properties["node_" + key] = {
		$title: key,
		$compute: function(_, instance) {
			return process[key];
		}
	};
});

entity.$properties.node_uptime = {
	$title: "up time",
	$compute: function(_, instance) {
		return time.fromSeconds(Math.floor(process.uptime())).toString();
	}
};

Object.keys(process.memoryUsage()).forEach(function(key) {
	entity.$properties["node_" + key] = {
		$title: key,
		$type: 'integer',
		$compute: function(_, instance) {
			return process.memoryUsage()[key];
		}
	};
});

// We should enumerate these keys dynamically but we don't have a connection to mongo
// So let's do it statically for now
['version', 'gitVersion', 'sysInfo', 'bits', 'debug', 'maxBsonObjectSize', 'ok'].forEach(function(key) {
	entity.$properties["mongo_" + key] = {
		$title: key,
		$compute: function(_, instance) {
			if (!instance.mongoInfo || instance.mongoTime < Date.now() - 1000) {
				instance.mongoInfo = instance._db.db.admin().serverInfo(_);
				instance.mongoTime = Date.now();
			}
			return instance.mongoInfo[key];
		}
	};
});

// We should enumerate these keys dynamically but we don't have a connection to mongo
// So let's do it statically for now
['version', 'name', 'tagline', 'status', 'ok'].forEach(function(key) {
	entity.$properties["elastic_" + key] = {
		$title: key,
		$compute: function(_, instance) {
			if (!instance.elasticInfo || instance.elasticTime < Date.now() - 1000) {
				instance.elasticInfo = JSON.parse(streams.httpRequest({
					url: elastic.serverConfig.baseUrl
				}).end().response(_).checkStatus(200).readAll(_));
				instance.elasticTime = Date.now();
			}
			var val = instance.elasticInfo[key];
			if (key === 'version') val = val.number;
			return val;
		}
	};
});

// We could enumerate all the env variables with Object.keys(process.env)
// but this may expose things that we don't want to expose. Be safe.
// Windows and Linux differ (of course). So we have key variants
['HOME', 'LANG', 'SHELL', 'PATH', 'PWD', 'TEMP', 'TMPDIR', 'OS', 'USER', 'USERNAME', 'USERDOMAIN'].filter(function(key) {
	return process.env[key] !== undefined;
}).forEach(function(key) {
	entity.$properties["env_" + key] = {
		$title: key,
		$compute: function(_, instance) {
			return process.env[key];
		}
	};
});