"use strict";

var os = require("os");
var globals = require('streamline/lib/globals');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var util = require('util');
var config = require("syracuse-main/lib/nodeconfig").config;
var streams = require("streamline/lib/streams/streams");
var locale = require("syracuse-core/lib/locale");

exports.entity = {
	$lockType: "noLock",
	$canDelete: false,
	$canCreate: false,
	$canEdit: false,
	$sequentialStorage: true, // uses a funnel to storage
	$titleTemplate: "Session status",
	$descriptionTemplate: "Provides http sessions status",
	$valueTemplate: "{userName}/{ssid}",
	$properties: {
		sid: {
			$title: "Session id",
			$serialize: false
		},
		userName: {
			$title: "User name"
		},
		lastAccess: {
			$title: "Last user access",
			$type: "datetime"
		},
		serverName: {
			$title: "Server name",
			$default: function(_) {
				return config.servername;
			}
		},
		badge: {
			$title: "Badge"
		},
		clientId: {
			$title: "Client ID"
		},
		lastUrl: {
			$title: "last URL"
		},
		x3Sessions: {
			$title: "X3 sessions"
		},
		peerAddress: {
			$title: "Peer address"
		}
	},
	$relations: {},
	$functions: {
		$canDelete: function(_) {
			var self = this;
			if (globals.context.session && globals.context.session.sid && (globals.context.sid == this.sid(_))) {
				self.deleteError = "Cannot delete current session";
				return false;
			} else return true;
		}
	},
	$services: {
		disconnect: {
			$method: "POST",
			$isMethod: true,
			$title: "Disconnect",
			$execute: function(_, context, instance) {
				if (globals.context.session && globals.context.session.id && (globals.context.session.id == instance.sid(_))) {
					instance.$addError(locale.format(module, "disconnectCurrent"));
					return;
				}
				// The session to disconnect might be on another server / process, so we do a request to logout using the session cookie
				var resp = streams.httpRequest({
					url: context.url.split("/").splice(0, 3).join("/") + "/logout",
					method: "POST",
					headers: {
						cookie: sessionManager.formatSessionCookie(instance.sid(_))
					}
				}).end().response(_).readAll(_);
				//
				if (resp) resp = JSON.parse(resp);
				else return;
				//
				if (resp.$diagnoses) resp.$diagnoses.forEach(function(d) {
					if (d.$severity === "success") instance.$addDiagnose("success", locale.format(module, "disconnected"));
					else instance.$addDiagnose(d.$severity, d.$message);
				});
			}
		}
	},
	$defaultOrder: [
		["lastAccess", true]
	],
	$expire: function(_, instance) {
		// set in hard the value, it will be configured after
		if (config.session.timeout) { // timeout + 1 
			return (config.session.timeout + 1) * 60000;
		}
	}

};