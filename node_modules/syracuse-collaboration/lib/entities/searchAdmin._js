"use strict";

var index = require("syracuse-search/lib/elasticIndex");
var IndexHelper = index.IndexHelper;
var locale = require("syracuse-core/lib/locale");
var streams = require("streamline/lib/streams/streams");

var adminHelpers = require('syracuse-collaboration/lib/helpers');

function _normalizeDiag(diag) {
	return {
		$severity: diag.$severity || diag.severity,
		$message: diag.$message || diag.message,
		$stackTrace: diag.$stackTrace
	};
}

exports.entity = {
	$isPersistent: false,
	$canSave: false,
	$titleTemplate: "Search indexes administration",
	$descriptionTemplate: "Administration interface for full text search indexes",
	$helpPage: "Administration-reference-search-indexes-administration",
	$properties: {
		differentialUpdate: {
			$title: "Update modified records only",
			$type: "boolean",
			$default: false,
			$propagate: function(_, instance, val) {
				if (val) instance.deleteBeforeUpdate(_, false);
			}
		},
		deleteBeforeUpdate: {
			$title: "Delete index before update",
			$description: "Only available for full index operations",
			$type: "boolean",
			$isDisabled: function(_, instance) {
				return instance.differentialUpdate(_);
			}
		},
		dataset: {
			$title: "Dataset",
			$isExcluded: true
		}
	},
	$relations: {
		entities: {
			$title: "Entities",
			$description: "Entities to be indexed. Leave empty for all entities",
			$type: "entityProxies",
			$inlineStore: true,
			$select: {
				parameters: "dataset={dataset}"
			},
			$isDisabled: function(_, instance) {
				return instance.dataset(_) == null;
			},
			$lookupFilter: {
				canSearch: true
			}
		},
		endpoint: {
			$title: "Endpoint",
			$type: "endPoint",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if (val) instance.dataset(_, val.dataset(_));
				else instance.dataset(_, "");
				instance.entities(_).reset(_);
			}
		},
		locales: {
			$title: "Locales",
			$type: "localePreferences"
		}
	},
	$init: function(_, instance) {
		var crt = instance._db.fetchInstance(_, instance._db.getEntity(_, "localePreference"), {
			jsonWhere: {
				code: locale.current
			}
		});
		var locs = instance.locales(_);
		if (crt && !locs.get(_, crt.$uuid)) instance.locales(_).set(_, crt);
	},
	$functions: {
		updateIndex: function(_, diags, tracker, isFunction) {

			var nbLaunch = 1;

			function _update(_, helper, localeCode, isSyracuse) {



				var entis = (isSyracuse ? null : instance.entities(_).toArray(_).map_(_, function(_, r) {
					return r.entity(_);
				}));

				if (isFunction) {
					helper.updateFunctionIndex(_, instance.differentialUpdate(_), {
						diagnoses: diags || instance.$diagnoses,
						tracer: config && config.searchEngine && config.searchEngine.tracer,
						entities: entis,
						locale: localeCode,
						tracker: tracker,
						progressSlices: locArray.length * nbLaunch,
						progressCurrentSlice: l_idx++
					});
				} else {
					helper.updateIndex(_, instance.differentialUpdate(_), {
						diagnoses: diags || instance.$diagnoses,
						tracer: config && config.searchEngine && config.searchEngine.tracer,
						entities: entis,
						locale: localeCode,
						tracker: tracker,
						progressSlices: locArray.length * nbLaunch,
						progressCurrentSlice: l_idx++
					});
				}
			}
			//

			var instance = this;
			var config = require("syracuse-main/lib/nodeconfig").config;
			instance.$diagnoses = instance.$diagnoses || [];
			var ep = instance.endpoint(_);
			/*if (!ep) { // raise an error where no endpoint is setted
				throw new Error(locale.format(module, "endpointMandatory"));
			}*/
			// launch first on syracuse administration endpoint
			var endpoint = instance._db.fetchInstance(_, instance._db.getEntity(_, "endPoint"), {
				jsonWhere: {
					description: "Syracuse administration"
				}
			});
			var locArray = instance.locales(_).toArray(_);
			var l_idx = 1;

			function _launchUpdate(_, ep, isSyracuse) {
				locArray.forEach_(_, function(_, loc) {
					var exists = true;
					if (isSyracuse) {
						var options = {
							url: index.serverConfig.baseUrl + "/syracuse.collaboration.syracuse." + loc.code(_).toLowerCase() + "/_aliases",
							method: 'GET'
						};
						var req = streams.httpRequest(options);
						var resp = req.end().response(_);
						exists = resp && resp.statusCode !== 200;

					}
					if (exists) {
						var h = new IndexHelper(ep, loc.code(_));
						if (instance.deleteBeforeUpdate(_)) index.deleteEndpointIndex(_, ep, loc.code(_), instance.$diagnoses);
						_update(_, h, loc.code(_), isSyracuse);
					}
				});

			}


			// endpoint choice 
			_launchUpdate(_, ep);
			//


		},

		scheduledExecute: function(_, diags) {
			this.updateIndex(_, diags);
		}
	},
	$services: {
		updateDataIndex: {
			$method: "PUT",
			$title: "Update data index",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$execute: function(_, context, instance) {
				var t = context && context.tracker;
				var d = t ? (t.$diagnoses = t.$diagnoses || []) : null;
				instance.updateIndex(_, d, t, false);
			}
		},
		updateFunctionIndex: {
			$method: "PUT",
			$title: "Update functions index",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$execute: function(_, context, instance) {
				var t = context && context.tracker;
				var d = t ? (t.$diagnoses = t.$diagnoses || []) : null;
				instance.updateIndex(_, d, t, true);
			}
		},

		deleteDataIndex: {
			$method: "DELETE",
			$title: "Delete data index",
			$isMethod: true,
			$execute: function(_, context, instance) {
				if (!instance.endpoint(_)) {
					instance.$addError(locale.format(module, "endpointMandatory"), "endpoint");
					return;
				}
				//
				var ep = instance.endpoint(_);
				instance.$diagnoses = instance.$diagnoses || [];
				// index.deleteEndpointIndex(_, ep, "", instance.$diagnoses);
				instance.locales(_).toArray(_).forEach_(_, function(_, loc) {
					index.deleteEndpointIndex(_, ep, loc.code(_), instance.$diagnoses);

				});
			}
		},
		deleteFunctionsIndex: {
			$method: "DELETE",
			$title: "Delete functions index",
			$isMethod: true,
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				// index.deleteIndex(_, null, "sage.x3.functions", instance.$diagnoses);
				var endpoints = adminHelpers.AdminHelper.getEndpoints(_, {});
				endpoints.forEach_(_, function(_, e) {
					var indexName = "sage.x3.functions" + "." + e.application(_).toLowerCase() + "." + e.contract(_).toLowerCase() + "." + e.dataset(_).toLowerCase() + ".";
					instance.locales(_).toArray(_).forEach_(_, function(_, loc) {
						index.deleteIndex(_, null, indexName + loc.code(_).toLowerCase(), instance.$diagnoses);
					});
				});
				var indexName = "sage.x3.functions" + ".";
				instance.locales(_).toArray(_).forEach_(_, function(_, loc) {
					index.deleteIndex(_, null, indexName + loc.code(_).toLowerCase(), instance.$diagnoses);
				});
			}
		},
		deleteAllIndex: {
			$method: "DELETE",
			$title: "Delete all indexes",
			$isMethod: true,
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				// index.deleteIndex(_, null, "sage.x3.functions", instance.$diagnoses);
				index.deleteAllIndex(_, null, instance.$diagnoses);

			}
		},
		schedule: {
			$method: "POST",
			$title: "Schedule index update",
			$isMethod: true,
			$parameters: {
				$actions: {
					$select: {
						$url: "{$baseUrl}/automates?representation=automate.$select"
					}
				}
			},
			//			$urlParameters: "scheduler={schedulerId}",
			$execute: function(_, context, instance, parameters) {
				if (!parameters || !parameters.$select) return;
				parameters.$select.forEach_(_, function(_, s) {
					var a = instance._db.fetchInstance(_, instance._db.getEntity(_, "automate"), s.$uuid);
					if (!a) return;
					var t = a.automateTasks(_).add(_);
					t.description(_, locale.format(module, "indexUpdateTaskLabel"));
					t.logLevel(_, "error");
					t.process(_, instance);
					a.save(_);
					var diag = [];
					a.getAllDiagnoses(_, diag, {
						addPropName: true,
						addEntityName: true
					});
					if (diag.some(function(d) {
						d = _normalizeDiag(d);
						return d.$severity === "error";
					})) diag.forEach(function(d) {
						d = _normalizeDiag(d);
						instance.$addDiagnose(d.$severity, d.$message);
					});
					else instance.$addDiagnose("success", locale.format(module, "taskCreated", a.description(_)));
				});
			}
		}
	}
};