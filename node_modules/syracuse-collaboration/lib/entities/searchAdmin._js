"use strict";

var index = require("syracuse-search/lib/elasticIndex");
var IndexHelper = index.IndexHelper;
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var sys = require("util");

exports.entity = {
	$isPersistent: false,
	$canSave: false,
	$titleTemplate: "Search indexes administration",
	$descriptionTemplate: "Administration interface for full text search indexes",
	$properties: {
		differentialUpdate: {
			$title: "Update modified records only",
			$type: "boolean",
			$default: true,
			$propagate: function(_, instance, val) {
				if(val)
					instance.deleteBeforeUpdate(_, false);
			}
		},
		deleteBeforeUpdate: {
			$title: "Delete index before update",
			$description: "Only available for full index operations",
			$type: "boolean",
			$isDisabled: function(_, instance) {
				return instance.differentialUpdate(_);
			}
		},
		debugMode: {
			$title: "Debug mode",
			$type: "boolean",
			$isDeveloppementFeature: true
		},
		dataset: {
			$title: "Dataset",
			$isHidden: true
		}
	},
	$relations: {
		representations: {
			$title: "Representations",
			$description: "Representations to be indexed. Leave empty for all representations",
			$type: "representationProxies",
			$inlineStore: true,
			$select: {
				parameters: "dataset={dataset}"
			},
			$isDisabled: function(_, instance) {
				return instance.dataset(_) == null;
			}
		},
		endpoint:{
			$title: "Endpoint",
			$type: "endPoint",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if(val)
					instance.dataset(_, val.dataset(_));
				else
					instance.dataset(_, "");
			}
		},
		locales: {
			$title: "Locales",
			$type: "localePreferences"
		}
	},
	$init: function(_, instance) {
		var crt = instance._db.fetchInstance(_, instance._db.getEntity(_, "localePreference"), {
			jsonWhere: {
				code: locale.current
			}
		});
		var locs = instance.locales(_);
		if(crt && !locs.get(_, crt.$uuid))
			instance.locales(_).set(_, crt);
	},
	$functions: {
		updateIndex: function(_, diags, withWait) {
			function _update(_, localeCode) {
				h.updateIndex(_, instance.differentialUpdate(_), {
					diagnoses: diags || (instance.debugMode && instance.debugMode(_) && instance.$diagnoses),
					tracer: config && config.searchEngine && config.searchEngine.tracer,
					representations: instance.representations(_).toArray(_).map_(_, function(_, r) { return r.representation(_); }),
					locale: localeCode
				});
			}
			//
			var instance = this;
			var config = require("syracuse-main/lib/nodeconfig").config;
			instance.$diagnoses = instance.$diagnoses || [];
			var ep = instance.endpoint(_);
			var h = new IndexHelper(ep);
			if(instance.deleteBeforeUpdate(_)) {
				index.deleteEndpointIndex(_, ep, "", instance.$diagnoses);
			}
			instance.locales(_).toArray(_).forEach_(_, function(_, loc) {
				if(instance.deleteBeforeUpdate(_))
					index.deleteEndpointIndex(_, ep, loc.code(_), instance.$diagnoses);
				if(withWait || (instance.debugMode && instance.debugMode(_))) {
					_update(_, loc.code(_));
				} else {
					_update(null, loc.code(_));
					instance.$addDiagnose("info", locale.format(module, "indexInProgress", instance.endpoint(_).description(_), loc.code(_)));
				}
			});
			//
		},
		scheduledExecute: function(_, diags) {
			this.updateIndex(_, diags, true);
		}
	},
	$services: {
		updateIndex: {
			$method: "PUT",
			$title: "Index update",
			$isMethod: true,
			$execute: function(_, context, instance) {
				instance.updateIndex(_);
			}
		},
		deleteIndex: {
			$method: "DELETE",
			$title: "Delete index",
			$isMethod: true,
			$execute: function(_, context, instance) {
				if(!instance.endpoint(_)) {
					instance.$addError(locale.format(module, "endpointMandatory"), "endpoint");
					return;
				}
				//
				var ep = instance.endpoint(_);
				instance.$diagnoses = instance.$diagnoses || [];
				index.deleteEndpointIndex(_, ep, "", instance.$diagnoses);
				instance.locales(_).toArray(_).forEach_(_, function(_, loc) {
					index.deleteEndpointIndex(_, ep, loc.code(_), instance.$diagnoses);
				});
			}
		},
		deleteFunctionsIndex: {
			$method: "DELETE",
			$title: "Delete functions index",
			$isMethod: true,
			$execute: function(_, context, instance) {
				//
				var ep = instance.endpoint(_);
				instance.$diagnoses = instance.$diagnoses || [];
				index.deleteIndex(_, null, "sage.x3.functions", instance.$diagnoses);
				instance.locales(_).toArray(_).forEach_(_, function(_, loc) {
					index.deleteIndex(_, null, "sage.x3.functions." + loc.code(_).toLowerCase(), instance.$diagnoses);
				});
			}
		},
		schedule: {
			$method: "POST",
			$title: "Schedule index update",
			$isMethod: true,
			$parameters: {
				$actions: {
					$select: {
						$url: "{$baseUrl}/automates?representation=automate.$select"
					}
				}
			},
			$urlParameters: "scheduler={schedulerId}",
			$execute: function(_, context, instance, parameters) {
				if(!parameters || !parameters.$select) return;
				parameters.$select.forEach_(_, function(_, s) {
					var a = instance._db.fetchInstance(_, instance._db.getEntity(_, "automate"), s.$uuid);
					if(!a) return;
					var t = a.automateTasks(_).add(_);
					t.description(_, locale.format(module, "indexUpdateTaskLabel"));
					t.logLevel(_, "error");
					t.process(_, instance);
					a.save(_);
					var diag = [];
					a.getAllDiagnoses(_, diag, {
						addPropName: true,
						addEntityName: true
					});
					if(diag.some(function(d) {
						return d.severity === "error";
					})) 
						diag.forEach(function(d) {
							instance.$addDiagnose(d.severity, d.message);
						});
					else
						instance.$addDiagnose("info", locale.format(module, "taskCreated", a.description(_)));
				});
			}
		}
	}
}
