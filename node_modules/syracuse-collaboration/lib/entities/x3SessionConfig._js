"use strict";
/// !doc
///
/// # Session configuration entity  
///
/// This entity is not persistent.  
/// Information managed by it are attached to the http session.  
/// 
var locale = require("syracuse-core/lib/locale");
var helpers = require('syracuse-core/lib/helpers');
var sa = require('syracuse-orm/lib/storageArea');
var datetime = require("syracuse-core/lib/types/datetime");


exports.Tracer = helpers.defineClass(function(id, description, abrev) {
	this.config = {};
	this.id = id;
	this.description = description;
	this.abrev = abrev;
	this.traces = {};
	this.enabled = false;
}, null, {
	openTrace: function(_, type) {
		//console.log("Open trace: "+type);
		var trace = this.traces[type];
		if (type && !trace) {
			trace = {};
			trace.properties = {
				description: type + " traces (" + this.description + ")",
				content: {
					contentType: "text/plain",
					fileName: "Trace_" + this.abrev + "_" + type + "_" + this.id
				}
			};
			trace.dd = sa.open(_, null, null, "serverLog");
			if (!trace.instance) {
				trace.instance = sa.getDocumentInstanceByDD(_, trace.dd);
				trace.instance.warnDiags(_, [locale.format(module, "traceOpened")]);
			}
			// Expires in two hours
			var dateExpire = new Date((new Date()).getTime() + 7200000);
			trace.properties.expiration = datetime.fromJsDate(dateExpire);
			//
			this.traces[type] = trace;
		}
		return this.traces[type];
	},
	trace: function(_, type, str, funcPlus) {
		//console.log("TRACE> TYPE: "+type+" - CONFIG: "+JSON.stringify(this.config,null,2));
		if (this.enabled && this.config[type]) {
			var t = this.traces[type];
			if (!t) t = this.openTrace(_, type);
			if (t) {
				sa.write(_, t.dd, t.properties, (new Date()).toISOString() + "\t" + str + "\n", true);
			}
		}
		if (funcPlus) funcPlus(str);
	},
	close: function(_) {
		for (var i in this.traces) {
			this.traces[i].instance.warnDiags(_, []);
			this.traces[i].instance.infoDiags(_, [locale.format(module, "traceClosed")]);
			sa.close(_, this.traces[i].dd, true);
			delete this.traces[i];
		}
	}
});

exports.entity = {
	$titleTemplate: "Session log activation",
	$isPersistent: false,
	$canDelete: false,
	$canCreate: false,
	$canSave: false,
	$autoRecreateWorkingCopy: true,
	$helpPage: "Administration-reference-X3-Session-configuration",
	/// ## Properties
	$properties: {
		/// * **runtimeLog** - *boolean*: Activates runtime logging for this Syracuse session  
		runtimeLog: {
			$title: "Enable Runtime Logging",
			$type: "boolean",
			$default: false,
			$propagate: function(_, instance, val) {
				if (val) {
					instance.logFlag(_, 0);
					instance.directory(_, "");
					instance.dataset(_, null);
				}
			}
		},
		/// * **logFlag** - *integer*: Bit mask to enable various logging options  
		logFlag: {
			$title: "Flags",
			$type: "integer",
			$default: 0,
			$displayLength: 10,
			$isHidden: function(_, instance) {
				return !instance.runtimeLog(_);
			},
			$isMandatory: function(_, instance) {
				return instance.runtimeLog(_);
			}
		},
		/// * **directory** - *string*: Directory used to store logging information  
		directory: {
			$title: "Log directory",
			$type: "string",
			$default: "",
			$displayLength: 10,
			$isHidden: function(_, instance) {
				return !instance.runtimeLog(_);
			},
			$isMandatory: function(_, instance) {
				return instance.runtimeLog(_);
			}
		},
		dataset: {
			$title: "Dataset",
			$isExcluded: true
		},
		/// * **cvgLog** - *boolean*: Activates the logging for the convergences sessions linked to this Syracuse session  
		cvgLog: {
			$title: "Enable Classic Server Logging",
			$type: "boolean",
			$default: false,
			$propagate: function(_, instance, val) {
				if (val) {
					instance.cvgProtocol(_, false);
					instance.cvgSession(_, false);
					instance.cvgAction(_, false);
				}
			}
		},
		/// * **cvgProtocol** - *boolean*: Activate protocol traces  
		cvgProtocol: {
			$title: "Protocol",
			$type: "boolean",
			$default: false,
			$isHidden: function(_, instance) {
				return !instance.cvgLog(_);
			}
		},
		/// * **cvgSession** - *boolean*: Activate session traces  
		cvgSession: {
			$title: "Session",
			$type: "boolean",
			$default: false,
			$isHidden: function(_, instance) {
				return !instance.cvgLog(_);
			}
		},
		/// * **cvgAction** - *boolean*: Activate actions traces  
		cvgAction: {
			$title: "Action",
			$type: "boolean",
			$default: false,
			$isHidden: function(_, instance) {
				return !instance.cvgLog(_);
			}
		}
	},
	/// ## Relations
	$relations: {
		/// * **endPoint** - Endpoint: Endpoint for which the log is activated (all endpoints if none is specified)
		///
		endpoint: {
			$title: "Endpoint",
			$type: "endPoint",
			$isHidden: function(_, instance) {
				return !instance.runtimeLog(_);
			},
			$propagate: function(_, instance, val) {
				if (val) instance.dataset(_, val.dataset(_));
				else instance.dataset(_, "");
			}
		}
	},
	$init: function(_, instance, context) {
		context.httpSession.x3SessionConfig = context.httpSession.x3SessionConfig || {};
		var runtimeCfg = context.httpSession.x3SessionConfig.runtime || {};
		if (runtimeCfg.runtimeLog) {
			instance.runtimeLog(_, true);
			instance.logFlag(_, runtimeCfg.logFlag || 0);
			instance.directory(_, runtimeCfg.logDir || "");
		}
		var cvgCfg = context.httpSession.x3SessionConfig.convergence || {};
		if (context.httpSession.x3SessionConfig.cvgLog) {
			instance.cvgLog(_, true);
			instance.cvgProtocol(_, cvgCfg.protocol || false);
			instance.cvgSession(_, cvgCfg.session || false);
			instance.cvgAction(_, cvgCfg.action || false);
		}

	},

	$functions: {},
	/// ## Services
	$services: {
		/// * **submit**: Apply changes
		submit: {
			$method: "POST",
			// $confirm: "This operation will change the X3 runtime configuration of all subsequent sessions.\n\nDo you want to continue ?",
			$isMethod: true,
			$title: "Submit",
			$execute: function(_, context, instance) {
				try {
					context.httpSession.x3SessionConfig = context.httpSession.x3SessionConfig || {};
					instance.$diagnoses = instance.$diagnoses || [];

					if (instance.runtimeLog(_)) {

						if (instance.logFlag(_) === 0 || instance.directory(_) === "")
							throw new Error(locale.format(module, "runtimeLogPreconditionFailed"));

						var runtimeCfg = context.httpSession.x3SessionConfig.runtime = (context.httpSession.x3SessionConfig.runtime || {});
						runtimeCfg.runtimeLog = instance.runtimeLog(_);
						runtimeCfg.logFlag = instance.logFlag(_);
						runtimeCfg.dataset = instance.endpoint(_) ? instance.endpoint(_).dataset(_) : null;
						runtimeCfg.logDir = instance.directory(_);


						instance.$diagnoses.push({
							$severity: "info",
							$message: locale.format(module, "runtimeLogEnabled", runtimeCfg.logDir)
						});
					} else {
						delete context.httpSession.x3SessionConfig.runtime;
					}
					if (instance.cvgLog(_)) {
						var cvgCfg = context.httpSession.x3SessionConfig.convergence = (context.httpSession.x3SessionConfig.convergence || {});
						context.httpSession.x3SessionConfig.cvgLog = instance.cvgLog(_);
						cvgCfg.protocol = instance.cvgProtocol(_);
						cvgCfg.session = instance.cvgSession(_);
						cvgCfg.action = instance.cvgAction(_);
						instance.$diagnoses.push({
							$severity: "info",
							$message: locale.format(module, "cvgLogEnabled")
						});
					} else {
						delete context.httpSession.x3SessionConfig.cvgLog;
						delete context.httpSession.x3SessionConfig.convergence;
					}
				} catch (e) {
					context.httpSession.x3SessionConfig = {};
					console.error(e.stack);
					return {
						$diagnoses: [{
							severity: "error",
							message: e.message
						}]
					};
				}
			}
		},
		reset: {
			$method: "POST",
			$isMethod: true,
			$title: "Reset",
			$execute: function(_, context, instance) {
				try {
					context.httpSession.x3SessionConfig = {};
					instance.$diagnoses = instance.$diagnoses || [];

					if (instance.runtimeLog(_)) {
						instance.runtimeLog(_, false);
						instance.$diagnoses.push({
							$severity: "info",
							$message: locale.format(module, "runtimeLogDisabled")
						});
					}
					if (instance.cvgLog(_)) {
						instance.cvgLog(_, false);
						instance.$diagnoses.push({
							$severity: "info",
							$message: locale.format(module, "cvgLogDisabled")
						});
					}
				} catch (e) {
					console.error(e.stack);
					return {
						$diagnoses: [{
							severity: "error",
							message: e.message
						}]
					};
				}
			}
		}
	},
	$fetchInstances: function(_, context, parameters) {
		return [];
	}
};