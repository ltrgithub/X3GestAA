"use strict";

var util = require("util");
var tracer; // = console.log
var cr = require('crypto');


//performance test for server
//executes a native function (pbkdf2 of crypto module) which takes much CPU time to perform and cannot
//be optimized away using Just in time compilers. Therefore its execution time is rather reliable.
//The execution time of pbkdf2 is roughly proportional to the value in the 3rd parameter which specifies
//the number of iterations.
//The value will be adjusted after each execution of "pbkdf2" so that the execution time will be about 
//SINGLE_COMPUTE_TIME milliseconds. Therefore the total test time will be about the same both on fast
//and slow machines.
//When there has been an execution which takes more than MIN_COMPUTE_TIME milliseconds, the next execution 
//will be done later (using process.nextTick). Therefore also the total load of the server and the queue
//can be investigated. When about MAXMILLIS milliseconds have passed since the first invocation, the results
//will be returned.
//The current value for SINGLE_COMPUTE_TIME ensures that the server is not blocked too long for a single
//execution of "pbkdf2".
//Interpretation of results: "speed": average number of "pbkdf2" iterations per millisecond (only considers
//           real computing time, not the wait time in the node.js queue)
//"percent": percentage of real computing time for "pbkdf2" as part of total time for this function. When
//          there is much load, the value will be lower
//"testTime": number of milliseconds which have passed since invocation of the function
function perfTest(callback) {

	var anz = 10;
	var pwd = new Buffer("abcde");
	var salt = new Buffer("xyz");
	var total = 0;
	var computeMillis = 0;
	var SINGLE_COMPUTE_TIME = 20;
	var MIN_COMPUTE_TIME = 2; // Math.floor(SINGLE_COMPUTE_TIME/10)
	var MAXMILLIS = 1000;
	var startMillis = Date.now();

	function test() {
		// console.log("Test "+noStart+" "+(noStart - startMillis))
		var noStart = Date.now();
		if (noStart - startMillis <= MAXMILLIS) {
			var no = noStart;
			var no2 = no;
			do {
				cr.pbkdf2Sync(pwd, salt, anz, 200);
				total += anz;
				no2 = Date.now();
				//  console.log("nach sync "+(no2-no))
				if (no2 - no <= MIN_COMPUTE_TIME) {
					anz *= 10; // very short execution times are unreliable
					no = no2;
					continue;
				} else {
					anz = 1 + Math.floor((anz * SINGLE_COMPUTE_TIME) / (no2 - no));
					break;
				}
			} while (no - noStart < SINGLE_COMPUTE_TIME);
			// console.log("nach Schleife");
			computeMillis += (no2 - noStart);
			if (no2 - startMillis <= MAXMILLIS) {
				process.nextTick(test);
				return;
			} else {
				noStart = no2;
			}
		}
		// console.log("CB");
		var speed = total / ((computeMillis > 1) ? computeMillis : 1);
		if (speed < 1) speed = Math.round(1000 * speed) / 1000;
		else if (speed < 10) speed = Math.round(100 * speed) / 100;
		else if (speed < 100) speed = Math.round(10 * speed) / 10;
		return callback(null, {
			speed: speed,
			testTime: (noStart - startMillis),
			percent: Math.round(1000 * computeMillis / (noStart - startMillis)) / 10
		});
	}

	test();
}



exports.entity = {
	$isPersistent: false,
	$autoRecreateWorkingCopy: true,
	$properties: {
		test: {
			$title: "Test"
		}
	},
	$titleTemplate: "Performance test",
	$valueTemplate: "Performance test",
	$descriptionTemplate: "Performance test",
	$functions: {},
	$services: {
		nodetest: { // list of currently valid licenses
			$method: "GET",
			$isMethod: false,
			$isHidden: true,
			$titel: "nodetest",
			$execute: function(_, context) {
				return perfTest(~_);
			}
		},
	}
};