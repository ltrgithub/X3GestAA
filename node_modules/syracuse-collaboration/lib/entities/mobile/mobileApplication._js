"use strict";

// Testcase: /syracuse-collaboration/test/server/mobileApplicationTest._js

var globals = require('streamline/lib/globals');
var helpers = require('syracuse-core/lib/helpers');
var forEachKey = helpers.object.forEachKey;
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var locale = require("syracuse-core/lib/locale");
var sdataStateless = require("syracuse-tablet/lib/sdataStatelessHack");

var tracer = null; //console.log;

exports.entity = {
	$titleTemplate: "Mobile application",
	$descriptionTemplate: "Mobile application definition",
	$valueTemplate: "{title}",
	$properties: {
		title: {
			$title: "Title",
			$linksToDetails: true,
			$isLocalized: true,
			$isMandatory: true
		},
		description: {
			$title: "Description",
			$isLocalized: true,
			$isMandatory: true
		},
		applicationName: {
			$title: "Mobile application name",
			$isMandatory: true,
			$isUnique: true
		}
	},
	$relations: {
		roles: {
			$type: "roles",
			$title: "Roles",
			$inv: "mobileApplications",
			$isComputed: true
		},
		endPoints: {
			$type: "endPoints",
			$title: "Endpoints",
			$isMandatory: true
		},
		homeDashboard: {
			$title: "Home dashboard",
			$type: "mobileDashboard",
			$isMandatory: true
		},
		representations: {
			$type: "mobileRepresentations",
			$title: "Representations",
			$isChild: true
		}
	},
	$searchIndex: {
		$fields: ["title", "description", "applicationName"]
	},
	$services: {
		applicationRepresentations: {
			$method: "POST",
			$isMethod: true,
			$overridesReply: true,
			$title: "Find used representations",
			$isHidden: false,
			$execute: function(_, context, instance) {
				var applicationData = {};

				var helpers;
				var cacheInfo = _getCacheInfo(_, instance);
				instance.endPoints(_).toArray(_).forEach_(_, function(_, ep) {
					helpers = _getHelpers(_, instance, context, ep);
					helpers.cacheInfo = cacheInfo;

					_gatherMetaData(_, instance, helpers, applicationData);
				});

				_updateRepresentations(_, instance, applicationData);

				instance.$diagnoses.push({
					$severity: "info",
					$message: locale.format(module, "reprsCollected", [Object.keys(applicationData.$pages).length])
				});
				return instance;
			}
		},

		/**
		 * return all mobile applications assigned with the current role
		 */
		availableApplications: {
			$isHidden: true,
			$method: "GET",
			$isMethod: false,
			$title: "Get available applications",
			$overridesReply: true,
			$execute: function(_, context) {
				var self = this;
				var $resources = [];

				var apps;
				var db = context.db;
				apps = db.fetchInstances(_, db.getEntity(_, "mobileApplication"), {});

				apps.forEach_(_, function(_, mobileApplication) {
					var app = _getApplicationInfo(_, context, mobileApplication);
					$resources.push(app);
				});

				context.reply(_, 200, {
					$resources: $resources
				});
			}
		},

		applicationMetaData: {
			$isHidden: true,
			$method: "GET",
			$isMethod: true,
			$title: "Get application meta data",
			$overridesReply: true,
			$execute: function(_, context, instance) {
				var applicationData = {};

				var cacheInfo = _getCacheInfo(_, instance);
				instance.endPoints(_).toArray(_).forEach_(_, function(_, ep) {
					helpers = _getHelpers(_, instance, context, ep);
					// eventually get role uuid as parameter
					helpers.role = context && context.parameters && context.parameters.role;
					helpers.cacheInfo = cacheInfo;
					_gatherMetaData(_, instance, helpers, applicationData);
				});
				context.reply(_, 200, applicationData);
			}
		}
	}
};

function _getHelpers(_, instance, context, endpoint) {
	var helpers;
	var helpers = {
		context: context,
		application: endpoint.application(_),
		contract: endpoint.contract(_),
		dataset: endpoint.dataset(_),
		endpointName: endpoint.application(_) + "." + endpoint.contract(_) + "." + endpoint.dataset(_),
		pageEntity: context.model.getEntity(_, "page"),
		mobileApplication: instance
	};

	// to make pageEntity.pageContent work when executing a method with POST
	helpers.context.instanceId = helpers.context.instanceId || instance.$uuid;
	return helpers;
}

function _getCacheInfo(_, instance) {
	var cacheInfo = {};
	instance.representations(_).toArray(_).forEach_(_, function(_, rep) {
		var key = rep.name(_) + "." + rep.facet(_);
		cacheInfo[key] = {
			cacheType: rep.cacheType(_),
			filter: rep.filter(_)
		};
	});
	return cacheInfo;
}

function _getApplicationInfo(_, context, mobileApplication) {
	var endpoints = [];
	mobileApplication.endPoints(_).toArray(_).forEach_(_, function(_, ep) {
		endpoints.push({
			application: ep.application(_),
			contract: ep.contract(_),
			dataset: ep.dataset(_),
			description: ep.description(_)
		});
	});

	var roles = [];
	mobileApplication.roles(_).toArray(_).forEach_(_, function(_, role) {
		roles.push({
			code: role.code(_),
			description: role.description(_)
		});
	});

	var $metaDataUrl = context.baseUrl + "/mobileApplications('" + mobileApplication.$uuid + "')/$service/applicationMetaData";
	return {
		$metaDataUrl: $metaDataUrl,
		$uuid: mobileApplication.$uuid,
		applicationName: mobileApplication.applicationName(_),
		title: mobileApplication.title(_),
		description: mobileApplication.description(_),
		$homeDashboard: {
			$uuid: mobileApplication.homeDashboard(_).$uuid,
			dashboardName: mobileApplication.homeDashboard(_).dashboardName(_)
		},
		roles: roles,
		endpoints: endpoints
	};
}

function _gatherMetaData(_, instance, helpers, applicationData) {

	applicationData.$application = _getApplicationInfo(_, helpers.context, instance);

	applicationData.$dashboards = {};
	applicationData.$gadgets = {};
	applicationData.$pages = {};

	tracer && tracer("Home dashboard:" + instance.homeDashboard(_).dashboardName(_));
	_processDashboard(_,
		helpers,
		applicationData,
		instance.homeDashboard(_)
	);

	tracer && tracer("Walk representations");
	_traversePages(_,
		helpers,
		applicationData);
}

function _processDashboard(_, helpers, applicationData, dashboard) {
	var dashboardName = dashboard.dashboardName(_);
	if (applicationData.$dashboards[dashboardName]) {
		return;
	}
	tracer && tracer("dashboard:" + dashboardName);

	var output = {
		$dashboardName: dashboardName,
		$title: dashboard.title(_),
		$description: dashboard.description(_),
		$vignettes: {}
	};

	dashboard.vignettes(_).toArray(_).forEach_(_, function(_, vignette) {
		var gadget = vignette.gadget(_);
		var data = {
			$uuid: gadget.$uuid,
			$displayStyle: vignette.displayStyle(_)
		};
		output.$vignettes[vignette.$uuid] = data;
		_processGadget(_, helpers, applicationData, gadget);
	});

	applicationData.$dashboards[dashboard.$uuid] = output;
}

function _processGadget(_, helpers, applicationData, gadget) {
	if (applicationData.$gadgets[gadget.$uuid]) {
		return;
	}

	var gt = gadget.gadgetType(_);
	tracer && tracer("gadget:" + gadget.title(_) + ":" + gt);
	var data = {
		$type: gt,
		$title: gadget.title(_),
		$description: gadget.description(_)
	};

	data["parameters"] = {};
	gadget.parameters(_).toArray(_).forEach_(_, function(_, p) {
		data["parameters"][p.name(_)] = {
			"title": p.title(_),
			"value": p.value(_)
		};
	});

	var endpoint;
	var fixedEp = false;
	if (gadget.endpoint(_)) {
		fixedEp = true;
		endpoint = gadget.endpoint(_).application(_) + "." + gadget.endpoint(_).contract(_) + "." + gadget.endpoint(_).dataset(_);
	} else {
		endpoint = helpers.application + "." + helpers.contract + "." + helpers.dataset;
	}

	switch (gt) {
		case "$dashboard":
			var dashboardName = gadget.mobileDashboard(_);
			var dashboard = _readDashboard(_, helpers, dashboardName);
			if (dashboard) {
				data["dashboardName"] = dashboardName;
				_processDashboard(_, helpers, applicationData, dashboard);
			} else {
				data = null;
			}
			break;

		case "$representation":
			var action = gadget.action(_);
			var entity = gadget.entity(_);
			var representation = gadget.representation(_);
			var facet = _getFacetForAction(action);
			var keyParameter = gadget.keyParameter(_);
			data["entity"] = entity;
			data["action"] = action;
			data["representation"] = representation;
			data["facet"] = facet;
			data["keyParameter"] = keyParameter;
			if (fixedEp) {
				data["endpoint"] = endpoint;
			}
			var pageName = endpoint + "." + representation + "." + facet;
			_processPage(_, helpers, applicationData, pageName);
			break;

		case "$process":
			data["processName"] = gadget.processName(_);
			data["processLeg"] = gadget.processLeg(_);
			data["processMenu"] = gadget.processMenu(_);
			break;

		case "$request":
			data["requestName"] = gadget.requestName(_);
			data["requestLevel"] = gadget.requestLevel(_);
			break;

		case "$stats":
			data["statName"] = gadget.statName(_);
			break;

		case "$external":
			data["externalUrl"] = gadget.externalUrl(_);
			break;

		default:
			throw new Error("Unknown gadget type: " + gt);
			data = null;
			break;
	}
	if (data) {
		applicationData.$gadgets[gadget.$uuid] = data;
	}
}

function _readDashboard(_, helpers, dashboardName) {
	var dashboard = helpers.context.db.fetchInstance(_, helpers.context.db.getEntity(_, "mobileDashboard", "$details"), {
		jsonWhere: {
			dashboardName: dashboardName
		}
	});
	return dashboard;
}

function _getFacetForAction(action) {
	return (action === "$create" ? "$edit" : action);
}

function _processPage(_, helpers, applicationData, pageName) {
	if (applicationData.$pages[pageName]) {
		return;
	}

	var repr = pageName.split(".");
	var representation = repr[3];
	var facet = repr[4];

	tracer && tracer("page: " + pageName);

	var x3Facet = facet === "$create" ? "$edit" : facet;
	var page;
	try {
		var opts = {
			application: repr[0],
			contract: repr[1],
			endpoint: repr[2],
			representation: representation,
			facet: x3Facet,
			device: "desktop",
			protoInPage: true
		};
		if (helpers.role) {
			opts.role = helpers.role;
		}
		page = helpers.pageEntity.pageContent(_, helpers.context, opts);
	} catch (e) {
		throw new Error("Unable to load " + pageName + " from " + helpers.dataset, e);
	}

	// For syracuse reps, there is no inlined proto.
	// add it here (Used for testcases only currently)
	if (typeof page.$prototype === "string") {
		var proto;
		if (helpers.applicationName === "syracuse") {
			proto = helpers.context.db.getEntity(_, representation).getPrototype(_, representation, facet);
		}
		if (!proto) {
			throw new Error("No prototype for: " + pageName);
		}
		page.$prototype = proto;
	}
	page.$prototype = sdataStateless.transformProto(page.$prototype, representation, facet, x3Facet);
	applicationData.$pages[pageName] = {
		"$notParsedYet": page
	};
}

function _traversePages(_, helpers, applicationData) {
	var $pages = applicationData.$pages;
	var done = false;
	while (!done) {
		done = true;
		Object.keys(applicationData.$pages).forEach_(_, function(_, pageName) {
			var page = $pages[pageName];
			if (page.$notParsedYet) { // only traverse each page once!
				page = page.$notParsedYet;
				var cache = _getPageCacheSettings(_, helpers, applicationData, pageName);

				applicationData.$pages[pageName] = {
					$page: page,
					$cache: cache
				};

				_parseProto(_, helpers, applicationData, page.$prototype, pageName);
				done = false;
			}
		});
	}
}

function _parseProto(_, helpers, applicationData, prototype, pageName, allowedLinks) {
	var repr = pageName.split(".");
	var representation = repr[3];
	var facet = repr[4];
	var $links;

	// Handle top level links $create, $delete, ...
	$links = prototype.$links;
	if ($links) {
		_parseLinks(_, helpers, applicationData, $links, allowedLinks, prototype, pageName);
	}
	$links = prototype.$properties && prototype.$properties.$resources && prototype.$properties.$resources.$item && prototype.$properties.$resources.$item.$links;
	if ($links) {
		_parseLinks(_, helpers, applicationData, $links, allowedLinks, prototype.$properties.$resources.$item, pageName);
	}
	if (prototype.$properties) {
		_parseProperties(_, helpers, applicationData, prototype.$properties, pageName);
	}
}

function _parseProperties(_, helpers, applicationData, properties, pageName) {
	var repr = pageName.split(".");
	var representation = repr[3];
	var facet = repr[4];

	Object.keys(properties).forEach_(_, function(_, propName) {
		var prop = properties[propName];

		switch (prop.$type) {
			case "application/x-array":
				if (prop.$item.$type === "application/x-reference") {
					// TODO:
				} else {
					_parseProto(_, helpers, applicationData, prop.$item, pageName,
						facet === "$details" ? ["$details", "$summary"] : ["$lookup"]);
				}
				break;
			case "application/x-reference":
				_parseProto(_, helpers, applicationData, prop.$item, pageName, ["$lookup"]);
				break;
		}
	});
}

function _parseLinks(_, helpers, applicationData, links, allowedLinks, prototype, pageName) {
	var repr = pageName.split(".");
	var representation = repr[3];
	var facet = repr[4];
	var endpoint = repr.slice(0, 3).join(".");

	Object.keys(links).forEach_(_, function(_, linkName) {
		if (!allowedLinks || allowedLinks.indexOf(linkName) > -1) { // If a list of allowed links is given, ignore other ones!
			var link = links[linkName];
			var url = link.$url;
			if (link.$isHidden) {
				return;
			}

			var rep = "representation=";
			var ir = url.indexOf(rep);
			if (url.indexOf("{$baseUrl}") != 0 || ir < 0) {
				tracer && tracer("Bad url: " + url);
			} else {
				var representation = url.substring(ir + rep.length);
				ir = representation.indexOf("&");
				if (ir > 0) representation = representation.substring(0, ir);
				representation = representation && representation.replace(/\{(.*?)\}/g, function(match, prop) {
					var value = prototype[prop];
					return value || "";
				});

				var rep = representation.split(".");
				_processPage(_, helpers, applicationData, endpoint + "." + rep[0] + "." + rep[1]);
			}
		}
	});
}

function _updateRepresentations(_, instance, applicationData) {
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "mobileRepresentation");
	var old = {};
	instance.representations(_).toArray(_).forEach_(_, function(_, repr) {
		var key = repr.name(_) + "." + repr.facet("_");
		old[key] = {
			cacheType: repr.cacheType(_),
			filter: repr.filter(_)
		};
	});
	instance.representations(_).reset(_);

	Object.keys(applicationData.$pages).forEach_(_, function(_, pageName) {
		var tmp = pageName.split(".");
		var rep = tmp[0];
		var facet = tmp[1];

		var repr = instance.representations(_).add();
		repr.name(_, rep);
		repr.facet(_, facet);
		var oldData = old[pageName];
		if (oldData) {
			repr.cacheType(_, oldData.cacheType);
			repr.filter(_, oldData.filter);
		}
	});
}

function _getPageCacheSettings(_, helpers, applicationData, pageName) {
	var cacheInfo = helpers.cacheInfo[pageName];
	if (!cacheInfo) {
		cacheInfo = {
			cacheType: "$auto",
			filter: null
		};
	}
	return cacheInfo;
}