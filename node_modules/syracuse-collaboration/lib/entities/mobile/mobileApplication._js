"use strict";

// Testcase: /syracuse-collaboration/test/server/mobileApplicationTest._js

var globals = require('streamline/lib/globals');
var helpers = require('syracuse-core/lib/helpers');
var forEachKey = helpers.object.forEachKey;
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var locale = require("syracuse-core/lib/locale");

var tracer = console.log;

exports.entity = {
	$titleTemplate: "Mobile application",
	$descriptionTemplate: "Mobile application definition",
	$valueTemplate: "{title}",
	$properties: {
		title: {
			$title: "Title",
			$linksToDetails: true,
			$isLocalized: true,
			$isMandatory: true
		},
		description: {
			$title: "Description",
			$isLocalized: true,
			$isMandatory: true
		},
		applicationName: {
			$title: "Mobile application name",
			$isMandatory: true,
			$isUnique: true
		}
	},
	$relations: {
		roles: {
			$type: "roles",
			$title: "Roles",
			$inv: "mobileApplications",
			$isComputed: true
		},
		homeDashboard: {
			$title: "Home dashboard",
			$type: "mobileDashboard",
			$isMandatory: true
		},
		representations: {
			$type: "mobileRepresentations",
			$title: "Representations",
			$isChild: true
		}
	},
	$searchIndex: {
		$fields: ["title", "description", "applicationName"]
	},
	$services: {
		applicationRepresentations: {
			$method: "POST",
			$isMethod: true,
			$overridesReply: true,
			$title: "Find used representations",
			$isHidden: false,
			$execute: function(_, context, instance) {
				var applicationData = {};
				var helpers = _getHelpers(_, instance, context);
				_gatherMetaData(_, instance, helpers, applicationData);
				_updateRepresentations(_, instance, helpers, applicationData);

				instance.$diagnoses.push({
					$severity: "info",
					$message: locale.format(module, "reprsCollected", [Object.keys(applicationData.$pages).length])
				});
				return instance;
			}
		},

		/**
		 * return all mobile applications assigned with the current role
		 */
		availableApplications: {
			$isHidden: true,
			$method: "GET",
			$isMethod: false,
			$title: "Get available applications",
			$overridesReply: true,
			$execute: function(_, context) {
				var self = this;
				var $resources = [];

				var apps = [];
				if (context && context.parameters && context.parameters.allApps) {
					var db = context.db;
					apps = db.fetchInstances(_, db.getEntity(_, "mobileApplication"), {});
				} else if (globals.context && globals.context.session) {
					var up = globals.context.session.getUserProfile(_);
					var upRole = up.selectedRole(_);
					if (upRole) {
						apps = upRole.mobileApplications(_).toArray(_);
					}
				}

				apps.forEach_(_, function(_, mobileApplication) {
					$resources.push({
						$metaDataUrl: context.baseUrl + "/mobileApplications('" + mobileApplication.$uuid + "')/$service/applicationMetaData",
						$uuid: mobileApplication.$uuid,
						applicationName: mobileApplication.applicationName(_),
						title: mobileApplication.title(_),
						description: mobileApplication.description(_)
					});
				});

				context.reply(_, 200, {
					$resources: $resources
				});
			}
		},

		applicationMetaData: {
			$isHidden: true,
			$method: "GET",
			$isMethod: true,
			$title: "Get application meta data",
			$overridesReply: true,
			$execute: function(_, context, instance) {
				var applicationData = {};
				var helpers = _getHelpers(_, instance, context);
				_gatherMetaData(_, instance, helpers, applicationData);
				context.reply(_, 200, applicationData);
			}
		}
	}
};

function _getHelpers(_, instance, context) {
	var helpers;
	if (globals.context && globals.context.session) {
		var up = globals.context.session.getUserProfile(_);
		var upEndpoint = up.selectedEndpoint(_);
		if (upEndpoint) {
			var helpers = {
				endpoint: upEndpoint,
				context: context,
				applicationName: upEndpoint.application(_),
				endpointName: upEndpoint.dataset(_),
				contractName: upEndpoint.contract(_),
				pageEntity: context.model.getEntity(_, "page")
			};
			var cacheInfo = {};
			instance.representations(_).toArray(_).forEach_(_, function(_, rep) {
				var key = rep.name(_) + "." + rep.facet(_);
				cacheInfo[key] = {
					cacheType: rep.cacheType(_),
					filter: rep.filter(_)
				};
			});
			helpers.cacheInfo = cacheInfo;

			// to make pageEntity.pageContent work when executing a method with POST
			helpers.context.instanceId = helpers.context.instanceId || instance.$uuid;
		} else {
			throw new Error("Unable to init meta data collection, no endpoint selected");
		}
	} else {
		throw new Error("Unable to init meta data collection, no session");
	}
	if (!helpers) {
		throw new Error("Unable to init meta data collection");
	}
	return helpers;
}

function _gatherMetaData(_, instance, helpers, applicationData) {

	applicationData.$application = {
		$metaDataUrl: helpers.context.baseUrl + "/mobileApplications('" + instance.$uuid + "')/$service/applicationMetaData",
		$uuid: instance.$uuid,
		applicationName: instance.applicationName(_),
		title: instance.title(_),
		description: instance.description(_),
		$homeDashboard: {
			$uuid: instance.homeDashboard(_).$uuid,
			dashboardName: instance.homeDashboard(_).dashboardName(_)
		}
	};
	applicationData.$dashboards = {};
	applicationData.$gadgets = {};
	applicationData.$pages = {};

	_processDashboard(_,
		helpers,
		applicationData,
		instance.homeDashboard(_)
	);
	_traversePages(_,
		helpers,
		applicationData);
}

function _processDashboard(_, helpers, applicationData, dashboard) {
	var dashboardName = dashboard.dashboardName(_);
	if (applicationData.$dashboards[dashboardName]) {
		return;
	}
	tracer && tracer("dashboard:" + dashboardName);

	var output = {
		$dashboardName: dashboardName,
		$vignettes: {}
	};
	dashboard.vignettes(_).toArray(_).forEach_(_, function(_, vignette) {
		var gadget = vignette.gadget(_);
		var data = {
			$uuid: gadget.$uuid,
			$displayStyle: vignette.displayStyle(_)
		};
		output.$vignettes[vignette.$uuid] = data;
		_processGadget(_, helpers, applicationData, gadget);
	});

	applicationData.$dashboards[dashboard.$uuid] = output;
}

function _processGadget(_, helpers, applicationData, gadget) {
	if (applicationData.$gadgets[gadget.$uuid]) {
		return;
	}

	var gt = gadget.gadgetType(_);
	var data = {
		$type: gt
	};

	switch (gt) {
		case "$dashboard":
			var dashboardName = gadget.mobileDashboard(_);
			var dashboard = _readDashboard(_, helpers, dashboardName);
			if (dashboard) {
				data["dashboardName"] = dashboardName;
				_processDashboard(_, helpers, applicationData, dashboard);
			} else {
				data = null;
			}
			break;

		case "$representation":
			var action = gadget.action(_);
			var entity = gadget.entity(_);
			var representation = gadget.representation(_);
			var facet = _getFacetForAction(action);
			data["entity"] = entity;
			data["action"] = action;
			data["representation"] = representation;
			data["facet"] = facet;
			_processPage(_, helpers, applicationData, representation, facet);
			break;

		case "$process":
			data["processName"] = gadget.processName(_);
			data["processLeg"] = gadget.processLeg(_);
			data["processMenu"] = gadget.processMenu(_);
			break;

		case "$request":
			data["requestName"] = gadget.requestName(_);
			data["requestLevel"] = gadget.requestLevel(_);
			break;

		case "$stats":
			data["statName"] = gadget.statName(_);
			break;

		case "$external":
			data["externalUrl"] = gadget.externalUrl(_);
			break;

		default:
			throw new Error("Unknown gadget type: " + gt);
			data = null;
			break;
	}
	if (data) {
		applicationData.$gadgets[gadget.$uuid] = data;
	}
}

function _readDashboard(_, helpers, dashboardName) {
	var dashboard = helpers.context.db.fetchInstance(_, helpers.context.db.getEntity(_, "mobileDashboard", "$details"), {
		jsonWhere: {
			dashboardName: dashboardName
		}
	});
	return dashboard;
}

function _getFacetForAction(action) {
	return (action === "$create" ? "$edit" : action);
}

function _processPage(_, helpers, applicationData, representation, facet) {
	var pageName = representation + "." + facet;
	if (applicationData.$pages[pageName]) {
		return;
	}

	tracer && tracer("page: " + pageName);
	var opts = {
		application: helpers.applicationName,
		contract: helpers.contractName,
		endpoint: helpers.endpointName,
		representation: representation,
		facet: facet,
		device: "desktop",
		protoInPage: true
	};

	var page = helpers.pageEntity.pageContent(_, helpers.context, opts);

	// For syracuse reps, there is no inlined proto.
	// add it here (Used for testcases only currently)
	if (typeof page.$prototype === "string") {
		var proto;
		if (helpers.applicationName === "syracuse") {
			proto = helpers.context.db.getEntity(_, representation).getPrototype(_, representation, facet);
		}
		if (!proto) {
			throw new Error("No prototype for: " + pageName);
		}
		page.$prototype = proto;
	}
	applicationData.$pages[pageName] = {
		"$notParsedYet": page
	};
}

function _traversePages(_, helpers, applicationData) {
	var $pages = applicationData.$pages;
	var done = false;
	while (!done) {
		done = true;
		Object.keys(applicationData.$pages).forEach_(_, function(_, pageName) {
			var page = $pages[pageName];
			if (page.$notParsedYet) { // only traverse each page once!
				page = page.$notParsedYet;
				var cache = _getPageCacheSettings(_, helpers, applicationData, pageName);
				applicationData.$pages[pageName] = {
					$page: page,
					$cache: cache
				};

				var rep = pageName.split(".");
				_parseProto(_, helpers, applicationData, page.$prototype, rep[0], rep[1]);
				done = false;
			}
		});
	}
}

function _parseProto(_, helpers, applicationData, prototype, representation, facet, allowedLinks) {
	var $links = prototype.$links;
	if (!$links) {
		return;
	}
	// Handle top level links $create, $delete, ...
	_parseLinks(_, helpers, applicationData, $links, allowedLinks, prototype);

	_parseProperties(_, helpers, applicationData, prototype.$properties, representation, facet);
}

function _parseProperties(_, helpers, applicationData, properties, representation, facet) {
	Object.keys(properties).forEach_(_, function(_, propName) {
		var prop = properties[propName];
		switch (prop.$type) {
			case "application/x-array":
				if (prop.$item.$type === "application/x-reference") {
					// TODO:
				} else {
					_parseProto(_, helpers, applicationData, prop.$item, representation, facet,
						facet === "$details" ? ["$details", "$summary"] : ["$lookup"]);
				}
				break;
			case "application/x-reference":
				_parseProto(_, helpers, applicationData, prop.$item, representation, facet, ["$lookup"]);
				break;
		}
	});
}

function _parseLinks(_, helpers, applicationData, links, allowedLinks, prototype) {
	Object.keys(links).forEach_(_, function(_, linkName) {
		if (!allowedLinks || allowedLinks.indexOf(linkName) > -1) { // If a list of allowed links is given, ignore other ones!
			var link = links[linkName];
			var url = link.$url;
			if (link.$isHidden) {
				return;
			}

			var rep = "representation=";
			var ir = url.indexOf(rep);
			if (url.indexOf("{$baseUrl}") != 0 || ir < 0) {
				tracer && tracer("Bad url: " + url);
			} else {
				var representation = url.substring(ir + rep.length);
				ir = representation.indexOf("&");
				if (ir > 0) representation = representation.substring(0, ir);
				representation = representation && representation.replace(/\{(.*?)\}/g, function(match, prop) {
					var value = prototype[prop];
					return value || "";
				});

				var rep = representation.split(".");
				_processPage(_, helpers, applicationData, rep[0], rep[1]);
			}
		}
	});
}

function _updateRepresentations(_, instance, helpers, applicationData) {
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "mobileRepresentation");
	var old = {};
	instance.representations(_).toArray(_).forEach_(_, function(_, repr) {
		var key = repr.name(_) + "." + repr.facet("_");
		old[key] = {
			cacheType: repr.cacheType(_),
			filter: repr.filter(_)
		};
	});
	instance.representations(_).reset(_);

	Object.keys(applicationData.$pages).forEach_(_, function(_, pageName) {
		var tmp = pageName.split(".");
		var rep = tmp[0];
		var facet = tmp[1];

		var repr = instance.representations(_).add();
		repr.name(_, rep);
		repr.facet(_, facet);
		var oldData = old[pageName];
		if (oldData) {
			repr.cacheType(_, oldData.cacheType);
			repr.filter(_, oldData.filter);
		}
	});
}

function _getPageCacheSettings(_, helpers, applicationData, pageName) {
	var cacheInfo = helpers.cacheInfo[pageName];
	if (!cacheInfo) {
		cacheInfo = {
			cacheType: "$auto",
			filter: null
		};
	}
	return cacheInfo;
}