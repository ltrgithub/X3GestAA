"use strict"

var streams = require("streamline/lib/streams/streams");
var helpers = require("syracuse-core/lib/helpers");

function _clone(obj) {
	var result = {};
	for (var i in obj)
	result[i] = obj[i];
	return result;
}

var _x3StoreTypes = {
	"1": "x3_file",
	"2": "x3_blob",
	"3": "x3_clob"
}

var _itemLoaderMap = {
	syracuse: function(ep, context, parameters, _) {
		var params = helpers.object.clone(parameters);
		// fetch count+1 to test if we're on last page
		if(params.count)
			params.count = params.count + 1;
		// convert paging key into where
		var keyWhere = "";
		if(params.key && params.orderBy && params.orderBy.length) {
			var s = params.key.split(".");
			keyWhere = params.orderBy[0].binding + " " + s[0] + " " + s.slice(1).join(".");
			delete params.key;
		}
		if(params.where)
			params.where = "(" + params.where + ") and (" + keyWhere + ")";
		else
			params.where = keyWhere;
		//
		var res = [];
		var db = ep.getOrm(_, false);
		var volEnt = db && db.model.getEntity("storageVolume");
		db && volEnt && db.fetchInstances(_, volEnt, params).forEach_(_, function(_, v) {
			var inst = context.db.model.getEntity("storageVolumeQuery").factory.createInstance(_, null, context.db);
			inst._orgResource = v.serializeInstance(_);
			inst._orgPrototype = context.getPrototypeResource(_, "storageVolume.$query");
			inst.code(_, v.code(_));
			inst.description(_, v.description(_));
			inst.storageType(_, v.storageType(_));
			//
			inst.$links = v.$links || volEnt.$links || {};
			//
			res.push(inst);
		});
		//
		if(res.length >= params.count)
			context.isLastPage = false;
		//
		return res;
	},
	x3: function(ep, context, parameters, _) {
		var res = [];
		// make a request to x3 data
		// prototype fetch
		var baseUrl = context.url.split("/").slice(0, 3).join("/") + ep.getBaseUrl(_);
		var options = {
			url: baseUrl + "/$prototypes('AVOLUME.$query')",
			method: "GET",
			headers: _clone(context.request.headers || {})
		}
		var req = streams.httpRequest(options);
		var proto = JSON.parse(req.end().response(_).readAll(_));
		// query
		// TODO: replace all corresponding properties
		var query = Object.keys(context.query).map(function(q) {
			return encodeURIComponent(q) + "=" + encodeURIComponent(context.query[q].
					replace("code", "VOLUME").
					replace("description", "TITLE"));
		}).join("&");
		var options = {
			url: baseUrl + "/AVOLUME?representation=AVOLUME.$query" + (query ? "&" + query : ""),
			method: "GET",
			headers: _clone(context.request.headers || {})
		}
//		console.log("url (75): "+options.url);
		var req = streams.httpRequest(options);
		var resp = JSON.parse(req.end().response(_).readAll(_));
		//
		if(resp.$links && resp.$links.$next)
			context.isLastPage = false;
		//
		((resp && resp.$resources) || []).forEach_(_, function(_, r) {
			var inst = context.db.model.getEntity("storageVolumeQuery").factory.createInstance(_, null, context.db);
			inst._orgResource = r;
			inst._orgPrototype = proto;
			inst.code(_, r.VOLUME);
			inst.description(_, r.TITLE);
			inst.storageType(_, _x3StoreTypes[r.VOLTYP]);
			inst.endpoint(_, ep);
			//
//			inst.$links = v.$links || volEnt.$links || {};
			//
			res.push(inst);
		});
		return res;
	},
	other: function(_, ep, res, context, parameters) {
		// do nothing
	}
}

exports.entity = {
	$isPersistent: false,
	$keyPager: true,
	$properties: {
		code: {
			$title: "Code"
		},
		description: {
			$title: "Description"
		},
		storageType: {
			$title: "Type",
			$enum: ["db_file", "rest", "file", "x3_file", "x3_blob", "x3_clob"],
			$enumCaptions: ["Syracuse Standard", "Web Server", "File", "File", "Blob", "Clob"]
		}
	},
	$relations: {
		endpoint: {
			$title: "Endpoint",
			$type: "endPoint"
		}
	},
	$fetchInstances: function(_, context, parameters) {
		var self = this;
		//
		// TODO: dataset ?
		var preliminary = [];
		// fetch all endpoints
		var endpoints = context.db.fetchInstances(_, context.db.model.getEntity("endPoint"), {});
		// use of futures
		var res = [];
		context.isLastPage = true;
		endpoints.forEach_(_, function(_, ep) {
			if(ep.applicationRef(_))
				res.push(_itemLoaderMap[ep.applicationRef(_).protocol(_)](ep, context, parameters));
		});
		res.forEach_(_, function(_, rf) {
			rf(_).forEach(function(r) {
				preliminary.push(r);
			});
		});
		//
		if(preliminary.length > parameters.count)
			context.isLastPage = false;
		//
		return preliminary;
	},
	$functions: {
		$serialize: function(_) {
			var self = this;
			var _orgProto = (self._orgPrototype && self._orgPrototype.$.$resources.$item) || {};
			//
			var res = self._internalSerialize(_);
			var r = self._orgResource;
			//
			res.$pluralType = _orgProto.$pluralType;
			res.$representation = _orgProto.$representation;
			res.$baseUrl = self._orgPrototype.$baseUrl;
			res.$uuid = r.$uuid;
			res.$key = r.$key;
			// copy some data, needed for links
			res.VOLUME = r.VOLUME;
			//
//			res.$ = self._orgPrototype.$.$resources.$item.$;
			res.$links = res.$links || {};
			var orgLinks = self._orgPrototype.$.$resources.$item.$links;
			(res.$links.$edit = res.$links.$edit || {
				$title: "Modifier",
				$method: "POST"
			}).$url = orgLinks.$edit.$url;
			(res.$links.$delete = res.$links.$delete || {}).$url = orgLinks.$delete.$url;
			res.$links.$browse = res.$links.$browse || orgLinks.$browse;
			// property links
			// TODO: define mapping in the property
			var _detLink = ((_orgProto.$.code || _orgProto.$.VOLUME || {}).$links || {}).$details;
			if(_detLink) {
				res.$.code = res.$.code || {};
				res.$.code.$links = res.$.code.$links || {};
				res.$.code.$links.$details = _detLink;
			}
			// TEMP
			if(((_orgProto.$.VOLUME || {}).$links || {}).$browse) {
				res.$links.$browse = _orgProto.$.VOLUME.$links.$browse;
				res.$links.$browse.$title = "List of files";
			}
			//
			return res;
		}
	},
	$defaultOrder: [["code"]]
}