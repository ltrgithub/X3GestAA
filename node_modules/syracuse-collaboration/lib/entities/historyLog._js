"use strict";
var locale = require('streamline-locale');
var util = require('util');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var helpers = require('@sage/syracuse-core').helpers;
var fs = require('streamline-fs');
var fsp = require('path');
var globals = require('streamline-runtime').globals;

var secProfile;
var entitiesToLog;


function _hasModifiedProperties(obj) {
	return JSON.stringify(obj, null, 1).match(/\$value|\$prev|\$added|\$deleted/g)
}

function _isProperty(obj) {
	return (obj && obj.hasOwnProperty("$prev") && (typeof(obj.$prev) != "object")) ||
		(obj && obj.hasOwnProperty("$value") && (typeof(obj.$value) != "object")) ||
		(obj && obj.$prev && (obj.$prev.hasOwnProperty("default"))) ||
		(obj && obj.$value && (obj.$value.hasOwnProperty("default")))

}

function _isCollection(obj) {
	return (obj && Array.isArray(obj) && _hasModifiedProperties(obj))
}

function _isReference(obj) {
	return (obj && obj.hasOwnProperty("$prev") &&
		((typeof(obj.$prev) == "object") || (typeof(obj.$value) == "object")))
}


function _propertyToText(_, instance, obj, path) {
	var result = {};
	if (_isCollection(obj)) {
		for (var item in obj) {
			var realName = _getProperty(_, instance.getLoggedEntity(_), path).getTitle();
			result[realName] = result[realName] || [];
			if (_hasModifiedProperties(obj[item])) {
				var aitem = _propertyToText(_, instance, obj[item], path);
				var value = _getValueFromTemplate(_, instance, path, obj[item]);
				if ((value) && (obj[item].$added)) value = locale.format(module, "added", value);
				if ((value) && (obj[item].$deleted)) value = locale.format(module, "deleted", value);
				var tmpObj = {}
				if (value) tmpObj[value] = aitem
				else tmpObj = aitem
				result[realName].push(tmpObj);
			}
		}
	} else {
		for (var key in obj) {
			if (_isProperty(obj[key])) {
				realName = _getProperty(_, instance.getLoggedEntity(_), path + '.' + key).getTitle();
				result[realName] = locale.format(module, "prevValue", obj[key].$value, obj[key].$prev);
			} else if (_isReference(obj[key])) {
				result[key] = _propertyToText(_, instance, item, key)
			} else if (_isCollection(obj[key])) {
				result[key] = _propertyToText(_, instance, item, key)
			}
		}

	}
	return result;
}

function _getProperty(_, entity, propName) {
	var oProp = propName;
	var nProp;

	if (propName.includes('.')) {
		var a = propName.split(".");
		oProp = a.shift();
		nProp = a.join(".");
	}
	var rel = entity.$relations[oProp] || entity.$properties[oProp];
	if (nProp) {
		var singular = rel.type && entity.getModel().singularize(rel.type);
		return _getProperty(_, entity.getModel().getEntity(_, singular), nProp);
	}
	return rel;
}

function _getLocalizeValue(data) {
	if (!data) return
	var locCode = (globals.context.sessionLocale || locale.current).toLowerCase();
	var val = ((locCode && data[locCode]) || data["default"] || data);
	return val;
}


function _getValueFromTemplate(_, instance, propName, obj) {
	if ((!obj) || (Object.keys(obj).length === 0)) return
	var prop = _getProperty(_, instance.getLoggedEntity(_), propName);
	if ((!prop) || (!prop.targetEntity)) return
	var template = prop.targetEntity.$valueTemplate;
	if (!template) return "undefined";
	var res = template.expression;
	if (!template.matches) return res;
	template.matches.forEach_(_, function(_, match) {
		var prop = match.substring(1, match.length - 1);
		if (obj[prop]) res = res.replace(match, _getLocalizeValue(obj[prop]))
		else res.replace(match, "")
	});
	return res;

}

function _getHistoryLogItems(_, instance) {
	var result = [];
	var delta = instance.delta(_);
	for (var key in delta) {
		if (_isProperty(delta[key])) {
			var prop = _getProperty(_, instance.getLoggedEntity(_), key);
			result.push({
				property: prop.getTitle(),
				oldValue: (prop.$type == "password" ? "encrypted" : _getLocalizeValue(delta[key].$prev)),
				newValue: (prop.$type == "password" ? "encrypted" : _getLocalizeValue(delta[key].$value))
			})
		} else if (_isCollection(delta[key])) {
			var d = JSON.stringify(_propertyToText(_, instance, delta[key], key), null, 5);
			d = d.replace(/[\[\]\{\}\"]+/g, '').replace(/,\n|,$/g, '\n').replace(/^\s*\n/gm, '');

			result.push({
				property: _getProperty(_, instance.getLoggedEntity(_), key).getTitle(),
				newValue: locale.format(module, "itemChanges",
					delta[key].filter(item => item.$added).length,
					delta[key].filter(item => item.$deleted).length,
					delta[key].filter(item => !item.$deleted && !item.$added && _hasModifiedProperties(item)).length),
				description: d

			})

		} else if (_isReference(delta[key])) {
			var d = JSON.stringify(_propertyToText(_, instance, delta[key], key), null, 5);
			result.push({
				property: _getProperty(_, instance.getLoggedEntity(_), key).getTitle(),
				oldValue: _getValueFromTemplate(_, instance, key, delta[key].$prev),
				newValue: _getValueFromTemplate(_, instance, key, delta[key].$value)
			})
		}
	}
	return result;
}


exports.entity = {
	$canCreate: false,
	$canDelete: false,
	$canEdit: false,
	$titleTemplate: "History log",
	$valueTemplate: "{type}",
	$descriptionTemplate: "{type}",
	$showMeta: "$creUser,$creDate",
	$properties: {
		name: {
			$title: "Entity name",
			$type: "string",
			$linksToDetails: true
		},
		value: {
			$title: "Value",
			$type: "string",
		},
		op: {
			$title: "Operation",
			$type: "string",
			$isMandatory: true,
			$isReadOnly: true,
			$enum: [{
				$value: "del",
				$title: "Deleted"
			}, {
				$value: "add",
				$title: "Created"
			}, {
				$value: "mod",
				$title: "Modified"
			}],
		},
		type: {
			$title: "Type",
			$type: "string"
		},
		delta: {
			$title: "Delta",
			$type: "object"
		},
		changes: {
			$title: "Changes",
			$type: "string",
			$format: "html",
			$compute: function(_, instance) {}
		},
		jsonDelta: {
			$title: "JSON Delta",
			$type: "string",
			$compute: function(_, instance) {
				return JSON.stringify(instance.delta(_), null, 3);
			},
			$isHidden: function(_, instance) {
				return instance.op(_) == "del";
			}

		}


	},

	$relations: {
		items: {
			$title: "Changes",
			$type: "historyLogItems",
			$isChild: true,
			$compute: true
		}
	},

	$functions: {
		getLoggedEntity: function(_) {
			var self = this;
			return self._db.model.getEntity(_, self.name(_));
		},
		$serialize: function(_) {
			let res = this._internalSerialize(_);
			res.items = _getHistoryLogItems(_, this);
			return res;
		}
	},

	$expire: function(_, instance) {
		var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
		var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {});
		if (setting && setting.historyMaxDays(_))
			return setting.historyMaxDays(_) * 24 * 3600;
	}
};

function _allowLogHistory(_, instance) {
	if (instance._meta.name == "historyLog") return false;
	if (instance._meta.name == "setting") return true;
	if (!entitiesToLog) {
		secProfile = secProfile || JSON.parse(fs.readFile(fsp.join(__dirname, "../security/historySetting.json"), _));
		entitiesToLog = [];
		var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
		var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {});
		setting.historyLogSettings(_).toArray(_)
			.filter_(_, function(_, hls) {
				return hls.enable(_);
			})
			.forEach_(_, function(_, hls) {
				for (var key in secProfile[hls.code(_)].entities)
					if (entitiesToLog.indexOf(key) === -1) {
						entitiesToLog.push(key);
					}
			});
	}
	return (entitiesToLog.indexOf(instance._meta.name) !== -1)
}


function _logHistory(_, instance, param) {

	if ((instance._parent) || (!_allowLogHistory(_, instance))) return;
	var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
	var op = "mod";
	if (instance.$created) op = "add";

	var serializer = require("syracuse-orm/lib/serializer");
	var deltaSerializer = new serializer.DeltaSerializer();
	var delta = deltaSerializer.serialize(_, instance, null, true);

	if (!_hasModifiedProperties(delta)) return


	var hl = db.getEntity(_, "historyLog").createInstance(_, db);

	hl.name(_, instance._meta.name);
	hl.op(_, op);
	hl.value(_, instance.getValue(_));
	hl.delta(_, delta);
	hl.save(_);
}

function _logDeleteHistory(_, instance) {
	if ((instance._parent) || (!_allowLogHistory(_, instance))) return;

	var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
	var si = instance.serializeInstance(_);
	var delta = helpers.resource.sdataDelta(si, si, false, false, false);
	var hl = db.getEntity(_, "historyLog").createInstance(_, db);
	var instTpl = instance._meta.$valueTemplate && instance._meta.$valueTemplate.resolve(si);
	hl.name(_, instance._meta.name);
	hl.op(_, "del");
	instTpl && hl.value(_, instTpl);
	hl.delta(_, delta);
	hl.save(_);
}

exports.reloadHistoryRights = function(_) {
	entitiesToLog = null;
}
exports.registerModelEvents = function(_, config) {
	try {
		var model = adminHelper.getCollaborationEndpoint(_).getModel(_, false);
		model && model.registerEvent(_, "$afterSave", "logHistory", _logHistory);
		model && model.registerEvent(_, "$afterDelete", "logDeleteHistory", _logDeleteHistory);
	} catch (e) {
		console.log("Cannot register history model events " + e);
		return;
	}


};