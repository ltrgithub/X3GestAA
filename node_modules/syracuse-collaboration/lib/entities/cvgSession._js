"use strict";

var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var datetime = require("syracuse-core/lib/types/datetime");

// This entity is not persistent 
// Data are provided on demand by sessionManager
// Entity data are provided by cvgSession.cvgAdmSessInfo
exports.entity = {
	$lockType: "noLock",
	$canDelete: false,
	$canCreate: false,
	$canEdit: false,
	$capabilities: "",
	$titleTemplate: "Convergence session status",
	$descriptionTemplate: " ",
	$valueTemplate: " ",
	$properties: {
		remoteaddr: {
			$title: "ClientIp",
			$displayLength: 7
		},
		syralogin: {
			$title: "UserLogin",
			$displayLength: 8
		},
		x3host: {
			$title: "x3Host",
			$displayLength: 8
		},
		x3port: {
			$title: "x3Port",
			$displayLength: 5
		},
		x3solution: {
			$title: "x3Solution",
			$displayLength: 8
		},
		x3folder: {
			$title: "x3Folder",
			$displayLength: 7
		},
		x3user: {
			$title: "x3User",
			$displayLength: 6
		},
		x3lang: {
			$title: "x3Lang",
			$displayLength: 5
		},
		x3func: {
			$title: "X3Func",
			$displayLength: 6
		},
		x3pid: {
			$title: "X3Pid",
			$displayLength: 5
		},
		lastAccess: {
			$title: "Last access",
			$type: "datetime",
			$displayLength: 9
		},
		timeout: {
			$title: "Timeout(sec)",
			$displayLength: 8
		},
		reused: {
			$title: "Reused",
			$displayLength: 5,
			$type: "boolean",
		},
		open: {
			$title: "Open",
			$displayLength: 4,
			$type: "boolean",
		},
		httpreferer: {
			$title: "Http referer",
			$displayLength: 10
		},
		creationDate: {
			$title: "Creation date",
			$type: "datetime",
			$displayLength: 9
		},
		sid: {
			$title: "Session id",
			$isHidden: true,
		},
		syraid: {
			$title: "Syracuse id",
			$isHidden: true,
		},
		cid: {
			$title: "cvgClient id",
			$isHidden: true,
		}
	},
	$relations: {},
	$functions: {
		$setId: function(_, context, id) {
			// instance as the same id as cvgSession
			var sessInfo = sessionManager.cvgAdmSessInfo(_, id);
			// error could occur if kill service is called on a session which has been closed by timeout (list must be refreshed before kill action)
			if (sessInfo == null) throw new Error("Convergence session not found in list\nid=" + id);
			// fulfill instance
			for (var p in sessInfo) {
				this[p](_, sessInfo[p]);
			}
		}
	},
	$services: {
		kill: {
			$method: "GET",
			$confirm: "This operation will delete the session and close assciated X3 clients.\n\nDo you want to continue ?",
			$isMethod: true,
			$title: "Kill session",
			$execute: function(_, context) {
				try {
					var inst = context.instance;
					if (inst) {
						var syraSess = sessionManager.sessionById(inst.syraid(_));
						if (syraSess) syraSess.closeCvgSession(inst.sid(_), false, "Closed by administrator", _);
						else throw new Error("Syracuse session not found\nid=" + inst.syraid(_));
					} else throw new Error("Instance not found in context");
					return {
						$diagnoses: [{
							severity: "info",
							message: "Session has been deleted"
						}]
					};
				} catch (e) {
					return {
						$diagnoses: [{
							severity: "error",
							message: e.message
						}]
					};
				}
			}
		}
	},
	$fetchInstances: function(_, context, parameters) {
		var result = [],
			self = this;
		var entity = context.db.model.getEntity(_, "cvgSession");
		var sessInfos = sessionManager.cvgAdmSessInfos(_);
		sessInfos.forEach_(_, function(_, info) {
			var inst = entity.factory.createInstance(_, null, context.db);
			for (var p in info) {
				if (inst[p]) inst[p](_, info[p]);
			}
			// same uid as convergence session in order to be able to retrieve the instance in context.instance - see kill service
			inst.$uuid = info.sid;
			result.push(inst);
		});
		return result;
	},
	$defaultOrder: [
		["remoteaddr", true],
		["syralogin", true]
	]
};