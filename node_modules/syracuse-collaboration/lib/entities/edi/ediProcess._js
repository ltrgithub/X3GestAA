"use strict";

var config = require("syracuse-main/lib/nodeconfig").config;
var EdiEntity = require("syracuse-edi/lib/EdiEntity");
var EdiType = require("syracuse-edi/lib/enumType").EdiType;
var EdiTypeToClass = require("syracuse-edi/lib/enumType").EdiTypeToClass;

exports.entity = {
	$capabilities: "",
	$titleTemplate: "EDI list process running",
	$descriptionTemplate: " ",
	$properties: {
		idProcess: {
			$title: "id Processus" // id of the edi process
		},
		x3ClassName: {
			$title: "X3 class name "
		},
		idMessageMapping: {
			$title: "Id of Message Mapping",
			$propagate: function(_, instance, val) {
				var cacheEdi = EdiEntity.getEdiCacheEntity(_, {
					filter: {
						sdataFilter: "id eq '" + val + "' and type eq '" + EdiType.MESSAGEMAPPING + "'"
					},
					db: instance._db
				});
				if (cacheEdi) {
					instance.messageMapping(_, cacheEdi.json(_));
				} else {
					// get the protocol by using x3 and cached it in mongodb
					instance.messageMapping(_, getEntity(_, EdiType.MESSAGEMAPPING, val));

				}
			}
		},
		idSequentialFile: {
			$title: "id of Sequential File",
			$propagate: function(_, instance, val) {
				var cacheEdi = EdiEntity.getEdiCacheEntity(_, {
					filter: {
						sdataWhere: "id eq '" + val + "' and type eq '" + EdiType.SEQFILE + "'"
					},
					db: instance._db
				});
				if (cacheEdi) {
					instance.sequentialFile(_, cacheEdi.json(_));
				} else {
					// get the protocol by using x3 and cached it in mongodb
					instance.sequentialFile(_, getEntity(_, EdiType.SEQFILE, val));

				}
			}
		},
		idEdiFlow: {
			$title: "id of Edi Flow",
			$propagate: function(_, instance, val) {
				var cacheEdi = EdiEntity.getEdiCacheEntity(_, {
					filter: {
						sdataWhere: "id eq '" + val + "' and type eq '" + EdiType.EDIFLOW + "'"
					},
					db: instance._db
				});
				if (cacheEdi) {
					instance.ediFlow(_, cacheEdi.json(_));
				} else {
					// get the protocol by using x3 and cached it in mongodb
					instance.ediFlow(_, getEntity(_, EdiType.EDIFLOW, val));

				}
			}

		},
		folder: {
			$title: "dataset value of the endpoint",
		},
		idProtocol: {
			$title: "id of protocol",
			$propagate: function(_, instance, val) {
				var cacheEdi = EdiEntity.getEdiCacheEntity(_, {
					filter: {
						sdataWhere: "id eq '" + val + "' and type eq '" + EdiType.PROTOCOL + "'"
					},
					db: instance._db
				});
				if (cacheEdi) {
					instance.protocol(_, cacheEdi.json(_));
				} else {
					// get the protocol by using x3 and cached it in mongodb
					instance.protocol(_, getEntity(_, EdiType.PROTOCOL, val));
					// save in a cache edi
				}
			}
		},
		messageMapping: {
			$title: "json content of the messageMapping",
			$type: "json"
		},
		sequentialFile: {
			$title: "json content of the sequentialFile",
			$type: "json"
		},
		ediFlow: {
			$title: "json content of the ediFlow",
			$type: "json"
		},
		protocol: {
			$title: "json content of the protocol",
			$type: "json"
		}

	},
	$relations: {

	},
	$functions: {
		getEntity: function(_, type, id) {
			var ep = adminHelper.getEndpoint(_, {
				dataset: this.folder(_)
			});
			var entity = ep.getModel(_).getEntity(_, EdiTypeToClass[type], facet);
			var db = ep.getOrm(_);
			return db.fetchInstance(_, entity, id);
		}
	},
	$services: {},
	$expire: function(_, instance) {
		/*/ set in hard the value, it will be configured after
         if (config.edi.cache.timeout) { // timeout + 1
         return (config.edi.cache.timeout + 1) * 60000;
         }*/
	}

};