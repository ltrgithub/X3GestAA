"use strict";

var locale = require("syracuse-core/lib/locale");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var httpClient = require('syracuse-httpclient/lib/httpClient');
var dns = require('dns');
//var x3pool = require("syracuse-x3/lib/pool");
var adminDb;

var hasErrors = function(body, k) {
	var msg;
	var hasErr = body && body.$diagnoses && body.$diagnoses.some(function(diag) {
		if (diag.$severity === "error") {
			msg = locale.format(module, "relatedFieldErr") + " : " + k + " : " + diag.$message;
			return msg;
		} else return false;
	});
	if (!hasErr) {
		for (var key in body) {
			if (typeof body[key] === "object") {
				hasErr = hasErr || hasErrors(body[key], key);
				if (hasErr) return hasErr;
			}
		}
	}
	return msg || hasErr;
};

var saveAndCheckErrors = function(_, inst) {
	var sav = inst.save(_);
	var err = hasErrors(sav);
	if (err) {
		throw new Error(err);
	}
};

exports.entity = {
	$titleTemplate: "X3 solution",
	$descriptionTemplate: "X3 solution settings",
	$valueTemplate: "{solutionName}",
	$helpPage: "Administration-reference_X3-solutions",
	$capabilities: "",
	$lockType: "noLock", // to let unban by timeout works
	$properties: {
		code: {
			$title: "Code",
			$description: "Code",
			$isMandatory: true,
			$isUnique: true
		},
		description: {
			$title: "Description",
			$description: "Friendly name",
			$isMandatory: true,
			$isLocalized: true,
			$linksToDetails: true,
		},
		solutionName: {
			$title: "Solution name",
			$description: "X3 solution alias",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if (val && instance.webHostname(_)) instance.synchronize(_);
			}
		},
		serverHost: {
			$title: "Main server host",
			$description: "Physical main X3 server name or IP address",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if (val && instance.solutionName(_)) instance.synchronize(_);
			}
		},
		serverPort: {
			$title: "Main X3 server port",
			$type: "integer",
			$isMandatory: true
		},
		serverTimeout: {
			$title: "Server timeout (ms)",
			$type: "integer",
			$isHidden: true,
			//$isMandatory: true, // commented because not used anywhere
			$default: 60000
		},
		webServer: {
			$title: "Apache server on application server host",
			$description: "If different from \"Main server host\"",
			$propagate: function(_, instance, val) {
				if (val && instance.solutionName(_)) instance.synchronize(_);
			}
		},
		webServerPort: {
			$title: "Apache server on application server port",
			$type: "integer",
			$default: 80,
			$propagate: function(_, instance, val) {
				if (val && instance.solutionName(_)) instance.synchronize(_);
			}
		},
		proxy: {
			$title: "Use Http proxy configuration",
			$type: "boolean",
			$default: false,
			$propagate: function(_, instance, val) {
				if (val != null && instance.solutionName(_) && instance.webHostname(_)) instance.synchronize(_);
			}
		}
	},
	$relations: {
		boServer: {
			$title: "Bo Server",
			$description: "This is the Business Objects Server associated to X3 Server",
			$type: "boServer"
		},
		application: {
			$title: "Application",
			$type: "application",
			$isMandatory: true,
			$lookupFilter: {
				protocol: "x3"
			},
		},
		endpoints: {
			$title: "Endpoints",
			$description: "Associated endpoints",
			$type: "endPoints",
			$inv: "x3solution",
			$isComputed: true,
			$capabilities: "sort,filter",
			$isReadOnly: true
		},
		certificate: {
			$title: "Certificate",
			$description: "Certificate used for authentication at this server",
			$type: "certificate",
			$inv: "x3solutions"
		},
		runtimes: {
			$title: "Runtimes",
			$description: "X3 runtimes",
			$type: "x3servers",
			$isChild: true,
		}

	},
	$services: {
		checkMainServer: {
			$title: "Check Main X3 Runtime",
			$description: "Attempts to connect to the server",
			$method: "GET",
			$isMethod: true,
			$facets: ["$details"],
			$parameters: {
				folderName: "X3",
				$properties: {
					folderName: {
						$title: "Folder to test",
						$description: "Indicate a X3 folder that can be used to test the connection",
						$type: "application/x-string"
					}
				}
			},
			$execute: function(_, context, instance) {
				instance.checkRuntime(_, context, function(_, s) {
					return s.tag(_) === "MAIN";
				});
			}
		},
		checkAllServer: {
			$title: "Check All X3 Runtime",
			$description: "Attempts to connect to all X3 process servers",
			$method: "GET",
			$isMethod: true,
			$facets: ["$details"],
			$parameters: {
				folderName: "X3",
				$properties: {
					folderName: {
						$title: "Folder to test",
						$description: "Indicate a X3 folder that can be used to test the connection",
						$type: "application/x-string"
					}
				}
			},
			$execute: function(_, context, instance) {
				instance.checkRuntime(_, context, function(_, s) {
					return !s.disabled(_);
				});
			}
		},
		createEndpoints: {
			$method: "POST",
			$isMethod: true,
			$title: "Create endpoints",
			$facets: ["$details"],
			$parameters: {
				$actions: {
					$select: {
						$url: "{$baseUrl}/lookupX3Folders?representation=lookupX3Folder.$select&x3solutionUuid={$uuid}",
					}
				}
			},
			$execute: function(_, context, instance, parameters) {

				var payload = JSON.parse(context.request.readAll(_));


				if (!payload || !payload.$select) {
					return;
				}
				instance.$diagnoses = instance.$diagnoses || [];
				var alreadyDefined = instance.endpoints(_).toArray(_).map_(_, function(_, ep) {
					return ep.x3ServerFolder(_);
				});

				//console.error("alreadyDefined: " + JSON.stringify(alreadyDefined, null, 2));
				var folders = payload.$select.map(function(f) {
					return f.name;
				}).filter(function(name) {
					var toCreate = alreadyDefined.indexOf(name) === -1;
					if (!toCreate) instance.$diagnoses.push({
						severity: "warning",
						message: locale.format(module, "epAlreadySet", name)
					});
					return toCreate;
				});

				if (folders.length > 0) {

					adminDb = adminDb || adminHelper.getCollaborationOrm(_);
					var srvEnt = adminDb.getEntity(_, "endPoint");

					folders.forEach_(_, function(_, f) {
						var ep = srvEnt.createInstance(_, adminDb);
						ep.description(_, instance.solutionName(_) + " / " + f);
						ep.x3ServerFolder(_, f);
						ep.dataset(_, instance.solutionName(_) + "_" + f);
						ep.applicationRef(_, instance.application(_));
						ep.x3solution(_, instance);

						try {
							saveAndCheckErrors(_, ep);
							instance.endpoints(_).set(_, ep);
							instance.$diagnoses.push({
								$severity: "info",
								$message: locale.format(module, "epCreationSuccess", ep.description(_))
							});
						} catch (e) {
							console.error(e.stack);
							instance.$diagnoses.push({
								$severity: "error",
								$message: locale.format(module, "epCreationErr", ep.description(_), e.message)
							});
						}

					});
					instance.save(_);
				}

			},
		},
	},
	$searchIndex: {
		$fields: ["solutionName", "serverHost", "serverPort", "webServer", "endpoints"]
	},
	$functions: {
		webHostname: function(_) {
			return this.webServer(_) || this.serverHost(_);
		},
		baseUrl: function(_) {
			return "http://" + this.webHostname(_) + (this.webServerPort(_) ? ":" + this.webServerPort(_) : "");
		},
		checkRuntime: function(_, context, filterFunc) {
			var self = this;
			this.$diagnoses = this.$diagnoses || [];
			var servers = this.runtimes(_).toArray(_);
			if (filterFunc) servers = servers.filter_(_, filterFunc);
			servers.forEach_(_, function(_, s) {
				try {
					self.$diagnoses.push(require("syracuse-x3/lib/pool").checkServerSettings(_, {
						x3server: s,
						applicationServer: self.serverHost(_),
						folder: context && context.parameters && context.parameters.folderName
					})[0]);
				} catch (e) {
					(self.$diagnoses = self.$diagnoses || []).push({
						severity: "error",
						message: e.message
					});
				}
			});

		},
		isMainRuntime: function(_, serverHost, serverPort) {
			var main = this.runtimes(_).toArray(_).filter_(_, function(_, item) {
				return item.tag(_) === "MAIN";
			});
			if (!main || !main.length) {
				throw new Error(locale.format(module, "noRuntimeMain", this.solutionName(_)));
			}

			return main[0].serverHost(_) === serverHost && main[0].serverPort(_) === serverPort;
		},
		selectX3Server: function(_, options) {
			return selectX3Server(_, this, options);
		},
		synchronize: function(_) {
			var self = this;
			this.$diagnoses = this.$diagnoses || [];

			adminDb = adminDb || adminHelper.getCollaborationOrm(_);
			var srvEnt = adminDb.getEntity(_, "x3server");
			var solName = this.solutionName(_);
			var mainHost = this.serverHost(_);
			var mainPort = this.serverPort(_);
			// get the ip of the main host to compare with runtime in order to determine the main server
			// for unit test
			if (mainHost !== "dummyhost") {
				try {
					var ipMainHosts = dns.lookup(mainHost, 4, ~_);
				} catch (e) {
					this.$addDiagnose("warning", locale.format(module, "cantAccessHost", mainHost));
					return;
				}
				if (!Array.isArray(ipMainHosts))
					ipMainHosts = [ipMainHosts];
			} else {
				ipMainHosts = ["dummyhost"];
			}

			var options = {
				method: "GET",
				url: this.baseUrl(_) + "/Adonix_" + solName + "/solution.json",
				headers: {}
			};
			if (!this.proxy(_)) options.ignoreProxy = true;
			var data;
			try {

				var request = httpClient.httpRequest(_, options);
				request.setTimeout(500);
				var resp = request.end().response(_);
				data = resp.readAll(_);
				if (+resp.statusCode === 404) { // file not found
					this.$addDiagnose("warning", locale.format(module, "cantAccessSol", options.url));
					return;
				}
				if (resp.statusCode !== 200) {
					this.$addDiagnose("warning", locale.format(module, "cantAccessSolutionJson", options.url));
					return;
				}
			} catch (e) {
				this.$addDiagnose("warning", locale.format(module, "cantAccessPort", options.url));
				return;
			}


			if (data) {
				var jsonSolution;
				try {
					jsonSolution = JSON.parse(data);
				} catch (e) {
					this.$addDiagnose("error", locale.format(module, "cantParseSolutionJson", e.message, options.url));
					return;
				}

				var runtimes = jsonSolution && jsonSolution.runtimes || [];
				if (runtimes.length === 0) {
					this.$addDiagnose("error", locale.format(module, "noRuntimes", solName));
					return;
				}

				this.serverPort(_, jsonSolution.solution && jsonSolution.solution.mainPort);

				// register every runtimes (x3servers)
				runtimes.forEach_(_, function(_, r) {

					// check if one ip that are resolv is corresponding to be set as a runtime main server
					if (r.server) {
						if (r.server !== "dummyHost") { // for unit test
							var ipRuntimes = dns.lookup(r.server, 4, ~_);
							if (!Array.isArray(ipRuntimes))
								ipRuntimes = [ipRuntimes];
						} else {
							ipRuntimes = ["dummyHost"];
						}
						// check when one of the ipRuntime correspond to one of the ipMainHost
						var inter = ipRuntimes.filter(function(ip) {
							return ipMainHosts.indexOf(ip);
						});
						if (!inter.length) {
							self.serverHost(_, r.server);
						}
					}

					var _runtimes = self.runtimes(_).filter(_, {
						jsonWhere: {
							serverHost: r.server,
							serverPort: r.mainPort
						}
					});
					var x3srv = _runtimes && _runtimes.length > 0 && _runtimes[0];
					if (!x3srv) {
						x3srv = srvEnt.createInstance(_, adminDb);

						x3srv.serverHost(_, r.server);
						x3srv.serverPort(_, r.mainPort);

					}

					x3srv.autoConfig(_, true);
					self.runtimes(_).set(_, x3srv);
				});
				this.runtimes(_).toArray(_).forEach_(_, function(_, r) {
					if (r.tag(_) === "MAIN" && r.serverHost(_) !== self.serverHost(_)) {
						self.runtimes(_).deleteInstance(_, r.$uuid);
					}
					if (r.serverHost(_) === self.serverHost(_) && r.serverPort(_) === self.serverPort(_)) {
						r.tag(_, "MAIN");
					}

				});
				this.$addDiagnose("success", locale.format(module, "syncDone"));

			} else {
				if (!this.runtimes(_).toArray(_).some_(_, function(_, r) {
					return r.serverPort(_) === mainPort && (r.serverHost(_) === mainHost || r.serverHost(_).indexOf('.') && r.serverHost(_).split('.')[0] === mainHost);
				})) {
					var x3srv = srvEnt.createInstance(_, adminDb);

					x3srv.serverHost(_, mainHost);
					x3srv.serverPort(_, mainPort);
					x3srv.tag(_, "MAIN");
					this.runtimes(_).set(_, x3srv);
				}
			}

		}
	},
	$events: {
		$canSave: [

			function(_, instance) {
				// there must be at least one active connection
				var certificate = instance.certificate(_);
				if (certificate && certificate.server(_)) {
					instance.$addError(locale.format(module, "clientNotServer"));
				}
				if (certificate && certificate.internal(_)) {
					instance.$addError(locale.format(module, "noInternal"));
				}
				return;
			}
		],
	},
};

var tracer = require("syracuse-trace/lib/helper").getTracer("x3Comm.loadBalancer");

var lbList = [];

var selectX3Server = function(_, solution, options) {

	function getServer(uuid) {
		if (!uuid) return;
		return servers.filter(function(s) {
			return s.$uuid === uuid;
		})[0];
	}

	var startTime = new Date().getTime();
	var server;
	try {

		var solName = solution.solutionName(_);
		options = options || {};
		lbList[solName] = lbList[solName] || [];
		var lbSol = lbList[solName];
		tracer.info && tracer.info("Begin server selection for solution [" + solName + "]");
		tracer.debug && tracer.debug("Selection options: " + JSON.stringify(options, null, 2));

		var servers = solution.runtimes(_).toArray(_);
		if (servers.length === 0) throw new Error(locale.format(module, "noX3ServerOnX3Solution", solution.solutionName(_)));

		// remove banned and disabled servers and 
		var bannedList = [],
			disabledList = [];
		var self = this;
		var realList = servers.filter_(_, function(_, s) {
			var isBanned = s.banned(_);
			if (isBanned) {
				bannedList.push(s.$uuid); // this server have to really be bannish
			}
			var isDisabled = s.disabled(_);
			if (isDisabled) disabledList.push(s.$uuid);
			return !isBanned && !isDisabled;
		});
		if (realList.length === 0) throw new Error(locale.format(module, "noUsableServerOnSolution", solution.solutionName(_)));

		// Filter with tags
		var tags = [];
		if (options.tags) {
			if (options.tags.indexOf(',') > 0) {
				tags = options.tags.split(',');
			} else {
				tags = [options.tags];
			}
			var taggedList = realList.filter_(_, function(_, s) {
				//console.error("SERVER: "+s.description(_)+" TAG : "+ s.tag(_) + " index : "+tags.indexOf(s.tag(_)));
				return tags.indexOf(s.tag(_)) >= 0;
			});
			realList = taggedList.length > 0 ? taggedList : realList;
		}

		// do not use servers where tags are exclusive and not matching
		realList = realList.filter_(_, function(_, s) {
			return !s.exclusive(_) || (s.exclusive(_) && tags.indexOf(s.tag(_)) >= 0);
		});

		if (realList.length === 0) throw new Error(locale.format(module, "noTaggedServerOnSolution", solution.solutionName(_)));

		realList = realList.map_(_, function(_, s) {
			return s.stringify(_);
		});
		tracer.debug && tracer.debug("Eligible Servers :" + JSON.stringify(realList, null, 2));

		// ***
		// Synchronize list and real list
		// ***		
		// Remove servers from list if banned or disabled
		tracer.debug && tracer.debug("*** Memory LB List before remove banned and disabled:" + JSON.stringify(lbSol, null, 2));
		lbSol = lbSol.filter(function(item) {
			return bannedList.indexOf(item) === -1 && disabledList.indexOf(item) === -1;
		});

		// Add never balanced servers
		tracer.debug && tracer.debug("*** Memory LB List before add new servers :" + JSON.stringify(lbSol, null, 2));
		lbSol = realList.filter(function(item) {
			return lbSol.indexOf(item.uuid) === -1 && !item.disabled && !item.banned;
		}).map(function(s) {
			return s.uuid;
		}).concat(lbSol);

		// reorder realList
		var orderedList = lbSol.filter(function(item) {
			return realList.some(function(s) {
				return s.uuid === item;
			});
		});

		if (orderedList.length === 0) throw new Error(locale.format(module, "noOrderedServerOnSolution", solution.solutionName(_)));

		tracer.debug && tracer.debug("Real selection list: " + JSON.stringify(orderedList, null, 2));

		// ***
		// Select server to use and Apply round robin algorithm : the first become the last...
		// ***
		var selectedUuid = orderedList[0];
		tracer.debug && tracer.debug("*** Memory LB List before apply round robin :" + JSON.stringify(lbSol, null, 2));

		server = getServer(selectedUuid);
		if (!server) throw new Error(locale.format(module, "noServerAvailable"));
		var lbIdx = lbSol.indexOf(selectedUuid);

		// Apply round robin
		if (lbSol.length > 1) {
			lbSol.splice(lbIdx, 1);
			lbSol.push(selectedUuid);
		}
		tracer.debug && tracer.debug("*** LB List after apply round robin :" + JSON.stringify(lbSol, null, 2));
		tracer.info && tracer.info("Selected server : " + server.$uuid + " : " + server.description(_));
		if (server.$uuid !== selectedUuid) server = getServer(selectedUuid);
		lbList[solName] = lbSol;
	} catch (e) {
		//helpers.log.error(module, e);
		tracer.error && tracer.error("X3 Server load balancer error: " + e.stack);
		throw e;
	}
	var endTime = new Date().getTime();
	tracer.debug && tracer.debug("Selection time: " + (endTime - startTime) + "ms");

	return server;
};