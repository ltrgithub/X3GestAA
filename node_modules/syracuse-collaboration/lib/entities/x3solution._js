"use strict";

var flows = require("streamline/lib/util/flows");
var locale = require("syracuse-core/lib/locale");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var httpClient = require('syracuse-httpclient/lib/httpClient');
var adminDb;

exports.entity = {
	$titleTemplate: "X3 solution",
	$descriptionTemplate: "X3 solution settings",
	$valueTemplate: "{description}",
	$helpPage: "Administration-reference_Sage-ERP-X3-Solutions",
	$capabilities: "",
	$lockType: "noLock", // to let unban by timeout works
	$properties: {
		code: {
			$title: "Code",
			$description: "Code",
			$isMandatory: true,
			$isUnique: true
		},
		description: {
			$title: "Description",
			$description: "Friendly name",
			$isMandatory: true,
			$isLocalized: true,
			$linksToDetails: true,
		},
		solutionName: {
			$title: "Solution name",
			$description: "X3 solution alias",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if (val && instance.webHostname(_)) instance.synchronize(_);
			}
		},
		serverHost: {
			$title: "Main server host",
			$description: "Physical main X3 server name or IP address",
			$isMandatory: true,
			$propagate: function(_, instance, val) {
				if (val && instance.solutionName(_)) instance.synchronize(_);
			}
		},
		serverPort: {
			$title: "Main X3 server port",
			$type: "integer",
			$isMandatory: true
		},
		serverTimeout: {
			$title: "Server timeout (ms)",
			$type: "integer",
			$isMandatory: true,
			$default: 60000
		},
		webServer: {
			$title: "Apache server on application server host",
			$description: "If different from \"Main server host\"",
			$propagate: function(_, instance, val) {
				if (val && instance.solutionName(_)) instance.synchronize(_);
			}
		},
		webServerPort: {
			$title: "Apache server on application server port",
			$type: "integer",
			$default: 80,
			$propagate: function(_, instance, val) {
				if (val && instance.solutionName(_)) instance.synchronize(_);
			}
		},
		proxy: {
			$title: "Use Http proxy configuration",
			$type: "boolean",
			$default: false,
			$propagate: function(_, instance, val) {
				if (val != null && instance.solutionName(_) && instance.webHostname(_)) instance.synchronize(_);
			}
		}
	},
	$relations: {
		boServer: {
			$title: "Bo Server",
			$description: "This is the Business Objects Server associated to X3 Server",
			$type: "boServer"
		},
		application: {
			$title: "Application",
			$type: "application",
			$isMandatory: true,
			$lookupFilter: {
				protocol: "x3"
			},
		},
		endpoints: {
			$title: "Endpoints",
			$description: "Associated endpoints",
			$type: "endPoints",
			$inv: "x3solution",
			$isComputed: true,
			$capabilities: "sort,filter",
			$isReadOnly: true
		},
		certificate: {
			$title: "Certificate",
			$description: "Certificate used for authentication at this server",
			$type: "certificate",
			$inv: "x3solutions"
		},
		runtimes: {
			$title: "Runtimes",
			$description: "X3 runtimes",
			$type: "x3servers",
			$isChild: true,
		}
	},
	$services: {
		checkServer: {
			$title: "Check server settings",
			$description: "Attempts to connect to the server",
			$method: "GET",
			$isMethod: true,
			$facets: ["$details"],
			$parameters: {
				folderName: "X3",
				$properties: {
					folderName: {
						$title: "Folder to test",
						$description: "Indicate a X3 folder that can be used to test the connection",
						$type: "application/x-string"
					}
				}
			},
			$execute: function(_, context, instance) {
				try {
					instance.$diagnoses = require("syracuse-x3/lib/pool").checkServerSettings(_, {
						x3server: instance.runtimes(_).toArray(_).filter_(_, function(_, s) {
							return s.tag(_) === "MAIN";
						})[0],
						applicationServer: instance.serverHost(_),
						folder: context && context.parameters && context.parameters.folderName
					});
				} catch (e) {
					(instance.$diagnoses = instance.$diagnoses || []).push({
						severity: "error",
						message: e.message
					});
				}
			}
		},
		createEndpoints: {
			$method: "POST",
			$isMethod: true,
			$title: "Create endpoints",
			$facets: ["$edit"],
			$parameters: {
				$actions: {
					$select: {
						$url: "{$baseUrl}/lookupX3Folders?representation=lookupX3Folder.$select&x3solutionUuid={$uuid}",
					}
				}
			},
			$execute: function(_, context, instance, parameters) {
				if (!parameters || !parameters.$select) {
					return;
				}
				var alreadyDefined = instance.endpoints(_).toArray(_).map_(_, function(_, ep) {
					return ep.x3ServerFolder(_);
				});

				console.error("alreadyDefined: " + JSON.stringify(alreadyDefined, null, 2));
				var folders = parameters.$select.map(function(f) {
					return f.name;
				}).filter(function(name) {
					var toCreate = alreadyDefined.indexOf(name) === -1;
					if (!toCreate)(instance.$diagnoses = instance.$diagnoses || []).push({
						severity: "warning",
						message: locale.format(module, "epAlreadySet", name)
					});
					return toCreate;
				});

				if (folders.length > 0) {

					adminDb = adminDb || adminHelper.getCollaborationOrm(_);
					var srvEnt = adminDb.getEntity(_, "endPoint");

					folders.forEach_(_, function(_, f) {
						var ep = srvEnt.createInstance(_, adminDb);
						ep.description(_, f + " / " + instance.solutionName(_));
						ep.x3ServerFolder(_, f);
						ep.dataset(_, f);
						ep.applicationRef(_, instance.application(_));
						ep.x3solution(_, instance);
						ep.save(_);
						instance.endpoints(_).set(_, ep);
					});
					instance.save(_);
				}

			},
		},
	},
	$searchIndex: {
		$fields: ["solutionName", "serverHost", "serverPort", "webServer", "endpoints"]
	},
	$functions: {
		webHostname: function(_) {
			return this.webServer(_) || this.serverHost(_);
		},
		baseUrl: function(_) {
			return "http://" + this.webHostname(_) + (this.webServerPort(_) ? ":" + this.webServerPort(_) : "");
		},
		selectX3Server: function(_, options) {
			return selectX3Server(_, this, options);
		},
		synchronize: function(_) {
			console.error("Synchronize");
			var self = this;
			this.$diagnoses = this.$diagnoses || [];

			adminDb = adminDb || adminHelper.getCollaborationOrm(_);
			var srvEnt = adminDb.getEntity(_, "x3server");
			var solName = this.solutionName(_);
			var mainHost = this.serverHost(_);
			var mainPort = this.serverPort(_);




			var options = {
				method: "GET",
				url: this.baseUrl(_) + "/Adonix_" + solName + "/solution.json",
				headers: {}
			};
			if (!this.proxy(_)) options.ignoreProxy = true;
			var data;
			try {

				var request = httpClient.httpRequest(_, options);
				request.setTimeout(500);
				var resp = request.end().response(_);
				if (resp.statusCode !== 200) {
					this.$addDiagnose("warning", locale.format(module, "cantAccessSolutionJson", options.url));
					return;
				}
				data = resp.readAll(_);
			} catch (e) {
				this.$addDiagnose("warning", locale.format(module, "cantAccessSolutionJson", options.url));
				return;
			}


			if (data) {
				var jsonSolution;
				try {
					jsonSolution = JSON.parse(data);
				} catch (e) {
					this.$addDiagnose("error", locale.format(module, "cantParseSolutionJson", e.message, options.url));
					return;
				}

				var runtimes = jsonSolution && jsonSolution.runtimes || [];
				if (runtimes.length === 0) {
					this.$addDiagnose("error", locale.format(module, "noRuntimes", solName));
					return;
				}

				this.serverPort(_, jsonSolution.solution && jsonSolution.solution.mainPort);

				// register every runtimes (x3servers)
				runtimes.forEach_(_, function(_, r) {

					// add maybe domain ?
					if (r.server && r.server.indexOf('.') && r.server.split('.')[0] === mainHost) {
						self.serverHost(_, r.server);
					}

					var _runtimes = self.runtimes(_).filter(_, {
						jsonWhere: {
							serverHost: r.server,
							serverPort: r.mainPort
						}
					});
					var x3srv = _runtimes && _runtimes.length > 0 && _runtimes[0];
					if (!x3srv) {
						x3srv = srvEnt.createInstance(_, adminDb);

						x3srv.serverHost(_, r.server);
						x3srv.serverPort(_, r.mainPort);

					}

					x3srv.autoConfig(_, true);
					self.runtimes(_).set(_, x3srv);
				});
				this.runtimes(_).toArray(_).forEach_(_, function(_, r) {
					if (r.tag(_) === "MAIN" && r.serverHost(_) !== self.serverHost(_)) {
						self.runtimes(_).deleteInstance(_, r.$uuid);
					}
					if (r.serverHost(_) === self.serverHost(_) && r.serverPort(_) === self.serverPort(_)) {
						r.tag(_, "MAIN");
					}

				});
				this.$addDiagnose("success", locale.format(module, "syncDone"));

			} else {
				if (!this.runtimes(_).toArray(_).some_(_, function(_, r) {
					return r.serverPort(_) === mainPort && (r.serverHost(_) === mainHost || r.serverHost(_).indexOf('.') && r.serverHost(_).split('.')[0] === mainHost);
				})) {
					var x3srv = srvEnt.createInstance(_, adminDb);

					x3srv.serverHost(_, mainHost);
					x3srv.serverPort(_, mainPort);
					x3srv.tag(_, "MAIN");
					this.runtimes(_).set(_, x3srv);
				}
			}

		}
	},
	$events: {
		$canSave: [

			function(_, instance) {
				// there must be at least one active connection
				var certificate = instance.certificate(_);
				if (certificate && certificate.server(_)) {
					instance.$addError(locale.format(module, "clientNotServer"));
				}
				if (certificate && certificate.internal(_)) {
					instance.$addError(locale.format(module, "noInternal"));
				}
				return;
			}
		],
	},
};

var tracer = require("syracuse-trace/lib/helper").getTracer("x3Comm.loadBalancer");

var lbList = [];

var lbFunnel = flows.funnel(1);
var selectX3Server = function(_, solution, options) {
	var startTime = new Date().getTime();
	var server;
	try {
		lbFunnel(_, function(_) {

			function getServer(uuid) {
				if (!uuid) return;
				return servers.filter(function(s) {
					return s.$uuid === uuid;
				})[0];
			}

			options = options || {};
			tracer.info && tracer.info("Begin server selection for solution [" + solution.solutionName(_) + "]");
			tracer.debug && tracer.debug("Selection options: " + JSON.stringify(options, null, 2));

			var servers = solution.runtimes(_).toArray(_);
			if (servers.length === 0) throw new Error(locale.format(module, "noX3ServerOnX3Solution", solution.solutionName(_)));

			// remove banned and disabled servers and 
			var bannedList = [],
				disabledList = [];
			var realList = servers.filter_(_, function(_, s) {
				var isBanned = s.banned(_);
				if (isBanned) bannedList.push(s.$uuid);
				var isDisabled = s.disabled(_);
				if (isDisabled) disabledList.push(s.$uuid);
				return !isBanned;
			});

			// Filter with tags
			if (options.tags) {
				var tags;
				if (options.tags.indexOf(',') > 0) {
					tags = options.tags.split(',');
				} else {
					tags = [options.tags];
				}
				var taggedList = realList.filter_(_, function(_, s) {
					//console.error("SERVER: "+s.description(_)+" TAG : "+ s.tag(_) + " index : "+tags.indexOf(s.tag(_)));
					return tags.indexOf(s.tag(_)) >= 0;
				});
				realList = taggedList.length > 0 ? taggedList : realList;
			}
			// create a map of uuids
			realList = realList.map(function(s) {
				return s.$uuid;
			});
			tracer.debug && tracer.debug("Servers linked to solution :" + JSON.stringify(realList, null, 2));
			tracer.debug && tracer.debug("Banned servers :" + JSON.stringify(bannedList, null, 2));
			tracer.debug && tracer.debug("Disabled servers :" + JSON.stringify(disabledList, null, 2));
			// ***
			// Synchronize list and real list
			// ***
			// Remove servers from list if banned or disabled
			tracer.debug && tracer.debug("*** LB List before remove banned and disabled:" + JSON.stringify(lbList, null, 2));
			lbList = lbList.filter(function(item) {
				return bannedList.indexOf(item) === -1 || disabledList.indexOf(item) === -1;
			});

			// Add never balanced servers
			tracer.debug && tracer.debug("*** LB List before add new servers :" + JSON.stringify(lbList, null, 2));
			lbList = realList.filter(function(item) {
				return lbList.indexOf(item) === -1;
			}).concat(lbList);

			// reorder realList
			realList = lbList.filter(function(item) {
				return realList.indexOf(item) !== -1;
			});
			//
			var port;
			var idx = 0;
			// if we want later force selection with host and port
			if (options.host && options.port) {
				var srvUuid;
				for (var j in servers) {
					port = servers[j].serverPort(_);
					if (servers[j].serverHost(_) === options.host && port === options.port) {
						srvUuid = servers[j].$uuid;
						break;
					}
				}
				if (!srvUuid) throw new Error(locale.format(module, "noServerMatchInConf", options.host + ":" + options.port));
				idx = realList.indexOf(srvUuid);
				if (idx === -1) {
					// Check if banned
					if (bannedList.indexOf(srvUuid) !== -1) {
						throw new Error(locale.format(module, "serverBanned", options.host + ":" + options.port));
					}
					throw new Error(locale.format(module, "noServerMatchInLB", options.host + ":" + options.port));
				}
			}
			//

			// ***
			// Select server to use and Apply round robin algorithm : the first become the last...
			// ***
			var selectedUuid = realList[idx];
			tracer.debug && tracer.debug("*** LB List before apply round robin :" + JSON.stringify(lbList, null, 2));

			server = getServer(selectedUuid);
			if (!server) throw new Error(locale.format(module, "noServerAvailable"));

			var lbIdx = lbList.indexOf(selectedUuid);

			// Apply round robin
			if (lbList.length > 1) {
				lbList.splice(lbIdx, 1);
				lbList.push(selectedUuid);
			}
			tracer.debug && tracer.debug("*** LB List after apply round robin :" + JSON.stringify(lbList, null, 2));
			tracer.info && tracer.info("Selected server : " + server.$uuid + " : " + server.description(_));
			if (server.$uuid !== selectedUuid) server = getServer(selectedUuid);
		});
	} catch (e) {
		//helpers.log.error(module, e);
		tracer.error && tracer.error("X3 Server load balancer error: " + e.stack);
		throw e;
	}
	var endTime = new Date().getTime();
	tracer.debug && tracer.debug("Selection time: " + (endTime - startTime) + "ms");

	return server;
};