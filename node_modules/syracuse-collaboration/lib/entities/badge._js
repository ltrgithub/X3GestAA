"use strict";

var util = require("util");
var fs = require('fs');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

// synchronize badge entity contents with data from policy file
exports.updateBadges = function(_) {
	// read badges
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity("badge");
	var dbBadges = {};
	var badges = entity.fetchInstances(_, db, { jsonWhere: { }});
	for (var i = 0; i < badges.length; i++) {
		dbBadges[badges[i].code(_)] = badges[i];		
	}		
	// read policy file
	var fileBadges = [];
	if (fs.existsSync("policy.json"))
		fileBadges = JSON.parse(fs.readFile("policy.json", _)).badges;
	// !!!policy
	var i = fileBadges.length;
	while (--i >= 0) {
		var badge = fileBadges[i];
		// !!!policy		
		var dbBadge = dbBadges[badge.code];
		if (dbBadge) { // update existing badge
			var save = false;
			if (badge.title !== dbBadge.title(_)) {
				dbBadge.title(_, badge.title);
				save = true;
			}
			var functionsj = badge.functions.join(",");
			if (functionsj !== dbBadge.functions(_)) {
				dbBadge.functions(_, functionsj);
				save = true;
			}
			if (save)
				dbBadge.save(_);
		} else if (dbBadge === "")  { // already handled
			console.log("Double badge in policy file "+util.log(badge));
		} else { // not yet available
			var dbBadge = entity.createInstance(_, db, null);
			dbBadge.code(_, badge.code);
			dbBadge.title(_, badge.title);
			dbBadge.functions(_, badge.functions.join(","));
			dbBadge.save(_);
		}
		// mark as used
		dbBadges[badge.code] = "";
	}
	
	// remove/invalidate badges which do not exist any more in license file
	var remaining = Object.keys(dbBadges);
	var i = remaining.length;
	while (--i >= 0) {
		var dbBadge = dbBadges[remaining[i]];
		if (dbBadge) { // not yet handled
			if (dbBadge.roles(_).toArray(_).length > 0) { // there are still roles attached to the badge: deactivate it
				if (dbBadge.functions(_)) {
					dbBadge.functions(_, ""); // do not allow functions from this badge any more
					dbBadge.save(_);
				}
			} else { // no roles attached: delete it
				dbBadge.deleteSelf(_);
			}
		}
	}
	return;
}

exports.entity = {
	$properties: {
		code: {
			$title: "Name",
			$isMandatory: true,
			$isUnique: true
		},
		title: {
			$title: "Description"
		},
		functions: {
			$title: "Functions"
		}
	},
	$titleTemplate: "Badges",
	$descriptionTemplate: "License badges",
	$valueTemplate: "{code}",
	$relations: {
		roles: {
			$title: "Roles",
			$type: "roles",
			$inv: "badges",
			$isComputed: true
		}
	},
	$searchIndex: {
		$fields: ["name"]
	}
};