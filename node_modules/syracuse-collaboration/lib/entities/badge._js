"use strict";

var util = require("util");
var fs = require('fs');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var check = require('syracuse-license/lib/check');

// synchronize badge entity contents with data from policy file
exports.updateBadges = function(_) {
	// read badges
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity("badge");
	var dbBadges = {};
	var badges = entity.fetchInstances(_, db, { jsonWhere: { }});
	for (var i = 0; i < badges.length; i++) {
		dbBadges[badges[i].code(_)] = badges[i];		
	}		
	var data = check.getParsedLicense(_);
	if (data === null || !data.badges) return;
	var keys = Object.keys(data.badges); 
	for (var i = keys.length-1; i>= 0; i--) {
	    var key = keys[i];
		var badge = data.badges[key];
		var functionsj = badge.func.join(",");
		var dbBadge = dbBadges[key];
		if (dbBadge) { // update existing badge
			var save = false;
			if (badge.title !== dbBadge.title(_)) {
				dbBadge.title(_, badge.title);
				save = true;
			}
			if (functionsj !== dbBadge.functions(_)) {
				dbBadge.functions(_, functionsj);
				save = true;
			}
			if (save)
				dbBadge.save(_);
		} else if (dbBadge === "")  { // already handled
			console.log("Double badge in policy file "+util.log(badge));
		} else { // not yet available
			var dbBadge = entity.createInstance(_, db, null);
			dbBadge.code(_, key);
			dbBadge.title(_, badge.title);
			dbBadge.functions(_, functionsj);
			dbBadge.save(_);
		}
		// mark as used
		dbBadges[badge.code] = "";
	}
	
	// remove/invalidate badges which do not exist any more in license file
	var remaining = Object.keys(dbBadges);
	var i = remaining.length;
	while (--i >= 0) {
		var dbBadge = dbBadges[remaining[i]];
		if (dbBadge) { // not yet handled
			if (dbBadge.roles(_).toArray(_).length > 0) { // there are still roles attached to the badge: deactivate it
				if (dbBadge.functions(_)) {
					dbBadge.functions(_, ""); // do not allow functions from this badge any more
					dbBadge.save(_);
				}
			} else { // no roles attached: delete it
				dbBadge.deleteSelf(_);
			}
		}
	}
	return;
}

exports.entity = {
	$properties: {
		code: {
			$title: "Name",
			$isMandatory: true,
			$isUnique: true
		},
		title: {
			$title: "Description"
		},
		functions: {
			$title: "Functions"
		}
	},
	$titleTemplate: "Badges",
	$descriptionTemplate: "License badges",
	$valueTemplate: "{code}",
	$relations: {
		roles: {
			$title: "Roles",
			$type: "roles",
			$inv: "badges",
			$isComputed: true
		}
	},
	$searchIndex: {
		$fields: ["name"]
	}
};