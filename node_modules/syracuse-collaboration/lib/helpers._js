"use strict";

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var helpers = require("syracuse-core/lib/helpers");
var pluralize = helpers.string.pluralize;
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");

var _config = {};

function _hasLock(instance) { return (instance._lock && (instance._lock.status === "success")); }

exports.AdminHelper = {
	lockInstance: function(_, instance) {
		// allways try to lock as the lock might have been deleted by another user
		if((instance._meta.$lockType === "pessimist")/* && !_hasLock(instance)*/) {
			instance._lock = this.getCollaborationOrm(_).lockInstance(_, instance);
			if(!_hasLock(instance)) {
				var ex;
				if(instance._lock && instance._lock.status === "locked") {
					// TODO: provide a comprehensible label for the object
					ex = new Error(locale.format(module, "lockError", instance._meta.name, instance._lock.lock.lockUser, instance._lock.lock.lockDate));
					ex.httpStatus = httpHelpers.HttpStatus.Conflict;
					ex.lockStatus = instance._lock;
				} else {
					ex = new Error(locale.format(module, "lockErrorFatal", instance._meta.name));
					ex.httpStatus = 500;
				}
				throw ex;
			}
		}
	},
	unlockInstance: function(_, instance) {
		if((instance._meta.$lockType === "pessimist")/* && instance._lock*/) {
			this.getCollaborationOrm(_).unlockInstance(_, instance);
		}
	},
	releaseSessionLocks: function(_, ssid) {
//		console.log("release session: "+ssid);
		this.getCollaborationOrm(_).db.collection("dbLocks", _).remove({
			sessionId: ssid
		}, {
			safe: true
		}, _);
	},
	getCollaborationOrm: function(_) {
		var contract = sdataRegistry.getContract(_config.application, _config.contract, true);
		var dataset = _config.dataset;
		//
		return dataModel.getOrm(_, this.getCollaborationModel(), contract.datasets[dataset]);
	},
	getCollaborationModel: function() {
		var contract = sdataRegistry.getContract(_config.application, _config.contract, true);
		var dataset = _config.dataset;
		return dataModel.make(contract, dataset);
	},
	getCollaborationApplication: function(_) {
		return this.getApplication(_, _config.application, _config.contract);
	},
	getCollaborationEndpoint: function(_) {
		return this.getEndpoint(_, {
			application: _config.application, 
			contract: _config.contract, 
			dataset: _config.dataset
		});
	},
	getApplication: function(_, applicationName, contractName) {
		var opt = {};
		// case insensitive search
		opt.jsonWhere = {
			application: {$regex: "^"+applicationName+"$", $options: "i"},
			contract: {$regex: "^"+contractName+"$", $options: "i"}
		}
		var db = this.getCollaborationOrm(_);
		return db.fetchInstance(_, db.model.getEntity("application"), opt);
	},
	getEndpoints: function(_, options) {
		var opt = {jsonWhere:{}};
		if(options.jsonWhere) opt.jsonWhere = options.jsonWhere;
		else {
			var app = this.getApplication(_, options.application, options.contract);
			if(!app) return null;
			// case insensitive search
			opt.jsonWhere.applicationRef = app.$uuid;
			if(options.dataset) opt.jsonWhere.dataset = {$regex: "^"+options.dataset+"$", $options: "i"};
		}
		var db = this.getCollaborationOrm(_);
		return db.fetchInstances(_, db.model.getEntity("endPoint"), opt);
	},
	getEndpoint: function(_, options) {
		var eps = this.getEndpoints(_, options);
		return eps && eps[0];
	},
	// This function computes $lookup for Syracuse and X3 representations
	// parameters: 
	// options = {
	// 		application: "applicationName",
	// 		contract: "contractName",
	// 		dataset: "endpointName",
	// 		representationField: "representationfieldName",  -> necessary to handle fieldMap correctly
	// 		entityField: "entityFieldName"-> necessary to handle fieldMap correctly
	// }
	getLookupRepresentations: function(_, options){
		var app = this.getApplication(_, options.application, options.contract);
		if (app){
			var baseUrl, lookup = {};
			var ep = this.getEndpoint(_, {
				application: options.application, 
				contract: options.contract, 
				dataset: options.dataset
			});
			if (!ep){
				lookup.$parameters = {
					$url: "{$baseUrl}/selectEndpoints/$template/$workingCopies?representation=selectEndpoint.$edit",
					$method: "POST",
					$properties: {}	
				};
				baseUrl = "/sdata/{application}/{contract}/{dataset}";
			}else{
				baseUrl = ep.getBaseUrl(_);
			}
			if (app.protocol(_) === "x3"){
				lookup.$type = "application/json;vnd.sage=syracuse";
				lookup.$url = baseUrl+"/AREPIDX?representation=AREPIDX.$lookup";
				lookup.$fieldMap = {}
				if (options.representationField)
					lookup.$fieldMap[options.representationField] = "NAME";
				if (options.entityField)
					lookup.$fieldMap[options.entityField] = "CLASSE";
				
			}else if (app.protocol(_) === "syracuse"){
				lookup.$type = "application/json;vnd.sage=syracuse";
				lookup.$url = baseUrl+"/lookupRepresentations?application={applicationName}&contract={contractName}&dataset={endpointName}&representation=lookupRepresentation.$lookup";
				lookup.$fieldMap = {}
				if (options.representationField)
					lookup.$fieldMap[options.representationField] = "name";
				if (options.entityField)
					lookup.$fieldMap[options.entityField] = "entityName";
			}
			return lookup;
		}else{
			return;
		}
	},
	// standard setting computed from configuration file and instance of settings singleton.
	// result has elements: 
	//   - method ("basic" or "oauth2-" followed by logical OAuth2 server name from oauth2 instance or just "oauth2-" when taken from configuration file
	//   - source: "db" for database authentication, "ldap" for LDAP authentication, empty for OAuth2 authentication
    //   - ldap:   data for standard LDAP server (only if source is "ldap")
    //   - oauth2: data for standard OAuth2 server (only if method starts with "oauth2-")	
	// !!! caching possible, because function will be invoked many times?
	getStandardSetting: function(_) {
		var db = this.getCollaborationOrm(_);
		var setting = db.fetchInstance(_, db.model.getEntity("setting"), {
			sdataWhere: ""
		});
		var result = {};
		var format = require('util').format;
		var authent = setting ? setting.authentication(_) : _config.session.auth;
		if (authent === "basic") {
			result.method = "basic";
			var ldap = setting? setting.ldap(_) : _config.session.ldap;
			if (ldap) {
				result.source = "ldap";
				// !!! not OK. How do I get a read-only copy of the contents?
				result.ldap = setting ? ldap._data : ldap
			} else {
				result.source = "db";
			}
		} else { // OAuth2 authentication
			if (setting) {				
				var oauth2 = setting.oauth2(_);				
				result.method = "oauth2-"+oauth2.name(_);
				// !!! not OK. How do I get a read-only copy of the contents?
				result.oauth2 = oauth2._data;
			} else {
				result.method = "oauth2-";
				result.oauth2 = _config.session.oauth2;
				if (!_config.session.oauth2) 
				  throw new Error("No oauth2 data in configuration file");
			}
		}
		return result;
	},
	startTimers: function(_) {
		var db = this.getCollaborationOrm(_);
		var auts = db.fetchInstances(_, db.getEntity(_, "automate"));
		auts.forEach_(_, function(_, a) {
			a.scheduleNextRun(_);
		});
	},
	logServerMessage: function(_, description, diagnoses, logDate) {
		//
		var db = this.getCollaborationOrm(_);
		var log = db.getEntity(_, "serverLog").createInstance(_, db);
		log.description(_, description);
		log.logDate(_, logDate || datetime.now());
		var diags = {
			error: [], 
			warning: [], 
			info: []
		}
		diagnoses && diagnoses.forEach(function(d) {
			diags[d.severity] && diags[d.severity].push(d.message);
		});
		log.errorDiags(_, diags.error);
		log.warnDiags(_, diags.warning);
		log.infoDiags(_, diags.info);
		//
		log.save(_);
	}
}

exports.setup = function(config, sessionConfig) {
	var collConf = config || {};
	_config.application = collConf.application || "syracuse";
	_config.contract = collConf.contract || "collaboration";
	_config.dataset = collConf.dataset || "syracuse";
	_config.session = sessionConfig || {};
}
