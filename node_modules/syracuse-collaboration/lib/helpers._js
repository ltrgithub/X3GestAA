"use strict";

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var helpers = require("syracuse-core/lib/helpers");
var pluralize = helpers.string.pluralize;
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var globals = require('streamline/lib/globals');
var _orm; // cache for collaboration ORM: either object (in multitenant mode) or just ORM
var _config = {};
var multiTenant;
var _productNameByEndpoint = {}; // map of product Name by endpoint. each connection will add the product if it's not the case;

var menuItemMap = {
	menu: {},
	lastModified: null // will be set during getBreadCrumb
};

exports.menuItemMapUnitTest = menuItemMap;


function _buildMenuItemMap(_) {

	var _targetNameMap = {
		$representation: function(_, instance) {
			//return instance.representation(_) + "." + instance.facet(_);
			return instance.representationRef(_) && instance.representationRef(_).representation(_);
		},
		$function: function(_, instance) {
			return instance.fusionFunction(_);
		},
		$dashboard: function(_, instance) {
			return instance.dashboard(_);
		},
		$external: function(_, instance) {
			return instance.externalUrl(_);
		},
		$calendar: function(_, instance) {
			return "QUERY~" + instance.requestName(_) + "~" + instance.requestLevel(_);
		},
		$request: function(_, instance) {
			return "QUERY~" + instance.requestName(_) + "~" + instance.requestLevel(_);
		},
		$stats: function(_, instance) {
			return "STATS~" + instance.statName(_);
		},
		$process: function(_, instance) {
			var leg = instance.processLeg(_);
			var nam = instance.processName(_);
			var men = instance.processMenu(_);
			// do not set last tild if no menu
			return "PROCESS~" + (leg || "") + "~" + (nam || "") + (men ? "~" + men : "");
		}
	};

	var model = exports.AdminHelper.getCollaborationModel();

	var db = exports.AdminHelper.getCollaborationOrm(_);
	// get menuModule first
	var entity = model.getEntity(_, "menuModule");
	db.fetchInstances(_, entity).forEach_(_, function(_, instance) {
		// menu
		if (!menuItemMap) {
			menuItemMap = {
				menu: {},
				lastModified: null // will be set during getReverseMenuMap
			};
		}
		menuItemMap.menu[instance.$uuid] = menuItemMap.menu[instance.$uuid] ||  {
			$type: instance.getEntity(_).name,
			sons: [],
			title: instance._data.title,
		};
		instance.submodules(_).toArray(_).forEach_(_, function(_, subModule) {

			function addSubModule(_, subModule, father) {
				menuItemMap.menu[subModule.$uuid] = menuItemMap.menu[subModule.$uuid] ||  {
					$type: subModule.getEntity(_).name,
					sons: [],
					title: subModule._data.title,
					navigFather: father.$uuid
				};
				// push sons in array of menuModule
				menuItemMap.menu[father.$uuid].sons.push(subModule.$uuid);

				subModule.items(_).toArray(_).forEach_(_, function(_, item) {
					if (item.$type === "menuSubblock" ||  item.$type === "menuBlock") {
						addSubModule(_, item, subModule);
					} else {
						if (item.linkType(_) && item.applicationName(_) && item.contractName(_)) {
							var key = item.applicationName(_) + "." + item.contractName(_) + "." + _targetNameMap[item.linkType(_)](_, item);

							menuItemMap.menu[key] = menuItemMap.menu[key] ||  {
								$type: item.getEntity(_).name,
								title: item._data.title,
								navigFather: subModule.$uuid,
								linkType: item.linkType(_),
								factoryOwner: item.$factoryOwner
							};
							menuItemMap.menu[subModule.$uuid].sons.push(key);
						}
					}
				});
			}
			// set submodule with father id
			addSubModule(_, subModule, instance);

		});
	});

	// Add all menu items used by landing pages for statistics
	var lpEntity = model.getEntity(_, "landingPage");
	db.fetchInstances(_, lpEntity).forEach_(_, function(_, instance) {
		menuItemMap.menu[instance.$uuid] = menuItemMap.menu[instance.$uuid] ||  {
			$type: instance.getEntity(_).name,
			sons: [],
			title: instance._data.title,
		};
		instance.vignettes(_).toArray(_).forEach_(_, function(_, vignette) {
			var item = vignette.vignette(_);
			if (item.linkType(_) && item.applicationName(_) && item.contractName(_)) {
				var key = item.applicationName(_) + "." + item.contractName(_) + "." + _targetNameMap[item.linkType(_)](_, item);
				if (!menuItemMap.menu[key]) {
					menuItemMap.menu[key] = {
						$type: item.getEntity(_).name,
						title: item._data.title,
						linkType: item.linkType(_),
						factoryOwner: item.$factoryOwner
					};
				}
				menuItemMap.menu[key].landingFather = instance.$uuid;
				menuItemMap.menu[instance.$uuid].sons.push(key);
			}
		});
	});

	// Add all portlets used by mobile application for statistics
	var ddEntity = model.getEntity(_, "dashboardDef");
	db.fetchInstances(_, ddEntity).forEach_(_, function(_, instance) {
		menuItemMap.menu[instance.$uuid] = menuItemMap.menu[instance.$uuid] ||  {
			$type: instance.getEntity(_).name,
			sons: [],
			title: instance._data.title,
		};
		instance.variants(_).toArray(_).forEach_(_, function(_, variant) {

			if (!menuItemMap.menu[variant.$uuid]) {
				menuItemMap.menu[variant.$uuid] = {

					$type: variant.getEntity(_).name,
					sons: [],
					title: variant._data.title
				};
			}
			menuItemMap.menu[variant.$uuid].dashboardFather = instance.$uuid;
			// push sons in array of dashboardDef
			menuItemMap.menu[instance.$uuid].sons.push(variant.$uuid);

			variant.vignettes(_).toArray(_).forEach_(_, function(_, vignette) {


				var portlet = vignette.portlet(_);
				if (!menuItemMap.menu[portlet.$uuid]) {
					menuItemMap.menu[portlet.$uuid] = {

						$type: portlet.getEntity(_).name,
						sons: [],
						title: portlet._data.title
					};
				}
				menuItemMap.menu[portlet.$uuid].dashboardFather = variant.$uuid;
				// push sons in array of variant
				menuItemMap.menu[variant.$uuid].sons.push(portlet.$uuid);

				function addItem(_, _item) {
					if (_item.linkType(_) && _item.applicationName(_) && _item.contractName(_)) {
						var key = _item.applicationName(_) + "." + _item.contractName(_) + "." + _targetNameMap[_item.linkType(_)](_, _item);
						if (!menuItemMap.menu[key]) {
							menuItemMap.menu[key] = {
								$type: _item.getEntity(_).name,
								title: _item._data.title,
								linkType: _item.linkType(_),
								factoryOwner: _item.$factoryOwner
							};
						}
						menuItemMap.menu[key].dashboardFather = portlet.$uuid;
						menuItemMap.menu[portlet.$uuid].sons.push(key);
					}
				}
				portlet.items(_).toArray(_).forEach_(_, function(_, item) {
					addItem(_, item);
				});
				var pi = portlet.pageItem(_);
				if (pi) {
					addItem(_, pi);
				}

			});

		});
	});
}

function _hasLock(instance) {
	return (instance._lock && (instance._lock.status === "success"));
}

function _normalizeDiag(diag) {
	return {
		$severity: diag.$severity || diag.severity,
		$message: diag.$message || diag.message,
		$stackTrace: diag.$stackTrace || diag.stackTrace
	};
}


exports.AdminHelper = {
	getProductNameByEndpoint: function(dataset) {
		return _productNameByEndpoint ? _productNameByEndpoint[dataset] : '';
	},
	setProductnameByEndpoint: function(productName, dataset) { // call after connection
		_productNameByEndpoint[dataset] = productName;
	},
	getMenuItemMap: function() {
		return menuItemMap;
	},
	getReverseMenuMap: function(_, lastModified, id, facet, origin) {
		// check if we need to generate the map of item because something change in syracuse menuItem, module etc...
		if (!menuItemMap.lastModified || menuItemMap.lastModified.getTime() !== lastModified.getTime()) {
			_buildMenuItemMap(_);
			menuItemMap.lastModified = lastModified;
			//console.error("menuItemMap: " + JSON.stringify(menuItemMap, null, 2));
			//console.error("menuItemMap: " + require('util').inspect(menuItemMap, null, 1));
		}

		//		console.error("ID: "+id);
		//		console.error("origin: "+origin);

		var current = menuItemMap.menu[id];
		var breadcrumb = [];
		if (current) {
			do {
				// compute url of the menu
				if (current.title && Object.keys(current.title).length > 0) {
					var title = current.title;
					/* we'll see if we needed editing or details informations
                     if (current.instance.$type === "menuItem" && ["$fusion", "$details", "$edit"].indexOf(facet) !== -1) {
                     title += " ( " + locale.format(module, facet) + " )";
                     }*/
					var elem = {
						//$url: current.instance.getItemUrl && current.instance.getItemUrl(_, endpoint, "{$baseUrl}"),
						title: title,
						linkType: current.linkType,
						factoryOwner: current.factoryOwner,
						$stacked: current.$stacked
					};
					// check if we can add the facet
					breadcrumb.push(elem);
				}

				var fatherLib;
				if (origin === "$landing") {
					fatherLib = "landingFather";
				} else if (origin === "$dashboard") {
					fatherLib = "dashboardFather";
				} else { // $navigation
					fatherLib = "navigFather";
				}
				current = current[fatherLib] ? menuItemMap.menu[current[fatherLib]] : null;

			} while (current);
		}
		breadcrumb.length > 0 && breadcrumb.push({
			title: locale.formatAllIso(module, '$all')
		});
		return breadcrumb.reverse();

	},
	menuMapToBreadCrumb: function(menuMap) {
		var bcClient = menuMap.map(function(cur) {
			return {
				title: cur.title[locale.current.toLowerCase()] || cur.title["en-us"]
			};
		}).slice(0, menuMap.length - 1); // don't send the last level
		return bcClient;
	},
	lockInstance: function(_, instance) {
		// allways try to lock as the lock might have been deleted by another user
		if ((instance._meta.$lockType === "pessimist") /* && !_hasLock(instance)*/ ) {
			instance._lock = this.getCollaborationOrm(_).lockInstance(_, instance);
			if (!_hasLock(instance)) {
				var ex;
				if (instance._lock && instance._lock.status === "locked") {
					// TODO: provide a comprehensible label for the object
					ex = new Error(locale.format(module, "lockError", instance._meta.name, instance._lock.lock.lockUser, instance._lock.lock.lockDate));
					ex.$httpStatus = httpHelpers.HttpStatus.Conflict;
					ex.lockStatus = instance._lock;
				} else {
					ex = new Error(locale.format(module, "lockErrorFatal", instance._meta.name));
					ex.$httpStatus = 500;
				}
				throw ex;
			}
		}
	},
	lockInstanceRetry: function(_, instance) {
		// allways try to lock as the lock might have been deleted by another user
		if ((instance._meta.$lockType === "pessimist") /* && !_hasLock(instance)*/ ) {
			instance._lock = this.getCollaborationOrm(_).lockInstanceRetry(_, instance);
			if (!_hasLock(instance)) {
				var ex;
				if (instance._lock && instance._lock.status === "locked") {
					// TODO: provide a comprehensible label for the object
					ex = new Error(locale.format(module, "lockError", instance._meta.name, instance._lock.lock.lockUser, instance._lock.lock.lockDate));
					ex.$httpStatus = httpHelpers.HttpStatus.Conflict;
					ex.lockStatus = instance._lock;
				} else {
					ex = new Error(locale.format(module, "lockErrorFatal", instance._meta.name));
					ex.$httpStatus = 500;
				}
				throw ex;
			}
		}
	},
	unlockInstance: function(_, instance) {
		if ((instance._meta.$lockType === "pessimist") /* && instance._lock*/ ) {
			this.getCollaborationOrm(_).unlockInstance(_, instance);
		}
	},
	releaseSessionLocks: function(_, ssid) {
		//		console.log("release session: "+ssid);
		this.getCollaborationOrm(_).db.collection("dbLocks", _).remove({
			sessionId: ssid
		}, {
			safe: true
		}, _);
	},

	getCollaborationOrm: function(_) {
		var tenantId;
		if (multiTenant) {
			tenantId = globals.context.tenantId;
			if (_orm[tenantId]) return _orm[tenantId];
		} else {
			if (_orm) return _orm;
		}
		var contract = sdataRegistry.getContract(_config.application, _config.contract, true);
		var dataset = _config.dataset;
		// require dynamically to avoid problem with circular require
		var result = require("syracuse-orm/lib/dataModel").getOrm(_, this.getCollaborationModel(), contract.datasets[dataset]);
		if (multiTenant) _orm[tenantId] = result;
		else _orm = result;
		return result;
	},
	getCollaborationModel: function() {
		var contract = sdataRegistry.getContract(_config.application, _config.contract, true);
		var dataset = _config.dataset;
		// require dynamically to avoid problem with circular require
		return require("syracuse-orm/lib/dataModel").make(contract, dataset);
	},
	getCollaborationApplication: function(_) {
		return this.getApplication(_, _config.application, _config.contract);
	},
	getCollaborationEndpoint: function(_) {
		return this.getEndpoint(_, {
			application: _config.application,
			contract: _config.contract,
			dataset: _config.dataset
		});
	},
	getApplication: function(_, applicationName, contractName) {
		var opt = {};
		// case insensitive search
		opt.jsonWhere = {
			application: {
				$regex: "^" + applicationName + "$",
				$options: "i"
			},
			contract: {
				$regex: "^" + contractName + "$",
				$options: "i"
			}
		};
		var db = this.getCollaborationOrm(_);
		return db.fetchInstance(_, db.model.getEntity(_, "application"), opt);
	},
	getEndpoints: function(_, options) {
		var opt = {
			jsonWhere: {}
		};
		if (options && options.jsonWhere) opt.jsonWhere = options.jsonWhere;
		else {
			// no need of application, dataset name is unique
			/*			var app = this.getApplication(_, options.application, options.contract);
			if(!app) return null;
			// case insensitive search
			opt.jsonWhere.applicationRef = app.$uuid;*/
			if (options && options.dataset) opt.jsonWhere.dataset = {
				$regex: "^" + options.dataset + "$",
				$options: "i"
			};
		}
		var db = this.getCollaborationOrm(_);
		return db.fetchInstances(_, db.model.getEntity(_, "endPoint"), opt);
	},
	getEndpoint: function(_, options) {
		var eps = this.getEndpoints(_, options);
		return eps && eps[0];
	},
	// This function computes $lookup for Syracuse and X3 representations
	// parameters: 
	// options = {
	// 		application: "applicationName",
	// 		contract: "contractName",
	// 		dataset: "endpointName",
	// 		representationField: "representationfieldName",  -> necessary to handle fieldMap correctly
	// 		entityField: "entityFieldName"-> necessary to handle fieldMap correctly
	// }
	getLookupRepresentations: function(_, options) {
		var app = options.application;
		if (!app) return;
		var ep = options.endpoint || app.defaultEndpoint(_);
		if (!ep) return;
		var lookup = {
			$type: "application/json;vnd.sage=syracuse"
		};
		var baseUrl = ep.getBaseUrl(_);
		if (app.protocol(_) === "x3") {
			lookup.$url = baseUrl + "/AREPIDX?representation=AREPIDX.$lookup";
			lookup.$fieldMap = {};
			if (options.representationField) lookup.$fieldMap[options.representationField] = "NAME";
			if (options.entityField) lookup.$fieldMap[options.entityField] = "CLASSE";

		} else if (app.protocol(_) === "syracuse") {
			lookup.$url = baseUrl + "/lookupRepresentations?application={applicationName}&contract={contractName}&dataset={endpointName}&representation=lookupRepresentation.$lookup";
			lookup.$fieldMap = {};
			if (options.representationField) lookup.$fieldMap[options.representationField] = "name";
			if (options.entityField) lookup.$fieldMap[options.entityField] = "entityName";
		}
		return lookup;
	},
	getSelectRepresentations: function(_, options) {
		var app = options.application;
		if (!app) return;
		var ep = options.endpoint || app.defaultEndpoint(_);
		if (!ep) return;
		var lookup = {
			$type: "application/json;vnd.sage=syracuse"
		};
		var baseUrl = ep.getBaseUrl(_);
		if (app.protocol(_) === "x3") {
			lookup.$url = baseUrl + "/AREPIDX?representation=AREPIDX.$select";
			lookup.$fieldMap = {};
			if (options.representationField) lookup.$fieldMap[options.representationField] = "NAME";
			if (options.entityField) lookup.$fieldMap[options.entityField] = "CLASSE";

		} else if (app.protocol(_) === "syracuse") {
			lookup.$url = baseUrl + "/lookupRepresentations?application={applicationName}&contract={contractName}&dataset={endpointName}&representation=lookupRepresentation.$select";
			lookup.$fieldMap = {};
			if (options.representationField) lookup.$fieldMap[options.representationField] = "name";
			if (options.entityField) lookup.$fieldMap[options.entityField] = "entityName";
		}
		return lookup;
	},
	startTimers: function(_) {
		try {
			var db = this.getCollaborationOrm(_);
			var auts = db.fetchInstances(_, db.getEntity(_, "automate"));
			auts.forEach_(_, function(_, a) {
				a.scheduleNextRun(_);
			});
			// start notification scheduler
			require('syracuse-event/lib/scheduler').scheduleAll(_);
		} catch (e) {
			console.error("Error during event scheduling " + e.stack);
		}
	},
	logServerMessage: function(_, description, diagnoses, logDate) {
		//
		var db = this.getCollaborationOrm(_);
		var log = db.getEntity(_, "serverLog").createInstance(_, db);
		log.description(_, description);
		log.logDate(_, logDate || datetime.now());
		var diags = {
			error: [],
			warning: [],
			info: []
		};
		diagnoses && diagnoses.forEach(function(d) {
			d = _normalizeDiag(d);
			diags[d.$severity] && diags[d.$severity].push(d.$message);
		});
		log.errorDiags(_, diags.error);
		log.warnDiags(_, diags.warning);
		log.infoDiags(_, diags.info);
		//
		log.save(_);
	},
	getFactoryOwner: function(_, sp) {
		sp = sp || globals.context.session && globals.context.session.getSecurityProfile(_);
		if (sp && sp.factoryOwner(_) === "SAGE") return exports.sageFactoryName;
		if (sp && sp.factoryOwner(_) && sp.factoryOwner(_) !== "") {
			return sp.factoryOwner(_);
		}
	}
};

exports.sageFactoryName = "SAGE";

exports.setup = function(config, sessionConfig, hosting) {
	var collConf = config || {};
	_config.application = collConf.application || "syracuse";
	_config.contract = collConf.contract || "collaboration";
	_config.dataset = collConf.dataset || "syracuse";
	_config.session = sessionConfig || {};
	multiTenant = (hosting && hosting.multiTenant);
	if (multiTenant) _orm = {};
};