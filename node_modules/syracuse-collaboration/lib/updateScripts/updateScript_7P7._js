"use strict";

exports.tracer = null;
var debug = true;

var _scripts = [];

_scripts[1] = function(_, db) {
	var hrmMenuPrefix = "STD_X3_HRM_";
	var hrmMenuRegex = /^STD_X3_HRM_/;

	function findHRMApplications(_, db) {
		return db.db.collection("Application", _).find({
			application: 'x3',
			contract: 'hrm'
		}, {
			_id: 1
		}, _).toArray(_);
	}

	// Find all rows in the collection that have an HRM application that do
	// not already start with the STD_X3_HRM_ prefix
	function findRowsToUpdate(_, coll, hrmAppid) {
		return coll.find({
			application: {
				_uuid: hrmAppid
			},
			code: {
				$not: hrmMenuRegex
			}
		}).toArray();
	}

	// Check if the code exists in the collection and if it does then add an incremental suffix
	// to guarantee uniqueness
	function findSuffixRequired(_, coll, menuCode) {
		var suffix = null,
			suffCode;

		// Use collection.count as we don't need to return a cursor
		if (coll.count({
			code: menuCode
		}) > 0) {
			suffix = 0;
			do {
				suffix = suffix + 1;
				suffCode = menuCode + "_" + suffix;
			} while (coll.count({
				code: suffCode
			}) > 0);
		}

		return suffix;
	}

	// Generic function to update the collection (MenuItem, MenuModule, MenuSubmodule)
	// with the new code, adding a suffix if required
	function updateCollection(_, coll, id, menuCode) {
		var newCode = hrmMenuPrefix + menuCode;
		var suffix = findSuffixRequired(_, coll, newCode);

		if (suffix !== null) newCode = newCode + "_" + suffix;

		coll.update({
			_id: id
		}, {
			$set: {
				code: newCode,
				_updDate: new Date()
			}
		}, {
			safe: true,
			multi: true
		}, _);
	}

	// Updates to menu item require the following rules to be applied
	// function - STD_X3_HRM_ + fusionFunction
	// representation - STD_X3_HRM_ + representation
	// All other linkType are ignored
	function updateMenuItem(_, coll, hrmAppid) {
		findRowsToUpdate(_, coll, hrmAppid).forEach_(_, function(_, item) {
			if (item.linkType === '$function') {
				updateCollection(_, coll, item._id, item.fusionFunction);
			} else if (item.linkType === '$representation') {
				updateCollection(_, coll, item._id, item.representation);
			}
		});
	}

	// Updates to MenuModule and MenuBlock require that any menu code linked
	// to an HRM application must start with STD_X3_HRM_
	function updateMenuOther(_, coll, hrmAppid) {
		findRowsToUpdate(_, coll, hrmAppid).forEach_(_, function(_, mod) {
			updateCollection(_, coll, mod._id, mod.code);
		});
	}

	exports.tracer && exports.tracer("Executing update script to version: 1; rename HRM menu entries");

	// We only want to update menu items, modules and submodules that are
	// attached to HRM applications
	findHRMApplications(_, db).forEach_(_, function(_, hrmAp) {
		updateMenuItem(_, db.db.collection("MenuItem", _), hrmAp._id);
		updateMenuOther(_, db.db.collection("MenuModule", _), hrmAp._id);
		updateMenuOther(_, db.db.collection("MenuBlock", _), hrmAp._id);
	});

	exports.tracer && exports.tracer("Update script to version: 1 executed");
};

// Boilerplate function/metadata below

exports.dataUpdate = function(_, db, actualVersion, targetVersion) {
	// force log: always
	exports.tracer = console.log;
	_scripts.slice(actualVersion + 1, targetVersion + 1).forEach_(_, function(_, sequence) {
		sequence && sequence(_, db);
	});
};

exports.metadata = {
	fileId: "a9ba458957fe", // this id MUST never change and MUST be unique over all update scripts
	description: "7 patch 7 branch update script" // !important, some description, optional and can change
};