"use strict";
var helpers = require('syracuse-core/lib/helpers');
var SadFsqFile = require('syracuse-adxadmin/lib/sadfsq/sadfsqFile').SadFsqFile;
var SadFsqComm = require('syracuse-adxadmin/lib/sadfsq/sadfsqComm').SadFsqComm;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;

function generateDiag(e) {
	return {
		$diagnoses: [{
			$severity: "error",
			$message: e.message,
			$stackTrace: e.stack
		}]
	};
};

exports.SadFsqClient = helpers.defineClass(function(_, hostname, port, user, password, secured) {
	this.hostname = hostname;
	this.port = port;
	this.user = user;
	this.password = password;
	this.secured = secured;
	this._connect(_);
}, null, {

	/// 
	/// -------------
	/// ## fileOptions :  
	/// Some following functions take in parameters `fileOptions`.  
	/// This chapter describes how these options can be used.  
	/// 

	/// 
	/// -------------
	/// ## open :
	/// ``` javascript
	/// var fd = sadFsqClient.open(_, fileOptions, attributes);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.   

	/// 
	/// Returns the file descriptor.  
	/// 
	/// or a diagnoses :  
	/// ``` javascript
	/// 	{
	///        "$diagnoses": [{
	///           $severity: "error",
	///           $message: "A message",
	///           $stackTrace: "A stack"
	///        }]
	///     }
	/// ```
	/// 
	open: function(_, options, flags) {
		try {
			var sadFile = new SadFsqFile(options);
			this.communicator.processTOUF(_, sadFile, "r");

		} catch (e) {
			return generateDiag(e);
		}
	},
	/// 
	/// -------------
	/// ## getFileInfo :
	/// ``` javascript
	/// var info = sadFsqClient.getFileInfo(_, fileOptions, attributes);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options.  
	///    eg:  
	/// ``` javascript
	///    var fileOptions = {
	///       folder: "SUPERV",
	///       path: "tmp",
	///       name: "test",
	///       extension: "txt"
	///    };
	/// ```
	///
	/// * Array of Integer : The `info` parameter is array that contains the attributes wanted.  
	///	   Option can have the following values :  
	///	   * 1  ->	file mode  
	///	   * 2  ->	inode number  
	///	   * 3  ->	id of device containing a directory entry  
	///	   * 4  ->	if of device if special char/block  
	///	   * 5  ->	number of links  
	///	   * 6  ->	uid  
	///	   * 7  ->	gid  
	///	   * 8  ->	file size in bytes  
	///	   * 9  ->	last time of access  
	///	   * 10 ->	last time of modification  
	///	   * 11 ->	last time of file status change  
	///    
	/// Returns the value of the wanted attribute.  
	/// 
	/// or a diagnoses :  
	/// ``` javascript
	/// 	{
	///        "$diagnoses": [{
	///           $severity: "error",
	///           $message: "A message",
	///           $stackTrace: "A stack"
	///        }]
	///     }
	/// ```
	/// 
	getFileInfo: function(_, options, info) {
		try {
			this._connect(_);
			var sadFile = new SadFsqFile(options);
			this.communicator.processTOUF(_, sadFile, "r");
			// read content 
			this.communicator.processTPRM(_, sadFile, info);
			// close remote file 
			this.communicator.processSFER(_, sadFile);
			var res = {};
			res[info] = sadFile.fileInfo[info];
			return res;
		} catch (e) {
			return generateDiag(e);
		}
	},
	readFile: function(_, options) {
		try {
			this._connect(_);
			var sadFile = new SadFsqFile(options);
			this.communicator.processTOUF(_, sadFile);
			// read content 
			this.communicator.processSLFB(_, sadFile);
			// close remote file 
			this.communicator.processSFER(_, sadFile);
			return {
				status: ok ? ok : true,
				sadFsqFile: sadFile
			};
		} catch (e) {
			return generateDiag(e);
		}

	},
	writeFile: function(_, file, buffer) {
		this._connect(_);
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		sadFile.binary = buffer;
		this.communicator.processTOUF(_, sadFile);
		// read content 
		this.communicator.processSEFB(_, sadFile);
		// close remote file 
		this.communicator.processSFER(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};


	},
	createProcessus: function(_) {
		this._connect(_);
	},
	deleteFile: function(_, file) {
		this._connect(_);
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		this.communicator.processTEFF(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};
	},
	killProcessus: function(_) { //TODO
		this._connect(_);
	},
	getFilePath: function(_) {
		this._connect(_);
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		this.communicator.processTPAT(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};

	},
	close: function() { // TODO
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	_connect: function(_) {
		try {
			if (!this.stream) {
				this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
				this.stream.setNoDelay(true);
				this.communicator = new SadFsqComm(_, this.stream);
				this.pid = this.communicator.connect(_, this.user, this.password, this.secured);
				this._setSocketTimeout();
			} else {
				this._setSocketTimeout(_, true);
			}
		} catch (e) {
			console.error("SadFsqClient connection error : " + e.stack);
			this._panicRelease(_);
			throw e;
		}
	},
	_setSocketTimeout: function(prevent) {
		if (this.socketTimeout && prevent) {
			clearTimeout(this.socketTimeout);
		}
		var self = this;
		this.socketTimeout = setTimeout(function() {
			try {
				if (self.stream && self.communicator) {
					self.communicator = null;
					self.stream.end();
					self.stream = null;
				}
			} catch (e) {
				console.log("SadFsq disconnection error: " + e.stack);
				self.stream.end();
				self.stream = null;
				throw e;
			}
		}, (config.x3sadfsq && config.x3sadfsq.timeout) || 300000);
	},
	_panicRelease: function(_) {
		var dis = false;
		try {
			this.communicator && this.communicator.disconnect(_);
			dis = true;
			this.stream && this.stream.end();
		} catch (e) {
			try {
				if (!dis && this.stream) {
					this.stream.end();
				}
			} catch (e) {}
		} finally {
			this.stream = null;
			//delete clients[this.printServer];
		}
	}
});