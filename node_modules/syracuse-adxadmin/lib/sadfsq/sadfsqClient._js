"use strict";
var helpers = require('syracuse-core/lib/helpers');
var SadFsqFile = require('syracuse-adxadmin/lib/sadfsq/sadfsqFile').SadFsqFile;
var sadFsqComm = require('syracuse-adxadmin/lib/sadfsq/sadfsqComm');
var SadFsqComm = sadFsqComm.SadFsqComm;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var upath = require('path');
var ufs = require('fs');
var configRecords = {
	dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), "node_modules/syracuse-adxadmin/lib/sadfsq/data")
};
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

var SadPlayer = helpers.defineClass(function(_, json) {
	this.json = json ? json : null;
	// skip RECINFO and COMMENT
	this.step = 2;
	this._nextStep();
}, null, {
	_nextStep: function() {
		if (this.step < this.json.length) {
			this.curStep = this.json[this.step++];
			this.curStep.buf = new Buffer(this.curStep.data, 'hex');
			this.curStep.offset = 0;
		}
	},
	end: function() {
		// nothin
	},
	read: function(_, size) {
		if (this.step <= this.json.length) {
			var buf;
			if (this.curStep.type === "READ") {
				if (this.curStep.buf.length >= this.curStep.offset + size) {
					buf = this.curStep.buf.slice(this.curStep.offset, size);
					this.curStep.offset += size;
					if (this.curStep.offset === this.curStep.buf.length) this._nextStep();
					return buf;
				} else { // ask to read with a size > length 
					console.log("ask to read more that length");
					if (this.curStep.offset < this.curStep.buf.length) {
						buf = this.curStep.buf.slice(this.curStep.offset, this.curStep.buf.length);
					}
					this._nextStep();
					buf = Buffer.concat([buf, new Buffer(size - buf.length)]);
				}
			}
			return new Buffer(size);
		}
	},
	write: function(_, buf) {
		if (this.step < this.json.length) {
			if (this.curStep.type === "WRITE") {
				this.curStep.writeBuf = this.curStep.writeBuf || new Buffer([]);
				this.curStep.writeBuf = Buffer.concat([this.curStep.writeBuf, buf]);
				var len = this.curStep.writeBuf.length;
				if (this.curStep.writeBuf.toString('hex') !== this.curStep.buf.slice(0, len).toString('hex')) {
					throw new Error("bytes written not correspond to buffer saved written buffer[" + this.curStep.writeBuf.toString('hex') + "] saved buffer[" + this.curStep.buf.slice(0, len).toString('hex') + "]");
				}
				if (this.curStep.writeBuf.length === this.curStep.buf.length) this._nextStep();
				return;
			}
		}
		throw new Error("step not correspond to WRITE step save file curStep " + JSON.stringify(this.curStep, null, 2));
	}

});


exports.SadFsqClient = helpers.defineClass(function(_, hostname, port, user, password, secured, recOptions) {
	this.hostname = hostname;
	this.port = port;
	this.user = user;
	this.password = password;
	this.recOptions = recOptions ? recOptions : null;
	this.secured = secured;
	this._connect(_);
	this.fdsOpen = {}; // list of opened fd
}, null, {

	/// 
	/// -------------
	/// ## fileOptions :  
	/// Some following functions take in parameters `fileOptions`.  
	/// This chapter describes how these options can be used.  
	/// TODO.

	/// 
	/// -------------
	/// ## open :
	/// ``` javascript
	/// var fd = sadFsqClient.open(_, fileOptions, flags);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.   
	/// * String : The `flags` parameter can be :
	///    * TODO :
	/// 
	/// Returns the file descriptor or a diagnoses.  
	/// 
	open: function(_, options, flags) {
		var sadFile = new SadFsqFile(options);
		var fd = this.communicator.processTOUF(_, sadFile, flags);
		this.fdsOpen[fd] = sadFile;
		return fd;
	},

	/// 
	/// -------------
	/// ## close :
	/// ``` javascript
	/// var fd = sadFsqClient.close(_, fd);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Integer : The `fd` parameter is the file descriptor.  
	/// 
	/// Return `null` or a diagnoses  
	/// 
	close: function(_, fd) {
		this.communicator.processSFER(_, fd);
		delete this.fdsOpen[fd];
		return;
	},

	/// 
	/// -------------
	/// ## stat :
	/// ``` javascript
	/// var stats = sadFsqClient.stat(_, fileOptions, attributes);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// * Array of String : The `attributes` parameter is an array that contains the attributes name.  
	///    Attributes can have the following values :  
	///    mode, ino, dev, rdev, nlink, uid, gid, size, atime, mtime, ctime.  
	///
	/// Returns a javascript object that contains attributes keys and values.  
	/// ``` json
	///    { 
	///       mode: 33188, // file mode  
	///       ino: 48064969, // inode number  
	///       dev: 0, // id of device containing a directory entry  
	///       rdev: 2114, // id of device if special char/block  
	///       nlink: 1, // number of links  
	///       uid: 85, // uid  
	///       gid: 100, // gid  
	///       size: 527, // file size in bytes  
	///       atime: Mon, 10 Oct 2011 23:24:11 GMT, // last time of access  
	///       mtime: Mon, 10 Oct 2011 23:24:11 GMT, // last time of modification  
	///       ctime: Mon, 10 Oct 2011 23:24:11 GMT // last time of file status change  
	///    }
	/// ``` 
	/// 
	stat: function(_, options, attributes) {
		if (attributes && !Array.isArray(attributes)) throw new Error("INFO parameter must be an array");
		var sadFile = new SadFsqFile(options);
		return this._getInfo(_, sadFile, attributes);
	},

	/// 
	/// -------------
	/// ## fstat :
	/// ``` javascript
	/// var stats = sadFsqClient.fstat(_, fd, attributes);  
	/// ```
	/// This function is the same that `stat` but take a file descriptor as first parameter.  
	/// 
	fstat: function(_, fd, attributes) {
		if (attributes && !Array.isArray(attributes)) throw new Error("INFO parameter must be an array");
		var sadFile = this.fdsOpen[fd];
		return this._getInfo(_, sadFile, attributes);
	},

	_getInfo: function(_, sadFile, attributes) {
		this._connect(_);
		var fileInfo = {};
		if (!attributes) {
			attributes = sadFsqComm.fileAttributes.slice(1);
		}
		for (var i = 0; i < attributes.length; i++) {
			fileInfo[attributes[i]] = this.communicator.processTPRM(_, sadFile, attributes[i]);

		}
		return fileInfo;
	},

	/// 
	/// -------------
	/// ## getFilePath :
	/// ``` javascript
	/// var path = sadFsqClient.getFilePath(_, fileOptions);  
	/// ```
	/// Retrieve the full path of the remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// Returns the the full path.  
	///
	getFilePath: function(_, options) {
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		var fullPath = this.communicator.processTPAT(_, sadFile);
		return fullPath;
	},

	/// 
	/// -------------
	/// ## readFile :  
	/// ``` javascript  
	/// var buf = sadFsqClient.readFile(_, fileOptions, options);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.  
	///
	/// * Object : The `options` parameter is the object that represent encoding and flag.  
	///     * encoding : a string that represent encoding ( 'utf-8', .... By default 'utf-8' )
	///     * flag : a string that represent the open mode for the remote file. See `Flags chapter`. 
	///     By default 'r'.  
	///   eg:  
	/// ``` javascript
	///    var options = {  
	///         encoding:"utf-8",
	///         flag : "r"
	///    };  
	/// ```
	///
	/// Returns the buffer that represents the content of the remote file.  
	/// 
	readFile: function(_, fileOptions, options) {
		this._connect(_);
		var fd = this.open(_, fileOptions, options.flag ? options.flag : "r");
		// get full size of the file 
		var info = this.fstat(_, fd, ['size']);
		var buffer = new Buffer(info.size);
		this.read(_, fd, buffer, 0, info.size);

		this.close(_, fd);
		if (options.encoding) {
			return buffer.toString(options.encoding);
		}
		return buffer;
	},

	/// 
	/// -------------
	/// ## read :  
	/// ``` javascript  
	/// var buf = sadFsqClient.read(_, fd, buffer, offset, length, position);  
	/// ```
	/// Read data from the file specified by fd. 
	///
	/// * `buffer` is the buffer that the data will be written to.  
	///
	/// * `offset` is the offset in the buffer to start writing at.  
	///
	/// * `length` is an integer specifying the number of bytes to read.  
	///
	/// * `position` is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.  
	///
	read: function(_, fd, buffer, offset, length, position) {
		this._connect(_);

		var buf = this.communicator.processSLBF(_, fd, length);
		buf.copy(buffer, offset);
	},
	writeFile: function(_, fileOptions, data, options) {
		this._connect(_);
		var fd = this.open(_, fileOptions, options.flag ? options.flag : "w");
		// get full size of the file 
		var buffer = data instanceof Buffer ? data : new Buffer(data, options.encoding ? options.encoding : "utf-8");
		this.write(_, fd, buffer, 0, buffer.length, 0);
		this.close(_, fd);
	},
	write: function(_, fd, buffer, offset, length, position) {
		this._connect(_);
		this.communicator.processSEBF(_, fd, buffer);
	},

	unlink: function(_, options) {
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		this.communicator.processTEFF(_, sadFile);
		return;
	},



	createProcessus: function(_) {
		this._connect(_);
	},

	killProcessus: function(_) { //TODO
		this._connect(_);
	},

	disconnect: function() { // TODO
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	_connect: function(_) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}


		try {
			if (!this.stream) {
				if (this.recOptions && this.recOptions.recMode === "PLAY") {

					this.stream = new SadPlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + this.recOptions.fileName), null);

				} else {
					this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
					this.stream.setNoDelay(true);
					if (this.recOptions && this.recOptions.recMode === "REC") {
						this.recorder = recordMgr.newRecorder(_, this.stream, this.recOptions, {}, configRecords);

					}
				}
				this.communicator = new SadFsqComm(_, this.stream);
				this.pid = this.communicator.connect(_, this.user, this.password, this.secured);
				this._setSocketTimeout(_);
			} else {
				this._setSocketTimeout(_, true);
			}

		} catch (e) {
			console.error("SadFsqClient connection error : " + e.stack);
			this._panicRelease(_);
			throw e;
		}
	},
	_setSocketTimeout: function(prevent) {
		if (this.socketTimeout && prevent) {
			clearTimeout(this.socketTimeout);
		}
		var self = this;
		this.socketTimeout = setTimeout(function() {
			try {
				if (self.stream && self.communicator) {
					//self.communicator.disconnect(_);
					this.recorder && this.recorder.close();
					self.communicator = null;
					self.stream.end();
					self.stream = null;
				}
			} catch (e) {
				console.log("SadFsq disconnection error: " + e.stack);
				self.stream.end();
				self.stream = null;
				throw e;
			}
		}, (config.x3sadfsq && config.x3sadfsq.timeout) || 10000);
	},
	_panicRelease: function(_) {
		var dis = false;
		try {
			this.recorder && this.recorder.close();
			this.communicator && this.communicator.disconnect(_);
			dis = true;
			this.stream && this.stream.end();
		} catch (e) {
			try {
				if (!dis && this.stream) {
					this.stream.end();
				}
			} catch (e) {}
		} finally {
			this.stream = null;
			//delete clients[this.printServer];
		}
	}
});