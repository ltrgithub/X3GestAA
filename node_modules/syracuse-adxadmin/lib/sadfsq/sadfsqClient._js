"use strict";
var helpers = require('syracuse-core/lib/helpers');
var SadFsqFile = require('syracuse-adxadmin/lib/sadfsq/sadfsqFile').SadFsqFile;
var sadFsqComm = require('syracuse-adxadmin/lib/sadfsq/sadfsqComm');
var SadFsqComm = sadFsqComm.SadFsqComm;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var upath = require('path');
var ufs = require('fs');
var configRecords = {
	dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), "node_modules/syracuse-adxadmin/lib/sadfsq/data")
};
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

var SadPlayer = helpers.defineClass(function(_, json) {
	this.json = json ? json : null;
	// skip RECINFO and COMMENT
	this.step = 2;
	this._nextStep();
}, null, {
	_nextStep: function() {
		if (this.step < this.json.length) {
			this.curStep = this.json[this.step++];
			this.curStep.buf = new Buffer(this.curStep.data, 'hex');
			this.curStep.offset = 0;
		}
	},
	end: function() {
		// nothin
	},
	read: function(_, size) {
		if (this.step <= this.json.length) {
			var buf;
			if (this.curStep.type === "READ") {
				if (this.curStep.buf.length >= this.curStep.offset + size) {
					buf = this.curStep.buf.slice(this.curStep.offset, size);
					this.curStep.offset += size;
					if (this.curStep.offset === this.curStep.buf.length) this._nextStep();
					return buf;
				} else { // ask to read with a size > length
					if (this.curStep.offset < this.curStep.buf.length) {
						buf = this.curStep.buf.slice(this.curStep.offset, this.curStep.buf.length);
					}
					this._nextStep();
					buf = Buffer.concat([buf, new Buffer(size - buf.length)]);
				}
			}
			return new Buffer(size);
		}
	},
	write: function(_, buf) {
		if (this.step < this.json.length) {
			if (this.curStep.type === "WRITE") {
				this.curStep.writeBuf = this.curStep.writeBuf || new Buffer([]);
				this.curStep.writeBuf = Buffer.concat([this.curStep.writeBuf, buf]);
				var len = this.curStep.writeBuf.length;
				if (this.curStep.writeBuf.toString('hex') !== this.curStep.buf.slice(0, len).toString('hex')) {
					throw new Error("bytes written not correspond to buffer saved written buffer[" + this.curStep.writeBuf.toString('hex') + "] saved buffer[" + this.curStep.buf.slice(0, len).toString('hex') + "]");
				}
				if (this.curStep.writeBuf.length === this.curStep.buf.length) this._nextStep();
				return;
			}
		}
		throw new Error("step not correspond to WRITE step save file curStep " + JSON.stringify(this.curStep, null, 2));
	}

});

exports.Mod = {
	O_RDONLY: 0x0000,
	O_WRONLY: 0x0001,
	O_RDWR: 0x0002,
	O_APPEND: 0x0008,
	O_CREAT: 0x0100,
	O_TRUNC: 0x0200,
	O_EXCL: 0x0400
};

exports.Mask = {
	S_IREAD: 0x0100,
	S_IWRITE: 0x0080,
	S_IEXEC: 0x0040
};

exports.SadFsqClient = helpers.defineClass(function(_, hostname, port, user, password, secured, recOptions) {
	this.hostname = hostname;
	this.port = port;
	this.user = user;
	this.password = password;
	this.recOptions = recOptions ? recOptions : null;
	this.secured = secured;
	this._connect(_);
	this.fdsOpen = {}; // list of opened fd
}, null, {

	/// !doc
	/// 
	/// # SadFsq Client  
	/// SadFsq is provided by simple wrappers around standard POSIX functions.  
	/// The module is using sadfsq protocol layer implemented in [SadFsqComm](./sadfsqComm.md).  
	/// To use this module do require('syracuse-adxadmin/lib/sadfsq/sadfsqClient').SadFsqClient.  
	/// All the methods are asynchronous.  
	/// ``` javascript
	/// var SadFsqClient = require('syracuse-adxadmin/lib/sadfsq/sadfsqClient').SadFsqClient;
	/// var sadfs = new SadFsqClient(_, "server", "port", "user", "password", secure);
	/// ```
	/// * `server` is the hostname of the adxadmin server.  
	/// * `port` is the port on adxadmin is listenning.  
	/// * `user` is the system user to use for the connection.  
	/// * `password` is the password corresponding to the user.  
	/// * `secure` is boolean that define if the connection is secured by user/password.  
	/// 
	/// 
	/// ## General parameters  
	/// In the following described functions, some general parameters would be necessary. This chapter describes these parameters.  
	/// 
	/// ### File Options :  
	/// Some following functions take in parameters `fileOptions`.  
	/// This chapter describes how these options can be used.  
	/// TODO.
	///
	/// -------------
	/// ### Flags :  
	/// Some following functions take in parameters `flags`.  
	/// This chapter describes how these options can be used.  
	/// The flags argument points to a string. If the string is one of the following, the file shall be opened in the indicated mode. Otherwise, the behavior is undefined.  
	/// * `r` or `rb` : Open file for reading.  
	/// * `w` or `wb` : Truncate to zero length or create file for writing.  
	/// * `a` or `ab` : Append; open or create file for writing at end-of-file.  
	/// * `r+` or `rb+` or `r+b` : Open file for update (reading and writing).  
	/// * `w+` or `wb+` or `w+b` : Truncate to zero length or create file for update.  
	/// * `a+` or `ab+` or `a+b` : Append; open or create file for update, writing at end-of-file.  
	/// 
	/// 
	/// 




	/// ## Functions
	/// 
	/// -------------
	/// ### open :
	/// ``` javascript
	/// var fd = sadfs.open(_, fileOptions, flags);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#File Options-). .   
	/// * `flag` : a string that represent the open mode for the remote file. See [Flags](./sadfsqClient.md#flags-). 
	/// 
	/// Opening a file with read mode (`r` as the first character in the mode argument) shall fail if the file does not exist or cannot be read.  
	/// 
	/// Opening a file with append mode (`a` as the first character in the mode argument) shall cause all subsequent writes to the file to be forced to the then current end-of-file, regardless of intervening calls to `seek()` function.  
	/// 
	/// When a file is opened with update mode ('+' as the second or third character in the mode argument), both input and output may be performed on the associated stream. However, the application shall ensure that output is not directly followed by input without an intervening call to flush() or to a file positioning function as seek(), and input is not directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file.  
	/// 
	/// If mode is `w`, `wb`, `a`, `ab`, `w+`, `wb+`, `w+b`, `a+`, `ab+`, or `a+b`, and the file did not previously exist, upon successful completion, `open()` shall mark for update the last data access, last data modification, and last file status change timestamps of the file and the last file status change and last data modification timestamps of the parent directory.  
	/// 
	/// If mode is `w`, `wb`, `a`, `ab`, `w+`, `wb+`, `w+b`, `a+`, `ab+`, or `a+b`, and the file did not previously exist, `open()` shall create a file.  
	/// 
	/// If mode is `w`, `wb`, `w+`, `wb+`, or `w+b`, and the file did previously exist, upon successful completion, `open()` shall mark for update the last data modification and last file status change timestamps of the file.  
	/// 
	/// Returns the file descriptor.  
	/// 
	open: function(_, options, flags) {
		var sadFile = new SadFsqFile(options);
		var fd = this.communicator.processOUF(_, sadFile, flags);
		var fuuid = helpers.uuid.generate();
		this.fdsOpen[fuuid] = {
			sadFile: sadFile,
			fd: fd,
			offset: 0,
			mode: flags
		};
		this.fdsOpen[fuuid].size = this.fstat(_, fuuid, ["size"]).size;
		return fuuid;
	},


	// not used today with the runtime
	_openSys: function(_, options, mod, umask) {
		var sadFile = new SadFsqFile(options);
		var fd = this.communicator.processOUS(_, sadFile, mod, umask);
		var fuuid = helpers.uuid.generate();
		this.fdsOpen[fuuid] = {
			sadFile: sadFile,
			fd: fd,
			offset: 0,
		};
		this.fdsOpen[fuuid].size = this.fstat(_, fuuid, ["size"]).size;
		return fuuid;
	},

	/// 
	/// -------------
	/// ## feof :
	/// ``` javascript
	/// sadfs.feof(_, fd);  
	/// ```
	/// return true if the current position in the remote file is End Of File.  
	/// 
	/// * `fd` is a file descriptor that identified the remote file.  
	/// 
	/// Returns the file descriptor.  
	/// 
	feof: function(_, fd) {
		if (this.fdsOpen && this.fdsOpen[fd]) {
			return this.communicator.processTFF(_, this.fdsOpen[fd].fd) !== 0;
		} else {
			throw new Error("file decriptor not valid - no opened file is associated");
		}

	},


	ftruncate: function(_, fd, len) {
		if (this.fdsOpen && this.fdsOpen[fd] && this.fdsOpen[fd].mode &&
			(this.fdsOpen[fd].mode === "r+" || this.fdsOpen[fd].mode === 'w+')) {
			var size = this.fdsOpen[fd].size;
			var sadFile = this.fdsOpen[fd].sadFile;
			var mod = this.fdsOpen[fd].mode;
			// read the content and not take the bytes that will be truncated
			var buffer = new Buffer(size - len);
			var readLen = this.read(_, fd, buffer, 0, size - len, len);
			if (readLen === size - len) {
				// close file
				this.close(_, fd);
				// delete remote file
				this.unlink(_, sadFile);
				if (mod === "r+") { // create an empty file
					this.communicator.processFER(_, this.communicator.processOUF(_, sadFile, "w+"));

				}
				// create a new file with truncate content
				this.fdsOpen[fd] = { // reassociate the new remote file with same uuid
					sadFile: sadFile,
					fd: this.communicator.processOUF(_, sadFile, mod),
					offset: 0,
					mode: mod
				};
				this.fdsOpen[fd].size = this.fstat(_, fd, ["size"]).size;
				// write truncate content
				this.write(_, fd, buffer, 0, buffer.length, 0);
			} else {
				throw new Error("can't truncate, the bytes read size not correspond to the size expected");
			}
		} else {
			throw new Error("can't truncate, not write mode on opened file. must be r+, w+, a+");
		}

	},

	truncate: function(_, options, len) {
		var fd = this.open(_, options, "r+");
		var size = this.fdsOpen[fd].size;
		if (size - len > 0) { // we need to keep some data in file
			this.ftruncate(_, fd, len);
			this.close(_, fd);
		} else {
			this.close(_, fd);
			fd = this.open(_, options, "w"); // automatically truncate all data in file
			this.close(_, fd);
		}
	},

	/// 
	/// -------------
	/// ### rename :
	/// ``` javascript
	/// sadfs.rename(_, oldOptions, newOptions);  
	/// ```
	/// Open a remote file in system mode
	/// Retrieve informations from remote file.  
	/// 
	/// * `oldOptions` is the object that represent the old sadFsq File options that you want to rename. See `fileOptions`.   
	/// * `newOptions` is the object that represent the new sadFsq File options . See `fileOptions`.   
	/// * `mod` can be :
	///    * TODO :
	/// * `umask` can be :
	///    * TODO :
	/// 
	/// Returns the file descriptor or a diagnoses.  
	/// 
	rename: function(_, oldOptions, newOptions) {
		var oldSadFile = new SadFsqFile(oldOptions);
		var newSadFile = new SadFsqFile(newOptions);
		this.communicator.processREN(_, oldSadFile, newSadFile);
	},

	/// 
	/// -------------
	/// ### close :
	/// ``` javascript
	/// var fd = sadfs.close(_, fd);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fd` is an integer that represents the file descriptor.  
	/// 
	/// Return `null` or a diagnoses  
	/// 
	close: function(_, fd) {
		var opened = this.fdsOpen[fd];
		if (opened) {
			this.communicator && this.communicator.processFER(_, opened.fd);
			delete this.fdsOpen[fd];
			return;
		} else {
			throw new Error("can't close file, fd is not valid");
		}
	},

	/// 
	/// -------------
	/// ### stat :
	/// ``` javascript
	/// var stats = sadfs.stat(_, fileOptions, attributes);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// * `attributes` is an array of strings that contains the attributes name.  
	///    Attributes can have the following values :  
	///    mode, ino, dev, rdev, nlink, uid, gid, size, atime, mtime, ctime.  
	///
	/// Returns a javascript object that contains attributes keys and values.  
	/// ``` json
	///    { 
	///       mode: 33188, // file mode  
	///       ino: 48064969, // inode number  
	///       dev: 0, // id of device containing a directory entry  
	///       rdev: 2114, // id of device if special char/block  
	///       nlink: 1, // number of links  
	///       uid: 85, // uid  
	///       gid: 100, // gid  
	///       size: 527, // file size in bytes  
	///       atime: Mon, 10 Oct 2011 23:24:11 GMT, // last time of access  
	///       mtime: Mon, 10 Oct 2011 23:24:11 GMT, // last time of modification  
	///       ctime: Mon, 10 Oct 2011 23:24:11 GMT // last time of file status change  
	///    }
	/// ``` 
	/// 
	stat: function(_, options, attributes) {
		if (attributes && !Array.isArray(attributes)) throw new Error("INFO parameter must be an array");
		var sadFile = new SadFsqFile(options);
		return this._getInfo(_, sadFile, attributes);
	},

	/// 
	/// -------------
	/// ### fstat :
	/// ``` javascript
	/// var stats = sadfs.fstat(_, fd, attributes);  
	/// ```
	/// This function is the same that `stat` but take a file descriptor as first parameter.  
	/// 
	fstat: function(_, fd, attributes) {
		if (attributes && !Array.isArray(attributes)) throw new Error("INFO parameter must be an array");
		var sadFile = this.fdsOpen[fd].sadFile;
		return this._getInfo(_, sadFile, attributes);
	},

	_getInfo: function(_, sadFile, attributes) {
		this._connect(_);
		var fileInfo = {};
		if (!attributes) {
			attributes = sadFsqComm.fileAttributes.slice(1);
		}
		for (var i = 0; i < attributes.length; i++) {
			fileInfo[attributes[i]] = this.communicator.processPRM(_, sadFile, attributes[i]);

		}
		return fileInfo;
	},

	/// 
	/// -------------
	/// ### path :
	/// ``` javascript
	/// var path = sadfs.path(_, fileOptions);  
	/// ```
	/// Retrieve the full path of the remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// Returns the the full path.  
	///
	path: function(_, options) {
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		var fullPath = this.communicator.processPAT(_, sadFile);
		return fullPath;
	},

	/// 
	/// -------------
	/// ### readFile :  
	/// ``` javascript  
	/// var buf = sadfs.readFile(_, fileOptions, [options]);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See `fileOptions`.  
	///
	/// * `options` is the object that represent encoding and flag.  
	///     * encoding : a string that represent encoding ( 'utf-8', .... By default 'utf-8' )
	///     * flag : a string that represent the open mode for the remote file. See `Flags chapter`. 
	///     By default 'r'.  
	///   eg:  
	/// ``` javascript
	///    var options = {  
	///         encoding:"utf-8",
	///         flag : "r"
	///    };  
	/// ```
	///
	/// Returns the buffer that represents the content of the remote file.  
	/// 
	readFile: function(_, fileOptions, options) {
		this._connect(_);
		var fd = this.open(_, fileOptions, options && options.flag ? options.flag : "r");
		// get full size of the file 
		var buffer = new Buffer(this.fdsOpen[fd].size);
		this.read(_, fd, buffer, 0, this.fdsOpen[fd].size);

		this.close(_, fd);
		if (options && options.encoding) {
			return buffer.toString(options.encoding);
		}
		return buffer;
	},

	/// 
	/// -------------
	/// ### read :  
	/// ``` javascript  
	/// var buf = sadfs.read(_, fd, buffer, offset, length, position);  
	/// ```
	/// Read data from the file specified by fd. 
	///
	/// * `buffer` is the buffer that the data will be written to.  
	///
	/// * `offset` is the offset in the buffer to start writing at.  
	///
	/// * `length` is an integer specifying the number of bytes to read.  
	///
	/// * `position` is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.  
	/// 
	/// Returns the size of red bytes.  
	///
	read: function(_, fd, buffer, offset, length, position) {
		this._connect(_);
		var fdOpened = this.fdsOpen[fd];
		var pos = position && position > 0 ? position : fdOpened.offset;

		var lenToRead = pos + length > fdOpened.size ? fdOpened.size - pos : length;
		if (lenToRead > 0) {
			if (position != null) {
				this.seek(_, fd, 0, position);
			}
			var buf = this.communicator.processLBF(_, fdOpened.fd, lenToRead);
			buf.copy(buffer, offset);
			fdOpened.offset += buf.length;
			return buf.length; // return size of bytes read
		} else {
			return 0;
		}
	},

	/// 
	/// -------------
	/// ### getPosition :  
	/// ``` javascript  
	/// var position = sadfs.getPosition(_, fd);  
	/// ```
	/// Get the cursor position in the file specified by fd. 
	///
	getPosition: function(_, fd) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			return this.communicator.processPOS(_, opened.fd);
		} else {
			throw new Error("File must be opened before get position.");
		}
	},

	/// 
	/// -------------
	/// ### seek :  
	/// ``` javascript  
	/// var position = sadfs.seek(_, fd, cursor, offset, [strict]);  
	/// ```
	/// Change the cursor position in the file specified by fd. 
	/// 
	/// * `cursor` is the base of the move. (0: BOF, 1: Current position, 2: EOF)  
	///
	/// * `offset` is a number of bytes to ignore until the new position.  
	/// 
	/// * `strict` define if the position is allowed to be out of bounds. `true` by default.  
	///
	seek: function(_, fd, cursor, offset, strict) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			if (strict == null) strict = true;
			if (strict) {
				switch (cursor) {
					case 0:
						if (offset > opened.size) throw new Error("Offset [" + offset + "] is bigger than file size [" + opened.size + "].");
						break;
					case 1:
						if (offset + opened.offset > opened.size)
							throw new Error("Offset added to current position is bigger than file size.");
						break;
					case 2:
						if (offset > 0) throw new Error("Offset can't be positive with EOF cursor.");
						break;
					default:
						throw new Error("Cursor parameter can be 0 for 'BOF', 1 for 'Current possition' or 2 for 'EOF'.");
				}
			}
			this.communicator.processDPL(_, opened.fd, cursor, offset);
			opened.offset += offset;
		} else {
			throw new Error("File must be opened before seek.");
		}
	},

	writeFile: function(_, fileOptions, data, options) {
		this._connect(_);
		var fd = this.open(_, fileOptions, options.flag ? options.flag : "w");
		// get full size of the file 
		var buffer = data instanceof Buffer ? data : new Buffer(data, options.encoding ? options.encoding : "utf-8");
		this.write(_, fd, buffer, 0, buffer.length, 0);
		this.close(_, fd);
	},
	write: function(_, fd, buffer, offset, length, position) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			if (position != null) {
				this.flush(_, fd);
				this.seek(_, fd, 0, position);
			}
			var begin = offset || 0;
			var end = begin + length;
			this.communicator.processEBF(_, opened.fd, buffer.slice(begin, end));
			this.fdsOpen[fd].size += length;
		} else {
			throw new Error("File must be opened before write.");
		}

	},

	/// 
	/// -------------
	/// ### unlink :  
	/// ``` javascript  
	/// sadfs.unlink(_, fileOptions);  
	/// ```
	/// Delete the remote file. 
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See `fileOptions`.  
	///
	unlink: function(_, options) {
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		this._unlink(_, sadFile);
		return;
	},

	_unlink: function(_, sadFile) {
		this._connect(_);
		this.communicator.processEFF(_, sadFile);
		return;
	},
	/// 
	/// -------------
	/// ### flush :  
	/// ``` javascript  
	/// sadfs.flush(_, fileOptions);  
	/// ```
	/// Force the buffers to be flushed into the file specified by fd without waiting for close.  
	///
	flush: function(_, fd) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			this.communicator.processVID(_, opened.fd);
		} else {
			throw new Error("File must be opened before flush.");
		}
	},

	appendFile: function(_, fileOptions, str, options) {
		this._connect(_);
		var fd = this.open(_, fileOptions, options.flag ? options.flag : "a");
		var buffer = new Buffer(str, options.encoding ? options.encoding : "utf-8");
		this.write(_, fd, buffer, 0, buffer.length);
		this.close(_, fd);
	},

	exists: function(_, options) {
		this._connect(_);
		try {
			this.stat(_, options, ["size"]);
			return true;
		} catch (e) {
			return false;
		}
	},
	/// 
	/// -------------
	/// ### lock :  
	/// ``` javascript  
	/// sadfs.lock(_, fd, type, len, pos);  
	/// ```
	/// Allows sections of the file specified by fd to be locked.  
	/// 
	/// * `fd` argument is an open file descriptor. The file descriptor must have Write permission in order to establish locks with this function call.  
	/// 
	/// * `type` argument is a control value that specifies the action to be taken. The permissible values for function are :  
	///    * 0: unlock previously locked section.  
	///    * 1: lock section for exclusive use.  
	///    * 2: test & lock section for exclusive use.  
	///    * 3: test section for other locks.  
	///
	/// * `len` argument is the number of contiguous bytes to be locked or unlocked.  
	/// 
	/// * `pos` define where the lock will start. Not including current byte.  
	///
	/// Force the buffers to be flushed into the file specified by fd without waiting for close.  
	///
	lock: function(_, fd, type, len, pos) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			return this.communicator.processLCK(_, opened.fd, type, len, pos);
		} else {
			throw new Error("File must be opened before lock.");
		}
	},

	exec: function(_, cmd, outOption) {
		this._connect(_);
		var sadFile = new SadFsqFile({
			canonical: cmd + " "
		});
		var pid = this.communicator.processOUP(_, sadFile, "r");
		if (pid) {
			var res = {
				pid: pid
			};
			if (outOption) {
				var buffer = this.communicator.processLBF(_, pid, 1024 * 32);
				if (buffer) {
					if (outOption.encoding)
						res.stdout = buffer.toString(outOption.encoding);
					res.stdout = buffer;
				}
			}
			return res;
		} // else an errar is catch by T_OUP
		throw new Error("failed to exec cmd " + cmd);
	},

	kill: function(_, pid, signal) { //TODO
		this._connect(_);
		this.communicator.processKUS(_, pid, signal);
	},

	disconnect: function() { // TODO
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	_connect: function(_) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}


		try {
			if (!this.stream) {
				if (this.recOptions && this.recOptions.recMode === "PLAY") {

					this.stream = new SadPlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + this.recOptions.fileName), null);

				} else {
					this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
					this.stream.setNoDelay(true);
					if (this.recOptions && this.recOptions.recMode === "REC") {
						this.recorder = recordMgr.newRecorder(_, this.stream, this.recOptions, {}, configRecords);

					}
				}
				this.communicator = new SadFsqComm(_, this.stream);
				this.pid = this.communicator.connect(_, this.user, this.password, this.secured);
				this._setSocketTimeout(_);
			} else {
				this._setSocketTimeout(_, true);
			}

		} catch (e) {
			console.error("SadFsqClient connection error : " + e.stack);
			this._panicRelease(_);
			throw e;
		}
	},
	_setSocketTimeout: function(prevent) {
		if (this.socketTimeout && prevent) {
			clearTimeout(this.socketTimeout);
		}
		var self = this;
		this.socketTimeout = setTimeout(function() {
			try {
				if (self.stream && self.communicator) {
					//self.communicator.disconnect(_);
					this.recorder && this.recorder.close();
					self.communicator = null;
					self.stream.end();
					self.stream = null;
				}
			} catch (e) {
				console.log("SadFsq disconnection error: " + e.stack);
				self.stream.end();
				self.stream = null;
				throw e;
			}
		}, (config.x3sadfsq && config.x3sadfsq.timeout) || 10000);
	},
	_panicRelease: function(_) {
		var dis = false;
		try {
			this.recorder && this.recorder.close();
			this.communicator && this.communicator.disconnect(_);
			dis = true;
			this.stream && this.stream.end();
		} catch (e) {
			try {
				if (!dis && this.stream) {
					this.stream.end();
				}
			} catch (e) {}
		} finally {
			this.stream = null;
			//delete clients[this.printServer];
		}
	}
});