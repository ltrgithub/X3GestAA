"use strict";
var helpers = require('syracuse-core/lib/helpers');
var SadFsqFile = require('syracuse-adxadmin/lib/sadfsq/sadfsqFile').SadFsqFile;
var SadFsqComm = require('syracuse-adxadmin/lib/sadfsq/sadfsqComm').SadFsqComm;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;

function generateDiag(e) {
	return {
		$diagnoses: [{
			$severity: "error",
			$message: e.message,
			$stackTrace: e.stack
		}]
	};
};

exports.SadFsqClient = helpers.defineClass(function(_, hostname, port, user, password, secured) {
	this.hostname = hostname;
	this.port = port;
	this.user = user;
	this.password = password;
	this.secured = secured;
	this._connect(_);
}, null, {

	///------------ 
	/// ## getFileInfo: 
	/// ``` javascript
	/// sadFsqClient.getFileInfo
	getFileInfo: function(_, options, info) {
		if (!this.stream) { // check if connected
			this._connect(_);
		}
		try {
			var sadFile = new SadFsqFile(options);

			this.communicator.processTOUF(_, sadFile, "r");
			// read content 
			this.communicator.processTPRM(_, sadFile, info);
			// close remote file 
			this.communicator.processSFER(_, sadFile);

		} catch (e) {
			// return status of file info 
			return generateDiag(e);
		}

		var res = {};
		res[info] = sadFile.fileInfo[info];
		return res;

	},
	readFile: function(_, file) {
		if (!this.stream) {
			this._connect(_);
		}
		var ok = true;
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		this.communicator.processTOUF(_, sadFile);
		// read content 
		this.communicator.processSLFB(_, sadFile);
		// close remote file 
		this.communicator.processSFER(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};

	},
	writeFile: function(_, file, buffer) {
		if (!this.stream) {
			this._connect(_);
		}
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		sadFile.binary = buffer;
		this.communicator.processTOUF(_, sadFile);
		// read content 
		this.communicator.processSEFB(_, sadFile);
		// close remote file 
		this.communicator.processSFER(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};


	},
	createProcessus: function(_) {
		if (!stream) {
			this._connect(_);
		}
	},
	deleteFile: function(_, file) {
		if (!this.stream) {
			this.connect(_);
		}
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		this.communicator.processTEFF(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};
	},
	killProcessus: function(_) { //TODO
		if (!this.stream) {
			this._connect(_);
		}
	},
	getFilePath: function(_) {
		if (!this.stream) {
			this._connect(_);
		}
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		this.communicator.processTPAT(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};

	},
	close: function() { // TODO
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	_connect: function(_) {
		try {
			this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
			this.stream.setNoDelay(true);
			this.communicator = new SadFsqComm(_, this.stream);
			this.pid = this.communicator.connect(_, this.user, this.password, this.secured);
			this._setSocketTimeout(_);
		} catch (e) {
			console.error("SadFsqClient connection error : " + e.stack);
			this._panicRelease(_);
			throw e;
		}
	},
	_setSocketTimeout: function(_, prevent) {
		if (this.socketTimeout && prevent) {
			clearTimeout(this.socketTimeout);
		}
		var self = this;
		this.socketTimeout = setTimeout(function(_) {
			try {
				if (self.stream && self.communicator) {
					//self.communicator.disconnect(_);
					self.stream.end();
					self.stream = null;
				}
			} catch (e) {
				console.log("SadFsq disconnection error: " + e.stack);
				self.stream.end();
				self.stream = null;
				throw e;
			}
		}, (config.x3sadfsq && config.x3sadfsq.timeout) || 300000);
	},
	_panicRelease: function(_) {
		var dis = false;
		try {
			this.communicator && this.communicator.disconnect(_);
			dis = true;
			this.stream && this.stream.end();
		} catch (e) {
			try {
				if (!dis && this.stream) {
					this.stream.end();
				}
			} catch (e) {}
		} finally {
			this.stream = null;
			//delete clients[this.printServer];
		}
	}
});