"use strict";
var helpers = require('syracuse-core/lib/helpers');
var SadFsqFile = require('syracuse-adxadmin/lib/sadfsq/sadfsqFile').SadFsqFile;
var SadFsqComm = require('syracuse-adxadmin/lib/sadfsq/sadfsqComm').SadFsqComm;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var upath = require('path');
var ufs = require('fs');
var configRecords = {
	dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), "node_modules/syracuse-adxadmin/lib/sadfsq/data")
};
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

var SadPlayer = helpers.defineClass(function(_, json) {
	this.json = json ? json : null;
	// skip RECINFO and COMMENT
	this.step = 2;
	this._nextStep();
}, null, {
	_nextStep: function() {
		if (this.step < this.json.length) {
			this.curStep = this.json[this.step++];
			this.curStep.buf = new Buffer(this.curStep.data, 'hex');
			this.curStep.offset = 0;
		}
	},
	read: function(_, size) {
		if (this.step <= this.json.length) {
			var buf;
			if (this.curStep.type === "READ") {
				if (this.curStep.buf.length >= this.curStep.offset + size) {
					buf = this.curStep.buf.slice(this.curStep.offset, size);
					this.curStep.offset += size;
					if (this.curStep.offset === this.curStep.buf.length) this._nextStep();
					return buf;
				} else { // ask to read with a size > length 
					console.log("ask to read more that length");
					if (this.curStep.offset < this.curStep.buf.length) {
						buf = this.curStep.buf.slice(this.curStep.offset, this.curStep.buf.length);
					}
					this._nextStep();
					buf = Buffer.concat([buf, new Buffer(size - buf.length)]);
				}
			}
			return new Buffer(size);
		}
	},
	write: function(_, buf) {
		if (this.step < this.json.length) {
			if (this.curStep.type === "WRITE") {
				this.curStep.writeBuf = this.curStep.writeBuf || new Buffer([]);
				this.curStep.writeBuf = Buffer.concat([this.curStep.writeBuf, buf]);
				var len = this.curStep.writeBuf.length;
				if (this.curStep.writeBuf.toString('hex') !== this.curStep.buf.slice(0, len).toString('hex')) {
					throw new Error("bytes written not correspond to buffer saved written buffer[" + this.curStep.writeBuf.toString('hex') + "] saved buffer[" + this.curStep.buf.slice(0, len).toString('hex') + "]");
				}
				if (this.curStep.writeBuf.length === this.curStep.buf.length) this._nextStep();
				return;
			}
		}
		throw new Error("step not correspond to WRITE step save file curStep " + JSON.stringify(this.curStep, null, 2));
	}

});


exports.SadFsqClient = helpers.defineClass(function(_, hostname, port, user, password, secured, recOptions) {
	this.hostname = hostname;
	this.port = port;
	this.user = user;
	this.password = password;
	this.recOptions = recOptions ? recOptions : null;
	this.secured = secured;
	this._connect(_);
}, null, {

	/// 
	/// -------------
	/// ## fileOptions :  
	/// Some following functions take in parameters `fileOptions`.  
	/// This chapter describes how these options can be used.  
	/// TODO.

	/// 
	/// -------------
	/// ## open :
	/// ``` javascript
	/// var fd = sadFsqClient.open(_, fileOptions, flags);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.   
	/// * String : The `flags` parameter can be :
	///    * TODO :
	/// 
	/// Returns the file descriptor or a diagnoses.  
	/// 
	open: function(_, options, flags) {
		var sadFile = new SadFsqFile(options);
		this.communicator.processTOUF(_, sadFile, flags);
		return sadFile.fd;
	},

	/// 
	/// -------------
	/// ## close :
	/// ``` javascript
	/// var fd = sadFsqClient.close(_, fd);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Integer : The `fd` parameter is the file descriptor.  
	/// 
	/// Return `null` or a diagnoses  
	/// 
	close: function(_, fd) {
		var sadFile = new SadFsqFile({
			fd: fd
		});
		this.communicator.processSFER(_, sadFile);
		return;
	},
	/// 
	/// -------------
	/// ## getFileInfos :
	/// ``` javascript
	/// var info = sadFsqClient.getFileInfo(_, fileOptions, attributes);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// * Array of String : The `attributes` parameter is an array that contains the attributes name.  
	///	   Attributes can have the following values :  
	///	   * `mode` :                1 -> file mode  
	///	   * `inode` :               2 -> inode number  
	///	   * `dev_id1` :             3 -> id of device containing a directory entry  
	///	   * `dev_id2` :             4 -> id of device if special char/block  
	///	   * `nb_links` :            5 -> number of links  
	///	   * `uid` :                 6 -> uid  
	///	   * `gid` :                 7 -> gid  
	///	   * `size` :                8 -> file size in bytes  
	///	   * `last_access` :         9 -> last time of access  
	///	   * `last_modification` :  10 -> last time of modification  
	///	   * `last_status_change` : 11 -> last time of file status change  
	///    
	/// Returns a javascript object that contains attributes keys and values.  
	/// 
	getFileInfo: function(_, options, info) {
		if (!Array.isArray(info)) throw new Error("INFO parameter must be an array");
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		for (var i = 0; i < info.length; i++) {
			this.communicator.processTPRM(_, sadFile, info[i]);
		}
		return sadFile.fileInfo;
	},

	/// 
	/// -------------
	/// ## getFilePath :
	/// ``` javascript
	/// var path = sadFsqClient.getFilePath(_, fileOptions);  
	/// ```
	/// Retrieve the full path of the remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// Returns the the full path.  
	///
	getFilePath: function(_, options) {
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		this.communicator.processTPAT(_, sadFile);
		return sadFile.fullpath;
	},

	/// 
	/// -------------
	/// ## readFile :  
	/// ``` javascript  
	/// var info = sadFsqClient.readFile(_, fileOptions, options);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options.  
	///    eg:  
	/// ``` javascript
	///    var fileOptions = {
	///       folder: "SUPERV",
	///       path: "tmp",
	///       name: "test",
	///       extension: "txt"
	///    };
	/// ```
	///
	/// * Object : The `options` parameter is the object that represent encoding and flag.  
	///    	* encoding : a string that represent encoding ( 'utf-8', .... By default 'utf-8' )
	///     * flag : a string that represent the open mode for the remote file ('r', 'w', ... By default 'r')
	///   eg:  
	/// ``` javascript
	///    var options = {  
	///			encoding:"utf-8",
	///         flag : "r"
	///	   };  
	///
	/// Returns the buffer representent the content of the remote file
	/// 

	readFile: function(_, fileOptions, options) {
		this._connect(_);
		var fd = this.open(_, fileOptions, options.flag ? options.flag : "r");
		// get full size of the file 
		var info = this.getFileInfo(_, fileOptions, ['size']);
		var buffer = new Buffer(info.size);
		this.read(_, fd, buffer, 0, info.size);

		this.close(_, fd);
		if (options.encoding) {
			return buffer.toString(options.encoding);
		}
		return buffer;

	},
	read: function(_, fd, buffer, offset, length, position) {
		if (!this.stream) throw Error("not connected to the server");
		var sadFile = new SadFsqFile({
			fd: fd
		});
		this.communicator.processSLBF(_, sadFile, length);
		sadFile.binary.copy(buffer, offset);
		return buffer;

	},
	writeFile: function(_, fileOptions, data, options) {
		try {
			this._connect(_);
			var fd = this.open(_, fileOptions, options.flag ? option.flag : "w");
			// get full size of the file 
			var buffer = data instanceof Buffer ? data : new Buffer(data, options.encoding ? options.encoding : "utf-8");
			this.write(_, fd, buffer, 0, size, 0);

			this.close(_, fd);
			if (options.encoding) {
				return buffer.toString(options.encoding);
			}
			return buffer;
		} catch (e) {
			return generateDiag(e);
		}

	},
	write: function(_, fd, buffer, offset, length, position) {
		if (!this.stream) throw Error("not connected to the server");
		try {
			var sadFile = new SadFsqFile({
				fd: fd
			});
			this.communicator.processSEFB(_, sadFile, length);
			sadFile.binary.copy(buffer, offset);
			return buffer;
		} catch (e) {
			return generateDiag(e);
		}

	},

	unlink: function(_, options) {
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		this.communicator.processTEFF(_, sadFile);
		return;
	},



	createProcessus: function(_) {
		this._connect(_);
	},

	killProcessus: function(_) { //TODO
		this._connect(_);
	},

	_disconnect: function() { // TODO
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	_connect: function(_) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}


		try {
			if (!this.stream) {
				if (this.recOptions && this.recOptions.recMode === "PLAY") {

					this.stream = new SadPlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + this.recOptions.fileName + ".json"), null);

				} else {
					this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
					this.stream.setNoDelay(true);
					if (this.recOptions && this.recOptions.recMode === "REC")
						this.recorder = recordMgr.newRecorder(_, this.stream, this.recOptions, {}, configRecords);
				}
				this.communicator = new SadFsqComm(_, this.stream);
				this.pid = this.communicator.connect(_, this.user, this.password, this.secured);
				this._setSocketTimeout(_);
			} else {
				this._setSocketTimeout(_, true);
			}

		} catch (e) {
			console.error("SadFsqClient connection error : " + e.stack);
			this._panicRelease(_);
			throw e;
		}
	},
	_setSocketTimeout: function(prevent) {
		if (this.socketTimeout && prevent) {
			clearTimeout(this.socketTimeout);
		}
		var self = this;
		this.socketTimeout = setTimeout(function() {
			try {
				if (self.stream && self.communicator) {
					//self.communicator.disconnect(_);
					this.recorder && this.recorder.close();
					self.communicator = null;
					self.stream.end();
					self.stream = null;
				}
			} catch (e) {
				console.log("SadFsq disconnection error: " + e.stack);
				self.stream.end();
				self.stream = null;
				throw e;
			}
		}, (config.x3sadfsq && config.x3sadfsq.timeout) || 300000);
	},
	_panicRelease: function(_) {
		var dis = false;
		try {
			this.recorder && this.recorder.close();
			this.communicator && this.communicator.disconnect(_);
			dis = true;
			this.stream && this.stream.end();
		} catch (e) {
			try {
				if (!dis && this.stream) {
					this.stream.end();
				}
			} catch (e) {}
		} finally {
			this.stream = null;
			//delete clients[this.printServer];
		}
	}
});