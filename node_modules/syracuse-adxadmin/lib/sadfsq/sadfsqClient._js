"use strict";
var helpers = require('syracuse-core/lib/helpers');
var SadFsqFile = require('syracuse-adxadmin/lib/sadfsq/sadfsqFile').SadFsqFile;
var SadFsqComm = require('syracuse-adxadmin/lib/sadfsq/sadfsqComm').SadFsqComm;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var upath = require('path');
var ufs = require('fs');
var configRecords = {
	dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), "node_modules/syracuse-adxadmin/lib/sadfsq/data")
};
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

function printErrors(sadFile) {
	if (sadFile.err) console.error(sadFile.err);
}

function generateDiag(message) {
	return {
		$diagnoses: [{
			$severity: "error",
			$message: message
		}]
	};
}

var SadPlayer = helpers.defineClass(function(_, json) {
	this.json = json ? json : null;
	// skip RECINFO and COMMENT
	this.step = 2;
	this._nextStep();
}, null, {
	_nextStep: function() {
		if (this.step < this.json.length) {
			this.curStep = this.json[this.step++];
			this.curStep.buf = new Buffer(this.curStep.data, 'hex');
			this.curStep.offset = 0;
		}
	},
	read: function(_, size) {
		if (this.step <= this.json.length) {
			var buf;
			if (this.curStep.type === "READ") {
				if (this.curStep.buf.length >= this.curStep.offset + size) {
					buf = this.curStep.buf.slice(this.curStep.offset, size);
					this.curStep.offset += size;
					if (this.curStep.offset === this.curStep.buf.length) this._nextStep();
					return buf;
				} else { // ask to read with a size > length 
					console.log("ask to read more that length");
					if (this.curStep.offset < this.curStep.buf.length) {
						buf = this.curStep.buf.slice(this.curStep.offset, this.curStep.buf.length);
					}
					this._nextStep();
					buf = Buffer.concat([buf, new Buffer(size - buf.length)]);
				}
			}
			return new Buffer(size);
		}
	},
	write: function(_, buf) {
		if (this.step < this.json.length) {
			if (this.curStep.type === "WRITE") {
				this.curStep.writeBuf = this.curStep.writeBuf || new Buffer([]);
				this.curStep.writeBuf = Buffer.concat([this.curStep.writeBuf, buf]);
				var len = this.curStep.writeBuf.length;
				if (this.curStep.writeBuf.toString('hex') !== this.curStep.buf.slice(0, len).toString('hex')) {
					throw new Error("bytes written not correspond to buffer saved written buffer[" + this.curStep.writeBuf.toString('hex') + "] saved buffer[" + this.curStep.buf.slice(0, len).toString('hex') + "]");
				}
				if (this.curStep.writeBuf.length === this.curStep.buf.length) this._nextStep();
				return;
			}
		}
		throw new Error("step not correspond to WRITE step save file curStep " + JSON.stringify(this.curStep, null, 2));
	}

});


exports.SadFsqClient = helpers.defineClass(function(_, hostname, port, user, password, secured, recOptions) {
	this.hostname = hostname;
	this.port = port;
	this.user = user;
	this.password = password;
	this.recOptions = recOptions ? recOptions : null;
	this.secured = secured;
	this._connect(_);
}, null, {

	/// 
	/// -------------
	/// ## fileOptions :  
	/// Some following functions take in parameters `fileOptions`.  
	/// This chapter describes how these options can be used.  
	/// TODO.

	/// 
	/// -------------
	/// ## open :
	/// ``` javascript
	/// var fd = sadFsqClient.open(_, fileOptions, flags);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.   
	/// * String : The `flags` parameter can be :
	///    * TODO :
	/// 
	/// Returns the file descriptor or a diagnoses.  
	/// 
	open: function(_, options, flags) {
		try {
			var sadFile = new SadFsqFile(options);
			this.communicator.processTOUF(_, sadFile, flags);
			return sadFile.fd;
		} catch (e) {
			return generateDiag(e);
		}
	},

	/// 
	/// -------------
	/// ## close :
	/// ``` javascript
	/// var fd = sadFsqClient.close(_, fd);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Integer : The `fd` parameter is the file descriptor.  
	/// 
	/// Return `null` or a diagnoses  
	/// 
	close: function(_, fd) {
		try {
			var sadFile = new SadFsqFile({
				fd: fd
			});
			this.communicator.processSFER(_, sadFile);
			return;
		} catch (e) {
			return generateDiag(e);
		}
	},
	/// 
	/// -------------
	/// ## getFileInfo :
	/// ``` javascript
	/// var info = sadFsqClient.getFileInfo(_, fileOptions, attributes);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// * Array of String : The `info` parameter is array that contains the attributes name.  
	///	   Attributes can have the following values :  
	///	   * mode :                1 -> file mode  
	///	   * inode :               2 -> inode number  
	///	   * dev_id1 :             3 -> id of device containing a directory entry  
	///	   * dev_id2 :             4 -> id of device if special char/block  
	///	   * nb_links :            5 -> number of links  
	///	   * uid :                 6 -> uid  
	///	   * gid :                 7 -> gid  
	///	   * size :                8 -> file size in bytes  
	///	   * last_access :         9 -> last time of access  
	///	   * last_modification :  10 -> last time of modification  
	///	   * last_status_change : 11 -> last time of file status change  
	///    
	/// Returns the value of the wanted attribute or a diagnoses :  
	/// 
	getFileInfo: function(_, options, info) {
		if (!Array.isArray(info)) throw new Error("INFO parameter must be an array");

		this._connect(_);
		// read content 
		var sadFile = new SadFsqFile(options);
		console.log("InfoLenght: " + info.length);
		for (var i = 0; i < info.length; i++) {
			this.communicator.processTPRM(_, sadFile, info[i]);
			console.log("SADFILE: " + JSON.stringify(sadFile, null, 2));
		}
		printErrors(sadFile);
		return sadFile.fileInfo;

	},
	/// 
	/// -------------
	/// ## readFile :  
	/// ``` javascript  
	/// var info = sadFsqClient.readFile(_, fileOptions, options);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * Object : The `fileOptions` parameter is the object that represent the sadFsq File options.  
	///    eg:  
	/// ``` javascript
	///    var fileOptions = {
	///       folder: "SUPERV",
	///       path: "tmp",
	///       name: "test",
	///       extension: "txt"
	///    };
	/// ```
	///
	/// * Object : The `options` parameter is the object that represent encoding and flag.  
	///    	- encoding : a string that represent encoding ( 'utf-8', .... By default 'utf-8' )
	///     - flag : a string that represent the open mode for the remote file ('r', 'w', ... By default 'r')
	///   eg:  
	/// ``` javascript
	///    var options = {  
	///			encoding:"utf-8",
	///         flag : "r"
	///	   };  
	///
	/// Returns the buffer representent the content of the remote file
	/// 
	/// or a diagnoses :  
	/// ``` javascript
	/// 	{
	///        "$diagnoses": [{
	///           $severity: "error",
	///           $message: "A message",
	///           $stackTrace: "A stack"
	///        }]
	///     }
	/// ```
	/// 

	readFile: function(_, fileOptions, options) {
		try {
			this._connect(_);
			var fd = this.open(_, fileOptions, options.flag ? option.flag : "r");
			// get full size of the file 
			var size = this.getFileInfo(_, fileOptions, ['size']);
			var buffer = new Buffer(size);
			this.read(_, fd, buffer, 0, size, 0);

			this.close(_, fd);
			if (options.encoding) {
				return buffer.toString(options.encoding);
			}
			return buffer;
		} catch (e) {
			return generateDiag(e);
		}

	},
	read: function(_, fd, buffer, offset, length, position) {
		if (!this.stream) throw Error("not connected to the server");
		try {
			var sadFile = new SadFsqFile({
				fd: fd
			});
			this.communicator.processSLFB(_, sadFile, length);
			sadFile.binary.copy(buffer, offset);
			return buffer;
		} catch (e) {
			return generateDiag(e);
		}

	},
	writeFile: function(_, fileOptions, data, options) {
		try {
			this._connect(_);
			var fd = this.open(_, fileOptions, options.flag ? option.flag : "w");
			// get full size of the file 
			var buffer = data instanceof Buffer ? data : new Buffer(data, options.encoding ? options.encoding : "utf-8");
			this.write(_, fd, buffer, 0, size, 0);

			this.close(_, fd);
			if (options.encoding) {
				return buffer.toString(options.encoding);
			}
			return buffer;
		} catch (e) {
			return generateDiag(e);
		}

	},
	write: function(_, fd, buffer, offset, length, position) {
		if (!this.stream) throw Error("not connected to the server");
		try {
			var sadFile = new SadFsqFile({
				fd: fd
			});
			this.communicator.processSEFB(_, sadFile, length);
			sadFile.binary.copy(buffer, offset);
			return buffer;
		} catch (e) {
			return generateDiag(e);
		}

	},

	createProcessus: function(_) {
		this._connect(_);
	},
	deleteFile: function(_, file) {
		this._connect(_);
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		this.communicator.processTEFF(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};
	},
	killProcessus: function(_) { //TODO
		this._connect(_);
	},
	getFilePath: function(_) {
		this._connect(_);
		var sadFile = null;
		if (!file instanceof SadFsqFile) {
			sadFile = new sadfsqFile(fileDescr);
		}
		sadFile = file;
		this.communicator.processTPAT(_, sadFile);
		return {
			status: ok ? ok : true,
			sadFsqFile: sadFile
		};

	},
	_disconnect: function() { // TODO
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	_connect: function(_) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}


		try {
			if (!this.stream) {
				if (this.recOptions && this.recOptions.recMode === "PLAY") {

					this.stream = new SadPlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + this.recOptions.fileName + ".json"), null);

				} else {
					this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
					this.stream.setNoDelay(true);
					if (this.recOptions && this.recOptions.recMode === "REC")
						this.recorder = recordMgr.newRecorder(_, this.stream, this.recOptions, {}, configRecords);
				}
				this.communicator = new SadFsqComm(_, this.stream);
				this.pid = this.communicator.connect(_, this.user, this.password, this.secured);
				this._setSocketTimeout(_);
			} else {
				this._setSocketTimeout(_, true);
			}

		} catch (e) {
			console.error("SadFsqClient connection error : " + e.stack);
			this._panicRelease(_);
			throw e;
		}
	},
	_setSocketTimeout: function(prevent) {
		if (this.socketTimeout && prevent) {
			clearTimeout(this.socketTimeout);
		}
		var self = this;
		this.socketTimeout = setTimeout(function() {
			try {
				if (self.stream && self.communicator) {
					//self.communicator.disconnect(_);
					this.recorder && this.recorder.close();
					self.communicator = null;
					self.stream.end();
					self.stream = null;
				}
			} catch (e) {
				console.log("SadFsq disconnection error: " + e.stack);
				self.stream.end();
				self.stream = null;
				throw e;
			}
		}, (config.x3sadfsq && config.x3sadfsq.timeout) || 300000);
	},
	_panicRelease: function(_) {
		var dis = false;
		try {
			this.recorder && this.recorder.close();
			this.communicator && this.communicator.disconnect(_);
			dis = true;
			this.stream && this.stream.end();
		} catch (e) {
			try {
				if (!dis && this.stream) {
					this.stream.end();
				}
			} catch (e) {}
		} finally {
			this.stream = null;
			//delete clients[this.printServer];
		}
	}
});