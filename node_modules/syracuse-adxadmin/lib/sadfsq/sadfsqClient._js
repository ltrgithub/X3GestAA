"use strict";
var helpers = require('syracuse-core/lib/helpers');
var SadFsqFile = require('syracuse-adxadmin/lib/sadfsq/sadfsqFile').SadFsqFile;
var sadFsqComm = require('syracuse-adxadmin/lib/sadfsq/sadfsqComm');
var SadFsqComm = sadFsqComm.SadFsqComm;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var upath = require('path');
var ufs = require('fs');
var configRecords = {
	dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), "node_modules/syracuse-adxadmin/lib/sadfsq/data")
};
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

var SadPlayer = helpers.defineClass(function(_, json) {
	this.json = json ? json : null;
	// skip RECINFO and COMMENT
	this.step = 2;
	this._nextStep();
}, null, {
	_nextStep: function() {
		if (this.step < this.json.length) {
			this.curStep = this.json[this.step++];
			this.curStep.buf = new Buffer(this.curStep.data, 'hex');
			this.curStep.offset = 0;
		}
	},
	end: function() {
		// nothin
	},
	read: function(_, size) {
		if (this.step <= this.json.length) {
			var buf;
			if (this.curStep.type === "READ") {
				if (this.curStep.buf.length >= this.curStep.offset + size) {
					buf = this.curStep.buf.slice(this.curStep.offset, size);
					this.curStep.offset += size;
					if (this.curStep.offset === this.curStep.buf.length) this._nextStep();
					return buf;
				} else { // ask to read with a size > length
					if (this.curStep.offset < this.curStep.buf.length) {
						buf = this.curStep.buf.slice(this.curStep.offset, this.curStep.buf.length);
					}
					this._nextStep();
					buf = Buffer.concat([buf, new Buffer(size - buf.length)]);
				}
			}
			return new Buffer(size);
		}
	},
	write: function(_, buf) {
		if (this.step < this.json.length) {
			if (this.curStep.type === "WRITE") {
				this.curStep.writeBuf = this.curStep.writeBuf || new Buffer([]);
				this.curStep.writeBuf = Buffer.concat([this.curStep.writeBuf, buf]);
				var len = this.curStep.writeBuf.length;
				if (this.curStep.writeBuf.toString('hex') !== this.curStep.buf.slice(0, len).toString('hex')) {
					throw new Error("bytes written not correspond to buffer saved written buffer[" + this.curStep.writeBuf.toString('hex') + "] saved buffer[" + this.curStep.buf.slice(0, len).toString('hex') + "]");
				}
				if (this.curStep.writeBuf.length === this.curStep.buf.length) this._nextStep();
				return;
			}
		}
		throw new Error("step not correspond to WRITE step save file curStep " + JSON.stringify(this.curStep, null, 2));
	}

});


exports.SadFsqClient = helpers.defineClass(function(_, hostname, port, user, password, secured, recOptions) {
	this.hostname = hostname;
	this.port = port;
	this.user = user;
	this.password = password;
	this.recOptions = recOptions ? recOptions : null;
	this.secured = secured;
	this._connect(_);
	this.fdsOpen = {}; // list of opened fd
}, null, {

	/// 
	/// -------------
	/// ## fileOptions :  
	/// Some following functions take in parameters `fileOptions`.  
	/// This chapter describes how these options can be used.  
	/// TODO.

	/// 
	/// -------------
	/// ## open :
	/// ``` javascript
	/// var fd = sadfs.open(_, fileOptions, flags);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See `fileOptions`.   
	/// * `flags` can be :
	///    * TODO :
	/// 
	/// Returns the file descriptor or a diagnoses.  
	/// 
	open: function(_, options, flags) {
		var sadFile = new SadFsqFile(options);
		var fd = this.communicator.processOUF(_, sadFile, flags);
		var fuuid = helpers.uuid.generate();
		this.fdsOpen[fuuid] = {
			sadFile: sadFile,
			fd: fd,
			offset: 0,
			mode: flags
		};
		this.fdsOpen[fuuid].size = this.fstat(_, fuuid, ["size"]).size;
		return fuuid;
	},

	/// 
	/// -------------
	/// ## close :
	/// ``` javascript
	/// var fd = sadfs.close(_, fd);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fd` is an integer that represents the file descriptor.  
	/// 
	/// Return `null` or a diagnoses  
	/// 
	close: function(_, fd) {
		var opened = this.fdsOpen[fd];
		if (opened) {
			this.communicator.processFER(_, opened.fd);
			delete this.fdsOpen[fd];
			return;
		} else {
			throw new Error("can't close file, fd is not valid");
		}
	},

	/// 
	/// -------------
	/// ## stat :
	/// ``` javascript
	/// var stats = sadfs.stat(_, fileOptions, attributes);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// * `attributes` is an array of strings that contains the attributes name.  
	///    Attributes can have the following values :  
	///    mode, ino, dev, rdev, nlink, uid, gid, size, atime, mtime, ctime.  
	///
	/// Returns a javascript object that contains attributes keys and values.  
	/// ``` json
	///    { 
	///       mode: 33188, // file mode  
	///       ino: 48064969, // inode number  
	///       dev: 0, // id of device containing a directory entry  
	///       rdev: 2114, // id of device if special char/block  
	///       nlink: 1, // number of links  
	///       uid: 85, // uid  
	///       gid: 100, // gid  
	///       size: 527, // file size in bytes  
	///       atime: Mon, 10 Oct 2011 23:24:11 GMT, // last time of access  
	///       mtime: Mon, 10 Oct 2011 23:24:11 GMT, // last time of modification  
	///       ctime: Mon, 10 Oct 2011 23:24:11 GMT // last time of file status change  
	///    }
	/// ``` 
	/// 
	stat: function(_, options, attributes) {
		if (attributes && !Array.isArray(attributes)) throw new Error("INFO parameter must be an array");
		var sadFile = new SadFsqFile(options);
		return this._getInfo(_, sadFile, attributes);
	},

	/// 
	/// -------------
	/// ## fstat :
	/// ``` javascript
	/// var stats = sadfs.fstat(_, fd, attributes);  
	/// ```
	/// This function is the same that `stat` but take a file descriptor as first parameter.  
	/// 
	fstat: function(_, fd, attributes) {
		if (attributes && !Array.isArray(attributes)) throw new Error("INFO parameter must be an array");
		var sadFile = this.fdsOpen[fd].sadFile;
		return this._getInfo(_, sadFile, attributes);
	},

	_getInfo: function(_, sadFile, attributes) {
		this._connect(_);
		var fileInfo = {};
		if (!attributes) {
			attributes = sadFsqComm.fileAttributes.slice(1);
		}
		for (var i = 0; i < attributes.length; i++) {
			fileInfo[attributes[i]] = this.communicator.processPRM(_, sadFile, attributes[i]);

		}
		return fileInfo;
	},

	/// 
	/// -------------
	/// ## path :
	/// ``` javascript
	/// var path = sadfs.path(_, fileOptions);  
	/// ```
	/// Retrieve the full path of the remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See `fileOptions`.
	///
	/// Returns the the full path.  
	///
	path: function(_, options) {
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		var fullPath = this.communicator.processPAT(_, sadFile);
		return fullPath;
	},

	/// 
	/// -------------
	/// ## readFile :  
	/// ``` javascript  
	/// var buf = sadfs.readFile(_, fileOptions, options);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See `fileOptions`.  
	///
	/// * `options` is the object that represent encoding and flag.  
	///     * encoding : a string that represent encoding ( 'utf-8', .... By default 'utf-8' )
	///     * flag : a string that represent the open mode for the remote file. See `Flags chapter`. 
	///     By default 'r'.  
	///   eg:  
	/// ``` javascript
	///    var options = {  
	///         encoding:"utf-8",
	///         flag : "r"
	///    };  
	/// ```
	///
	/// Returns the buffer that represents the content of the remote file.  
	/// 
	readFile: function(_, fileOptions, options) {
		this._connect(_);
		var fd = this.open(_, fileOptions, options.flag ? options.flag : "r");
		// get full size of the file 
		var buffer = new Buffer(this.fdsOpen[fd].size);
		this.read(_, fd, buffer, 0, this.fdsOpen[fd].size);

		this.close(_, fd);
		if (options.encoding) {
			return buffer.toString(options.encoding);
		}
		return buffer;
	},

	/// 
	/// -------------
	/// ## read :  
	/// ``` javascript  
	/// var buf = sadfs.read(_, fd, buffer, offset, length, position);  
	/// ```
	/// Read data from the file specified by fd. 
	///
	/// * `buffer` is the buffer that the data will be written to.  
	///
	/// * `offset` is the offset in the buffer to start writing at.  
	///
	/// * `length` is an integer specifying the number of bytes to read.  
	///
	/// * `position` is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.  
	/// 
	/// Returns the size of red bytes.  
	///
	read: function(_, fd, buffer, offset, length, position) {
		this._connect(_);
		var fdOpened = this.fdsOpen[fd];
		var pos = position && position > 0 ? position : fdOpened.offset;

		var lenToRead = pos + length > fdOpened.size ? fdOpened.size - pos : length;
		if (lenToRead > 0) {
			if (position) {
				this.seek(_, fd, 0, position);
			}
			var buf = this.communicator.processLBF(_, fdOpened.fd, lenToRead);
			buf.copy(buffer, offset);
			fdOpened.offset += buf.length;
			return buf.length; // return size of bytes read
		} else {
			return 0;
		}
	},

	/// 
	/// -------------
	/// ## getPosition :  
	/// ``` javascript  
	/// var position = sadfs.getPosition(_, fd);  
	/// ```
	/// Get the cursor position in the file specified by fd. 
	///
	getPosition: function(_, fd) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			return this.communicator.processPOS(_, opened.fd);
		} else {
			throw new Error("File must be opened before get position.");
		}
	},

	/// 
	/// -------------
	/// ## seek :  
	/// ``` javascript  
	/// var position = sadfs.seek(_, fd, cursor, offset, [strict]);  
	/// ```
	/// Change the cursor position in the file specified by fd. 
	/// 
	/// * `cursor` is the base of the move. (0: BOF, 1: Current position, 2: EOF)  
	///
	/// * `offset` is a number of bytes to ignore until the new position.  
	/// 
	/// * `strict` define if the position is allowed to be out of bounds. `true` by default.  
	///
	seek: function(_, fd, cursor, offset, strict) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			if (strict == null) strict = true;
			if (strict) {
				switch (cursor) {
					case 0:
						if (offset >= opened.size) throw new Error("Offset [" + offset + "] is bigger than file size [" + opened.size + "].");
						break;
					case 1:
						if (offset + opened.offset > opened.size)
							throw new Error("Offset added to current position is bigger than file size.");
						break;
					case 2:
						if (offset > 0) throw new Error("Offset can't be positive with EOF cursor.");
						break;
					default:
						throw new Error("Cursor parameter can be 0 for 'BOF', 1 for 'Current possition' or 2 for 'EOF'.");
				}
			}
			this.communicator.processDPL(_, opened.fd, cursor, offset);
			opened.offset += offset;
		} else {
			throw new Error("File must be opened before seek.");
		}
	},

	writeFile: function(_, fileOptions, data, options) {
		this._connect(_);
		var fd = this.open(_, fileOptions, options.flag ? options.flag : "w");
		// get full size of the file 
		var buffer = data instanceof Buffer ? data : new Buffer(data, options.encoding ? options.encoding : "utf-8");
		this.write(_, fd, buffer, 0, buffer.length, 0);
		this.close(_, fd);
	},
	write: function(_, fd, buffer, offset, length, position) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		this.communicator.processEBF(_, opened.fd, buffer);
	},

	unlink: function(_, options) {
		this._connect(_);
		var sadFile = new SadFsqFile(options);
		this.communicator.processEFF(_, sadFile);
		return;
	},

	flush: function(_, fd) {
		this._connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			this.communicator.processVID(_, opened.fd);
		} else {
			throw new Error("File must be opened before flush.");
		}
	},

	createProcessus: function(_) {
		this._connect(_);
	},

	killProcessus: function(_) { //TODO
		this._connect(_);
	},

	disconnect: function() { // TODO
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	_connect: function(_) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}


		try {
			if (!this.stream) {
				if (this.recOptions && this.recOptions.recMode === "PLAY") {

					this.stream = new SadPlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + this.recOptions.fileName), null);

				} else {
					this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
					this.stream.setNoDelay(true);
					if (this.recOptions && this.recOptions.recMode === "REC") {
						this.recorder = recordMgr.newRecorder(_, this.stream, this.recOptions, {}, configRecords);

					}
				}
				this.communicator = new SadFsqComm(_, this.stream);
				this.pid = this.communicator.connect(_, this.user, this.password, this.secured);
				this._setSocketTimeout(_);
			} else {
				this._setSocketTimeout(_, true);
			}

		} catch (e) {
			console.error("SadFsqClient connection error : " + e.stack);
			this._panicRelease(_);
			throw e;
		}
	},
	_setSocketTimeout: function(prevent) {
		if (this.socketTimeout && prevent) {
			clearTimeout(this.socketTimeout);
		}
		var self = this;
		this.socketTimeout = setTimeout(function() {
			try {
				if (self.stream && self.communicator) {
					//self.communicator.disconnect(_);
					this.recorder && this.recorder.close();
					self.communicator = null;
					self.stream.end();
					self.stream = null;
				}
			} catch (e) {
				console.log("SadFsq disconnection error: " + e.stack);
				self.stream.end();
				self.stream = null;
				throw e;
			}
		}, (config.x3sadfsq && config.x3sadfsq.timeout) || 10000);
	},
	_panicRelease: function(_) {
		var dis = false;
		try {
			this.recorder && this.recorder.close();
			this.communicator && this.communicator.disconnect(_);
			dis = true;
			this.stream && this.stream.end();
		} catch (e) {
			try {
				if (!dis && this.stream) {
					this.stream.end();
				}
			} catch (e) {}
		} finally {
			this.stream = null;
			//delete clients[this.printServer];
		}
	}
});