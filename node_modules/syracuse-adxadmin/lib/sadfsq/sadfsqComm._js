"use strict";

var helpers = require('syracuse-core/lib/helpers');

var tracer = console.log;

var T_INI = 1; //initializatio of server
var T_OUF = 2; //open file
var T_OUS = 3; //open system file
var T_OUP = 4; //open pip
var T_ERR = 6; //get error message
var T_PRM = 7; //get access right
var T_PAT = 8; //get absolute path
var T_EFF = 10; //delete file
var T_KUS = 15; //stop processus

function hasError(buffer) {
	return buffer[0] & 0x80 !== 0;
}

function getBuffers(order, sadFile, options) {
	var buffers = {};
	switch (order) {
		case T_INI: //initializatio of server
		case T_OUF: //open file
		case T_OUS: //open system file
		case T_OUP: //open pip
		case T_ERR: //get error message
		case T_PRM: //get access right
		case T_PAT: //get absolute path
		case T_EFF: //delete file
			break;
		case T_KUS: //stop processus
			break;
		default:
			throw new Error("bad order");
	}
	// init
	buffers.init = {
		descr: "Init buffer",
		buf: function() {
			return new Buffer([0x00]);
		}
	};
	// file descr
	buffers.fileDescr = {
		descr: "File descriptor",
		buf: function() {
			return new Buffer(sadFile.fileDescriber, 'utf-8');
		}
	};
	// len util 
	buffers.lenUtil = {
		descr: "Length to follow",
		buf: function() {
			var lenUtil = new Buffer(2);
			lenUtil.writeInt16BE(buffers.fileDescr.buf().length + 6, 0);
			return lenUtil;
		}
	};

	// order
	buffers.order = {
		descr: "Order [" + order + "]",
		buf: function() {
			return new Buffer([order]);
		}
	};

	// file descr buffer length + 2

	buffers.fileDescrBufLen = {
		descr: "File descriptor size",
		buf: function() {
			var fileDescrBufLen = new Buffer(2);
			fileDescrBufLen.writeInt16BE(buffers.fileDescr.buf().length + 2, 0);
			return fileDescrBufLen;
		}
	};

	// file descr length
	buffers.fileDescrLen = {
		descr: "Nb char of file descriptor",
		buf: function() {
			var fileDescrLen = new Buffer(2);
			fileDescrLen.writeInt16BE(sadFile.fileDescriber.length, 0);
			return fileDescrLen;
		}
	};


	return buffers;

}

function bufferConcat(table) {
	var buf = new Buffer([]);
	table.map(function(item, i) {
		var b = item.buf();
		tracer && tracer("Buffer[" + i + "] (" + item.descr + ") =" + b.toString('hex'));
		buf = Buffer.concat([buf, b]);
	});
	return buf;
}

exports.SadFsqComm = helpers.defineClass(function(_, stream) {
	this.stream = stream;
}, null, {
	// write buffer in remote file
	_getBufLaunch: function(_) { //TODO
	},
	processLaunch: function(_) { //TODO
	},

	_getBufSEBF: function(_) { //TODO
	},
	processSEBF: function(_) { //TODO

	},

	// close remote open file
	_getBufSFER: function(_) { // TODO
	},
	processSFER: function(_) { // TODO
	},

	// read all buffer from remote file
	_getBufSLBF: function(_, sadFile) { // TODO
	},
	processSLBF: function(_, sadFile) { // TODO
	},

	// 
	_getBufTOUS: function(_) { // TODO 
	},
	processTOUS: function(_) { // TODO 
	},

	// delete file
	_getBufTEFF: function(sadFile) { // TODO 
		var buffers = getBuffers(T_EFF, sadFile);
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.fileDescrBufLen, buffers.fileDescrLen, buffers.fileDescr]);


	},
	processTEFF: function(_, sadFile) { // TODO 




	},

	// kill remote processus
	_getBufTKUS: function(_) { // TODO
	},
	processTKUS: function(_) { // TODO
	},

	// open remote file 
	_getBufTOUF: function(sadFile, openMod) {
		var writeBuf = this._getBufBase(T_OUF, sadFile);

		var openModBuff = new Buffer(openMod, 'utf-8');
		writeBuf = Buffer.concat([writeBuf, new Buffer(2).writeInt16BE(openModBuff.length + 2, 0)]); // openMod in byte length + 2
		writeBuf = Buffer.concat([writeBuf, new Buffer(2).writeInt16BE(openMod.length, 0)]); // openMod length
		writeBuf = Buffer.concat([writeBuf, openModBuff]); // openMod byte
		writeBuf = Buffer.concat([0, writeBuf.length, writeBuf]);
		return writeBuf;

	},
	processTOUF: function(_, sadFile, openMod) { //TODO
		// write open order
		this.stream.write(_, _getBufTOUF(sadFile));
		// read result 
		var buf = this.stream.read(_, 4);
		if (hasError(buf)) {
			//get Error
			sadFile.err = 256 - buf.readUInt8();
		} else {
			sadFile.fileNum = buf.readInt8();
		}

	},

	// create remote process
	_getBufTOUP: function(_) { //TODO
	},
	processTOUP: function(_) { //TODO
	},

	// get remote file path
	_getBufTPAT: function(_) { //TODO
	},
	processTPAT: function(_) { //TODO
	},
	_getBufBase: function(order, sadFile) {
		var offset = 0;
		var fileDescriberBuff = new Buffer(sadFile.fileDescriber, 'utf-8');

		//0 + len util 
		var lenUtil = new Buffer(2);
		lenUtil.writeInt16BE(fileDescriberBuff.length + 6, 0);
		var writeBuf = Buffer.concat([new Buffer([0x00]), lenUtil]);
		// order
		writeBuf = Buffer.concat([writeBuf, new Buffer([order])]);

		var fdbufflen = new Buffer(2);
		fdbufflen.writeInt16BE(fileDescriberBuff.length + 2, 0);
		writeBuf = Buffer.concat([writeBuf, fdbufflen]); // file name in byte length + short length
		var fdlen = new Buffer(2);
		fdlen.writeInt16BE(sadFile.fileDescriber.length + 2, 0);
		writeBuf = Buffer.concat([writeBuf, fdlen]); // nombre of character file name in short
		writeBuf = Buffer.concat([writeBuf, fileDescriberBuff]); // nombre of character file name in short
		return writeBuf;

	},
	// get file information
	_getBufTPRM: function(sadFile, option) { //TODO
		if (option !== "size" && option !== "stamp") {
			throw new Error("not valid option for get Info . TODO");
		}
		var offset = 0;
		var fileDescriberBuff = new Buffer(sadFile.fileDescriber, 'utf-8');

		// len util 
		var lenUtilBuf = new Buffer(2);
		lenUtilBuf.writeInt16BE(fileDescriberBuff.length + 6, 0);


		// order
		var orderBuf = new Buffer([T_PRM]);

		// option size or stamp 
		var optionBuf = new Buffer([option === "size" ? 8 : 10]);

		//file descr buff len + 2
		var fdbufflen = new Buffer(2);
		fdbufflen.writeInt16BE(fileDescriberBuff.length + 2, 0);

		// file descr len 
		var fdlen = new Buffer(2);
		fdlen.writeInt16BE(sadFile.fileDescriber.length, 0);

		return Buffer.concat([new Buffer([0x00]), lenUtilBuf, orderBuf, optionBuf, fdbufflen, fdlen, fileDescriberBuff]);

	},
	processTPRM: function(_, sadFile) { //TODO
	}

});