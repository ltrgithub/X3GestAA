"use strict";

var helpers = require('syracuse-core/lib/helpers');

var tracer = console.log;
var MAX_BYTE_TO_WRITE = 1024;

var T_INI = {
	descr: "T_INI",
	id: 1,
	len: 6,
	lenUtil: ["canonical"]
}; //initializatio of server
var T_OUF = {
	descr: "T_OUF",
	id: 2,
	len: 9,
	lenUtil: ["canonical", "openMod"]
}; //open file
var S_LBF = {
	descr: "S_LBF",
	id: 5,
	len: 5,
	lenUtil: []
}; // read
var S_EBF = {
	descr: "S_EBF",
	id: 8,
	len: 5,
	lenUtil: []
}; // write 
var T_OUP = {
	descr: "T_OUP",
	id: 4,
	len: 9,
	lenUtil: ["canonical", "openMod"]
}; //open pip
var S_FER = {
	descr: "S_FER",
	id: 1,
	len: 1,
	lenUtil: []
}; // close file
var T_ERR = {
	descr: "T_ERR",
	id: 6,
	len: 5,
	lenUtil: ["canonical"]
}; //get error message
var T_PRM = {
	descr: "T_PRM",
	id: 7,
	len: 6,
	lenUtil: ["canonical"]
}; //get access right
var T_PAT = {
	descr: "T_PAT",
	id: 8,
	len: 5,
	lenUtil: ["canonical"]
}; //get absolute path
var T_EFF = {
	descr: "T_EFF",
	id: 10,
	len: 5,
	lenUtil: ["canonical"]
}; //delete file
var T_KUS = {
	descr: "T_KUS",
	id: 15,
	len: 6,
	lenUtil: []
}; //stop processus

var fileAttributes = [
	null,
	"mode",
	"inode",
	"dev_id1",
	"dev_id2",
	"nb_links",
	"uid",
	"gid",
	"size",
	"last_access",
	"last_modification",
	"last_status_change"
];

function getBuffers(order, params) {
	tracer && tracer("\n### Create buffer for order: " + order.descr + " ###");
	var buffers = {};
	var sadFile = params.sadFile;
	buffers.infoId = {
		descr: "information id",
		buf: function() {
			var buf = new Buffer(1);
			buf.writeInt8(params.infoId, 0);
			return buf;
		}
	};

	buffers.lenToRead = {
		descr: "length of bytes to read",
		buf: function() {
			var buf = new Buffer(4);
			buf.writeInt32BE(params.lenToRead, 0);
			return buf;
		}
	};
	buffers.lenToWrite = {
		descr: "length of bytes to write",
		buf: function() {
			var buf = new Buffer(4);
			var len = params.lenToWrite > sadFile.binary.length ? sadFile.binary.length : params.lenToWrite;
			buf.writeInt32BE(len, 0);
			return buf;
		}
	};
	buffers.binary = {
		descr: "binary to write",
		buf: function() {
			var len = params.lenToWrite > sadFile.binary.length ? sadFile.binary.length : params.lenToWrite;
			var buf = sadFile.binary.slice(0, len);
			sadFile.binary = sadFile.binary.slice(len + 1);
			return buf;
		}
	};

	// init
	buffers.init = {
		descr: "Init buffer",
		buf: function() {
			return new Buffer([0x00]);
		}
	};
	// canonical
	buffers.canonical = {
		descr: "Canonical name",
		buf: function() {
			return new Buffer(sadFile.canonical, 'utf-8');
		}
	};

	// order
	buffers.order = {
		descr: "Order [" + order.descr + "]",
		buf: function() {
			return new Buffer([order.id]);
		}
	};
	buffers.openMod = {
		descr: "OpenMod Buffer",
		buf: function() {
			return new Buffer(params.openMod ? params.openMod : "", "utf-8");
		}

	};

	buffers.openModLen = {
		descr: "OpenMod size",
		buf: function() {
			var openModLen = new Buffer(2);
			openModLen.writeInt16BE((params.openMod ? params.openMod.length : 0), 0);
			return openModLen;
		}
	};

	buffers.openModBufLen = {
		descr: "OpenMod buffer size",
		buf: function() {
			var openModBufLen = new Buffer(2);
			openModBufLen.writeInt16BE(buffers.openMod.buf().length + 2, 0);
			return openModBufLen;
		}

	};


	// file descr buffer length + 2
	buffers.canonicalBufLen = {
		descr: "File descriptor size",
		buf: function() {
			var canonicalBufLen = new Buffer(2);
			canonicalBufLen.writeInt16BE(buffers.canonical.buf().length + 2, 0);
			return canonicalBufLen;
		}
	};

	// canonical (nb character) length
	buffers.canonicalLen = {
		descr: "Nb char of file descriptor",
		buf: function() {
			var canonicalLen = new Buffer(2);
			canonicalLen.writeInt16BE(sadFile.canonical.length, 0);
			return canonicalLen;
		}
	};
	// file descriptor 
	buffers.fd = {
		descr: "remote file descriptor (identification of remote file)",
		buf: function() {
			return new Buffer([sadFile.fd]);
		}
	};
	buffers.signal = { // kill signal (1,..,9)
		descr: " signal send to process ",
		buf: function() {
			return new Buffer([params.signal]);
		}
	};


	buffers.pid = { // use fd
		descr: "processus pid ",
		buf: function() {
			var buf = new Buffer(4);
			buf.writeInt32BE(sadFile.pid, 0);
			return buf;
		}
	};

	// len util 
	buffers.lenUtil = {
		descr: "Length to follow",
		buf: function() {
			var lenUtil = new Buffer(2);
			var size = 0;
			for (var i in order.lenUtil) {
				var item = buffers[order.lenUtil[i]];
				size += item.buf().length;
			}
			lenUtil.writeInt16BE(size + order.len, 0);
			return lenUtil;
		}
	};

	return buffers;

}

function bufferConcat(table) {
	var buf = new Buffer([]);
	table.map(function(item, i) {
		if (item.buf) {
			var b = item.buf();
			traceBuffer(i, item.descr, b);
			buf = Buffer.concat([buf, b]);
		} else {
			tracer && tracer("no method buf for item ");
		}
	});
	tracer && tracer(buf);
	return buf;
}

function traceBuffer(id, descr, buf) {
	tracer && tracer("Buffer[" + id + "] (" + descr + ") = " + buf.toString('hex') + " [Length: " + buf.length + "]");
}


var SAD_ID = 6;
var SAD_SECURE_ID = 106;

/// !doc
/// 
/// # SadFsqComm module
/// 
/// DO NOT USE THIS MODULE DIRECTLY !!!  
/// This documentation is only provided to understand the protocol layer !  
/// 
/// To interface with adxadmin server, please refer to [SadFsqClient module API](https://github.com/Sage-ERP-X3/Syracuse/blob/master/node_modules/syracuse-adxadmin/lib/sadfsq/sadfsqClient.md "SadFsqClient module API").
/// 
/// ---
exports.SadFsqComm = helpers.defineClass(function(_, stream) {
	this.stream = stream;
}, null, {
	_hasError: function(buffer) {
		return (buffer[0] & 0x80) !== 0;
	},

	_NoLogicalError: function(_, buf, sadFile) {
		if (this._hasError(buf)) {
			this.processTERR(_, sadFile);
			throw new Error(sadFile.err);
		}
		return true;
	},
	_checkStream: function() {
		if (!this.stream) throw new Error("stream is null or undefined");
	},
	/// # Connection / Disconnection
	/// 
	/// This chapter describes connection and disconnection sequences with Safe X3 AdxAdmin server component.
	/// 
	/// 
	/// ##**Connection**
	/// 
	/// Opening classic TCP/IP socket on 'server:port' with AdxAdmin server.  
	/// 
	///   - **First step** : open session.  
	///   - Request :  
	///      - **1-byte** : The service ID : 6 by default and 106 for secure mode.  
	///      - **1-byte** : The length to follow.  
	///      - **1-byte** : The user string length.  
	///      - **N-bytes** : The user.
	///      - **1-byte** : The user string length.  
	///      - **N-bytes** : The user.  
	///      - **1-byte** : The password string length.  
	///      - **N-bytes** : The password
	///   - Reply :  
	///      - **4-bytes** : (integer LE) The adonix process PID or -1 if an error occurred.  
	///      - **[1-byte]** : Only if -1 : The message length.  
	///      - **[4-bytes]** : Only if -1 : (integer LE) The adonix error code.  
	///      - **[N-bytes]** : Only if -1 : The error message.  
	/// 
	/// ---
	/// 
	_writeBufConnect: function(params) { //TODO
		tracer && tracer("\n### Create buffer for CONNECTION ###");
		var bufServiceId = new Buffer(1);
		var serviceId = params.secured ? SAD_SECURE_ID : SAD_ID;
		bufServiceId.writeInt8(serviceId, 0);

		var bufUser = new Buffer(params.user, "utf-8");
		var bufPass = new Buffer(params.password, "utf-8");
		var bufLenUser = new Buffer(1);
		bufLenUser.writeInt8(bufUser.length, 0);
		var bufLenPass = new Buffer(1);
		bufLenPass.writeInt8(bufPass.length, 0);
		var bufLenUtil = new Buffer(1);
		bufLenUtil.writeInt8(bufUser.length * 2 + bufPass.length + 3, 0);

		tracer && tracer("Buffer[0] (Service ID) " + bufServiceId.toString("hex"));
		tracer && tracer("Buffer[1] (Length to follow) " + bufLenUtil.toString("hex"));
		tracer && tracer("Buffer[2] (User length) " + bufLenUser.toString("hex"));
		tracer && tracer("Buffer[3] (User) " + bufUser.toString("hex"));
		tracer && tracer("Buffer[4] (User length) " + bufLenUser.toString("hex"));
		tracer && tracer("Buffer[5] (User) " + bufUser.toString("hex"));
		tracer && tracer("Buffer[6] (Password length) " + bufLenPass.toString("hex"));
		tracer && tracer("Buffer[7] (Password) " + bufPass.toString("hex"));
		var buf = Buffer.concat([bufServiceId, bufLenUtil, bufLenUser, bufUser, bufLenUser, bufUser, bufLenPass, bufPass]);
		tracer && tracer(buf);
		return buf;
	},
	connect: function(_, user, password, secured) {

		this._checkStream();
		this.stream.write(_, this._writeBufConnect({
			secured: secured,
			user: user,
			password: password
		}));

		tracer && tracer("\n### Read buffer for order: CONNECT ###");
		var buf = this.stream.read(_, 4);
		var pid = buf.readInt32BE(0);
		if (pid > -1) {
			traceBuffer(0, "PID", buf);
			tracer && tracer("Adonix process pid: " + pid);
			return pid;
		} else {
			buf = this.stream.read(_, 5);
			traceBuffer(1, "Message length (1) and error code (4)", buf);
			var msgLen = buf.readInt8(0);
			var errCode = buf.readInt32BE(1);
			buf = this.stream.read(_, msgLen);
			traceBuffer(2, "Error message", buf);
			var msg = buf.toString('utf-8');
			throw new Error("Connection failed: " + errCode + " : " + msg);
		}
	},



	/// #Remote files management
	/// 
	/// This chapter describes different sequences that allow to manage remote files with AdxAdmin server component.  
	/// 
	/// 

	/// ##**Action T_OUF**
	/// 
	/// Open remote file.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 2. 
	///       - **2-bytes** : (short) The descriptor buffer length + 2. 
	///       - **2-bytes** : (short) The descriptor characters count. 
	///       - **N-bytes** : The descriptor string (utf-8). 
	///       - **2-bytes** : (short) The open mode buffer length + 2. 
	///       - **2-bytes** : (short) The open mode characters count. 
	///       - **N-bytes** : The open mode string (utf-8). 
	///    - Reply :  
	///       - **1-bytes** : Identify an error or file number.  
	/// 
	/// ---
	/// 
	_writeBufTOUF: function(sadFile, openMod) {
		var buffers = getBuffers(T_OUF, {
			sadFile: sadFile,
			openMod: openMod
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical, buffers.openModBufLen, buffers.openModLen, buffers.openMod]);
	},
	_readBufTOUF: function(buf, sadFile) {
		// get file num 
		traceBuffer(0, "File number", buf);
		sadFile.fd = buf.readInt8(0);
	},
	_processTOU: function(_, suf, sadFile, openMod) {
		this._checkStream();
		var suffix = suf;
		// write open order
		this.stream.write(_, this["_writeBuf" + suffix].apply(this, [sadFile, openMod]));
		// read result 
		tracer && tracer("\n### Read buffer for order: " + suf + " ###");
		var buf = this.stream.read(_, 1);
		if (this._NoLogicalError(_, buf, sadFile)) {
			this["_readBuf" + suffix].apply(null, [buf, sadFile]);
		} else {
			traceBuffer(0, "Error code", buf);
		}
	},
	processTOUF: function(_, sadFile, openMod) { //TODO
		this._processTOU(_, "TOUF", sadFile, openMod);
	},

	_writeBufSVID: function(sadFile, openMod) {
		var buffers = getBuffers(T_OUF, {
			sadFile: sadFile,
			openMod: openMod
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical, buffers.openModBufLen, buffers.openModLen, buffers.openMod]);
	},
	_readBufSVID: function(buf, sadFile) {
		// get file num 
		traceBuffer(0, "File number", buf);
		sadFile.fd = buf.readInt8(0);
	},

	processSVID: function(_, sadFile, openMod) { //TODO
		this._processTOU(_, "TOUF", sadFile, openMod);
	},

	/// ##**Action S_FER**
	/// 
	/// Close remote opened file.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 1. 
	///    - Reply :  
	///       - **1-byte** : The error code.  
	/// 
	/// ---
	/// 
	_writeBufSFER: function(sadFile) {
		var buffers = getBuffers(S_FER, {
			sadFile: sadFile,
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order]);
	},

	processSFER: function(_, sadFile) { // TODO
		this._checkStream();
		this.stream.write(_, this._writeBufSFER(sadFile));
		tracer && tracer("\n### Read buffer for order: S_FER ###");
		var buf = this.stream.read(_, 1);
		traceBuffer(0, "Error code", buf);
		if (this._NoLogicalError(_, buf, sadFile)) {
			// nothin
		}
	},

	/// ##**Action T_PAT**
	/// 
	/// Get remote file path.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 8. 
	///       - **2-bytes** : (short) The descriptor buffer length + 2. 
	///       - **2-bytes** : (short) The descriptor characters count. 
	///       - **N-bytes** : The descriptor string (utf-8). 
	///    - Reply :  
	///       - **X-bytes** : TODO.  
	/// 
	/// ---
	/// 
	_writeBufTPAT: function(sadFile) { // TODO 
		var buffers = getBuffers(T_PAT, {
			sadFile: sadFile
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical]);
	},
	_readBufTPAT: function(buf, id, sadFile) {
		switch (id) {
			case 0:
				traceBuffer(id + 1, "Length of path", buf);
				return buf.readInt8(0);
			case 1:
				traceBuffer(id + 1, "Path", buf);
				sadFile.path = buf.toString("utf-8");
				break;
			default:
				throw new Error("Can't read, reply not expected");
		}
	},
	processTPAT: function(_, sadFile) { //TODO;
		this._checkStream();
		this.stream.write(_, this._writeBufTPAT(sadFile));
		tracer && tracer("\n### Read buffer for order: T_PAT ###");
		var buf = this.stream.read(_, 1);
		traceBuffer(0, "Error code", buf);
		if (this._NoLogicalError(_, buf, sadFile))
			this._readBufTPAT(this.stream.read(_, this._readBufTPAT(this.stream.read(_, 1), sadFile)), sadFile);

	},

	/// ##**Action T_PRM**
	/// 
	/// Get file information.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00.  
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 7.  
	///       - **1-byte** : info id. Can be 'size' (8) or 'stamp' (10).  
	///       - **2-bytes** : (short) The descriptor buffer length + 2.  
	///       - **2-bytes** : (short) The descriptor characters count.  
	///       - **N-bytes** : The descriptor string (utf-8).  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received or the value of the info Id (serialized in unsigned integer).  
	///       - **4-byte** : Value of the info Id (serialized in integer Big Endian).  
	/// 
	/// ---
	/// 
	_writeBufTPRM: function(sadFile, info) { //TODO
		var fileInfo = fileAttributes.indexOf(info);
		if (info == null || fileInfo === -1) {
			console.error("The file attribute '" + info + "' is not allowed.");
			throw new Error("The file attribute '" + info + "' is not allowed.");
		}
		var buffers = getBuffers(T_PRM, {
			sadFile: sadFile,
			infoId: fileInfo
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.infoId, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical]);

	},
	_readBufTPRM: function(buf, sadFile, info) {
		traceBuffer(1, info, buf);
		sadFile.fileInfo[info] = buf.readInt32BE(0);
	},
	processTPRM: function(_, sadFile, info) { //TODO
		this._checkStream();
		this.stream.write(_, this._writeBufTPRM(sadFile, info));

		tracer && tracer("\n### Read buffer for order: T_PRM ###");
		var buf = this.stream.read(_, 1);
		traceBuffer(0, "Error code", buf);
		if (this._NoLogicalError(_, buf, sadFile)) {
			this._readBufTPRM(this.stream.read(_, 4), sadFile, info);
		}
	},

	/// ##**Action S_LBF**
	/// 
	/// Read all buffer from remote file.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier.  
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 5.  
	///       - **4-bytes** : (integer) The length to read.  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	///       - **4-byte** : Buffer size to read (serialised in integer Big Endian).  
	///       - **n-byte** : Part of the file content in bytes.  
	/// 
	/// ---
	/// 
	_writeBufSLBF: function(sadFile, lenToRead) { // TODO
		var buffers = getBuffers(S_LBF, {
			sadFile: sadFile,
			lenToRead: lenToRead
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order, buffers.lenToRead]);

	},
	_readBufSLBF: function(buf, id, sadFile) {
		switch (id) {
			case 0:
				traceBuffer(0, "Length", buf);
				var len = buf.readInt32BE(0); // length of buffer to read
				return len;
			case 1:
				traceBuffer(1, "Binary", buf);
				sadFile.binary = Buffer.concat([sadFile.binary, buf]);
				break;
			default:
				throw new Error("Can't read, reply not expected");
		}
	},

	processSLBF: function(_, sadFile) {
		this._checkStream();
		tracer && tracer("\n### Read buffer for order: S_LBF ###");
		var buf = this.stream.read(_, 1);
		if (this._NoLogicalError(_, buf, sadFile)) {
			var size = sadFile.fileInfo && sadFile.fileInfo.size;
			if (!size) throw new Error("No file size found");
			// read file 
			var i = 0; // kind of binary 
			var len = -1;
			var stop = false;
			while (sadFile.binary.length < size && !stop) {
				if ((i % 2) !== 0) {
					stop = !this._NoLogicalError(_, buf = this.stream.read(_, 1), sadFile);
					len = this._readBufSLBF(buf, i % 2, sadFile);
				} else if (len !== -1) {
					buf = Buffer.concat([buf, this.stream.read(_, len - 1)]);
					this._readBufSLBF(buf, i % 2, sadFile);
					len = -1;
				} else {
					throw new Error("automate issue, can't read the right segment");
				}
				i++;
			}
		}

	},


	/// ##**Action S_EBF**
	/// 
	/// Write buffer to remote file file.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 8. 
	///       - **4-bytes** : (integer) The length of the binary to write. 
	///       - **N-bytes** : The binary content. 
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufSEBF: function(sadFile, lenToWrite) { //TODO
		var buffers = getBuffers(S_EBF, {
			sadFile: sadFile,
			lenToWrite: lenToWrite
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order, buffers.lenToWrite, buffers.binary]);
	},
	processSEBF: function(_, sadFile, byteByRequest) {
		this._checkStream();
		// write all file 
		var byteToWriteByReq = byteByRequest ? byteByRequest : MAX_BYTE_TO_WRITE;
		var buf;
		while (sadFile.binary.length !== 0) {
			buf = this._writeBufSEBF(sadFile, byteToWriteByReq);
			this.stream.write(_, buf); // write buf
			// read response 
		}
		tracer && tracer("\n### Read buffer for order: S_EBF ###");
		buf = this.stream.read(_, 1);
		traceBuffer(0, "Error code", buf);
		this._NoLogicalError(_, buf, sadFile);

	},

	/// ##**Action T_EFF**
	/// 
	/// Delete remote file.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 10. 
	///       - **2-bytes** : (short) The descriptor buffer length + 2. 
	///       - **2-bytes** : (short) The descriptor characters count. 
	///       - **N-bytes** : The descriptor string (utf-8). 
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufTEFF: function(sadFile) { // TODO 
		var buffers = getBuffers(T_EFF, {
			sadFile: sadFile
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical]);

	},
	processTEFF: function(_, sadFile) { // TODO 
		this._checkStream();
		// write open order
		this.stream.write(_, this._writeBufTEFF(sadFile));
		// read result 
		tracer && tracer("\n### Read buffer for order: T_EFF ###");
		var buf = this.stream.read(_, 1);
		traceBuffer(0, "Error code", buf);
		this._NoLogicalError(_, buf, sadFile);
	},

	/// ##**Action T_OUP**
	/// 
	/// Open remote process.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 4. 
	///       - **2-bytes** : (short) The command line buffer length + 2. 
	///       - **2-bytes** : (short) The command line characters count. 
	///       - **N-bytes** : The command line string (utf-8). 
	///       - **2-bytes** : (short) The open mode buffer length + 2. 
	///       - **2-bytes** : (short) The open mode characters count. 
	///       - **N-bytes** : The open mode string (utf-8). 
	///    - Reply :  
	///       - **1-bytes** : Identify an error occurs depending of the value else file number.  
	/// 
	/// ---
	/// 
	_writeBufTOUP: function(sadFile, openMod) {
		var buffers = getBuffers(T_OUP, {
			sadFile: sadFile,
			openMod: openMod
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical, buffers.openModBufLen, buffers.openModLen, buffers.openMod]);
	},
	_readBufTOUP: function(buf, sadFile) { // TODO merge with TOUP , it's the same 
		traceBuffer(0, "File number", buf);
		// get file num 
		sadFile.pid = buf.readInt8(0);
	},
	processTOUP: function(_, sadFile, openMod) { //TODO
		this._processTOU(_, "TOUP", sadFile, openMod);
	},

	/// ##**Action T_KUS**
	/// 
	/// Kill remote processus.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 7. 
	///       - **1-byte** : signal.
	///       - **4-bytes** : (integer) PID. 
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufTKUS: function(sadFile, signal) { // TODO
		var buffers = getBuffers(T_KUS, {
			sadFile: sadFile,
			signal: signal
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.signal, buffers.pid]);
	},
	processTKUS: function(_, sadFile) { // TODO
		this._checkStream();
		this.stream.write(_, this._writeBufTKUS(sadFile));
		tracer && tracer("\n### Read buffer for order: T_KUS ###");
		var buf = this.stream.read(_, 1);
		traceBuffer(0, "Error code", buf);
		this._NoLogicalError(_, buf, sadFile);

	},

	/// ##**Action T_ERR**
	/// 
	/// Get error.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. fixed: 0x00,0x01 
	///       - **1-byte** : order id = 6. 
	///    - Reply :  
	///       - **1-byte** : fixed: 0x00. indicate this is an error.
	///		  - **1-byte** : buffer size serialized as a unsigned integer
	/// 	  - **n-bytes** : error message encoded in utf-8 
	/// ---
	/// 
	_writeBufTERR: function() { // TODO 
		// order
		return new Buffer([0x00, 0x00, 0x01, T_ERR.id]);
	},
	_readBufTERR: function(buf, id, sadFile) {
		switch (id) {
			case 0:
				traceBuffer(id + 1, "Message length", buf);
				return buf.readUInt8(0);
			case 1:
				traceBuffer(id + 1, "Message", buf);
				sadFile.err = buf.toString("utf-8");
				break;
			default:
				throw new Error("automate issue, can't read the right segment");
		}
	},
	processTERR: function(_, sadFile) { // TODO 
		tracer && tracer("\nCatch logical error");
		this._checkStream();
		this.stream.write(_, this._writeBufTERR());
		// read first by that is normally an error
		tracer && tracer("\n### Read buffer for order: T_ERR ###");
		var buf = this.stream.read(_, 2);
		traceBuffer(0, "Error code and size", buf);
		var size = this._readBufTERR(buf.slice(1), 0, sadFile);
		this._readBufTERR(this.stream.read(_, size), 1, sadFile);
		tracer && tracer(JSON.stringify(sadFile.err, null, 2));
	}

});