"use strict";

var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3errors = require('syracuse-adxadmin/lib/common/x3errors');
var commonComm = require('syracuse-adxadmin/lib/common/commonComm._js');
var tracer = nodeconfig.config && nodeconfig.config.x3sadfsq && nodeconfig.config.x3sadfsq.protocol && nodeconfig.config.x3sadfsq.protocol.trace;

// close file
var S_FER = {
	descr: "S_FER",
	id: 1,
	len: 1,
	lenUtil: []
};
// flush file
var S_VID = {
	descr: "S_VID",
	id: 2,
	len: 1,
	lenUtil: []
};
// test EOF
var S_TFF = {
	descr: "S_TFF",
	id: 3,
	len: 1,
	lenUtil: []
};
// get position in file
var S_POS = {
	descr: "S_POS",
	id: 4,
	len: 1,
	lenUtil: []
};
// read buffer
var S_LBF = {
	descr: "S_LBF",
	id: 5,
	len: 5,
	lenUtil: []
};
// read string
var S_LCH = {
	descr: "S_LCH",
	id: 6,
	len: 5,
	lenUtil: []
};
// read delimited buffer
var S_LBU = {
	descr: "S_LBU",
	id: 7,
	len: 5,
	lenUtil: []
};
// write buffer
var S_EBF = {
	descr: "S_EBF",
	id: 8,
	len: 5,
	lenUtil: []
};
// write string
var S_ECH = {
	descr: "S_ECH",
	id: 9,
	len: 5,
	lenUtil: []
};
// write delimited buffer
var S_EBU = {
	descr: "EBU",
	id: 10,
	len: 5,
	lenUtil: []
};
// insert char
var S_INC = {
	descr: "S_INC",
	id: 11,
	len: 5,
	lenUtil: []
};
// move cursor in file
var S_DPL = {
	descr: "S_DPL",
	id: 12,
	len: 6,
	lenUtil: []
};
// lock in file
var S_LCK = {
	descr: "S_LCK",
	id: 13,
	len: 10,
	lenUtil: []
};
// read grammar
var S_AXR = {
	descr: "S_AXR",
	id: 14,
	len: 1,
	lenUtil: []
};
// read archive index
var S_AIR = {
	descr: "AIR",
	id: 15,
	len: 1,
	lenUtil: []
};
// read archive hdd adxd
var S_AHD = {
	descr: "S_AHD",
	id: 16,
	len: 1,
	lenUtil: []
};
// read files from index
var S_IFD = {
	descr: "S_IFD",
	id: 17,
	len: 1,
	lenUtil: []
};
// read files from index again
var S_ILD = {
	descr: "S_ILD",
	id: 18,
	len: 1,
	lenUtil: []
};
// ask struct types
var S_TYP = {
	descr: "S_TYP",
	id: 19,
	len: 1,
	lenUtil: []
};
// new index entry
var S_MID = {
	descr: "S_MID",
	id: 20,
	len: 1,
	lenUtil: []
};


var INI = {
	descr: "INI",
	id: 1,
	len: 6,
	lenUtil: ["canonical"]
}; //initializatio of server
var OUF = {
	descr: "OUF",
	id: 2,
	len: 9,
	lenUtil: ["canonical", "openMod"]
}; //open file
var OUS = {
	descr: "OUS",
	id: 3,
	len: 13,
	lenUtil: ["canonical"]
}; //open file
var OUP = {
	descr: "OUP",
	id: 4,
	len: 9,
	lenUtil: ["canonical", "openMod"]
}; //open pip
var ERR = {
	descr: "ERR",
	id: 6,
	len: 5,
	lenUtil: ["canonical"]
}; //get error message
var PRM = {
	descr: "PRM",
	id: 7,
	len: 6,
	lenUtil: ["canonical"]
}; //get access right
var PAT = {
	descr: "PAT",
	id: 8,
	len: 5,
	lenUtil: ["canonical"]
}; //get absolute path
var EFF = {
	descr: "EFF",
	id: 10,
	len: 5,
	lenUtil: ["canonical"]
}; //delete file
var KUS = {
	descr: "KUS",
	id: 15,
	len: 6,
	lenUtil: []
}; //stop processus
var T_REN = {
	descr: "T_REN",
	id: 19,
	len: 0, // caculate directly in write
	lenUtil: ["canonical"]
};


var fileAttributes = exports.fileAttributes = [
	null,
	"mode",
	"ino",
	"dev",
	"rdev",
	"nlink",
	"uid",
	"gid",
	"size",
	"atime",
	"mtime",
	"ctime"
];

function getBuffers(order, params) {
	tracer && tracer("\n### Create buffer for order: " + order.descr + " ###");
	var buffers = {};
	var sadFile = params.sadFile;
	buffers.infoId = {
		descr: "information id",
		buf: function() {
			var buf = new Buffer(1);
			buf.writeInt8(params.infoId, 0);
			return buf;
		}
	};

	buffers.lenToRead = {
		descr: "length of bytes to read",
		buf: function() {
			var buf = new Buffer(4);
			buf.writeInt32BE(params.lenToRead, 0);
			return buf;
		}
	};
	buffers.lenToWrite = {
		descr: "length of bytes to write",
		buf: function() {
			var buf = new Buffer(4);
			var len = params.binary.length;
			buf.writeInt32BE(len, 0);
			return buf;
		}
	};
	buffers.binary = {
		descr: "binary to write",
		buf: function() {
			return params.binary;
		}
	};

	// init
	buffers.init = {
		descr: "Init buffer",
		buf: function() {
			return new Buffer([0x00]);
		}
	};
	// canonical
	buffers.canonical = {
		descr: "Canonical name",
		buf: function() {
			if (sadFile && sadFile.canonical) {
				return new Buffer(sadFile.canonical, 'utf-8');
			} else {
				throw new Error(locale.format(module, "canonicalNotExists"));
			}
		}
	};

	// order
	buffers.order = {
		descr: "Order [" + order.descr + "]",
		buf: function() {
			return new Buffer([order.id]);
		}
	};
	buffers.openMod = {
		descr: "OpenMod Buffer",
		buf: function() {
			return new Buffer(params.openMod ? params.openMod : "", "utf-8");
		}

	};
	buffers.openModLen = {
		descr: "OpenMod size",
		buf: function() {
			var openModLen = new Buffer(2);
			openModLen.writeInt16BE((params.openMod ? params.openMod.length : 0), 0);
			return openModLen;
		}
	};

	buffers.openModBufLen = {
		descr: "OpenMod buffer size",
		buf: function() {
			var openModBufLen = new Buffer(2);
			openModBufLen.writeInt16BE(buffers.openMod.buf().length + 2, 0);
			return openModBufLen;
		}

	};


	// file descr buffer length + 2
	buffers.canonicalBufLen = {
		descr: "Canonical buf size",
		buf: function() {
			var canonicalBufLen = new Buffer(2);
			var can = buffers.canonical.buf();
			canonicalBufLen.writeInt16BE(can.length + 2, 0);
			return canonicalBufLen;
		}
	};

	// canonical (nb character) length
	buffers.canonicalLen = {
		descr: "Nb char of canonical",
		buf: function() {
			var canonicalLen = new Buffer(2);
			var can = buffers.canonical.buf();
			canonicalLen.writeInt16BE(can.length, 0);
			return canonicalLen;
		}
	};
	// file descriptor 
	buffers.fd = {
		descr: "remote file descriptor (identification of remote file)",
		buf: function() {
			return new Buffer([params.fd]);
		}
	};
	buffers.signal = { // kill signal (1,..,9)
		descr: " signal send to process ",
		buf: function() {
			return new Buffer([params.signal]);
		}
	};


	buffers.pid = {
		descr: "processus pid ",
		buf: function() {
			var buf = new Buffer(4);
			buf.writeInt32BE(params.pid, 0);
			return buf;
		}
	};

	// len util 
	buffers.lenUtil = {
		descr: "Length to follow",
		buf: function() {
			var lenUtil = new Buffer(2);
			var size = 0;
			for (var i in order.lenUtil) {
				var item = buffers[order.lenUtil[i]];
				size += item.buf().length;
			}
			lenUtil.writeInt16BE(size + order.len, 0);
			return lenUtil;
		}
	};

	return buffers;

}


function bufferConcat(table) {
	var buf = new Buffer([]);
	table.map(function(item, i) {
		if (item.buf) {
			var b = item.buf();
			commonComm.traceBuffer(tracer, i, item.descr, b);
			buf = Buffer.concat([buf, b]);
		} else {
			tracer && tracer("no method buf for item ");
		}
	});
	tracer && tracer(buf);
	return buf;
}

var SAD_ID = 6;
var SAD_SECURE_ID = 106;

/// !doc
/// 
/// # SadFsqComm module
/// 
/// DO NOT USE THIS MODULE DIRECTLY !!!  
/// This documentation is only provided to understand the protocol layer !  
/// 
/// To interface with adxadmin server, please refer to [SadFsqClient module API](https://github.com/Sage-ERP-X3/Syracuse/blob/master/node_modules/syracuse-adxadmin/lib/sadfsq/sadfsqClient.md "SadFsqClient module API").
/// 
/// ---
exports.SadFsqComm = helpers.defineClass(function(_, stream) {
	commonComm.CommonComm.call(this, _, stream, tracer);
}, commonComm.CommonComm, {
	_hasError: function(buffer) {
		return (buffer[0] & 0x80) !== 0;
	},
	_NoLogicalError: function(_, buf) {
		if (!buf) {
			throw new Error(locale.format(module, "errorIdNotFound"));
		} else if (this._hasError(buf)) {
			var err = this.processERR(_, (256 - buf.readUInt8(0)));
			throw new Error(err);
		}
		return true;
	},
	/// # Connection / Disconnection
	/// 
	/// This chapter describes connection and disconnection sequences with Safe X3 AdxAdmin server component.
	/// 
	/// 
	/// ##**Connection**
	/// 
	/// Opening classic TCP/IP socket on 'server:port' with AdxAdmin server.  
	/// 
	///   - **First step** : open session.  
	///   - Request :  
	///      - **1-byte** : The service ID : 6 by default and 106 for secure mode.  
	///      - **1-byte** : The length to follow.  
	///      - **1-byte** : The user string length.  
	///      - **N-bytes** : The user.
	///      - **1-byte** : The user string length.  
	///      - **N-bytes** : The user.  
	///      - **1-byte** : The password string length.  
	///      - **N-bytes** : The password
	///   - Reply :  
	///      - **4-bytes** : (integer LE) The adonix process PID or -1 if an error occurred.  
	///      - **[1-byte]** : Only if -1 : The message length.  
	///      - **[4-bytes]** : Only if -1 : (integer LE) The adonix error code.  
	///      - **[N-bytes]** : Only if -1 : The error message.  
	/// 
	/// ---
	/// 
	connect: function(_, user, password, secured) {
		var serviceId = secured ? SAD_SECURE_ID : SAD_ID;
		this._connect(_, serviceId, user, password, secured);

	},

	_writeBufCLS: function() {
		var buffer = new Buffer([0x00, 5]);
		commonComm.traceBuffer(tracer, 0, "disconnect", buffer);
		return buffer;
	},
	disconnect: function(_) {
		this._checkStream(_);
		this.stream.write(_, this._writeBufCLS());
	},

	/// #Remote files management
	/// 
	/// This chapter describes different sequences that allow to manage remote files with AdxAdmin server component.  
	/// 
	/// 

	/// ##**Action OUF**
	/// 
	/// Open remote file.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 2. 
	///       - **2-bytes** : (short) The descriptor buffer length + 2. 
	///       - **2-bytes** : (short) The descriptor characters count. 
	///       - **N-bytes** : The descriptor string (utf-8). 
	///       - **2-bytes** : (short) The open mode buffer length + 2. 
	///       - **2-bytes** : (short) The open mode characters count. 
	///       - **N-bytes** : The open mode string (utf-8). 
	///    - Reply :  
	///       - **1-bytes** : Identify an error or file number.  
	/// 
	/// ---
	/// 
	_writeBufOUF: function(sadFile, openMod) {
		var buffers = getBuffers(OUF, {
			sadFile: sadFile,
			openMod: openMod
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical, buffers.openModBufLen, buffers.openModLen, buffers.openMod]);
	},
	_readBufOUF: function(buf) {
		// get file num 
		commonComm.traceBuffer(tracer, 0, "File number", buf);
		return buf.readInt8(0);
	},
	_processOU: function(_, suf, sadFile, openMod) {
		this._checkStream();
		var suffix = suf;
		// write open order
		this.stream.write(_, this["_writeBuf" + suffix].apply(this, [sadFile, openMod]));
		// read result 
		tracer && tracer("\n### Read buffer for order: " + suf + " ###");
		var buf = this.stream.read(_, 1);
		if (this._NoLogicalError(_, buf)) {
			return this["_readBuf" + suffix].apply(null, [buf]);
		} else {
			commonComm.traceBuffer(tracer, 0, "Error code", buf);
		}
	},
	processOUF: function(_, sadFile, openMod) {
		return this._processOU(_, "OUF", sadFile, openMod);
	},


	/// ##**Action OUS**
	/// 
	/// Open remote file.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 2. 
	///       - **2-bytes** : (short) The descriptor buffer length + 2. 
	///       - **2-bytes** : (short) The descriptor characters count. 
	///       - **N-bytes** : The descriptor string (utf-8). 
	///       - **4-bytes** : (integer BE) The mod 
	///       - **4-bytes** : (integer BE) The mask  
	///    - Reply :  
	///       - **1-bytes** : Identify an error or file number.  
	/// 
	/// ---
	/// 


	_writeBufOUS: function(sadFile, mod, mask) { //TODO
		var _mod = {
			descr: "mod Buffer",
			buf: function() {
				var buf = new Buffer(4);
				buf.writeInt32BE(mod, 0);
				return buf;
			}
		};
		var _mask = {
			descr: "mask Buffer",
			buf: function() {
				var buf = new Buffer(4);
				buf.writeInt32BE(mask, 0);
				return buf;
			}
		};

		var buffers = getBuffers(OUS, {
			sadFile: sadFile,
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical, _mod, _mask]);
	},
	_readBufOUS: function(buf) {
		commonComm.traceBuffer(tracer, 0, "File number", buf);
		return buf.readInt8(0);
	},
	processOUS: function(_, sadFile, mod, mask) { //not used at all today
		this._checkStream();
		this.stream.write(_, this._writeBufOUS(sadFile, mod, mask));
		tracer && tracer("\n### Read buffer for order: OUS ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		if (this._NoLogicalError(_, buf)) {
			// nothin
			return this._readBufOUS(buf);
		}
	},

	/// ##**Action S_POS**
	/// 
	/// Get current position in file.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier.  
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 4.  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	///       - **4-bytes** : (Integer) The current position.  
	/// 
	/// ---
	/// 
	_writeBufPOS: function(fd) {
		var buffers = getBuffers(S_POS, {
			fd: fd,
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order]);
	},

	processPOS: function(_, fd) {
		this._checkStream();
		this.stream.write(_, this._writeBufPOS(fd));
		tracer && tracer("\n### Read buffer for order: S_POS ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		if (this._NoLogicalError(_, buf)) {
			buf = this.stream.read(_, 4);
			return buf.readInt32BE(0);
		}
	},

	/// ##**Action S_DPL**
	/// 
	/// Change cursor position in file.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier.  
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 5.  
	///       - **1-byte** : base (0:BOF, 1:Curr, 2:EOF).  
	///       - **4-bytes** : (integer) The offset used to move.  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufDPL: function(fd, cursor, offset) {
		var buffers = getBuffers(S_DPL, {
			fd: fd,
			cursor: cursor,
			offset: offset
		});
		var _cursor = {
			descr: "Cursor base",
			buf: function() {
				var buf = new Buffer(1);
				buf.writeInt8(cursor, 0);
				return buf;
			}
		};

		var _offset = {
			descr: "Offset",
			buf: function() {
				var buf = new Buffer(4);
				buf.writeInt32BE(offset, 0);
				return buf;
			}
		};
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order, _cursor, _offset]);
	},

	processDPL: function(_, fd, cursor, offset) {
		this._checkStream();
		this.stream.write(_, this._writeBufDPL(fd, cursor, offset));
		tracer && tracer("\n### Read buffer for order: S_DPL ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		this._NoLogicalError(_, buf);
	},

	/// ##**Action S_VID**
	/// 
	/// Flush file content.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier.  
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 2.  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufVID: function(fd) {
		var buffers = getBuffers(S_VID, {
			fd: fd,
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order]);
	},

	processVID: function(_, fd) {
		this._checkStream();
		this.stream.write(_, this._writeBufVID(fd));
		tracer && tracer("\n### Read buffer for order: S_VID ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		this._NoLogicalError(_, buf);
	},


	/// ##**Action S_LCK**
	/// 
	/// Flush file content.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier.  
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 13.  
	///       - **1-byte** : The lock type.  
	///       - **4-bytes** : The lock position.  
	///       - **4-bytes** : Number of characters that are concerned.  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufLCK: function(fd, type, len, pos) {
		var buffers = getBuffers(S_LCK, {
			fd: fd,
		});

		var lockType = {
			descr: "Lock type",
			buf: function() {
				return new Buffer([type]);
			}
		};
		var lockPos = {
			descr: "Lock position",
			buf: function() {
				var buf = new Buffer(4);
				buf.writeInt32BE(pos, 0);
				return buf;
			}
		};
		var nbChars = {
			descr: "Number of characters",
			buf: function() {
				var buf = new Buffer(4);
				buf.writeInt32BE(len, 0);
				return buf;
			}
		};
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order, lockType, lockPos, nbChars]);
	},

	processLCK: function(_, fd, type, len, pos) {
		this._checkStream();
		this.stream.write(_, this._writeBufLCK(fd, type, len, pos));
		tracer && tracer("\n### Read buffer for order: S_LCK ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		this._NoLogicalError(_, buf);
		return buf.readUInt8(0);
	},

	_writeBufREN: function(oldSadFile, newSadFile) {
		var oldBuffers = getBuffers(T_REN, {
			sadFile: oldSadFile
		});
		var newBuffers = getBuffers(T_REN, {
			sadFile: newSadFile
		});
		var lenUtil = {
			descr: "Length to follow",
			buf: function() {
				var lenUtil = new Buffer(2);
				var size = 0;
				var item = newBuffers.canonical;
				size += item.buf().length;
				item = oldBuffers.canonical;
				size += item.buf().length;
				lenUtil.writeInt16BE(size + 9, 0);
				return lenUtil;
			}
		};

		return bufferConcat([oldBuffers.init, lenUtil, oldBuffers.order, oldBuffers.canonicalBufLen, oldBuffers.canonicalLen, oldBuffers.canonical, newBuffers.canonicalBufLen, newBuffers.canonicalLen, newBuffers.canonical]);

	},
	processREN: function(_, oldSadFile, newSadFile) {
		this._checkStream();
		this.stream.write(_, this._writeBufREN(oldSadFile, newSadFile));
		tracer && tracer("\n### Read buffer for order: S_REN ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		this._NoLogicalError(_, buf);

	},

	processLCH: function() {},
	processLBU: function() {},
	processECH: function() {},
	processINC: function() {},
	processMAP: function() {},


	/// ##**Action S_TFF**
	/// 
	/// check if is end of file  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier.  
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 2.  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 

	_writeBufTFF: function(fd) {
		var buffers = getBuffers(S_TFF, {
			fd: fd,
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order]);
	},
	_readBufTFF: function(buf) {
		commonComm.traceBuffer(tracer, 0, "is End Of File", buf);
		return buf.readUInt8(0);
	},
	processTFF: function(_, fd) { // not used today at all
		this._checkStream();
		this.stream.write(_, this._writeBufTFF(fd));
		tracer && tracer("\n### Read buffer for order: S_TFF ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		this._NoLogicalError(_, buf);
		return this._readBufTFF(buf);
	},

	_writeBufINI: function(fd) { //TODO
	},

	processINI: function() { //TODO
	},



	/// ##**Action S_FER**
	/// 
	/// Close remote opened file.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 1. 
	///    - Reply :  
	///       - **1-byte** : The error code.  
	/// 
	/// ---
	/// 
	_writeBufFER: function(fd) {
		var buffers = getBuffers(S_FER, {
			fd: fd,
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order]);
	},

	processFER: function(_, fd) {
		this._checkStream();
		this.stream.write(_, this._writeBufFER(fd));
		tracer && tracer("\n### Read buffer for order: S_FER ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		if (this._NoLogicalError(_, buf)) {
			// nothin
		}
	},

	/// ##**Action PAT**
	/// 
	/// Get remote file path.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 8. 
	///       - **2-bytes** : (short) The descriptor buffer length + 2. 
	///       - **2-bytes** : (short) The descriptor characters count. 
	///       - **N-bytes** : The descriptor string (utf-8). 
	///    - Reply :  
	///       - **X-bytes** : TODO.  
	/// 
	/// ---
	/// 
	_writeBufPAT: function(sadFile) {
		var buffers = getBuffers(PAT, {
			sadFile: sadFile
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical]);
	},
	_readBufPAT: function(buf, id) {
		switch (id) {
			case 0:
				commonComm.traceBuffer(tracer, id + 1, "Length of path", buf);
				return buf.readInt8(0);
			case 1:
				commonComm.traceBuffer(tracer, id + 1, "Path", buf);
				return buf.toString("utf-8");
			default:
				throw new Error("Can't read, reply not expected");
		}
	},
	processPAT: function(_, sadFile) {
		this._checkStream();
		this.stream.write(_, this._writeBufPAT(sadFile));
		tracer && tracer("\n### Read buffer for order: PAT ###");
		var buf = this.stream.read(_, 2);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		if (this._NoLogicalError(_, buf))
			return this._readBufPAT(this.stream.read(_, this._readBufPAT(buf.slice(1), 0)), 1);

	},

	/// ##**Action PRM**
	/// 
	/// Get file information.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. : 
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 7.  
	///       - **1-byte** : info id. Can be 'size' (8) or 'stamp' (10).  
	///       - **2-bytes** : (short) The descriptor buffer length + 2.  
	///       - **2-bytes** : (short) The descriptor characters count.  
	///       - **N-bytes** : The descriptor string (utf-8).  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received or the value of the info Id (serialized in unsigned integer).  
	///       - **4-byte** : Value of the info Id (serialized in integer Big Endian).  
	/// 
	/// ---
	/// 
	_writeBufPRM: function(sadFile, info) {
		var fileInfo = fileAttributes.indexOf(info);
		if (info == null || fileInfo === -1) {
			throw new Error("The file attribute '" + info + "' is not allowed.");
		}
		var buffers = getBuffers(PRM, {
			sadFile: sadFile,
			infoId: fileInfo
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.infoId, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical]);

	},
	_readBufPRM: function(buf, info) {
		commonComm.traceBuffer(tracer, 1, info, buf);
		var v = buf.readInt32BE(0);
		if (fileAttributes.indexOf(info) > 8)
			v = new Date(v);
		return v;
	},
	processPRM: function(_, sadFile, info) {
		this._checkStream();
		var b = this._writeBufPRM(sadFile, info);
		//nconsole.log(b);
		this.stream.write(_, b);

		tracer && tracer("\n### Read buffer for order: PRM ###");
		var buf = this.stream.read(_, 5);
		commonComm.traceBuffer(tracer, 0, "Error code", buf.slice(0, 1));
		if (this._NoLogicalError(_, buf)) {
			return this._readBufPRM(buf.slice(1), info);
		}
	},

	/// ##**Action S_LBF**
	/// 
	/// Read all buffer from remote file.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier.  
	///       - **2-bytes** : (Short) The length to follow.  
	///       - **1-byte** : order id = 5.  
	///       - **4-bytes** : (integer) The length to read.  
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	///       - **4-byte** : Buffer size to read (serialised in integer Big Endian).  
	///       - **n-byte** : Part of the file content in bytes.  
	/// 
	/// ---
	/// 
	_writeBufLBF: function(fd, lenToRead) {
		var buffers = getBuffers(S_LBF, {
			fd: fd,
			lenToRead: lenToRead
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order, buffers.lenToRead]);

	},
	_readBufLBF: function(buf, id, binary) {
		switch (id) {
			case 0:
				commonComm.traceBuffer(tracer, 0, "Length", buf);
				var len = buf.readInt32BE(0); // length of buffer to read
				return len;
			case 1:
				commonComm.traceBuffer(tracer, 1, "Binary", buf);
				return Buffer.concat([binary, buf]);
			default:
				throw new Error("Can't read, reply not expected");
		}
	},

	processLBF: function(_, fd, lenToRead) {
		this._checkStream();
		var size = lenToRead ? lenToRead : 1024 * 32;
		if (size < 0) throw new Error(locale.format(module, "sizeToReadNegative"));
		if (size === 0) return new Buffer([]);
		this.stream.write(_, this._writeBufLBF(fd, size));
		tracer && tracer("\n### Read buffer for order: S_LBF ###");
		// read file 
		var len = -1;
		var buf = new Buffer([]);
		var tmpbuf;
		do {
			this._NoLogicalError(_, tmpbuf = this.stream.read(_, 5));
			len = this._readBufLBF(tmpbuf.slice(1), 0);
			if (len) {
				buf = this._readBufLBF(this.stream.read(_, len), 1, buf);
			}
		} while ((lenToRead && lenToRead !== len) || (!lenToRead && len === size)); // allow to read without know the file size
		return buf;
	},

	/// ##**Action S_EBF**
	/// 
	/// Write buffer to remote file file.  
	/// 
	///    - Request :  
	///       - **1-byte** : The file descriptor identifier. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 8. 
	///       - **4-bytes** : (integer) The length of the binary to write. 
	///       - **N-bytes** : The binary content. 
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufEBF: function(fd, data) {
		var buffers = getBuffers(S_EBF, {
			fd: fd,
			binary: data
		});
		return bufferConcat([buffers.fd, buffers.lenUtil, buffers.order, buffers.lenToWrite, buffers.binary]);
	},
	processEBF: function(_, fd, data) {
		this._checkStream();
		// write all file 
		var buf = this._writeBufEBF(fd, data);
		this.stream.write(_, buf); // write buf
		tracer && tracer("\n### Read buffer for order: S_EBF ###");
		buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		this._NoLogicalError(_, buf);

	},

	/// ##**Action EFF**
	/// 
	/// Delete remote file.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 10. 
	///       - **2-bytes** : (short) The descriptor buffer length + 2. 
	///       - **2-bytes** : (short) The descriptor characters count. 
	///       - **N-bytes** : The descriptor string (utf-8). 
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufEFF: function(sadFile) {
		var buffers = getBuffers(EFF, {
			sadFile: sadFile
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical]);

	},
	processEFF: function(_, sadFile) {
		this._checkStream();
		// write open order
		this.stream.write(_, this._writeBufEFF(sadFile));
		// read result 
		tracer && tracer("\n### Read buffer for order: EFF ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		this._NoLogicalError(_, buf);
	},

	/// #Remote processes management
	/// 
	/// This chapter describes different sequences that allow to manage remote processes with AdxAdmin server component.  
	/// 
	/// 

	/// ##**Action OUP**
	/// 
	/// Open remote process.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 4. 
	///       - **2-bytes** : (short) The command line buffer length + 2. 
	///       - **2-bytes** : (short) The command line characters count. 
	///       - **N-bytes** : The command line string (utf-8). 
	///       - **2-bytes** : (short) The open mode buffer length + 2. 
	///       - **2-bytes** : (short) The open mode characters count. 
	///       - **N-bytes** : The open mode string (utf-8). 
	///    - Reply :  
	///       - **1-bytes** : Identify an error occurs depending of the value else file number.  
	/// 
	/// ---
	/// 
	_writeBufOUP: function(sadFile, openMod) {
		var buffers = getBuffers(OUP, {
			sadFile: sadFile,
			openMod: openMod
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.canonicalBufLen, buffers.canonicalLen, buffers.canonical, buffers.openModBufLen, buffers.openModLen, buffers.openMod]);
	},
	_readBufOUP: function(buf) {
		commonComm.traceBuffer(tracer, 0, "File number", buf);
		// get file num 
		return buf.readInt8(0);
	},
	processOUP: function(_, sadFile, openMod) {
		return this._processOU(_, "OUP", sadFile, openMod);
	},

	/// ##**Action KUS**
	/// 
	/// Kill remote processus.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. 
	///       - **1-byte** : order id = 7. 
	///       - **1-byte** : signal.
	///       - **4-bytes** : (integer) PID. 
	///    - Reply :  
	///       - **1-byte** : Identified if an error occurs depending of the value received.  
	/// 
	/// ---
	/// 
	_writeBufKUS: function(pid, signal) {
		var buffers = getBuffers(KUS, {
			pid: pid,
			signal: signal
		});
		return bufferConcat([buffers.init, buffers.lenUtil, buffers.order, buffers.signal, buffers.pid]);
	},
	processKUS: function(_, pid, signal) {
		this._checkStream();
		this.stream.write(_, this._writeBufKUS(pid, signal));
		tracer && tracer("\n### Read buffer for order: KUS ###");
		var buf = this.stream.read(_, 1);
		commonComm.traceBuffer(tracer, 0, "Error code", buf);
		this._NoLogicalError(_, buf);

	},

	/// ##**Action ERR**
	/// 
	/// Get error.  
	/// 
	///    - Request :  
	///       - **1-byte** : fixed: 0x00. 
	///       - **2-bytes** : (Short) The length to follow. fixed: 0x00,0x01 
	///       - **1-byte** : order id = 6. 
	///    - Reply :  
	///       - **1-byte** : fixed: 0x00. indicate this is an error.
	///		  - **1-byte** : buffer size serialized as a unsigned integer
	/// 	  - **n-bytes** : error message encoded in utf-8 
	/// ---
	/// 
	_writeBufERR: function() {
		// order
		return new Buffer([0x00, 0x00, 0x01, ERR.id]);
	},
	_readBufERR: function(buf, id) {
		switch (id) {
			case 0:
				commonComm.traceBuffer(this.tracer, id + 1, "Message length", buf);
				return buf.readUInt8(0);
			case 1:
				commonComm.traceBuffer(this.tracer, id + 1, "Message", buf);
				return buf.toString("utf-8");
			default:
				throw new Error("automate issue, can't read the right segment");
		}
	},
	processERR: function(_, errId) {
		this.tracer && this.tracer("Catch logical error");
		this._checkStream();
		this.tracer && this.tracer("\n### Create buffer for order ERR ###");
		var buf = this._writeBufERR();
		commonComm.traceBuffer(this.tracer, 0, "Ask error", buf);
		this.stream.write(_, buf);
		// read first by that is normally an error
		this.tracer && this.tracer("\n### Read buffer for order: ERR ###");
		buf = this.stream.read(_, 2);
		commonComm.traceBuffer(this.tracer, 0, "Error code and size", buf);
		var err = x3errors.getError(errId) + " : ";
		var size = this._readBufERR(buf.slice(1), 0);
		err += this._readBufERR(this.stream.read(_, size), 1);
		//this.tracer && this.tracer(JSON.stringify(err, null, 2));
		return err;
	}

});