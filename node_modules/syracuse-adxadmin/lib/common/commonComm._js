"use strict";

var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var x3errors = require('syracuse-adxadmin/lib/common/x3errors');
var nodeconfig = require('syracuse-main/lib/nodeconfig');

var ERR = {
	descr: "ERR",
	id: 6,
	len: 5,
	lenUtil: ["canonical"]
}; //get error message

var traceBuffer = exports.traceBuffer = function(tracer, id, descr, buf) {
	if (buf)
		tracer && tracer("Buffer[" + id + "] (" + descr + ") = " + buf.toString('hex') + " [Length: " + buf.length + "]");
};


exports.CommonComm = helpers.defineClass(function(_, stream, tracer) {
	this.stream = stream;
	this.tracer = tracer;
}, null, {
	_hasError: function(buffer) {
		return (buffer[0] & 0x80) !== 0;
	},
	_NoLogicalError: function(_, buf) {
		if (!buf) {
			throw new Error(locale.format(module, "errorIdNotFound"));
		} else if (this._hasError(buf)) {
			var err = this.processERR(_, (256 - buf.readUInt8(0)));
			throw new Error(err);
		}
		return true;
	},
	_checkStream: function() {
		if (!this.stream) throw new Error(locale.format(module, "streamNull"));
	},
	_writeBufConnect: function(params) {
		this.tracer && this.tracer("\n### Create buffer for CONNECTION ###");
		var bufServiceId = new Buffer(1);
		bufServiceId.writeInt8(params.serviceId, 0);

		var bufUser = new Buffer(params.user, "utf-8");
		var bufPass = new Buffer(params.password, "utf-8");
		var bufLenUser = new Buffer(1);
		bufLenUser.writeInt8(bufUser.length, 0);
		var bufLenPass = new Buffer(1);
		bufLenPass.writeInt8(bufPass.length, 0);
		var bufLenUtil = new Buffer(1);
		bufLenUtil.writeInt8(bufUser.length * 2 + bufPass.length + 3, 0);

		this.tracer && this.tracer("Buffer[0] (Service ID) " + bufServiceId.toString("hex"));
		this.tracer && this.tracer("Buffer[1] (Length to follow) " + bufLenUtil.toString("hex"));
		this.tracer && this.tracer("Buffer[2] (User length) " + bufLenUser.toString("hex"));
		this.tracer && this.tracer("Buffer[3] (User) " + bufUser.toString("hex"));
		this.tracer && this.tracer("Buffer[4] (User length) " + bufLenUser.toString("hex"));
		this.tracer && this.tracer("Buffer[5] (User) " + bufUser.toString("hex"));
		this.tracer && this.tracer("Buffer[6] (Password length) " + bufLenPass.toString("hex"));
		this.tracer && this.tracer("Buffer[7] (Password) " + bufPass.toString("hex"));
		var buf = Buffer.concat([bufServiceId, bufLenUtil, bufLenUser, bufUser, bufLenUser, bufUser, bufLenPass, bufPass]);
		//this.tracer && this.tracer(buf);
		return buf;
	},
	_connect: function(_, serviceId, user, password, secured) {

		this._checkStream();
		this.stream.write(_, this._writeBufConnect({
			serviceId: serviceId,
			secured: secured,
			user: user,
			password: password
		}));

		this.tracer && this.tracer("\n### Read buffer for order: CONNECT ###");
		var buf = this.stream.read(_, 4);
		var pid = buf.readInt32BE(0);
		if (pid > -1) {
			traceBuffer(this.tracer, 0, "PID", buf);
			this.tracer && this.tracer("Adonix process pid: " + pid);
			return pid;
		} else {
			buf = this.stream.read(_, 5);
			traceBuffer(this.tracer, 1, "Message length (1) and error code (4)", buf);
			var msgLen = buf.readInt8(0);
			var errCode = buf.readInt32BE(1);
			buf = this.stream.read(_, msgLen);
			traceBuffer(this.tracer, 2, "Error message", buf);
			var msg = buf.toString('utf-8');
			throw new Error(locale.format(module, "connectionFailed", errCode, msg));
		}
	},

	_disconnect: function(_) {

	},

	_writeBufERR: function() {
		// order
		return new Buffer([0x00, 0x00, 0x01, ERR.id]);
	},
	_readBufERR: function(buf, id) {
		switch (id) {
			case 0:
				traceBuffer(this.tracer, id + 1, "Message length", buf);
				return buf.readUInt8(0);
			case 1:
				traceBuffer(this.tracer, id + 1, "Message", buf);
				return buf.toString("utf-8");
			default:
				throw new Error("automate issue, can't read the right segment");
		}
	},
	_processERR: function(_, errId) {
		this.tracer && this.tracer("Catch logical error");
		this._checkStream();
		this.tracer && this.tracer("\n### Create buffer for order ERR ###");
		var buf = this._writeBufERR();
		traceBuffer(this.tracer, 0, "Ask error", buf);
		this.stream.write(_, buf);
		// read first by that is normally an error
		this.tracer && this.tracer("\n### Read buffer for order: ERR ###");
		buf = this.stream.read(_, 2);
		traceBuffer(this.tracer, 0, "Error code and size", buf);
		var err = x3errors.getError(errId) + " : ";
		var size = this._readBufERR(buf.slice(1), 0);
		err += this._readBufERR(this.stream.read(_, size), 1);
		//this.tracer && this.tracer(JSON.stringify(err, null, 2));
		return err;
	}

});