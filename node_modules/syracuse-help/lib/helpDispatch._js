"use strict";

var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var locale = require('syracuse-core/lib/locale');
var datetime = require("syracuse-core/lib/types/datetime");
var helpers = require('syracuse-core/lib/helpers');
var sys = require("util");
var path = require('path');
var fs = require('streamline-fs');
var crypto = require('crypto');
var url = require('url');
var httpClient = require('syracuse-httpclient/lib/httpClient');

var helpTrace = config.help && config.help.trace;

var secret = (function() {
	var o = {
		k: "a1b3a33b-f792-4c19-a10b-505a48715d1b"
	};
	var x = 0;
	return o.k.replace(/./g, function(c) {
		return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
	});

})();

var helpPath = (config.help && config.help.rootDir) || path.join(__dirname, "../../../../online-doc/DOCV7-X3");
var helpProvider = fs.existsSync(helpPath) ? require('streamline-static/lib/staticProvider').staticProvider({
	root: helpPath,
	maxAge: 3600 * 1000
}) : null;

function helpProxyProvider(rootUrl, authent) {
	return function(_, request) {
		if (authent) {
			var token = {
				"serial": authent.serial || "0000000000000000",
				"date": datetime.now().toString(),
				"once": helpers.uuid.generate()
			};
			var md5sum = crypto.createHash('md5');
			md5sum.update(token.serial + '/' + token.date + '/' + token.once + '/' + secret, "ascii");
			token.signature = md5sum.digest("hex");

			request.headers["Cache-Control"] = request.headers["Cache-Control"] ? request.headers["Cache-Control"] + ", must-revalidate, proxy-revalidate" : "must-revalidate, proxy-revalidate";
			request.headers.authorization = "X3Doc " + new Buffer(JSON.stringify(token)).toString('base64');
			request.headers['accept-encoding'] = 'deflate';
		}
		var options = {
			url: url.resolve(rootUrl, request.url),
			method: "GET",
			headers: request.headers
		};

		helpTrace && helpTrace("helpProxyProvider: rootUrl=" + rootUrl + ", request.url=" + request.url + "\n>>> options=" + sys.inspect(options));
		var helpRequest = httpClient.httpRequest(_, options);
		var buf;
		while (buf = request.read(_)) helpRequest.write(_, buf);
		var helpResponse = helpRequest.end().response(_);
		helpTrace && helpTrace("helpProxyProvider:\n>>> helpResponse.headers=" + sys.inspect(helpResponse.headers) + "\n>>> helpResponse.statusCode=" + helpResponse.statusCode);
		return helpResponse;
	};
}

function plainReply(response, status, message, headers) {
	headers = headers || {};
	headers['content-type'] = "text/plain";
	response.writeHead(status, headers);
	response.end(message, 'utf8');
}


exports.dispatcher = function(config) {
	return function(_, request, response) {
		var rel;
		var uri = url.parse(request.url, true),
			langParam = uri.query.language;
		var matches = /^\/help\/(\w{2}[_-]\w{2})\/([^\/]*)\/([^\/]*)\/([^\/]*)\/(.*)/.exec(uri.pathname);
		var langSeg, i = 0;

		if (!matches) {
			matches = /^\/help\/([^\/]*)\/([^\/]*)\/([^\/]*)\/(.*)/.exec(uri.pathname);
		} else {
			langSeg = matches[1];
			i = 1;
		}

		if (!matches) {
			matches = /^\/help\/(\w{2}[_-]\w{2})\/(.*)/.exec(uri.pathname);
			if (!matches) {
				matches = /^\/help\/(.*)/.exec(uri.pathname);
			} else {
				langSeg = matches[1];
				i = 1;
			}
			if (matches) {
				rel = matches[i + 1];
			} else {
				return plainReply(response, 400, "invalid help URL: " + request.url);
			}
		} else {
			var application = matches[i + 1];
			// ignore contract and dataset
			var remain = matches[i + 4];

			if (application === "syracuse") {
				rel = 'V7DEV/' + remain;
			} else if (application === "x3") {
				rel = remain;
				if (remain.indexOf('.') === -1) rel += ".htm";
			} else {
				return plainReply(response, 404, "application not found: " + application);
			}
		}
		// Default is to use the server in the cloud
		var helpConfig = (config.help || {});
		var configUrl = helpConfig.url || "http://online-help.sageerpx3.com";
		var provider = configUrl ? helpProxyProvider(configUrl, {}) : helpProvider;

		if (!provider) return plainReply(response, 404, 'help not configured');

		// use relative path for more flexible in premise infrastructure
		var urls = [];
		langParam && urls.push(langParam + '/' + rel);
		langSeg && urls.push(langSeg + '/' + rel);
		urls.push(locale + '/' + rel);
		// last chance with en_US language
		urls.push('en-US/' + rel);

		helpTrace && helpTrace("helpDispatcher: urls=[" + urls + "]");

		for (var j = 0; j < urls.length; j++) {
			helpTrace && helpTrace("helpDispatcher: Request number: " + j);
			request.url = urls[j];
			var helpResponse = provider(_, request);
			helpTrace && helpTrace("helpDispatcher: is status code ok: " + (helpResponse && helpResponse.statusCode < 400));
			helpTrace && helpTrace("helpDispatcher: is last request: " + (j === (urls.length - 1)));
			// If response has error code status, continue until last chance
			if ((helpResponse && helpResponse.statusCode < 400) || (j === (urls.length - 1))) {
				var buf;
				response.writeHead(helpResponse.statusCode, helpResponse.headers);
				while (buf = helpResponse.read(_)) {
					response.write(_, buf);
				}
				response.end();
				return;
			}
		}
		// Must never walk here
		return plainReply(response, 404, 'help file not found: ' + rel);
	};
};