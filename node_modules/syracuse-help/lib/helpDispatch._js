"use strict";

var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var locale = require('syracuse-core/lib/locale');
var datetime = require("syracuse-core/lib/types/datetime");
var helpers = require('syracuse-core/lib/helpers');
var sys = require("util");
var path = require('path');
var fs = require('streamline-fs');
var crypto = require('crypto');
var url = require('url');
var httpClient = require('syracuse-httpclient/lib/httpClient');
var check = require('syracuse-license/lib/check');

var helpTrace = config.help && config.help.trace;

var secret = (function() {
	var o = {
		k: "a1b3a33b-f792-4c19-a10b-505a48715d1b"
	};
	var x = 0;
	return o.k.replace(/./g, function(c) {
		return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
	});

})();

var helpPath = (config.help && config.help.rootDir) || path.join(__dirname, "../../../../online-doc/DOCV7-X3");
var helpProvider = fs.existsSync(helpPath) ? require('streamline-static/lib/staticProvider').staticProvider({
	root: helpPath,
	maxAge: 3600 * 1000
}) : null;

function helpProxyProvider(rootUrl, authent) {
	var baseUri = url.parse(rootUrl);

	return function(_, request) {
		if (authent) {
			var userLogin = request.session && request.session.getUserLogin(_) || "";
			var token = {
				"serial": authent.serial || "0000000000000000",
				"user": userLogin,
				"date": datetime.now().toString(),
				"once": helpers.uuid.generate()
			};
			var md5sum = crypto.createHash('md5');
			md5sum.update(token.serial + '/' + token.date + '/' + token.once + '/' + secret, "ascii");
			token.signature = md5sum.digest("hex");
			helpTrace && helpTrace("helpProxyProvider: token=" + JSON.stringify(token, null, "\t"));
			request.headers.Authorization = "X3Doc " + new Buffer(JSON.stringify(token)).toString('base64');
		}

		var cacheControl = request.headers["cache-control"];
		var mustReval = false;
		var proxyReval = false;
		if (cacheControl && cacheControl.length > 0) {
			var cc;
			if (cacheControl.lastIndexOf(",") > 0) {
				cc = cacheControl.split(",");
			} else {
				cc = [cacheControl];
			}

			for (var i = 0; i < cc.length; i++) {
				if (!mustReval && cc[i].trim() == "must-revalidate") {
					mustReval = true;
				}
				if (!proxyReval && cc[i].trim() == "proxy-revalidate") {
					proxyReval = true;
				}
			}

			if (!mustReval) {
				cacheControl = cacheControl + ", must-revalidate,";
			}
			if (!proxyReval) {
				cacheControl = cacheControl + ", proxy-revalidate";
			}
		} else {
			cacheControl = "must-revalidate, proxy-revalidate";
		}

		request.headers["cache-control"] = cacheControl;
		request.headers['accept-encoding'] = 'deflate';
		var hostHeader = (config.help && config.help.lowercaseHeader) ? "host" : "Host";
		request.headers[hostHeader] = baseUri.host || request.headers['host'] || request.headers['Host'];

		helpTrace && helpTrace("helpProxyProvider: original request.url=" + request.url);
		var options = {
			url: url.resolve(rootUrl, request.url),
			method: "GET",
			headers: request.headers
		};

		helpTrace && helpTrace("helpProxyProvider: rootUrl=" + rootUrl + ", request.url=" + request.url + "\n>>> options=" + sys.inspect(options));
		var helpRequest = httpClient.httpRequest(_, options);
		var buf;
		while ((buf = request.read(_))) {
			helpRequest.write(_, buf);
		}
		var helpResponse = helpRequest.end().response(_);
		helpTrace && helpTrace("helpProxyProvider:\n>>> helpResponse.headers=" + sys.inspect(helpResponse.headers) + "\n>>> helpResponse.statusCode=" + helpResponse.statusCode);
		return helpResponse;
	};
}

function plainReply(response, status, message, headers) {
	headers = headers || {};
	headers['content-type'] = "text/plain";
	response.writeHead(status, headers);
	response.end(message, 'utf8');
}


exports.dispatcher = function(config) {
	var lic, authent = {};

	return function(_, request, response) {
		if (!lic) {
			lic = check.validLicenses();
			authent.serial = JSON.stringify(lic.map(function(l) {
				return [l.productCode, l.serial];
			}));
			helpTrace && helpTrace("dispatcher: init serials=" + authent.serial);
		}
		var rel;
		var uri = url.parse(request.url, true),
			langParam = uri.query.language;
		var matches = /^\/help\/(\w{2}[_-]\w{2})\/([^\/]*)\/([^\/]*)\/([^\/]*)\/(.*)/.exec(uri.pathname);
		var langSeg, i = 0;

		if (!matches) {
			matches = /^\/help\/([^\/]*)\/([^\/]*)\/([^\/]*)\/(.*)/.exec(uri.pathname);
		} else {
			langSeg = matches[1];
			i = 1;
		}

		if (!matches) {
			matches = /^\/help\/(\w{2}[_-]\w{2})\/(.*)/.exec(uri.pathname);
			if (!matches) {
				matches = /^\/help\/(.*)/.exec(uri.pathname);
			} else {
				langSeg = matches[1];
				i = 1;
			}
			if (matches) {
				rel = matches[i + 1];
			} else {
				return plainReply(response, 400, locale.format(module, "badUrl", request.url));
			}
		} else {
			var application = matches[i + 1];
			// ignore contract and dataset
			var remain = matches[i + 4];

			if (application === "syracuse") {
				rel = 'V7DEV/' + remain;
			} else if (application === "x3") {
				rel = remain;
				if (remain.indexOf('.') === -1) rel += ".htm";
			} else {
				return plainReply(response, 404, locale.format(module, "appNotFound", application));
			}
		}

		// Set up the urls that will be used to find help
		var helpConfig = (config.help || {});
		var providerName = [];
		var provider = [];

		// If help is configured as local it will override the all of the urls
		if (helpConfig.local) {
			var p = helpProvider;

			if (!p) {
				return plainReply(response, 404, locale.format(module, "localHelpConfig"));
			} else {
				provider.push(p);
				providerName.push("local");
			}
		} else {
			// Check to see if the endpoint has a help url configured as
			// this will be the first place we check
			var up = request.session && request.session.getUserProfile(_);
			var ep = up && up.selectedEndpoint(_);

			if (ep && ep.helpBaseUrl(_)) {
				helpTrace && helpTrace("helpDispatcher: endpoint help url=[" + ep.helpBaseUrl(_) + "]");
				provider.push(helpProxyProvider(ep.helpBaseUrl(_), authent));
				providerName.push(ep.helpBaseUrl(_));
			}

			// Configuration provides the next base URL
			if (helpConfig.url) {
				provider.push(helpProxyProvider(helpConfig.url, authent));
				providerName.push(helpConfig.url);
			}


			var _contract = (ep && ep.contract(_)) || "erp";
			if (_contract === "collaboration") _contract = "erp";
			// And finally fall back to the server in the cloud
			provider.push(helpProxyProvider("http://online-help.sageerpx3.com/" + _contract + "/", authent));
			providerName.push("http://online-help.sageerpx3.com/" + _contract);
		}

		// use relative path for more flexible in premise infrastructure
		var urls = [];
		langParam && urls.push(langParam + '/' + rel);
		langSeg && urls.push(langSeg + '/' + rel);
		urls.push(locale.current + '/' + rel);
		// last chance with en_US language
		urls.push('en-US/' + rel);

		helpTrace && helpTrace("helpDispatcher: urls=[" + urls + "]");

		for (var k = 0; k < provider.length; k++) {
			for (var j = 0; j < urls.length; j++) {
				helpTrace && helpTrace("helpDispatcher: Request number: " + j);
				request.url = urls[j];
				var helpResponse;
				try {
					helpResponse = provider[k](_, request);
				} catch (e) {
					// Error is thrown by httpClient when request times out
					return plainReply(response, 404, locale.format(module, "noHelpServer", providerName[k]));
				}
				helpTrace && helpTrace("helpDispatcher: is status code ok: " + _checkHelpResponse(helpResponse));
				helpTrace && helpTrace("helpDispatcher: is last request: " + (k === (provider.length - 1) && j === (urls.length - 1)));
				// If response has error code status, continue until last chance
				if (_checkHelpResponse(helpResponse) || (k === (provider.length - 1) && j === (urls.length - 1))) {
					var buf;
					response.writeHead(helpResponse.statusCode, helpResponse.headers);
					while ((buf = helpResponse.read(_))) {
						response.write(_, buf);
					}
					response.end();
					return;
				}
			}
		}
		// Must never walk here
		return plainReply(response, 404, locale.format(module, "helpNotFound", rel));
	};
};

// when the response just redirects to an error page, it will also not be accepted
function _checkHelpResponse(helpResponse) {
	if (!helpResponse) return false;
	if (helpResponse.statusCode >= 400) return false;
	if (helpResponse.statusCode >= 300 && helpResponse.headers && helpResponse.headers.location && helpResponse.headers.location.indexOf("/error_html/") > 0) return false;
	return true;
}
