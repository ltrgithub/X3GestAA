"use strict";

var config = require('config'); // must be first syracuse require
var locale = require('streamline-locale');
var datetime = require('@sage/syracuse-core').types.datetime;
var helpers = require('@sage/syracuse-core').helpers;
var sys = require("util");
var path = require('path');
var fs = require('streamline-fs');
var crypto = require('crypto');
var url = require('url');
var httpClient = require('../../../src/httpclient/httpClient');
var check = require('syracuse-license/lib/check');
var patchtools = require('syracuse-patch/lib/patchtools');

var tracer = require('@sage/syracuse-core').getTracer("help");

var secret = (function() {
	var o = {
		k: "a1b3a33b-f792-4c19-a10b-505a48715d1b"
	};
	var x = 0;
	return o.k.replace(/./g, function(c) {
		return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
	});

})();

var helpPath = (config.help && config.help.rootDir) || path.join(__dirname, "../../../../online-doc/DOCV7-X3");
var helpProvider = fs.existsSync(helpPath) ? require('streamline-static').dispatcher({
	root: helpPath,
	maxAge: 3600 * 1000
}) : null;

function helpProxyProvider(rootUrl, authent) {
	var baseUri = url.parse(rootUrl);
	return function(_, url0, content, request) {
		var headers = {}; // local copy of request
		for (var k in request.headers) {
			headers[k] = request.headers[k];
		}
		if (authent) {
			var userLogin = request.session && request.session.getUserLogin(_) || "";
			var token = {
				"serial": authent.serial || "0000000000000000",
				"user": userLogin,
				"date": datetime.now().toString(),
				"once": helpers.uuid.generate()
			};
			var md5sum = crypto.createHash('md5');
			md5sum.update(token.serial + '/' + token.date + '/' + token.once + '/' + secret, "ascii");
			token.signature = md5sum.digest("hex");
			tracer.debug && tracer.debug("helpProxyProvider: token=" + JSON.stringify(token, null, "\t"));
			headers.Authorization = "X3Doc " + new Buffer(JSON.stringify(token)).toString('base64');
		}

		var cacheControl = headers["cache-control"];
		var mustReval = false;
		var proxyReval = false;
		if (cacheControl && cacheControl.length > 0) {
			var cc;
			if (cacheControl.lastIndexOf(",") > 0) {
				cc = cacheControl.split(",");
			} else {
				cc = [cacheControl];
			}

			for (var i = 0; i < cc.length; i++) {
				if (!mustReval && cc[i].trim() == "must-revalidate") {
					mustReval = true;
				}
				if (!proxyReval && cc[i].trim() == "proxy-revalidate") {
					proxyReval = true;
				}
			}

			if (!mustReval) {
				cacheControl = cacheControl + ", must-revalidate,";
			}
			if (!proxyReval) {
				cacheControl = cacheControl + ", proxy-revalidate";
			}
		} else {
			cacheControl = "must-revalidate, proxy-revalidate";
		}

		headers["cache-control"] = cacheControl;
		headers['accept-encoding'] = 'deflate';
		var hostHeader = (config.help && config.help.lowercaseHeader) ? "host" : "Host";
		headers[hostHeader] = baseUri.host || headers['host'] || headers['Host'];

		tracer.debug && tracer.debug("helpProxyProvider: original request.url=" + url0);
		var options = {
			url: url.resolve(rootUrl, url0),
			method: "GET",
			headers: headers
		};

		tracer.debug && tracer.debug("helpProxyProvider: rootUrl=" + rootUrl + ", request.url=" + url0 + "\n>>> options=" + sys.inspect(options));
		var helpRequest = httpClient.httpRequest(_, options);
		for (var i = 0; i < content.length; i++) {
			helpRequest.write(_, content[i]);
		}
		var helpResponse = helpRequest.end().response(_);
		tracer.debug && tracer.debug("helpProxyProvider:\n>>> helpResponse.headers=" + sys.inspect(helpResponse.headers) + "\n>>> helpResponse.statusCode=" + helpResponse.statusCode);
		return helpResponse;
	};
}

// read everything from response so that resources can be freed internally
function _readResponse(_, response) {
	if (response) {
		try {
			var buf;
			while (buf = response.read(_)) {};
		} catch (e) {} // ignore error
	}
}


function plainReply(response, status, message, headers) {
	headers = headers || {};
	headers['content-type'] = "text/plain";
	response.writeHead(status, headers);
	response.end(message, 'utf8');
}


exports.dispatcher = function(config) {
	var lic, authent = {};
	return function(_, request, response) {
		if (!lic) {
			lic = check.validLicenses();
			authent.serial = JSON.stringify(lic.map(function(l) {
				return [l.productCode, l.serial];
			}));
			tracer.debug && tracer.debug("dispatcher: init serials=" + authent.serial);
		}
		var rel;
		var uri = url.parse(request.url, true),
			langParam = uri.query.language;
		var matches = /^\/help\/(\w{2}[_-]\w{2})\/([^\/]*)\/([^\/]*)\/([^\/]*)\/(.*)/.exec(uri.pathname);
		var langSeg, i = 0;

		if (!matches) {
			matches = /^\/help\/([^\/]*)\/([^\/]*)\/([^\/]*)\/(.*)/.exec(uri.pathname);
		} else {
			langSeg = matches[1];
			i = 1;
		}

		if (!matches) {
			matches = /^\/help\/(\w{2}[_-]\w{2})\/(.*)/.exec(uri.pathname);
			if (!matches) {
				matches = /^\/help\/(.*)/.exec(uri.pathname);
			} else {
				langSeg = matches[1];
				i = 1;
			}
			if (matches) {
				rel = matches[i + 1];
			} else {
				return plainReply(response, 400, locale.format(module, "badUrl", request.url));
			}
		} else {
			var application = matches[i + 1];
			// ignore contract and dataset
			var remain = matches[i + 4];

			if (application === "syracuse") {
				rel = 'V7DEV/' + remain;
			} else if (application === "x3") {
				rel = remain;
				if (remain.indexOf('.') === -1) rel += ".htm";
			} else {
				return plainReply(response, 404, locale.format(module, "appNotFound", application));
			}
		}

		// Set up the urls that will be used to find help
		var helpConfig = (config.help || {});
		var providerName = [];
		var provider = [];

		// If help is configured as local it will override the all of the urls
		if (helpConfig.local) {
			var p = helpProvider;

			if (!p) {
				return plainReply(response, 404, locale.format(module, "localHelpConfig"));
			} else {
				provider.push(p);
				providerName.push("local");
			}
		} else {
			// Check to see if the endpoint has a help url configured as
			// this will be the first place we check
			var up = request.session && request.session.getUserProfile(_);
			var ep = up && up.selectedEndpoint(_);

			if (ep && ep.helpBaseUrl(_)) {
				tracer.debug && tracer.debug("helpDispatcher: endpoint help url=[" + ep.helpBaseUrl(_) + "]");
				provider.push(helpProxyProvider(ep.helpBaseUrl(_), authent));
				providerName.push(ep.helpBaseUrl(_));
			}

			// Configuration provides the next base URL
			if (helpConfig.url) {
				provider.push(helpProxyProvider(helpConfig.url, authent));
				providerName.push(helpConfig.url);
			}


			var _contract = (ep && ep.contract(_)) || "erp";
			if (_contract === "collaboration") _contract = "erp";
			// And finally fall back to the server in the cloud
			var version;
			if (ep) version = require('syracuse-collaboration/lib/helpers').AdminHelper.getProductVersionByEndpoint(ep.dataset(_));
			tracer.debug && tracer.debug("Version from endpoint " + ep.dataset(_) + ": " + version);
			if (!version) {
				// get version from version.json
				try {
					var versionFile = patchtools.readVersionFile(patchtools.BASE_DIRECTORY, _);
					version = versionFile.relNumber;
					tracer.debug && tracer.debug("From version.json: " + version);
					if (version.indexOf("2.999.") === 0) version = 9;
					else if (version.indexOf("2.") === 0) version = 7;
					else {
						var r = /^(\d+\.\d+)\./.exec(version);
						// cut to major.minor version
						if (r) version = r[1];
						else version = "";
					}
				} catch (e) {
					console.error(e.stack);
				}
			}
			// add version only if it is at least 8 (major version)
			tracer.debug && tracer.debug("Update number " + version);
			if (version) {
				version = version.toString();
				var index = version.indexOf('.');
				var major = index >= 0 ? version.substr(0, index) : version;
				if (+major < 8) version = '';
			}
			tracer.debug && tracer.debug("URL " + "http://online-help.sageerpx3.com/" + _contract + (version ? "/" + version + "/" : "/"));

			provider.push(helpProxyProvider("http://online-help.sageerpx3.com/" + _contract + (version ? "/" + version + "/" : "/"), authent));
			providerName.push("http://online-help.sageerpx3.com/" + _contract);
		}
		// use relative path for more flexible in premise infrastructure
		var urls = [];
		langParam && urls.push(langParam + '/' + rel);
		langSeg && urls.push(langSeg + '/' + rel);
		urls.push(locale.current + '/' + rel);
		// last chance with en_US language
		urls.push('en-US/' + rel);

		tracer.debug && tracer.debug("helpDispatcher: urls=[" + urls + "]");
		var content = [];
		var buf;
		while ((buf = request.read(_))) {
			content.push(buf);
		}
		buf = undefined;

		for (var k = 0; k < provider.length; k++) {
			for (var j = 0; j < urls.length; j++) {
				tracer.debug && tracer.debug("helpDispatcher: Request number: " + j);
				// request.url = urls[j];
				var helpResponse;
				try {
					helpResponse = provider[k](_, urls[j], content, request);
				} catch (e) {
					// Error is thrown by httpClient when request times out
					_readResponse(_, helpResponse);
					return plainReply(response, 404, locale.format(module, "noHelpServer", providerName[k]));
				}
				tracer.debug && tracer.debug("helpDispatcher: is status code ok: " + (helpResponse && helpResponse.statusCode < 400));
				tracer.debug && tracer.debug("helpDispatcher: is last request: " + (k === (provider.length - 1) && j === (urls.length - 1)));
				// If response has error code status, continue until last chance
				if ((helpResponse && helpResponse.statusCode < 400) || (k === (provider.length - 1) && j === (urls.length - 1))) {
					var buf;
					response.writeHead(helpResponse.statusCode, helpResponse.headers);
					while ((buf = helpResponse.read(_))) {
						response.write(_, buf);
					}
					response.end();
					return;
				} else
					_readResponse(_, helpResponse);
			}
		}
		// Must never walk here
		return plainReply(response, 404, locale.format(module, "helpNotFound", rel));
	};
};