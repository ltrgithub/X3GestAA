"use strict";

var helpers = require("syracuse-core/lib/helpers");
var forEachKey = helpers.object.forEachKey;
var tracer = helpers.debug.tracer("sdata.internals");
var flows = require('streamline/lib/util/flows');

// applying events

function _sendEvent(_, context, dbHandle, event) {
	tracer && tracer("event: " + event);
	var fn = context.entity.$events[event];
	if (dbHandle && fn) return fn(_, context, dbHandle);
	return null;
}

function _sendEvents(_, context, dbHandles, event) {
	if (!context.entity.$events[event]) return;
	dbHandles.forEach_(_, function(_, dbHandle, i) {
		_sendEvent(_, context, dbHandle, event);
	});
}

function _fetchRelated(_, context, dbHandle, meta) {
	flows.eachKey(_, meta.$relations, function(_, name, rel) {
		if (!rel.isSelected && !rel.needsThumb) return;
		tracer && tracer(name + ": fetching")
		if (rel.isPlural) {
			var query = dbHandle[name];
			rel.defaultOrder.forEach(function(order) {
				query = query.order(order[0], order[1]);
			});
			var relDbHandles = query.list(context.transaction, _);
			tracer && tracer(name + ": fetch got " + relDbHandles.length + " related dbHandles");
			relDbHandles.forEach_(_, function(_, relDbHandle, i) {
				_fetchRelated(_, context, relDbHandle, rel);
			});
		} else {
			var relDbHandle = dbHandle.fetch(context.transaction, name, _);
			if (relDbHandle) _fetchRelated(_, context, relDbHandle, rel);
		}
	});
}

// Conversion of where clause into persistencejs queries
// For now, only supports conjunction of simple "property op value" clauses.
// Will need to improve persistencejs to support more complex ones.

function _applyCondition(query, exp) {
	if (exp.children.length != 2) throw new Error("invalid where clause: expected binary expression, got " + exp);
	if (exp.children[0].type != "identifier") throw new Error("invalid where clause: expected identifier, got " + exp.children[0]);
	if (exp.children[1].type != "literal") throw new Error("invalid where clause: expected literal, got " + exp.children[1]);
	return query.filter(exp.children[0].value, exp.value.code, exp.children[1].value)
}

function _applyWhere(query, where) {
	if (!where) return query;
	switch (where.type) {
		case "literal":
			throw new Error("invalid where clause: expected condition, got literal");
		case "function":
			throw new Error("NIY: function in where clause");
		case "operator":
			switch (where.value.code) {
				case "and":
					return _applyWhere(_applyWhere(query, where.children[0]), where.children[1]);
				case "or":
					throw new Error("NIY: 'or' operator in where clause");
				default:
					return _applyCondition(query, where);

			}
			break;
		default:
			throw new Error("internal error: bad expression type: " + where.type);
	}
}

exports.fetchDbHandle = function(_, context) {
	if (context.instanceId == null) return null;
	var parameters = context.parameters;
	var query = context.entity.dbFactory.all(context.session).filter('id', '=', context.instanceId);
	forEachKey(context.meta.$relations, function(name, rel) {
		if (rel.isSelected) {
			if (!rel.isPlural) query = query.prefetch(name);
		}
	});
	var results = query.list(context.transaction, _);
	context.dbHandle = results.length == null ? null : results[0];
	if (!context.dbHandle) {
		context.dbHandle = _sendEvent(_, context, context.entity, "dbHandleNotFound");
		if (!context.dbHandle) {
			return null;
		}
	}
	_fetchRelated(_, context, context.dbHandle, context.meta);
	_sendEvent(_, context, context.dbHandle, "afterRead");
	return context.dbHandle;
}

function _toHex(n) {
	if (n < 16) return "0" + n.toString(16);
	return n.toString(16);
}

function _bufToHex(b) {
	var out = [],
		len = b.length;
	for (var i = 0; i < len; i++) {
		out[i] = _toHex(b[i]);
	}
	return out.join("");
}

exports.fetchDbHandleProperty = function(_, context) {
	if (context.instanceId == null) return null;
	var prop = context.entity.$properties[context.propertyName];
	if (prop.$isLazy) {
		var rows = context.transaction.executeSql("SELECT " + context.propertyName + " FROM " + context.entity.className + " where id=unhex(?)", [helpers.uuid.toString32(context.instanceId)], _);
		if (rows && rows.length) {
			var value = rows[0][context.propertyName];
			// temporary hack
			if (prop.type == "binary" && !(value instanceof Buffer)) value = new Buffer(value, "binary");
			return value;
		} else return null;
	} else {
		var query = context.entity.dbFactory.all(context.session).filter('id', '=', context.instanceId);
		var results = query.list(context.transaction, _);
		context.dbHandle = results.length == null ? null : results[0];
		return context.dbHandle[context.propertyName] + "";
	}
}
exports.fetchDbHandles = function(_, context) {
	var parameters = context.parameters;
	var query = context.scratch.query.limit(parameters.count).skip(parameters.startIndex - 1);
	if (parameters.orderBy.length) {
		parameters.orderBy.forEach(function(orderBy) {
			query = query.order(orderBy.binding, !orderBy.descending);
		});
	} else {
		context.meta.defaultOrder.forEach(function(order) {
			query = query.order(order[0], order[1]);
		})
	}
	forEachKey(context.meta.$relations, function(name, rel) {
		if (rel.isSelected) {
			if (!rel.isPlural) query = query.prefetch(name);
		}
	});
	query = _applyWhere(query, context.parameters.where);

	var dbHandles = query.list(context.transaction, _);
	if (dbHandles.length == parameters.count) {
		var countQuery = _applyWhere(context.scratch.query, context.parameters.where);
		context.totalCount = countQuery.count(context.transaction, _);
	} else {
		context.totalCount = dbHandles.length;
	}
	dbHandles.forEach_(_, function(_, dbHandle, i) {
		_fetchRelated(_, context, dbHandle, context.meta);
	});
	_sendEvents(_, context, dbHandles, "afterRead");
	return dbHandles;
}
exports.updatePropertyDbHandle = function(_, context, value) {
	// work only for binary props
	if (context.instanceId == null) return null;
	var prop = context.entity.$properties[context.propertyName];
	if (prop.$isLazy) {
		context.transaction.executeSql("UPDATE " + context.entity.className + " SET " + context.propertyName + "=0x" + _bufToHex(value) + " where id=unhex(?)", [helpers.uuid.toString32(context.instanceId)], _);
		context.transaction.executeSql("COMMIT", [], _);
		return value;
	} else return null;
}