"use strict";

var PdfDocument = require('streamline-pdfkit');
var stylesheet = require('./stylesheet');

var fs = require('fs');
var path = require('path');
var streams = require('streamline/lib/streams/server/streams');
var helpers = require('syracuse-core/lib/helpers');
var glob = require('streamline/lib/globals');
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var time = require('syracuse-core/lib/types/time');
var debug = false;

exports.render = function(_, context, data, proto) {
    //console.log(data);
    var doc = PdfDocument.create(_, {
        size: 'A4',
        layout: data.$resources ? 'landscape' : 'portrait'
    });
    //doc.font(path.join(__dirname, '../../../pdfkit/demo/fonts/PalatinoBold.ttf'));
    var baseProto = proto;

    var pageUrl = (context.request.headers.referer || '');
    pageUrl = pageUrl.substring(0, pageUrl.indexOf('?'));

    var sst = stylesheet.create(_),
        cssValue = sst.cssValue;

    function format(expression, proto, res) {
        return expression && expression.replace(/\{(.*?)\}/g, function(key) {
            key = key.substring(1, key.length - 1);
            //console.log("key=" + key + ", res=" + res[key] + ", data=" + data[key] + ", proto=" + proto[key] + ", baseProto=" + baseProto[key])
            return res[key] || data[key] || proto[key] || baseProto[key];
        });
    }

    function clone(options) {
        return Object.keys(options).reduce(function(obj, key) {
            obj[key] = options[key];
            return obj;
        }, {})
    }

    var cx = {};

    function setColor(color) {
        if (color && color !== cx.color) {
            doc.fillColor(color);
            cx.color = color;
        }
        return doc;
    }

    function setFontStyle(_, style) {
        var font = style.font;
        if (font) {
            if (font.family && font.family !== cx.fontFamily) {
                doc.font(_, font.family);
                cx.fontFamily = font.family;
            }
            if (font.size && font.size !== cx.fontSize) {
                doc.fontSize(font.size);
                cx.fontSize = font.size;
            }
        }
        if (style.color) {
            doc.fillColor(style.color);
            cx.color = style.color;
        }
    }

    function setFont(_, clas) {
        setFontStyle(_, sst.getStyle(clas));
        return doc;
    }

    doc.textLink = function(s, url, x, y, options) {
        if (!url) return doc.text(s, x, y, options);
        var y0 = doc.y;
        options = clone(options);
        var color = cssValue('link', 'color', 'blue')
        options.underlineColor = color;
        options.url = url;
        return doc.fillColor(color).text(s, x, y, options).fillColor(cx.color);
    }

    function getUrl(prop, val, res) {
        if (prop.$format === '$email') return 'mailto:' + val;
        var url = prop.$links && prop.$links.$details && prop.$links.$details.$url;
        return url && format(url, proto, res);
    }

    function mapUrl(url) {
        return (url && /^http:.*/.test(url)) ? pageUrl + "?url=" + encodeURIComponent(url) : url;
    }

    function mapProperties(_, fn) {
        return Object.keys(proto.$).filter(function(name) {
            return name[0] !== '$';
        }).map_(_, function(_, name, i) {
            return fn && fn(_, proto.$[name], name, i)
        });
    }

    function toStr(val) {
        return val == null ? '' : val.toString();
    }

    function sum(vals) {
        return vals.reduce(function(result, w) {
            return result + w;
        }, 0);
    }

    function splitVal(str, url, split) {
        return split ? str.split(' ').map(function(s) {
            return {
                str: s,
                url: url
            };
        }) : [{
            str: str,
            url: url
        }]
    }

    function getImage(_, val) {
        return; // see later
        if (!val || !val.$url) return;
        //var url = format(val.$url || prop.$url, prop, res);
        console.log("LOADING IMAGE: " + val.$url)
        var image = val.$data || (val.$data = streams.httpRequest({
            url: val.$url,
            headers: {
                cookie: context.httpSession.cookie,
                accept: "image"
            }

        }).end().response(_).readAll(_));
        //fs.writeFile(__dirname + "/good.jpeg", image, _);
        return {
            str: '',
            url: val.$url,
            data: image,
        };
    }

    function segs(_, res, prop, name, split) {
        var val = res[name];
        //console.log(name + ": " + prop.$type + " val=" + val)
        if (val == null) return [];
        switch (prop.$type) {
        case 'application/x-collection':
            return (val || []).reduce(function(r, v, i) {
                var url = mapUrl(format(prop.$item.$url, prop.$item, v));
                var str = format(prop.$item.$value, prop.$item, v);
                return r.concat(splitVal(str, url, split));
            }, []);
        case 'application/x-reference':
            var url = mapUrl(format(prop.$links.$details.$url, prop, val));
            var str = format(prop.$value, prop, val);
            return splitVal(str, url, split);
        default:
/*
            if ((val.$type || prop.$type).indexOf('image') >= 0) {
                var image = getImage(_, res, prop, val)
                image.width = (image.height = 3 * doc.currentLineHeight(true));
                return [image];
            }*/
            var url = mapUrl(getUrl(prop, val, res));
            val = val == null ? '' : val.toString();
            return splitVal(val, url, split);
        }
    }

    var Box = helpers.defineClass(function(clas, meta, data) {
        //console.log(clas + ": meta=" + meta.$type + "(" + meta.$title + "), data=" + data);
        this.clas = clas;
        this.meta = meta;
        this.data = data;
        this.style = sst.boxStyle(clas);
        // coordinates describe border (margin excluded).
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
    }, null, {
        place: function(parent, before, above) {
            if (before) {
                this.x = before.x + before.width + Math.max(before.style.margin.right, this.style.margin.left);
            } else {
                this.x = parent.x + parent.style.border.left.width + parent.style.padding.left + this.style.margin.left;
            }
            if (above) {
                this.y = above.y + above.height + Math.max(above.style.margin.bottom, this.style.margin.top);
            } else {
                this.y = parent.y + parent.style.border.top.width + parent.style.padding.top + this.style.margin.top;
            }
            return this;
        },
        fill: function(_, width) {
            this.width = width;
            if (typeof this.data === 'string') {
                setFontStyle(_, this.style);
                var border = this.style.border;
                var padding = this.style.padding;
                this.height = border.top.width + padding.top + padding.bottom + border.bottom.width;
                this.height += doc.currentLineHeight();
            }
            return this;
        },
        inner: {
            get: function() {
                var border = this.style.border;
                var padding = this.style.padding;
                return this.width - border.left.width - padding.left - padding.right - border.right.width;
            }
        },
        setWidths: function(_) {
            setFontStyle(_, this.style);
            switch (this.meta) {
            case 'application/x-string':
                //segs(_, r, prop, col.bind, true).forEach(function(seg) {
                //    col.minWidth = Math.max(col.minWidth, seg.width || doc.widthOfString(seg.str + ' '));
                //});
                this.minWidth = doc.widthOfString(this.data + ' ');
                this.maxWidth = doc.widthOfString(this.data + ' ');
                break;
            case 'image':
                this.minWidth = 3 * doc.currentLineHeight();
                this.maxWidth = 3 * doc.currentLineHeight();
                break;
            default:
                this.minWidth = 0;
                this.maxWidth = 0;
            }
            //console.log("setWidths: " + this);
            return this;
        },
        setHeight: function(last) {
            var border = this.style.border;
            var padding = this.style.padding;
            if (last) {
                this.height = last.y + last.height - this.y;
            } else {
                this.height = border.top.width + padding.top;
            }
            this.height += padding.bottom + border.bottom.width;
        },
        draw: function(_) {
            var bg = this.style.background,
                border = this.style.border,
                padding = this.style.padding,
                stext = this.style.text;
            if (bg) {
                if (bg.color) doc.roundedRect(this.x, this.y, this.width, this.height, 5).fill(bg.color);
                var bw, bc;
                if ((bc = border.top.color) && ((bw = border.top.width) || border.bottom.width || border.left.width || border.right.width)) {
                    if (bw === border.bottom.width && bw === border.left.width && bw === border.right.width && //
                    bc === border.bottom.color && bc === border.left.color && bc === border.right.color) {
                        doc.lineWidth(bw);
                        doc.roundedRect(this.x, this.y, this.width, this.height, 5).stroke(bc);
                    }
                }
            }
            var x = this.x + border.left.width + padding.left,
                y = this.y + border.top.width + padding.top,
                inner = this.inner;
            if (this.meta === 'application/x-string') {
                setFontStyle(_, this.style);
                doc.text(this.data, x, y, {
                    width: inner,
                    align: (stext && stext.align) || 'left'
                });
            } else if (this.meta === 'image') {
                var image = this.data;
                if (image) {
                    doc.image(_, image.data, x, y, {
                        fit: [image.width, image.height]
                    }).link(x, y, image.width, image.height, image.url);
                }
            }
            this.title && this.title.draw(_);
            this.value && this.value.draw(_);
            this.items && this.items.forEach_(_, function(_, b) {
                b.draw(_);
            });
            this.rows && this.rows.forEach_(_, function(_, b) {
                b.draw(_);
            });
            return this;
        },
        toString: function() {
            var self = this;
            return '{' + Object.keys(self).map(function(k) {
                return k + ': ' + (Array.isArray(self[k]) ? '[' + self[k].length + ']' : self[k]);
            }) + '}';
        },
    });

    function buildBox(article, meta, data, clas, title) {
        clas = clas || article.$category || (article.$bind ? 'property' : 'layout');
        title = title || (data && data.$title) || article.$title || (meta && meta.$title);
        var box = new Box(clas, meta, data);
        if (title) {
            box.title = new Box(clas + '-title', 'application/x-string', title);
        }
        if (article.$bind) {
            box.layoutType = article.$items ? 'table' : 'property';
            box.bind = article.$bind;
        } else {
            box.layoutType = article.$layoutType || "stack";
            box.layoutSubType = article.$layoutSubType;
        }
        var items = article.$items || (article.$layout && article.$layout.$items);
        box.items = items && items.map(function(item) {
            var m = meta;
            if (box.layoutType === 'table') m = m.$item;
            var m = (m.$ && item.$bind) ? m.$[item.$bind] : m;
            var d = (data && item.$bind) ? data[item.$bind] : data;
            if (m && m.$url && d && !d.$url) {
                d.$url = format(m.$url, meta, data);
            }
            return buildBox(item, m, d);
        });
        return box;
    }

    function objText(val, prop) {
        return prop && prop.$value ? format(prop.$value, proto, val) : (val != null ? val.toString() : '');
    }

    function valueBox(_, box) {
        var prop = box.meta;
        console.log(prop.$type);
        var val = box.data;
        var type = 'application/x-string';
        if (val != null && prop) {
            switch (prop.$type) {
            case 'application/x-string':
            case 'application/x-integer':
            case 'application/x-decimal':
            case 'application/x-boolean':
            case 'application/x-choice':
                val = val.toString();
                break;
            case 'application/x-date':
                val = date.parse(val).toString(glob.context.localePreferences.shortDate);
                break;
            case 'application/x-datetime':
                val = datetime.parse(val).toString(glob.context.localePreferences.shortDatetime);
                break;
            case 'application/x-time':
                val = time.parse(val).toString(glob.context.localePreferences.shortTime);
                break;
/*
            case 'application/x-collection':
                return (val || []).map(function(v) {
                    return objText(v, prop.$item);
                });
            case 'application/x-reference':
                return [objText(val, prop.$item)];
                */
            case 'image':
                type = 'image';
                val = val.$url ? getImage(_, val) : null;
                break;
            default:
                val = prop.$type;
            }
            return val != null ? new Box('property-value', type, val) : null;
        }
    }

    function computeBox(_, box) {
        var style = box.style;
        var inner = box.inner;
/*
        // discount margins
        var dx = Math.max(0, style.margin.left - prevMargin.width);
        var dy = Math.max(0, style.margin.top - prevMargin.height);
        x += dx;
        y += dy;
        box.x = x;
        box.y = y;
        box.margin = style.margin || margins0;
        avail -= dx + style.margin.right;
        // discount border and padding
        var border = style.border;
        x += border.left.width + style.padding.left;
        var inner = avail - (border.left.width + style.padding.left + style.padding.right + border.right.width);
        y += border.top.width + style.padding.top;

        var pm = {
            width: 0,
            height: 0
        };*/
        switch (box.layoutType) {
        case 'property':
            box.title.place(box).fill(_, box.title.style.width);
            box.value = valueBox(_, box);
            //box.value = new Box('property-value', box.meta, box.data);
            //if (box.value.texts == null) box.value.image = getImage(_, res, prop, res[box.bind]);
            box.value && box.value.place(box, box.title, null).fill(_, inner - box.title.style.width);
            box.setHeight(box.value || box.title);
/*
            var prop = proto.$[box.bind];
            var x0 = x;
            computeBox(_, box.title, pm, res, x, y, inner);
            pm.width = box.title.margin.right;
            x = box.title.x + box.title.width;
            box.value = new Box('property-value', prop, res[box.bind]);
            box.value.texts = getTexts(_, res, box.bind);
            if (box.value.texts == null) box.value.image = getImage(_, res, prop, res[box.bind]);
            computeBox(_, box.value, pm, res, x, y, x0 + inner - x);
            box.width = avail;
            y += Math.max(box.title.height, box.value.height);*/
            break;
        case 'columns':
            box.title && box.title.place(box).fill(_, inner);
            var widths = box.layoutSubType.split(',').map(function(s) {
                return parseInt(s, 10);
            });
            var total = Math.max(1, sum(widths));
            var prev = null,
                tallest = null;
            widths.forEach_(_, function(_, w, i) {
                var b = box.items[i];
                if (!b) b = new Box('layout');
                b.place(box, box.title, prev).fill(_, inner * w / total);
                computeBox(_, b);
                tallest = tallest && tallest.height > b.height ? tallest : b;
                prev = b;
            });
            box.setHeight(tallest || box.title);
            break;
        case 'table':
            box.title && box.title.place(box).fill(_, inner);
/*
            box.width = avail;
            var prop = proto.$[box.bind];
            var y0 = y;
            if (prop.$title) {
                computeBox(_, box.title, pm, res, x, y, inner);
                pm.height = box.title.margin.bottom;
                y += box.title.height;
            }*/
/*
            box.items.forEach(function(col) {
                //var prop = proto.$.$resources.$item.$[col.bind];
                delete col.title;
                col.layoutType = 'stack';
                col.value = new Box('column', 'application/x-string', col.meta.$title);
                //col.texts = [prop.$title];
                //console.log(col);
            });*/

            var resources = box.data || [];
            var m = box.meta.$item;
            box.rows = resources.map_(_, function(_, r) {
                var row = new Box('row', m, r);
                // box.items are columns
                row.items = box.items.map_(_, function(_, col) {
                    var prop = col.meta;
                    var cell = new Box('cell', prop, r[col.bind]);
                    cell.value = valueBox(_, cell);
                    //cell.texts = getTexts(_, r, col.bind, prop);
                    //if (cell.texts == null) cell.image = getImage(_, r, prop, r[col.bind]);
                    return cell;
                })
                return row;
            });
            //var colStyle = sst.boxStyle('col');
            //var cellStyle = sst.boxStyle('cell');
            box.items.forEach_(_, function(_, col) {
                col.title.setWidths(_);
                col.minWidth = col.title.minWidth;
                col.maxWidth = col.title.maxWidth;
/*
                // todo: check next one
                var prop = proto.$.$resources.$item.$[col.bind];
                setFontStyle(_, colStyle);
                col.minWidth = measureMin(prop.$title);
                col.maxWidth = doc.widthOfString(prop.$title + ' ');
                setFontStyle(_, cellStyle);
                
                //console.log("1: " + col.bind + ": min=" + col.minWidth + ", max=" + col.maxWidth);
                resources.forEach_(_, function(_, r) {
                    segs(_, r, prop, col.bind, true).forEach(function(seg) {
                        col.minWidth = Math.max(col.minWidth, seg.width || doc.widthOfString(seg.str + ' '));
                    });
                    segs(_, r, prop, col.bind, false).forEach(function(seg) {
                        col.maxWidth = Math.max(col.maxWidth, seg.width || doc.widthOfString(seg.str + ' '));
                    });
                });*/
                //console.log("2: " + col.bind + ": min=" + col.minWidth + ", max=" + col.maxWidth);
            });
            box.rows.forEach_(_, function(_, row) {
                row.items.forEach_(_, function(_, cell, i) {
                    var col = box.items[i];
                    var value = cell.value;
                    if (value) {
                        value.setWidths(_);
                        col.minWidth = Math.max(col.minWidth, value.minWidth);
                        col.maxWidth = Math.max(col.maxWidth, value.maxWidth);
                    }
                });
            });

            var minSum = box.items.reduce(function(v, col) {
                return v + col.minWidth;
            }, 0);
            var maxSum = box.items.reduce(function(v, col) {
                return v + col.maxWidth;
            }, 0);
/*setFontStyle(_, colStyle);
            var height = 0;
            var x0 = x;
            var y0 = y;
            pm.width = 0;*/
            //console.log("avail=" + avail + ", minSum=" + minSum + ", maxSum=" + maxSum);
            var prev = null,
                tallest = null,
                last = box.title,
                above = box.title;
            box.items.forEach_(_, function(_, col) {
                var w;
                if (inner > maxSum) w = col.maxWidth + (inner - maxSum + 1) * (col.maxWidth + 1) / (maxSum + 1);
                else if (inner > minSum) w = col.minWidth + (inner - minSum + 1) * (col.maxWidth - col.minWidth + 1) / (maxSum - minSum + 1);
                else w = col.minWidth;
                col.place(box, prev, above).fill(_, w);
                col.title && col.title.place(col).fill(_, col.inner);
                col.setHeight(col.title);
                tallest = tallest && tallest.height > col.height ? tallest : col;
                prev = col;
/*
                //console.log("3: " + col.bind + ": min=" + col.minWidth + ", max=" + col.maxWidth + ", w=" + width);
                computeBox(_, col, pm, res, x, y0, width);
                pm.width = col.margin.right;
                x += width;
                y = Math.max(y, y0 + col.height);
                */
            });
            box.items.forEach(function(col) {
                col.height = tallest.height;
            });
            last = tallest || last;
            box.rows.forEach_(_, function(_, row) {
                above = tallest;
                prev = null;
                tallest = null;
                //x = x0;
                //y0 = y;
                row.items.forEach_(_, function(_, cell, i) {
                    var col = box.items[i];
                    cell.place(box, prev, above).fill(_, col.inner);
                    cell.value && cell.value.place(cell).fill(_, cell.inner);
                    cell.setHeight(cell.value);
                    tallest = tallest && tallest.height > cell.height ? tallest : cell;
                    prev = cell;
/*
                    computeBox(_, cell, pm, row.res, x, y0, col.width);
                    pm.width = cell.margin.right;
                    x += cell.width;
                    y = Math.max(y, y0 + cell.height);*/
                });
                row.items.forEach(function(cell) {
                    cell.height = tallest.height;
                });
                last = tallest || last;
            });
            box.setHeight(last);
            break;
        default:
            // will see about flow mode later.
            //box.width = style.width != null ? style.width : avail;
            var above = null;
            above = (box.title && box.title.place(box, null, above).fill(_, inner)) || above;
            above = (box.value && box.value.place(box, null, above).fill(_, inner)) || above;
/*
            if (box.texts) {
                setFontStyle(_, style);
                y += box.texts.length * doc.currentLineHeight(true);
            }
            var image = box.image;
            if (image) {
                image.width = image.width || doc.currentLineHeight(true) * 3;
                image.height = image.height || doc.currentLineHeight(true) * 3;
                y += image.height;
            }
            */
            box.items && box.items.forEach_(_, function(_, b) {
                b.place(box, null, above);
                b.width = inner;
                computeBox(_, b);
                above = b;
/*y += pm.height;
                computeBox(_, b, pm, res, x, y, inner);
                pm.height = b.margin.bottom;
                y = b.y + b.height;*/
            });
            box.setHeight(above);
            break;
        }
        //y += style.padding.bottom + style.border.bottom.width;
        //box.height = y - box.y;
    }

    function measureMin(str) {
        return str.split(' ').reduce(function(w, s) {
            return Math.max(w, doc.widthOfString(s + ' '));
        }, 0);
    }

    try {
        var bodyWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
        var bodyHeight = doc.page.height - doc.page.margins.top - doc.page.margins.bottom;
        var title = format(data.$description || proto.$description || data.$title || proto.$title, proto, data);
        debug && doc.roundedRect(doc.page.margins.left, doc.page.margins.top, bodyWidth, bodyHeight, 5).stroke('red');
        var res = data;
        var rootBox = buildBox(proto.$article, proto, res, 'page', title);
        rootBox.x = doc.x;
        rootBox.y = doc.y;
        rootBox.width = bodyWidth;
        //measureBox(_, rootBox, res);
        computeBox(_, rootBox);
/*, {
            width: 0,
            height: 0
        }, res, doc.x, doc.y, bodyWidth);*/
        rootBox.height = bodyHeight;
        rootBox.draw(_);
    } catch (ex) {
        console.log(ex.stack);
        setFont(_, 'error').text(ex.message + "\n" + ex.stack);
    }
    doc.save();
    //doc.write("/users/bruno/Dev/junk/toto.pdf")
    return doc.output(_);
}
/*if (false && data.$resources) {
            setFont(_, 'page-title').text(title, {
                align: cssValue('page-title', 'text-align', 'center')
            });
            doc.moveDown().fontSize(10);

            proto = proto.$.$resources.$item;
            setFont(_, 'column-title');
            // note: always measure words with trailing space because this is how pdfkit's word wrap cuts them.
            // otherwise longuest word gets shifted one line down
            var minWidths = mapProperties(_, function(_, prop, name, i) {
                return measureMin(prop.$title);
            });
            var maxWidths = mapProperties(_, function(_, prop, name, i) {
                return doc.widthOfString(prop.$title + ' ');
            });
            var maxWidths = minWidths.slice(0);
            var n = 1;
            setFont(_, 'column-value');
            data.$resources.forEach_(_, function(_, res) {
                //console.log(res);
                mapProperties(_, function(_, prop, name, i) {
                    segs(_, res, prop, name, true).forEach(function(seg) {
                        minWidths[i] = Math.max(minWidths[i], seg.width || doc.widthOfString(seg.str + ' '));
                    });
                    segs(_, res, prop, name, false).forEach(function(seg) {
                        maxWidths[i] = Math.max(maxWidths[i], seg.width || doc.widthOfString(seg.str + ' '));
                    });
                });
                n++;
            });

            // here: get css extra size info            
            var dw = 0,
                dh = 2;
            var minSum = sum(minWidths);
            var maxSum = sum(maxWidths);
            bodyWidth = Math.min(bodyWidth, maxSum + n * dw);
            var avail = Math.max(bodyWidth - minSum - n * dw, 0);
            var widths = minWidths.map(function(w, i) {
                return w + avail * (maxWidths[i] - minWidths[i] + 1) / (maxSum - minSum + 1);
            })
            var totalWidth = sum(widths);
            //console.log("minWidths=" + minWidths.join(' '))
            //console.log("maxWidths=" + maxWidths.join(' '))
            //console.log("avail=" + avail)
            //console.log("widths=" + widths.join(' '))
            doc.scale(bodyWidth / totalWidth);
            //doc.transform(1, 1, 0, 1, 0, 0).translate(10, 20).transform(1, 0, 0, 1.5, 0, 0).scale(0.8).transform(1, -1, 0, 1, 0, 0);
            setFont(_, 'column-title');
            var x0 = doc.x,
                y0 = doc.y,
                y1 = y0,
                y2 = y0,
                x = x0;
            doc.x = x0;
            mapProperties(_, function(_, prop, name, i) {
                doc.text(prop.$title, x, y0, {
                    width: widths[i],
                    align: 'left'
                });
                x += widths[i] + dw;
                y1 = Math.max(y1, doc.y);
            });
            setFont(_, 'column-value');
            data.$resources.forEach_(_, function(_, res, i) {
                doc.strokeColor('#ddd').lineWidth(i ? 1 : 2).moveTo(x0, y1).lineTo(x0 + totalWidth, y1).stroke();
                y1 += dh;
                x = x0, y2 = y1;
                mapProperties(_, function(_, prop, name, i) {
                    segs(_, res, prop, name, false).forEach_(_, function(_, seg) {
                        //doc.y = y1;
                        if (seg.data) {
                            //console.log("IMAGE: " + seg.data.length + ", url=" + seg.url);
                            doc.image(_, seg.data, x, y1, {
                                fit: [seg.width, seg.height]
                            }).link(x, y1, seg.width, seg.height, seg.url);
                            y2 += seg.height;
                        } else {
                            //console.log("drawing " + seg.str + " at " + x + " " + y1)
                            doc.textLink(seg.str, seg.url, x, y1, {
                                width: widths[i],
                                align: 'left'
                            });
                        }
                    });
                    x += widths[i] + dw;
                    y2 = Math.max(y2, doc.y);

                });
                y1 = y2;
            });
        } else {*/