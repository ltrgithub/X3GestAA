"use strict";
/// !doc
/// 
/// # Pdf rendering
/// 
/// The Pdf rendering use the concept of [CSS boxes](http://www.w3schools.com/css/css_boxmodel.asp)
/// +------------------------------------------------------------------+
/// |                            margin                                |
/// |  (x,y)--------------------------------------------------------+  |
/// |  |                         border                             |  |
/// |  |  +------------------------------------------------------+  |  |
/// |  |  |                      padding                         |  |  |
/// |  |  |  +------------------------------------------------+  |  |  |
/// |  |  |  |                                                |  |  |  |
/// |  |  |  |              content (inner rect)              |  |  |  |
/// |  |  |  |                                                |  |  |  |
/// |  |  |  +------------------------------------------------+  |  |  |
/// |  |  |                                                      |  |  |
/// |  |  +------------------------------------------------------+  |  |
/// |  |                                                            |  |
/// |  +------------------------------------------------------------+  |
/// |                          (outer rect)                            |
/// +------------------------------------------------------------------+
///
/// The (x, y) point determines the top left point of the drawing part so it excludes the margin as it is a transparent area.
///
var PdfDocument = require('streamline-pdfkit');
var stylesheet = require('./stylesheet');

var sys = require('util');
var fs = require('fs');
var path = require('path');
var streams = require('streamline/lib/streams/server/streams');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var helpers = require('syracuse-core/lib/helpers');
var glob = require('streamline/lib/globals');
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var time = require('syracuse-core/lib/types/time');
var debug = config.pdfReport.debug;

function _logBox(box, prefix, linePrefix) {
    debug.log((linePrefix ? linePrefix : "") + (prefix ? prefix + " " : "") + "class=" + box.clas + " '" + box.data + "', parent=" + (box.parent && box.parent.clas) + ", before=" + (box.before && box.before.clas) + ", above=" + (box.above && box.above.clas));
    debug.log((linePrefix ? linePrefix : "") + "...rect={" + box.x + "," + box.y + "," + box.width + "," + box.height + //
    "}, margin={" + box.style.margin.right + ", " + box.style.margin.left + "}, padding={" + box.style.padding.right + ", " + box.style.padding.left + //
    "}, border={" + box.style.border.left.width + ", " + box.style.border.left.height + "}");
};

// to control debug feature add this fragment to your nodelocal.js file.
// pdfReport: {
//     debug: {
//         format: true,
//         data: true,
//         proto: true,
//         image: true,
//         box: true,
//         buildBox: true,
//         valueBox: true,
//         output: {
//             pdf: "pdf_report.pdf",
//             data: "pdf_data.js",
//             proto: "pdf_proto.js",
//         },
//         log: function(s) {
//             var fs = require('fs');
//             this._fd = fs.openSync("pdf_output.txt", this._fd == null ? "w" : "a");
//             fs.writeSync(this._fd, s + "\n");
//             fs.closeSync(this._fd);
//         }
//     }
// }
if (debug) debug.log = debug.log || console.log;

exports.render = function(_, context, data, proto) {
    debug && debug.log("****************************** Pdf.render **********************************\ndebug=" + sys.inspect(debug, true, null));
    debug && debug.output && debug.output.data && fs.writeFile(debug.output.data, JSON.stringify(data), "utf8", _);
    debug && debug.output && debug.output.proto && fs.writeFile(debug.output.proto, JSON.stringify(proto), "utf8", _);
    var doc = PdfDocument.create(_, {
        size: 'A4',
        layout: data.$resources ? 'landscape' : 'portrait'
    });
    var workDoc = PdfDocument.create(_, {
        size: 'A4',
        layout: data.$resources ? 'landscape' : 'portrait'
    });

    //doc.font(path.join(__dirname, '../../../pdfkit/demo/fonts/PalatinoBold.ttf'));
    var baseProto = proto;

    var pageUrl = (context.request.headers.referer || '');
    pageUrl = pageUrl.substring(0, pageUrl.indexOf('?'));

    var sst = stylesheet.create(_),
        cssValue = sst.cssValue;

    function format(expression, proto, res) {
        // debug && debug.format && debug.log("format: expression=" + expression);
        return expression && expression.replace(/\{(.*?)\}/g, function(key) {
            key = key.substring(1, key.length - 1);
            // debug && debug.format && debug.log("...key=" + key + ", res=" + res[key] + ", data=" + data[key] + ", proto=" + proto[key] + ", baseProto=" + baseProto[key])
            return res[key] || data[key] || proto[key] || baseProto[key];
        });
    }

    function clone(options) {
        return Object.keys(options).reduce(function(obj, key) {
            obj[key] = options[key];
            return obj;
        }, {})
    }

    var cx = {};

    function setColor(color) {
        if (color && color !== cx.color) {
            doc.fillColor(color);
            cx.color = color;
        }
        return doc;
    }

    function setFontStyle(_, style) {
        var font = style.font;
        if (font) {
            if (font.family && font.family !== cx.fontFamily) {
                doc.font(_, font.family);
                cx.fontFamily = font.family;
            }
            if (font.size && font.size !== cx.fontSize) {
                doc.fontSize(font.size);
                cx.fontSize = font.size;
            }
        }
        if (style.color) {
            doc.fillColor(style.color);
            cx.color = style.color;
        }
    }

    function setFont(_, clas) {
        setFontStyle(_, sst.getStyle(clas));
        return doc;
    }

    doc.textLink = function(s, url, x, y, options) {
        if (!url) return doc.text(s, x, y, options);
        var y0 = doc.y;
        options = clone(options);
        var color = cssValue('link', 'color', 'blue')
        options.underlineColor = color;
        options.url = url;
        return doc.fillColor(color).text(s, x, y, options).fillColor(cx.color);
    }

    function getUrl(prop, val, res) {
        if (prop.$format === '$email') return 'mailto:' + val;
        var url = prop.$links && prop.$links.$details && prop.$links.$details.$url;
        return url && format(url, proto, res);
    }

    function mapUrl(url) {
        return (url && /^http:.*/.test(url)) ? pageUrl + "?url=" + encodeURIComponent(url) : url;
    }

    function mapProperties(_, fn) {
        return Object.keys(proto.$).filter(function(name) {
            return name[0] !== '$';
        }).map_(_, function(_, name, i) {
            return fn && fn(_, proto.$[name], name, i)
        });
    }

    function toStr(val) {
        return val == null ? '' : val.toString();
    }

    function sum(vals) {
        return vals.reduce(function(result, w) {
            return result + w;
        }, 0);
    }

    function splitVal(str, url, split) {
        return split ? str.split(' ').map(function(s) {
            return {
                str: s,
                url: url
            };
        }) : [{
            str: str,
            url: url
        }]
    }

    function getImage(_, val) {
        return; // see later
        if (!val || !val.$url) return;
        //var url = format(val.$url || prop.$url, prop, res);
        debug && debug.image && debug.log("LOADING IMAGE: " + val.$url)
        var image = val.$data || (val.$data = streams.httpRequest({
            url: val.$url,
            headers: {
                cookie: context.httpSession.cookie,
                accept: "image"
            }

        }).end().response(_).readAll(_));
        //fs.writeFile(__dirname + "/good.jpeg", image, _);
        return {
            str: '',
            url: val.$url,
            data: image,
        };
    }

    function segs(_, res, prop, name, split) {
        var val = res[name];
        //debug.log(name + ": " + prop.$type + " val=" + val)
        if (val == null) return [];
        switch (prop.$type) {
        case 'application/x-collection':
            return (val || []).reduce(function(r, v, i) {
                var url = mapUrl(format(prop.$item.$url, prop.$item, v));
                var str = format(prop.$item.$value, prop.$item, v);
                return r.concat(splitVal(str, url, split));
            }, []);
        case 'application/x-reference':
            var url = mapUrl(format(prop.$links.$details.$url, prop, val));
            var str = format(prop.$value, prop, val);
            return splitVal(str, url, split);
        default:
            /*
            if ((val.$type || prop.$type).indexOf('image') >= 0) {
                var image = getImage(_, res, prop, val)
                image.width = (image.height = 3 * doc.currentLineHeight(true));
                return [image];
            }*/
            var url = mapUrl(getUrl(prop, val, res));
            val = val == null ? '' : val.toString();
            return splitVal(val, url, split);
        }
    }

    var Box = helpers.defineClass(function(clas, meta, data) {
        //debug.log(clas + ": meta=" + meta.$type + "(" + meta.$title + "), data=" + data);
        this.clas = clas;
        this.meta = meta;
        this.data = data;
        this.style = sst.boxStyle(clas);
        // coordinates describe border (margin excluded).
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
    }, null, {
        place: function(parent, before, above) {
            // x,y are define the visible part
            this.parent = parent;
            this.before = before;
            this.above = above;
            debug && debug.box && debug.log("\tBox.place: this=" + this.clas + " '" + this.data + "', parent=" + (parent && parent.clas) + ", before=" + (before && before.clas) + ", above=" + (above && above.clas));
            if (before) {
                this.x = before.x + before.width + Math.max(before.style.margin.right, this.style.margin.left) - this.style.margin.left;
            } else {
                this.x = parent.x + parent.style.border.left.width + parent.style.padding.left;
            }
            if (above) {
                this.y = above.y + above.height + Math.max(above.style.margin.bottom, this.style.margin.top) - this.style.margin.top;
            } else {
                this.y = parent.y + parent.style.margin.top + parent.style.border.top.width;
            }
            this.x += this.style.margin.left;
            this.y += this.style.margin.top;

            if (debug && debug.box) {
                _logBox(this, "...this", "\t");
                parent && _logBox(parent, "...parent", "\t");
                before && _logBox(before, "...before", "\t");
                above && _logBox(above, "...above", "\t");
            }
            return this;
        },
        fill: function(_, outerWidth) {
            this.setWidth(outerWidth);
            if (typeof this.data === 'string') {
                setFontStyle(_, this.style);
                var border = this.style.border;
                var padding = this.style.padding;
                this.height = border.top.width + padding.top + padding.bottom + border.bottom.width;
                this.height += doc.currentLineHeight();
            }
            if (debug && debug.box) {
                debug.log("\tBox.fill: outerWidth=" + outerWidth + ", data='" + this.data + "'");
                debug.log("\t...style=" + sys.inspect(this.style, true, null));
                _logBox(this, "\t...this")
            }
            return this;
        },
        fakeDraw: function(_, outerWidth) {
            // body...
        },
        inner: {
            get: function() {
                var border = this.style.border;
                var padding = this.style.padding;
                // margins are already substracted from the width
                return this.width - border.left.width - padding.left - padding.right - border.right.width;
            }
        },
        outer: {
            get: function() {
                var margin = this.style.margin;
                return this.width + margin.left + margin.right;
            }
        },
        setWidth: function(outerWidth) {
            var margin = this.style.margin;
            this.width = outerWidth - margin.left - margin.right;
        },
        setWidths: function(_) {
            setFontStyle(_, this.style);
            switch (this.meta) {
            case 'application/x-string':
                //segs(_, r, prop, col.bind, true).forEach(function(seg) {
                //    col.minWidth = Math.max(col.minWidth, seg.width || doc.widthOfString(seg.str + ' '));
                //});
                this.minWidth = doc.widthOfString(this.data + ' ');
                this.maxWidth = doc.widthOfString(this.data + ' ');
                break;
            case 'image':
                this.minWidth = 3 * doc.currentLineHeight();
                this.maxWidth = 3 * doc.currentLineHeight();
                break;
            default:
                this.minWidth = 0;
                this.maxWidth = 0;
            }
            //debug.log("setWidths: " + this);
            return this;
        },
        setHeight: function(last) {
            // var margin = this.style.margin;
            var border = this.style.border;
            var padding = this.style.padding;
            if (last) {
                this.height = last.y + last.height - this.y;
            } else {
                this.height = border.top.width + padding.top;
                // this.height = margin.top + border.top.width + padding.top;
            }
            this.height += padding.bottom + border.bottom.width;
            // this.height += padding.bottom + border.bottom.width + margin.bottom;
        },
        draw: function(_) {
            var bg = this.style.background,
                border = this.style.border,
                padding = this.style.padding,
                stext = this.style.text,
                bw = border.top.width,
                bc = border.top.color;
            doc.lineWidth(bw);
            bg && bg.color && doc.roundedRect(this.x, this.y, this.width, this.height, border.radius).fill(bg.color);
            //TODO: manage borders with diffrent width
            if (bc && (bw || border.bottom.width || border.left.width || border.right.width)) {
                if (bw === border.bottom.width && bw === border.left.width && bw === border.right.width && //
                bc === border.bottom.color && bc === border.left.color && bc === border.right.color) {
                    doc.roundedRect(this.x, this.y, this.width, this.height, border.radius).stroke(bc);
                }
            }
            var x = this.x + border.left.width + padding.left,
                y = this.y + border.top.width + padding.top,
                inner = this.inner;
            debug && debug.box && debug.log("\tBox.draw:  this=" + this.clas + " '" + this.data + "'");
            if (this.meta === 'application/x-string') {
                setFontStyle(_, this.style);
                debug && debug.box && debug.log("\t...text:" + this.data + " at {" + x + "," + y + "}");
                doc.text(this.data, x, y, {
                    width: inner,
                    align: (stext && stext.align) || 'left'
                });
            } else if (this.meta === 'image') {
                var image = this.data;
                if (image) {
                    debug && debug.box && debug.log("\t...image at {" + x + "," + y + "}, size={" + image.width + "," + image.height + "}");
                    doc.image(_, image.data, x, y, {
                        fit: [image.width, image.height]
                    }).link(x, y, image.width, image.height, image.url);
                }
            }
            if (debug && debug.box) {
                debug.log("\t...rect={" + this.x + "," + this.y + "," + this.width + "," + this.height + "}");
                debug.log("\t...doc=" + sys.inspect(doc, true, null));
                // if (this.meta !== 'application/x-string' && this.meta !== 'image') {
                // doc.fillColor("black");
                // // doc.font(_, "Arial");
                // doc.fontSize(8);
                // doc.text(this.clas + ": {" + this.x + "," + this.y + "," + this.width + "," + this.height + "}", this.x, this.y - 8, {
                //     width: this.inner,
                //     align: 'left'
                // });
                // cx.color && doc.fillColor(cx.color);
                // // cx.fontFamily && doc.font(_, cx.fontFamily);
                // cx.fontSize && doc.fontSize(cx.fontSize);
                // // }
            }

            this.title && this.title.draw(_);
            this.value && this.value.draw(_);
            this.items && this.items.forEach_(_, function(_, b) {
                b.draw(_);
            });
            this.rows && this.rows.forEach_(_, function(_, b) {
                b.draw(_);
            });
            return this;
        },
        toString: function() {
            var self = this;
            return '{' + Object.keys(self).map(function(k) {
                return k + ': ' + (Array.isArray(self[k]) ? '[' + self[k].length + ']' : self[k]);
            }) + '}';
        },
    });

    function buildBox(article, meta, data, clas, title) {
        // debug && debug.buildBox && debug.log("**** Pdf.render.buildBox ****\narticle=" + sys.inspect(article, true, null));
        clas = clas || article.$category || (article.$bind ? 'property' : 'layout');
        title = title || (data && data.$title) || article.$title || (meta && meta.$title);
        var box = new Box(clas, meta, data);
        if (title) {
            box.title = new Box(clas + '-title', 'application/x-string', title);
        }
        if (article.$bind) {
            box.layoutType = article.$items ? 'table' : 'property';
            box.bind = article.$bind;
        } else {
            box.layoutType = article.$layoutType || "stack";
            box.layoutSubType = article.$layoutSubType;
        }
        var items = article.$items || (article.$layout && article.$layout.$items);
        debug && debug.buildBox && debug.log("Pdf.render.buildBox: class=" + clas + ", title=" + title);
        box.items = items && items.map(function(item) {
            var m = meta;
            if (box.layoutType === 'table') m = m.$item;
            var m = (m.$ && item.$bind) ? m.$[item.$bind] : m;
            var d = (data && item.$bind) ? data[item.$bind] : data;
            if (m && m.$url && d && !d.$url) {
                d.$url = format(m.$url, meta, data);
            }
            return buildBox(item, m, d);
        });
        return box;
    }

    function objText(val, prop) {
        return prop && prop.$value ? format(prop.$value, proto, val) : (val != null ? val.toString() : '');
    }

    function valueBox(_, box) {
        var prop = box.meta;
        var val = box.data;
        var type = 'application/x-string';
        debug && debug.valueBox && debug.log("Pdf.render.valueBox: prop=" + (prop ? prop.$type : "undefined"));
        if (val != null && prop) {
            switch (prop.$type) {
            case 'application/x-string':
            case 'application/x-integer':
            case 'application/x-decimal':
            case 'application/x-boolean':
            case 'application/x-choice':
                val = val.toString();
                break;
            case 'application/x-date':
                val = date.parse(val).toString(glob.context.localePreferences.shortDate);
                break;
            case 'application/x-datetime':
                val = datetime.parse(val).toString(glob.context.localePreferences.shortDatetime);
                break;
            case 'application/x-time':
                val = time.parse(val).toString(glob.context.localePreferences.shortTime);
                break;
                /*
            case 'application/x-collection':
                return (val || []).map(function(v) {
                    return objText(v, prop.$item);
                });
            case 'application/x-reference':
                return [objText(val, prop.$item)];
                */
            case 'image':
                type = 'image';
                val = val.$url ? getImage(_, val) : null;
                break;
            default:
                val = prop.$type;
            }
            debug && debug.valueBox && debug.log("Pdf.render.valueBox: val=" + val);
            return val != null ? new Box('property-value', type, val) : null;
        }
    }

    function computeBox(_, box) {
        if (debug && debug.computeBox) {
            debug.log("Pdf.render.computeBox: class=" + box.clas + ", inner=" + box.inner + ", layoutType=" + box.layoutType + ", layoutSubType=" + box.layoutSubType);
            // debug.log("... box=" + sys.inspect(box, true, null));
        }
        var style = box.style;
        var inner = box.inner;
        switch (box.layoutType) {
        case 'property':
            box.title && box.title.place(box).fill(_, box.title.style.width);
            box.value = valueBox(_, box);
            box.value && box.value.place(box, box.title, null).fill(_, inner - box.title.style.width);
            box.setHeight(box.value || box.title);
            break;
        case 'columns':
            box.title && box.title.place(box).fill(_, inner);
            var widths = box.layoutSubType.split(',').map(function(s) {
                return parseInt(s, 10);
            });
            // var row = new Box('row');
            // row.place(box, null, box.title)
            var total = Math.max(1, sum(widths));
            var prev = null,
                tallest = null;
            widths.forEach_(_, function(_, w, i) {
                var b = box.items[i];
                if (!b) b = new Box('layout');
                b.place(box, prev, box.title).fill(_, inner * w / total);
                // b.place(row, prev).fill(_, inner * w / total);
                computeBox(_, b);
                tallest = tallest && tallest.height > b.height ? tallest : b;
                prev = b;
            });
            box.setHeight(tallest || box.title);
            // row.setHeight(tallest || box.title);
            // box.setHeight(tallest || box.title);
            break;
        case 'table':
            box.title && box.title.place(box).fill(_, inner);
            /*
            box.width = avail;
            var prop = proto.$[box.bind];
            var y0 = y;
            if (prop.$title) {
                computeBox(_, box.title, pm, res, x, y, inner);
                pm.height = box.title.margin.bottom;
                y += box.title.height;
            }*/
            /*
            box.items.forEach(function(col) {
                //var prop = proto.$.$resources.$item.$[col.bind];
                delete col.title;
                col.layoutType = 'stack';
                col.value = new Box('column', 'application/x-string', col.meta.$title);
                //col.texts = [prop.$title];
                //debug.log(col);
            });*/

            var resources = box.data || [];
            var m = box.meta.$item;
            box.rows = resources.map_(_, function(_, r) {
                var row = new Box('row', m, r);
                // box.items are columns
                row.items = box.items.map_(_, function(_, col) {
                    var prop = col.meta;
                    var cell = new Box('cell', prop, r[col.bind]);
                    cell.value = valueBox(_, cell);
                    //cell.texts = getTexts(_, r, col.bind, prop);
                    //if (cell.texts == null) cell.image = getImage(_, r, prop, r[col.bind]);
                    return cell;
                })
                return row;
            });
            //var colStyle = sst.boxStyle('col');
            //var cellStyle = sst.boxStyle('cell');
            box.items.forEach_(_, function(_, col) {
                col.title.setWidths(_);
                col.minWidth = col.title.minWidth;
                col.maxWidth = col.title.maxWidth;
                /*
                // todo: check next one
                var prop = proto.$.$resources.$item.$[col.bind];
                setFontStyle(_, colStyle);
                col.minWidth = measureMin(prop.$title);
                col.maxWidth = doc.widthOfString(prop.$title + ' ');
                setFontStyle(_, cellStyle);
                
                //debug.log("1: " + col.bind + ": min=" + col.minWidth + ", max=" + col.maxWidth);
                resources.forEach_(_, function(_, r) {
                    segs(_, r, prop, col.bind, true).forEach(function(seg) {
                        col.minWidth = Math.max(col.minWidth, seg.width || doc.widthOfString(seg.str + ' '));
                    });
                    segs(_, r, prop, col.bind, false).forEach(function(seg) {
                        col.maxWidth = Math.max(col.maxWidth, seg.width || doc.widthOfString(seg.str + ' '));
                    });
                });*/
                //debug.log("2: " + col.bind + ": min=" + col.minWidth + ", max=" + col.maxWidth);
            });
            box.rows.forEach_(_, function(_, row) {
                row.items.forEach_(_, function(_, cell, i) {
                    var col = box.items[i];
                    var value = cell.value;
                    if (value) {
                        value.setWidths(_);
                        col.minWidth = Math.max(col.minWidth, value.minWidth);
                        col.maxWidth = Math.max(col.maxWidth, value.maxWidth);
                    }
                });
            });

            var minSum = box.items.reduce(function(v, col) {
                return v + col.minWidth;
            }, 0);
            var maxSum = box.items.reduce(function(v, col) {
                return v + col.maxWidth;
            }, 0);
            /*setFontStyle(_, colStyle);
            var height = 0;
            var x0 = x;
            var y0 = y;
            pm.width = 0;*/
            //debug.log("avail=" + avail + ", minSum=" + minSum + ", maxSum=" + maxSum);
            var prev = null,
                tallest = null,
                last = box.title,
                above = box.title;
            box.items.forEach_(_, function(_, col) {
                var w;
                if (inner > maxSum) w = col.maxWidth + (inner - maxSum + 1) * (col.maxWidth + 1) / (maxSum + 1);
                else if (inner > minSum) w = col.minWidth + (inner - minSum + 1) * (col.maxWidth - col.minWidth + 1) / (maxSum - minSum + 1);
                else w = col.minWidth;
                col.place(box, prev, above).fill(_, w);
                col.title && col.title.place(col).fill(_, col.inner);
                col.setHeight(col.title);
                tallest = tallest && tallest.height > col.height ? tallest : col;
                prev = col;
                /*
                //debug.log("3: " + col.bind + ": min=" + col.minWidth + ", max=" + col.maxWidth + ", w=" + width);
                computeBox(_, col, pm, res, x, y0, width);
                pm.width = col.margin.right;
                x += width;
                y = Math.max(y, y0 + col.height);
                */
            });
            box.items.forEach(function(col) {
                col.height = tallest.height;
            });
            last = tallest || last;
            box.rows.forEach_(_, function(_, row) {
                above = tallest;
                prev = null;
                tallest = null;
                //x = x0;
                //y0 = y;
                row.items.forEach_(_, function(_, cell, i) {
                    var col = box.items[i];
                    cell.place(box, prev, above).fill(_, col.inner);
                    cell.value && cell.value.place(cell).fill(_, cell.inner);
                    cell.setHeight(cell.value);
                    tallest = tallest && tallest.height > cell.height ? tallest : cell;
                    prev = cell;
                    /*
                    computeBox(_, cell, pm, row.res, x, y0, col.width);
                    pm.width = cell.margin.right;
                    x += cell.width;
                    y = Math.max(y, y0 + cell.height);*/
                });
                row.items.forEach(function(cell) {
                    cell.height = tallest.height;
                });
                last = tallest || last;
            });
            box.setHeight(last);
            break;
        default:
            // stack layout
            var above = null;
            above = (box.title && box.title.place(box, null, above).fill(_, inner)) || above;
            above = (box.value && box.value.place(box, null, above).fill(_, inner)) || above;
            /*
            if (box.texts) {
                setFontStyle(_, style);
                y += box.texts.length * doc.currentLineHeight(true);
            }
            var image = box.image;
            if (image) {
                image.width = image.width || doc.currentLineHeight(true) * 3;
                image.height = image.height || doc.currentLineHeight(true) * 3;
                y += image.height;
            }
            */
            box.items && box.items.forEach_(_, function(_, b) {
                b.place(box, null, above);
                b.setWidth(inner);
                debug && debug.box && _logBox(b, "...b")
                computeBox(_, b);
                above = b;
                /*y += pm.height;
                computeBox(_, b, pm, res, x, y, inner);
                pm.height = b.margin.bottom;
                y = b.y + b.height;*/
            });
            box.setHeight(above);
            break;
        }
        //y += style.padding.bottom + style.border.bottom.width;
        //box.height = y - box.y;
    }

    function measureMin(str) {
        return str.split(' ').reduce(function(w, s) {
            return Math.max(w, doc.widthOfString(s + ' '));
        }, 0);
    }

    try {
        var bodyWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
        var bodyHeight = doc.page.height - doc.page.margins.top - doc.page.margins.bottom;
        var pageStyle = sst.boxStyle("page");
        debug && debug.log("********* Building PDF **********");
        // debug.log("data.$description=" + data.$description);
        // debug.log("proto.$description=" + proto.$description);
        // debug.log("data.$title=" + data.$title);
        // debug.log("proto.$title=" + proto.$title);
        var title = format(data.$description || proto.$description || data.$title || proto.$title, proto, data);
        // doc.lineWidth(pageStyle.border.top.width);
        // debug && doc.roundedRect(doc.page.margins.left, doc.page.margins.top, bodyWidth, bodyHeight, pageStyle.border.radius).stroke(pageStyle.border.top.color);
        var res = data;
        var rootBox = buildBox(proto.$article, proto, res, 'page', title);
        rootBox.x = doc.x;
        rootBox.y = doc.y;
        rootBox.width = bodyWidth;
        //measureBox(_, rootBox, res);
        debug && debug.box && _logBox(rootBox, "before computeBox rootBox");
        computeBox(_, rootBox);
        /*, {
            width: 0,
            height: 0
        }, res, doc.x, doc.y, bodyWidth);*/
        rootBox.height = bodyHeight;
        debug && debug.box && _logBox(rootBox, "before draw rootBox");
        rootBox.draw(_);
    } catch (ex) {
        console.log(ex.stack);
        setFont(_, 'error').text(ex.message + "\n" + ex.stack);
    }
    doc.save();
    debug && debug.output && debug.output.pdf && doc.write(debug.output.pdf)
    return doc.output(_);
}
/*if (false && data.$resources) {
            setFont(_, 'page-title').text(title, {
                align: cssValue('page-title', 'text-align', 'center')
            });
            doc.moveDown().fontSize(10);

            proto = proto.$.$resources.$item;
            setFont(_, 'column-title');
            // note: always measure words with trailing space because this is how pdfkit's word wrap cuts them.
            // otherwise longuest word gets shifted one line down
            var minWidths = mapProperties(_, function(_, prop, name, i) {
                return measureMin(prop.$title);
            });
            var maxWidths = mapProperties(_, function(_, prop, name, i) {
                return doc.widthOfString(prop.$title + ' ');
            });
            var maxWidths = minWidths.slice(0);
            var n = 1;
            setFont(_, 'column-value');
            data.$resources.forEach_(_, function(_, res) {
                //debug.log(res);
                mapProperties(_, function(_, prop, name, i) {
                    segs(_, res, prop, name, true).forEach(function(seg) {
                        minWidths[i] = Math.max(minWidths[i], seg.width || doc.widthOfString(seg.str + ' '));
                    });
                    segs(_, res, prop, name, false).forEach(function(seg) {
                        maxWidths[i] = Math.max(maxWidths[i], seg.width || doc.widthOfString(seg.str + ' '));
                    });
                });
                n++;
            });

            // here: get css extra size info            
            var dw = 0,
                dh = 2;
            var minSum = sum(minWidths);
            var maxSum = sum(maxWidths);
            bodyWidth = Math.min(bodyWidth, maxSum + n * dw);
            var avail = Math.max(bodyWidth - minSum - n * dw, 0);
            var widths = minWidths.map(function(w, i) {
                return w + avail * (maxWidths[i] - minWidths[i] + 1) / (maxSum - minSum + 1);
            })
            var totalWidth = sum(widths);
            //debug.log("minWidths=" + minWidths.join(' '))
            //debug.log("maxWidths=" + maxWidths.join(' '))
            //debug.log("avail=" + avail)
            //debug.log("widths=" + widths.join(' '))
            doc.scale(bodyWidth / totalWidth);
            //doc.transform(1, 1, 0, 1, 0, 0).translate(10, 20).transform(1, 0, 0, 1.5, 0, 0).scale(0.8).transform(1, -1, 0, 1, 0, 0);
            setFont(_, 'column-title');
            var x0 = doc.x,
                y0 = doc.y,
                y1 = y0,
                y2 = y0,
                x = x0;
            doc.x = x0;
            mapProperties(_, function(_, prop, name, i) {
                doc.text(prop.$title, x, y0, {
                    width: widths[i],
                    align: 'left'
                });
                x += widths[i] + dw;
                y1 = Math.max(y1, doc.y);
            });
            setFont(_, 'column-value');
            data.$resources.forEach_(_, function(_, res, i) {
                doc.strokeColor('#ddd').lineWidth(i ? 1 : 2).moveTo(x0, y1).lineTo(x0 + totalWidth, y1).stroke();
                y1 += dh;
                x = x0, y2 = y1;
                mapProperties(_, function(_, prop, name, i) {
                    segs(_, res, prop, name, false).forEach_(_, function(_, seg) {
                        //doc.y = y1;
                        if (seg.data) {
                            //debug.log("IMAGE: " + seg.data.length + ", url=" + seg.url);
                            doc.image(_, seg.data, x, y1, {
                                fit: [seg.width, seg.height]
                            }).link(x, y1, seg.width, seg.height, seg.url);
                            y2 += seg.height;
                        } else {
                            //debug.log("drawing " + seg.str + " at " + x + " " + y1)
                            doc.textLink(seg.str, seg.url, x, y1, {
                                width: widths[i],
                                align: 'left'
                            });
                        }
                    });
                    x += widths[i] + dw;
                    y2 = Math.max(y2, doc.y);

                });
                y1 = y2;
            });
        } else {*/