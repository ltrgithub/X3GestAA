"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Parser = require("./parser/parser").Parser;
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var sys = require("util");
var serizalizer = require("syracuse-core/lib/resource/serializer");
var sdataDbHandle = require("./sdataDbHandle");
var flows = require('streamline/lib/util/flows');
var httpHelper = require('syracuse-sdata/lib/httpHelper');
var HttpContext = httpHelper.HttpContext;
var factory = require("syracuse-orm/lib/factory");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminUtil = require("syracuse-collaboration/lib/util");
var pluralize = helpers.string.pluralize;
var locale = require("syracuse-core/lib/locale");

var _defaultCount = 20;
var _maxCount = 1000;

var queryRepr = ["$query", "$lookup", "$search", "$select"]; // query like facets
exports.tracer = console.log;
exports.tracer = null;

function _getTranslatedString(stringResources, parts, combineParts) {
	if(!stringResources || !parts || !parts.length) return "";
	for(var i = 0; i < (combineParts ? parts.length : 1); i++) {
		var str = stringResources[parts.slice(i).join(".")];
		//console.log("resource for : "+parts.slice(i).join(".")+"="+str);
		if(str) return str;
	}
	return "";
}

function _intValue(str, def) {
	return str == null ? def : parseInt(str, 10);
}

function _parsePaths(param) {
	if (!param) return;
	var result = {};
	param.split(',').forEach(function(path) {
		var obj = result;
		path.split('.').forEach(function(name) {
			obj[name] = {};
			obj = obj[name];
		});
	});
	return result;
}

function _parseParameters(query) {
	var parameters = helpers.object.clone(query);
	if (parameters.url) parameters = helpers.url.parseQueryString(parameters.url.split("?")[1]);
	// convert non-string parameters
	parameters.startIndex = _intValue(parameters.startIndex, 1);
	parameters.count = Math.min(_intValue(parameters.count, _defaultCount), _maxCount);
	parameters.orderBy = helpers.url.parseOrderBy(parameters.orderBy);
	parameters.select = _parsePaths(parameters.select);
	parameters.include = _parsePaths(parameters.include);
	parameters.includeSchema = parameters.includeSchema == "true";
	parameters.where = Parser.parse(parameters.where);
	return parameters;
};

function _splitRepresentation(str) {
	if (!str) return {};
	var comps = str.split(',');
	var comps = comps[0].split('.');
	return {
		application: comps[0],
		contract: comps[1],
		dataset: comps[2],
		entity: comps[3],
		type: comps[4],
		variant: comps[5]
	}
}

function _toHtml(context, result) {
	function replacer(key, value) {
		if (typeof value == "string" && value.indexOf("http") == 0) return "<a href='" + value.replace(/'/g, "%27") + "'>" + value + "</a>";
		else return value;
	};

	var body = typeof result == "object" ? JSON.stringify(result, replacer, 2) : result.toString();

	return "<html><head><title>" + result.$descriptor + "</title></head>" + "<body><pre>" + body + "</pre></body></html>"
}

function _queryString(parameters) {
	var items = helpers.object.toArray(parameters, function(key, val) {
		return key + "=" + encodeURIComponent(val);
	});
	return items.length == 0 ? "" : ("?" + items.join('&'));
}

function _formatFeed(context, url, results) {
	var parameters = helpers.object.clone(context.query);
	var uiMain = context.url.split('/').splice(0, 3).join('/') + "/syracuse-main/html/main.html"

	var feed = {
		$url: url + _queryString(parameters),
		$descriptor: context.entity ? context.entity.plural : context.currentSegment,
		$startIndex: context.parameters.startIndex,
		$itemsPerPage: context.parameters.count,
		$totalResults: context.totalCount,
		$ui: uiMain + "#ui=" + url + "/$ui/master" + "&data=" + url,
		$resources: results,
		$links: {}
	};
	parameters.startIndex = 1;
	parameters.count = feed.$itemsPerPage;
	if ((feed.$totalResults > feed.$itemsPerPage) && (feed.$startIndex > feed.$itemsPerPage))
		feed.$links.$first = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		};

	if (feed.$startIndex + feed.$itemsPerPage <= feed.$totalResults) {
		parameters.startIndex = feed.$startIndex + feed.$itemsPerPage;
//		parameters.letter = "{$letter}";
//		parameters.key = "gt." + results[results.length-1].$uuid;
		parameters.count = feed.$itemsPerPage;
		feed.$links.$next = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	}
	if (feed.$startIndex > 1) {
		parameters.startIndex = Math.max(1, feed.$startIndex - feed.$itemsPerPage);
//		parameters.count = feed.$startIndex - parameters.startIndex;
		// leave count to "itemsPerPage", it serves to link formatting
		parameters.count = feed.$itemsPerPage;
		feed.$links.$previous = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	}
	var lastCount = feed.$totalResults % feed.$itemsPerPage;
	if (lastCount === 0)
		lastCount = feed.$itemsPerPage;
	parameters.startIndex = Math.max(1, 1 + feed.$totalResults - lastCount);
	parameters.count = lastCount;
	if ((feed.$totalResults > feed.$itemsPerPage) && (feed.$startIndex < parameters.startIndex))
		feed.$links.$last = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	if (context.entity) {
		feed.$template = {
			$url: url + "/$template"
		};
	}
	// excel
	var order = [];
	context.parameters.orderBy.forEach(function(orderBy) {
		order.push(orderBy.binding + " " + (orderBy.descending ? "desc" : "asc"));
	});
	feed.$links.$excel = {
		$url: feed.$url,
		$title: "Excel",
		$type: httpHelper.mediaTypes.xlsx
	}
	//
	return feed;
}

function Context(request, response) {
	HttpContext.call(this, request, response, {
		acceptParam: "format"
	});
	var self = this;
	self.parameters = _parseParameters(self.query);

	self.segments = self.path.split('/').map(function(seg) {
		return decodeURIComponent(seg);
	});
	self.where = [];
	self.representation = {};
	if (self.parameters && self.parameters.representation) {
		var parts = self.parameters.representation.split(".");
		self.representation = {
			application: self.application,
			contract: self.contract,
			dataset: self.dataset,
			entity: parts[0], // representation, not entity
			type: parts[1], // facet
			variant: parts[2]
		}
	}
	// obsolette
	//else self.representation = _splitRepresentation(self.accept[0].parameters["vnd.sage.syracuse.representation"]);
	self.validationErrors = [];
	self.httpSession = request.session;
	self.reply = exports.Context.prototype.reply; // fix later
}

exports.Context = helpers.defineClass(Context, HttpContext, {
	getLink: function(singular, plural, facetName, title, params) {
		if(!singular) singular = "{$representation}";
		var link = {
			$type: "application/json;vnd.sage=syracuse"
		}
		if (title) link.$title = title;
		switch (facetName) {
		case "$details":
			link.$url = "{$baseUrl}/" + plural + "('{$key}')?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			break;
		case "$lookup":
		case "$select":
		case "$query":
			link.$url = "{$baseUrl}/" + plural + "?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			break;
		case "$edit":
			link.$url = "{$baseUrl}/" + plural + "('{$key}')/$workingCopies?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			link.$method = "POST";
			break;
		case "$create":
			// $create facet is in fact an $edit facet
			link.$url = "{$baseUrl}/" + plural + "/$template/$workingCopies?representation=" + singular + ".$edit&role={$role}" + (params ? "&" + params : "");
			link.$method = "POST";
			break;
		}
		return link;
	},
	getEntity: function() {
		if(this.entity) return this.entity;
		// load from representation
		if(this.contract && this.contract.representations && this.representation.entity) {
			var repr = this.contract.representations[this.representation.entity];
			return repr ? this.model.getEntity(repr.$entityName) : this.model.getEntity(this.representation.entity);
		}
		return null;
	},
	addComplementFilter: function(_, params) {
		function processFilter(_, instance, filterNode, filterPart) {
			flows.eachKey(_, filterPart, function(_, key, value) {
				exports.tracer && exports.tracer("sdataContext.processFilter parts: " + key + "=" + sys.inspect(value));
				// TODO : extend / standardize parser
				if(Array.isArray(value)) {
					filterNode[key] = value.map_(_, function(_, item) {
						var filterItem = {};
						processFilter(_, instance, filterItem, item);
						return filterItem;
					});
				} else {
					if(value == null) {
						filterNode[key] = null;
					} else
						if (typeof value === "object") {
							filterNode[key] = {};
							processFilter(_, instance, filterNode[key], value);
						} else 
							if (typeof value === "string") {
								var template = new resourceProxy.Template(value);
								if (template.matches && template.matches.length >= 1) {
									exports.tracer && exports.tracer("sdataContext.processFilter template: " + key + "=" + sys.inspect(template.matches));
									// supported for now : {prop|relation} | {$parent}.{prop|relation}
									var propName = template.matches.pop();
									propName = propName.substring(1, propName.length - 1);
									//
/*									for(var i = template.matches.length - 1; i >= 0; i--)
										if((template.matches[i] === "{$parent}") && instance) {
											instance = instance._parent;
										}
									*/
									template.matches.forEach_(_, function(_, match) {
										if(!instance) return;
										var rel = match.substring(1, match.length - 1);
										if(rel === "$parent")
											instance = instance._parent;
										else {
											if(instance._meta.$relations[rel] && !instance._meta.$relations[rel].isPlural) {
												exports.tracer && exports.tracer("sdataContext.processFilter walking to: " + rel);
												instance = instance[rel](_);
											}
										}
									});
									//
									if(instance) {
										var prop = instance._meta.$properties[propName];
										if (prop) 
											filterNode[key] = instance[propName](_);
										else {
											var rel = instance._meta.$relations[propName];
											if (rel) {
												if (rel.isPlural) 
													filterNode[key] = instance[propName](_).toUuidArray(_);
												else 
													if(instance[propName](_))
														filterNode[key] = instance[propName](_).$uuid;
											}
										}
									}
								} else
									filterNode[key] = value;
							}
				}
			});
		}
		
		// add relation filter if necessary
		exports.tracer && exports.tracer("sdataContext.addComplementFilter enter");
		if (params.trackingId && params.binding) {
			// binding is "relation" | "childRelation('childId')/relation"
			var bindings = /([^\/(]*)\('([^']*)'\)\/(.*)/.exec(params.binding);	
			//
			var instance = this.httpSession[params.trackingId];
			if (!instance) return;
			exports.tracer && exports.tracer("sdataContext.addComplementFilter found instance: " + instance.$uuid);
			var relName = params.binding;
			if(bindings && bindings.length) {
				exports.tracer && exports.tracer("sdataContext.addComplementFilter stepping child: " + bindings[1] + "('" + bindings[2] + "')/" + bindings[3]);
				if(instance._meta.$relations[bindings[1]] && instance._meta.$relations[bindings[1]].isPlural)
					instance = instance[bindings[1]](_).get(_, bindings[2]);
				else
					instance = instance[bindings[1]](_);
				relName = bindings[3];
			}
			if(!instance) return;
			var rel = instance._meta.$relations[relName];
			if (!rel) return;
			exports.tracer && exports.tracer("sdataContext.addComplementFilter found rel: " + rel.name);
			var filter = params.jsonWhere = params.jsonWhere || {};
			// TODO : different filters must properly concatenate
			if (rel.$lookupFilter) processFilter(_, instance, filter, rel.$lookupFilter)
			//
			if (rel.isPlural) {
				var uuidColl = instance[params.binding](_).toUuidArray(_, true);
				exports.tracer && exports.tracer("sdataContext.addComplementFilter found collection: " + sys.inspect(uuidColl));
				if (uuidColl.length) filter.$uuid = {
					"$nin": uuidColl
				};
			}
			//
			exports.tracer && exports.tracer("sdataContext.addComplementFilter filter: " + sys.inspect(filter, null, 4));
		}
	},
	reply: function(_, statusCode, result, headers) {
		var self = this;
		headers = headers || {};
		if (statusCode == 201) {
			headers.location = headers.location || (result && result.$url);
			if (!headers.location) return self.reply(_, 500, "Server erorr: $url missing in 201 response");
		}
		if (!result) {
			httpHelper.tracer && httpHelper.tracer("HTTP RESPONSE: " + statusCode + " " + JSON.stringify(headers));
			this.response.writeHead(statusCode, headers);
			return this.response.end();
		}
		var encoding = "utf8";
		switch (this.accept[0].type) {
		case "json":
		case "*":
			if (typeof result == "string") {
				result = {
					$diagnoses: [{
						severity: statusCode >= 400 ? "error" : "info",
						message: result
					}]
				};
			}
			// '{' test to avoid problem with pattern in prototype.
			var type = headers["content-type"] || (result.$type && result.$type[0] != '{' && result.$type);
			if (type && type.indexOf("application/json") < 0) {
				return self.reply(_, 406, "expected JSON, got " + result.$type);
			}
			headers["content-type"] = type || "application/json";
			result = JSON.stringify(result);
			break;

		case "xml":
			return self.reply(_, 406, "expected JSON, got " + result.$type);

		case "html":
			headers["content-type"] = "text/html"
			result = _toHtml(self, result);
			break;

		case "text":
			headers["content-type"] = "text/plain"
			result = typeof result == "object" ? JSON.stringify(result, null, 2) : result.toString();
			break;

		case "pdf":
			var proto = self.getPrototypeResource(_, self.parameters.representation, true);
			result = require('syracuse-sdata/lib/render/pdf').render(_, self, result, proto);
			headers["content-type"] = httpHelper.mediaTypes.pdf;
			encoding = "binary";
			break;

		case "xlsx":
			// excel will be pulling the data from server. 
			// So it is a waste to generate data (and even more proto).
			// Review and improve later.
			//var proto = self.getPrototypeResource(_, self.parameters.representation, true);
			headers["content-type"] = httpHelper.mediaTypes.xlsx;
			headers["cache-control"] = "no-cache,must-revalidate";
			self.response.writeHead(statusCode, headers);
			var xlsxUrl = self.url + "?representation=" + self.parameters.representation;
			require('msoffice/lib/excel/xlsx').render(_, self.response, xlsxUrl, self.request.url);
			self.response.end();
			return; // response has been written
			
		case "docx": 
			headers["content-type"] = httpHelper.mediaTypes.docx;
			headers["cache-control"] = "no-cache,must-revalidate";
			self.response.writeHead(statusCode, headers);
			var urlRep = self.url + "?representation=" + self.parameters.representation;
			require('msoffice/lib/word/docx').render(_, self.response, result.$url, urlRep);
			self.response.end();
			return;
			
		default:
			if (!headers["content-type"]) {
				headers["content-type"] = "text/plain";
				result = result && result.toString();
			}
			break;
		}
		//
		headers["cache-control"] = "no-cache,must-revalidate";
		// locales
		headers["content-language"] = locale.current;
		//
		headers["content-length"] = Buffer.byteLength(result, encoding);
		//
		httpHelper.tracer && httpHelper.tracer("HTTP RESPONSE: " + statusCode + " " + JSON.stringify(headers));
		httpHelper.tracer && httpHelper.tracer("BODY: " + result);

		this.response.writeHead(statusCode, headers);
		this.response.end(result, encoding);
	},

	withTransaction: function(_, doIt) {
		var self = this;
		var session = self.model.connect(_, self.dataset);
		self.session = session;
		self.transaction = session.transaction(true, _);
		try {
			return doIt && doIt(_);
		} catch (ex) {
			self.transaction.rollback(session, _);
			throw ex;
		} finally {
			self.transaction = null;
		}
	},
	setUser: function(user) {
		var self = this;
		self.request.session.setData("user", user);
		self.request.session.setData("userID", user.$key);
	},
	getUser: function(_) {
		var self = this;
		var userId = self.request.session.getData("userID");
		if(userId) {
			if(self._user && self._user.$uuid == userId)
				return self._user;
			var db = adminUtil.getCollaborationOrm(_);
			if (db) {
				self._user = db.fetchInstance(_, db.model.getEntity("user"), this.request.session.getData("userID"));
				return self._user;
			}
		} else
			return null;
	},
	setUserProfile: function(_, userProfile) {
		this.httpSession.setUserProfile(_, userProfile);
	},
	getUserProfile: function(_) {
		return this.httpSession.getUserProfile(_);
	},
	updateUserProfile: function(_) {
		// !!!! this method updates user profile, be carrefull not to call it from an GET request
		var self = this;
		// avoid loops
		if (self.entity && (self.entity.name === "userProfile")) return;
		// user profile update
		var userProfile = self.getUserProfile(_);
		if (self.parameters && self.parameters.role && userProfile && /*temp!!!!*/ (self.parameters.role != "{$role}")) {
			// !!!! role, endpoint are not on the same model as context
			var modified = false;
			if (userProfile.selectedRole(_) && (userProfile.selectedRole(_).$uuid !== self.parameters.role)) {
				userProfile.selectedRole(_, userProfile._db.fetchInstance(_, userProfile._db.model.getEntity("role"), self.parameters.role));
				modified = true;
			}
/*			if (userProfile.selectedEndpoint(_) && !userProfile.selectedEndpoint(_).isSame(_, self.application && self.application.name, self.contract && self.contract.name, self.dataset)) {
				// TODO load new endpoint
				modified = true;
			}
			*/
			//
			modified && userProfile.save(_);
		}
	},
	getSelectedRoleId: function(_) {
		var userProfile = this.getUserProfile(_);
		exports.tracer && exports.tracer("sdataContext.getUserProfileId - param: " + this.parameters["role"] + "; userProfile :" + sys.inspect(userProfile));
		return ((this.parameters["role"] /*temp$*/ && (this.parameters["role"] != "{$role}")) ? this.parameters["role"] : ((userProfile && userProfile.selectedRole(_)) ? userProfile.selectedRole(_).$uuid : null));
	},
	replyUser: function(_) {
		function notFound(_, ctxt) {
			ctxt.reply(_, 403, "you should create a session");
		}
		if (helpers.useInstances) {
			var userId = this.request.session.getData("userID");
			if (userId) {
				this.instanceId = userId;
				factory.fetchInstance(_, this, notFound);
			} else notFound(_, this);
		} else {
			var user = this.getUser(_);
			if (!user) this.reply(_, 403, "you should create a session");
			return this.replyDbHandle(_, 200, user);
		}
	},
	setMeta: function(forceChildren) {
		var self = this;
		self.meta = self.entity.getMeta(self.parameters, forceChildren);
	},
	getPrototypeResource: function(_, prototypeId, addSectionInfo, applicationName, contractName, datasetName) {
		// BRJOU added next 3 lines for PDF generation -- review
		applicationName = applicationName || (this.application && this.application.name);
		contractName = contractName || (this.contract && this.contract.name);
		datasetName = datasetName || this.dataset;
		//
		function _fillProtoTemplates(result, entity) {
			result.$url = "{$baseUrl}/{$pluralType}('{$key}')";
			result.$value = (entity.$valueTemplate && (_getTranslatedString(stringRes, [entity.name, "$valueTemplate"]) 
				|| entity.$valueTemplate.expression)) || "{$key}";
			// $title conflicts with the property title for reference thumb.
			//			result.$title = (entity.$titleTemplate && entity.$titleTemplate.expression) || (entity.title + " {$key}");
			result.$description = (entity.$descriptionTemplate && (_getTranslatedString(stringRes, [entity.name, "$descriptionTemplate"]) 
				|| entity.$descriptionTemplate.expression)) || _getTranslatedString(stringRes, [entity.name, "$title"]) || result.$title;
			// extract all fields in templates
			result.$key = "{$uuid}";
			result.$ = {};
			var allFields = {};

			function addField(elem) {
				elem = elem.substring(1, elem.length - 1);
				if (!allFields[elem] && entity.$properties[elem]) allFields[elem] = entity.$properties[elem];
			}
			if (entity.$valueTemplate && entity.$valueTemplate.matches) entity.$valueTemplate.matches.forEach(addField);
			if (entity.$titleTemplate && entity.$titleTemplate.matches) entity.$titleTemplate.matches.forEach(addField);
			if (entity.$descriptionTemplate && entity.$descriptionTemplate.matches) entity.$descriptionTemplate.matches.forEach(addField);
			//
			forEachKey(allFields, function(field, value) {
				result.$[field] = {
					$type: value.getMimeType()
				}
			});
		}

		function _fillThumb($thumb, targetEntity, rel, prefix) {
			_fillProtoTemplates($thumb, targetEntity);
			//			$thumb.$type = "application/json";
			$thumb.$url += "?representation={$representation}.$thumb";
			$thumb.$links = {
				$details: self.getLink(targetEntity.name, targetEntity.plural, "$details")
			};
			//
			var lookupLinkName = ((rel && rel.isPlural && rel.relType !== "children") ? "$select" : "$lookup");
			$thumb.$links[lookupLinkName] = self.getLink(targetEntity.name, targetEntity.plural, lookupLinkName, locale.format(module, "createTableActionTitle"), "trackingId={$trackingId}" + ((rel && rel.name) ? "&binding=" + prefix : ""));
		}

		function _getEntityPrototype(_, entity, isChild, childPrefix) {
			entity.getMeta({}, true);
			// representation fields
			var url = self.baseUrl.split("/");
			url = url[0] + "//" + url[2] + "/" + url[3] + "/";
			url += (applicationName ? [applicationName, contractName, datasetName].join("/") : [url[4], url[5], url[6]].join("/"));
			//
			var resource = {
				$descriptor: "prototype " + prototypeId,
				$type: "application/json"
			};
			if (!isChild) {
				resource.$baseType = model.baseType;
				if (representation.type !== "$search") resource.$baseUrl = url;
				resource.$url = "{$baseUrl}/{$pluralType}('{$key}')";
				resource.$value = (entity.$valueTemplate && (_getTranslatedString(stringRes, [entity.name, "$valueTemplate"]) || entity.$valueTemplate.expression)) || "{$key}";
				resource.$title = (entity.$titleTemplate && (_getTranslatedString(stringRes, [entity.name, "$titleTemplate"]) || entity.$titleTemplate.expression)) || (entity.title + " {$key}");
			}
			resource.$description = (entity.$descriptionTemplate && (_getTranslatedString(stringRes, [entity.name, "$descriptionTemplate"]) || entity.$descriptionTemplate.expression)) || resource.$title;
			if (representation.type !== "$search") {
				resource.$pluralType = entity.plural;
				resource.$representation = representationName;
			}
			var $ = resource.$ = {};
			flows.eachKey(_, entity.$properties, function(_, name, prop) {
				if (prop.type === "json") return;
				if ((prop.type === "graph") && (queryRepr.indexOf(representation.type) >= 0)) return;
				if ((prop.type === "password") && (representation.type !== "$edit")) return;
				if (prop.$isDeveloppementFeature && !helpers.enableDeveloppementFeatures) return;
				//
// don't send default values as might create an difference between the value stored on server and showed by the client
//				if (typeof prop.$default !== "undefined") {
//					resource[name] = resourceHelpers.formatValue(prop, prop.$default);
//				}
				//
				var $p = $[name] = prop.getPropertyPrototype(_, stringRes, representation.type, isChild);
			});
			var $links = resource.$links = {};
			flows.eachKey(_, entity.$relations, function(_, name, rel) {
				if (rel.isPlural && (queryRepr.indexOf(representation.type) >= 0)) return;
				if (rel.relType == "parent") return;
				var targetType = "{$baseType}." + rel.targetEntity.name;
				var $r = ($[name] = {});
				$r.$title = _getTranslatedString(stringRes, [entity.name, name, "$title"], true) || rel.title;
				$r.$constraints = rel.$constraints;
				$r.$isMandatory = rel.$isMandatory;
				$r.$capabilities = (rel.$capabilities != null) ? rel.$capabilities : (isChild ? "sort" : "sort,filter");
				$r.$isHidden = rel.$isHidden;
				// properly format binding for childrens
				var thumbRelName = rel.name;
				if(childPrefix)
					thumbRelName = childPrefix + "('{$uuid}')/" + thumbRelName;
				//
				if (rel.isPlural) {
					$r.$type = "application/x-collection";
					var $item = $r.$item = {};
					switch (rel.relType) {
					case "association":
					case "link":
						if (rel.$assoType) {
							$item = $r.$item = _getEntityPrototype(_, rel.targetAssoEntity, true, thumbRelName);
							if (representation.type === "$edit") {
								$r.$actions = $r.$actions || {};
								$r.$actions.$create = $r.$actions.$create || {
									$title: locale.format(module, "createTableActionTitle"),
									$method: "PUT"
								}
							}
						} else {
							$item.$type = "application/x-reference";
							_fillThumb($item, rel.targetEntity, rel, thumbRelName);
						}
						break;
					case "children":
						//							$item.$type = targetType + ".$child";
						$item = $r.$item = _getEntityPrototype(_, rel.targetEntity, true, thumbRelName);
						if (representation.type === "$edit") {
							$r.$actions = $r.$actions || {};
							$r.$actions.$create = $r.$actions.$create || {
								$title: locale.format(module, "createTableActionTitle"),
								$method: "PUT"
							}
							if(rel.$select) {
								$r.$actions.$create.$parameters = $r.$actions.$create.$parameters || {};
								var selectEnt = model.getEntity(rel.$select.$type);
								$r.$actions.$create.$parameters.$actions = $r.$actions.$create.$parameters.$actions || {};
								$r.$actions.$create.$parameters.$actions.$select = {
									$title: rel.$select.$title,
									$type: "application/x-collection",
									$item: _getEntityPrototype(_, selectEnt, true, thumbRelName),
									$url: "{$baseUrl}/" + selectEnt.plural + "?representation=" + selectEnt.name + ".$select" + 
										(rel.$select.$parameters ? "&" + rel.$select.$parameters : "")
								}
//								if(rel.$select.$selectField) 
//									$r.$actions.$create.$parameters.$actions.$select.$selectField = rel.$select.$selectField;
							}
						}
						break;
					default:
						throw new Error(locale.format(module,"badRelType",rel.relType));
					}
				} else {
					switch (rel.relType) {
					case "child":
						//							$[name].$type = targetType + ".$child";
						$item = $r.$item = _getEntityPrototype(_, rel.targetEntity, true, thumbRelName);
						if (representation.type === "$edit") {
							$r.$actions = $r.$actions || {};
							$r.$actions.$create = $r.$actions.$create || {
								$title: locale.format(module, "createActionTitle"),
								$method: "PUT"
							}
						}
						break;
					case "reference":
						$r.$type = "application/x-reference";
						_fillThumb($r, rel.targetEntity, rel, thumbRelName);
						break;

					default:
						throw new Error(locale.format(module,"badRelType",rel.relType));
					}
				}
			})
			// some standard properties
			$["$creUser"] = {
					$title: "Created by",
					$type: "application/x-string",
					$isDisabled: true,
					$isHidden: true,
					$capabilities: "sort,filter"
				};
			$["$updUser"] = {
					$title: "Updated by",
					$type: "application/x-string",
					$isDisabled: true,
					$isHidden: true,
					$capabilities: "sort,filter"
				};
			$["$creDate"] = {
					$title: "Created on",
					$type: "application/x-datetime",
					$isDisabled: true,
					$isHidden: true,
					$capabilities: "sort,filter"
				};
			$["$updDate"] = {
					$title: "Updated on",
					$type: "application/x-datetime",
					$isDisabled: true,
					$isHidden: true,
					$capabilities: "sort,filter"
				};
			//
			if ((representation.type !== "$child") && !isChild) {
				if (representation.type !== "$details") {
					if (entity.$isPersistent !== false) $links.$details = self.getLink("", "{$pluralType}", "$details", locale.format(module,"detailsLinkTitle"))
				}
				if (representation.type !== "$edit") {
					if(entity.$canEdit !== false)
						$links.$edit = self.getLink("", "{$pluralType}", "$edit", locale.format(module, "editLinkTitle"));
					if(entity.$canDelete !== false)
						$links.$delete = {
							$title: locale.format(module, "deleteActionTitle"),
							$confirm: locale.format(module, "deleteConfirmMessage", _getTranslatedString(stringRes, [entity.name, "$valueTemplate"])),
							// send to query representation
							$url: "{$baseUrl}/{$pluralType}('{$key}')?representation={$representation}." + representation.type + "&role={$role}",
							$type: "application/json;vnd.sage=syracuse",
							$method: "DELETE"
						}
				}
				if (representation.type !== "$query") {
					if (entity.$isPersistent !== false) $links.$query = self.getLink("", "{$pluralType}", "$query", _getTranslatedString(stringRes, [entity.name, "$listTitle"]) || locale.format(module, "listOf", entity.plural));
				}
				if (representation.type === "$edit") {
					resource.$actions = resource.$actions || {};
					if (entity.$canSave !== false) {
						resource.$actions.$save = resource.$actions.$save || {
							$title: locale.format(module, "saveActionTitle"),
							$isDisabled: true,
							$links: {
								$details: self.getLink("", entity.plural, "$details", locale.format(module, "ok")),
								$query: self.getLink("", entity.plural, "$query", locale.format(module, "backToList")),
								$create: self.getLink("", entity.plural, "$create", _getTranslatedString(stringRes, [entity.name, "$createActionTitle"]) || locale.format(module, "newLinkTitle", entity.name))
							}
						}
						resource.$actions.$save.$links.$details.$isHidden = (entity.$isPersistent === false);
						resource.$actions.$save.$links.$query.$isHidden = (entity.$isPersistent === false);
						resource.$actions.$save.$links.$create.$isHidden = (entity.$isPersistent === false);
					}
				}
				// services
				forEachKey(entity.$services, function(key, service) {
					if (service.$method && (service.$method !== "GET") && (representation.type === "$edit")) {
						resource.$actions = resource.$actions || {};
						var action = resource.$actions[key] = {};
						action.$title = service.$title || key;
						action.$method = service.$method || "GET";
					} else {
						// make service links
						resource.$links = resource.$links || {};
						var link = resource.$links[key] = {
							$type: "application/json;vnd.sage=syracuse",
							$title: service.$title || key,
							$method: service.$method || "GET",
							$url: "{$baseUrl}/{$pluralType}('{$uuid}')/$service/" + key
						}
					}
				});
				resource.$links = resource.$links || {};
				forEachKey(entity.$links, function(key, link) {
					resource.$links[key] = link;
				});
				// PDFHACK
				$links.$print = self.getLink("", "{$pluralType}", representation.type, locale.format(module, "print"));
				$links.$print.$type = "application/pdf";

				if (queryRepr.indexOf(representation.type) >= 0) {
					var old = resource;
					resource = {
						$baseUrl: resource.$baseUrl,
						$baseType: resource.$baseType,
						$url: "{$baseUrl}/" + entity.plural,
						$type: resource.$type,
						$title: _getTranslatedString(stringRes, [entity.name, "$listTitle"]) || locale.format(module, "listOf", entity.plural),
						$: {
							$resources: {
								$type: "application/x-collection",
								$item: resource
							}
						}
					}
					if (representation.type !== "$search") {
						resource.$pluralType = entity.plural;
						resource.$representation = representationName;
					}
					resource.$links = resource.$links || {};
					resource.$links.$create = self.getLink("", "{$pluralType}", "$create", _getTranslatedString(stringRes, [entity.name, "$createActionTitle"]) || locale.format(module, "newLinkTitle", entity.name));
					// PDFHACK
					resource.$links.$print = self.getLink("", "{$pluralType}", representation.type, locale.format(module, "print"));
					resource.$links.$print.$type = httpHelper.mediaTypes.pdf;
					// EXCELHACK
					resource.$links.$excel = self.getLink("", "{$pluralType}", representation.type, "Excel");
					//resource.$links.$excel.$url += '&format=' + encodeURIComponent(httpHelper.mediaTypes.xlsx);
					resource.$links.$excel.$type = httpHelper.mediaTypes.xlsx;

					// WORDHACK / TODO: NLS
					var link = self.getLink("", "{$pluralType}", representation.type, "Word");
					resource.$links.$word =  self.getLink("msoMailMergeDocSel", "msoMailMergeDocSels", "$create", "Word", "$msommdata=" + link.$url);

					// var paramlink = self.getLink("msoMailMergeDocSel", "msoMailMergeDocSels", "$edit");
					/* TODO: Review later / seems not to work
					resource.$links.$word = {
								"$title": "Word",
								"$url": self.getLink("", "{$pluralType}", representation.type).$url,
								"$type": httpHelper.mediaTypes.docx,
								
								"$parameters": {
									"$url": "{$baseUrl}/msoMailMergeDocSels/$template/$workingCopies?representation=msoMailMergeDocSel.$edit&role={$role}",
									"$method": "POST",
									"$": {
										"dummy": {  // the user will be prompted to enter user1 value
											"$title": "dummy",
											"$type": "application/x-string"
										}
									}
								}
							};
					*/
					resource.$links.$word = {
						"$title": "Word",
						"$url": self.getLink("", "{$pluralType}", representation.type).$url + "&createMode={createMode}.&doc_uuid={doc_uuid}.",
						"$type": httpHelper.mediaTypes.docx,
						
						"$parameters": {
							"$": {
								"createMode": {
									"$title": "Mode",
									"$type": "application/x-string",
									"$defaultValue": "1"
								},
								"doc_uuid": {
									"$title": "Doc ID",
									"$type": "application/x-string",
									"$value": "1"
								}
							}
						}
					};

					delete old.$baseType;
					delete old.$baseUrl;
					//old.$type = result.$baseType + "." + entity.name + ":$queryItem";
					old.$type = "application/json";
				}
			} else if (isChild) {
				if (representation.type === "$edit") {
					resource.$actions = resource.$actions || {};
					resource.$actions.$delete = resource.$actions.$delete || {
						$title: locale.format(module, "deleteActionTitle"),
						$method: "PUT"
					}
				}
			}
			//
			return resource;
		}
		//
		var self = this;
		// request parse
		var keys = prototypeId.split(",");
		var keys = keys[0].split(".");
		var representationName = keys[0];
		// if applicationName/contractName aren't provided, use same as contexts
		var contract;
		var model;
		if(applicationName) {
			contract = sdataRegistry.getContract(applicationName, contractName);
			if (!contract) return null;
			model = dataModel.make(contract, datasetName);
		} else {
			contract = this.contract;
			if (!contract) return null;
			model = this.model;
		}
		// extract from representation
		var rep = contract && contract.representations && contract.representations[representationName];
		var entityName = (rep && rep.$entityName) || representationName;
		//
		var representation = {
			application: applicationName,
			contract: contractName,
			entity: entityName,
			type: keys[1],
			// type is facet ...
			variant: keys[2]
		}
		//
		var stringRes = contract.resources && contract.resources();
		var mainEntity = model.getEntity(model.singularize(entityName) || entityName);
//		if (!mainEntity) throw self.notFound(locale.format(module, "entityNotFound", model.singularize(entityName)));
		if(!mainEntity) return null;
		//
		var res = _getEntityPrototype(_, mainEntity);
		// merge facets meta
		if(stringRes && stringRes[representationName]) res.$localization = stringRes[representationName];
		
		// layout
		if (addSectionInfo) {
			var rep = (rep || contract.representations && contract.representations[mainEntity.name]);
			var repMeta = self.getRepresentationMeta(contract, rep, representation.type);
			if (repMeta) {
				var layout = repMeta.$layout && (repMeta.$layout.$copy ? ((self.getRepresentationMeta(contract, rep, repMeta.$layout.$copy) || {}).$layout) : repMeta.$layout);
				res.$article = {
					$layout: layout
				}
				// merge meta
				helpers.resource.applyDiff(res, repMeta.$prototype, true);
			}
		}
		//
		return res;
	},
	getRepresentationMeta: function(contract, representation, facetName) {
		var rep = representation;
		var facet = rep && rep.$facets && rep.$facets[facetName];
		return facet && (facet.$copy ? this.getRepresentationMeta(contract, representation, facet.$copy) : facet);
	},
	getRepresentation: function(contract, entityName, representationName) {
		return contract.representations && (contract.representations[representationName] || contract.representations[entityName]);
	},
	replyProperty: function(_, instance, propertyName) {
		var store = instance[propertyName](_);
		if (!store.fileExists(_)) return this.reply(_, 404);
		var props = store.getProperties(_);
		var headers = {
			"content-length": props.length,
			"cache-control": "no-cache,must-revalidate",
			"expires": (new Date(0)).toString(),
		};
		headers["content-type"] = props.contentType;
		this.response.writeHead(200, headers);
		store.readOpen(_);
		var buf;
		while(buf = store.read(_, props.chunkSize))
			this.response.write(_, buf, "binary");
		this.response.end();
	},
	replyPrototype: function(_) {
		var proto = this.getPrototypeResource(_, this.prototypeId);
		if(proto)
			this.reply(_, 200, proto);
		else
			this.reply(_, 404, locale.format(module, "prototypeNotFound", this.prototypeId));
	},
	replyTemplate: function(_) {
		replyPrototype(_);
	},
	getTemplate: function(_, entity, id) {
		var self = this;
		var dbHandle = self.getPrototype(_, entity, id);
		// for now -- will trigger additional rules later
		return dbHandle;
	},
	validationError: function(path, message) {
		var self = this;
		self.validationErrors.push({
			path: path,
			message: message
		});
	},
	hasValidationErrors: function() {
		var self = this;
		return self.validationErrors.length > 0;
	},
	executeOperation: function(_) {
		exports.tracer && exports.tracer("sdataContext method execute enter");
		var self = this;
		var operation = self.operation;
		exports.tracer && exports.tracer("sdataContext method execute operation: " + operation.name + "; method: " + operation.method + "; method got: " + self.method);
		if (helpers.string.compare((operation.method || "GET"), self.method, true) != 0) 
			throw self.badMethod("operation " + operation.name + " expected " + operation.method + ", got " + self.method);
		if (operation.isMethod) {
//			self.setMeta(false);
			console.log("1");
			var instance = self.db.fetchInstance(_, self.entity, self.instanceId);
			exports.tracer && exports.tracer("sdataContext method execute found instance: " + instance && instance.$uuid);
			return operation.execute(_, self, instance);
		} else 
			return operation.execute(_, self, null);
	},
	executeDatasetOperation: function(_) {
		throw context.niy("dataset operation");
	},
	getSerializeOptions: function() {
		var self = this;
		return {
			model: self.model,
			baseUrl: self.baseUrl,
			representation: self.representation,
			isPrototype: self.isPrototype,
			isTemplate: self.isTemplate,
			getPluralDbHandles: function(_, dbHandle, relation) {
				if (self.isPrototype || self.isTemplate) return null;
				else {
					var query = dbHandle[relation.name];
					relation.defaultOrder.forEach(function(order) {
						query = query.order(order[0], order[1]);
					})
				}
				// crnit : instance management
				if (!query || Array.isArray(query)) return query;
				else return query.list(self.transaction, _);
			}
		};
	},
	exception: function(statusCode, message) {
		var ex = new Error(message);
		ex.httpStatus = statusCode;
		return ex;
	},
	notFound: function(message) {
		var self = this;
		return self.exception(404, "Not found: " + message);
	},
	niy: function(message) {
		var self = this;
		return self.exception(501, "Not implemented: " + message);
	},
	badMethod: function(message) {
		var self = this;
		return self.exception(405, "Method not allowed: " + (message || self.method));
	},
	badRequest: function(message) {
		var self = this;
		return self.exception(400, "Bad request: " + message);
	},
	serverError: function(message) {
		var self = this;
		return self.exception(500, "Server error: " + message);
	},
	replyDbHandle: function(_, statusCode, dbHandle, options) {
		var self = this;
		options = options || self.getSerializeOptions();
		options.url = true;
		var resource;
		if (typeof dbHandle.serialize == "function") // page resource hack
		resource = dbHandle.serialize(_);
		else resource = serizalizer.serialize(_, dbHandle, self.meta, options);
		return self.replyResource(_, statusCode, resource);
	},
	replyDbHandles: function(_, statusCode, results) {
		var self = this;
		var resources = self.toResources(_, results);
		return self.reply(_, 200, _formatFeed(self, self.url, resources));
	},
	replyResource: function(_, statusCode, resource) {
		var self = this;
		if (!resource) throw self.serverError("trying to reply null resource!")
		return self.reply(_, statusCode, resource);
	},
	replyResources: function(_, statusCode, resources) {
		var self = this;
		return self.reply(_, 200, _formatFeed(self, self.url, resources));
	},
	replySearchResults: function(_, statusCode, resources, searchFacets) {
		var self = this;
		var feed = _formatFeed(self, self.url, resources);
		if (searchFacets) feed.$searchFacets = searchFacets;
		return self.reply(_, 200, feed);
	},
	replyDeleted: function(_) {
		var self = this;
		var loc = self.getLink("", "{$pluralType}", "$query", locale.format(module, "backToList"));
		return self.reply(_, 200, locale.format(module, "resourceDeleted"), {location:loc.$url});
	},
	replyDictionaryPage: function(_, dict, title, mapping) {
		var self = this;
		var baseUrl = self.walked();
		mapping = mapping ||
		function(name) {
			return {
				$url: self.url + "/" + name,
				$key: name,
				$descriptor: title + " " + name,
				name: name
			};
		}

		var entries = helpers.object.toArray(dict, function(key, val) {
			return mapping(key, val);
		});
		entries.sort(function(e1, e2) {
			return helpers.string.compare(e1.name, e2.name, true);
		});
		var parameters = self.parameters;
		self.totalCount = entries.length;
		entries = entries.slice(parameters.startIndex - 1, parameters.startIndex - 1 + parameters.count);
		return self.reply(_, 200, _formatFeed(self, baseUrl, entries));
	},
	sortInstancesArray: function(_, resources, defaultOrder) {
		var orderBy = (this.parameters && this.parameters.orderBy);
		if((!orderBy || !orderBy.length) && defaultOrder)
			orderBy = defaultOrder.map(function(order) {
				return {
					binding: order[0],
					descending: !order[1]
				}
			});
//		console.log("order by: "+sys.inspect(orderBy));
		if(!orderBy) return;
		resources.sort_(_, function(_, a, b) {
			for(var i = 0; i < orderBy.length; i++) {
				var prop = orderBy[i].binding;
				var sens = orderBy[i].descending ? -1 : 1;
//				console.log("prop: "+prop+"; a: "+a[prop](_)+"; b: "+b[prop](_));
				if(a[prop](_) !== b[prop](_)) {
					return (a[prop](_) > b[prop](_)) ? sens : -sens;
				}
			}
			return 0;
		});
		//
		return resources;
	},
	filterInstancesArray: function(_, instances, parameters) {
		var params = parameters || this.parameters.where;
		//
		return instances.filter_(_, function(_, instance) {
			return instance.match(_, params);
		});
	}
})
