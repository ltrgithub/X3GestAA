"use strict";

var globals = require('streamline/lib/globals');
var helpers = require("syracuse-core/lib/helpers");
var Parser = require("./parser/parser").Parser;
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var sys = require("util");
var flows = require('streamline/lib/util/flows');
var httpHelper = require('syracuse-sdata/lib/httpHelper');
var HttpContext = httpHelper.HttpContext;
var factory = require("syracuse-orm/lib/factory");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminUtil = require("syracuse-collaboration/lib/util");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var pluralize = helpers.string.pluralize;
var locale = require("syracuse-core/lib/locale");
var http = require('http');
var depend = require("streamline-require/lib/server/depend");
var config = require('config');
var htmlTransforms = require('html-escape/lib/transforms');

var nocache = config && config.hosting && config.hosting.nocache;

var _defaultCount = 20;
var _maxCount = 1000;

var queryRepr = ["$query", "$lookup", "$search", "$select"]; // query like facets
exports.tracer = null; // console.log;

function _getTranslatedString(stringResources, parts, combineParts) {
	if (!stringResources || !parts || !parts.length) return "";
	for (var i = 0; i < (combineParts ? parts.length : 1); i++) {
		var str = stringResources[parts.slice(i).join(".")];
		//console.log("resource for : "+parts.slice(i).join(".")+"="+str);
		if (str) return str;
	}
	return "";
}

function _intValue(str, def) {
	return str == null ? def : parseInt(str, 10);
}

function _parsePaths(param) {
	if (!param) return;
	var result = {};
	param.split(',').forEach(function(path) {
		var obj = result;
		path.split('.').forEach(function(name) {
			obj[name] = obj[name] || {};
			obj = obj[name];
		});
	});
	return result;
}

function _parseParameters(query) {
	var parameters = helpers.object.clone(query);
	if (parameters.url) parameters = helpers.url.parseQueryString(parameters.url.split("?")[1]);
	// convert non-string parameters
	parameters.startIndex = _intValue(parameters.startIndex, 1);
	parameters.count = Math.min(_intValue(parameters.count, _defaultCount), _maxCount);
	parameters.orderBy = helpers.url.parseOrderBy(parameters.orderBy);
	parameters.rawSelect = parameters.select;
	parameters.select = _parsePaths(parameters.select);
	parameters.rawInclude = parameters.include;
	parameters.include = _parsePaths(parameters.include);
	parameters.includeSchema = parameters.includeSchema == "true";
	parameters.where = Parser.parse(parameters.where);
	return parameters;
};

function _splitRepresentation(str) {
	if (!str) return {};
	var comps = str.split(',');
	var comps = comps[0].split('.');
	return {
		application: comps[0],
		contract: comps[1],
		dataset: comps[2],
		entity: comps[3],
		type: comps[4],
		variant: comps[5]
	};
}

function _toHtml(context, result) {
	function replacer(key, value) {
		if (typeof value == "string" && value.indexOf("http") == 0) return "<a href='" + value.replace(/'/g, "%27") + "'>" + value + "</a>";
		else return value;
	};

	var body = typeof result == "object" ? JSON.stringify(result, replacer, 2) : result.toString();

	return "<html><head><title>" + result.$descriptor + "</title></head>" + "<body><pre>" + body + "</pre></body></html>";
}

function _queryString(parameters) {
	var items = helpers.object.toArray(parameters, function(key, val) {
		return key + "=" + encodeURIComponent(val);
	});
	return items.length == 0 ? "" : ("?" + items.join('&'));
}

function _formatKeyPagerFeed(context, url, results) {
	var parameters = helpers.object.clone(context.query);
	var uiMain = context.url.split('/').splice(0, 3).join('/') + "/syracuse-main/html/main.html";

	var feed = {
		$url: url + _queryString(parameters),
		$itemsPerPage: context.parameters.count,
		$resources: results,
		$links: {}
	};
	//
	parameters.orderBy = parameters.orderBy || ((context.entity.$defaultOrder && context.entity.$defaultOrder[0]) || [])[0];
	if (!parameters.orderBy) throw new Error(locale.format(module, "orderByRequired", context.entity.name));
	var orderProp = parameters.orderBy.split(" ")[0];
	//
	if (parameters.key) {
		delete parameters.key;
		feed.$links.$first = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		};
	}

	if (!context.isLastPage && results.length) {
		parameters.key = "gt." + results[results.length - 1][orderProp];
		feed.$links.$next = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		};
	}
	if (feed.$links.$first && results.length) {
		parameters.key = "lt." + results[0][orderProp];
		feed.$links.$previous = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		};
	}
	if (!context.isLastPage) {
		parameters.key = "lt.zzzzzz";
		feed.$links.$last = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		};
	}
	return feed;
}

function _formatDefaultFeed(context, url, results) {
	var parameters = helpers.object.clone(context.query);
	var uiMain = context.url.split('/').splice(0, 3).join('/') + "/syracuse-main/html/main.html";

	var feed = {
		$url: url + _queryString(parameters),
		$descriptor: context.entity ? context.entity.plural : context.currentSegment,
		$startIndex: context.parameters.startIndex,
		$itemsPerPage: context.parameters.count,
		$totalResults: context.totalCount,
		$ui: uiMain + "#ui=" + url + "/$ui/master" + "&data=" + url,
		$resources: results,
		$links: {}
	};
	parameters.startIndex = 1;
	parameters.count = feed.$itemsPerPage;
	if ((feed.$totalResults > feed.$itemsPerPage) && (feed.$startIndex > feed.$itemsPerPage)) feed.$links.$first = {
		$url: url + _queryString(parameters),
		$type: "application/json; vnd-sage=syracuse"
	};

	if (feed.$startIndex + feed.$itemsPerPage <= feed.$totalResults) {
		parameters.startIndex = feed.$startIndex + feed.$itemsPerPage;
		//		parameters.letter = "{$letter}";
		//		parameters.key = "gt." + results[results.length-1].$uuid;
		parameters.count = feed.$itemsPerPage;
		feed.$links.$next = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		};
	}
	if (feed.$startIndex > 1) {
		parameters.startIndex = Math.max(1, feed.$startIndex - feed.$itemsPerPage);
		//		parameters.count = feed.$startIndex - parameters.startIndex;
		// leave count to "itemsPerPage", it serves to link formatting
		parameters.count = feed.$itemsPerPage;
		feed.$links.$previous = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		};
	}
	var lastCount = feed.$totalResults % feed.$itemsPerPage;
	if (lastCount === 0) lastCount = feed.$itemsPerPage;
	parameters.startIndex = Math.max(1, 1 + feed.$totalResults - lastCount);
	parameters.count = lastCount;
	if ((feed.$totalResults > feed.$itemsPerPage) && (feed.$startIndex < parameters.startIndex)) feed.$links.$last = {
		$url: url + _queryString(parameters),
		$type: "application/json; vnd-sage=syracuse"
	};
	if (context.entity) {
		feed.$template = {
			$url: url + "/$template"
		};
	}
	//
	return feed;
}

function _formatFeed(_, context, url, results) {
	var feed;
	if (context.entity && context.entity.$keyPager) feed = _formatKeyPagerFeed(context, url, results);
	else feed = _formatDefaultFeed(context, url, results);
	if (context.entity) {
		feed.$template = {
			$url: url + "/$template"
		};
	}
	// prototype
	if (context.representation) {
		feed.$prototype = "{$baseUrl}/$prototypes('" + context.representation.entity + "." + context.representation.type + "')";
		var pars = [];
		if (context.parameters.rawInclude) pars.push("include=" + encodeURIComponent(context.parameters.rawInclude));
		if (context.parameters.rawSelect) pars.push("select=" + encodeURIComponent(context.parameters.rawSelect));
		if (pars.length) feed.$prototype += "?" + pars.join("&");
	}
	// user rights: hide create if cannot create
	var sp = globals.context.session && globals.context.session.getSecurityProfile(_);
	if (sp) {
		exports.tracer && exports.tracer("sdataContext._formatFeed found security profile: " + sp.code(_));
		if (context.entity && !sp.canCreateClass(_, context.entity.name)) {
			// hide the link here, not in prototype as the prototype should be cached and application of rights might prevent it
			feed.$links = feed.$links || {};
			feed.$links.$create = feed.$links.$create || {};
			feed.$links.$create.$isHidden = true;
		}
	}
	var order = [];
	context.parameters.orderBy.forEach(function(orderBy) {
		order.push(orderBy.binding + " " + (orderBy.descending ? "desc" : "asc"));
	});
	// excel
	if (context.entity && context.entity.isCapableOf("excel")) {
		feed.$links.$excel = {
			$url: feed.$url,
			$title: locale.format(module, "excel"),
			$type: httpHelper.mediaTypes.excel_worksheet
		};
	}

	// Excel-report
	if (context.entity && context.entity.isCapableOf("excelReport")) {
		feed.$links.$excelreport = {
			$url: feed.$url + "&excelReportMode={excelReportMode}&doc_uuid={document}&xlsx=application/syracuse-excel-worksheet",
			$title: locale.format(module, "excelReport"),
			$type: httpHelper.mediaTypes.excel_worksheet
		};
	}


	// Mailmerge
	if (context.entity && context.entity.isCapableOf("mailMerge")) {
		feed.$links.$wordmailmerge = {
			$url: feed.$url + "&createMode={creationMode}&doc_uuid={document}&docx=mailmerge",
			$title: locale.format(module, "mailMerge"),
			$type: httpHelper.mediaTypes.word_mailmerge
		};
	}

	// Word-report
	if (context.entity && context.entity.isCapableOf("wordReport")) {
		feed.$links.$wordreport = {
			$url: feed.$url + "&reportMode={reportMode}&doc_uuid={document}&docx=application/syracuse-word-report",
			$title: locale.format(module, "wordReport"),
			$type: httpHelper.mediaTypes.word_report
		};
	}
	//
	return feed;
}

function Context(request, response, options) {
	HttpContext.call(this, request, response, {
		acceptParam: "format"
	});
	exports.tracer = exports.tracer || (options && options.tracer);
	var self = this;
	self.parameters = _parseParameters(self.query);

	self.segments = self.path.split('/').map(function(seg) {
		return decodeURIComponent(seg);
	});
	self.where = [];
	self.representation = {};
	if (self.parameters && self.parameters.representation) {
		var parts = self.parameters.representation.split(".");
		self.representation = {
			application: self.application,
			contract: self.contract,
			dataset: self.dataset,
			entity: parts[0], // representation, not entity
			type: parts[1], // facet
			variant: parts[2]
		};
	} else if (/^\/api\//.test(request.url)) {
		self.representation = {
			application: self.application,
			contract: self.contract,
			dataset: self.dataset,
			entity: self.entityName,
			type: self.instanceId || request.method === "POST" ? "$details" : "$query",
		};
	}
	// obsolette
	//else self.representation = _splitRepresentation(self.accept[0].parameters["vnd.sage.syracuse.representation"]);
	self.validationErrors = [];
	self.httpSession = request.session;
	self.reply = exports.Context.prototype.reply; // fix later
}

exports.Context = helpers.defineClass(Context, HttpContext, {
	getLink: function(singular, plural, facetName, title, params) {
		if (!singular) singular = "{$representation}";
		var link = {
			$type: "application/json;vnd.sage=syracuse"
		};
		if (title) link.$title = title;
		switch (facetName) {
			case "$details":
				link.$url = "{$baseUrl}/" + plural + "('{$key}')?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
				break;
			case "$lookup":
			case "$select":
			case "$query":
				link.$url = "{$baseUrl}/" + plural + "?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
				break;
			case "$edit":
				link.$url = "{$baseUrl}/" + plural + "('{$key}')/$workingCopies?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
				link.$method = "POST";
				break;
			case "$create":
				// $create facet is in fact an $edit facet
				link.$url = "{$baseUrl}/" + plural + "/$template/$workingCopies?representation=" + singular + ".$edit&role={$role}" + (params ? "&" + params : "");
				link.$method = "POST";
				break;
		}
		return link;
	},
	getEntity: function(_) {
		if (this.entity) return this.entity;
		// load from representation
		if (this.contract && this.contract.representations && this.representation.entity) {
			var repr = this.contract.representations[this.representation.entity];
			return repr ? this.model.getEntity(_, repr.$entityName) : this.model.getEntity(_, this.representation.entity);
		}
		return null;
	},
	addComplementFilter: function(_, params) {
		function processFilter(_, instance, filterNode, filterPart) {
			flows.eachKey(_, filterPart, function(_, key, value) {
				exports.tracer && exports.tracer("sdataContext.processFilter parts: " + key + "=" + sys.inspect(value));
				// TODO : extend / standardize parser
				if (Array.isArray(value)) {
					filterNode[key] = value.map_(_, function(_, item) {
						var filterItem = {};
						processFilter(_, instance, filterItem, item);
						return filterItem;
					});
				} else {
					if (value == null) {
						filterNode[key] = null;
					} else if (typeof value === "object") {
						filterNode[key] = {};
						processFilter(_, instance, filterNode[key], value);
					} else if (typeof value === "string") {
						var template = new resourceProxy.Template(value);
						if (template.matches && template.matches.length >= 1) {
							exports.tracer && exports.tracer("sdataContext.processFilter template: " + key + "=" + sys.inspect(template.matches));
							// supported for now : {prop|relation} | {$parent}.{prop|relation}
							var propName = template.matches.pop();
							propName = propName.substring(1, propName.length - 1);
							//
							/*									for(var i = template.matches.length - 1; i >= 0; i--)
										if((template.matches[i] === "{$parent}") && instance) {
											instance = instance._parent;
										}
									*/
							template.matches.forEach_(_, function(_, match) {
								if (!instance) return;
								var rel = match.substring(1, match.length - 1);
								if (rel === "$parent") instance = instance._parent;
								else {
									if (instance._meta.$relations[rel] && !instance._meta.$relations[rel].isPlural) {
										exports.tracer && exports.tracer("sdataContext.processFilter walking to: " + rel);
										instance = instance[rel](_);
									}
								}
							});
							//
							if (instance) {
								var prop = instance._meta.$properties[propName];
								if (prop) filterNode[key] = instance[propName](_);
								else {
									var rel = instance._meta.$relations[propName];
									if (rel) {
										if (rel.isPlural) filterNode[key] = instance[propName](_).toUuidArray(_);
										else if (instance[propName](_)) filterNode[key] = instance[propName](_).$uuid;
									}
								}
							}
						} else filterNode[key] = value;
					} else filterNode[key] = value;
				}
			});
		}

		function _step(_, instance, relName) {
			var bindings = /([^\/(]*)\('([^']*)'\)\/(.*)/.exec(relName);
			exports.tracer && exports.tracer("sdataContext.addComplementFilter bindings: " + sys.inspect(bindings));
			//
			if (!instance) return;
			exports.tracer && exports.tracer("sdataContext.addComplementFilter found instance: " + instance.$uuid);
			if (bindings && bindings.length) {
				exports.tracer && exports.tracer("sdataContext.addComplementFilter stepping child: " + bindings[1] + "('" + bindings[2] + "')/" + bindings[3]);
				if (instance._meta.$relations[bindings[1]] && instance._meta.$relations[bindings[1]].isPlural) instance = instance[bindings[1]](_).get(_, bindings[2]);
				else instance = instance[bindings[1]](_);
				relName = bindings[3];
				return _step(_, instance, bindings[3]);
			} else {
				exports.tracer && exports.tracer("sdataContext.addComplementFilter fetching relation: " + relName);
				return {
					instance: instance,
					relName: relName
				};
			}
		}
		// add relation filter if necessary
		exports.tracer && exports.tracer("sdataContext.addComplementFilter enter");
		var self = this;
		if ((params.trackingId || params.parent) && params.binding) {
			var parentInst = params.trackingId ? this.httpSession[params.trackingId] : (function(_) {
				var det = httpHelper.decodeDetailSegment(params.parent);
				if (!det) return null;
				return self.db.fetchInstance(_, self.db.getEntity(_, det.name), det.id);
			})(_);
			// binding is "relation" || "childRelation('childId')/relation"
			var res = _step(_, parentInst, params.binding) || {};
			var instance = res.instance;
			var relName = res.relName;
			//
			if (!instance) return;
			var rel = instance._meta.$relations[relName];
			if (!rel) return;
			var v_rel = params.variant && rel.$variants[params.variant];
			exports.tracer && exports.tracer("sdataContext.addComplementFilter found rel: " + rel.name);
			var filter = params.jsonWhere = params.jsonWhere || {};
			// TODO : different filters must properly concatenate
			var lf = (v_rel && v_rel.$lookupFilter) || rel.$lookupFilter;
			if (lf) {
				if (typeof lf !== "function") processFilter(_, instance, filter, lf);
				else processFilter(_, instance, filter, lf(_, instance));
			}
			//
			if (rel.isPlural) {
				var uuidColl = instance[rel.name](_).toUuidArray(_, true);
				exports.tracer && exports.tracer("sdataContext.addComplementFilter found collection: " + sys.inspect(uuidColl));
				if (uuidColl.length) filter.$uuid = {
					"$nin": uuidColl
				};
			}
			//
			exports.tracer && exports.tracer("sdataContext.addComplementFilter filter: " + sys.inspect(filter, null, 4));
		}
	},
	reply: function(_, statusCode, result, headers) {
		var self = this;
		headers = headers || {};

		if (statusCode == 201) {
			headers.location = headers.location || (result && result.$url);
			if (!headers.location) return self.reply(_, 500, "Server erorr: $url missing in 201 response");
			if (self.batchResult) self.batchResult.$httpLocation = headers.location;
		}
		if (!result) {
			httpHelper.tracer && httpHelper.tracer("HTTP RESPONSE: " + statusCode + " " + JSON.stringify(headers));
			if (self.batchResult) {
				self.batchResult.$httpStatus = statusCode;
				self.batchResult.$httpMessage = http.STATUS_CODES[statusCode];
				return;
			}
			this.response.writeHead(statusCode, headers);
			return this.response.end();
		}
		var encoding = "utf8";
		switch (this.accept[0].type) {
			case "json":
			case "*":
				if (typeof result == "string") {
					result = {
						$diagnoses: [{
							$severity: statusCode >= 400 ? "error" : "info",
							$message: result
						}]
					};
				}
				// '{' test to avoid problem with pattern in prototype.
				var type = headers["content-type"] || (result.$type && result.$type[0] != '{' && result.$type);
				if (type && type.indexOf("application/json") < 0) {
					return self.reply(_, 406, "expected JSON, got " + result.$type);
				}
				type = type || "application/json";
				if (type.search(/;charset=/i) < 0) type += ";charset=UTF-8";
				headers["content-type"] = type;
				if (!self.batchResult) result = JSON.stringify(result);
				break;

			case "xml":
				return self.reply(_, 406, "expected JSON, got " + result.$type);

			case "html":
				headers["content-type"] = "text/html";
				result = _toHtml(self, result);
				break;

			case "text":
				headers["content-type"] = "text/plain";
				result = typeof result == "object" ? JSON.stringify(result, null, 2) : result.toString();
				break;

			case "pdf":
				var proto = self.getPrototypeResource(_, self.parameters.representation, true);
				result = require('syracuse-sdata/lib/render/pdf').render(_, self, result, proto);
				headers["content-type"] = httpHelper.mediaTypes.pdf;
				encoding = "binary";
				break;

				/*		case "xlsx":
			// excel will be pulling the data from server.
			// So it is a waste to generate data (and even more proto).
			// Review and improve later.
			//var proto = self.getPrototypeResource(_, self.parameters.representation, true);
			headers["content-type"] = httpHelper.mediaTypes.xlsx;
			headers["cache-control"] = "no-cache,must-revalidate";
			self.response.writeHead(statusCode, headers);
			var xlsxUrl = self.url + "?representation=" + self.parameters.representation;
			require('msoffice/lib/excel/xlsx').render(_, self.response, xlsxUrl, self.request.url);
			self.response.end();
			return; // response has been written

		case "docx":
			var proto = self.getPrototypeResource(_, self.parameters.representation, true);
			require('msoffice/lib/word/docx').render(_, self, result, proto, headers, statusCode);
			self.response.end();
			return;
*/
			case "pptx":
				var proto = self.getPrototypeResource(_, self.parameters.representation, true);
				require('msoffice/lib/ppt/pptx').render(_, self, result, proto, headers, statusCode);
				self.response.end();
				return;

			default:
				if (!headers["content-type"]) {
					headers["content-type"] = "text/plain";
					result = result && JSON.stringify(result);
				}
				break;
		}
		if (!self.batchResult) {
			//
			//	headers["cache-control"] = "no-cache,must-revalidate";
			//
			headers["content-length"] = Buffer.byteLength(result, encoding);
			//
		}
		httpHelper.tracer && httpHelper.tracer("HTTP RESPONSE: " + statusCode + " " + JSON.stringify(headers));
		httpHelper.tracer && httpHelper.tracer("BODY: " + result);
		if (self.batchResult) {
			if (result) {
				if (typeof result === "object") {
					helpers.object.copy(result, self.batchResult);
				} else {
					self.batchResult.$httpMessage = result;

				}
			}
			self.batchResult.$httpStatus = statusCode;
			return;
		}

		if (statusCode === 304) delete headers["content-length"];
		this.response.writeHead(statusCode, headers);
		if (this.response.managePaging) {
			this.response.managePaging.parameters = this.parameters;
			this.response.managePaging.location = this.location;
		}

		this.response.end(result, encoding);
	},
	setUser: function(user) {
		var self = this;
		self.request.session.setData("user", user);
		self.request.session.setData("userID", user.$key);
		self.request.session.setData("userLogin", user._data.login);
	},
	getUser: function(_) {
		var self = this;
		var userId = self.request.session.getData("userID");
		if (userId) {
			if (self._user && self._user.$uuid == userId) return self._user;
			var db = adminUtil.getCollaborationOrm(_);
			if (db) {
				self._user = db.fetchInstance(_, db.model.getEntity(_, "user"), this.request.session.getData("userID"));
				return self._user;
			}
		} else return null;
	},
	setUserProfile: function(_, userProfile) {
		this.httpSession.setUserProfile(_, userProfile);
	},
	getUserProfile: function(_) {
		return this.httpSession.getUserProfile(_);
	},
	updateUserProfile: function(_) {
		// !!!! this method updates user profile, be carrefull not to call it from an GET request
		var self = this;
		// avoid loops
		if (self.entity && (self.entity.name === "userProfile")) return;
		// user profile update
		var userProfile = self.getUserProfile(_);
		if (self.parameters && self.parameters.role && userProfile && /*temp!!!!*/ (self.parameters.role != "{$role}")) {
			// !!!! role, endpoint are not on the same model as context
			var modified = false;
			if (userProfile.selectedRole(_) && (userProfile.selectedRole(_).$uuid !== self.parameters.role)) {
				userProfile.selectedRole(_, userProfile._db.fetchInstance(_, userProfile._db.model.getEntity(_, "role"), self.parameters.role));
				modified = true;
			}
			/*			if (userProfile.selectedEndpoint(_) && !userProfile.selectedEndpoint(_).isSame(_, self.application && self.application.name, self.contract && self.contract.name, self.dataset)) {
				// TODO load new endpoint
				modified = true;
			}
			*/
			//
			modified && userProfile.save(_);
		}
	},
	getSelectedRoleId: function(_) {
		if (this.parameters.role && (this.parameters.role != "{$role}")) return this.parameters.role;
		var userProfile = this.getUserProfile(_);
		exports.tracer && exports.tracer("sdataContext.getUserProfileId - param: " + this.parameters["role"] + "; userProfile :" + sys.inspect(userProfile));
		return userProfile && userProfile.selectedRole(_) && userProfile.selectedRole(_).$uuid;
	},
	replyUser: function(_) {
		function notFound(_, ctxt) {
			ctxt.reply(_, 403, "you should create a session");
		}
		var userId = this.request.session.getData("userID");
		if (userId) {
			this.instanceId = userId;
			factory.replyInstance(_, this, notFound);
		} else notFound(_, this);
	},
	setMeta: function(forceChildren) {
		var self = this;
		self.meta = self.entity.getMeta(self.parameters, forceChildren);
	},
	getPrototypeResource: function(_, prototypeId, addSectionInfo, applicationName, contractName, datasetName) {
		// BRJOU added next 3 lines for PDF generation -- review
		applicationName = applicationName || (this.application && this.application.name);
		contractName = contractName || (this.contract && this.contract.name);
		datasetName = datasetName || this.dataset;
		//

		function _getEntityPrototype(_, entity, isChild, childPrefix) {
			// representation fields
			var url = self.baseUrl.split("/");
			url = url[0] + "//" + url[2] + "/" + url[3] + "/";
			url += (applicationName ? [applicationName, contractName, datasetName].join("/") : [url[4], url[5], url[6]].join("/"));
			var p = entity.getPrototype(_, representationName, representation.type, null, null, null, {
				include: params.include,
				select: params.select
			});
			p.$descriptor = "prototype " + prototypeId;
			p.$baseType = model.baseType;
			p.$baseUrl = url;
			p.$baseHelpUrl = url.replace("/sdata/", "/help/" + locale.current + "/");
			return p;
		}
		//
		var self = this;
		var params = self.parameters || {};
		// request parse
		var keys = prototypeId.split(",");
		var keys = keys[0].split(".");
		var representationName = keys[0];
		// if applicationName/contractName aren't provided, use same as contexts
		var contract;
		var model;
		if (applicationName) {
			contract = sdataRegistry.getContract(applicationName, contractName);
			if (!contract) return null;
			model = dataModel.make(contract, datasetName);
		} else {
			contract = this.contract;
			if (!contract) return null;
			model = this.model;
		}
		// extract from representation
		var rep = contract && contract.representations && contract.representations[representationName];
		var entityName = (rep && rep.$entityName) || representationName;
		//
		var representation = {
			application: applicationName,
			contract: contractName,
			entity: entityName,
			type: keys[1],
			// type is facet ...
			variant: keys[2]
		};
		//
		//		var stringRes = contract.resources && contract.resources();
		var mainEntity = model.getEntity(_, model.singularize(entityName) || entityName);
		if (!mainEntity) return null;
		//
		var res = _getEntityPrototype(_, mainEntity);
		// merge facets meta
		if (rep && rep.resources) res.$localization = rep.resources();

		// layout
		if (addSectionInfo) {
			var rep = (rep || contract.representations && contract.representations[mainEntity.name]);
			var repMeta = self.getRepresentationMeta(contract, rep, representation.type);
			if (repMeta) {
				var layout = repMeta.$layout && (repMeta.$layout.$copy ? ((self.getRepresentationMeta(contract, rep, repMeta.$layout.$copy) || {}).$layout) : repMeta.$layout);
				var gb = repMeta.$garbageFields && (repMeta.$garbageFields.$copy ? ((self.getRepresentationMeta(contract, rep, repMeta.$garbageFields.$copy) || {}).$garbageFields) : repMeta.$garbageFields);
				if (layout || gb) res.$article = {
					$layout: layout,
					$garbageFields: gb
				};
				// merge meta
				helpers.resource.applyDiff(res, repMeta.$prototype, true);
			}
		}
		//
		return res;
	},
	getRepresentationMeta: function(contract, representation, facetName) {
		var rep = representation;
		var facet = rep && rep.$facets && rep.$facets[facetName];
		return facet && (facet.$copy ? this.getRepresentationMeta(contract, representation, facet.$copy) : facet);
	},
	getRepresentation: function(contract, entityName, representationName) {
		return contract.representations && (contract.representations[representationName] || contract.representations[entityName]);
	},
	replyProperty: function(_, instance, propertyName) {
		var self = this;
		//
		var meta = instance.getEntity(_);
		var prop = meta.$properties && meta.$properties[propertyName];
		if (!prop) return self.reply(_, 404);
		//
		if (prop.isExternalStorage()) {
			var store = instance[propertyName](_);
			if (!store.fileExists(_)) return self.reply(_, 404);
			var props = store.getProperties(_);
			var headers = {
				"cache-control": "no-cache,must-revalidate",
				"expires": (new Date(0)).toString(),
				//"content-disposition": "attachment; filename=" + props.fileName
				"content-disposition": "filename=" + props.fileName,
				"content-type": props.contentType,
			};

			var isHtml = /html/.test(props.contentType);
			if (isHtml) headers["transfer-encoding"] = "chunked";
			else headers["content-length"] = props.length;

			self.response.writeHead(200, headers);
			var reader = store.createReadableStream(_);
			if (isHtml) reader = reader.map(function(_, buf) {
				return buf.toString('binary');
			}).transform(htmlTransforms.escaper());
			var buf;
			while (buf = reader.read(_)) {
				self.response.write(_, buf, "binary");
			}
			self.response.write(_);
		} else {
			self.reply(_, 200, instance[propertyName](_));
		}
	},
	replyPrototype: function(_) {
		var self = this;
		var reqEtag = self.request && self.request.headers && self.request.headers["if-none-match"];
		var locEtag = depend.etag([locale.current]);
		if (!nocache && reqEtag && (reqEtag === locEtag)) return self.reply(_, 304, {});
		var proto = this.getPrototypeResource(_, this.prototypeId, true);
		if (proto) this.reply(_, 200, proto, {
			ETag: locEtag,
			Expires: (new Date()).toGMTString()
		});
		else this.reply(_, 404, locale.format(module, "prototypeNotFound", this.prototypeId));
	},
	replyTemplate: function(_) {
		//create a working copy
		return this.replyPrototype(_);
	},
	getTemplate: function(_, entity, id) {
		// TODO
		//var self = this;
		//var dbHandle = self.getPrototype(_, entity, id);
		// for now -- will trigger additional rules later
		//return dbHandle;
	},
	validationError: function(path, message) {
		var self = this;
		self.validationErrors.push({
			path: path,
			message: message
		});
	},
	hasValidationErrors: function() {
		var self = this;
		return self.validationErrors.length > 0;
	},
	executeOperation: function(_) {
		exports.tracer && exports.tracer("sdataContext method execute enter");
		var self = this;
		var operation = self.operation;
		exports.tracer && exports.tracer("sdataContext method execute operation: " + operation.name + "; method: " + operation.method + "; method got: " + self.method);
		if (helpers.string.compare((operation.method || "GET"), self.method, true) != 0) throw self.badMethod("operation " + operation.name + " expected " + operation.method + ", got " + self.method);
		var res = null;
		var statusCode = 200;
		var sp = globals.context.session && globals.context.session.getSecurityProfile(_);
		sp && exports.tracer && exports.tracer("sdataContext.executeOperation found security profile: " + sp.code(_));
		if (sp && !sp.canReadClass(_, self.entity.name)) {
			return self.reply(_, httpHelper.HttpStatus.Forbidden, locale.format(module, "forbiddenExecute", operation.name, self.entity.name));
		}
		if (sp && !sp.canExecuteService(_, self.entity.name, operation.name)) {
			return self.reply(_, httpHelper.HttpStatus.Forbidden, locale.format(module, "forbiddenExecute", operation.name, self.entity.name));
		} else {
			if (operation.isMethod) {
				//				self.setMeta(false);
				//				var instance = self.db.fetchInstance(_, self.entity, self.instanceId);
				var instance = self.instance || factory.fetchInstance(_, self);
				exports.tracer && exports.tracer("sdataContext method execute found instance: " + ((instance && instance.$uuid) || "none"));
				if (!instance) return self.reply(_, httpHelper.HttpStatus.NotFound, locale.format(module, "notFound"));
				if (!instance.validateSelf(_)) return self.replyResource(_, httpHelper.HttpStatus.PreconditionFailed, instance.serializeInstance(_));
				res = operation.execute(_, self, instance);
				if (!res && !operation.$overridesReply) res = (self.initialInstance || instance).serializeInstance(_);
				statusCode = (res && res.$diagnoses || []).some(function(d) {
					return d.severity === "error";
				}) ? 500 : 200;
			} else res = operation.execute(_, self, null);
			if (!operation.$overridesReply) self.reply(_, statusCode, (res && res.body) ? res.body : res, res && res.headers);
		}
	},
	executeDatasetOperation: function(_) {
		throw this.niy("dataset operation");
	},
	getSerializeOptions: function() {
		var self = this;
		return {
			model: self.model,
			baseUrl: self.baseUrl,
			representation: self.representation,
			isPrototype: self.isPrototype,
			isTemplate: self.isTemplate,
			getPluralDbHandles: function(_, dbHandle, relation) {
				if (self.isPrototype || self.isTemplate) return null;
				else {
					var query = dbHandle[relation.name];
					relation.defaultOrder.forEach(function(order) {
						query = query.order(order[0], order[1]);
					});
				}
				// crnit : instance management
				if (!query || Array.isArray(query)) return query;
				else return query.list(self.transaction, _);
			}
		};
	},
	exception: function(statusCode, message) {
		var ex = new Error(message);
		ex.httpStatus = statusCode;
		return ex;
	},
	notFound: function(message) {
		var self = this;
		return self.exception(404, "Not found: " + message);
	},
	niy: function(message) {
		var self = this;
		return self.exception(501, "Not implemented: " + message);
	},
	badMethod: function(message) {
		var self = this;
		return self.exception(405, "Method not allowed: " + (message || self.method));
	},
	badRequest: function(message) {
		var self = this;
		return self.exception(400, "Bad request: " + message);
	},
	serverError: function(message) {
		var self = this;
		return self.exception(500, "Server error: " + message);
	},
	replyResource: function(_, statusCode, resource, etag) {
		var self = this;
		if (!resource) throw self.serverError("trying to reply null resource!");
		var headers = etag ? {
			ETag: etag,
			Expires: (new Date()).toGMTString() // IE9 needs this header in order to manage ETag
		} : null;
		return self.reply(_, statusCode, resource, headers);
	},
	replyResources: function(_, statusCode, resources) {
		var self = this;
		return self.reply(_, 200, _formatFeed(_, self, self.url, resources));
	},
	replySearchResults: function(_, statusCode, result) {
		var self = this;
		var feed = _formatFeed(_, self, self.url, result.$resources);
		feed.query = result.query;
		if (result.$searchFacets) feed.$searchFacets = result.$searchFacets;
		return self.reply(_, 200, feed);
	},
	replyDeleted: function(_) {
		var self = this;
		var loc = self.getLink("", "{$pluralType}", "$query", locale.format(module, "backToList"));
		return self.reply(_, 200, locale.format(module, "resourceDeleted"), {
			location: loc.$url
		});
	},
	replyDictionaryPage: function(_, dict, title, mapping) {
		var self = this;
		var baseUrl = self.walked();
		mapping = mapping || function(name) {
			return {
				$url: self.url + "/" + name,
				$key: name,
				$descriptor: title + " " + name,
				name: name
			};
		};

		var entries = helpers.object.toArray(dict, function(key, val) {
			return mapping(key, val);
		});
		entries.sort(function(e1, e2) {
			return helpers.string.compare(e1.name, e2.name, true);
		});
		var parameters = self.parameters;
		self.totalCount = entries.length;
		entries = entries.slice(parameters.startIndex - 1, parameters.startIndex - 1 + parameters.count);
		return self.reply(_, 200, _formatFeed(_, self, baseUrl, entries));
	},
	sortInstancesArray: function(_, resources, parameters, defaultOrder) {
		var orderBy = (parameters && parameters.orderBy);
		if (resources.length < 2 || (!orderBy || !orderBy.length) && (!defaultOrder || !defaultOrder.length)) return resources;
		if ((!orderBy || !orderBy.length) && defaultOrder) orderBy = defaultOrder.map(function(order) {
			return {
				binding: order[0],
				descending: !order[1]
			};
		});
		// sorting preparation (inspired by Schwartzian transform): prepare values and make temporary array: accumulate the sort attributes to a temporary array
		// this makes the sorting faster, finally strip the sort attributes and return the sorted array
		var sortFunctions = [];
		var sortOrder = [];
		sortOrder.length = sortFunctions.length = orderBy.length + 1;
		var sortValues = resources.map(function(resource) {
			var t = [resource];
			t.length = sortOrder.length;
			return t;
		});
		var props = resources[0]._meta.$properties;
		var i = sortOrder.length;
		while (--i > 0) {
			var prop = orderBy[orderBy.length - i].binding;
			sortFunctions[i] = props[prop].$computeSortValue;
			sortOrder[i] = orderBy[orderBy.length - i].descending ? -1 : 1;
			var j = resources.length;
			while (--j >= 0) {
				sortValues[j][i] = resources[j][prop](_);
			}
		}
		//		console.log("order by: "+sys.inspect(orderBy));
		return sortValues.sort(function(a, b) {
			for (var i = orderBy.length; i > 0; i--) { // all values are indexed because of Schwartzian transform
				var fkt = sortFunctions[i];
				if (fkt) {
					var diff = fkt(a[i], b[i]);
					if (diff) return diff * sortOrder[i];
				} else {
					if (a[i] !== b[i]) return (a[i] > b[i]) ? sortOrder[i] : -sortOrder[i];
				}
			}
			return 0;
		}).map(function(element) {
			return element[0];
		});
	},
	filterInstancesArray: function(_, instances, parameters) {
		var params = parameters || this.parameters.where;
		//
		return instances.filter_(_, function(_, instance) {
			return instance.match(_, params);
		});
	}
});