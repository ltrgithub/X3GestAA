"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Parser = require("./parser/parser").Parser;
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var sys = require("util");
var serizalizer = require("syracuse-core/lib/resource/serializer");
var sdataDbHandle = require("./sdataDbHandle");
var flows = require('streamline/lib/util/flows');
var httpHelper = require('syracuse-sdata/lib/httpHelper');
var HttpContext = httpHelper.HttpContext;
var factory = require("syracuse-orm/lib/factory");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminUtil = require("syracuse-collaboration/lib/util");
var pluralize = helpers.string.pluralize;
var locale = require("syracuse-core/lib/locale");

var _defaultCount = 20;
var _maxCount = 1000;

var queryRepr = ["$query", "$lookup", "$search", "$select"]; // query like facets
exports.tracer = console.log;
exports.tracer = null;

function _getTranslatedString(stringResources, parts, combineParts) {
	if(!stringResources || !parts || !parts.length) return "";
	for(var i = 0; i < (combineParts ? parts.length : 1); i++) {
		var str = stringResources[parts.slice(i).join(".")];
		//console.log("resource for : "+parts.slice(i).join(".")+"="+str);
		if(str) return str;
	}
	return "";
}

function _intValue(str, def) {
	return str == null ? def : parseInt(str, 10);
}

function _parsePaths(param) {
	if (!param) return;
	var result = {};
	param.split(',').forEach(function(path) {
		var obj = result;
		path.split('.').forEach(function(name) {
			obj[name] = {};
			obj = obj[name];
		});
	});
	return result;
}

function _parseParameters(query) {
	var parameters = helpers.object.clone(query);
	if (parameters.url) parameters = helpers.url.parseQueryString(parameters.url.split("?")[1]);
	// convert non-string parameters
	parameters.startIndex = _intValue(parameters.startIndex, 1);
	parameters.count = Math.min(_intValue(parameters.count, _defaultCount), _maxCount);
	parameters.orderBy = helpers.url.parseOrderBy(parameters.orderBy);
	parameters.select = _parsePaths(parameters.select);
	parameters.include = _parsePaths(parameters.include);
	parameters.includeSchema = parameters.includeSchema == "true";
	parameters.where = Parser.parse(parameters.where);
	return parameters;
};

function _splitRepresentation(str) {
	if (!str) return {};
	var comps = str.split(',');
	var comps = comps[0].split('.');
	return {
		application: comps[0],
		contract: comps[1],
		dataset: comps[2],
		entity: comps[3],
		type: comps[4],
		variant: comps[5]
	}
}

function _toHtml(context, result) {
	function replacer(key, value) {
		if (typeof value == "string" && value.indexOf("http") == 0) return "<a href='" + value.replace(/'/g, "%27") + "'>" + value + "</a>";
		else return value;
	};

	var body = typeof result == "object" ? JSON.stringify(result, replacer, 2) : result.toString();

	return "<html><head><title>" + result.$descriptor + "</title></head>" + "<body><pre>" + body + "</pre></body></html>"
}

function _queryString(parameters) {
	var items = helpers.object.toArray(parameters, function(key, val) {
		return key + "=" + encodeURIComponent(val);
	});
	return items.length == 0 ? "" : ("?" + items.join('&'));
}

function _formatKeyPagerFeed(context, url, results) {
	var parameters = helpers.object.clone(context.query);
	var uiMain = context.url.split('/').splice(0, 3).join('/') + "/syracuse-main/html/main.html"

	var feed = {
		$url: url + _queryString(parameters),
		$itemsPerPage: context.parameters.count,
		$resources: results,
		$links: {}
	};
	//
	parameters.orderBy = parameters.orderBy || ((context.entity.$defaultOrder && context.entity.$defaultOrder[0]) || [])[0];
	if(!parameters.orderBy)
		throw new Error(locale.format(module, "orderByRequired", context.entity.name));
	var orderProp = parameters.orderBy.split(" ")[0];
	//
	if (parameters.key) {
		delete parameters.key;
		feed.$links.$first = {
				$url: url + _queryString(parameters),
				$type: "application/json; vnd-sage=syracuse"
			};
	}

	if (!context.isLastPage && results.length) {
		parameters.key = "gt." + results[results.length-1][orderProp];
		feed.$links.$next = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	}
	if (feed.$links.$first && results.length) {
		parameters.key = "lt." + results[0][orderProp];
		feed.$links.$previous = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	}
	if (!context.isLastPage) {
		parameters.key = "lt.zzzzzz";
		feed.$links.$last = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	}
	return feed;
}

function _formatDefaultFeed(context, url, results) {
	var parameters = helpers.object.clone(context.query);
	var uiMain = context.url.split('/').splice(0, 3).join('/') + "/syracuse-main/html/main.html"

	var feed = {
		$url: url + _queryString(parameters),
		$descriptor: context.entity ? context.entity.plural : context.currentSegment,
		$startIndex: context.parameters.startIndex,
		$itemsPerPage: context.parameters.count,
		$totalResults: context.totalCount,
		$ui: uiMain + "#ui=" + url + "/$ui/master" + "&data=" + url,
		$resources: results,
		$links: {}
	};
	parameters.startIndex = 1;
	parameters.count = feed.$itemsPerPage;
	if ((feed.$totalResults > feed.$itemsPerPage) && (feed.$startIndex > feed.$itemsPerPage))
		feed.$links.$first = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		};

	if (feed.$startIndex + feed.$itemsPerPage <= feed.$totalResults) {
		parameters.startIndex = feed.$startIndex + feed.$itemsPerPage;
//		parameters.letter = "{$letter}";
//		parameters.key = "gt." + results[results.length-1].$uuid;
		parameters.count = feed.$itemsPerPage;
		feed.$links.$next = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	}
	if (feed.$startIndex > 1) {
		parameters.startIndex = Math.max(1, feed.$startIndex - feed.$itemsPerPage);
//		parameters.count = feed.$startIndex - parameters.startIndex;
		// leave count to "itemsPerPage", it serves to link formatting
		parameters.count = feed.$itemsPerPage;
		feed.$links.$previous = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	}
	var lastCount = feed.$totalResults % feed.$itemsPerPage;
	if (lastCount === 0)
		lastCount = feed.$itemsPerPage;
	parameters.startIndex = Math.max(1, 1 + feed.$totalResults - lastCount);
	parameters.count = lastCount;
	if ((feed.$totalResults > feed.$itemsPerPage) && (feed.$startIndex < parameters.startIndex))
		feed.$links.$last = {
			$url: url + _queryString(parameters),
			$type: "application/json; vnd-sage=syracuse"
		}
	if (context.entity) {
		feed.$template = {
			$url: url + "/$template"
		};
	}
	//
	return feed;
}

function _formatFeed(context, url, results) {
	var feed;
	if(context.entity && context.entity.$keyPager)
		feed = _formatKeyPagerFeed(context, url, results);
	else
		feed = _formatDefaultFeed(context, url, results);
	if (context.entity) {
		feed.$template = {
			$url: url + "/$template"
		};
	}
	// excel
	var order = [];
	context.parameters.orderBy.forEach(function(orderBy) {
		order.push(orderBy.binding + " " + (orderBy.descending ? "desc" : "asc"));
	});

	feed.$links.$excel = {
		$url: feed.$url,
		$title: locale.format(module, "excel"),
		$type: httpHelper.mediaTypes.excel_worksheet
	}
	//
	return feed;
}

function Context(request, response, options) {
	HttpContext.call(this, request, response, {
		acceptParam: "format"
	});
	exports.tracer = exports.tracer || (options && options.tracer);
	var self = this;
	self.parameters = _parseParameters(self.query);

	self.segments = self.path.split('/').map(function(seg) {
		return decodeURIComponent(seg);
	});
	self.where = [];
	self.representation = {};
	if (self.parameters && self.parameters.representation) {
		var parts = self.parameters.representation.split(".");
		self.representation = {
			application: self.application,
			contract: self.contract,
			dataset: self.dataset,
			entity: parts[0], // representation, not entity
			type: parts[1], // facet
			variant: parts[2]
		}
	}
	// obsolette
	//else self.representation = _splitRepresentation(self.accept[0].parameters["vnd.sage.syracuse.representation"]);
	self.validationErrors = [];
	self.httpSession = request.session;
	self.reply = exports.Context.prototype.reply; // fix later
}

exports.Context = helpers.defineClass(Context, HttpContext, {
	getLink: function(singular, plural, facetName, title, params) {
		if(!singular) singular = "{$representation}";
		var link = {
			$type: "application/json;vnd.sage=syracuse"
		}
		if (title) link.$title = title;
		switch (facetName) {
		case "$details":
			link.$url = "{$baseUrl}/" + plural + "('{$key}')?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			break;
		case "$lookup":
		case "$select":
		case "$query":
			link.$url = "{$baseUrl}/" + plural + "?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			break;
		case "$edit":
			link.$url = "{$baseUrl}/" + plural + "('{$key}')/$workingCopies?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			link.$method = "POST";
			break;
		case "$create":
			// $create facet is in fact an $edit facet
			link.$url = "{$baseUrl}/" + plural + "/$template/$workingCopies?representation=" + singular + ".$edit&role={$role}" + (params ? "&" + params : "");
			link.$method = "POST";
			break;
		}
		return link;
	},
	getEntity: function() {
		if(this.entity) return this.entity;
		// load from representation
		if(this.contract && this.contract.representations && this.representation.entity) {
			var repr = this.contract.representations[this.representation.entity];
			return repr ? this.model.getEntity(repr.$entityName) : this.model.getEntity(this.representation.entity);
		}
		return null;
	},
	addComplementFilter: function(_, params) {
		function processFilter(_, instance, filterNode, filterPart) {
			flows.eachKey(_, filterPart, function(_, key, value) {
				exports.tracer && exports.tracer("sdataContext.processFilter parts: " + key + "=" + sys.inspect(value));
				// TODO : extend / standardize parser
				if(Array.isArray(value)) {
					filterNode[key] = value.map_(_, function(_, item) {
						var filterItem = {};
						processFilter(_, instance, filterItem, item);
						return filterItem;
					});
				} else {
					if(value == null) {
						filterNode[key] = null;
					} else
						if (typeof value === "object") {
							filterNode[key] = {};
							processFilter(_, instance, filterNode[key], value);
						} else 
							if (typeof value === "string") {
								var template = new resourceProxy.Template(value);
								if (template.matches && template.matches.length >= 1) {
									exports.tracer && exports.tracer("sdataContext.processFilter template: " + key + "=" + sys.inspect(template.matches));
									// supported for now : {prop|relation} | {$parent}.{prop|relation}
									var propName = template.matches.pop();
									propName = propName.substring(1, propName.length - 1);
									//
/*									for(var i = template.matches.length - 1; i >= 0; i--)
										if((template.matches[i] === "{$parent}") && instance) {
											instance = instance._parent;
										}
									*/
									template.matches.forEach_(_, function(_, match) {
										if(!instance) return;
										var rel = match.substring(1, match.length - 1);
										if(rel === "$parent")
											instance = instance._parent;
										else {
											if(instance._meta.$relations[rel] && !instance._meta.$relations[rel].isPlural) {
												exports.tracer && exports.tracer("sdataContext.processFilter walking to: " + rel);
												instance = instance[rel](_);
											}
										}
									});
									//
									if(instance) {
										var prop = instance._meta.$properties[propName];
										if (prop) 
											filterNode[key] = instance[propName](_);
										else {
											var rel = instance._meta.$relations[propName];
											if (rel) {
												if (rel.isPlural) 
													filterNode[key] = instance[propName](_).toUuidArray(_);
												else 
													if(instance[propName](_))
														filterNode[key] = instance[propName](_).$uuid;
											}
										}
									}
								} else
									filterNode[key] = value;
							}
				}
			});
		}
		function _step(_, instance, relName) {
			var bindings = /([^\/(]*)\('([^']*)'\)\/(.*)/.exec(relName);	
			exports.tracer && exports.tracer("sdataContext.addComplementFilter bindings: " + sys.inspect(bindings));
			//
			if (!instance) return;
			exports.tracer && exports.tracer("sdataContext.addComplementFilter found instance: " + instance.$uuid);
			if(bindings && bindings.length) {
				exports.tracer && exports.tracer("sdataContext.addComplementFilter stepping child: " + bindings[1] + "('" + bindings[2] + "')/" + bindings[3]);
				if(instance._meta.$relations[bindings[1]] && instance._meta.$relations[bindings[1]].isPlural)
					instance = instance[bindings[1]](_).get(_, bindings[2]);
				else
					instance = instance[bindings[1]](_);
				relName = bindings[3];
				return _step(_, instance, bindings[3]);
			} else {
				exports.tracer && exports.tracer("sdataContext.addComplementFilter fetching relation: " + relName);
				return {
					instance: instance,
					relName: relName
				};
			}
		}
		// add relation filter if necessary
		exports.tracer && exports.tracer("sdataContext.addComplementFilter enter");
		if (params.trackingId && params.binding) {
			// binding is "relation" | "childRelation('childId')/relation"
			var res = _step(_, this.httpSession[params.trackingId], params.binding) || {};
			var instance = res.instance;
			var relName = res.relName;
			//
			if(!instance) return;
			var rel = instance._meta.$relations[relName];
			if (!rel) return;
			exports.tracer && exports.tracer("sdataContext.addComplementFilter found rel: " + rel.name);
			var filter = params.jsonWhere = params.jsonWhere || {};
			// TODO : different filters must properly concatenate
			if (rel.$lookupFilter) {
				if (typeof rel.$lookupFilter !== "function")
					processFilter(_, instance, filter, rel.$lookupFilter);
				else 
					processFilter(_, instance, filter, rel.$lookupFilter(_, instance));
			}
			//
			if (rel.isPlural) {
				var uuidColl = instance[rel.name](_).toUuidArray(_, true);
				exports.tracer && exports.tracer("sdataContext.addComplementFilter found collection: " + sys.inspect(uuidColl));
				if (uuidColl.length) filter.$uuid = {
					"$nin": uuidColl
				};
			}
			//
			exports.tracer && exports.tracer("sdataContext.addComplementFilter filter: " + sys.inspect(filter, null, 4));
		}
	},
	reply: function(_, statusCode, result, headers) {
		var self = this;
		headers = headers || {};
		
		if (statusCode == 201) {
			headers.location = headers.location || (result && result.$url);
			if (!headers.location) return self.reply(_, 500, "Server erorr: $url missing in 201 response");
			if (self.batchResult) self.batchResult.$httpLocation = headers.location;
		}
		if (!result) {
			httpHelper.tracer && httpHelper.tracer("HTTP RESPONSE: " + statusCode + " " + JSON.stringify(headers));
			if (self.batchResult) return;
			this.response.writeHead(statusCode, headers);
			return this.response.end();
		}
		var encoding = "utf8";
		switch (this.accept[0].type) {
		case "json":
		case "*":
			if (typeof result == "string") {
				result = {
					$diagnoses: [{
						severity: statusCode >= 400 ? "error" : "info",
						message: result
					}]
				};
			}
			// '{' test to avoid problem with pattern in prototype.
			var type = headers["content-type"] || (result.$type && result.$type[0] != '{' && result.$type);
			if (type && type.indexOf("application/json") < 0) {
				return self.reply(_, 406, "expected JSON, got " + result.$type);
			}
			type= type || "application/json";
			if (type.search(/;charset=/i)<0) type+=";charset=UTF-8";
			headers["content-type"] = type;
			if (!self.batchResult) result = JSON.stringify(result);
			break;

		case "xml":
			return self.reply(_, 406, "expected JSON, got " + result.$type);

		case "html":
			headers["content-type"] = "text/html"
			result = _toHtml(self, result);
			break;

		case "text":
			headers["content-type"] = "text/plain"
			result = typeof result == "object" ? JSON.stringify(result, null, 2) : result.toString();
			break;

		case "pdf":
			var proto = self.getPrototypeResource(_, self.parameters.representation, true);
			result = require('syracuse-sdata/lib/render/pdf').render(_, self, result, proto);
			headers["content-type"] = httpHelper.mediaTypes.pdf;
			encoding = "binary";
			break;

/*		case "xlsx":
			// excel will be pulling the data from server. 
			// So it is a waste to generate data (and even more proto).
			// Review and improve later.
			//var proto = self.getPrototypeResource(_, self.parameters.representation, true);
			headers["content-type"] = httpHelper.mediaTypes.xlsx;
			headers["cache-control"] = "no-cache,must-revalidate";
			self.response.writeHead(statusCode, headers);
			var xlsxUrl = self.url + "?representation=" + self.parameters.representation;
			require('msoffice/lib/excel/xlsx').render(_, self.response, xlsxUrl, self.request.url);
			self.response.end();
			return; // response has been written
			
		case "docx": 
			var proto = self.getPrototypeResource(_, self.parameters.representation, true);
			require('msoffice/lib/word/docx').render(_, self, result, proto, headers, statusCode);
			self.response.end();
			return;
*/
		case "pptx": 
			var proto = self.getPrototypeResource(_, self.parameters.representation, true);
			require('msoffice/lib/ppt/pptx').render(_, self, result, proto, headers, statusCode);
			self.response.end();
			return;

		default:
			if (!headers["content-type"]) {
				headers["content-type"] = "text/plain";
				result = result && result.toString();
			}
			break;
		}
		if (!self.batchResult) {
			//
			headers["cache-control"] = "no-cache,must-revalidate";
			//
			headers["content-length"] = Buffer.byteLength(result, encoding);
			//
		}
		httpHelper.tracer && httpHelper.tracer("HTTP RESPONSE: " + statusCode + " " + JSON.stringify(headers));
		httpHelper.tracer && httpHelper.tracer("BODY: " + result);
		if (self.batchResult) {
			if (result) {
				if (typeof result === "object") {
					helpers.object.copy(result, self.batchResult);
				} else  {
					self.batchResult.$httpMessage = result;
					
				}
			}	
			self.batchResult.$httpStatus = statusCode;
			return;
		}
		this.response.writeHead(statusCode, headers);
		this.response.end(result, encoding);
	},

	withTransaction: function(_, doIt) {
		var self = this;
		var session = self.model.connect(_, self.dataset);
		self.session = session;
		self.transaction = session.transaction(true, _);
		try {
			return doIt && doIt(_);
		} catch (ex) {
			self.transaction.rollback(session, _);
			throw ex;
		} finally {
			self.transaction = null;
		}
	},
	setUser: function(user) {
		var self = this;
		self.request.session.setData("user", user);
		self.request.session.setData("userID", user.$key);
		self.request.session.setData("userLogin", user._data.login);
	},
	getUser: function(_) {
		var self = this;
		var userId = self.request.session.getData("userID");
		if(userId) {
			if(self._user && self._user.$uuid == userId)
				return self._user;
			var db = adminUtil.getCollaborationOrm(_);
			if (db) {
				self._user = db.fetchInstance(_, db.model.getEntity("user"), this.request.session.getData("userID"));
				return self._user;
			}
		} else
			return null;
	},
	setUserProfile: function(_, userProfile) {
		this.httpSession.setUserProfile(_, userProfile);
	},
	getUserProfile: function(_) {
		return this.httpSession.getUserProfile(_);
	},
	updateUserProfile: function(_) {
		// !!!! this method updates user profile, be carrefull not to call it from an GET request
		var self = this;
		// avoid loops
		if (self.entity && (self.entity.name === "userProfile")) return;
		// user profile update
		var userProfile = self.getUserProfile(_);
		if (self.parameters && self.parameters.role && userProfile && /*temp!!!!*/ (self.parameters.role != "{$role}")) {
			// !!!! role, endpoint are not on the same model as context
			var modified = false;
			if (userProfile.selectedRole(_) && (userProfile.selectedRole(_).$uuid !== self.parameters.role)) {
				userProfile.selectedRole(_, userProfile._db.fetchInstance(_, userProfile._db.model.getEntity("role"), self.parameters.role));
				modified = true;
			}
/*			if (userProfile.selectedEndpoint(_) && !userProfile.selectedEndpoint(_).isSame(_, self.application && self.application.name, self.contract && self.contract.name, self.dataset)) {
				// TODO load new endpoint
				modified = true;
			}
			*/
			//
			modified && userProfile.save(_);
		}
	},
	getSelectedRoleId: function(_) {
		var userProfile = this.getUserProfile(_);
		exports.tracer && exports.tracer("sdataContext.getUserProfileId - param: " + this.parameters["role"] + "; userProfile :" + sys.inspect(userProfile));
		return ((this.parameters["role"] /*temp$*/ && (this.parameters["role"] != "{$role}")) ? this.parameters["role"] : ((userProfile && userProfile.selectedRole(_)) ? userProfile.selectedRole(_).$uuid : null));
	},
	replyUser: function(_) {
		function notFound(_, ctxt) {
			ctxt.reply(_, 403, "you should create a session");
		}
		if (helpers.useInstances) {
			var userId = this.request.session.getData("userID");
			if (userId) {
				this.instanceId = userId;
				factory.replyInstance(_, this, notFound);
			} else notFound(_, this);
		} else {
			var user = this.getUser(_);
			if (!user) this.reply(_, 403, "you should create a session");
			return this.replyDbHandle(_, 200, user);
		}
	},
	setMeta: function(forceChildren) {
		var self = this;
		self.meta = self.entity.getMeta(self.parameters, forceChildren);
	},
	getPrototypeResource: function(_, prototypeId, addSectionInfo, applicationName, contractName, datasetName) {
		// BRJOU added next 3 lines for PDF generation -- review
		applicationName = applicationName || (this.application && this.application.name);
		contractName = contractName || (this.contract && this.contract.name);
		datasetName = datasetName || this.dataset;
		//
		function _getEntityPrototype(_, entity, isChild, childPrefix) {
			// representation fields
			var url = self.baseUrl.split("/");
			url = url[0] + "//" + url[2] + "/" + url[3] + "/";
			url += (applicationName ? [applicationName, contractName, datasetName].join("/") : [url[4], url[5], url[6]].join("/"));
			var p = entity.getPrototype(_, representationName, representation.type);
			p.$descriptor = "prototype " + prototypeId;
			p.$baseType = model.baseType;
			p.$baseUrl = url;
			return p;
		}
		//
		var self = this;
		// request parse
		var keys = prototypeId.split(",");
		var keys = keys[0].split(".");
		var representationName = keys[0];
		// if applicationName/contractName aren't provided, use same as contexts
		var contract;
		var model;
		if(applicationName) {
			contract = sdataRegistry.getContract(applicationName, contractName);
			if (!contract) return null;
			model = dataModel.make(contract, datasetName);
		} else {
			contract = this.contract;
			if (!contract) return null;
			model = this.model;
		}
		// extract from representation
		var rep = contract && contract.representations && contract.representations[representationName];
		var entityName = (rep && rep.$entityName) || representationName;
		//
		var representation = {
			application: applicationName,
			contract: contractName,
			entity: entityName,
			type: keys[1],
			// type is facet ...
			variant: keys[2]
		}
		//
		var stringRes = contract.resources && contract.resources();
		var mainEntity = model.getEntity(model.singularize(entityName) || entityName);
//		if (!mainEntity) throw self.notFound(locale.format(module, "entityNotFound", model.singularize(entityName)));
		if(!mainEntity) return null;
		//
		var res = _getEntityPrototype(_, mainEntity);
		// merge facets meta
		if(stringRes && stringRes[representationName]) res.$localization = stringRes[representationName];
		
		// layout
		if (addSectionInfo) {
			var rep = (rep || contract.representations && contract.representations[mainEntity.name]);
			var repMeta = self.getRepresentationMeta(contract, rep, representation.type);
			if (repMeta) {
				var layout = repMeta.$layout && (repMeta.$layout.$copy ? ((self.getRepresentationMeta(contract, rep, repMeta.$layout.$copy) || {}).$layout) : repMeta.$layout);
				if(layout)
				res.$article = {
					$layout: layout
				}
				// merge meta
				helpers.resource.applyDiff(res, repMeta.$prototype, true);
			}
		}
		//
		return res;
	},
	getRepresentationMeta: function(contract, representation, facetName) {
		var rep = representation;
		var facet = rep && rep.$facets && rep.$facets[facetName];
		return facet && (facet.$copy ? this.getRepresentationMeta(contract, representation, facet.$copy) : facet);
	},
	getRepresentation: function(contract, entityName, representationName) {
		return contract.representations && (contract.representations[representationName] || contract.representations[entityName]);
	},
	replyProperty: function(_, instance, propertyName) {
		var store = instance[propertyName](_);
		if (!store.fileExists(_)) return this.reply(_, 404);
		var props = store.getProperties(_);
		var headers = {
			"content-length": props.length,
			"cache-control": "no-cache,must-revalidate",
			"expires": (new Date(0)).toString(),
			"content-disposition": "attachment; filename=" + props.fileName
		};
		headers["content-type"] = props.contentType;
		this.response.writeHead(200, headers);
		var stream = store.createReadableStream(_);
		var buf;
		while(buf = stream.read(_, props.chunkSize))
			this.response.write(_, buf, "binary");
		this.response.end();
	},
	replyPrototype: function(_) {
		var proto = this.getPrototypeResource(_, this.prototypeId);
		if(proto)
			this.reply(_, 200, proto);
		else
			this.reply(_, 404, locale.format(module, "prototypeNotFound", this.prototypeId));
	},
	replyTemplate: function(_) {
		//create a working copy
		return this.replyPrototype(_);
	},
	getTemplate: function(_, entity, id) {
		// TODO
		//var self = this;
		//var dbHandle = self.getPrototype(_, entity, id);
		// for now -- will trigger additional rules later
		//return dbHandle;
	},
	validationError: function(path, message) {
		var self = this;
		self.validationErrors.push({
			path: path,
			message: message
		});
	},
	hasValidationErrors: function() {
		var self = this;
		return self.validationErrors.length > 0;
	},
	executeOperation: function(_) {
		exports.tracer && exports.tracer("sdataContext method execute enter");
		var self = this;
		var operation = self.operation;
		exports.tracer && exports.tracer("sdataContext method execute operation: " + operation.name + "; method: " + operation.method + "; method got: " + self.method);
		if (helpers.string.compare((operation.method || "GET"), self.method, true) != 0) 
			throw self.badMethod("operation " + operation.name + " expected " + operation.method + ", got " + self.method);
		var res = null;
		var statusCode = 200;
		if (operation.isMethod) {
//			self.setMeta(false);
			var instance = self.db.fetchInstance(_, self.entity, self.instanceId);
			exports.tracer && exports.tracer("sdataContext method execute found instance: " + instance && instance.$uuid);
			res = operation.execute(_, self, instance);
			if(!res) res = instance.serializeInstance(_);
			statusCode = (res.$diagnoses || []).some(function(d) {
				return d.severity === "error";
			}) ? 500 : 200;
		} else 
			res = operation.execute(_, self, null);
		self.reply(_, statusCode, (res && res.body) ? res.body : res, res && res.headers);
	},
	executeDatasetOperation: function(_) {
		throw context.niy("dataset operation");
	},
	getSerializeOptions: function() {
		var self = this;
		return {
			model: self.model,
			baseUrl: self.baseUrl,
			representation: self.representation,
			isPrototype: self.isPrototype,
			isTemplate: self.isTemplate,
			getPluralDbHandles: function(_, dbHandle, relation) {
				if (self.isPrototype || self.isTemplate) return null;
				else {
					var query = dbHandle[relation.name];
					relation.defaultOrder.forEach(function(order) {
						query = query.order(order[0], order[1]);
					})
				}
				// crnit : instance management
				if (!query || Array.isArray(query)) return query;
				else return query.list(self.transaction, _);
			}
		};
	},
	exception: function(statusCode, message) {
		var ex = new Error(message);
		ex.httpStatus = statusCode;
		return ex;
	},
	notFound: function(message) {
		var self = this;
		return self.exception(404, "Not found: " + message);
	},
	niy: function(message) {
		var self = this;
		return self.exception(501, "Not implemented: " + message);
	},
	badMethod: function(message) {
		var self = this;
		return self.exception(405, "Method not allowed: " + (message || self.method));
	},
	badRequest: function(message) {
		var self = this;
		return self.exception(400, "Bad request: " + message);
	},
	serverError: function(message) {
		var self = this;
		return self.exception(500, "Server error: " + message);
	},
	replyDbHandle: function(_, statusCode, dbHandle, options) {
		var self = this;
		options = options || self.getSerializeOptions();
		options.url = true;
		var resource;
		if (typeof dbHandle.serialize == "function") // page resource hack
		resource = dbHandle.serialize(_);
		else resource = serizalizer.serialize(_, dbHandle, self.meta, options);
		return self.replyResource(_, statusCode, resource);
	},
	replyDbHandles: function(_, statusCode, results) {
		var self = this;
		var resources = self.toResources(_, results);
		return self.reply(_, 200, _formatFeed(self, self.url, resources));
	},
	replyResource: function(_, statusCode, resource) {
		var self = this;
		if (!resource) throw self.serverError("trying to reply null resource!")
		return self.reply(_, statusCode, resource);
	},
	replyResources: function(_, statusCode, resources) {
		var self = this;
		return self.reply(_, 200, _formatFeed(self, self.url, resources));
	},
	replySearchResults: function(_, statusCode, result) {
		var self = this;
		var feed = _formatFeed(self, self.url, result.$resources);
		feed.query = result.query;
		if (result.$searchFacets) feed.$searchFacets = result.$searchFacets;
		return self.reply(_, 200, feed);
	},
	replyDeleted: function(_) {
		var self = this;
		var loc = self.getLink("", "{$pluralType}", "$query", locale.format(module, "backToList"));
		return self.reply(_, 200, locale.format(module, "resourceDeleted"), {location:loc.$url});
	},
	replyDictionaryPage: function(_, dict, title, mapping) {
		var self = this;
		var baseUrl = self.walked();
		mapping = mapping ||
		function(name) {
			return {
				$url: self.url + "/" + name,
				$key: name,
				$descriptor: title + " " + name,
				name: name
			};
		}

		var entries = helpers.object.toArray(dict, function(key, val) {
			return mapping(key, val);
		});
		entries.sort(function(e1, e2) {
			return helpers.string.compare(e1.name, e2.name, true);
		});
		var parameters = self.parameters;
		self.totalCount = entries.length;
		entries = entries.slice(parameters.startIndex - 1, parameters.startIndex - 1 + parameters.count);
		return self.reply(_, 200, _formatFeed(self, baseUrl, entries));
	},
	sortInstancesArray: function(_, resources, parameters, defaultOrder) {
		var orderBy = (parameters && parameters.orderBy);
		if (resources.length < 2 || (!orderBy || !orderBy.length) && (!defaultOrder || !defaultOrder.length)) 
			return resources;
		if((!orderBy || !orderBy.length) && defaultOrder)
			orderBy = defaultOrder.map(function(order) {
				return {
					binding: order[0],
					descending: !order[1]
				}
			});
		// sorting preparation (inspired by Schwartzian transform): prepare values and make temporary array: accumulate the sort attributes to a temporary array
		// this makes the sorting faster, finally strip the sort attributes and return the sorted array 
		var sortFunctions = [];
		var sortOrder = [];
		sortOrder.length = sortFunctions.length = orderBy.length+1;
		var sortValues = resources.map(function(resource){ var t = [resource]; t.length = sortOrder.length; return t; })
		var props = resources[0]._meta.$properties;
		var i = sortOrder.length;
		while (--i > 0) {
			var prop = orderBy[orderBy.length-i].binding;
			sortFunctions[i] = props[prop].$computeSortValue;
			sortOrder[i] = orderBy[orderBy.length-i].descending ? -1 : 1;
			var j = resources.length;
			while (--j >= 0) {
				sortValues[j][i] = resources[j][prop](_);
			}
		}
//		console.log("order by: "+sys.inspect(orderBy));
		return sortValues.sort(function(a, b) {
			for (var i = orderBy.length; i > 0; i--) { // all values are indexed because of Schwartzian transform
				var fkt = sortFunctions[i];
				if (fkt) {
					var diff = fkt(a[i], b[i])
					if (diff)
						return diff*sortOrder[i];
				} else {
					if(a[i] !== b[i]) 
						return (a[i] > b[i]) ? sortOrder[i] : -sortOrder[i];
				}
			}
			return 0;
		}).map(function (element) { return element[0] });
	},
	filterInstancesArray: function(_, instances, parameters) {
		var params = parameters || this.parameters.where;
		//
		return instances.filter_(_, function(_, instance) {
			return instance.match(_, params);
		});
	}
})
