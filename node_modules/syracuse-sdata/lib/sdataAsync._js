"use strict";

var helpers = require("syracuse-core/lib/helpers");

var TrackerResponse = helpers.defineClass(function() {
    this.status = 202;
    this.head = null;
    this.encoding = null;
    this.chunks = [];
}, null, {
    writeHead: function(status, head) {
        this.status = status;
        this.head = head;
    },
    write: function(_, data, encoding) {
        this.encoding = encoding;
        this.chunks.push(data);
    },
    end: function(data) {
        if (data) this.chunks.push(data);
    },
    finish: function(err) {
        if (err) {
            this.status = 500, this.head = {
                "content-type": "application/json"
            };
            this.encoding = "utf8", this.chunks = [JSON.stringify({
                $diagnoses: [{
                    severity: "error",
                    message: err.message
                }]
            })];
        }
    },
    flush: function(_, response) {
        response.writeHead(this.status, this.head);
        for (var i = 0; i < this.chunks.length; i++)
        response.write(_, this.chunks[i], this.encoding);
        response.end();
    }
});

var Tracker = helpers.defineClass(function(context, trackingId, dispatch) {
    var self = this;
    this.response = context.response;
    this.status = 202;
    this.headers = {
        "content-type": "application/json",
        location: "/sdata/$trackers('" + trackingId + "')",
    };
    this.tracker = {
        phase: "starting",
        pollingMillis: 1000,
    }
    dispatch(function(err) {
        self.tracker = null;
        self.response.finish(err);
    }, context);
}, null, {
    reply: function(_, response) {
        if (this.tracker) {
            response.writeHead(this.status, this.headers);
            response.write(_, JSON.stringify(this.tracker), "utf8");
            response.end();
        } else {
            this.response.flush(_, response);
        }
    }
});

var trackers = {};

exports.track = function(_, context, id) {
    var tracker = trackers[id];
    if (!tracker) return context.reply(_, 404, "tracker not found: " + id);
    tracker.reply(_, context.response);
}

exports.start = function(_, context, dispatch) {
    var trackingId = context.parameters.trackngId;
    var response = context.response;
    var tracker = trackers[trackingId];
    if (!tracker) {
        context.response = new TrackerResponse();
        trackers[trackingId] = tracker = new Tracker(context, trackingId, dispatch);
    }
    tracker.reply(_, response);
}