"use strict";

var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var util = require('util');

var TrackerResponse = helpers.defineClass(function() {
	this.status = 202;
	this.head = null;
	this.encoding = null;
	this.chunks = [];
}, null, {
	writeHead: function(status, head) {
		this.status = status;
		this.head = head;
	},
	write: function(_, data, encoding) {
		this.encoding = encoding;
		this.chunks.push(data);
	},
	end: function(data) {
		if (data) this.chunks.push(data);
	},
	finish: function(err) {
		if (err) {
			this.status = 500, this.head = {
				"content-type": "application/json"
			};
			this.encoding = "utf8", this.chunks = [JSON.stringify({
				$diagnoses: [{
					$severity: "error",
					$message: err.message ? err.message : err,
					$stackTrace: err.stack
				}]
			})];
		} else {
			if (this.status === 202) { // only set status when it has not been explicitly set in writeHead function
				this.status = 200;
			}
		}
	},
	flush: function(_, response) {
		response.writeHead(this.status, this.head);
		for (var i = 0; i < this.chunks.length; i++) {
			response.write(_, this.chunks[i], this.encoding);
		}
		response.end();
	}
});

function _serialize(tracker) {
	var t = {
		location: tracker.location,
		phase: tracker.phase,
		phaseDetail: tracker.phaseDetail,
		progress: tracker.progress,
		elapsedSeconds: tracker.elapsedSeconds,
		remainingSeconds: tracker.remainingSeconds,
		pollingMillis: tracker.pollingMillis,
		$diagnoses: tracker.$diagnoses,
		$links: tracker.$links
	};
	// add standard suspend / resume links
	if (!tracker.done) {
		t.$links = t.$links || {};
		/*		if(tracker.suspended) 
			t.$links.$resume = {
				$title: locale.format(module, "resumeTitle"),
				$url: tracker.location + "?resume=true",
				$method: "PUT"
			};
		else {
			t.$links.$suspend = {
				$title: locale.format(module, "suspendTitle"),
				$url: tracker.location + "?suspend=true",
				$method: "PUT"
			};
		}*/
		if (tracker.canAbort) {
			t.$links.$abort = {
				$title: locale.format(module, "abortTitle"),
				$url: tracker.location + "?abort=true",
				$method: "PUT"
			};
		}
	}
	return t;
}

var Tracker = helpers.defineClass(function(context, trackerResponse, trackngId, dispatch) {
	this.trackngId = trackngId;
	this.response = trackerResponse;
	this.status = 202;
	this.done = false;
	this.suspended = false;
	this.abortRequested = false;
	this.location;
	this.convStep;
	this.maxtry;
	this.nbtry;

	this.context = context;
	this.phase = locale.format(module, "starting");
	this.phaseDetail = null;
	this.progress = null;
	this.elapsedSeconds = null;
	this.remainingSeconds = null;
	this.pollingMillis = 1000;
	this.startTime = new Date().getTime();
	this.dispatch = dispatch;

}, null, {
	reply: function(_, response) {
		var headers = {
			"content-type": "application/json",
			location: this.location,
		};
		var body;
		if (!this.done) {
			var currentTime = new Date().getTime();
			this.elapsedSeconds = Math.floor((currentTime - this.startTime) / 1000);
			response.writeHead(this.status, headers);
			body = _serialize(this);
			response.write(_, JSON.stringify(body), "utf8");

			response.end();
		} else {
			if (this.abortRequested) {
				this.phase = locale.format(module, "aborted");
			} else {
				this.phase = locale.format(module, "completed");
			}

			if (this.response) {
				this.response.flush(_, response);
				this.response = null;
			} else {
				response.writeHead(200, headers);

				body = _serialize(this);
				response.write(_, JSON.stringify(body), "utf8");

				response.end();
			}
		}
	},
	requestAbort: function() {
		this.abortRequested = true;
	},
	acceptAbort: function() {
		this.phase = locale.format(module, "aborted");
	},
	start: function(_) {
		var self = this;
		this.dispatch(_ >> function(err) {
			self.done = true;
			self.response && self.response.finish(err);
		}, this.context);

		this.originResponse && this.reply(_, this.originResponse);
	},
	addError: function(message, stackTrace) {
		this.$diagnoses = this.$diagnoses || [];
		this.$diagnoses.push({
			$severity: "error",
			$message: message,
			$stackTrace: stackTrace
		});
	},
	addDiagnose: function(severity, message, stackTrace) {
		this.$diagnoses = this.$diagnoses || [];
		this.$diagnoses.push({
			$severity: severity,
			$message: message,
			$stackTrace: stackTrace
		});
	}
});

var trackers = exports.trackers = {};

exports.track = function(_, context, id) {
	var tracker = id && trackers[id];
	switch (context.request.method.toLowerCase()) {
		case 'get':
			if (tracker) {
				tracker.reply(_, context.response);			
			} else {
				var headers = {
					"content-type": "application/json"
				};
				context.response.writeHead(200, headers);
				var res = {
					$resources: Object.keys(trackers).map_(_, function(_, ttId) {
						var tt = trackers[ttId];
						if (!tt.done) {
							var currentTime = new Date().getTime();
							tt.elapsedSeconds = Math.floor((currentTime - tt.startTime) / 1000);
						}
						return _serialize(tt);
					})
				}
				context.response.write(_, JSON.stringify(res), "utf8");
				context.response.end();
			}
			break;
		case 'delete':
			if (!tracker) return context.reply(_, 404, "tracker not found: " + id);
			delete trackers[id];
			context.reply(_, 204);
			break;
		case "put":
			if (!tracker) return context.reply(_, 404, "tracker not found: " + id);
			if (context.parameters && context.parameters.abort) {
				tracker.requestAbort();
			}
			tracker.reply(_, context.response);
			//context.reply(_, 202, _serialize(tracker));
			break;
		default:
			throw new Error("Bad method: " + context.request.method);
	}
};

// keepOriginalResponse: DO NOT substitute original response with TrackerResponse
exports.create = function(context, dispatch, keepOriginalResponse) {
	var trackngId = context.parameters.trackngId;
	var response = null;
	var tracker = trackers[trackngId];
	if (tracker) {
		throw new Error("Tracker already exists.");
	}
	if (!keepOriginalResponse) {
		response = context.response;
		context.response = new TrackerResponse();
	}
	trackers[trackngId] = tracker = new Tracker(context, (keepOriginalResponse ? null : context.response), trackngId, dispatch);
	tracker.originResponse = response;
	context.tracker = tracker;
	return tracker;
};