"use strict";

var globals = require('streamline/lib/globals');
var helpers = require("syracuse-core/lib/helpers");
var registry = require("./sdataRegistry");
var Context = require("./sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var find = helpers.object.find;
var sdataDbHandle = require("./sdataDbHandle");
var factory = require("syracuse-orm/lib/factory");
var searchEngine = require("syracuse-search/lib/elasticSearch");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var x3pool = require("syracuse-x3/lib/pool");
var locale = require("syracuse-core/lib/locale");
var graph = require("syracuse-graph/lib/graph");
var tagCloud = require("syracuse-graph/lib/tagCloud");
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var sdataAsync = require("syracuse-sdata/lib/sdataAsync");
var sys = require("util");
var streams = require("streamline/lib/streams/streams");

// STUBS

function getPrototypeStub(_, context) {
	var fs = require('streamline-fs');
	var fsp = require('path');
	// url is like '/sdata/contract/application/dataset/$prototypes('name.type.variant')',
	var path = context.request.url.split("/");
	var url = context.request.url.split("/").slice(0, 5).join("/");
	path[1] = helpers.stubsPath;
	path[5] = "prototypes";
	path = path.slice(1, 6).join("/") + "/" + context.prototypeId.split(".").join("-") + ".json";
	var proto = JSON.parse(fs.readFile(fsp.join(__dirname, "../../..") + "/" + path, "utf8", _));
	proto.$baseUrl = url;
	return proto;
}

function getEntitiesListStub(_, context) {
	var fs = require('streamline-fs');
	var fsp = require('path');
	// url is like '/sdata/contract/application/dataset/entities',
	var path = context.request.url.split("?")[0].split("/");
	path[1] = helpers.stubsPath;
	path = path.slice(1, 6).join("/") + ".json";
	var proto = JSON.parse(fs.readFile(fsp.join(__dirname, "../../..") + "/" + path, "utf8", _));
	return proto;
}

function getEntityStub(_, context) {
	var fs = require('streamline-fs');
	var fsp = require('path');
	// url is like '/sdata/contract/application/dataset/entities('id')',
	var path = context.request.url.split("?")[0].split("(")[0].split("/");
	path[1] = helpers.stubsPath;
	path = path.slice(1, 6).join("/") + "-" + context.instanceId + ".json";
	var proto = JSON.parse(fs.readFile(fsp.join(__dirname, "../../..") + "/" + path, "utf8", _));
	return proto;
}

///

function _parseSegment(segment) {
	return httpHelper.decodeDetailSegment(segment) || {
		name: segment
	};
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.id) context.isExpressionId = pair.isExpressionId;
		if (pair.name[0] == '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				if (map.$canExecute && !map.$canExecute(_, context, name)) return context.reply(_, httpHelper.HttpStatus.Forbidden, locale.format(module, "forbiddenSegment", pair.name, context.method));
				else return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest("unexpected URL segment: " + seg);
	}
}

// URL is http://host/sdata
var _sdataMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		context.application = registry.applications[name];
		//		if (!context.application && !helpers.stubsPath) throw context.notFound("application not found: " + name);
		return _dispatch(_, context, _applicationMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, registry.applications, "application");
	},
	trackers: function(_, context, id) {
		return sdataAsync.track(_, context, id);
	},
	search: function(_, context, id) {
		return _dispatch(_, context, _searchMap);
	}
};

// URL is http://host/sdata/app
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		if (context.application) context.contract = context.application.contracts[name];
		//
		var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		if (!app && !context.application && !helpers.stubsPath) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		context.applicationRef = app;
		//
		return _dispatch(_, context, (app && (app.protocol(_) !== "syracuse")) ? _x3ContractMap : _syracuseContractMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.application.contracts, "contract");
	}
};

// URL is http://host/sdata/app/contract
var _syracuseContractMap = {
	walk: function(_, context, name, id) {
		// allow stubs
		if (context.contract) {
			var ds = registry.getDataset(_, context.contract, name);
			if (!ds) throw context.notFound("dataset not found: " + name);
			context.dataset = name;
			context.model = dataModel.make(context.contract, context.dataset);
			// crnit : database abstraction
			context.db = dataModel.getOrm(_, context.model, ds);
			//
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _syracuseDatasetMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.contract.datasets, "dataset");
	}
};

var _x3ContractMap = {
	walk: function(_, context, name, id) {
		var protocol = "";
		if (context.applicationRef) { // TEST to allow stubs
			// find the endpoint
			var ep = adminHelper.getEndpoint(_, {
				application: context.applicationName,
				contract: context.contractName,
				dataset: name
			});
			// TEMP : no error if syracuse endpoint not found, for unit tests to pass. fix later.
			if (!ep) throw context.notFound(locale.format(module, "endpointNotFound", context.applicationName, context.contractName, name));
			context.endpoint = ep;
			//
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _x3DatasetMap);
	}
};

// URL is http://host/sdata/app/contract/dataset
// for syracuse endpoints
var _syracuseDatasetMap = {
	walk: function(_, context, name, id) {
		var model = context.model;
		var singular = model && model.singularize(name);
		//
		if (context.parameters.search) {
			var ep = context.endpoint || adminHelper.getCollaborationEndpoint(_);
			context.searchIndexName = ep.getIndexName(_);
			context.searchEntityName = context.entityName = singular;
			searchEngine.search(_, context);
		} else {
			if (model) { // TEST to allow stubs
				context.entity = model.getEntity(_, singular);
				if (!context.entity) throw context.notFound(locale.format(module, "entityNotFound", name));
			}
			if (id) {
				context.instanceId = id;
				if (context.entity) {
					context.instance = factory.fetchInstance(_, context);
					// don't test here the instance, as the call for non persistent instances might have ids that aren't instance id
					//				if(!context.instance) throw context.notFound(locale.format(module, "instanceNotFound", name, id));
				}
				return _dispatch(_, context, _instanceMap);
			} else {
				return _dispatch(_, context, _entityMap);
			}
		}
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		return context.replyDictionaryPage(_, context.model.getEntities(), "entity", function(name, entity) {
			return {
				$url: baseUrl + "/" + entity.plural,
				$key: entity.plural,
				$descriptor: "entity " + entity.name,
				name: entity.plural
			};
		});
	},
	prototypes: function(_, context, id) {
		if (id) {
			context.prototypeId = id;
			return _dispatch(_, context, _prototypeMap);
		} else {
			return _dispatch(_, context, _prototypesMap);
		}
	},
	workingCopies: function(_, context, id) {
		context.workingCopyId = id;
		return _dispatch(_, context, _workingCopiesMap);
	},
	service: function(_, context) {
		return _dispatch(_, context, _datasetServiceMap);
	},
	backups: function(_, context) {
		return _dispatch(_, context, _backupsMap);
	},
	search: function(_, context, id) {
		context.searchIndexName = id;
		return _dispatch(_, context, _searchMap);
	},
	import: function(_, context) {
		return _dispatch(_, context, _importMap);
	},
	$canExecute: function(_, context, operation) {
		// security
		var sp = globals.context.session && globals.context.session.getSecurityProfile && globals.context.session.getSecurityProfile(_);
		//    	sp && config.tracer && config.tracer("_syracuseDatasetMap found security profile: "+sp.code(_));
		return (sp && sp.canExecuteService(_, null, operation)) || (sp == null);
	}
};

function _x3hackResponse(batchresp) {
	this.data = "";
	this.status = 200;
	this.head = null;
	this.batchResponse = batchresp;
};

_x3hackResponse.prototype = {
	writeHead: function(status, head) {
		this.head = head;
		this.status = status;
		if (this.batchResponse) this.batchResponse.$httpStatus = this.status;
	},
	write: function(_, data) {
		this.data += data;
	},
	end: function() {
		if (this.batchResponse) {
			try {
				var dd = JSON.parse(this.data);
				if (dd && dd.$resources) {
					if (dd.$resources.length) dd = dd.$resources[0];
					else dd = null;
				}
				if (dd) {
					for (var v in dd)
						this.batchResponse[v] = dd[v];
				}
			} catch (ex) {
				// Add warning diagnose if failed
				var d = this.batchResponse.$diagnoses || (this.batchResponse.$diagnoses = []);
				d.push({
					$severity: "warning",
					$message: ex.message,
					$stackTrace: ex.stack + "\n" + this.data
				});
			}
		}
	}
};
var _x3Hacks = {
	// Mobile specific
	batchGet: function(_, context) {
		var cr = context.response;
		try {
			var batchResult = {
				$resources: []
			};
			var brequest = JSON.parse(context.request.readAll(_));
			var path = context.path.split('/');
			path.pop();
			context.path = path.join('/');
			brequest.$resources.forEach_(_, function(_, entry) {
				var opres = {
					$httpStatus: 200
				};
				batchResult.$resources.push(opres);
				try {
					switch (entry.$httpMethod.toLowerCase()) {
						case "get":
							context.response = new _x3hackResponse(opres);
							context.method = entry.$httpMethod;
							context.url = entry.$url;
							context.method = "GET";
							context.request.url = context.url;
							context.request.method = context.method;
							x3pool.send(_, context);
							break;
						default:
							break;
					}
				} catch (ex) {
					opres.$httpStatus = 500;
					opres.$httpMessage = ex.message;
				}
			});
			context.response = cr;
			context.reply(_, 200, batchResult);
		} catch (e) {
			context.response = cr;
			context.batchResult = null;
			context.reply(_, 500, e.message);
		}
	},
	// Mobile specific
	// -> Temporary - Wating for X3 core tream to implement $template service for X3 entities
	// Marc beinat is going to fix the bug
	template: function(_, context, name, id) {
		var resp = context.response,
			respS = 200,
			respB, respH;
		try {
			// -1- Create a working copy
			context.response = new _x3hackResponse();
			context.request.url = context.request.url.replace('/$template', '/$workingCopies') + '&trackingId=' + helpers.uuid.generate();
			context.request.method = "POST";
			x3pool.send(_, context);
			respS = context.response.status;
			respB = JSON.parse(context.response.data);
			respH = context.response.header;
			if (respS == 200 && respB.$url && respB.$trackingId) {
				// -2- DELETE Working copy
				// -> X3 do not implement DELETE method on working copies -> We send an abort action
				delete respB.$trackingId;
				var url = respB.$url.replace("{$baseUrl}", respB.$baseUrl);
				// Bug on X3 side - abort needs referer to read workingcopy id  :-( 
				// -> if no referer -> 404 - "$message":"Working-copie not found (00000000-0000-0000-0000-000000000000)"
				var referer = context.request.headers.referer + "?url=" + encodeURIComponent(url);
				// Send JSON Data with abort action parameter like desktop client
				var reply = x3pool.jsonSend(_, context.request.session, context.endpoint, {
					head: {
						accept: "application/json;vnd.sage=syracuse",
						"content-type": "application/json; charset=UTF-8",
						referer: referer,
						method: "PUT",
						url: url
					},
					body: {
						"$etag": respB.$etag,
						"$actions": {
							"$abort": {
								"$isRequested": true
							}
						},
						"$uuid": respB.$uuid
					}
				});
				if (reply.head.statusCode != 200) {
					// Add warning diagnose if failed
					var d = respB.$diagnoses || (respB.$diagnoses = []);
					d.push({
						$severity: "warning",
						$message: "Can't delete working copie",
						$stackTrace: url + "\n" + JSON.stringify(reply.body)
					});
				}
			}
		} catch (e) {
			respS = 500;
			respB = {
				$diagnoses: [{
					$severity: "error",
					$message: "Error creating working copy\n",
					$stackTrace: context.request.url + "\n" + e.stack
				}]
			};
		}
		context.response = resp;
		if (!respH) respH = {};
		if (!respH["content-type"]) respH["content-type"] = "application/json";
		context.reply(_, respS, respB, respH);
	}
};

function _endsWith(a, b) {
	if (!a || !b || !a.length || !b.length) return false;
	var i = a.lastIndexOf(b);
	return i == -1 ? false : (a.length - i - b.length) == 0;
}

var _x3DatasetMap = {
	walk: function(_, context, name, id) {
		if (context.parameters.search) {
			context.searchIndexName = context.endpoint.getIndexName(_);
			context.searchEntityName = context.entityName = name;
			searchEngine.search(_, context);
		} else {
			// delegate to x3pool
			if (context.path && context.path.indexOf('/$batchGet') > 0) {
				//Mobile - hack for batch with gets 
				return _x3Hacks.batchGet(_, context);
			} else if (_endsWith(context.path, '/$template') && context.method == "get") {
				//Mobile - hack for template which is not emplemented on X3 side 
				return _x3Hacks.template(_, context, name, id);
			} else x3pool.send(_, context);
		}
	},
	prototypes: function(_, context, name, id) {
		// delegate to x3pool
		x3pool.send(_, context);
	},
	workingCopies: function(_, context, name, id) {
		// delegate to x3pool
		x3pool.send(_, context);
	},
	service: function(_, context, name, id) {
		// delegate to x3pool
		x3pool.send(_, context);
	}
};

var _datasetServiceMap = {
	walk: function(_, context, name, id) {
		context.operation = name;
		return _dispatch(_, context, _datasetOperationMap);

	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.model.datasetOperations(), "operation", function(key, operation) {
			return {
				$url: baseUrl + "/" + key,
				$key: key,
				name: key
			};
		});
	}
};

var _datasetOperationMap = {
	get: function(_, context) {
		return context.executeDatasetOperation(_);
	},
	post: function(_, context) {
		return context.executeDatasetOperation(_);
	}
};

var _backupsMap = { // TODO
};

//URL is http:/host/sdata/app/contract/dataset/entity('id')/property
// used for binary properties
var _propertyMap = {
	get: function(_, context) {
		context.setMeta(false);
		var instance = factory.fetchInstance(_, context);
		if (!instance) return context.reply(_, 404, "The requested instance was not found");
		context.replyProperty(_, instance, context.propertyName);
	},
	put: function(_, context) {
		context.setMeta(true);
		var instance = factory.fetchInstance(_, context);
		if (!instance) return context.reply(_, 404, "The requested instance was not found");
		var store = instance[context.propertyName](_);
		//
		context.request.setEncoding(null);
		var stream = store.createWritableStream(_, {
			contentType: context.request.headers["x-content-type-override"] || context.request.headers["content-type"],
			fileName: context.request.headers["x-file-name"]
		});
		var buf;
		while (buf = context.request.read(_)) {
			stream.write(_, buf, "binary");
			/*			store.write(_, buf, {
             contentType: context.request.headers["x-content-type-override"] || context.request.headers["content-type"],
             fileName: context.request.headers["x-file-name"]
             });*/
		}
		// write (null) means end
		stream.write(_, null);
		store.uploadDone(_);
		//		store.close(_);
		//
		context.reply(_, 204);
	},
	// IE9 does a POST instead of a PUT so we accept it and do the same action as the PUT
	post: function(_, context) {
		return _propertyMap.put(_, context);
	},
	"delete": function(_, context) {
		var instance = factory.fetchInstance(_, context);
		if (!instance) return context.reply(_, 404, "The requested instance was not found");
		// get a document
		var store = instance[context.propertyName](_);
		store.deleteFile(_);
		//
		context.reply(_, 204);
	}
};
//URL is http://host/sdata/app/contract/dataset/$workingCopies('1fc2...')/property
//used for binary properties
var _wcPropertyMap = {
	get: function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		if (!instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		context.replyProperty(_, instance, context.propertyName);
	},
	put: function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		if (!instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		// get a document
		var store = instance[context.propertyName](_);
		store.createWorkingCopy(_);
		context.request.setEncoding(null);
		//
		var buf;
		var match, filename, contentType, boundary;
		if (match = /^multipart\/form-data;\s*boundary=(.*)/.exec(context.request.headers["content-type"])) {
			boundary = match[1];
			buf = context.request.read(_, 2048);
			var lines = buf.toString("binary").split('\n');
			if (lines[0].indexOf(boundary) < 0) throw new Error("boundary not found");
			var i = 0;
			for (; i < lines.length; i++) {
				if (/^\r?$/.test(lines[i])) break;
				if (match = /^content-disposition\:.*filename=([^;]*)[;$]/.exec(lines[i])) filename = match[1];
				else if (match = /^content-type\:\s*(.*)$/.exec(lines[i])) contentType = match[1];
				// else ignore header
			}
			var len = 0;
			while (i >= 0) len += lines[i--].length + 1;
			context.request.unread(buf.slice(len));
		} else {
			contentType = context.request.headers["x-content-type-override"] || context.request.headers["content-type"];
			filename = context.request.headers["x-file-name"];
		}
		var stream = store.createWritableStream(_, {
			contentType: contentType,
			fileName: filename
		});
		if (boundary) {
			var len = Math.max(boundary.length, 2048);
			while (buf = context.request.read(_, 2 * len)) {
				var s = buf.toString("binary");
				var i = s.indexOf(boundary);
				if (i >= 0) {
					i = s.lastIndexOf('\n', i);
					stream.write(_, s.substring(0, i), "binary");
					context.request.readAll(_); // discard any trailing data
				} else {
					stream.write(_, s.substring(0, len), "binary");
					context.request.unread(buf.slice(len));
				}
			}
		} else {
			while (buf = context.request.read(_))
				stream.write(_, buf, "binary");
		}
		stream.write(_, null);
		store.uploadDone(_);
		/*			store.write(_, buf, {
         contentType: context.request.headers["x-content-type-override"] || context.request.headers["content-type"],
         fileName: context.request.headers["x-file-name"]
         });
         store.close(_);*/
		//
		context.reply(_, 200, instance.serializeInstance(_));
	},
	// IE9 does a POST instead of a PUT so we accept it and do the same action as the PUT
	post: function(_, context) {
		return _wcPropertyMap.put(_, context);
	},
	"delete": function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		if (!instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		// get a document
		var store = instance[context.propertyName](_);
		store.createWorkingCopy(_);
		//
		context.reply(_, 204);
	}
};

// URL is http://host/sdata/app/contract/dataset/entity (or deeper)
var _entityMap = {
	get: function(_, context) {
		// stubs
		if (!context.contract && helpers.stubsPath) {
			context.reply(_, 200, getEntitiesListStub(_, context));
		} else return factory.replyInstances(_, context);
	},
	post: function(_, context) {
		context.setMeta(true);
		return factory.createInstance(_, context, context.entity.factory);
	},
	template: function(_, context) {
		return _dispatch(_, context, _templateMap);
	},
	batch: function(_, context) {
		return _dispatch(_, context, _batchMap);
	},
	// batchGet = batch (has only gets)
	batchGet: function(_, context) {
		return _dispatch(_, context, _batchMap);
	},
	schema: function(_, context) {
		return _dispatch(_, context, _schemaMap);
	},
	service: function(_, context) {
		return _dispatch(_, context, _serviceMap);
	}
};

// URL is http://host/sdata/app/contract/dataset/entity('id') (or deeper)
var _instanceMap = {
	walk: function(_, context, name, id) {
		context.propertyName = name;
		var rel = context.entity.$relations[name];
		if (!rel) {
			//
			var prop = context.entity.$properties[name];
			if (prop) return _dispatch(_, context, _propertyMap);
			throw context.notFound("relation or property not found: " + name);
		}

		context.setMeta(false);
		var inst = factory.fetchInstance(_, context);
		context.relation = rel;
		context.entity = context.relation.targetEntity;
		if (rel.isPlural) {
			// TODO set context params for fetchInstances (for list)
			return _dispatch(_, context, _entityMap);
		} else {
			context.instanceId = inst._data[name].$uuid;
			return _dispatch(_, context, _instanceMap);
		}
	},
	get: function(_, context) {
		if (!context.contract && helpers.stubsPath) {
			context.reply(_, 200, getEntityStub(_, context));
		} else {
			context.setMeta(context.representation.type && context.representation.type.indexOf("$details") >= 0);
			factory.replyInstance(_, context);
		}
	},
	put: function(_, context) {
		context.setMeta(true);
		return factory.updateInstance(_, context);
	},
	"delete": function(_, context) {
		context.setMeta(true);
		return factory.deleteInstance(_, context);
	},
	schema: function(_, context) {
		return _dispatch(_, context, _schemaMap);
	},
	service: function(_, context) {
		return _dispatch(_, context, _serviceMap);
	},
	workingCopies: function(_, context) {
		return _dispatch(_, context, _workingCopiesMap);
	},
	graphs: function(_, context) {
		return _dispatch(_, context, _graphsMap);
	},
	tagClouds: function(_, context) {
		return _dispatch(_, context, _tagCloudsMap);
	}
};

// URL is http://host/sdata/app/contract/dataset/$prototypes
var _prototypesMap = {
	get: function(_, context) {
		throw context.niy("prototypes list");
	}
};

// URL is http://host/sdata/app/contract/dataset/$prototypes('id')
var _prototypeMap = {
	get: function(_, context) {
		var keys = context.prototypeId.split(".");
		// use of stubs ?
		if ((!context.application || !context.contract) && helpers.stubsPath) {
			context.reply(_, 200, getPrototypeStub(_, context));
		} else {
			//
			context.representation = {
				application: context.application.name,
				contract: context.contract.name,
				entity: keys[0],
				type: keys[1],
				variant: keys[2]
			};

			context.replyPrototype(_);
		}
	}
};
var _batchMap = {
	post: function(_, context) {
		factory.batch(_, context);
	}
};
var _templateMap = {
	get: function(_, context) {
		context.setMeta(true);
		factory.createTemplate(_, context, context.entity.factory);
	},
	workingCopies: function(_, context) {
		return _dispatch(_, context, _workingCopiesMap);
	}
};
// URL is http://host/sdata/app/contract/dataset/entity/$template/$workingCopies?trackingId=1fc2...
// URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$workingCopies?trackingId=1fc2...
// URL is http://host/sdata/app/contract/dataset/$workingCopies('1fc2...')
var _workingCopiesMap = {
	walk: function(_, context, name, id) {
		context.propertyName = name;
		// pour le moment gestion des properties uniquement
		//		var prop = context.entity.$properties[name];
		return _dispatch(_, context, _wcPropertyMap);
		//		throw context.notFound("relation or property not found: " + name);
	},
	get: function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		var entity = context.getEntity(_);
		if (!instance && !(entity && entity.$autoRecreateWorkingCopy)) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		factory.getWorkingCopy(_, context, instance);
	},
	post: function(_, context) {
		factory.createWorkingCopy(_, context, context.entity.factory);
	},
	put: function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		var entity = context.getEntity(_);
		if (!instance && !(entity && entity.$autoRecreateWorkingCopy)) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		factory.updateWorkingCopy(_, context, instance);
	},
	"delete": function(_, context) {
		delete context.httpSession[context.workingCopyId];
		return context.reply(_, 204);
	},
	graphs: function(_, context) {
		context.instance = context.httpSession[context.workingCopyId];
		if (!context.instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		context.entity = context.instance._meta;
		return _dispatch(_, context, _graphsMap);
	},
	tagClouds: function(_, context) {
		context.instance = context.httpSession[context.workingCopyId];
		if (!context.instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		context.entity = context.instance._meta;
		return _dispatch(_, context, _tagCloudsMap);
	},
	service: function(_, context) {
		context.instance = context.httpSession[context.workingCopyId];
		if (!context.instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		context.entity = context.instance._meta;
		return _dispatch(_, context, _serviceMap);
	}
};

//URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$graphs
var _graphsMap = {
	walk: function(_, context, name, id) {
		context.graphName = name;
		return _dispatch(_, context, _graphMap);
	}
};

//URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$graphs/graphName
var _graphMap = {
	get: function(_, context) {
		return graph.replyGraph(_, context);
	}
};

//URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$tagClouds
var _tagCloudsMap = {
	walk: function(_, context, name, id) {
		context.tagCloudName = name;
		return _dispatch(_, context, _tagCloudMap);
	}
};

//URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$tagClouds/cloudName
var _tagCloudMap = {
	get: function(_, context) {
		return tagCloud.replyTagCloud(_, context);
	}
};

// URL is http://host/sdata/app/contract/dataset/.../$schema
var _schemaMap = {
	get: function(_, context) {
		context.setMeta(false);
		throw context.niy("schemas not supported");
	}
};

// URL is http://host/sdata/app/contract/dataset/.../$service
var _serviceMap = {
	walk: function(_, context, name, id) {
		var operation = context.entity.$services[name];
		if (!operation) throw context.notFound("service operation not found: " + name);
		var hasInstance = (context.instance != null) || (context.instanceId != null);

		if (hasInstance != operation.isMethod) throw context.badRequest("isMethod mismatch on operation");
		operation.method = operation.method || "post"; //TODO Should remove this
		context.operation = operation;
		context.setMeta(false);
		return _dispatch(_, context, _operationMap);
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		var hasInstance = context.instanceId != null;
		return context.replyDictionaryPage(_, context.entity.$services, "operation", function(name, operation) {
			if (operation.isMethod != hasInstance) return;
			return {
				$url: baseUrl + "/" + name,
				$key: name,
				name: name
			};
		});
	}
};

// URL is http://host/sdata/app/contract/dataset/.../$service/operation
var _operationMap = {
	get: function(_, context) {
		return context.executeOperation(_, context);
	},
	post: function(_, context) {
		return context.executeOperation(_, context);
	}
};

// URL is thhp://host/sdata/syracuse/search/dataset/$search[('indexName')][?q='search string']

var _searchMap = {
	get: function(_, context) {
		return searchEngine.search(_, context);
	},
	put: function(_, context) {
		return searchEngine.updateIndex(_, context);
	},
	"delete": function(_, context) {
		return searchEngine.deleteIndex(_, context, context.id);
	}
};

var _importTools = {
	"application/json": require("syracuse-import/lib/jsonImport").streamImport
};

var _importMap = {
	post: function(_, context) {
		var r = context.request;
		var ct = httpHelper.parseHeaders(r.headers)["content-type"] || "application/json";
		context.reply(_, 201, _importTools[ct] && _importTools[ct](_, context.db, r, {
			importMode: "insert",
			createSession: true
		}));
	},
	put: function(_, context) {
		var r = context.request;
		var ct = httpHelper.parseHeaders(r.headers)["content-type"] || "application/json";
		context.reply(_, 200, _importTools[ct] && _importTools[ct](_, context.db, r, {
			importMode: "update",
			createSession: true
		}));
	}
};

var protocolTracer = helpers.debug.tracer("sdata.protocol");

function _logRequest(_, context) {
	if (!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity(_, "navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var sdata = context.walkUrl();
		if (sdata != "sdata") throw new Error("Bad URL: expected 'sdata', got '" + sdata + "'");

		// fire and forget log call
		_logRequest(!_, context);
		//
		switch (context.accept[0].type) {
			case "xlsx":
			case "docx":
			case "pptx":
				require("msoffice/lib/officeDispatch").dispatch(_, context);
				break;
			default:
				_dispatch(_, context, _sdataMap);
		}
		//
	} catch (ex) {
		if ("phone" === context.parameters.device) {
			var $diagnoses;
			// Try to get diag from X3 response body
			if (ex.httpBody && ex.httpBody.$diagnoses && ex.httpStatus === 404) {
				$diagnoses = {
					$diagnoses: ex.httpBody.$diagnoses
				};
				if ($diagnoses.$diagnoses[0]) {
					if ($diagnoses.$diagnoses[0].$stackTrace) $diagnoses.$diagnoses[0].$stackTrace += "\n---\n" + ex.message + "\n" + ex.stack;
					else $diagnoses.$diagnoses[0].$stackTrace = "\n---\n" + ex.message + "\n" + ex.stack;
				}
			} else {
				$diagnoses = {
					$diagnoses: [{
						$severity: "error",
						$message: locale.format(module, "mobileException"),
						$stackTrace: ex.message + "\n" + ex.stack
					}]
				};
			}
			context.reply(_, ex.httpStatus == null ? 500 : ex.httpStatus, $diagnoses);
		} else {
			if (ex.httpStatus) {
				return context.reply(_, ex.httpStatus, ex.message + "\n" + (ex.$stackTrace || ex.stack));
			} else if (ex.stack) {
				console.error(ex.message + "\n" + ex.stack);
				return context.reply(_, 500, ex.message + "\n" + (ex.$stackTrace || ex.stack));
			} else {
				console.error("CAUGHT NON ERROR: " + ex);
				return context.reply(_, 500, ex.toString());
			}
		}
	}
}

exports.dispatcher = function(options) {
	registry.register(options.endpoints);

	return function(_, request, response) {
		var context = new Context(request, response, options);
		request.context = context;
		try {
			var id = context.parameters.trackngId;
			if (id) {
				var tracker = sdataAsync.create(context, _doIt);
				tracker.location = "/sdata/$trackers('" + id + "')";
				tracker.start(_);
			} else _doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + (err.$stackTrace || err.stack));
		}
	};
};