"use strict";

var helpers = require("syracuse-core/lib/helpers");
var registry = require("./sdataRegistry");
var Context = require("./sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var find = helpers.object.find;
var sdataDbHandle = require("./sdataDbHandle");
var factory = require("syracuse-orm/lib/factory");
var searchEngine = require("syracuse-search/lib/elasticSearch");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var x3pool = require("syracuse-x3/lib/pool");
var locale = require("syracuse-core/lib/locale");
var graph = require("syracuse-graph/lib/graph");
var tagCloud = require("syracuse-graph/lib/tagCloud");
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var sys = require("util");

// STUBS


function getPrototypeStub(_, context) {
	var fs = require('fs');
	var fsp = require('path');
	// url is like '/sdata/contract/application/dataset/$prototypes('name.type.variant')',
	var path = context.request.url.split("/");
	var url = context.request.url.split("/").slice(0, 5).join("/");
	path[1] = helpers.stubsPath;
	path[5] = "prototypes";
	path = path.slice(1, 6).join("/") + "/" + context.prototypeId.split(".").join("-") + ".json";
	var proto = JSON.parse(fs.readFile(fsp.join(__dirname, "../../..") + "/" + path, "utf8", _));
	proto.$baseUrl = url;
	return proto;
}

function getEntitiesListStub(_, context) {
	var fs = require('fs');
	var fsp = require('path');
	// url is like '/sdata/contract/application/dataset/entities',
	var path = context.request.url.split("?")[0].split("/");
	path[1] = helpers.stubsPath;
	path = path.slice(1, 6).join("/") + ".json";
	var proto = JSON.parse(fs.readFile(fsp.join(__dirname, "../../..") + "/" + path, "utf8", _));
	return proto;
}

function getEntityStub(_, context) {
	var fs = require('fs');
	var fsp = require('path');
	// url is like '/sdata/contract/application/dataset/entities('id')',
	var path = context.request.url.split("?")[0].split("(")[0].split("/");
	path[1] = helpers.stubsPath;
	path = path.slice(1, 6).join("/") + "-" + context.instanceId + ".json";
	var proto = JSON.parse(fs.readFile(fsp.join(__dirname, "../../..") + "/" + path, "utf8", _));
	return proto;
}

///

function _parseSegment(segment) {
	return httpHelper.decodeDetailSegment(segment) || {
			name: segment
		}
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if(pair.id)
			context.isExpressionId = pair.isExpressionId;
		if (pair.name[0] == '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest("unexpected URL segment: " + seg);
	}
}

// URL is http://host/sdata
var _sdataMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		context.application = registry.applications[name];
//		if (!context.application && !helpers.stubsPath) throw context.notFound("application not found: " + name);
		return _dispatch(_, context, _applicationMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, registry.applications, "application");
	}
}

// URL is http://host/sdata/app
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		if (context.application)
			context.contract = context.application.contracts[name];
		//
		var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		if(!app && !context.application && !helpers.stubsPath) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		context.applicationRef = app;
		//
		return _dispatch(_, context, (app && (app.protocol(_) !== "syracuse"))? _x3ContractMap : _syracuseContractMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.application.contracts, "contract");
	}
}

// URL is http://host/sdata/app/contract
var _syracuseContractMap = {
	walk: function(_, context, name, id) {
		// allow stubs
		if(context.contract) {
			var ds = registry.getDataset(_, context.contract, name);
			if (!ds) throw context.notFound("dataset not found: " + name);
			context.dataset = name;
			context.model = dataModel.make(context.contract, context.dataset);
			// crnit : database abstraction
			context.db = dataModel.getOrm(_, context.model, ds);
			//
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _syracuseDatasetMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.contract.datasets, "dataset");
	}
}

var _x3ContractMap = {
	walk: function(_, context, name, id) {
		var protocol = "";
		if (context.applicationRef) { // TEST to allow stubs
			// find the endpoint
			var ep = adminHelper.getEndpoint(_, {
				application: context.applicationName,
				contract: context.contractName,
				dataset: name
			});
			// TEMP : no error if syracuse endpoint not found, for unit tests to pass. fix later.
			if(!ep) throw context.notFound(locale.format(module, "endpointNotFound", context.applicationName, context.contractName, name));
			context.endpoint = ep;
			//
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _x3DatasetMap);
	}
}

// URL is http://host/sdata/app/contract/dataset
// for syracuse endpoints
var _syracuseDatasetMap = {
	walk: function(_, context, name, id) {
		var model = context.model;
		if (model) { // TEST to allow stubs
			var singular = model.singularize(name);
			context.entity = model.getEntity(singular)
			if (!context.entity) throw context.notFound(locale.format(module, "entityNotFound", name));
		}
		if (id) {
			context.instanceId = id;
			if(context.entity) {
				context.instance = factory.fetchInstance(_, context);
				// don't test here the instance, as the call for non persistent instances might have ids that aren't instance id
//				if(!context.instance) throw context.notFound(locale.format(module, "instanceNotFound", name, id));
			}
			return _dispatch(_, context, _instanceMap);
		} else {
			return _dispatch(_, context, _entityMap);
		}
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		return context.replyDictionaryPage(_, context.model.getEntities(), "entity", function(name, entity) {
			return {
				$url: baseUrl + "/" + entity.plural,
				$key: entity.plural,
				$descriptor: "entity " + entity.name,
				name: entity.plural
			}
		});
	},
	prototypes: function(_, context, id) {
		if (id) {
			context.prototypeId = id;
			return _dispatch(_, context, _prototypeMap);
		} else {
			return _dispatch(_, context, _prototypesMap);
		}
	},
	workingCopies: function(_, context, id) {
		context.workingCopyId = id;
		return _dispatch(_, context, _workingCopiesMap);
	},
	service: function(_, context) {
		return _dispatch(_, context, _datasetServiceMap);
	},
	backups: function(_, context) {
		return _dispatch(_, context, _backupsMap);
	},
	search: function(_, context, id) {
		context.searchIndexName = id;
		return _dispatch(_, context, _searchMap);
	},
	import: function(_, context) {
		return _dispatch(_, context, _importMap);
	}
}

var _x3DatasetMap = {
	walk: function(_, context, name, id) {
		// delegate to x3pool
		x3pool.send(_, context);
	},
	prototypes: function(_, context, name, id) {
		// delegate to x3pool
		x3pool.send(_, context);
	},
	workingCopies: function(_, context, name, id) {
		// delegate to x3pool
		x3pool.send(_, context);
	}
}

var _datasetServiceMap = {
	walk: function(_, context, name, id) {
		context.operation = name;
		return _dispatch(_, context, _datasetOperationMap)

	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.model.datasetOperations(), "operation", function(key, operation) {
			return {
				$url: baseUrl + "/" + key,
				$key: key,
				name: key
			};
		});
	}
}

var _datasetOperationMap = {
	get: function(_, context) {
		return context.executeDatasetOperation(_);
	},
	post: function(_, context) {
		return context.executeDatasetOperation(_);
	}
}

var _backupsMap = { // TODO
}

//URL is http:/host/sdata/app/contract/dataset/entity('id')/property
// used for binary properties
var _propertyMap = {
	get: function(_, context) {
		context.setMeta(false);
		var instance = factory.fetchInstance(_, context);
		if (!instance) return context.reply(_, 404, "The requested instance was not found");
		context.replyProperty(_, instance, context.propertyName);
	},
	put: function(_, context) {
		context.setMeta(true);
		var instance = factory.fetchInstance(_, context);
		if (!instance) return context.reply(_, 404, "The requested instance was not found");
		var store = instance[context.propertyName](_);
		//
		context.request.setEncoding(null);
		var stream = store.createWritableStream(_, {
				contentType: context.request.headers["x-content-type-override"] || context.request.headers["content-type"],
				fileName: context.request.headers["x-file-name"]
			});
		var buf;
		while(buf = context.request.read(_)) {
			stream.write(_, buf, "binary");
/*			store.write(_, buf, {
				contentType: context.request.headers["x-content-type-override"] || context.request.headers["content-type"],
				fileName: context.request.headers["x-file-name"]
			});*/
		}
		// write (null) means end
		stream.write(_, null);
		store.uploadDone(_);
//		store.close(_);
		//
		context.reply(_, 204);
	},
	"delete": function(_, context) {
		var instance = factory.fetchInstance(_, context);
		if (!instance) return context.reply(_, 404, "The requested instance was not found");
		// get a document
		var store = instance[context.propertyName](_);
		store.deleteFile(_);
		//
		context.reply(_, 204);
	}
};
//URL is http://host/sdata/app/contract/dataset/$workingCopies('1fc2...')/property
//used for binary properties
var _wcPropertyMap = {
	get: function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		if (!instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		context.replyProperty(_, instance, context.propertyName);
	},
	put: function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		if (!instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		// get a document
		var store = instance[context.propertyName](_);
		store.createWorkingCopy(_);
		//
		context.request.setEncoding(null);
		var stream = store.createWritableStream(_, {
				contentType: context.request.headers["x-content-type-override"] || context.request.headers["content-type"],
				fileName: context.request.headers["x-file-name"]
			});
		var buf;
		while(buf = context.request.read(_)) 
			stream.write(_, buf, "binary");
		stream.write(_, null);
		store.uploadDone(_);
/*			store.write(_, buf, {
				contentType: context.request.headers["x-content-type-override"] || context.request.headers["content-type"],
				fileName: context.request.headers["x-file-name"]
			});
		store.close(_);*/
		//
		context.reply(_, 200, instance.serializeInstance(_));
	},
	"delete": function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		if (!instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		// get a document
		var store = instance[context.propertyName](_);
		store.createWorkingCopy(_);
		//
		context.reply(_, 204);
	}
};

// URL is http://host/sdata/app/contract/dataset/entity (or deeper)
var _entityMap = {
	get: function(_, context) {
		// stubs
		if (!context.contract && helpers.stubsPath) {
			context.reply(_, 200, getEntitiesListStub(_, context));
		} else 
			return factory.replyInstances(_, context);
	},
	post: function(_, context) {
		context.setMeta(true);
		return factory.createInstance(_, context, context.entity.factory);
	},
	template: function(_, context) {
		return _dispatch(_, context, _templateMap);
	},
	batch: function(_, context) {
		return _dispatch(_, context, _batchMap);
	},
	schema: function(_, context) {
		return _dispatch(_, context, _schemaMap);
	},
	service: function(_, context) {
		return _dispatch(_, context, _serviceMap);
	}
}

// URL is http://host/sdata/app/contract/dataset/entity('id') (or deeper)
var _instanceMap = {
	walk: function(_, context, name, id) {
		context.propertyName = name;
		var rel = context.entity.$relations[name];
		if (!rel) {
			//
			var prop = context.entity.$properties[name];
			if (prop) return _dispatch(_, context, _propertyMap);
			throw context.notFound("relation or property not found: " + name);
		}

		context.setMeta(false);
		var inst = factory.fetchInstance(_, context);
		context.relation = rel;
		context.entity = context.relation.targetEntity;
		if (rel.isPlural) {
			// TODO set context params for fetchInstances (for list)
			return _dispatch(_, context, _entityMap);
		} else {
			context.instanceId = inst._data[name].$uuid;
			return _dispatch(_, context, _instanceMap);
		}
	},
	get: function(_, context) {
		if (!context.contract && helpers.stubsPath) {
			context.reply(_, 200, getEntityStub(_, context));
		} else {
			context.setMeta(context.representation.type && context.representation.type.indexOf("$details") >= 0);
			factory.replyInstance(_, context);
		}
	},
	put: function(_, context) {
		context.setMeta(true);
		return factory.updateInstance(_, context);
	},
	"delete": function(_, context) {
		context.setMeta(true);
		return factory.deleteInstance(_, context);
	},
	schema: function(_, context) {
		return _dispatch(_, context, _schemaMap);
	},
	service: function(_, context) {
		return _dispatch(_, context, _serviceMap);
	},
	workingCopies: function(_, context) {
		return _dispatch(_, context, _workingCopiesMap);
	},
	graphs: function(_, context) {
		return _dispatch(_, context, _graphsMap);
	},
	tagClouds: function(_, context) {
		return _dispatch(_, context, _tagCloudsMap);
	}
}

// URL is http://host/sdata/app/contract/dataset/$prototypes
var _prototypesMap = {
	get: function(_, context) {
		throw context.niy("prototypes list");
	}
}

// URL is http://host/sdata/app/contract/dataset/$prototypes('id')
var _prototypeMap = {
	get: function(_, context) {
		var keys = context.prototypeId.split(".");
		// use of stubs ?
		if ((!context.application || !context.contract) && helpers.stubsPath) {
			context.reply(_, 200, getPrototypeStub(_, context));
		} else {
			//
			context.representation = {
				application: context.application.name,
				contract: context.contract.name,
				entity: keys[0],
				type: keys[1],
				variant: keys[2]
			}

			context.replyPrototype(_);
		}
	}
}
var _batchMap = {
	post: function(_, context) {
		factory.batch(_, context);
	}
};
var _templateMap = {
	get: function(_, context) {
		context.setMeta(true);
		if (helpers.useInstances) {
			factory.createTemplate(_, context, context.entity.factory);
		} else {
			context.withTransaction(_, function(_) {
				context.isTemplate = true;
				var dbHandle = context.getTemplate(_, context.entity);
				dbHandle.$url = context.url; // add version later
				var options = context.getSerializeOptions();
				options.actions = true;
				return context.replyDbHandle(_, 200, dbHandle, options);
			});
		}
	},
	workingCopies: function(_, context) {
		return _dispatch(_, context, _workingCopiesMap);
	}
};
// URL is http://host/sdata/app/contract/dataset/entity/$template/$workingCopies?trackingId=1fc2...
// URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$workingCopies?trackingId=1fc2...
// URL is http://host/sdata/app/contract/dataset/$workingCopies('1fc2...')
var _workingCopiesMap = {
	walk: function(_, context, name, id) {
		context.propertyName = name;
		// pour le moment gestion des properties uniquement
//		var prop = context.entity.$properties[name];
		return _dispatch(_, context, _wcPropertyMap);
//		throw context.notFound("relation or property not found: " + name);
	},
	get: function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		var entity = context.getEntity();
		if (!instance && !(entity && entity.$autoRecreateWorkingCopy)) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		factory.getWorkingCopy(_, context, instance);
	},
	post: function(_, context) {
		factory.createWorkingCopy(_, context, context.entity.factory);
	},
	put: function(_, context) {
		var instance = context.httpSession[context.workingCopyId];
		var entity = context.getEntity();
		if (!instance && !(entity && entity.$autoRecreateWorkingCopy)) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		factory.updateWorkingCopy(_, context, instance);
	},
	"delete": function(_, context) {
		delete context.httpSession[context.workingCopyId];
		return context.reply(_, 204);
	},
	graphs: function(_, context) {
		context.instance = context.httpSession[context.workingCopyId];
		if (!context.instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		context.entity = context.instance._meta;
		return _dispatch(_, context, _graphsMap);
	},
	tagClouds: function(_, context) {
		context.instance = context.httpSession[context.workingCopyId];
		if (!context.instance) return context.reply(_, 404, "The requested working copy is not available (session expired)");
		context.entity = context.instance._meta;
		return _dispatch(_, context, _tagCloudsMap);
	}
};

//URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$graphs
var _graphsMap = {
	walk: function(_, context, name, id) {
		context.graphName = name;
		return _dispatch(_, context, _graphMap);
	}
};

//URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$graphs/graphName
var _graphMap = {
	get: function(_, context) {
		return graph.replyGraph(_, context);
	}
}

//URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$tagClouds
var _tagCloudsMap = {
	walk: function(_, context, name, id) {
		context.tagCloudName = name;
		return _dispatch(_, context, _tagCloudMap);
	}
};

//URL is http://host/sdata/app/contract/dataset/entity('xxxxx')/$tagClouds/cloudName
var _tagCloudMap = {
	get: function(_, context) {
		return tagCloud.replyTagCloud(_, context);
	}
}


// URL is http://host/sdata/app/contract/dataset/.../$schema
var _schemaMap = {
	get: function(_, context) {
		context.setMeta(false);
		throw context.niy("schemas not supported")
	}
}

// URL is http://host/sdata/app/contract/dataset/.../$service
var _serviceMap = {
	walk: function(_, context, name, id) {
		var operation = context.entity.$services[name];
		if (!operation) throw context.notFound("service operation not found: " + name);
		var hasInstance = context.instanceId != null;

		if (hasInstance != operation.isMethod) throw context.badRequest("isMethod mismatch on operation");
		operation.method = operation.method || "post"; //TODO Should remove this
		context.operation = operation;
		context.setMeta(false);
		return _dispatch(_, context, _operationMap);
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		var hasInstance = context.instanceId != null;
		return context.replyDictionaryPage(_, context.entity.$services, "operation", function(name, operation) {
			if (operation.isMethod != hasInstance) return;
			return {
				$url: baseUrl + "/" + name,
				$key: name,
				name: name
			};
		});
	}
}

// URL is http://host/sdata/app/contract/dataset/.../$service/operation
var _operationMap = {
	get: function(_, context) {
		return context.executeOperation(_, context);
	},
	post: function(_, context) {
		return context.executeOperation(_, context);
	}
}

// URL is thhp://host/sdata/syracuse/search/dataset/$search[('indexName')][?q='search string']

var _searchMap = {
	get: function(_, context) {
		return searchEngine.search(_, context);
	},
	put: function(_, context) {
		return searchEngine.updateIndex(_, context);
	},
	"delete": function(_, context) {
		return searchEngine.deleteIndex(_, context, context.id);
	}
}

var _importTools = {
	"application/json": require("syracuse-import/lib/jsonImport").streamImport
}

var _importMap = {
	post: function(_, context) {
		var r = context.request;
		var ct = httpHelper.parseHeaders(r.headers)["content-type"] || "application/json";
		context.reply(_, 201, _importTools[ct] && _importTools[ct](_, context.db, r, {
			importMode: "insert",
			createSession: true
		}));  
	},
	put: function(_, context) {
		var r = context.request;
		var ct = httpHelper.parseHeaders(r.headers)["content-type"] || "application/json";
		context.reply(_, 200, _importTools[ct] && _importTools[ct](_, context.db, r, {
			importMode: "update",
			createSession: true
		}));
	}
}

var protocolTracer = helpers.debug.tracer("sdata.protocol");

function _logRequest(_, context) {
	if(!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity("navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var sdata = context.walkUrl();
		if (sdata != "sdata") throw new Error("Bad URL: expected 'sdata', got '" + sdata + "'");
		
		// fire and forget log call
		_logRequest(null, context);
		//
		switch(context.accept[0].type) {
			case "xlsx": 
			case "docx": 
				require("msoffice/lib/officeDispatch").dispatch(_, context);
				break;
			default:
				_dispatch(_, context, _sdataMap);
		}
		//
	} catch (ex) {
		if (ex.httpStatus) {
			return context.reply(_, ex.httpStatus, ex.message + "\n" + ex.stack);
		} else if (ex.stack) {
			console.error(ex.message + "\n" + ex.stack);
			return context.reply(_, 500, ex.message + "\n" + ex.stack);
		} else {
			console.error("CAUGHT NON ERROR: " + ex)
			return context.reply(_, 500, ex.toString());
		}
	}
}

exports.dispatcher = function(options) {
	registry.register(options.endpoints);

	return function(_, request, response) {
		var context = new Context(request, response, options);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + err.stack);
		}
	}
}