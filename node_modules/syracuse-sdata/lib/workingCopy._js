"use strict";

var url = require('url'),
	helpers = require("syracuse-core/lib/helpers");
var registry = require("./sdataRegistry");
var sdataContext = require("./sdataContext");
var DataContext = require("syracuse-orm/lib/dataContext").DataContext;
var sessionManager = require("syracuse-session/lib/sessionManager").sessionManager;
var dataModel = require('syracuse-orm/lib/dataModel');

function _parseSegment(segment) {
	segment = decodeURIComponent(segment);
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? [match[1], match[2]] : [segment];
}

var WorkingCopyOp = {
	unknown: "unknownWorkingCopy",
	create: "createWorkingCopy",
	restore: "restoreWorkingCopy",
	edit: "editWorkingCopy",
	//edit or duplicate
	drop: "dropWorkingCopy",
	delta: "deltaWorkingCopy",
	//save/update/Other operations
	duplicate: "duplicateWorkingCopy",
	get: "getWorkingCopy"
};
var c_workingCopies = "$workingCopies";

function WorkingCopyRequest(request) {
	var self = this;
	self.request = request;
	self.baseUrl = "";
	self.root = (request.socket ? ((request.socket.secure ? "https" : "http") + "://" + request.headers.host) : "");
	self.method = (request.headers["x-http-method-override"] || request.method).toLowerCase();
	self.url = request.url;
	self.application = "";
	self.contract = "";
	self.entityPluralName = "";
	self.entityId = "";
	self.trackingId = "";
	self.contentType = request.headers.accept || "application/json";
	if (self.contentType.indexOf("application/json") != 0) self.contentType = "application/json";
	self.operation = WorkingCopyOp.unknown;
	if (request.session) self.session = request.session
	else self.session = sessionManager.sessionByCookie(request.headers.cookie);
}

WorkingCopyRequest = helpers.defineClass(WorkingCopyRequest, null, {
	_checkTrackingId: function() {
		var self = this;
		if (!self.trackingId) throw new Error("Invalid workingCopies url, no trackingId. " + self.url);
	},
	_parseTrackingId: function(segment) {
		var self = this;
		var cseg = _parseSegment(segment);
		if (cseg.length != 2) self._throwInvalidURL("expected " + c_workingCopies + "('id') found " + segment);
		if (cseg[0] != c_workingCopies) self._throwInvalidURL("expected " + c_workingCopies + " found " + cseg[0]);
		self.trackingId = cseg[1];
		self._checkTrackingId();
	},
	_throwInvalidURL: function(message) {
		var self = this;
		throw new Error("Invalid workingCopies url" + (message ? (" (" + message + ")") : "") + ". " + self.url);
	},
	parse: function(_) {
		var self = this;
		if (!self.session) throw new Error("Authorization Required:  object session not found");
		self.data = self.request.context.parseBody(_) || {};
		var parsedURL = url.parse(self.url, true);
		if (parsedURL.host) self.root = parsedURL.protocol + "//" + parsedURL.host;
		var path = parsedURL.pathname.split("/");
		if (path.length < 6) self._throwInvalidURL();
		self.application = path[2];
		self.contract = path[3];
		self.dataset = path[4];
		self.baseUrl = self.root + "/" + path[1] + "/" + path[2] + "/" + path[3] + "/" + path[4];
		switch (self.method) {
		case "get":
			var cseg = _parseSegment(decodeURIComponent(path[5]));
			self.entityId = cseg[1];
			self.operation = WorkingCopyOp.get;
			break;
		case "post":
			var cseg = _parseSegment(path[5]);
			self.entityPluralName = cseg[0];
			self.trackingId = parsedURL.query["trackingId"];
			self._checkTrackingId();
			if (cseg.length == 1) {
				// create or restore 
				if (path.length != 8) self._throwInvalidURL();
				self.operation = (self.data && self.data.$uuid) ? WorkingCopyOp.restore : WorkingCopyOp.create;
				if (path[6] != "$template") self._throwInvalidURL("expected $template found " + path[6]);
				if (path[7] != c_workingCopies) self._throwInvalidURL("expected " + c_workingCopies + " found " + path[7]);
			} else {
				//edit, duplicate or restore 
				self.entityId = cseg[1];
				self.operation = ((self.data && self.data.$uuid) ? WorkingCopyOp.restore : WorkingCopyOp.edit);
				if (path[6] == "$template") {
					self.operation = WorkingCopyOp.duplicate;
					if (path.length != 8) self._throwInvalidURL();
					if (path[7] != c_workingCopies) self._throwInvalidURL("expected " + c_workingCopies + " found " + path[7]);
				} else {
					if (path.length != 7) self._throwInvalidURL();
					if (path[6] != c_workingCopies) self._throwInvalidURL("expected " + c_workingCopies + " found " + path[6]);
				}
			}
			break;
		case "delete":
			self._parseTrackingId(path[5]);
			self.operation = WorkingCopyOp.drop;
			break;
		case "put":
			// save or update
			self._parseTrackingId(path[5]);
			self.operation = WorkingCopyOp.delta;
			break;
		default:
			throw new Error("Invalid workingCopies method " + self.method);
		}
	}
});


function WorkingCopyContext(request) {
	var self = this;
	self.etag = 0;
	self.id = request.trackingId;
	self.baseUrl = request.baseUrl;
	var application = registry.applications[request.application];
	if (!application) throw new Error("application not found: " + request.application);
	var contract = application.contracts[request.contract];
	if (!contract) throw new Error("contract not found: " + request.contract);
	if (!contract.datasets[request.dataset]) throw new Error("dataset not found: " + request.dataset);
	self.model = dataModel.make(contract, request.dataset);
	var singular = self.model.singularize(request.entityPluralName);
	if (!singular) throw new Error("entity not found: " + request.entityPluralName);
	var entity = self.model.getEntity(singular)
	if (!entity) throw new Error("entity not found: " + request.singular);
	self.entity = entity;
	self.dataContext = new DataContext(self.model, request.dataset, true);
	self.dataContext.serverSession = request.session;
}

WorkingCopyContext = helpers.defineClass(WorkingCopyContext, null, {
	execute: function(_, context, request) {
		var self = this;
		var dc = self.dataContext;
		try {
			if (self[request.operation]) self[request.operation](_, context, request);
			else throw new Error("Invalid $workingCopies request (no operation found). ");
		} catch (ex) {
			console.error("EXCEPTION " + ex.message + "\n" + ex.stack)
			context.reply(_, 500, ex.message);
		}
	},
	_replyDbHandle: function(_, context, request, dc, dbHandle) {
		var self = this;
		var statusCode = dc.statusCode;
		var headers = {};
		//HACK ALCOU
		var delta = true;
		if (dbHandle.$NoDelta) {
			//delta = false;
			delete dbHandle.$NoDelta;
		}
		//FIN HACK ALCOU
		dbHandle.$type = dbHandle.$type || request.contentType;
		var resource = dc.serializeDbHandle(_, dbHandle, {
			baseUrl: self.baseUrl,
			delta: delta,
			actions: true
		});
		resource.$url = self.baseUrl + "/" + c_workingCopies + "('" + self.id + "')";
		if (statusCode == 201) headers.location = resource.$url;
		self.etag++;
		resource.$etag = self.etag;
		headers.etag = resource.$etag;
		headers["content-type"] = request.contentType;
		context.reply(_, dc.statusCode, resource, headers);
	},

	_testEtag: function(_, context, request) {
		var self = this;
		if (!request.data || request.data.$etag != self.etag) {
			var headers = {};
			headers.etag = self.dataContext.lastState.$etag;
			headers["content-type"] = request.contentType;
			context.reply(_, 412, self.dataContext.lastState, headers);
			return false;
		}
		return true;
	},
	createWorkingCopy: function(_, context, request) {
		var self = this;
		var dc = self.dataContext;
		dc.statusCode = 201;
		var dbHandle = dc.create(_, self.entity.className, null);
		dc.setMainDbHandle(dbHandle);
		dc.check(_);
		self._replyDbHandle(_, context, request, dc, dbHandle);
	},
	duplicateWorkingCopy: function(_, context, request) {
		var self = this;
		var dc = self.dataContext;
		dc.statusCode = 201;
		var dbHandle = dc.create(_, self.entity.className, null);
		dc.setMainDbHandle(dbHandle);
		dc.check(_);
		self._replyDbHandle(_, context, request, dc, dbHandle);
	},
	getWorkingCopy: function(_, context, request) {
		var self = this;
		var dc = self.dataContext;
		var dbHandle = dc.dbHandles[0];
		dbHandle.$NoDelta = true; //Hack alcou
		self._replyDbHandle(_, context, request, dc, dbHandle); //ALCOU, c'est Ã§a qu'il faut faire ???
	},
	restoreWorkingCopy: function(_, context, request) {
		var self = this;
		var dc = self.dataContext;
		dc.statusCode = 201;
		if (request.data.$etag) {
			self.etag = request.data.$etag;
		}
		var dbHandle;
		var entityId = request.data.$uuid;
		if (entityId) {
			dbHandle = dc.edit(_, self.entity.className, request.data);
			if (!dbHandle) {
				dbHandle = dc.create(_, self.entity.className, request.data);
				// remove working copy
				//dc.throwException("DbHandle not found");
				//request.session.setData(request.trackingId);
				//return _createReply(404, "DbHandle not found");
			}
		}
		dc.setMainDbHandle(dbHandle);
		dc.check(_);
		dc.restoreLastResource(request.data);
		self._replyDbHandle(_, context, request, dc, dbHandle);
	},
	editWorkingCopy: function(_, context, request) {
		var self = this;
		var dc = self.dataContext;
		var cd = {
			$uuid: request.entityId
		};
		dc.statusCode = 201;
		var dbHandle = dc.edit(_, self.entity.className, cd);
		if (!dbHandle) {
			// remove working copy
			request.session.setData(request.trackingId);
			return context.reply(_, 500, "DbHandle not found");
		}
		dc.setMainDbHandle(dbHandle);
		dc.check(_);
		self._replyDbHandle(_, context, request, dc, dbHandle);
	},
	deltaWorkingCopy: function(_, context, request) {
		var self = this;
		var dc = self.dataContext;
		dc.statusCode = 200;
		if (!self._testEtag(_, context, request)) return;
		var dbHandle = dc.applyDelta(_, request.data);
		dc.check(_);
		self._replyDbHandle(_, context, request, dc, dbHandle);
	},
	onDestroy: function(_) {
		var self = this;
		var dc = self.dataContext;
		delete self.dataContext;
		if (dc && dc.onDestroy) dc.onDestroy();
	}

});


function _dispatch(_, context) {
	try {
		var workingCopyRequest = new WorkingCopyRequest(context.request);
		workingCopyRequest.parse(_);
		var draft = null;
		if (workingCopyRequest.operation == WorkingCopyOp.drop) {
			draft = workingCopyRequest.session.getData(workingCopyRequest.trackingId);
			if (draft) {
				workingCopyRequest.session.setData(draft.id, null);
				return context.reply(_, 204);
			} else return context.reply(_, 404, "Not found");
		}
		var createDraft = ([WorkingCopyOp.create, WorkingCopyOp.restore, WorkingCopyOp.edit, WorkingCopyOp.duplicate].indexOf(workingCopyRequest.operation) >= 0);
		if (createDraft) {
			draft = new WorkingCopyContext(workingCopyRequest);
			workingCopyRequest.session.setData(draft.id, draft);
		} else {
			var id = workingCopyRequest.trackingId || workingCopyRequest.entityId;
			draft = workingCopyRequest.session.getData(id);
			if (!draft) {
				return context.reply(_, 404, "Draft not found");
			}
		}
		draft.execute(_, context, workingCopyRequest);
	} catch (ex) {
		//console.error(ex.message + "\n" + ex.stack);
		// BRJOU: PB cannot distinguish between 400 and 500 here
		context.reply(_, ex.statusCode || 400, ex.message);
	}
};

exports.dispatchsData = _dispatch;

function TestResponse() {
	this.writeHead = function(statusCode, headers) {
		this.statusCode = statusCode;
		this.headers = headers;
	}
	this.write = function(data, enc) {
		throw new Error("write not supported on test response!!!")
	}
	this.end = function(body) {
		this.body = body;
	}
}
// Special entry point for unit tests - clean up later
exports.dispatch = function(_, request) {
	request.socket = {};
	var response = new TestResponse();
	_dispatch(_, new sdataContext.Context(request, response));
	if (response.headers["content-type"].indexOf("application/json") == 0) response.body = JSON.parse(response.body);
	return response;
}