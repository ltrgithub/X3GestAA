"use strict";
/**
 * Copyright (c) 2011 Bruno Jouhier <bruno.jouhier@sage.com>
 * MIT License
 */

var helpers = require("syracuse-core/lib/helpers");
var jsurl = require("jsurl");
//var config = require("config"); // no call require(config) because this is use by the ui client that implies failure of some feature in client  side
/// !nodoc -- experimental
/// 
/// # syracuse-sdata/lib/httpHelper
///  
/// HTTP helpers
exports.HttpStatus = {
	OK: 200,
	Created: 201,
	Accepted: 202,
	NoContent: 204,
	MovedPermanently: 301,
	Found: 302,
	SeeOther: 303,
	NotModified: 304,
	TemporaryRedirect: 307,
	BadRequest: 400,
	Unauthorized: 401,
	Forbidden: 403,
	NotFound: 404,
	MethodNotAllowed: 405,
	NotAcceptable: 406,
	Conflict: 409,
	Gone: 410,
	PreconditionFailed: 412,
	UnsupportedMediaType: 415,
	InternalServerError: 500,
	NotImplemented: 501,
	ServiceUnavailable: 503
};

exports.statusMessages = Object.keys(exports.HttpStatus).reduce(function(map, msg) {
	return map[exports.HttpStatus[msg]] = msg.replace(/[A-Z]/g, function(letter) {
		return ' ' + letter.toLowerCase();
	}).substring(1), map; // substring to remove leading space introduced by replace.
}, {});

exports.mediaTypes = {
	pdf: "application/pdf",
	xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
	docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
	pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
	doc: "application/msword",
	xls: "application/vnd.ms-excel",
	zip: "application/zip",

	excel_worksheet: "application/syracuse-excel-worksheet",
	word_report: "application/syracuse-word-report",
	word_mailmerge: "application/syracuse-word-mailmerge",
	ppt_slide: "application/syracuse-ppt-slide",

};

function _classifyMedia(str) {
	if (str == "*" || str == "*/*") return "*";
	var lower = str.toLowerCase();

	if (lower.indexOf("vnd.openxmlformats-officedocument.spreadsheetml.sheet") >= 0) return "xlsx";
	if (lower.indexOf("syracuse-excel-worksheet") >= 0) return "xlsx";

	if (lower.indexOf("application/vnd.openxmlformats-officedocument.wordprocessingml.document") >= 0) return "docx";
	if (lower.indexOf("syracuse-word-report") >= 0) return "docx";
	if (lower.indexOf("syracuse-word-mailmerge") >= 0) return "docx";

	if (lower.indexOf("application/vnd.openxmlformats-officedocument.presentationml.presentation") >= 0) return "pptx";
	if (lower.indexOf("syracuse-ppt-slide") >= 0) return "pptx";

	if (lower.indexOf("xml") >= 0) return "xml";
	if (lower.indexOf("html") >= 0) return "html";
	if (lower.indexOf("json") >= 0) return "json";
	if (lower.indexOf("text") >= 0) return "text";
	if (lower.indexOf("image") >= 0) return "image";
	if (lower.indexOf("pdf") >= 0) return "pdf";

	// in order to solve upload issue on IE
	if (lower.indexOf("application/x-ms-application") >= 0) return "html";

	return "unknown";
}

exports.parseAccept = function(str) {
	// parse and sort by decreasing quality
	var accept = (str || "").toString().split(/\s*,\s*/).map(function(part, i) {
		var m = part.match(/^([^;]+)(?:;\s*q=(\d+(?:\.\d+)?))?/);
		return m && [m[1], Number(m[2] || 1.0), i];
	}).filter(function(elt) {
		return elt;
	}).sort(function(elt1, elt2) {
		return elt2[1] - elt1[1] || elt1[2] - elt2[2]; // 2nd test to preserve order
	}).map(function(elt) {
		var split = elt[0].split(';');
		var result = {
			rawType: split[0],
			type: _classifyMedia(split[0]),
			parameters: {}
		};
		split.slice(1).forEach(function(str) {
			var pair = str.split(/\s*=\s*/);
			result.parameters[pair[0]] = pair[1];
		});
		return result;
	});
	// empty accept means accept anything
	return accept.length > 0 ? accept : [{
		rawType: "*",
		type: "*",
		parameters: {}
	}];
};

// extracts some interesting headers
exports.parseHeaders = function(headers) {
	function _normalize(str) {
		return str.replace(/^\s+|\s+$/, "").toLowerCase();
	}
	var result = {
		isJSON: function() {
			return (this["content-type"] === "application/json") || !this["content-type"];
		},
		toNodeCharset: function() {
			// TODO: have a proper list of node supported charsets
			return (this.charset === "utf-8" || this.charset === "utf8") ? "utf8" : "binary";
		}
	};
	// content type
	var contentType = ((headers || {})["content-type"] || "").split(";");
	if (contentType[0]) result["content-type"] = _normalize(contentType[0]);
	contentType.slice(1).forEach(function(param) {
		param = param.split("=");
		if (param[0]) result[_normalize(param[0])] = _normalize(param[1]);
		else return;
	});
	//
	return result;
};

exports.decodeDetailSegment = function(segment) {
	var match = /^([^\/(]*)\((.*)\)$/.exec(segment);
	if (match) {
		var res = {
			name: match[1]
		};
		if (match[2]) {
			if (match[2][0] !== "'") {
				res.id = match[2];
				res.isExpressionId = true;
			} else {
				res.id = match[2].substring(1, match[2].length - 1);
				res.isExpressionId = false;
			}
		}
		return res;
	} else return null;
};

exports.tracer = null;

exports.HttpContext = function(request, response, options) {
	if (request == null) // subclassing
		return;
	options = options || {};

	this.request = request;
	this.response = response;
	// URL stuff
	var _split = request.url.split('?');
	this.path = _split.splice(0, 1)[0];
	this.secure = (request.hosting && request.hosting.https) || ('authorized' in request.connection);
	var _urlBegin = (this.secure ? "https" : "http") + "://" + request.headers.host;
	this.url = _urlBegin + this.path;
	this.rawQuery = _split.join('?');
	this.query = helpers.url.parseQueryString(this.rawQuery);
	this.method = (this.query.$method || request.headers[options.methodHeader || "x-http-method-override"] || request.method).toLowerCase();
	// shouldn't change the method case, X3 doesn't like it 
	if ((request.method && request.method.toLowerCase()) !== this.method) request.method = this.method;
	delete this.query.$method;
	if (exports.tracer) {
		exports.tracer("\nHTTP REQUEST: " + request.method + " " + request.url + "\n");
		exports.tracer("headers: " + JSON.stringify(request.headers) + "\n");
	}
	var _segments = this.path.split('/').map(function(seg) {
		return decodeURIComponent(seg);
	});
	var _segI = 1; // start after leading /
	this.walkUrl = function() {
		return _segments[_segI++];
	};
	this.unwalkUrl = function() {
		_segI--;
	};
	this.walked = function() {
		return _urlBegin + _segments.slice(0, _segI).join("/");
	};
	this.toWalk = function() {
		return _segments.slice(_segI).join("/");
	};

	// Accept stuff
	this.rawAccept = this.query[options.acceptParam] || request.headers.accept || "*";
	this.accept = exports.parseAccept(this.rawAccept);

	this.reply = function(code, message, headers) {
		headers = headers || {};
		if (message && !headers["content-type"]) headers["content-type"] = "text/plain";
		response.writeHead(code, headers);
		response.end(message);
	};

	this.scratch = {}; // scratch area where business logic can write stuff
};