"use strict";

var module = QUnit.module;
var baseUrl = "http://localhost:8124"
// var baseUrl = "http://localhost:3004"
// var port = 3004;
var fs = require('fs');

var helpers = require('syracuse-core/lib/helpers');
var types = require('syracuse-core/lib/types/allTypes');
// must be first syracuse require
var config = require('syracuse-main/lib/nodeconfig').config;
var pdfRenderer = require('syracuse-sdata/lib/render/pdf');
var sys = require("util");
var forEachKey = helpers.object.forEachKey;

// var tracer = console.log;
var tracer = (function() {
	var _fd;
	return function(s) {
		_fd = fs.openSync("pdfTest.log", _fd == null ? "w" : "a");
		fs.writeSync(_fd, s + "\n");
		fs.closeSync(_fd);
	}
})();

// var tracer = null;
module("pdfTest", {
	setup : function() {
		// tracer("pdfTest setup");
		// _inject();
	},
	teardown : function() {
		// tracer("pdfTest teardown");
	}
});

var roundedRectCalled;

var context = {
	request : {
		headers : {
			referer : ''
		},
		httpSession : {
			cookie : ''
		}
	}
};

asyncTest("full page user", 4, function(_) {
	var name = "user_full", rep = _load("user", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json",
			"proto $type is application/json");
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);
	start();
});

asyncTest("2 pages user", 4, function(_) {
	var name = "2_pages_user_full", rep = _load("user", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json",
			"proto $type is application/json");
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

asyncTest("user list on a single page", 4, function(_) {
	var name = "user_list", rep = _load("user_list", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	ok(rep.data.$resources.length > 0, "$resources array not empty");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json",
			"proto $type is application/json");
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

var current = {};

function _load(name, _) {
	current[name] = current[name]
			|| {
				proto : JSON.parse(fs.readFile(__dirname + "/resources/" + name
						+ "_proto.json", 'utf8', _)),
				data : JSON.parse(fs.readFile(__dirname + "/resources/" + name
						+ "_data.json", 'utf8', _))
			};

	return current[name];
}

function _loadArticle(name, _) {
	return JSON.parse(fs.readFile(__dirname + "/resources/" + name
			+ "_article.json", 'utf8', _));
}

function _writePdf(pdf, name, _) {
	var path = __dirname + "/output";
	// var exists = fs.exists(path, _);
	try {
		var stats = fs.stat(path, _);
	} catch (e) {
		if (e.code === 'ENOENT')
			fs.mkdir(path, undefined, _);
	}
	fs.writeFile(path + "/" + name + ".pdf", pdf, 'binary', _);
}

function LayoutBuilder() {
	this.items = [];
	this.layout = {
		$layout : {
			$items : this.items
		}
	};
};

exports.LayoutBuilder = helpers.defineClass(LayoutBuilder, null, {
	appendSection : function(items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$category : "section",
			$layout : {
				$items : this.items
			}
		});
		return this;
	},
	appendLayout : function(layoutType, layoutSubType, items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$layoutType : layoutType,
			$layoutSubType : layoutSubType,
			$items : this.items
		});
		return this;
	},
	appendBlock : function(title, items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$title : title,
			$category : "block",
			$layout : {
				$items : this.items
			}
		});
		return this;
	},
	addProperty : function(bind, options, items) {
		items = items || this.items;
		var prop = options || {};
		prop.$bind = bind;
		items.push(prop);
		return this;
	},
});

function Aspect() {
};

var Aspect = helpers.defineClass(Aspect, null, {
	before : function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				aspect.apply(this, [ {
					pointCut : "before",
					name : k
				}, Array.prototype.slice.call(arguments) ]);
				return old.apply(this, arguments);
			};
		});
	},
	after : function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				var res = old.apply(this, arguments);
				aspect.apply(this, [ {
					pointCut : "after",
					name : k
				}, Array.prototype.slice.call(arguments) ], res);
				return res;
			};
		});
	},
	around : function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				var args = Array.prototype.slice.call(arguments);
				aspect.apply(this, [ {
					pointCut : "before",
					name : k
				}, args ]);
				var res = old.apply(this, arguments);
				aspect.apply(this, [ {
					pointCut : "after",
					name : k
				}, args, res ]);
				return res;
			};
		});
	},
	_setPointCut : function(obj, funcs, aspect, pointCut) {
		if (!this._isFunction(aspect))
			return;
		if (typeof (funcs) === "string")
			funcs = [ funcs ];
		var proto = obj.prototype;
		for ( var k in proto) {
			if (k === "toString")
				continue;
			var old = proto[k];
			if (!old || !this._isFunction(old))
				continue;

			var injectIt = funcs.some(function(e) {
				return (k.search(e) != -1);
			});

			if (injectIt)
				proto[k] = pointCut(k, old);
		}
	},
	_isFunction : function(obj) {
		return !!(obj && obj.constructor && obj.call && obj.apply);
	}
});

function _inject() {
	var PdfDocument = require('streamline-pdfkit');
	var aspect = new Aspect();
	aspect.around(PdfDocument, [ "roundedRect", "text", "fillColor",
			"lineWidth", "widthOfString", "currentLineHeight" ], function(
			context, args, result) {
		if (context.pointCut === "before") {
			tracer("before " + context.name + " [" + args + "]");
		} else {
			tracer("after " + context.name + " ==> " + result);
		}
	});
}