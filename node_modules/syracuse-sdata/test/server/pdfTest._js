"use strict";

var baseUrl = "http://localhost:8124";
// var baseUrl = "http://localhost:3004"
// var port = 3004;
var fs = require('streamline-fs');

var streams = require('streamline/lib/streams/streams');
var helpers = require('syracuse-core/lib/helpers');
var aspect = require('syracuse-core/lib/aspect');
var types = require('syracuse-core/lib/types/allTypes');
// must be first syracuse require
var config = require('config');
var pdfRenderer = require('syracuse-sdata/lib/render/pdf');
var stylesheet = require('syracuse-sdata/lib/render/stylesheet');
var sys = require("util");
var forEachKey = helpers.object.forEachKey;

var tracer; // = console.log;
var roundedRectCalled;

var context = {
	request: {
		headers: {
			referer: ''
		}
	},
	httpSession: {
		cookie: ''
	}
};

function link(desc, url) {
	return '<a href="' + url + '" target="_blank">' + desc + '</a>';
}

QUnit.module(module.id, {
	setup: function() {
		// tracer("pdfTest setup");
		// _inject();
	},
	teardown: function() {
		// tracer("pdfTest teardown");
	}
});

asyncTest('cookie', 2, function(_) {
	context.httpSession.cookie = getCookie(_, "guest", "guest");
	ok(context.httpSession.cookie && context.httpSession.cookie.length > 0, "cookie ok");

	start();
});

asyncTest(link("full page user", "/syracuse-sdata/test/server/output/user_full.pdf"), 4, function(_) {
	var name = "user_full",
		rep = _load("user", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	delete context.pdfReport;
	var options = {
		// debug: {
		// 	format: true,
		// 	image: true,
		// 	box: true,
		// 	buildBox: true,
		// 	computeBox: true,
		// 	valueBox: true
		// },
		css: {
			// "default": {
			// 	font: {
			// 		size: 9,
			// 		family: "Helvetica"
			// 		// family: "DejaVuSans"
			// 	}
			// },
			page: {
				background: {
					image: "url('http://localhost:8124/syracuse-sdata/lib/render/images/sage-banner.png')",
					// image: "url('http://localhost:8124/syracuse-sdata/lib/render/images/bg_lightGreen.3698.jpg')",
					// size: "80 60",
					// position: "center"
				}
			},
			block: {
				background: {
					image: "url('http://localhost:8124/syracuse-sdata/lib/render/images/Koala-watermark.png')",
				}

			}
		}
	};
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto, options);
	_writePdf(pdf, name, _);

	start();
});

asyncTest(link("2 pages user", "/syracuse-sdata/test/server/output/2_pages_user_full.pdf"), 4, function(_) {
	var name = "2_pages_user_full",
		rep = _load("user", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	delete context.pdfReport;
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

asyncTest(link("user list on a single page", "/syracuse-sdata/test/server/output/user_list.pdf"), 4, function(_) {
	var name = "user_list",
		rep = _load("user_list", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	ok(rep.data.$resources.length > 0, "$resources array not empty");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	var options = {
		// 	debug: {
		// 		format: true,
		// 		image: true,
		// 		box: true,
		// 		buildBox: true,
		// 		computeBox: true,
		// 		valueBox: true,
		// 	}
	};

	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto, options);
	_writePdf(pdf, name, _);

	start();
});

asyncTest(link("user list on several pages", "/syracuse-sdata/test/server/output/user_list_more_pages.pdf"), 4, function(_) {
	var name = "user_list",
		rep = _load("user_list", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	ok(rep.data.$resources.length > 0, "$resources array not empty");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");

	// duplicate users
	rep.data.$resources.forEach(function(e, i, a) {
		for (var n = 1; n <= 20; n++) {
			var user = helpers.object.clone(e, true);
			// user.$key = user.$uuid = helpers.uuid.generate();
			user.login += n;
			a.push(user);
		}
	});

	var options = {
		// 	debug: {
		// 		format: true,
		// 		image: true,
		// 		box: true,
		// 		buildBox: true,
		// 		computeBox: true,
		// 		valueBox: true,
		// 	}
	};
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name + "_more_pages", _);

	start();
});

asyncTest(link("unicode string", "/syracuse-sdata/test/server/output/unicode_string.pdf"), 3, function(_) {
	var name = "unicode_string",
		rep = _load("unicode_string", _);
	ok(rep.data != null, "data not null");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	// var unicode = getUnicodeString();
	// 		var unicode = "\
	// 00a0-00cf: ¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ\n\
	// 00d0-00ff:ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿn\
	// 0100-01ff:ĀāĂăĄą";
	// €àâäéèêëîïôöùûü§º
	var unicode = "\
00a0-00cf: ...........ÈÉÊËÌÍÎÏ\n\
00d0-00ff:ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\n";
	// 00a0-00cf: ¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ\n\
	// 00d0-00ff:ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\n\
	// 0100-01ff:ĀāĂăĄą";
	unicode = "00a0-00ff: ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ";
	rep.data = {
		// "unicode": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋŌōŎŏŐőŒœŔŕŖŗŘřŚśŜŝŞşŠšŢţŤťŦŧŨũŪūŬŭŮůŰűŲųŴŵŶŷŸŹźŻżŽžſƀƁƂƃƄƅƆƇƈƉƊƋƌƍƎƏƐƑƒƓƔƕƖƗƘƙƚƛƜƝƞƟƠơƢƣƤƥƦƧƨƩƪƫƬƭƮƯưƱƲƳƴƵƶƷƸƹƺƻƼƽƾƿǀǁǂǃǄǅǆǇǈǉǊǋǌǍǎǏǐǑǒǓǔǕǖǗǘǙǚǛǜǝǞǟǠǡǢǣǤǥǦǧǨǩǪǫǬǭǮǯǰǱǲǳǴǵǶǷǸǹǺǻǼǽǾǿ"
		unicode: unicode
	};

	var path = __dirname + "/output";
	try {
		var stats = fs.stat(path, _);
	} catch (e) {
		if (e.code === 'ENOENT') fs.mkdir(path, undefined, _);
	}
	fs.writeFile(path + "/" + name + ".txt", unicode, _);

	var options = {
		// 	debug: {
		// 		// output: {
		// 		// 	pdf: "pdf_report.pdf",
		// 		// 	data: "pdf_data.json",
		// 		// 	proto: "pdf_proto.json",
		// 		// }
		// 	},
		// 	css: {
		// 		"default": {
		// 			font: {
		// 				size: 9,
		// 				// family: "Helvetica"
		// 				family: "DejaVuSans"
		// 			}
		// 		}
		// 	}
	};
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto, options);
	_writePdf(pdf, name, _);

	start();
});

asyncTest(link("unicode char table", "/syracuse-sdata/test/server/output/unicode_table.pdf"), 4, function(_) {
	var name = "unicode_table",
		rep = _load("unicode_table", _);
	// rep.proto.$article = _loadArticle(name, _);
	ok(rep.data != null, "data not null");
	ok(rep.data.$resources.length > 0, "$resources array not empty");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	var options = {
		// 	debug: {
		// 		output: {
		// 			pdf: "pdf_report.pdf",
		// 			data: "pdf_data.json",
		// 			proto: "pdf_proto.json",
		// 		}
		// 	}
	};
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

function getCookie(_, login, pass) {
	var response = new streams.httpRequest({
		url: baseUrl + "/syracuse-main/html/main.html",
		user: login || "guest",
		password: pass || "guest"
	}).end().response(_);
	response.readAll(_);
	strictEqual(response.statusCode, 200, "user authenticated");
	return response.headers["set-cookie"];
}

function getUnicodeString() {
	var cstart = 0x00a0;
	var cend = 0x0200;
	// var cend = 0x0100;
	for (var i = cstart; i < cend; i++) {
		if ((i - cstart) % 48 == 0) {
			unicode += (i == cstart ? "" : "\n") + ("00" + i.toString(16)).slice(-4) + "-" + ("00" + (i + 47).toString(16)).slice(-4) + ":";
		}
		// if ([0x00AD,0x00EC,0x00ED,0x00EE,0x00EF].some(function(e) {
		// 	return e === i;
		// })) {
		// 	unicode += String.fromCharCode(0x007E);
		// } else {
		unicode += String.fromCharCode(i);
		// }
	}
	return unicode;
}

var current = {};

function _load(name, _) {
	current[name] = current[name] || {
		proto: JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_proto.json", 'utf8', _)),
		data: JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_data.json", 'utf8', _))
	};

	return current[name];
}

function _loadArticle(name, _) {
	return JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_article.json", 'utf8', _));
}

function _writePdf(pdf, name, _) {
	var path = __dirname + "/output";
	// var exists = fs.exists(path, _);
	try {
		var stats = fs.stat(path, _);
	} catch (e) {
		if (e.code === 'ENOENT') fs.mkdir(path, undefined, _);
	}
	fs.writeFile(path + "/" + name + ".pdf", pdf, 'binary', _);
}

function LayoutBuilder() {
	this.items = [];
	this.layout = {
		$layout: {
			$items: this.items
		}
	};
};

exports.LayoutBuilder = helpers.defineClass(LayoutBuilder, null, {
	appendSection: function(items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$category: "section",
			$layout: {
				$items: this.items
			}
		});
		return this;
	},
	appendLayout: function(layoutType, layoutSubType, items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$layoutType: layoutType,
			$layoutSubType: layoutSubType,
			$items: this.items
		});
		return this;
	},
	appendBlock: function(title, items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$title: title,
			$category: "block",
			$layout: {
				$items: this.items
			}
		});
		return this;
	},
	addProperty: function(bind, options, items) {
		items = items || this.items;
		var prop = options || {};
		prop.$bind = bind;
		items.push(prop);
		return this;
	},
});

function _inject() {
	var PdfDocument = require('streamline-pdfkit');
	aspect.around(PdfDocument, ["roundedRect", "text", "fillColor", "lineWidth", "widthOfString", "currentLineHeight"], function(
		context, args, result) {
		if (context.pointCut === "before") {
			tracer("before " + context.name + " [" + args + "]");
		} else {
			tracer("after " + context.name + " ==> " + result);
		}
	});
}