"use strict";

var module = QUnit.module;
var baseUrl = "http://localhost:8124"
// var baseUrl = "http://localhost:3004"
// var port = 3004;
var fs = require('fs');

var streams = require('streamline/lib/streams/streams');
var helpers = require('syracuse-core/lib/helpers');
var types = require('syracuse-core/lib/types/allTypes');
// must be first syracuse require
var config = require('syracuse-main/lib/nodeconfig').config;
var pdfRenderer = require('syracuse-sdata/lib/render/pdf');
var sys = require("util");
var forEachKey = helpers.object.forEachKey;

// var tracer = null;
var tracer = console.log;
// var tracer = (function() {
// 	var _fd;
// 	return function(s) {
// 		_fd = fs.openSync(".out/pdfTest.log", _fd == null ? "w" : "a");
// 		fs.writeSync(_fd, s + "\n");
// 		fs.closeSync(_fd);
// 	}
// })();

var roundedRectCalled;

var context = {
	request: {
		headers: {
			referer: ''
		}
	},
	httpSession: {
		cookie: ''
	}
};


module("pdfTest", {
	setup: function() {
		// tracer("pdfTest setup");
		// _inject();
	},
	teardown: function() {
		// tracer("pdfTest teardown");
	}
});

asyncTest('cookie', 2, function(_) {
	context.httpSession.cookie = getCookie(_, "guest", "guest");
	ok(context.httpSession.cookie && context.httpSession.cookie.length > 0, "cookie ok");

	start();
});

asyncTest('<a href="/syracuse-sdata/test/server/output/user_full.pdf">full page user</a>', 4, function(_) {
	var name = "user_full",
		rep = _load("user", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	delete context.pdfReport;
	// context.pdfReport = {
	// 	debug: {
	// 		format: true,
	// 		image: true,
	// 		box: true,
	// 		buildBox: true,
	// 		computeBox: true,
	// 		valueBox: true,
	// 	}
	// };
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

asyncTest('<a href="/syracuse-sdata/test/server/output/2_pages_user_full.pdf">2 pages user</a>', 4, function(_) {
	var name = "2_pages_user_full",
		rep = _load("user", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	delete context.pdfReport;
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

asyncTest('<a href="/syracuse-sdata/test/server/output/user_list.pdf">user list on a single page</a>', 4, function(_) {
	var name = "user_list",
		rep = _load("user_list", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	ok(rep.data.$resources.length > 0, "$resources array not empty");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	delete context.pdfReport;
	// context.pdfReport = {
	// 	debug: {
	// 		format: true,
	// 		image: true,
	// 		box: true,
	// 		buildBox: true,
	// 		computeBox: true,
	// 		valueBox: true,
	// 	}
	// };

	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

asyncTest('<a href="/syracuse-sdata/test/server/output/user_list_more_pages.pdf">user list on several pages</a>', 4, function(_) {
	var name = "user_list",
		rep = _load("user_list", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	ok(rep.data.$resources.length > 0, "$resources array not empty");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");

	// duplicate users
	rep.data.$resources.forEach(function(e, i, a) {
		for (var n = 1; n <= 20; n++) {
			var user = helpers.object.clone(e, true);
			// user.$key = user.$uuid = helpers.uuid.generate();
			user.login += n;
			a.push(user);
		}
	});

	delete context.pdfReport;
	// context.pdfReport = {
	// 	debug: {
	// 		format: true,
	// 		image: true,
	// 		box: true,
	// 		buildBox: true,
	// 		computeBox: true,
	// 		valueBox: true,
	// 	}
	// };
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name + "_more_pages", _);

	start();
});

asyncTest('<a href="/syracuse-sdata/test/server/output/unicode_string.pdf">unicode string</a>', 3, function(_) {
	var name = "unicode_string",
		rep = _load("unicode_string", _);
	ok(rep.data != null, "data not null");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	// var unicode = getUnicodeString();
	// 		var unicode = "\
	// 00a0-00cf: ¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ\n\
	// 00d0-00ff:ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿn\
	// 0100-01ff:ĀāĂăĄą";

	// €àâäéèêëîïôöùûü§º
	var unicode = "\
00a0-00cf: ...........ÈÉÊËÌÍÎÏ\n\
00d0-00ff:ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\n";
	// 00a0-00cf: ¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏ\n\
	// 00d0-00ff:ÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\n\
	// 0100-01ff:ĀāĂăĄą";
	unicode = "00a0-00ff: ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ";
	rep.data = {
		// "unicode": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋŌōŎŏŐőŒœŔŕŖŗŘřŚśŜŝŞşŠšŢţŤťŦŧŨũŪūŬŭŮůŰűŲųŴŵŶŷŸŹźŻżŽžſƀƁƂƃƄƅƆƇƈƉƊƋƌƍƎƏƐƑƒƓƔƕƖƗƘƙƚƛƜƝƞƟƠơƢƣƤƥƦƧƨƩƪƫƬƭƮƯưƱƲƳƴƵƶƷƸƹƺƻƼƽƾƿǀǁǂǃǄǅǆǇǈǉǊǋǌǍǎǏǐǑǒǓǔǕǖǗǘǙǚǛǜǝǞǟǠǡǢǣǤǥǦǧǨǩǪǫǬǭǮǯǰǱǲǳǴǵǶǷǸǹǺǻǼǽǾǿ"
		unicode: unicode
	}

	var path = __dirname + "/output";
	try {
		var stats = fs.stat(path, _);
	} catch (e) {
		if (e.code === 'ENOENT') fs.mkdir(path, undefined, _);
	}
	fs.writeFile(path + "/" + name + ".txt", unicode, _);

	delete context.pdfReport;
	// context.pdfReport = {
	// 	debug: {
	// 		// output: {
	// 		// 	pdf: "pdf_report.pdf",
	// 		// 	data: "pdf_data.json",
	// 		// 	proto: "pdf_proto.json",
	// 		// }
	// 	}
	// };
	var options = null;
	// var options = {
	// 	css: {
	// 		"default": {
	// 			font: {
	// 				size: 9,
	// 				// family: "Helvetica"
	// 				family: "DejaVuSans"
	// 			}
	// 		}
	// 	}
	// }
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto, options);
	_writePdf(pdf, name, _);

	start();
});

asyncTest('<a href="/syracuse-sdata/test/server/output/unicode_table.pdf">unicode char table</a>', 4, function(_) {
	var name = "unicode_table",
		rep = _load("unicode_table", _);
	// rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	ok(rep.data.$resources.length > 0, "$resources array not empty");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	delete context.pdfReport;
	// context.pdfReport = {
	// 	debug: {
	// 		output: {
	// 			pdf: "pdf_report.pdf",
	// 			data: "pdf_data.json",
	// 			proto: "pdf_proto.json",
	// 		}
	// 	}
	// };
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

function getCookie(_, login, pass) {
	var response = new streams.httpRequest({
		url: baseUrl + "/syracuse-main/html/main.html",
		user: login || "guest",
		password: pass || "guest"
	}).end().response(_);
	response.readAll(_);
	strictEqual(response.statusCode, 200, "user authenticated");
	return response.headers["set-cookie"];
}

var current = {};

function _load(name, _) {
	current[name] = current[name] || {
		proto: JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_proto.json", 'utf8', _)),
		data: JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_data.json", 'utf8', _))
	};

	return current[name];
}

function _loadArticle(name, _) {
	return JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_article.json", 'utf8', _));
}

function _writePdf(pdf, name, _) {
	var path = __dirname + "/output";
	// var exists = fs.exists(path, _);
	try {
		var stats = fs.stat(path, _);
	} catch (e) {
		if (e.code === 'ENOENT') fs.mkdir(path, undefined, _);
	}
	fs.writeFile(path + "/" + name + ".pdf", pdf, 'binary', _);
}

function LayoutBuilder() {
	this.items = [];
	this.layout = {
		$layout: {
			$items: this.items
		}
	};
};

exports.LayoutBuilder = helpers.defineClass(LayoutBuilder, null, {
	appendSection: function(items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$category: "section",
			$layout: {
				$items: this.items
			}
		});
		return this;
	},
	appendLayout: function(layoutType, layoutSubType, items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$layoutType: layoutType,
			$layoutSubType: layoutSubType,
			$items: this.items
		});
		return this;
	},
	appendBlock: function(title, items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$title: title,
			$category: "block",
			$layout: {
				$items: this.items
			}
		});
		return this;
	},
	addProperty: function(bind, options, items) {
		items = items || this.items;
		var prop = options || {};
		prop.$bind = bind;
		items.push(prop);
		return this;
	},
});

function Aspect() {};

var Aspect = helpers.defineClass(Aspect, null, {
	before: function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				aspect.apply(this, [{
					pointCut: "before",
					name: k
				},
				Array.prototype.slice.call(arguments)]);
				return old.apply(this, arguments);
			};
		});
	},
	after: function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				var res = old.apply(this, arguments);
				aspect.apply(this, [{
					pointCut: "after",
					name: k
				},
				Array.prototype.slice.call(arguments)], res);
				return res;
			};
		});
	},
	around: function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				var args = Array.prototype.slice.call(arguments);
				aspect.apply(this, [{
					pointCut: "before",
					name: k
				},
				args]);
				var res = old.apply(this, arguments);
				aspect.apply(this, [{
					pointCut: "after",
					name: k
				},
				args, res]);
				return res;
			};
		});
	},
	_setPointCut: function(obj, funcs, aspect, pointCut) {
		if (!this._isFunction(aspect)) return;
		if (typeof(funcs) === "string") funcs = [funcs];
		var proto = obj.prototype;
		for (var k in proto) {
			if (k === "toString") continue;
			var old = proto[k];
			if (!old || !this._isFunction(old)) continue;

			var injectIt = funcs.some(function(e) {
				return (k.search(e) != -1);
			});

			if (injectIt) proto[k] = pointCut(k, old);
		}
	},
	_isFunction: function(obj) {
		return !!(obj && obj.constructor && obj.call && obj.apply);
	}
});

function _inject() {
	var PdfDocument = require('streamline-pdfkit');
	var aspect = new Aspect();
	aspect.around(PdfDocument, ["roundedRect", "text", "fillColor", "lineWidth", "widthOfString", "currentLineHeight"], function(
	context, args, result) {
		if (context.pointCut === "before") {
			tracer("before " + context.name + " [" + args + "]");
		} else {
			tracer("after " + context.name + " ==> " + result);
		}
	});
}