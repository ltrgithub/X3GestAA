"use strict";

var module = QUnit.module;
var baseUrl = "http://localhost:8124"
// var baseUrl = "http://localhost:3004"
// var port = 3004;
var fs = require('fs');

var helpers = require('syracuse-core/lib/helpers');
var types = require('syracuse-core/lib/types/allTypes');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var pdfRenderer = require('syracuse-sdata/lib/render/pdf');
var sys = require("util");
var forEachKey = helpers.object.forEachKey;

var pdfDebug = config.pdfReport.debug;

// var tracer = console.log;
var tracer = (function() {
	var _fd;
	return function(s) {
		_fd = fs.openSync("pdfTest.log", _fd == null ? "w" : "a");
		fs.writeSync(_fd, s + "\n");
		fs.closeSync(_fd);
	}
})();

//var tracer = null;
module("pdfTest", {
	setup: function() {
		// tracer("pdfTest setup");
		// _inject();
	},
	teardown: function() {
		// tracer("pdfTest teardown");
	}
});

var roundedRectCalled;


var context = {
	request: {
		headers: {
			referer: ''
		},
		httpSession: {
			cookie: ''
		}
	}
};

asyncTest("simple user", 4, function(_) {
	var name = "user_simple",
		rep = _load("user", _);
	// var builder = new LayoutBuilder();
	// builder.addSection().addLayout("columns", "50,50").addBlock
	rep.proto.$article = _loadArticle(name, _);
	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);
	start();
});

asyncTest("full user", 4, function(_) {
	var name = "user_full",
		rep = _load("user", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);

	start();
});

asyncTest("2 pages full user", 4, function(_) {
	var name = "2_pages_user_full",
		rep = _load("user", _);
	rep.proto.$article = _loadArticle(name, _);

	ok(rep.data != null, "data not null");
	equal(rep.data.login, "erbou", "login ok");
	ok(rep.proto != null, "proto not null");
	equal(rep.proto.$type, "application/json", "proto $type is application/json");
	var pdf = pdfRenderer.render(_, context, rep.data, rep.proto);
	_writePdf(pdf, name, _);
	
	start();
});

var current = {};

function _load(name, _) {
	current[name] = current[name] || {
		proto: JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_proto.json", 'utf8', _)),
		data: JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_data.json", 'utf8', _))
	};

	return current[name];
}

function _loadArticle(name, _) {
	return JSON.parse(fs.readFile(__dirname + "/resources/" + name + "_article.json", 'utf8', _));
}

function _writePdf(pdf, name, _) {
	var path = __dirname + "/output/";
	// var e = fs.exists(path, _);
	var stats = fs.stat(path, _);
	if (!stats.isDirectory()) {
		fs.mkdir(path, undefined, _);
	}
	fs.writeFile(path + name + ".pdf", pdf, 'binary', _);
}

function LayoutBuilder() {
	this.items = [];
	this.layout = {
		$layout: {
			$items: this.items
		}
	};
};

exports.LayoutBuilder = helpers.defineClass(LayoutBuilder, null, {
	appendSection: function(items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$category: "section",
			$layout: {
				$items: this.items
			}
		});
		return this;
	},
	appendLayout: function(layoutType, layoutSubType, items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$layoutType: layoutType,
			$layoutSubType: layoutSubType,
			$items: this.items
		});
		return this;
	},
	appendBlock: function(title, items) {
		items = items || this.items;
		this.items = [];
		items.push({
			$title: title,
			$category: "block",
			$layout: {
				$items: this.items
			}
		});
		return this;
	},
	addProperty: function(bind, options, items) {
		items = items || this.items;
		var prop = options || {};
		prop.$bind = bind;
		items.push(prop);
		return this;
	},
});

function Aspect() {};

var Aspect = helpers.defineClass(Aspect, null, {
	before: function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				aspect.apply(this, [{
					pointCut: "before",
					name: k
				},
				Array.prototype.slice.call(arguments)]);
				return old.apply(this, arguments);
			};
		});
	},
	after: function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				var res = old.apply(this, arguments);
				aspect.apply(this, [{
					pointCut: "after",
					name: k
				},
				Array.prototype.slice.call(arguments)], res);
				return res;
			};
		});
	},
	around: function(obj, funcs, aspect) {
		this._setPointCut(obj, funcs, aspect, function(k, old) {
			return function() {
				var args = Array.prototype.slice.call(arguments);
				aspect.apply(this, [{
					pointCut: "before",
					name: k
				},
				args]);
				var res = old.apply(this, arguments);
				aspect.apply(this, [{
					pointCut: "after",
					name: k
				},
				args, res]);
				return res;
			};
		});
	},
	_setPointCut: function(obj, funcs, aspect, pointCut) {
		if (!this._isFunction(aspect)) return;
		if (typeof(funcs) === "string") funcs = [funcs];
		var proto = obj.prototype;
		for (var k in proto) {
			if (k === "toString") continue;
			var old = proto[k];
			if (!old || !this._isFunction(old)) continue;

			var injectIt = funcs.some(function(e) {
				return (k.search(e) != -1);
			});

			if (injectIt) proto[k] = pointCut(k, old);
		}
	},
	_isFunction: function(obj) {
		return !!(obj && obj.constructor && obj.call && obj.apply);
	}
});

function _inject() {
	var PdfDocument = require('streamline-pdfkit');
	var aspect = new Aspect();
	aspect.around(PdfDocument, ["roundedRect", "text", "fillColor", "lineWidth", "widthOfString", "currentLineHeight"], function(context, args, result) {
		if (context.pointCut === "before") {
			tracer("before " + context.name + " [" + args + "]");
		} else {
			tracer("after " + context.name + " ==> " + result);
		}
	});
}