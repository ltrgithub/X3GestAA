"use strict";

var fs = require('streamline-fs'),
	path = require('path'),
	program = require('commander');

var config = require('../index').config;
if (!config.etna) throw new Error("config.etna missing");
var tmpRoot = config.etna.tmpRoot || path.resolve(__dirname, '../../../tmp/METADATA');

var t0 = Date.now();
var trace = config.etna.trace;
var entities = [],
	texts = [];

function getResource(_, folder) {
	var resPath = path.join(__dirname, folder);
	if (program.test) {
		return fs.exists(path.join(resPath, program.test + "._js"), _) ? [require(path.join(resPath, program.test))] : [];
	} else {
		return fs.readdir(resPath, _).map_(_, function(_, filename) {
			return (/(.*)\.(_js)/).test(filename) ? require(path.join(resPath, filename)) : null;
		}).filter(function(file) {
			return file !== null;
		});
	}
}

function exportMetadata(_) {
	var exporter = require("etna-etl/lib/exporter").newExporter({
		db: config.etna.SUPERV.x3SqlStore,
		trace: config.etna.trace,
		dir: tmpRoot + "/METADATA",
		force: true, // for now!
		parallel: 1,
	});

	if (!program.test || program.clean) exporter.clean(_);
	exporter.init(_);

	var entityExporter = require("etna-etl/lib/export-entity");
	entities = getResource(_, "entities");
	entities.forEach_(_, function(_, entityResource) {
		entityExporter.run(_, exporter, entityResource.entity);
	});

	var textExporter = require("etna-etl/lib/export-text");
	texts = getResource(_, "texts");
	texts.forEach_(_, function(_, textResource) {
		textExporter.run(_, exporter, textResource.text);
	});
}

function importMetadata(_) {
	var importer = require("etna-etl/lib/importer").newImporter({
		store: "mongo",
		trace: config.etna.trace,
		dir: tmpRoot + "/METADATA",
	});
	var store = importer(_).open(_);
	if (!program.test) store.createTables(_);
	entities = getResource(_, "/entities/");
	entities.forEach_(_, function(_, entityResource) {
		store.fillTables(_, entityResource.entity);
	});
	store.fillTexts(_);
}

function initData(_) {
	var importer = require("etna-etl/lib/importer").newImporter({
		store: "oracle",
		trace: config.etna.trace,
		dir: tmpRoot + "/METADATA",
	});
	var store = importer(_).open(_);
	store.createTables(_);
}

function exportData(_) {
	require("etna-etl/lib/sqldump").exportAll(_);
}

function importData(_) {
	require("etna-etl/lib/sqldump").importAll(_);
}

// parse command line input via commander
program
	.version("0.1.0", '-v, --version')
	.option('-a, --all', 'perform all steps')
	.option('-e, --exportMeta', 'export metadata from source sql database')
	.option('-i, --importMeta', 'import metadata into mongodb')
	.option('-E, --exportData', 'export data from source sql database')
	.option('-Z, --initData', 'initialize tables in destination oracle database')
	.option('-I, --importData', 'import data into destination oracle database')
	.option('-c, --clean', 'clean output directory')
	.option('-t, --test <test>', 'test single entity or text')
	.option('-g, --git', 'git repo commit')
	.option('-j, --jsgit', 'git repo commit via jsgit')
	.option('-n, --nodegit', 'git repo commit via nodegit')
	.parse(process.argv);

var gitR = program.git ? "nodegit" : program.jsgit ? "jsgit" : program.nodegit ? "nodegit" : null;

if (program.exportMeta || program.all) exportMetadata(_);
if (program.importMeta || program.all) importMetadata(_);
if (program.exportData || program.all) exportData(_);
if (program.initData || program.all) initData(_);
if (program.importData || program.all) importData(_);

if (gitR) {
	var git = require("etna-etl/lib/" + gitR).newGit(config.etna);
	git.gitify(_);
}

trace && trace("execution completed in " + Math.round((Date.now() - t0) / 1000) + " seconds");
