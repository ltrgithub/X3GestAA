"use strict";

//var defaultExcludedColumns = ["AUUID", "UPDDAT", "UPDUSR", "UPDDATTIM", "CREDAT", "CREUSR", "CREDATTIM", "UPDTICK"];
var defaultExcludedColumns = ["AUUID"];



exports.run = function(_, exporter, entity, tracker, entityNames) {

	function queryTable(_, tableMeta, elt, textLinks, orderBy, where) {
		var cols = [];
		Object.keys(tableMeta.columns).forEach(function(colName) {
			var colDef = tableMeta.columns[colName];
			for (var i = 0; i < colDef.dimension; i++) {
				cols.push(colDef.name + "_" + i);
			};
		});
		var results = buildExecute(_, tableMeta, cols, tableMeta.name, orderBy, elt, where, textLinks);
		return results;

	}

	if (entity.tableName === "AENTREE") return [];
	var t0 = Date.now();
	var buildExecute = exporter.buildExecute,
		trace = exporter.trace;

	var excludedColumns = entity.excludedColumns || defaultExcludedColumns;
	var tableMeta = exporter.getTableMeta(_, entity.tableName, excludedColumns);
	// var mainColumns = exporter.getTableColumns(_, entity.tableName, excludedColumns);
	var mainKey = entity.primaryKey;

	var childrenMetas = {};
	Object.keys(entity.children).forEach_(_, function(_, childName) {
		var child = entity.children[childName];
		// The child tables have the same excluded columns as their main table except when 
		// specific columns are described
		var excludedChildColumns = child.excludedColumns || excludedColumns;
		childrenMetas[childName] = exporter.getTableMeta(_, child.tableName, excludedChildColumns);
	});

	trace && trace(entity.title + ": loading list : " + childrenMetas);

	var elts = buildExecute(_, null, mainKey, entity.tableName, mainKey).filter(function(s) {
		if (entityNames) {
			if (entityNames.indexOf(s[mainKey]) == -1)
				return false;
		}
		return !~entity.excludedInitials.indexOf(s[mainKey][0]);
	});

	var filenames = [];
	elts.forEach_(_, exporter.config.parallel || 4, function(_, elt, i) {
		if (tracker && tracker.abortRequested) return;
		var phaseDetail = "Exporting " + entity.title + " : " + exporter.objVals(_, elt);
		if (tracker)
			tracker.phaseDetail = phaseDetail;
		trace && trace((i + 1) + "/" + elts.length + ": " + phaseDetail);
		var data = queryTable(_, tableMeta, elt, entity.textLinks)[0];
		//		var data = buildExecute(_, context, tableMeta, entity.tableName, null, elt, null, entity.textLinks)[0];

		Object.keys(entity.children).forEach_(_, function(_, childName) {
			var child = entity.children[childName];
			data[childName] = queryTable(_, childrenMetas[childName], elt, child.textLinks, child.orderBy, child.parentKey || mainKey);
			// data[childName] = buildExecute(_, context, childrenCols[childName], child.tableName, child.orderBy, elt, child.parentKey || mainKey, child.textLinks);
		});
		var modulePart;
		if (exporter.folderType == 0)
			modulePart = "SUPERV";
		else if (exporter.moduleNames[data.MODULE])
			modulePart = exporter.moduleNames[data.MODULE];
		else if (data.CHAPITRE) {
			var chapter = data.CHAPITRE;
			var idx = chapter.indexOf('|');
			if (idx != -1)
				chapter = chapter.substring(idx + 1);
			modulePart = "CHAPTERS/" + chapter;
		} else
			modulePart = "GLOBAL";
		filenames.push(exporter.writeResource(_, {
			path: modulePart + "/" + entity.subdir,
			name: elt[mainKey],
			data: data
		}));

	});

	trace && trace(entity.title + ": " + elts.length + " resources exported in " + Math.round((Date.now() - t0) / 1000) + " seconds");
	return filenames;
};

exports.extractSingle = function(_, exporter, entity, entityTableName) {
	var buildExecute = exporter.buildExecute;

	// Retrieve the columns name of the table (except the excluded ones)
	var mainColumns = exporter.getTableColumns(_, entity.tableName, entity.excludedColumns || defaultExcludedColumns);
	var mainKey = entity.primaryKey;

	return {
		mainKey: mainKey,
		mainKeyValue: entityTableName,
		tableName: entity.tableName,
		data: buildExecute(_, null, mainColumns, entity.tableName, null, {
			'CODFIC': entityTableName
		})[0]
	};
};