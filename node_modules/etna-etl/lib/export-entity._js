"use strict";

var jsonHelper = require('bundles/scm-helper/lib/jsonHelper');


//var defaultExcludedColumns = ["AUUID", "UPDDAT", "UPDUSR", "UPDDATTIM", "CREDAT", "CREUSR", "CREDATTIM", "UPDTICK"];
var defaultExcludedColumns = ["AUUID"];




/// !doc 
/// ### run(_, exporter, entity, tracker, entityNames)
/// Exports the metadata of a set of entities into JSON files
/// This function returns the names of the generated files. 
/// WARNING : The filenames are RELATIVE to the solution.metaFolder
///
/// * exporter : the exporter that will be used to serialize the metadata into JSON files
/// * entity : the entity descriptor
/// * tracker : the tracker
/// * entityNames : the name of the entities
exports.run = function(_, exporter, entity, tracker, entityNames) {

	var tableMetas = {};

	if (entity.tableName === "AENTREE") return [];
	var t0 = Date.now();
	var buildExecute = exporter.buildExecute,
		trace = exporter.trace;

	var excludedColumns = entity.excludedColumns || defaultExcludedColumns;
	var tableMeta = getTableMeta(_, entity.tableName, excludedColumns);
	var mainKey = entity.primaryKey;

	// First, we have to filter the entities, according to the provided filter
	var elts = buildExecute(_, null, mainKey, entity.tableName, mainKey).filter(function(s) {
		if (entityNames) {
			if (entityNames.indexOf(s[mainKey]) == -1) {
				// This entity was not included in the provided filter
				return false;
			}
		}
		return !~entity.excludedInitials.indexOf(s[mainKey][0]);
	});

	var relativeFilenames = [];

	function getTableMeta(_, tableName, excludedColumns) {
		var tableMeta = tableMetas[tableName];
		if (!tableMeta) {
			tableMeta = exporter.getTableMeta(_, tableName, excludedColumns);
			tableMetas[tableName] = tableMeta;
		}
		return tableMeta;
	}

	function queryTable(_, tableMeta, keys, entityDescriptor, parentDescriptor, options) {
		options = options || {};
		entityDescriptor = entityDescriptor || {};
		entityDescriptor.activityCodeProperty = entityDescriptor.activityCodeProperty || "CODACT";

		if (entityDescriptor && entityDescriptor.linkTable && !options.skipLinkTable) {
			// We have to use the pivot table to retrieve rows
			if (!parentDescriptor)
				throw new Error("Parent descriptor is missing");
			var pivotKeys = {};
			pivotKeys[parentDescriptor.primaryKey] = keys[parentDescriptor.primaryKey];
			var pivots = queryTable(_, getTableMeta(_, entityDescriptor.linkTable.tableName), pivotKeys, null, null, {
				formatValues: false
			});
			var allResults = [];
			// Now, we iterate on each pivot and query the child table

			// We assume that linked entities all belong to the activity code ""
			pivots = pivots[""] || [];
			pivots.forEach_(_, function(_, pivot) {
				var targetKey = {};
				var parentColumn = entityDescriptor.parentKey || parentDescriptor.primaryKey;
				targetKey[parentColumn] = pivot[parentColumn];
				var partialResults = queryTable(_, tableMeta, targetKey, entityDescriptor, parentDescriptor, {
					skipLinkTable: true,
					formatValues: true
				})[""];
				allResults = allResults.concat(partialResults);
			});
			return {
				"": allResults
			};
		}

		var cols = [];
		Object.keys(tableMeta.columns).forEach(function(colName) {
			var colDef = tableMeta.columns[colName];
			for (var i = 0; i < colDef.dimension; i++) {
				cols.push(colDef.name + "_" + i);
			};
		});
		var where = entityDescriptor.parentKey;
		if (!where && parentDescriptor)
			where = parentDescriptor.primaryKey;
		var sqlResults = buildExecute(_, tableMeta, cols, tableMeta.name, entityDescriptor.orderBy, keys, where, entityDescriptor.textLinks, options);
		// Now, we have to dispatch all the results by activity code
		var results = {};
		sqlResults.forEach(function(row) {
			var activityCode = row[entityDescriptor.activityCodeProperty];
			if (!activityCode)
				activityCode = "";
			else {
				// The activityCode is a string that has already been formatted like "S:xx|activityCode"
				// We have to unformat it.
				activityCode = activityCode.substring(activityCode.indexOf('|') + 1).trim();
			}

			results[activityCode] = results[activityCode] || [];
			results[activityCode].push(row);
		});
		return results;
	}

	elts.forEach_(_, exporter.config.parallel || 4, function(_, elt, i) {
		if (tracker && tracker.abortRequested) return;
		var phaseDetail = "Exporting " + entity.title + " : " + exporter.objVals(_, elt);
		if (tracker)
			tracker.phaseDetail = phaseDetail;
		trace && trace((i + 1) + "/" + elts.length + ": " + phaseDetail);

		// Read the data for the entity itself
		var data = queryTable(_, tableMeta, elt, entity, null, {
			formatValues: true
		});
		Object.keys(data).forEach(function(key) {
			// Note : there's only on item in the array as we are on the main entity
			data[key] = data[key][0];
		});

		if (entity.children) {
			// This entity has some child entities (for instance columns or indexes for tables)
			Object.keys(entity.children).forEach_(_, function(_, childName) {
				var child = entity.children[childName];
				// The child tables have the same excluded columns as their main table except when specific columns are described
				var childTableMeta = getTableMeta(_, child.tableName, child.excludedColumns || excludedColumns);
				var subResults = queryTable(_, childTableMeta, elt, child, entity, {
					formatValues: true
				});
				// note : subResults are indexed by activityCode
				Object.keys(subResults).forEach(function(key) {
					data[key] = data[key] || {};
					data[key][childName] = subResults[key];
				});
			});
		}

		var modulePart;
		var mainData = data[""]; // The data for no activityCode (i.e. the data that contains all the common properties)
		if (!mainData) {
			// use the first activity code
			mainData = data[Object.keys(data)[0]];
		}
		if (exporter.folderType == 0)
			modulePart = "SUPERV";
		else if (exporter.moduleNames[mainData.MODULE])
			modulePart = exporter.moduleNames[mainData.MODULE];
		else if (mainData.CHAPITRE) {
			var chapter = mainData.CHAPITRE;
			var idx = chapter.indexOf('|');
			if (idx != -1)
				chapter = chapter.substring(idx + 1);
			modulePart = "CHAPTERS/" + chapter;
		} else
			modulePart = "GLOBAL";

		Object.keys(data).forEach_(_, function(_, activityCode) {
			var dataPart = data[activityCode];
			if (activityCode) {
				// This data concerns a specific activity code
				// We have to insert the PK of the main data
				dataPart[mainKey] = mainData[mainKey];
			}

			// We have to re-sort the JSON object to avoid git differences
			// When a conflict will be detected on this JSON object, the conflict will be resolved and the JSON
			// will be sorted with jsonHelper.sortJsonObject() function. So, the original JSON file (the one we are building now)
			// must be sorted with the same function to limit git differences.
			dataPart = jsonHelper.sortJsonObject(_, dataPart, entity);

			// Now, we can write the file
			relativeFilenames.push(exporter.writeResource(_, {
				path: modulePart + "/" + entity.subdir,
				name: elt[mainKey] + (activityCode ? "." + activityCode : ""),
				data: dataPart
			}));

		});
	});

	trace && trace(entity.title + ": " + elts.length + " resources exported in " + Math.round((Date.now() - t0) / 1000) + " seconds");
	return relativeFilenames;
};

exports.extractSingle = function(_, exporter, entity, entityTableName) {
	var buildExecute = exporter.buildExecute;

	// Retrieve the columns name of the table (except the excluded ones)
	var mainColumns = exporter.getTableColumns(_, entity.tableName, entity.excludedColumns || defaultExcludedColumns);
	var mainKey = entity.primaryKey;

	return {
		mainKey: mainKey,
		mainKeyValue: entityTableName,
		tableName: entity.tableName,
		data: buildExecute(_, null, mainColumns, entity.tableName, null, {
			'CODFIC': entityTableName
		})[0]
	};
};