import { _ } from 'streamline-runtime';
import * as fs from 'fs';
import * as path from 'path';
import * as mongodb from 'mongodb';
import { ExporterConfig, Dict, Tracker, Descriptor, FileStruct, ResourceManager } from './exporter';

var locale = require('streamline-locale'),
	datetime = require('@sage/syracuse-core').types.datetime,
	jsonHelper = require('scm-lib/jsonHelper');

export function newImporter(_: _, resourceManager : ResourceManager, config: ExporterConfig) {
	var trace = config.trace;
	var jsondir = config.metaFolder;
	var mongoConfig = config.mongo || {};
	var mgConf = mongoConfig;
	var dbUrl = "mongodb://" + (mgConf.connectionString || ((mgConf.host || "localhost") + ":" + (mgConf.port || 27017))) + "/" + (mgConf.database || "x3meta");

	trace && trace(locale.format(module, "importToMongoWithUrl", dbUrl));
	var db = mongodb.MongoClient.connect(dbUrl, mgConf.options as mongodb.MongoClientOptions || {
		db: {
			w: 1
		}
	}).then(_, _);

	// files[xxx] contains only ABSOLUTE filenames
	var files: any = {
		/*		
		TEXTS: [],
		MENUS: []
*/
	};

	buildFilesList(_);

	function buildFilesList(_: _) {
		// Note : config.fileStructs is a list of {status:xxx, absoluteFilename : xxx}
		if (config.fileStructs) {
			config.fileStructs.forEach(function (fileStruct) {
				var result = jsonHelper.parseMetaFilename(fileStruct.absoluteFilename);
				files[result.type] = files[result.type] || [];
				files[result.type].push(fileStruct);
			});
			return;
		}

		// No fileStruct are provided, we have to parse jsondir to retrieve all the available metadata files
		fs.readdir(jsondir, _).forEach_(_, function (_, module) {
			var moduleDir = path.join(jsondir, module);
			if (fs.stat(moduleDir, _).isDirectory()) {
				fs.readdir(moduleDir, _).forEach_(_, function (_, type) {
					var typeDir = path.join(moduleDir, type);
					if (fs.stat(typeDir, _).isDirectory()) {
						var entries = fs.readdir(typeDir, _);

						entries.filter(function (name) {
							return (/\.(json|delete)$/).test(name);
						}).forEach_(_, function (_, name) {
							files[type] = files[type] || [];
							files[type].push({
								status: 'added',
								absoluteFilename: path.join(typeDir, name)
							});
						});

						entries.filter(function (name) {
							return (/^\w\w\w$/).test(name);
						}).forEach_(_, function (_, lan) {
							fs.readdir(typeDir + "/" + lan, _).filter(function (name) {
								return (/\.(json|delete)$/).test(name);
							}).forEach_(_, function (_, name) {
								var dest = type === "MENUS" ? files.MENUS : files.TEXTS;
								var absoluteFilename = path.join(jsondir, module, type, lan, name);
								dest.push({
									status: 'added',
									absoluteFilename: absoluteFilename,
								});
							});
						});
					}
				});
			}
		});

	}

	return {
		open: function (_: _) {
			//db.open(_);
			return this;
		},
		updateCollection: function (_: _, entity: Descriptor, tracker: Tracker, dropCollectionBeforeImport: boolean) {

			function addDiagnose(message: string, severity?: string) {
				if (!tracker) {
					return;
				}
				tracker.$diagnoses = tracker.$diagnoses || [];
				tracker.$diagnoses.push({
					$severity: severity || "info",
					$message: message,
				});
			}

			trace && trace(locale.format(module, "insertMetadaWithType", entity.title));
			var t0 = Date.now();
			var coln = db.collection(entity.tableName);

			if (dropCollectionBeforeImport) {
				addDiagnose(locale.format(module, "fullSyncDropCollection", entity.tableName));
				coln.drop();
			}

			// Note: fileStructs is a list of {status:xxx, absoluteFilename : xxx}
			var fileStructs: FileStruct[] = files[entity.subdir] || [];

			var importedFilesCount = 0;
			var etag = datetime.now().toString();

			fileStructs.forEach_(_, function (_, fileStruct, i) {
				if (tracker && tracker.abortRequested) {
					return;
				}

				var msg = locale.format(module, "importJSONWithCount", entity.title, i + 1, fileStructs.length, fileStruct.absoluteFilename, fileStruct.status);
				//addDiagnose(msg);
				trace && trace(msg);

				importedFilesCount++;
				switch (fileStruct.status) {
					case 'deleted':
						const entityName = path.basename(fileStruct.absoluteFilename, '.json').substring(1).toUpperCase();
						if (fs.exists(fileStruct.absoluteFilename, _, _)) {
							trace && trace("delete resource:" + fileStruct.absoluteFilename);
							try {
								fs.unlink(fileStruct.absoluteFilename, _);
							} catch (err) {
								let msg = "Could not delete file '" + fileStruct.absoluteFilename + "', reason = " + err.message;
								if (tracker)
									addDiagnose(msg, 'warning');
								trace && trace(msg);
							}
						}
						else {
							trace && trace("deletion of resource skipped (does not exist) :" + fileStruct.absoluteFilename);
						}
						const key = entityName.split('~').reduce(function (r, e, i) {
							r[entity.primaryKey[i]] = e;
							return r;
						}, {} as any);
						trace && trace("remove " + JSON.stringify(key) + " from mongo collection " + entity.tableName);
						coln.remove(key).then(_, _);
						break;
					case 'added':
					case 'updated':
						var data: any;
						try {
							data = jsonHelper.readJsonFile(_, resourceManager, fileStruct.absoluteFilename, entity, {
								dontCreateEmptyLines: true
							});
							data = jsonHelper.decodeObject(data);
						} catch (err) {
							var msg = locale.format(module, "importJSONError", fileStruct.absoluteFilename, err.message);
							trace && trace(msg);
							addDiagnose(msg, "error");
							console.error(msg);
							return;
						}
						var filter = (entity.primaryKey as string[]).reduce(function (total, item) {
							total[item] = data[item];
							return total;
						}, {} as any);

						data._etag = etag;
						coln.update(filter, data, {
							upsert: true
						}).then(_, _);
						break;
					default:
						throw new Error("Unhandled status (" + fileStruct.status + ") for file " + fileStruct.absoluteFilename);
				}

			});

			if (tracker && tracker.abortRequested) {
				return;
			}
			trace && trace(locale.format(module, "importDone", entity.title, fileStructs.length, Math.round((Date.now() - t0) / 1000)));

			var msg = locale.format(module, "createUniqueIndex", entity.title, entity.primaryKey);
			addDiagnose(msg);
			trace & trace(msg);
			var keys = (entity.primaryKey as string[]).reduce(function (global, item) {
				global[item] = 1;
				return global;
			}, {} as any);
			coln.ensureIndex(keys, {
				unique: true
			}).then(_, _);
			return importedFilesCount;
		},
	};
};