"use strict";

var mongodb = require('mongodb'),
	supervisor = require("etna-supervisor/lib/supervisor"),
	resourceManager = require('bundles/scm-helper/lib/resourceManager');

exports.newIncrementalSync = function(config, tracker) {

	config.trace = config.trace || console.log;

	var trace = config.trace;

	function _trace(message, severity) {
		trace && trace(message);
		if (severity) {
			if (tracker)
				(tracker.$diagnoses = tracker.$diagnoses || []).push({
					severity: severity,
					message: message,
				});
		}
	}

	function trim(obj) {
		var result = Object.keys(obj).reduce(function(o, k) {
			var v = obj[k];
			if (v instanceof Date) {
				v = v.toISOString();
				if (/T00\:00\:00\.000Z$/.test(v)) {
					v = v.substring(0, v.length - 14);
					if (v === '1599-12-31') v = null;
				}
			}
			if (/^CAST\(AUUID_0/.test(k)) k = "AUUID_0";
			var lastIndex = k.lastIndexOf('_');
			if (lastIndex == -1) {
				// Skip this column : not use directly by X3 (sth like ROWID)
			} else {
				var kk = k.substring(0, lastIndex);
				var isArray = (obj[kk + '_1'] !== undefined);
				if (isArray) {
					o[kk] = o[kk] || [];
					o[kk].push(v);
				} else {
					if (v && v !== ' ') o[kk] = v;
				}
			}
			return o;
		}, {});
		Object.keys(result).forEach(function(k) {
			var v = result[k];
			if (Array.isArray(v)) {
				var len = v.length;
				while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
				result[k] = v.slice(0, len);
			}
		});
		return result;
	}

	function syncType(_, itemHandler, options) {
		_trace("Synchronize Mongo collection '" + itemHandler.mongo.colName + "'");
		var superv = supervisor.create(_, config);

		options = options || {};
		var mongoConfig = config.mongo || {};
		var mongoServer = new mongodb.Server(mongoConfig.host || "localhost", mongoConfig.port || 27017, {});
		var mongoDb = new mongodb.Db(mongoConfig.database || "x3meta", mongoServer, {
			w: 1 //"majority"
		});
		mongoDb.open(_);
		var settingsColn = mongoDb.collection("user_settings", _);
		var dataColn = mongoDb.collection(itemHandler.mongo.colName, _);
		console.log(mongoConfig);
		var lastSyncFilter = {
			type: itemHandler.mongo.syncDocType,
		};
		var lastSync = settingsColn.find(lastSyncFilter, _).toArray(_)[0];
		var fullSync = options.fullSync;

		if (!lastSync) {
			// First sync : full sync
			fullSync = true;
		}

		// Note: fullSync is 'on' if no previous sync date could be found or if set in options
		var lastSyncDateFilters = null;

		if (fullSync) {
			// Full sync
			// Droping the collection instead of just removing all its docs ensures that any obsolete indexes
			// will be removed as well.
			try {
				dataColn.drop(_);
			} catch (err) {
				// Nothing to do, the collection may not exist
			}
			_trace("Full synchronization : the mongoDb collection has been dropped.");
		} else {
			// Incremental sync. We only process update / insert (remove are ignored, for now)
			var lastSyncDate = new Date(Date.parse(lastSync.date));
			_trace("Incremental synchronization : will only process changes from " + lastSyncDate);
			lastSyncDateFilters = [{
				key: itemHandler.sql.dateColName,
				operator: '>',
				value: lastSyncDate
			}];
		}
		var count = 0;
		var tableDef = superv.sqlDriver.getTableDef(_, superv.folderName, itemHandler.sql.tableName);
		var tableReader = superv.sqlDriver.createTableReader(_, tableDef, lastSyncDateFilters);
		// if (lastSyncDateFilters != null)
		// 	tableReader = tableReader.filter(lastSyncDateFilters);

		tableReader.forEach(_, function(_, row) {
			count++;
			var filter = {};
			itemHandler.mongo.distinctKeys.forEach(function(key) {
				filter[key] = row[key + '_0'];
			});
			if ((count % 100) == 0)
				_trace("Processed " + count + ", last = " + JSON.stringify(filter), "info");

			var data = trim(row);

			try {
				if (fullSync)
					dataColn.insert(data, _);
				else {
					dataColn.update(filter, data, {
						upsert: true
					}, _);
				}
			} catch (e) {
				console.error("tableReader:" + e);
			}
		});

		_trace("Processed " + count + " records");

		// Now, create the indexes

		// We always create an index, based on the distinct keys
		var distinctIndex = {
			unique: true,
			keys: itemHandler.mongo.distinctKeys
		};

		if (options.skipIndexes) {
			_trace("Creation of indexes skipped by options.");
		} else {
			var indexesToCreate = [distinctIndex].concat(itemHandler.mongo.extraIndexes);
			indexesToCreate.forEach_(_, function(_, index) {
				var idxKeys = {};
				var idxOptions = {};
				index.keys.forEach(function(colName) {
					idxKeys[colName] = 1;
				});
				if (index.unique)
					idxOptions["unique"] = true;
				dataColn.ensureIndex(idxKeys, idxOptions, _);
				_trace("Index " + JSON.stringify(idxKeys) + " created (unique = " + index.unique + ")");
			});
		}

		// End of process, store the current date (for later incremental updates)
		settingsColn.update(lastSyncFilter, {
			type: lastSyncFilter.type,
			date: new Date(),
		}, {
			upsert: true
		}, _);

	};
	return {
		syncText: function(_, textType, options) {
			var textDescriptor = resourceManager.getTextDescriptor(_, textType).text;
			return syncType(_, textDescriptor, options);
		},
	};

};