"use strict";

var locale = require('streamline-locale'),
	mongodb = require('mongodb'),
	supervisor = require("etna/lib/supervisor/supervisor"),
	resourceManager = require('scm-lib/resourceManager');

exports.newIncrementalSync = function(config, tracker) {

	config.trace = config.trace || console.log;

	var trace = config.trace;

	function _trace(message, severity) {
		trace && trace(message);
		if (severity) {
			if (tracker) {
				tracker.$diagnoses = tracker.$diagnoses || [];
				tracker.$diagnoses.push({
					$severity: severity,
					$message: message,
				});
			}
		}
	}

	function trim(obj) {
		var result = Object.keys(obj).reduce(function(o, k) {
			var v = obj[k];
			if (v instanceof Date) {
				v = v.toISOString();
				if (/T00\:00\:00\.000Z$/.test(v)) {
					v = v.substring(0, v.length - 14);
					if (v === '1599-12-31') v = null;
				}
			}
			if (/^CAST\(AUUID_0/.test(k)) k = "AUUID_0";
			var lastIndex = k.lastIndexOf('_');
			if (lastIndex == -1) {
				// Skip this column : not use directly by X3 (sth like ROWID)
			} else {
				var kk = k.substring(0, lastIndex);
				var isArray = (obj[kk + '_1'] !== undefined);
				if (isArray) {
					o[kk] = o[kk] || [];
					o[kk].push(v);
				} else {
					if (v && v !== ' ') o[kk] = v;
				}
			}
			return o;
		}, {});
		Object.keys(result).forEach(function(k) {
			var v = result[k];
			if (Array.isArray(v)) {
				var len = v.length;
				while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
				result[k] = v.slice(0, len);
			}
		});
		return result;
	}

	function syncType(_, itemHandler, options) {
		_trace(locale.format(module, "syncMongoCollection", itemHandler.mongo.colName), "info");
		var t0 = Date.now();
		var superv = supervisor.create(_, config);

		options = options || {};
		var mongoConfig = config.mongo || {};
		var mongoServer = new mongodb.Server(mongoConfig.host || "localhost", mongoConfig.port || 27017, {});
		var mongoDb = new mongodb.Db(mongoConfig.database || "x3meta", mongoServer, {
			w: 1 //"majority"
		});
		mongoDb.open(_);
		var settingsColn = mongoDb.collection("user_settings", _);
		var dataColn = mongoDb.collection(itemHandler.mongo.colName, _);
		var lastSyncFilter = {
			type: itemHandler.mongo.syncDocType,
		};
		var lastSync = settingsColn.find(lastSyncFilter, _).toArray(_)[0];
		var fullSync = options.fullSync;

		if (!lastSync) {
			// First sync : full sync
			fullSync = true;
		}

		// Note: fullSync is 'on' if no previous sync date could be found or if set in options
		var lastSyncDateFilters = null;

		if (fullSync) {
			// Full sync
			// Droping the collection instead of just removing all its docs ensures that any obsolete indexes
			// will be removed as well.
			try {
				dataColn.drop(_);
			} catch (err) {
				// Nothing to do, the collection may not exist
			}
			_trace(locale.format(module, "fullSyncCollectionDropped"), "info");
		} else {
			// Incremental sync. We only process update / insert (remove are ignored, for now)
			var lastSyncDate = new Date(Date.parse(lastSync.date));
			_trace(locale.format(module, "incSync", lastSyncDate), "info");
			lastSyncDateFilters = [{
				key: itemHandler.sql.dateColName,
				operator: '>',
				value: lastSyncDate
			}];
		}
		var count = 0;
		var tableDef = superv.sqlDriver.getTableDef(_, superv.folderName, itemHandler.sql.tableName);
		var tableReader = superv.sqlDriver.createTableReader(_, tableDef, lastSyncDateFilters);
		// if (lastSyncDateFilters != null)
		// 	tableReader = tableReader.filter(lastSyncDateFilters);

		tableReader.forEach(_, function(_, row) {
			count++;
			var filter = {};
			itemHandler.mongo.distinctKeys.forEach(function(key) {
				filter[key] = row[key + '_0'];
			});
			if ((count % 100) == 0) {
				_trace(locale.format(module, "processed", count, JSON.stringify(filter)), "info");
			}

			var data = trim(row);

			try {
				if (fullSync) {
					dataColn.insert(data, _);
				} else {
					dataColn.update(filter, data, {
						upsert: true
					}, _);
				}
			} catch (e) {
				console.error("tableReader:" + e);
			}
		});

		_trace(locale.format(module, "syncDone", count, Math.round((Date.now() - t0) / 1000)), "info");

		// Now, create the indexes

		// We always create an index, based on the distinct keys
		var distinctIndex = {
			unique: true,
			keys: itemHandler.mongo.distinctKeys
		};

		if (options.skipIndexes) {
			_trace(locale.format(module, "indexesSkipByConfig"), "info");
		} else {
			var indexesToCreate = [distinctIndex].concat(itemHandler.mongo.extraIndexes);
			indexesToCreate.forEach_(_, function(_, index) {
				var idxKeys = {};
				var idxOptions = {};
				index.keys.forEach(function(colName) {
					idxKeys[colName] = 1;
				});
				if (index.unique) {
					idxOptions["unique"] = true;
				}
				dataColn.ensureIndex(idxKeys, idxOptions, _);
				_trace(locale.format(module, "indexCreated", JSON.stringify(idxKeys), index.unique), "info");
			});
		}

		// End of process, store the current date (for later incremental updates)
		settingsColn.update(lastSyncFilter, {
			type: lastSyncFilter.type,
			date: new Date(),
		}, {
			upsert: true
		}, _);

	};
	return {
		syncText: function(_, textType, options) {
			var textDescriptor = resourceManager.getTextDescriptor(_, textType).text;
			return syncType(_, textDescriptor, options);
		},
	};

};