"use strict";

var fs = require('streamline-fs');
var getEntityDescriptor = require('scm-helper/lib/resourceManager').getEntityDescriptor;
var tableEntity = getEntityDescriptor("tables").entity;

exports.run = function(_, exporter, text, tracker, entityType, entityNames) {
	var t0 = Date.now();
	var buildExecute = exporter.buildExecute,
		trace = exporter.trace;

	var mainColumns = exporter.getTableColumns(_, text.tableName);
	var mainKeys = text.distinctKey.split(',');
	var processedCount = 0;
	var filenames = [];

	trace && trace(text.title + ": loading list");
	var elts = buildExecute(_, "distinct " + text.distinctKey, text.tableName, text.distinctKey);
	if (text.tableName === "ATEXTRA") {
		elts = elts.filter(function(elt) {
			return elt.CODFIC && tableEntity.excludedInitials.indexOf(elt.CODFIC[0]) < 0;
		});
	}

	elts.forEach_(_, exporter.config.parallel || 4, function(_, elt, i) {
		if (tracker && tracker.abortRequested) return;

		// there must be a better way to accomplish this
		mainKeys.forEach_(_, function(_, val) {
			elt[val] = elt[val] || '';
		});

		if (entityNames) {
			// We have to filter the entities
			switch (text.tableName) {
				case 'ATEXTRA':
					if (entityNames.indexOf(elt.CODFIC) == -1)
						return;
					break;

				case 'ATEXTE':
					if (entityNames.indexOf(elt.NOMOBJ) == -1)
						return;
					break;
			}
		}
		/*		
		if (entityType) {
			// We have to filter the entities
			switch (text.tableName) {
				case 'ATEXTE':
					var entities = text.entities;
					// query all the resources for a given obj
					if (entityType && (entities[elt.TYPEOBJ] != entityType)) {
						// This entity type does not match the filter provided as parameters
						return;
					}
					break;
			}
		}
*/
		processedCount++;

		trace && trace((i + 1) + "/" + elts.length + ": exporting " + text.title + ": " + exporter.objVals(_, elt, text.objectTypes));

		var data = buildExecute(_, mainColumns, text.tableName, text.orderBy, elt);

		var meta, res = {};

		switch (text.tableName) {
			case 'ATEXTRA':
				meta = buildExecute(_, 'MODULE,CODACT', 'ATABLE', null, {
					CODFIC: elt.CODFIC
				}, 'CODFIC');
				if (!meta) return;
				res = {
					path: exporter.moduleNames[meta.MODULE] + "/TEXTS/",
					name: elt.CODFIC,
				};
				break;

			case 'ATEXTE':
				var entities = text.entities;
				// query all the resources for a given obj
				if (entities[elt.TYPOBJ] && fs.exists("./entities/" + entities[elt.TYPOBJ] + "._js", _)) {
					var entity = getEntityDescriptor(entities[elt.TYPOBJ]).entity;
					var mainKey = entities[elt.TYPOBJ] === "parameters" ? "CHAPITRE,CODACT" : "MODULE,CODACT";
					if (elt.NOMOBJ) elt.NOMOBJ = elt.NOMOBJ.replace(/'/g, '');
					meta = buildExecute(_, mainKey, entity.tableName, null, {
						NOMOBJ: elt.NOMOBJ
					}, entity.primaryKey)[0];
				}
				res = {
					path: (meta ? (exporter.moduleNames[meta.MODULE] || (meta.CHAPITRE ? "CHAPTERS/" + meta.CHAPITRE : "GLOBAL")) : "GLOBAL") +
						"/" + (elt.TYPOBJ ? text.objectTypes[elt.TYPOBJ] : "MISC") + "/",
					name: elt.NOMOBJ || "_ALL_",
				};
				break;

			case 'APLSTD':
				res = {
					path: "GLOBAL/MENUS/",
					name: elt.LANCHP,
				};
				break;
		}

		// group by language
		var bylan = data.reduce(function(r, d) {
			(r[d[text.lan]] = r[d[text.lan]] || []).push(d);
			return r;
		}, {});
		Object.keys(bylan).forEach_(_, function(_, lan) {
			var fn = exporter.writeResource(_, {
				path: res.path + lan,
				name: res.name,
				data: bylan[lan]
			});
			filenames.push(fn);
		});
	});
	trace && trace(text.title + ": " + processedCount + " exported in " + Math.round((Date.now() - t0) / 1000) + " seconds");
	return filenames;
};