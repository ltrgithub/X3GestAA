"use strict";
var fs = require("streamline-fs"),
	path = require('path'),
	mongodb = require('streamline-mongodb'),
	datetime = require('syracuse-core/lib/types/datetime');

exports.newImporter = function(_, config) {
	var trace = config.trace;
	var jsondir = path.join(config.rootFolder, config.metaSubFolder);
	var mongoConfig = config.mongo || {};
	var mgConf = mongoConfig;
	var dbUrl = "mongodb://" + (mgConf.connectionString || ((mgConf.host || "localhost") + ":" + (mgConf.port || 27017))) + "/" + (mgConf.database || "x3meta");
	var db = mongodb.MongoClient.connect(dbUrl, mgConf.options || {
		db: {
			w: 1
		}
	}, _);
	var files = {
		TEXTS: [],
		MENUS: []
	};

	buildFilesList(_);

	function cleanData(data) {
		if ("string" === typeof(data)) {
			// The data is written with a prefix that describes its format. We have to remove
			// the prefix to retrieve the raw value
			// the data looks like tt[:xx]|yyyyyy where 
			// - tt the data type (S:string, C:clob, N:decimal, D:date, T:timestamp)
			// - xx (if supplied) is an option of the format
			// - yyyyyy the raw value we are interested in.
			var parts = /^(\w)(\:[^|"]+)?\|(.*)$/.exec(data);
			if (!parts)
				throw new Error("Wrong format. Value = " + value);
			switch (parts[1]) {
				case 'D':
				case 'T':
					data = new Date(Date.parse(parts[3]));
					break;
				default:
					data = parts[3];
					break;
			}
		} else if (Array.isArray(data)) {
			data.forEach(function(item, idx) {
				data[idx] = cleanData(item);
			});
		} else if ("object" === typeof(data)) {
			Object.keys(data).forEach(function(key) {
				if (/^##\w+##$/.test(key)) {
					// this is a special tag for extra properties that are not needed here
					delete data[key];
					return;
				}
				data[key] = cleanData(data[key]);
			});
		}

		return data;
	}

	function readFile(_, path) {
		var data = JSON.parse(fs.readFile(path, 'utf8', _));
		return cleanData(data);
	}

	function buildFilesList(_) {
		fs.readdir(jsondir, _).forEach_(_, function(_, module) {
			var moduleDir = path.join(jsondir, module);
			if (fs.stat(moduleDir, _).isDirectory()) {
				fs.readdir(moduleDir, _).forEach_(_, function(_, type) {
					var typeDir = path.join(moduleDir, type);
					if (fs.stat(typeDir, _).isDirectory()) {
						var entries = fs.readdir(typeDir, _);

						entries.filter(function(name) {
							var fn = config.metaSubFolder + "/" + module + "/" + type + "/" + name;
							if (!(/\.json$/).test(name))
								return false;
							if (config.filenames) {
								// The file must belong to the provided list of files to process
								if (config.filenames.indexOf(fn) == -1)
									return false;
							}
							return true;
						}).forEach_(_, function(_, name) {
							files[type] = files[type] || {};
							files[type][name.substring(0, name.length - 5)] = path.join(typeDir, name);
						});

						entries.filter(function(name) {
							return (/^\w\w\w$/).test(name);
						}).forEach_(_, function(_, lan) {
							fs.readdir(typeDir + "/" + lan, _).filter(function(name) {
								return (/\.json$/).test(name);
							}).forEach_(_, function(_, name) {
								var dest = type === "MENUS" ? files.MENUS : files.TEXTS;
								var relativeFilename = path.join(config.metaSubFolder, module, type, lan, name);
								if (config.filenames) {
									// The file must belong to the provided list of files to process
									if (config.filenames.indexOf(relativeFilename) == -1)
										return;
								}
								dest.push(config.metaSubFolder + "/" + relativeFilename);
							});
						});
					}
				});
			}
		});
	}

	return {
		open: function(_) {
			//db.open(_);
			return this;
		},
		fillTables: function(_, entity, tracker) {
			trace && trace("inserting " + entity.title + " metadata ...");
			var t0 = Date.now();
			var names = Object.keys(files[entity.subdir] || {});
			var coln = db.collection(entity.tableName, _);

			var etag = datetime.now().toString();
			names.forEach_(_, function(_, name, i) {
				if (tracker && tracker.abortRequested) return;

				if (tracker)
					tracker.phaseDetail = "Importing " + entity.title + " : " + name;

				trace && trace(entity.title + ": " + (i + 1) + "/" + names.length + " importing " + name + " from " + files[entity.subdir][name]);
				var data = readFile(_, files[entity.subdir][name]);
				var filter = {};
				filter[entity.primaryKey] = data[entity.primaryKey];
				data._etag = etag;
				coln.update(filter, data, {
					upsert: true
				}, _);

			});
			if (tracker && tracker.abortRequested) return;
			trace && trace(entity.title + ": " + names.length + " resources created in " + Math.round((Date.now() - t0) / 1000) + " seconds");

			if (tracker)
				tracker.phaseDetail = "Create unique index base on primary key (" + entity.primaryKey + ")";
			console.log("Create unique index base on primary key (" + entity.title + "." + entity.primaryKey + ")");
			var keys = {};
			keys[entity.primaryKey] = 1;
			coln.ensureIndex(keys, {
				unique: true
			}, _);
		},

		fillTexts: function(_, tracker) {
			trace && trace("inserting texts ...");
			var t0 = Date.now();
			var names = files.TEXTS;
			var colnATEXTE = db.collection("ATEXTE", _);
			var colnATEXTRA = db.collection("ATEXTRA", _);
			names.forEach_(_, function(_, name, i) {
				if (tracker && tracker.abortRequested) return;
				trace("texts: " + (i + 1) + "/" + names.length + " importing " + name);
				var data = readFile(_, name);
				if (data.TEXTS) colnATEXTRA.insert(data.TEXTS, _);
				else if (Array.isArray(data)) colnATEXTE.insert(data, _);
				else console.log("bad text file: " + name);
			});
			var colnAPLSTD = db.collection("APLSTD", _);
			files.MENUS.forEach_(_, function(_, name, i) {
				if (tracker && tracker.abortRequested) return;
				trace("enums: " + (i + 1) + "/" + files.MENUS.length + " importing " + name);
				var data = readFile(_, name);
				colnAPLSTD.insert(data, _);
			});
			if (tracker && tracker.abortRequested) return;
			colnAPLSTD.ensureIndex({
				"LAN": 1,
				"LANCHP": 1,
				"LANNUM": 1
			}, _);
			trace && trace("TEXTS: " + (names.length + files.MENUS.length) + " resources created in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		},
		readInstance: function(_, entity, key) {
			var filter = {};
			filter[entity.primaryKey] = key;
			return db.collection(entity.tableName, _).find(filter, _).toArray(_)[0];
		},
	};
};

function getResource(_, folder) {
	var resPath = path.join(__dirname, folder);
	return fs.readdir(resPath, _).map_(_, function(_, filename) {
		return (/(.*)\.(_js)/).test(filename) ? require(path.join(resPath, filename)) : null;
	}).filter(function(file) {
		return file !== null;
	});
}
