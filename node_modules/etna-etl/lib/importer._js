"use strict";
var fs = require("streamline-fs"),
	path = require('path'),
	mongodb = require('streamline-mongodb');

exports.newImporter = function(_, config) {
	var trace = config.trace;
	var jsondir = config.dir;
	var mongoConfig = config.mongo || {};
	var server = new mongodb.Server(mongoConfig.host || "localhost", mongoConfig.port || 27017, {});
	var db = new mongodb.Db(mongoConfig.database || "x3meta", server, {
		w: 1 //"majority"
	});

	function readFile(_, path) {
		return JSON.parse(fs.readFile(path, 'utf8', _));
	}

	var files = {
		TEXTS: [],
		MENUS: []
	};
	fs.readdir(jsondir, _).forEach_(_, function(_, module) {
		var moduleDir = jsondir + "/" + module;
		if (fs.stat(moduleDir, _).isDirectory()) {
			fs.readdir(moduleDir, _).forEach_(_, function(_, type) {
				var typeDir = moduleDir + "/" + type;
				if (fs.stat(typeDir, _).isDirectory()) {
					var entries = fs.readdir(typeDir, _);
					entries.filter(function(name) {
						return (/\.json$/).test(name);
					}).forEach_(_, function(_, name) {
						files[type] = files[type] || {};
						files[type][name.substring(0, name.length - 5)] = typeDir + "/" + name;
					});
					entries.filter(function(name) {
						return (/^\w\w\w$/).test(name);
					}).forEach_(_, function(_, lan) {
						fs.readdir(typeDir + "/" + lan, _).filter(function(name) {
							return (/\.json$/).test(name);
						}).forEach_(_, function(_, name) {
							var dest = type === "MENUS" ? files.MENUS : files.TEXTS;
							dest.push(typeDir + "/" + lan + "/" + name);
						});
					});
				}
			});
		}
	});

	return {
		open: function(_) {
			db.open(_);
			return this;
		},
		createTables: function(_) {
			trace && trace("dropping old collections ...");
			var t0 = Date.now();
			var tableNames = db.collectionNames(_).map(function(o) {
				return o.name.substring(o.name.lastIndexOf('.') + 1);
			}).filter(function(s) {
				return files.TABLES[s];
			});
			tableNames.forEach_(_, function(_, name) {
				trace && trace("dropping " + name);
				db.dropCollection(name, _);
			});
			trace && trace(tableNames.length + " collections dropped in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		},
		fillTables: function(_, entity, tracker) {
			trace && trace("inserting " + entity.title + " metadata ...");
			var t0 = Date.now();
			if (!files.TABLES[entity.tableName]) throw new Error("NO FILES: " + entity.tableName);
			var meta = readFile(_, files.TABLES[entity.tableName]);
			var names = Object.keys(files[entity.subdir] || {});
			var coln = db.collection(entity.tableName, _);
			names.forEach_(_, function(_, name, i) {
				if (tracker && tracker.abortRequested) return;
				trace(entity.title + ": " + (i + 1) + "/" + names.length + " importing " + name);
				var data = readFile(_, files[entity.subdir][name]);
				coln.insert(data, _);
			});
			if (tracker && tracker.abortRequested) return;
			trace && trace(entity.title + ": " + names.length + " resources created in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		},
		fillTexts: function(_, tracker) {
			trace && trace("inserting texts ...");
			var t0 = Date.now();
			var names = files.TEXTS;
			var colnATEXTE = db.collection("ATEXTE", _);
			var colnATEXTRA = db.collection("ATEXTRA", _);
			names.forEach_(_, function(_, name, i) {
				if (tracker && tracker.abortRequested) return;
				trace("texts: " + (i + 1) + "/" + names.length + " importing " + name);
				var data = readFile(_, name);
				if (data.TEXTS) colnATEXTRA.insert(data.TEXTS, _);
				else if (Array.isArray(data)) colnATEXTE.insert(data, _);
				else console.log("bad text file: " + name);
			});
			var colnAPLSTD = db.collection("APLSTD", _);
			files.MENUS.forEach_(_, function(_, name, i) {
				if (tracker && tracker.abortRequested) return;
				trace("enums: " + (i + 1) + "/" + files.MENUS.length + " importing " + name);
				var data = readFile(_, name);
				colnAPLSTD.insert(data, _);
			});
			if (tracker && tracker.abortRequested) return;
			trace && trace("TEXTS: " + (names.length + files.MENUS.length) + " resources created in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		},
		readInstance: function(_, entity, key) {
			var filter = {};
			filter[entity.primaryKey] = key;
			return db.collection(entity.tableName, _).find(filter, _).toArray(_)[0];
		},
	};
};

function getResource(_, folder) {
	var resPath = path.join(__dirname, folder);
	return fs.readdir(resPath, _).map_(_, function(_, filename) {
		return (/(.*)\.(_js)/).test(filename) ? require(path.join(resPath, filename)) : null;
	}).filter(function(file) {
		return file !== null;
	});
}

exports.importMetadata = function(_, config, tracker) {
	var importer = exports.newImporter(_, {
		trace: function(str) {
			if (tracker) tracker.phaseDetail = str;
			if (config.trace) config.trace(str);
		},
		dir: config.solutionPath + "/"  + config.folderName + "/META",
		mongo: config.mongo,
	}).open(_);
	if (tracker) tracker.phase = "creating collections";
	importer.createTables(_, tracker);
	var entities = getResource(_, "entities");
	entities.forEach_(_, function(_, entityResource) {
		if (tracker && tracker.abortRequested) return;
		if (tracker) tracker.phase = "importing " + entityResource.entity.title;
		importer.fillTables(_, entityResource.entity, tracker);
	});
	if (tracker) tracker.phase = "importing texts";
	importer.fillTexts(_, tracker);
}
