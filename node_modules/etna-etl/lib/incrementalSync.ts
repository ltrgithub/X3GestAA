import { _ } from 'streamline-runtime';
import * as mongodb from 'mongodb';
import { Dict, ExporterConfig, Tracker } from './exporter';

var locale = require('streamline-locale'),
	resourceManager = require('scm-lib/resourceManager');

export interface ItemHandler {
	mongo: {
		colName: string;
		syncDocType: string;
		distinctKeys: string[];
		extraIndexes: Index[];
	};
	sql: {
		tableName: string;
		dateColName: string;
	};
}
export interface SyncOptions {
	fullSync?: boolean;
	skipIndexes?: boolean;
}

interface Filter {
	key: string;
	operator: string;
	value: any;
}

interface Index {
	unique: boolean;
	keys: string[];
}

export function newIncrementalSync(config: any, tracker: Tracker) { // !!!! config is etnaConfig

	config.trace = config.trace || console.log;

	var trace = config.trace;

	function _trace(message: string, severity: string, options?: any) {
		options = options || {};
		trace && trace(message);
		if (severity) {
			if (tracker && !options.noTracker) {
				tracker.$diagnoses = tracker.$diagnoses || [];
				tracker.$diagnoses.push({
					$severity: severity,
					$message: message,
				});
			}
		}
	}

	function trim(obj: any) {
		var result = Object.keys(obj).reduce(function (o, k) {
			var v = obj[k];
			if (v instanceof Date) {
				v = v.toISOString();
				if (/T00\:00\:00\.000Z$/.test(v)) {
					v = v.substring(0, v.length - 14);
					if (v === '1599-12-31') v = null;
				}
			}
			if (/^CAST\(AUUID_0/.test(k)) k = "AUUID_0";
			var lastIndex = k.lastIndexOf('_');
			if (lastIndex == -1) {
				// Skip this column : not use directly by X3 (sth like ROWID)
			} else {
				var kk = k.substring(0, lastIndex);
				var isArray = (obj[kk + '_1'] !== undefined);
				if (isArray) {
					o[kk] = o[kk] || [];
					o[kk].push(v);
				} else {
					if (v && v !== ' ') o[kk] = v;
				}
			}
			return o;
		}, {} as any);
		Object.keys(result).forEach(function (k) {
			var v = result[k];
			if (Array.isArray(v)) {
				var len = v.length;
				while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
				result[k] = v.slice(0, len);
			}
		});
		return result;
	}

	function syncType(_: _, itemHandler: ItemHandler, options: SyncOptions) {
		_trace(locale.format(module, "syncMongoCollection", itemHandler.mongo.colName), "info");
		var t0 = Date.now();
		var sqlDriver = require('@sage/etna-' + config.sql.driver).create(config.sql);

		options = options || {};
		var mongoConfig = config.mongo || {};
		var dbUrl = mongoConfig.url || ("mongodb://" + (mongoConfig.connectionString || ((mongoConfig.host || "localhost") + ":" + (mongoConfig.port || 27017))));
		var mongoDb = mongodb.MongoClient.connect(dbUrl, mongoConfig.options as mongodb.MongoClientOptions || {}).then(_, _).db(mongoConfig.database);
		var settingsColn = mongoDb.collection("user_settings");
		var dataColn = mongoDb.collection(itemHandler.mongo.colName);
		var lastSyncFilter = {
			type: itemHandler.mongo.syncDocType,
		};
		var lastSync = settingsColn.find(lastSyncFilter).toArray().then(_, _)[0];
		var fullSync = options.fullSync;

		if (!lastSync) {
			// First sync : full sync
			fullSync = true;
		}

		// Note: fullSync is 'on' if no previous sync date could be found or if set in options
		var lastSyncDateFilters: Filter[] = null;

		if (fullSync) {
			// Full sync
			// Droping the collection instead of just removing all its docs ensures that any obsolete indexes
			// will be removed as well.
			try {
				dataColn.drop().then(_, _);
			} catch (err) {
				// Nothing to do, the collection may not exist
			}
			_trace(locale.format(module, "fullSyncCollectionDropped"), "info");
		} else {
			// Incremental sync. We only process update / insert (remove are ignored, for now)
			var lastSyncDate = new Date(Date.parse(lastSync.date));
			_trace(locale.format(module, "incSync", lastSyncDate), "info");
			lastSyncDateFilters = [{
				key: itemHandler.sql.dateColName,
				operator: '>',
				value: lastSyncDate
			}];
		}
		var count = 0;
		var tableDef = sqlDriver.getTableDef(config.folderName, itemHandler.sql.tableName);
		var tableReader = sqlDriver.createTableReader<any>(tableDef, lastSyncDateFilters);
		// if (lastSyncDateFilters != null)
		// 	tableReader = tableReader.filter(lastSyncDateFilters);

		tableReader.forEach_(_, (_, row) => {
			count++;
			var filter = {} as any;
			itemHandler.mongo.distinctKeys.forEach(function (key) {
				filter[key] = row[key + '_0'];
			});
			if ((count % 100) == 0) {
				_trace(locale.format(module, "processed", count, JSON.stringify(filter)), "info", {
					noTracker: true
				});
			}

			var data = trim(row);

			try {
				if (fullSync) {
					dataColn.insert(data).then(_, _);
				} else {
					dataColn.update(filter, data, {
						upsert: true
					}).then(_, _);
				}
			} catch (e) {
				console.error("tableReader:" + e);
			}
		});

		_trace(locale.format(module, "syncDone", count, Math.round((Date.now() - t0) / 1000)), "info");

		// Now, create the indexes

		// We always create an index, based on the distinct keys
		var distinctIndex: Index = {
			unique: true,
			keys: itemHandler.mongo.distinctKeys
		};

		if (options.skipIndexes) {
			_trace(locale.format(module, "indexesSkipByConfig"), "info");
		} else {
			var indexesToCreate = [distinctIndex].concat(itemHandler.mongo.extraIndexes);
			indexesToCreate.forEach_(_, function (_, index) {
				var idxKeys = {} as Dict<number>;
				var idxOptions = {} as Dict<boolean>;
				index.keys.forEach(function (colName) {
					idxKeys[colName] = 1;
				});
				if (index.unique) {
					idxOptions["unique"] = true;
				}
				dataColn.createIndex(idxKeys, idxOptions).then(_, _);
				_trace(locale.format(module, "indexCreated", JSON.stringify(idxKeys), index.unique), "info");
			});
		}

		// End of process, store the current date (for later incremental updates)
		settingsColn.update(lastSyncFilter, {
			type: lastSyncFilter.type,
			date: new Date(),
		}, {
				upsert: true
			}).then(_, _);

	};
	return {
		syncText(_: _, textType: string, options: SyncOptions) {
			resourceManager.setConfiguration({
				rootFolder: config.scmDefinitionFilesFolder
			})
			var textDescriptor = resourceManager.getTextDescriptor(_, textType).text;
			return syncType(_, textDescriptor, options);
		},
	};

};