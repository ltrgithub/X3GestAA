"use strict";

var spawn = require('child_process').spawn;
var ez = require('ez-streams');

/// !doc
/// # git wrapper
/// A wrapper around git client that can perform a set of operations and return structured results.

exports.git = function(options) {
	var globalOptions = options || {};
	var trace = options.trace;

	// Launches a command with given (optional) args and returns an object with the stdout, stderr, exitCode.
	function launchCommand(_, command, args) {
		args = args || [];
		trace && trace(">>> " + command + ' ' + args.join(' '));
		var result = {
			out: "",
			err: "",
			exitCode: 0,
		};

		options = {
			errorPrefix: "[ERR]",
			errorThrow: false,
			acceptCode: function(code) {
				result.exitCode = code;
				return true;
			}
		};
		if (globalOptions.folder) {
			process.chdir(globalOptions.folder);
		}

		// Note : there can be 2 different kinds of error : 
		// - the command is invalid (command not found) : an error is raised and should be catched by the caller
		// - the command is valid but fails : no error is raised, the exitCode and err properties are set
		var child = spawn(command, args);
		var reader = ez.devices.child_process.reader(child, options);
		reader.forEach(_, function(_, line) {
			if (/^\[ERR\]/.test(line)) {
				if (result.err.length > 0)
					result.err += "\n";
				result.err += line.substring(5);

			} else {
				if (result.out.length > 0)
					result.out += "\n";
				result.out += line;
			}

		});
		//trace && trace("            " + JSON.stringify(result));
		return result;
	}

	// Launches a 'git' command with given (optional) args.	
	function launchGitCommand(_, command, args) {
		args = args || [];
		args.unshift(command);
		command = "git";
		return launchCommand(_, command, args);
	}

	function getFilenamesFromGitDiff(_, fromSha1, toSha1) {
		var allText = '';
		executeGitCommand(_, "git diff --stat", function(git) {
			var child = git.spawn("diff", ['--stat', fromSha1 + '..' + toSha1]);
			child.stdout.on("data", function(txt) {
				allText += txt;
			});
			return child;
		});

		var filenames = [];

		allText.split('\n').forEach(function(item) {
			// Each line looks like 'META/SUPERV/CLASSES/ATABLE.json         | 2357 ++++++++++++++'
			var reg = /\s*([^\s]+)\s*\|\s*\d+\s*([\+\-]+)/.exec(item);
			if (reg) {
				var filename = reg[1];
				filenames[filename] = true;
			}
		});
		return Object.keys(filenames);
	}


	return {
		/// !doc
		/// ### command(_, gitCommand, args)
		/// Performs a git command with the given arguments
		/// The function returns an abject with the following structure : 
		/// ``` javascript
		/// { 
		///		out: xxxx (the stdout of the git command)
		///		err: xxxx (the stderr of the git command)
		///		exitCode: nnn  (the exitCode of the git command)
		/// }
		/// ```
		command: function(_, gitCommand, args) {
			return launchGitCommand(_, gitCommand, args);
		},

		/// !doc
		/// ### pull(_, options)
		/// Performs a 'git pull'.
		/// optional parameters can be provided through `options.args`
		/// The function returns an abject with the following structure : 
		/// ``` javascript
		/// { 
		///		out: xxxx (the stdout of the git command)
		///		err: xxxx (the stderr of the git command)
		///		exitCode: nnn  (the exitCode of the git command)
		/// }
		/// ```
		pull: function(_, options) {
			options = options || {};
			return launchGitCommand(_, "pull", options.args);
		},

		/// !doc
		/// ### push(_, options)
		/// Performs a 'git push'.
		/// optional parameters can be provided through `options.args`
		push: function(_, options) {
			options = options || {};
			return launchGitCommand(_, "push", options.args);
		},

		/// !doc
		/// ### commit(_, msg, options)
		/// Performs a 'git commit'.
		/// optional parameters can be provided through `options.args`
		commit: function(_, msg, options) {
			options = options || {};
			options.args = ['-m' + msg].concat(options.args || []);
			return launchGitCommand(_, "commit", options.args);
		},

		/// !doc
		/// ### diffStat(_, fromSha1, [toSha1])
		/// Returns the git diffs between 2 sha1. When omitted, HEAD will be used as `toSha1`.
		/// This function returns on abject with the following structure : 
		/// ``` javascript
		/// {
		///		diffs : [
		///			{
		///				filename : xxx
		///				touch : add | remove | update
		/// 		},
		///			...
		///		]
		/// }
		/// ```
		diffStat: function(_, fromSha1, toSha1) {
			function parseDiffStatsResult(gitResult, withStatus) {
				var files = {
					diffs: [],
				};
				var allText = gitResult.out;
				var reg = /(A|C|D|M|R|T|U|X|B)\t([^\s]+)/;
				allText.split('\n').forEach(function(item) {
					// Each line looks like 'META/SUPERV/CLASSES/ATABLE.json         | 2357 ++++++-----'
					// Each line looks like 'D    node_modules/nodegit/src/branch.cc'
					if (!withStatus) {
						// Consider all the files as new
						item = "A\t" + item;
					}
					var result = reg.exec(item);
					if (result) {
						files.diffs.push({
							filename: result[2],
							touch: result[1]
						});
					}
				});
				return files;
			}

			if (fromSha1) {
				// List only the files that where modified in the range fromSha1..toSha1
				toSha1 = toSha1 || "HEAD";
				var gitResult = launchGitCommand(_, "diff", ['--name-status', fromSha1 + '..' + toSha1]);
				return parseDiffStatsResult(gitResult, true);
			} else {
				// List all versionned files
				var gitResult = launchGitCommand(_, "ls-files", []);
				return parseDiffStatsResult(gitResult, false);
			}
		},

		/// !doc
		/// ### add(_, filenames)
		/// Adds a set of files from their filename.
		add: function(_, filenames) {
			filenames.forEach_(_, function(_, filename) {
				launchGitCommand(_, "add", [filename]);
			});
		},

		/// !doc
		/// ### getHead(_)
		/// Returns the HEAD of the current git repository as a structure 
		/// ``` javascript
		/// { 
		///		sha1: xxxx,
		///		author: xxxx,
		///		email: xxxx,
		///		date: xxxx,
		///		subject: xxxx,
		/// }
		/// 
		/// ```
		getHead: function(_) {
			return this.getLog(_, {
				logSize: 1
			}).logs[0];
		},

		/// !doc
		/// ### getLog(_, options)
		/// Returns the git logs as an object.
		/// options can be used to configure the result set.
		/// - options.logSize : number of logs returned (default = 10)
		/// 
		/// This function returns on abject with the following structure : 
		/// ``` javascript
		/// {
		///		logs : [
		///			{
		///				sha1: xxxx,
		///				author: xxxx,
		///				email: xxxx,
		///				date: xxxx,
		///				subject: xxxx,
		/// 		},
		///			...
		///		]
		/// }
		/// ```
		getLog: function(_, options) {
			function parseLogResult(gitResult) {
				var result = {};
				result.logs = gitResult.out.split("\n").map(function(line) {
					// Each line to parse looks like 'ed7f1e68874833d8e03f2be5540ade5036d8b08c||sdeniaud||stephane.deniaud@sage.com||2014-12-15 13:38:10 +0100||Merge branch 'etna' into F_100971_metadata_versioning'
					var reg = /(\w*)\|\|(.+)\|\|(.+)\|\|(.+)\|\|(.+)$/.exec(line);
					if (!reg)
						throw new Error("Could not parse line : " + line);
					return {
						sha1: reg[1],
						author: reg[2],
						email: reg[3],
						date: reg[4],
						subject: reg[5],
					};
				});
				return result;
			}

			options = options || {};
			options.logSize = options.logSize || 10;
			// we use a specific format : it will be easier to parse the results
			// %H  - commit hash
			// %an - author name
			// %aE - author email
			// %ai - author date, ISO 8601 format
			// %s  - subject
			var gitResult = launchGitCommand(_, "log", [-options.logSize, "--pretty=oneline", "--format=\"%H||%an||%aE||%ai||%s\""]);
			if (gitResult.exitCode != 0)
				throw new Error("Could not retrieve the logs (" + options.logSize + "), code = " + gitResult.exitCode + ", reason = " + gitResult.err);
			return parseLogResult(gitResult);
		},

		test: function(_, args) {
			//var result = launchCommand(_, "lse");
			var result = launchCommand(_, "ls", ["-ZZ"]);

			trace && trace(result);
		},
	};
};