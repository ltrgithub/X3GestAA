/// <reference path="../node_modules/streamline-node/index.d.ts"/>
import { _ } from 'streamline-runtime';
import { wait } from 'f-promise';
import * as fs from 'fs';
import * as path from 'path';
import { Driver } from '@sage/etna-sql';

var locale = require('streamline-locale'),
    jsonHelper = require('scm-lib/jsonHelper'),
    encodeValueToJsonString = require('scm-lib/jsonHelper').encodeValueToJsonString,
    decodeValueFromJsonString = require('scm-lib/jsonHelper').decodeValueFromJsonString,
    productsHelper = require('scm-lib/productsHelper');

type TableMeta = any;
type ColumnMeta = any;
type TrimOptions = any;
type ExecuteOptions = any;
type ResourceManager = any;

export type Dict<T> = { [key: string]: T };

interface Idents {
    ident1: string;
    ident2?: string;
    texts?: any;
    index?: any;
}

interface Text {
    IDENT1: string;
    IDENT2: string;
    LANG: string;
    TEXT: string;
    index: any;
}

interface Resource {
    data: any;
    path: string;
    fileName: string;
}

export interface Diagnose {
    $severity: string;
    $message: string;
}

export interface Tracker {
    phase: string;
    phaseDetail: string;
    $diagnoses: Diagnose[];
    abortRequested: boolean;
}

export interface FileStruct {
    status: string;
    absoluteFilename: string;
    relativeFilename?: string;
}
export interface ExporterConfig {
    trace?: any;
    langs?: string[];
    etnaConfig: any;
    metaFolder: string;
    outputFolder: string;
    mongo: any;
    fileStructs: FileStruct[];
};

type Mappings = any;

interface Group {
    name: string;
    children: Dict<Descriptor>;
}

export interface Descriptor {
    subdir: string;
    parentMappings: Mappings;
    distinctKey: string[] | string;
    primaryKey: string[] | string;
    patchPK: string[] | string;
    tableName: string;
    excludedColumns: string[];
    itemIndex: string;
    orderBy: string;
    children: Dict<Descriptor>;
    groups: Group[];
    dummyObject: boolean;
    title: string;
    parentCount: number;
    excludedInitials: string;
    filter: any;
}

export interface Product {
    name: string;
}

export interface Exporter {
    config: ExporterConfig;
    trace: any;
    product: Product;
    init(_: _, tracker: Tracker): boolean;
    clean(_: _, tracker: Tracker): void;
    release(_: _): void;
    getTableColumns(_: _, tableName: string, excludedColumnNames: string[]): any[];

    buildExecute(_: _, tableMeta: TableMeta, select: string | string[], tableName: string, orderBy: string | string[], keys: any, where?: string | string[], options?: ExecuteOptions): any[];
    writeResource(_: _, res: Resource): string;
    getTableMeta(_: _, tableName: string, excludedColumnNames: string[]): TableMeta;
    objVals(_: _, elt: any, objectTypes: any): string;
    listMetadataFiles(_: _, entity: Descriptor): Dict<any>;
}

function filterMeta(s: string) {
    return [
        /"(CREDATTIM|UPDDATTIM)": "(T\|(?:[\d-T:\.]*Z|NULL))"/g,
        /"(CREUSR|UPDUSR)": "(S:.*)"/g,
        /"(CREDAT|UPDDAT)": "(D\|(?:[\d-]*|NULL))"/g,
    ].reduce(function (r, exp) {
        r = r.replace(exp, '"$1" :""');
        return r;
    }, s);
}

export function newExporter(config: ExporterConfig): Exporter {
    const MARK_extraTables = "##extraTables##";
    var trace = config.trace;
    config.langs = config.langs || ["ENG", "FRA"];
    var sqlConfig = config.etnaConfig.sql;
    if (!sqlConfig) {
        throw new Error(locale.format(module, "sqlConfigMissing"));
    }
    var driver = require('@sage/etna-' + sqlConfig.driver).create(sqlConfig) as Driver;
    var fsFunnel = _.funnel<void>(1);

    // Creates a directory and returns whether the creation succeeded
    function mkdir(_: _, s: string) {
        var result = true;
        if (!fs.exists(s, _, _)) {
            fsFunnel(_, (_: _) => {
                if (!fs.exists(s, _, _)) {
                    try {
                        fs.mkdir(s, _);
                    } catch (err) {
                        result = false;
                    }
                }
            });
        }
        return result;
    }

    // Recursively removes a folder
    function rm(_: _, fileOrFolderName: string) {
        if (!fs.exists(fileOrFolderName, _, _)) {
            return;
        }
        var stat = fs.stat(fileOrFolderName, _);
        if (stat.isDirectory()) {
            // Folder
            fs.readdir(fileOrFolderName, _).forEach_(_, function (_, f) {
                rm(_, path.join(fileOrFolderName, f));
            });
            try {
                fs.rmdir(fileOrFolderName, _);
                trace && trace("Remove folder " + fileOrFolderName);
            } catch (err) {
                // The folder could not be deleted. This will happen when the folder contains some special
                // files that were not deleted (.gitignore, .gitattributes, ...)
            }
        } else {
            // File
            if (fileOrFolderName.endsWith('.gitignore') ||
                fileOrFolderName.endsWith('.gitattributes') ||
                fileOrFolderName.endsWith('.gitmodules')) {
                // Leave git files (.gitIgnore, .gitAttribues, ...)
            } else {
                trace && trace("Remove file " + fileOrFolderName);
                fs.unlink(fileOrFolderName, _);
            }
        }
    }

    function trim(obj: any, tableMeta: TableMeta, options: TrimOptions) {

        options = options || {};

        var result = Object.keys(obj).reduce(function (o, k) {
            var v = obj[k];
            if (/^CAST\(AUUID_0/.test(k)) {
                k = "AUUID_0";
            }
            if (v.iLob && v.iLob.read) {
                // oracle LOB
                v = require('f-oracle').lobReader(v).readAll();
            }
            var colShortName = k.substring(0, k.lastIndexOf('_'));

            var columnMeta: ColumnMeta;
            if (tableMeta) {
                columnMeta = tableMeta.columns[colShortName];
            }

            var isArray = (obj[colShortName + '_1'] !== undefined);
            if (isArray) {
                // We assume that the items will be in the right order XXX_0, XXX_1, XXX_2, ...
                o[colShortName] = o[colShortName] || [];
                o[colShortName].push(options.formatValues ? encodeValueToJsonString(v, columnMeta, driver) : v);
            } else {
                // Note : we keep all the values, including 0 and " " because these values will be needed
                // when transforming json files into .dat files
                o[colShortName] = options.formatValues ? encodeValueToJsonString(v, columnMeta, driver) : v;
            }
            return o;
        }, {} as any);
        return result;
    }

    function executeSql(_: _, sql: string, args: any[], tableMeta: TableMeta, options: ExecuteOptions) {
        // trace && trace("SQL: " + sql + "\nARGS: ",args);
        try {
            return driver.reader(sql, args)
                .map(record => trim(record, tableMeta, options)).toArray();
        } catch (ex) {
            console.error(ex.stack);
            throw new Error(locale.format(module, "sqlError", ex.message, sql, args));
        }
    }

    function buildKey(keys: string | string[], where?: boolean) {
        if (!Array.isArray(keys)) {
            keys = keys.split(',');
        }
        return keys.map(function (c, i) {
            if (where) {
                return c + '_0=' + driver.param(i);
            } else {
                return (~keys.indexOf('_0') ? c : c + '_0');
            }
        }).join(where ? ' and ' : ',');
    }

    function buildExecute(_: _, tableMeta: TableMeta, select: string | string[], tableName: string, orderBy: string | string[] = [], keys: any, where?: string, options?: ExecuteOptions) {
        options = options || {};

        var pkColumns = Object.keys(keys || {});
        if (!Array.isArray(select)) {
            select = select.split(',');
        }
        if (!~select[0].indexOf('_0')) {
            select = buildKey(select);
        }
        if (!where && keys) {
            where = pkColumns.join(',');
        }
        // trace && trace(tableName, orderBy, keys, where);
        var sqlQuery = "select " + select + " from " + tableName;
        if (where) {
            sqlQuery += " where " + buildKey(where, true);
        }
        if (options.groupBy) {
            sqlQuery += " group by " + buildKey(options.groupBy);
        }
        if (!Array.isArray(orderBy))
            orderBy = orderBy.split(",");
        if (orderBy.length > 0)
            sqlQuery += " order by " + buildKey(orderBy);
        var args: any[];
        if (keys) {
            args = pkColumns.map(c => keys[c] || '');
        } else {
            args = [];
        }
        //console.log("\t>>>> " + sqlQuery + "    ///   " + JSON.stringify(args));		
        var results = executeSql(_, sqlQuery, args, tableMeta, options);

        if (tableMeta && tableMeta.extraTables && tableMeta.extraTables.ATEXTRA) {
            if (!options.entityDescriptor)
                throw new Error("Entity descriptor is missing");
            if (!options.entityDescriptor.primaryKey && !options.entityDescriptor.distinctKey) {
                // primaryKey === undefined on child entities
                throw new Error("DistinctKey is missing on '" + options.entityDescriptor.tableName + "'");
            }
            results.forEach_(_, function (_, result) {
                var colNames = Object.keys(tableMeta.extraTables.ATEXTRA.columns);
                driver.withConnection(function (cnx) {
                    colNames.forEach(function (colName) {
                        var sqlParams = [
                            tableMeta.tableName,
                            colName,
                        ];
                        const colDef = tableMeta.extraTables.ATEXTRA.columns[colName];
                        var getAtextraIndicesFunction: (obj: any, texts: Text[]) => any = undefined;

                        // A getAtextraIndicesXXXXX function can be used for dimensioned atextra columns
                        // to compute the index of atextra rows.
                        getAtextraIndicesFunction = options.entityDescriptor["getAtextraIndices" + colName];

                        var keysToUse: any;
                        if (options.entityDescriptor.dummyObject) {
                            // A dummy object must have 1 (and only 1) child. This child defines the full
                            // PK to use. 
                            const firstChild = options.entityDescriptor.children[Object.keys(options.entityDescriptor.children)[0]];
                            keysToUse = firstChild.distinctKey;
                        } else
                            keysToUse = options.entityDescriptor.primaryKey || options.entityDescriptor.distinctKey;
                        if (!Array.isArray(keysToUse))
                            keysToUse = keysToUse.split(',');
                        // Force it to string (for instance ATABTAB has a numeric PK ... (NUMTAB))
                        var idents: Idents = {
                            ident1: "" + decodeValueFromJsonString(undefined, result[keysToUse[0]]).value,
                        };

                        var txtQuery = "select LANGUE_0 LANG, TEXTE_0 TEXT, IDENT1_0 IDENT1, IDENT2_0 IDENT2 " +
                            "from ATEXTRA where CODFIC_0 = " + driver.param(0) + " AND ZONE_0 = " + driver.param(1);

                        if (keysToUse.length > 1) {
                            if (getAtextraIndicesFunction) {
                                // We will query all the atextra, only filtered by the ident1_0. 
                                // The parse function will then be used to filter the atextras to keep.
                            } else {
                                // Force it to string (for instance ATABTAB has a numeric PK ... (NUMTAB))
                                idents.ident2 = "" + decodeValueFromJsonString(undefined, result[keysToUse[1]]).value;
                            }
                        } else {
                            if (options.entityDescriptor.primaryKey) {
                                // Query on a main object (ATABLE for instance)
                            } else {
                                // Query on a child object (ATABZON for instance - child object of ATABLE)
                                if (getAtextraIndicesFunction) {
                                    // We will query all the atextra, only filtered by the ident1_0. 
                                    // The parse function will then be used to filter the atextras to keep.
                                } else {
                                    idents.ident2 = ' ';
                                }
                            }
                        }

                        var overrideAtextraIdents = options.entityDescriptor["overrideAtextraIdents" + colName];
                        if (overrideAtextraIdents) {
                            overrideAtextraIdents(jsonHelper.decodeObject(result), idents);
                        }

                        if (idents.hasOwnProperty('ident1')) {
                            txtQuery += " AND IDENT1_0 = " + driver.param(2);
                            sqlParams.push(idents.ident1 === '' ? ' ' : idents.ident1);
                            if (idents.hasOwnProperty('ident2')) {
                                txtQuery += " AND IDENT2_0 = " + driver.param(3);
                                sqlParams.push(idents.ident2 === '' ? ' ' : idents.ident2);
                            }
                        }

                        txtQuery += " ORDER BY IDENT1, IDENT2, LANG";

                        var texts = driver.execute(cnx, txtQuery, sqlParams) as Text[];

                        if (getAtextraIndicesFunction) {
                            // All the atextra are now only filtered from their IDENT1 (see above)
                            // We now need to call the user-defined function that will provide us
                            // with the index of each atextra row.
                            var resultFn = getAtextraIndicesFunction(jsonHelper.decodeObject(result), texts);
                            texts = texts.filter(function (text: Text) {
                                const index = resultFn[text.IDENT2];
                                if (index === undefined) {
                                    // this atextra row does not concern the current object
                                    return false;
                                }
                                text.index = index;
                                return true;
                            });
                        }

                        result[MARK_extraTables] = result[MARK_extraTables] || {};
                        result[MARK_extraTables].ATEXTRA = result[MARK_extraTables].ATEXTRA || {};
                        result[MARK_extraTables].ATEXTRA[colName] = []

                        var currentZone: Idents = undefined;
                        var currentIdents: Idents = undefined;
                        texts.forEach(function (text) {
                            if (currentIdents && (currentIdents.ident1 === text.IDENT1) && (currentIdents.ident2 === text.IDENT2)) {
                                // Append the current zone with a new translation (a new lang).
                                // For instance, the previous row was defining the text for lang='ENG' and the current defines the text for lang='FRA'
                            } else {
                                // A new zone							
                                currentIdents = {
                                    ident1: text.IDENT1,
                                    ident2: text.IDENT2,
                                };
                                currentZone = {
                                    ident1: text.IDENT1 === " " ? "" : text.IDENT1,
                                    ident2: text.IDENT2 === " " ? "" : text.IDENT2,
                                    texts: {},
                                };
                                if (text.index !== undefined)
                                    currentZone.index = text.index;
                                result[MARK_extraTables].ATEXTRA[colName].push(currentZone);
                            }
                            currentZone.texts[text.LANG] = (text.TEXT === " " ? "" : text.TEXT);
                        });
                        // Now, sort the ATEXTRAs by (ident1, index) or (ident1, ident2)
                        result[MARK_extraTables].ATEXTRA[colName].sort((i1: any, i2: any) => {
                            function compareValues(v1: any, v2: any) {
                                if (isFinite(v1) && isFinite(v2)) {
                                    // The 2 values are numbers, sort them as numbers
                                    // otherwise "10" would be before "2"
                                    return parseInt(v1) - parseInt(v2);
                                }
                                return v1.localeCompare(v2);
                            }
                            var c = compareValues(i1.ident1, i2.ident1);
                            if (c !== 0)
                                return c;
                            if ((i1.index !== undefined) && (i2.index !== undefined)) {
                                c = compareValues(i1.index, i2.index);
                                if (c !== 0)
                                    return c;
                            }
                            return compareValues(i1.ident2, i2.ident2);
                        });
                    });
                });
            });
        }
        return results;
    }

    /// Write a JSON file and returs the ABSOLUTE filename that was written
    function writeResource(_: _, res: Resource) {
        var absoluteFolder = config.outputFolder;
        res.path.split(path.sep).forEach_(_, function (_, s) {
            absoluteFolder = path.join(absoluteFolder, s);
            if (!mkdir(_, absoluteFolder)) {
                throw new Error(locale.format(module, "couldNotCreateFolder", absoluteFolder));
            }
        });
        // Note : we add a leading underscore '_' to the name to avoid conflict with some reserved names
        // on Windows (sth like CON, PRN, AUX, NUL, ....)
        var absoluteFilename = path.join(absoluteFolder, '_' + res.fileName + ".json");
        try {
            var newMeta = JSON.stringify(res.data, null, '\t');
            if (fs.exists(absoluteFilename, _, _)) {
                const content = fs.readFile(absoluteFilename, 'utf8', _);
                var prevMeta = JSON.stringify(JSON.parse(content), null, '\t');
                if (filterMeta(newMeta) === filterMeta(prevMeta)) {
                    trace && trace(locale.format(module, "noChangesDetected", absoluteFilename));
                    return undefined;
                }
            }
            fs.writeFile(absoluteFilename, newMeta, "utf8", _);
        } catch (ex) {
            console.error(ex.stack);
        }
        return absoluteFilename;
    }

    return {
        config: config,
        trace: trace,
        product: undefined as any,
        sqlDriver: driver,
        init(_: _, tracker: Tracker) {
            var msg = "Creating output: " + config.outputFolder;
            trace && trace(msg);
            if (tracker) {
                tracker.phase = msg;
            }

            if (!mkdir(_, config.outputFolder)) {
                trace && trace(locale.format(module, "couldNotCreateFolder", config.outputFolder));
                return false;
            }
            // Retrieve the product (0=SUPERV, ...)
            const folderType = parseInt(buildExecute(_, undefined, "VALEUR", "ADOVAL", undefined, {
                "PARAM": "TYPDOS"
            })[0].VALEUR);
            this.product = productsHelper.getProductFromFolderType(folderType);
            return true;
        },
        clean(_: _, tracker: Tracker) {
            var msg = locale.format(module, "cleaningOutput", config.outputFolder);
            trace && trace(msg);
            if (tracker) {
                tracker.phase = msg;
            }
            fs.readdir(config.outputFolder, _).forEach_(_, function (_, folderName) {
                if (folderName !== '.git') {
                    rm(_, path.join(config.outputFolder, folderName));
                }
            });
        },
        release(_: _) {
            driver.release();
        },
        getTableMeta(_: _, tableName: string, excludedColumnNames: string[] = []) {
            var meta = {
                tableName: tableName,
                columns: {} as Dict<any>,
                extraTables: undefined as any,
            };
            trace && trace(locale.format(module, "loadingColDef", tableName));
            var query = "select TZ.CODZONE_0 ZONCOD, TZ.DIME_0 ZONDIM, TZ.CODTYP_0 ZONCODTYP, TZ.OPTION_0 ZONOPT";
            query += ",TP.TYPTYP_0 TYPTYP, TP.OPTION_0 TYPOPT, TP.TYPSELSYR_0 TYPSELSYR, TP.CODCLA_0 TYPCLA";
            query += " from ATABZON TZ";
            query += " left join ATYPE TP ON TP.CODTYP_0 = TZ.CODTYP_0";
            query += " where CODFIC_0 = '" + tableName + "'";
            query += " order by CODZONE_0";

            interface Row {
                ZONCOD: string;
                ZONDIM: number;
                TYPTYP: number;
                ZONCODTYP: string;
                ZONOPT: string;
                TYPOPT: string;
                TYPSELSYR: number;
                TYPCLA: string;
            }
            driver.withConnection(cnx => {
                var rows = driver.execute(cnx, query) as Row[];
                rows.forEach(row => {
                    if (~excludedColumnNames.indexOf(row.ZONCOD)) {
                        return;
                    }

                    var colDef = {
                        columnName: row.ZONCOD,
                        dimension: row.ZONDIM,
                        type: row.TYPTYP, // 1 = local menu, 2 = short integer, 3 = long integer, 4 = decimal, 5 = floating, 6 = double, 7 = string, ...
                        codeType: row.ZONCODTYP, // AX1, AY, ...
                        option: undefined as string,
                    };
                    if (row.ZONOPT && row.ZONOPT.trim().length) {
                        colDef.option = row.ZONOPT.trim();
                    } else if (row.TYPOPT && row.TYPOPT.trim().length) {
                        colDef.option = row.TYPOPT.trim();
                    }
                    var extraTable: string = undefined;
                    if (row.TYPSELSYR == 2) {
                        // type = reference
                        if (row.TYPCLA == 'ATEXTRA') {
                            // The texts for this column are stored in the ATEXTRA table
                            // The type of the column is sth like AX1, AX2, AX3, AXX, ...
                            extraTable = 'ATEXTRA';
                        }
                    }
                    if (extraTable) {
                        if (!meta.extraTables) {
                            meta.extraTables = {};
                        }
                        if (!meta.extraTables[extraTable]) {
                            meta.extraTables[extraTable] = {
                                tableName: extraTable,
                                columns: {}
                            };
                        }
                        meta.extraTables[extraTable].columns[colDef.columnName] = colDef;
                    } else {
                        meta.columns[colDef.columnName] = colDef;
                    }
                });
            });
            return meta;
        },

        getTableColumns(_: _, tableName: string, excludedColumnNames: string[]) {
            trace && trace(locale.format(module, "loadingColumns", tableName));
            return buildExecute(_, undefined, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
                'CODFIC': tableName
            }).map(function (elt) {
                if (~excludedColumnNames.indexOf(elt.CODZONE)) {
                    return;
                }
                var arr = [] as string[];
                for (var i = 0; i < elt.DIME; i++) {
                    var s = elt.CODZONE + '_' + i;
                    if (s === "AUUID_0" && sqlConfig.driver === "oracle") {
                        s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver
                    }
                    if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) {
                        arr.push(s);
                    }
                }
                return arr.join(',');
            }).filter(function (s) {
                return s;
            });
        },
        buildExecute: buildExecute,
        writeResource: writeResource,
        objVals(_: _, elt: any, objectTypes: any) {
            return Object.keys(elt).map_(_, function (_, k) {
                return (objectTypes && objectTypes[elt[k]] ? objectTypes[elt[k]] : elt[k]);
            }).join(' ');
        },

        // List the metadata files for a given entity
        // returns an object {xx: yy, ...} where xx is the entityName and yy the absolute filename
        listMetadataFiles(_: _, entity: Descriptor) {
            const entityDir = path.join(config.outputFolder, this.product.name, entity.subdir);

            if (!fs.exists(entityDir, _, _))
                return {};
            try {
                return fs.readdir(entityDir, _).reduce_(_, function (_, r, f) {
                    const filename = path.join(entityDir, f);
                    if (fs.stat(filename, _).isFile() && f.toLowerCase().endsWith('.json')) {
                        r[path.basename(filename, '.json').substring(1).toUpperCase()] = filename;
                    }
                    return r;
                }, {} as any);
            } catch (err) {
                console.log("ERROR", err);
                return {};
            }
        }
    };
};