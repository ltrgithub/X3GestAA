"use strict";

var locale = require('streamline-locale'),
	fs = require('streamline-fs'),
	jsonHelper = require('scm-lib/jsonHelper'),
	path = require('path'),
	flows = require('streamline-runtime').flows,
	encodeValueToJsonString = require('scm-lib/jsonHelper').encodeValueToJsonString,
	decodeValueFromJsonString = require('scm-lib/jsonHelper').decodeValueFromJsonString,
	getAllEntityDescriptors = require('scm-lib/resourceManager').getAllEntityDescriptors,
	productsHelper = require('scm-lib/productsHelper');

exports.newExporter = function(_, config) {
	const MARK_extraTables = "##extraTables##";
	var trace = config.trace;
	config.langs = config.langs || ["ENG", "FRA"];
	var sqlConfig = config.etnaConfig.sql;
	if (!sqlConfig) {
		throw new Error(locale.format(module, "sqlConfigMissing"));
	}
	var driver = require('etna/lib/engine/drivers/' + sqlConfig.driver).create(sqlConfig);
	var fsFunnel = flows.funnel(1);

	// Creates a directory and returns whether the creation succeeded
	function mkdir(_, s) {
		var result = true;
		if (!fs.exists(s, _)) {
			fsFunnel(_, function(_) {
				if (!fs.exists(s, _)) {
					try {
						fs.mkdir(s, _);
					} catch (err) {
						result = false;
					}
				}
			});
		}
		return result;
	}

	// Recursively removes a folder
	function rm(_, fileOrFolderName) {
		if (!fs.exists(fileOrFolderName, _)) {
			return;
		}
		var stat = fs.stat(fileOrFolderName, _);
		if (stat.isDirectory()) {
			// Folder
			fs.readdir(fileOrFolderName, _).forEach_(_, function(_, f) {
				rm(_, path.join(fileOrFolderName, f));
			});
			try {
				fs.rmdir(fileOrFolderName, _);
				trace && trace("Remove folder " + fileOrFolderName);
			} catch (err) {
				// The folder could not be deleted. This will happen when the folder contains some special
				// files that were not deleted (.gitignore, .gitattributes, ...)
			}
		} else {
			// File
			if (fileOrFolderName.endsWith('.gitignore') ||
				fileOrFolderName.endsWith('.gitattributes') ||
				fileOrFolderName.endsWith('.gitmodules')) {
				// Leave git files (.gitIgnore, .gitAttribues, ...)
			} else {
				trace && trace("Remove file " + fileOrFolderName);
				fs.unlink(fileOrFolderName, _);
			}
		}
	}

	function trim(_, obj, tableMeta, options) {

		options = options || {};

		var result = Object.keys(obj).reduce_(_, function(_, o, k) {
			var v = obj[k];
			if (/^CAST\(AUUID_0/.test(k)) {
				k = "AUUID_0";
			}
			if (v.iLob && v.iLob.read) {
				// oracle LOB
				v = require('ez-oracle').lob.reader(v).readAll(_);
			}
			var colShortName = k.substring(0, k.lastIndexOf('_'));

			var columnMeta;
			if (tableMeta) {
				columnMeta = tableMeta.columns[colShortName];
			}

			var isArray = (obj[colShortName + '_1'] !== undefined);
			if (isArray) {
				// We assume that the items will be in the right order XXX_0, XXX_1, XXX_2, ...
				o[colShortName] = o[colShortName] || [];
				o[colShortName].push(options.formatValues ? encodeValueToJsonString(v, columnMeta, driver) : v);
			} else {
				// Note : we keep all the values, including 0 and " " because these values will be needed
				// when transforming json files into .dat files
				o[colShortName] = options.formatValues ? encodeValueToJsonString(v, columnMeta, driver) : v;
			}
			return o;
		}, {});
		return result;
	}

	function executeSql(_, sql, args, tableMeta, options) {
		// trace && trace("SQL: " + sql + "\nARGS: ",args);
		try {
			return driver.reader(_, sql, args).map(function(_, record) {
				return trim(_, record, tableMeta, options);
			}).toArray(_);
		} catch (ex) {
			console.error(ex.stack);
			throw new Error(locale.format(module, "sqlError", ex.message, sql, args));
		}
	}

	function buildKey(_, keys, where) {
		if (!Array.isArray(keys)) {
			keys = keys.split(',');
		}
		return keys.map_(_, function(_, c, i) {
			if (where) {
				return c + '_0=' + driver.param(i);
			} else {
				return (~keys.indexOf('_0') ? c : c + '_0');
			}
		}).join(where ? ' and ' : ',');
	}

	function buildExecute(_, tableMeta, select, tableName, orderBy, keys, where, options) {
		options = options || {};
		var pkColumns = Object.keys(keys || {});
		if (!Array.isArray(select)) {
			select = select.split(',');
		}
		if (!~select[0].indexOf('_0')) {
			select = buildKey(_, select);
		}
		if (!where && keys) {
			where = pkColumns.join(',');
		}
		// trace && trace(tableName, orderBy, keys, where);
		var sqlQuery = "select " + select + " from " + tableName;
		if (where) {
			sqlQuery += " where " + buildKey(_, where, 1);
		}
		if (options.groupBy) {
			sqlQuery += " group by " + buildKey(_, options.groupBy);
		}
		if (orderBy) {
			if (!Array.isArray(orderBy))
				orderBy = orderBy.split(",");
			sqlQuery += " order by " + buildKey(_, orderBy);
		}
		var args;
		if (keys) {
			args = pkColumns.map_(_, function(_, c) {
				return keys[c] || '';
			});
		} else {
			args = [];
		}
		//console.log("\t>>>> " + sqlQuery + "    ///   " + JSON.stringify(args));		
		var results = executeSql(_, sqlQuery, args, tableMeta, options);

		if (tableMeta && tableMeta.extraTables && tableMeta.extraTables.ATEXTRA) {
			if (!options.entityDescriptor)
				throw new("Entity descriptor is missing");
			if (!options.entityDescriptor.primaryKey && !options.entityDescriptor.distinctKey) {
				// primaryKey === undefined on child entities
				throw new Error("DistinctKey is missing on '" + options.entityDescriptor.tableName + "'");
			}
			results.forEach_(_, function(_, result) {
				var colNames = Object.keys(tableMeta.extraTables.ATEXTRA.columns);
				driver.withConnection(_, function(_, cnx) {
					colNames.forEach_(_, function(_, colName) {
						var sqlParams = [
							tableMeta.tableName,
							colName,
						];
						const colDef = tableMeta.extraTables.ATEXTRA.columns[colName];
						var getAtextraIndicesFunction = undefined;

						// A getAtextraIndicesXXXXX function can be used for dimensioned atextra columns
						// to compute the index of atextra rows.
						getAtextraIndicesFunction = options.entityDescriptor["getAtextraIndices" + colName];

						var keysToUse;
						if (options.entityDescriptor.dummyObject) {
							// A dummy object must have 1 (and only 1) child. This child defines the full
							// PK to use. 
							const firstChild = options.entityDescriptor.children[Object.keys(options.entityDescriptor.children)[0]];
							keysToUse = firstChild.distinctKey;
						} else
							keysToUse = options.entityDescriptor.primaryKey || options.entityDescriptor.distinctKey;
						if (!Array.isArray(keysToUse))
							keysToUse = keysToUse.split(',');
						// Force it to string (for instance ATABTAB has a numeric PK ... (NUMTAB))
						var idents = {
							ident1: "" + decodeValueFromJsonString(undefined, result[keysToUse[0]]).value,
						};

						var txtQuery = "select LANGUE_0 LANG, TEXTE_0 TEXT, IDENT1_0 IDENT1, IDENT2_0 IDENT2 " +
							"from ATEXTRA where CODFIC_0 = " + driver.param(0) + " AND ZONE_0 = " + driver.param(1);

						if (keysToUse.length > 1) {
							if (getAtextraIndicesFunction) {
								// We will query all the atextra, only filtered by the ident1_0. 
								// The parse function will then be used to filter the atextras to keep.
							} else {
								// Force it to string (for instance ATABTAB has a numeric PK ... (NUMTAB))
								idents.ident2 = "" + decodeValueFromJsonString(undefined, result[keysToUse[1]]).value;
							}
						} else {
							if (options.entityDescriptor.primaryKey) {
								// Query on a main object (ATABLE for instance)
							} else {
								// Query on a child object (ATABZON for instance - child object of ATABLE)
								if (getAtextraIndicesFunction) {
									// We will query all the atextra, only filtered by the ident1_0. 
									// The parse function will then be used to filter the atextras to keep.
								} else {
									idents.ident2 = ' ';
								}
							}
						}

						var overrideAtextraIdents = options.entityDescriptor["overrideAtextraIdents" + colName];
						if (overrideAtextraIdents) {
							overrideAtextraIdents(jsonHelper.decodeObject(result), idents);
						}

						if (idents.hasOwnProperty('ident1')) {
							txtQuery += " AND IDENT1_0 = " + driver.param(2);
							sqlParams.push(idents.ident1 === '' ? ' ' : idents.ident1);
							if (idents.hasOwnProperty('ident2')) {
								txtQuery += " AND IDENT2_0 = " + driver.param(3);
								sqlParams.push(idents.ident2 === '' ? ' ' : idents.ident2);
							}
						}

						txtQuery += " ORDER BY IDENT1, IDENT2, LANG";

						var texts = driver.execute(_, cnx, txtQuery, sqlParams);

						if (getAtextraIndicesFunction) {
							// All the atextra are now only filtered from their IDENT1 (see above)
							// We now need to call the user-defined function that will provide us
							// with the index of each atextra row.
							var resultFn = getAtextraIndicesFunction(jsonHelper.decodeObject(result), texts);
							texts = texts.filter(function(text) {
								const index = resultFn[text.IDENT2];
								if (index === undefined) {
									// this atextra row does not concern the current object
									return false;
								}
								text.index = index;
								return true;
							});
						}

						result[MARK_extraTables] = result[MARK_extraTables] || {};
						result[MARK_extraTables].ATEXTRA = result[MARK_extraTables].ATEXTRA || {};
						result[MARK_extraTables].ATEXTRA[colName] = []

						var currentZone = undefined;
						var currentIdents = undefined;
						texts.forEach(function(text) {
							if (currentIdents && (currentIdents.ident1 === text.IDENT1) && (currentIdents.ident2 === text.IDENT2)) {
								// Append the current zone with a new translation (a new lang).
								// For instance, the previous row was defining the text for lang='ENG' and the current defines the text for lang='FRA'
							} else {
								// A new zone							
								currentIdents = {
									ident1: text.IDENT1,
									ident2: text.IDENT2,
								};
								currentZone = {
									ident1: text.IDENT1 === " " ? "" : text.IDENT1,
									ident2: text.IDENT2 === " " ? "" : text.IDENT2,
									texts: {},
								};
								if (text.index !== undefined)
									currentZone.index = text.index;
								result[MARK_extraTables].ATEXTRA[colName].push(currentZone);
							}
							currentZone.texts[text.LANG] = (text.TEXT === " " ? "" : text.TEXT);
						});
						// Now, sort the ATEXTRAs by (ident1, index) or (ident1, ident2)
						result[MARK_extraTables].ATEXTRA[colName].sort(function(i1, i2) {
							function compareValues(v1, v2) {
								if (isFinite(v1) && isFinite(v2)) {
									// The 2 values are numbers, sort them as numbers
									// otherwise "10" would be before "2"
									return parseInt(v1) - parseInt(v2);
								}
								return v1.localeCompare(v2);
							}
							var c = compareValues(i1.ident1, i2.ident1);
							if (c !== 0)
								return c;
							if ((i1.index !== undefined) && (i2.index !== undefined)) {
								c = compareValues(i1.index, i2.index);
								if (c !== 0)
									return c;
							}
							return compareValues(i1.ident2, i2.ident2);
						});
					});
				});
			});
		}
		return results;
	}

	/// Write a JSON file and returs the ABSOLUTE filename that was written
	function writeResource(_, res) {
		var absoluteFolder = config.outputFolder;
		res.path.split(path.sep).forEach_(_, function(_, s) {
			absoluteFolder = path.join(absoluteFolder, s);
			if (!mkdir(_, absoluteFolder)) {
				throw new Error(locale.format(module, "couldNotCreateFolder", absoluteFolder));
			}
		});
		// Note : we add a leading underscore '_' to the name to avoid conflict with some reserved names
		// on Windows (sth like CON, PRN, AUX, NUL, ....)
		var absoluteFilename = path.join(absoluteFolder, '_' + res.fileName + ".json");
		try {
			fs.writeFile(absoluteFilename, JSON.stringify(res.data, null, '\t'), "utf8", _);
		} catch (ex) {
			console.error(ex.stack);
		}
		return absoluteFilename;
	}

	return {
		config: config,
		trace: trace,
		product: undefined,
		init: function(_, tracker) {
			var msg = "Creating output: " + config.outputFolder;
			trace && trace(msg);
			if (tracker) {
				tracker.phase = msg;
			}

			if (!mkdir(_, config.outputFolder)) {
				trace && trace(locale.format(module, "couldNotCreateFolder", config.outputFolder));
				return false;
			}
			// Retrieve the product (0=SUPERV, ...)
			const folderType = parseInt(buildExecute(_, null, "VALEUR", "ADOVAL", null, {
				"PARAM": "TYPDOS"
			})[0].VALEUR);
			this.product = productsHelper.getProductFromFolderType(folderType);
			return true;
		},
		clean: function(_, tracker) {
			var msg = locale.format(module, "cleaningOutput", config.outputFolder);
			trace && trace(msg);
			if (tracker) {
				tracker.phase = msg;
			}
			fs.readdir(config.outputFolder, _).forEach_(_, function(_, folderName) {
				if (folderName !== '.git') {
					rm(_, path.join(config.outputFolder, folderName));
				}
			});
		},
		getTableMeta: function(_, tableName, excludedColumnNames) {
			var meta = {
				tableName: tableName,
				columns: {}
			};
			trace && trace(locale.format(module, "loadingColDef", tableName));
			var query = "select TZ.CODZONE_0 ZONCOD, TZ.DIME_0 ZONDIM, TZ.CODTYP_0 ZONCODTYP, TZ.OPTION_0 ZONOPT";
			query += ",TP.TYPTYP_0 TYPTYP, TP.OPTION_0 TYPOPT, TP.TYPSELSYR_0 TYPSELSYR, TP.CODCLA_0 TYPCLA";
			query += " from ATABZON TZ";
			query += " left join ATYPE TP ON TP.CODTYP_0 = TZ.CODTYP_0";
			query += " where CODFIC_0 = '" + tableName + "'";
			query += " order by CODZONE_0";

			driver.withConnection(_, function(_, cnx) {
				var rows = driver.execute(_, cnx, query);
				rows.forEach_(_, function(_, row) {
					if (excludedColumnNames && ~excludedColumnNames.indexOf(row.ZONCOD)) {
						return;
					}

					var colDef = {
						columnName: row.ZONCOD,
						dimension: row.ZONDIM,
						type: row.TYPTYP, // 1 = local menu, 2 = short integer, 3 = long integer, 4 = decimal, 5 = floating, 6 = double, 7 = string, ...
						codeType: row.ZONCODTYP, // AX1, AY, ...
					};
					if (row.ZONOPT && row.ZONOPT.trim().length) {
						colDef.option = row.ZONOPT.trim();
					} else if (row.TYPOPT && row.TYPOPT.trim().length) {
						colDef.option = row.TYPOPT.trim();
					}
					var extraTable = null;
					if (row.TYPSELSYR == 2) {
						// type = reference
						if (row.TYPCLA == 'ATEXTRA') {
							// The texts for this column are stored in the ATEXTRA table
							// The type of the column is sth like AX1, AX2, AX3, AXX, ...
							extraTable = 'ATEXTRA';
						}
					}
					if (extraTable) {
						if (!meta.extraTables) {
							meta.extraTables = {};
						}
						if (!meta.extraTables[extraTable]) {
							meta.extraTables[extraTable] = {
								tableName: extraTable,
								columns: {}
							};
						}
						meta.extraTables[extraTable].columns[colDef.columnName] = colDef;
					} else {
						meta.columns[colDef.columnName] = colDef;
					}
				});
			});
			return meta;
		},

		getTableColumns: function(_, tableName, excludedColumnNames) {
			trace && trace(locale.format(module, "loadingColumns", tableName));
			return buildExecute(_, null, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
				'CODFIC': tableName
			}).map(function(elt) {
				if (excludedColumnNames && ~excludedColumnNames.indexOf(elt.CODZONE)) {
					return;
				}
				var arr = [];
				for (var i = 0; i < elt.DIME; i++) {
					var s = elt.CODZONE + '_' + i;
					if (s === "AUUID_0" && sqlConfig.driver === "oracle") {
						s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver
					}
					if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) {
						arr.push(s);
					}
				}
				return arr.join(',');
			}).filter(function(s) {
				return s;
			});
		},
		buildExecute: buildExecute,
		writeResource: writeResource,
		objVals: function(_, elt, objectTypes) {
			return Object.keys(elt).map_(_, function(_, k) {
				return (objectTypes && objectTypes[elt[k]] ? objectTypes[elt[k]] : elt[k]);
			}).join(' ');
		}
	};
};