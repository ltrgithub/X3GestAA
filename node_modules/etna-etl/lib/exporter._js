"use strict";

var fs = require('streamline-fs'),
	path = require('path'),
	flows = require('streamline/lib/util/flows');

exports.newExporter = function(config) {
	var trace = config.trace;
	var db = config.db;
	if (!db) throw new Error("config.db missing");
	var driver = require('etna-supervisor/lib/drivers/' + db.driver)(db);

	var fsFunnel = flows.funnel(1);

	function mkdir(_, s) {
		if (!fs.exists(s, _)) {
			fsFunnel(_, function(_) {
				if (!fs.exists(s, _)) fs.mkdir(s, _);
			});
		}
	}

	function rm(_, s) {
		if (!fs.exists(s, _)) return;
		var stat = fs.stat(s, _);
		if (stat.isDirectory()) {
			fs.readdir(s, _).forEach_(_, function(_, f) {
				rm(_, s + '/' + f);
			});
			fs.rmdir(s, _);
		} else {
			fs.unlink(s, _);
		}
	}

	function trim(obj) {
		var result = Object.keys(obj).reduce(function(o, k) {
			var v = obj[k];
			if (v instanceof Date) {
				v = v.toISOString();
				if (/T00\:00\:00\.000Z$/.test(v)) {
					v = v.substring(0, v.length - 14);
					if (v === '1599-12-31') v = null;
				}
			}
			if (/^CAST\(AUUID_0/.test(k)) k = "AUUID_0";
			var kk = k.substring(0, k.lastIndexOf('_'));
			var isArray = (obj[kk + '_1'] !== undefined);
			if (isArray) {
				o[kk] = o[kk] || [];
				o[kk].push(v);
			} else {
				if (v && v !== ' ') o[kk] = v;
			}
			return o;
		}, {});
		Object.keys(result).forEach(function(k) {
			var v = result[k];
			if (Array.isArray(v)) {
				var len = v.length;
				while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
				result[k] = v.slice(0, len);
			}
		});
		return result;
	}

	function executeSql(_, sql, args) {
		//trace && trace("SQL: " + sql + "\nARGS: " + args);
		try {
			return driver.withConnection(_, function(_, cnx) {
				return driver.execute(_, cnx, sql, args).map(trim);
			});
		} catch (ex) {
			throw new Error("SQL error: " + ex.message + " while executing: " + sql + " with args: " + args);
		}
	}

	function buildKey(_, keys, where) {
		if (!Array.isArray(keys)) keys = keys.split(',');
		return keys.map_(_, function(_, c, i) {
			return where ? c + '_0=' + driver.param(i) : (~keys.indexOf('_0') ? c : c + '_0');
		}).join(where ? ' and ' : ',');
	}

	function buildExecute(_, select, tableName, orderBy, elt, where) {
		if (!Array.isArray(select) && !~select.indexOf('_0')) select = buildKey(_, select);
		if (!where && elt) where = Object.keys(elt).join(',');
		// trace && trace(tableName, orderBy, elt, where);
		return executeSql(_, "select " + select + " from " + tableName + //
			(where ? " where " + buildKey(_, where, 1) : '') + (orderBy ? " order by " + buildKey(_, orderBy) : ''), //
			(elt ? Object.keys(elt).map_(_, function(_, c) {
				return elt[c] || '';
			}) : []));
	}

	function writeResource(_, res) {
		var d = config.dir;
		res.path.split('/').forEach_(_, function(_, s) {
			mkdir(_, d = d + "/" + s);
		});
		fs.writeFile(d + "/" + res.name + ".json", JSON.stringify(res.data, null, '\t'), "utf8", _);
	}

	return {
		config: config,
		trace: trace,
		clean: function(_) {
			trace && trace("cleaning output: " + config.dir);
			mkdir(_, config.dir);
			fs.readdir(config.dir, _).forEach_(_, function(_, name) {
				if (name !== '.git') rm(_, config.dir + '/' + name);
			});
		},
		init: function(_) {
			trace && trace("getting folder type");
			var folderType = parseInt(buildExecute(_, "VALEUR", "ADOVAL", null, {
				"PARAM": "TYPDOS"
			})[0].VALEUR_0, 10);
			if (folderType !== 1 && !config.force) throw new Error("Bad folder type: " + folderType);
		},
		moduleNames: ["UNKNOWN", "SUPERV", "FINANCE", "BP", "EXTERNAL", //
			"SALES", "PURCHASES", "STOCKS", "CAPM", "COMMON", //
			"DEV", "INTERNAL", "SUPPORT", "MARKETING", "FA", //
			"HR", "SPE1", "SPE2", "SPE3", "SPE4", "TALENT"
		],
		getTableColumns: function(_, tableName) {
			trace && trace("loading columns for " + tableName);
			return buildExecute(_, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
				'CODFIC': tableName
			}).map(function(elt) {
				var arr = [];
				for (var i = 0; i < elt.DIME; i++) {
					var s = elt.CODZONE + '_' + i;
					if (s === "AUUID_0" && db.driver === "oracle") s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver
					if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) arr.push(s);
				}
				return arr.join(',');
			}).filter(function(s) {
				return s;
			});
		},
		buildExecute: buildExecute,
		writeResource: writeResource,
		objVals: function(_, elt, objectTypes) {
			return Object.keys(elt).map_(_, function(_, k) {
				return (objectTypes && objectTypes[elt[k]] ? objectTypes[elt[k]] : elt[k]);
			}).join(' ');
		}
	};
};

function getResource(_, folder) {
	var resPath = path.join(__dirname, folder);
	return fs.readdir(resPath, _).map_(_, function(_, filename) {
		return (/(.*)\.(_js)/).test(filename) ? require(path.join(resPath, filename)) : null;
	}).filter(function(file) {
		return file !== null;
	});
}

exports.exportMetadata = function(_, config, tracker) {
	config.trace = config.trace || console.log;
	var exporter = require("etna-etl/lib/exporter").newExporter({
		db: config.sql,
		trace: function(str) {
			if (tracker) tracker.phaseDetail = str;
			if (config.trace) config.trace(str);
		},
		dir: config.solutionPath + "/"  + config.folderName + "/META",
		force: true, // for now!
		parallel: 1,
	});

	if (tracker) tracker.phase = "cleaning";
	exporter.clean(_);
	if (tracker) tracker.phase = "initializing";
	exporter.init(_);

	var entityExporter = require("etna-etl/lib/export-entity");
	var entities = getResource(_, "entities");
	entities.forEach_(_, function(_, entityResource) {
		if (tracker && tracker.abortRequested) return;
		if (tracker) tracker.phase = "exporting " + entityResource.entity.title;
		entityExporter.run(_, exporter, entityResource.entity, tracker);
	});
	
	var textExporter = require("etna-etl/lib/export-text");
	var texts = getResource(_, "texts");
	texts.forEach_(_, function(_, textResource) {
		if (tracker && tracker.abortRequested) return;
		if (tracker) tracker.phase = "exporting " + textResource.text.title;
		textExporter.run(_, exporter, textResource.text, tracker);
	});
}

