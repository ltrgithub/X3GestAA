"use strict";

var fs = require('streamline-fs'),
	path = require('path'),
	supervisor = require("etna-supervisor/lib/supervisor"),
	flows = require('streamline/lib/util/flows');



exports.newExporter = function(_, config) {
	var trace = config.trace;
	// var sqlConfig = config.sql;
	// if (!sqlConfig) throw new Error("config.sql missing");
	// var driver = require('etna-supervisor/lib/drivers/' + sqlConfig.driver)(sqlConfig);
	var fsFunnel = flows.funnel(1);

	console.log(JSON.stringify(config.config));
	var superv = supervisor.create(_, config.config);
	var driver = superv.sqlDriver;

	function mkdir(_, s) {
		if (!fs.exists(s, _)) {
			fsFunnel(_, function(_) {
				if (!fs.exists(s, _)) fs.mkdir(s, _);
			});
		}
	}

	function rm(_, s) {
		if (!fs.exists(s, _)) return;
		trace && trace("Remove " + s);
		var stat = fs.stat(s, _);
		if (stat.isDirectory()) {
			fs.readdir(s, _).forEach_(_, function(_, f) {
				rm(_, s + '/' + f);
			});
			fs.rmdir(s, _);
		} else {
			fs.unlink(s, _);
		}
	}

	function trim(obj, tableMeta) {

		function transformValue(value, columnMeta) {
			if (columnMeta) {
				switch (columnMeta.type) {
					case 1: // local menu
						break;
					case 2: // short integer
						break;
					case 3: // long integer
						break;
					case 4: // decimal
						value = "N|" + value;
						break;
					case 5: // floating
						break;
					case 6: // double
						break;
					case 7: // string
						var out = "S";
						if (columnMeta.option)
							out += ":" + columnMeta.option;
						out += "|" + value;
						value = out;
						break;
					case 8: // date
						value = value.toISOString();
						// Just remove the 'time' part (should be 'T00:00:00.000Z')
						value = value.substring(0, value.length - 14);
						var date = new Date(Date.parse(value));
						if (driver.isNullDate(date))
							value = "D|NULL";
						else
							value = "D|" + value;
						break;
					case 9: // image file
						break;
					case 10: // text file
						var out = "C";
						out += "|" + value;
						value = out;
						break;
					case 11: // UUID
						break;
					case 12: // date time
						value = "T|" + value.toISOString();
						break;
					default:
						if (value instanceof String)
							console.log("Unhandled type " + columnMeta.type);
						break;
				}
			} else {
				if (value instanceof Date) {
					value = value.toISOString();
					if (/T00\:00\:00\.000Z$/.test(value)) {
						value = value.substring(0, value.length - 14);
						if (value === '1599-12-31') value = null;
					}
				}
			}
			return value;
		}

		var result = Object.keys(obj).reduce(function(o, k) {
			var v = obj[k];
			if (/^CAST\(AUUID_0/.test(k))
				k = "AUUID_0";
			var colShortName = k.substring(0, k.lastIndexOf('_'));

			var columnMeta;
			if (tableMeta) {
				columnMeta = tableMeta.columns[colShortName];
			}

			var isArray = (obj[colShortName + '_1'] !== undefined);
			if (isArray) {
				// We assume that the items will be in the right order XXX_0, XXX_1, XXX_2, ...
				o[colShortName] = o[colShortName] || [];
				o[colShortName].push(transformValue(v, columnMeta));
			} else {
				// Note : we keep all the values, including 0 and " " because these values will be needed
				// when transforming json files into .dat files
				o[colShortName] = transformValue(v, columnMeta);
			}
			return o;
		}, {});
		/*		
		Object.keys(result).forEach(function(k) {
			var v = result[k];
			if (Array.isArray(v)) {
				var len = v.length;
				while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
				result[k] = v.slice(0, len);
			}
		});
*/
		return result;
	}

	function executeSql(_, sql, args, tableMeta) {
		// trace && trace("SQL: " + sql + "\nARGS: " + args);
		try {
			return driver.withConnection(_, function(_, cnx) {
				return driver.execute(_, cnx, sql, args).map(
					function(item) {
						return trim(item, tableMeta);
					});
			});
		} catch (ex) {
			throw new Error("SQL error: " + ex.message + " while executing: " + sql + " with args: " + args);
		}
	}

	function buildKey(_, keys, where) {
		if (!Array.isArray(keys))
			keys = keys.split(',');
		return keys.map_(_, function(_, c, i) {
			if (where)
				return c + '_0=' + driver.param(i);
			else
				return (~keys.indexOf('_0') ? c : c + '_0');
		}).join(where ? ' and ' : ',');
	}

	function buildExecute(_, tableMeta, select, tableName, orderBy, elt, where, textLinks) {
		if (!Array.isArray(select) && !~select.indexOf('_0'))
			select = buildKey(_, select);
		if (!where && elt)
			where = Object.keys(elt).join(',');
		// trace && trace(tableName, orderBy, elt, where);
		var sqlQuery = "select " + select + " from " + tableName;
		if (where)
			sqlQuery += " where " + buildKey(_, where, 1);
		if (orderBy)
			sqlQuery += " order by " + buildKey(_, orderBy);
		var args;
		if (elt)
			args = Object.keys(elt).map_(_, function(_, c) {
				return elt[c] || '';
			});
		else
			args = [];
		// console.log(">>>> " + sqlQuery + "    ///   " + JSON.stringify(args));
		var results = executeSql(_, sqlQuery, args, tableMeta);
		// console.log(results);
		if (textLinks) {
			results.forEach_(_, function(_, result) {
				textLinks.forEach_(_, function(_, textLink) {
					result["##texts##"] = result["##texts##"] || {};
					if (result[textLink]) {
						result["##texts##"][textLink] = [];
						var textIds = Array.isArray(result[textLink]) ? result[textLink] : [result[textLink]];
						// We have to retrieve all the texts for this item
						// The texts are extracted from ATEXTE (where the NUMERO col matches the text-column of the entity,
						// INTITFIC_0 for ATABLE for instance)
						textIds.forEach_(_, function(_, textId, index) {
							var textResults = buildExecute(_, null, "LAN_0, TEXTE_0, COMMENT_0", "ATEXTE", null, {
								"NUMERO": textId
							});

							var textElt = {};
							result["##texts##"][textLink].push(textElt);
							textResults.forEach(function(langItem) {
								textElt[langItem["LAN"]] = langItem["TEXTE"];
								if (langItem["COMMENT"]) {
									result["##comments##"] = result["##comments##"] || {};
									result["##comments##"][textLink] = result["##comments##"][textLink] || [];
									result["##comments##"][textLink][index] = result["##comments##"][textLink][index] || {};
									result["##comments##"][textLink][index][langItem["LAN"]] = langItem["COMMENT"];
								}
							});
						});
					} else {
						// No texts are available for this item
						// We still write an info to inform readers that this item is a localized text.
						// for instance, this information will be used when building patches from json files.
						result["##texts##"][textLink] = [{}];
					}
				});
			});
		}
		if (tableMeta && tableMeta.extraTables && tableMeta.extraTables.ATEXTRA) {
			results.forEach_(_, function(_, result) {
				var cols = Object.keys(tableMeta.extraTables.ATEXTRA.columns);

				driver.withConnection(_, function(_, cnx) {
					var txtQuery = "select ZONE_0 ZONE, LANGUE_0 LANG, TEXTE_0 TEXT, IDENT1_0 IDENT1, IDENT2_0 IDENT2 from ATEXTRA where CODFIC_0 = " + driver.param(0) + " AND IDENT1_0 = " + driver.param(1);
					// Here, we assume that the first property of elt contains the PK of the table we are querying
					var txtParams = [tableMeta.name, elt[Object.keys(elt)[0]]];
					var texts = driver.execute(_, cnx, txtQuery, txtParams);
					if (!result["##extraTables##"])
						result["##extraTables##"] = {};
					if (!result["##extraTables##"].ATEXTRA)
						result["##extraTables##"].ATEXTRA = {};
					texts.forEach(function(text) {
						if (!result["##extraTables##"].ATEXTRA[text.ZONE])
							result["##extraTables##"].ATEXTRA[text.ZONE] = {};
						if (!result["##extraTables##"].ATEXTRA[text.ZONE][text.IDENT2])
							result["##extraTables##"].ATEXTRA[text.ZONE][text.IDENT2] = {};
						result["##extraTables##"].ATEXTRA[text.ZONE][text.IDENT2][text.LANG] = text.TEXT;
					});
				});
			});
		}
		return results;
	}



	function writeResource(_, res) {
		var relativeFolder = "";
		res.path.split('/').forEach_(_, function(_, s) {
			relativeFolder += "/" + s;
			mkdir(_, config.metaFolder + "/" + relativeFolder);
		});
		var relativeFilename = relativeFolder + "/" + res.name + ".json";
		try {
			fs.writeFile(config.metaFolder + "/" + relativeFilename, JSON.stringify(res.data, null, '\t'), "utf8", _);
		} catch (ex) {
			console.error(ex.stack);
		}
		return relativeFilename;
	}

	return {
		config: config,
		trace: trace,
		folderType: undefined,
		init: function(_, tracker) {
			var outputFolder = config.metaFolder;
			var msg = "Creating output: " + outputFolder;
			trace && trace(msg);
			if (tracker)
				tracker.phase = msg;

			mkdir(_, outputFolder);
			this.folderType = parseInt(buildExecute(_, null, "VALEUR", "ADOVAL", null, {
				"PARAM": "TYPDOS"
			})[0].VALEUR);
		},
		clean: function(_, tracker) {
			var outputFolder = config.metaFolder;
			var msg = "Cleaning output: " + outputFolder;
			trace && trace(msg);
			if (tracker)
				tracker.phase = msg;
			fs.readdir(outputFolder, _).forEach_(_, function(_, name) {
				if (name !== '.git')
					rm(_, outputFolder + "/" + name);
			});
		},
		check: function(_) {
			trace && trace("getting folder type");
			if (this.folderType !== 1 && !config.force) throw new Error("Bad folder type: " + this.folderType);
		},
		moduleNames: ["UNKNOWN", "SUPERV", "FINANCE", "BP", "EXTERNAL", //
			"SALES", "PURCHASES", "STOCKS", "CAPM", "COMMON", //
			"DEV", "INTERNAL", "SUPPORT", "MARKETING", "FA", //
			"HR", "SPE1", "SPE2", "SPE3", "SPE4", "TALENT"
		],
		getTableMeta: function(_, tableName, excludedColumnNames) {
			var meta = {
				name: tableName,
				columns: {}
			};
			trace && trace("loading columns for " + tableName);
			var query = "select TZ.CODZONE_0 ZONCOD, TZ.DIME_0 ZONDIM, TZ.CODTYP_0 ZONCODTYP, TZ.OPTION_0 ZONOPT";
			query += ",TP.TYPTYP_0 TYPTYP, TP.OPTION_0 TYPOPT, TP.TYPSELSYR_0 TYPSELSYR, TP.CODCLA_0 TYPCLA";
			query += " from ATABZON TZ";
			query += " left join ATYPE TP ON TP.CODTYP_0 = TZ.CODTYP_0";
			query += " where CODFIC_0 = '" + tableName + "'";
			query += " order by CODZONE_0";

			driver.withConnection(_, function(_, cnx) {
				var rows = driver.execute(_, cnx, query);
				rows.forEach_(_, function(_, row) {
					if (excludedColumnNames && ~excludedColumnNames.indexOf(row.ZONCOD))
						return;

					var colDef = {
						name: row.ZONCOD,
						dimension: row.ZONDIM,
						type: row.TYPTYP, // 1 = local menu, 2 = short integer, 3 = long integer, 4 = decimal, 5 = floating, 6 = double, 7 = string, ...
						codeType: row.ZONCODTYP, // AX1, AY, ...
					};
					if (row.ZONOPT && row.ZONOPT.trim().length)
						colDef.option = row.ZONOPT.trim();
					else if (row.TYPOPT && row.TYPOPT.trim().length)
						colDef.option = row.TYPOPT.trim();
					var extraTable = null;
					if (row.TYPSELSYR == 2) {
						// type = reference
						if (row.TYPCLA == 'ATEXTRA') {
							// This column is described in ATABZON but its content is not in the table itself but in ATEXTRA
							extraTable = 'ATEXTRA';
						}
					}
					if (extraTable) {
						if (!meta.extraTables)
							meta.extraTables = {};
						if (!meta.extraTables[extraTable])
							meta.extraTables[extraTable] = {
								name: extraTable,
								columns: {}
							};
						meta.extraTables[extraTable].columns[colDef.name] = colDef;
					} else
						meta.columns[colDef.name] = colDef;
				});
			});

			return meta;
			/*
			return buildExecute(_, null, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
				'CODFIC': tableName
			}).map(function(elt) {
				if (excludedColumnNames && ~excludedColumnNames.indexOf(elt.CODZONE))
					return;
				var arr = [];
				for (var i = 0; i < elt.DIME; i++) {
					var s = elt.CODZONE + '_' + i;
					if (s === "AUUID_0" && sqlConfig.driver === "oracle") s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver					
					if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) arr.push(s);
				}
				return arr.join(',');
			}).filter(function(s) {
				return s;
			});
*/
		},
		getTableColumns: function(_, tableName, excludedColumnNames) {
			trace && trace("loading columns for " + tableName);
			return buildExecute(_, null, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
				'CODFIC': tableName
			}).map(function(elt) {
				if (excludedColumnNames && ~excludedColumnNames.indexOf(elt.CODZONE))
					return;
				var arr = [];
				for (var i = 0; i < elt.DIME; i++) {
					var s = elt.CODZONE + '_' + i;
					if (s === "AUUID_0" && sqlConfig.driver === "oracle") s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver					
					if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) arr.push(s);
				}
				return arr.join(',');
			}).filter(function(s) {
				return s;
			});
		},
		buildExecute: buildExecute,
		writeResource: writeResource,
		objVals: function(_, elt, objectTypes) {
			return Object.keys(elt).map_(_, function(_, k) {
				return (objectTypes && objectTypes[elt[k]] ? objectTypes[elt[k]] : elt[k]);
			}).join(' ');
		}
	};
};

function getResources(_, folder) {
	var resPath = path.join(__dirname, folder);
	return fs.readdir(resPath, _).map_(_, function(_, filename) {
		return (/(.*)\.(_js)/).test(filename) ? require(path.join(resPath, filename)) : null;
	}).filter(function(file) {
		return file !== null;
	});
}

exports.exportMetadata = function(_, config, tracker) {
	config.trace = config.trace || console.log;
	var exporter = require("etna-etl/lib/exporter").newExporter(_, {
		config: config,
		trace: function(str) {
			if (tracker) tracker.phaseDetail = str;
			if (config.trace) config.trace(str);
		},
		dir: config.solutionPath + "/" + config.folderName + "/META",
		force: true, // for now!
		parallel: 1,
	});

	/*if (tracker) tracker.phase = "cleaning";
	exporter.clean(_);*/

	if (tracker) tracker.phase = "initializing";
	exporter.init(_);

	var entityExporter = require("etna-etl/lib/export-entity");
	var entities = getResources(_, "entities");
	entities.forEach_(_, function(_, entityResource) {
		if (tracker && tracker.abortRequested) return;
		if (tracker) tracker.phase = "exporting " + entityResource.entity.title;
		if (entityResource.entity.title === "contexts") {
			entityExporter.run(_, exporter, entityResource.entity, tracker);
		}
	});

	/* Text exporter are disabled for now, replaced by incremental syncs
	var textExporter = require("etna-etl/lib/export-text");
	var texts = getResources(_, "texts");
	texts.forEach_(_, function(_, textResource) {
		if (tracker && tracker.abortRequested) return;
		if (tracker) tracker.phase = "exporting " + textResource.text.title;
		textExporter.run(_, exporter, textResource.text, tracker);
	});
*/
};