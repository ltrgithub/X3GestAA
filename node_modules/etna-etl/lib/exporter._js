"use strict";

var fs = require('streamline-fs'),
	path = require('path'),
	supervisor = require("etna-supervisor/lib/supervisor"),
	flows = require('streamline/lib/util/flows');



exports.newExporter = function(_, config) {
	var trace = config.trace;
	// var sqlConfig = config.sql;
	// if (!sqlConfig) throw new Error("config.sql missing");
	// var driver = require('etna-supervisor/lib/drivers/' + sqlConfig.driver)(sqlConfig);
	var fsFunnel = flows.funnel(1);

	console.log(JSON.stringify(config.config));
	var superv = supervisor.create(_, config.config);
	var driver = superv.sqlDriver;

	function mkdir(_, s) {
		if (!fs.exists(s, _)) {
			fsFunnel(_, function(_) {
				if (!fs.exists(s, _)) fs.mkdir(s, _);
			});
		}
	}

	function rm(_, s) {
		if (!fs.exists(s, _)) return;
		trace && trace("Remove " + s);
		var stat = fs.stat(s, _);
		if (stat.isDirectory()) {
			fs.readdir(s, _).forEach_(_, function(_, f) {
				rm(_, s + '/' + f);
			});
			fs.rmdir(s, _);
		} else {
			fs.unlink(s, _);
		}
	}

	function trim(obj, tableDef) {

		function transformValue(value, columnDef) {
			if (columnDef) {
				switch (columnDef.type) {
					case "datetime":
						value = "T|" + value.toISOString();
						break;
					case "date":
						value = value.toISOString();
						// Just remove the 'time' part (should be 'T00:00:00.000Z')
						value = value.substring(0, value.length - 14);
						var date = new Date(Date.parse(value));
						if (driver.isNullDate(date))
							value = "D|NULL";
						else
							value = "D|" + value;
						break;
					case "decimal":
						value = "N|" + value;
						break;
					case "nvarchar":
						var out = "S";
						if (columnDef.typeOption)
							out += ":" + columnDef.typeOption;
						out += "|" + value;
						value = out;
						break;
					case "clob":
						var out = "C";
						out += "|" + value;
						value = out;
						break;
					default:
						if (value instanceof String)
							console.log("Unhandled type " + columnDef.type);
						break;
				}
			} else {
				if (value instanceof Date) {
					value = value.toISOString();
					if (/T00\:00\:00\.000Z$/.test(value)) {
						value = value.substring(0, value.length - 14);
						if (value === '1599-12-31') value = null;
					}
				}
			}
			return value;
		}

		var result = Object.keys(obj).reduce(function(o, k) {
			var v = obj[k];
			var columnDef;
			if (tableDef) {
				columnDef = tableDef.columns[k];
			}
			if (/^CAST\(AUUID_0/.test(k))
				k = "AUUID_0";
			var kk = k.substring(0, k.lastIndexOf('_'));
			var isArray = (obj[kk + '_1'] !== undefined);
			if (isArray) {
				// We assume that the items will be in the right order XXX_0, XXX_1, XXX_2, ...
				o[kk] = o[kk] || [];
				o[kk].push(transformValue(v, columnDef));
			} else {
				// Note : we keep all the values, including 0 and " " because these values will be needed
				// when transforming json files into .dat files
				o[kk] = transformValue(v, columnDef);
			}
			return o;
		}, {});
		/*		
		Object.keys(result).forEach(function(k) {
			var v = result[k];
			if (Array.isArray(v)) {
				var len = v.length;
				while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
				result[k] = v.slice(0, len);
			}
		});
*/
		return result;
	}

	function executeSql(_, sql, args, tableDef) {
		// trace && trace("SQL: " + sql + "\nARGS: " + args);
		try {
			return driver.withConnection(_, function(_, cnx) {
				return driver.execute(_, cnx, sql, args).map(
					function(item) {
						return trim(item, tableDef);
					});
			});
		} catch (ex) {
			throw new Error("SQL error: " + ex.message + " while executing: " + sql + " with args: " + args);
		}
	}

	function buildKey(_, keys, where) {
		if (!Array.isArray(keys))
			keys = keys.split(',');
		return keys.map_(_, function(_, c, i) {
			if (where)
				return c + '_0=' + driver.param(i);
			else
				return (~keys.indexOf('_0') ? c : c + '_0');
		}).join(where ? ' and ' : ',');
	}

	function buildExecute(_, context, select, tableName, orderBy, elt, where, textLinks) {
		var tableDef;
		if (context) {
			context.tableMetas = context.tableMetas || {};
			tableDef = context.tableMetas[tableName];
			if (!tableDef) {
				tableDef = {
					schemaName: superv.folderName,
					tableName: tableName
				};
				driver.readTableSchema(_, tableDef);
				context.tableMetas[tableName] = tableDef;
			}
		}
		if (!Array.isArray(select) && !~select.indexOf('_0'))
			select = buildKey(_, select);
		if (!where && elt)
			where = Object.keys(elt).join(',');
		// trace && trace(tableName, orderBy, elt, where);
		var sqlQuery = "select " + select + " from " + tableName;
		if (where)
			sqlQuery += " where " + buildKey(_, where, 1);
		if (orderBy)
			sqlQuery += " order by " + buildKey(_, orderBy);
		var args;
		if (elt)
			args = Object.keys(elt).map_(_, function(_, c) {
				return elt[c] || '';
			});
		else
			args = [];
		// console.log(">>>> " + sqlQuery + "    ///   " + JSON.stringify(args));
		var results = executeSql(_, sqlQuery, args, tableDef);
		// console.log(results);
		if (textLinks) {
			results.forEach_(_, function(_, result) {
				textLinks.forEach_(_, function(_, textLink) {
					result["##texts##"] = result["##texts##"] || {};
					if (result[textLink]) {
						result["##texts##"][textLink] = [];
						var textIds = Array.isArray(result[textLink]) ? result[textLink] : [result[textLink]];
						// We have to retrieve all the texts for this item
						// The texts are extracted from ATEXTE (where the NUMERO col matches the text-column of the entity,
						// INTITFIC_0 for ATABLE for instance)
						textIds.forEach_(_, function(_, textId, index) {
							var textResults = buildExecute(_, null, "LAN_0, TEXTE_0, COMMENT_0", "ATEXTE", null, {
								"NUMERO": textId
							});

							var textElt = {};
							result["##texts##"][textLink].push(textElt);
							textResults.forEach(function(langItem) {
								textElt[langItem["LAN"]] = langItem["TEXTE"];
								if (langItem["COMMENT"]) {
									result["##comments##"] = result["##comments##"] || {};
									result["##comments##"][textLink] = result["##comments##"][textLink] || [];
									result["##comments##"][textLink][index] = result["##comments##"][textLink][index] || {};
									result["##comments##"][textLink][index][langItem["LAN"]] = langItem["COMMENT"];
								}
							});
						});
					} else {
						// No texts are available for this item
						// We still write an info to inform readers that this item is a localized text.
						// for instance, this information will be used when building patches from json files.
						result["##texts##"][textLink] = [{}];
					}
				});
			});
		}
		return results;
	}

	function writeResource(_, res) {
		var relativeFolder = "";
		res.path.split('/').forEach_(_, function(_, s) {
			relativeFolder += "/" + s;
			mkdir(_, config.metaFolder + "/" + relativeFolder);
		});
		var relativeFilename = relativeFolder + "/" + res.name + ".json";
		try {
			fs.writeFile(config.metaFolder + "/" + relativeFilename, JSON.stringify(res.data, null, '\t'), "utf8", _);
		} catch (ex) {
			console.error(ex.stack);
		}
		return relativeFilename;
	}

	return {
		config: config,
		trace: trace,
		folderType: undefined,
		init: function(_, tracker) {
			var outputFolder = config.metaFolder;
			var msg = "Creating output: " + outputFolder;
			trace && trace(msg);
			if (tracker)
				tracker.phase = msg;

			mkdir(_, outputFolder);
			this.folderType = parseInt(buildExecute(_, null, "VALEUR", "ADOVAL", null, {
				"PARAM": "TYPDOS"
			})[0].VALEUR);
		},
		clean: function(_, tracker) {
			var outputFolder = config.metaFolder;
			var msg = "Cleaning output: " + outputFolder;
			trace && trace(msg);
			if (tracker)
				tracker.phase = msg;
			fs.readdir(outputFolder, _).forEach_(_, function(_, name) {
				if (name !== '.git')
					rm(_, outputFolder + "/" + name);
			});
		},
		check: function(_) {
			trace && trace("getting folder type");
			if (this.folderType !== 1 && !config.force) throw new Error("Bad folder type: " + this.folderType);
		},
		moduleNames: ["UNKNOWN", "SUPERV", "FINANCE", "BP", "EXTERNAL", //
			"SALES", "PURCHASES", "STOCKS", "CAPM", "COMMON", //
			"DEV", "INTERNAL", "SUPPORT", "MARKETING", "FA", //
			"HR", "SPE1", "SPE2", "SPE3", "SPE4", "TALENT"
		],
		getTableColumns: function(_, tableName, excludedColumnNames) {
			trace && trace("loading columns for " + tableName);
			return buildExecute(_, null, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
				'CODFIC': tableName
			}).map(function(elt) {
				if (excludedColumnNames && ~excludedColumnNames.indexOf(elt.CODZONE))
					return;
				var arr = [];
				for (var i = 0; i < elt.DIME; i++) {
					var s = elt.CODZONE + '_' + i;
					if (s === "AUUID_0" && sqlConfig.driver === "oracle") s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver					
					if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) arr.push(s);
				}
				return arr.join(',');
			}).filter(function(s) {
				return s;
			});
		},
		buildExecute: buildExecute,
		writeResource: writeResource,
		objVals: function(_, elt, objectTypes) {
			return Object.keys(elt).map_(_, function(_, k) {
				return (objectTypes && objectTypes[elt[k]] ? objectTypes[elt[k]] : elt[k]);
			}).join(' ');
		}
	};
};

function getResources(_, folder) {
	var resPath = path.join(__dirname, folder);
	return fs.readdir(resPath, _).map_(_, function(_, filename) {
		return (/(.*)\.(_js)/).test(filename) ? require(path.join(resPath, filename)) : null;
	}).filter(function(file) {
		return file !== null;
	});
}

exports.exportMetadata = function(_, config, tracker) {
	config.trace = config.trace || console.log;
	var exporter = require("etna-etl/lib/exporter").newExporter(_, {
		config: config,
		trace: function(str) {
			if (tracker) tracker.phaseDetail = str;
			if (config.trace) config.trace(str);
		},
		dir: config.solutionPath + "/" + config.folderName + "/META",
		force: true, // for now!
		parallel: 1,
	});

	/*if (tracker) tracker.phase = "cleaning";
	exporter.clean(_);*/

	if (tracker) tracker.phase = "initializing";
	exporter.init(_);

	var entityExporter = require("etna-etl/lib/export-entity");
	var entities = getResources(_, "entities");
	entities.forEach_(_, function(_, entityResource) {
		if (tracker && tracker.abortRequested) return;
		if (tracker) tracker.phase = "exporting " + entityResource.entity.title;
		if (entityResource.entity.title === "contexts") {
			entityExporter.run(_, exporter, entityResource.entity, tracker);
		}
	});

	/* Text exporter are disabled for now, replaced by incremental syncs
	var textExporter = require("etna-etl/lib/export-text");
	var texts = getResources(_, "texts");
	texts.forEach_(_, function(_, textResource) {
		if (tracker && tracker.abortRequested) return;
		if (tracker) tracker.phase = "exporting " + textResource.text.title;
		textExporter.run(_, exporter, textResource.text, tracker);
	});
*/
};