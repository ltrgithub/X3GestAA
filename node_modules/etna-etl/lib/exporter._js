"use strict";

var fs = require('streamline-fs'),
	path = require('path'),
	supervisor = require("etna-supervisor/lib/supervisor"),
	flows = require('streamline/lib/util/flows'),
	encodeValueToJsonString = require('bundles/scm-helper/lib/jsonHelper').encodeValueToJsonString,
	getAllEntityDescriptors = require('bundles/scm-helper/lib/resourceManager').getAllEntityDescriptors;


exports.newExporter = function(_, config) {
	var trace = config.trace;
	config.langs = config.langs || ["ENG", "FRA"];
	config.endpoint = config.endpoint || [];
	var sqlConfig = config.endpoint.sql;
	if (!sqlConfig)
		throw new Error("config.endpoint.sql missing ");
	var driver = require('etna-engine/lib/drivers/' + sqlConfig.driver)(sqlConfig);
	var fsFunnel = flows.funnel(1);

	function mkdir(_, s) {
		if (!fs.exists(s, _)) {
			fsFunnel(_, function(_) {
				if (!fs.exists(s, _)) fs.mkdir(s, _);
			});
		}
	}

	function rm(_, s) {
		if (!fs.exists(s, _))
			return;
		trace && trace("Remove " + s);
		var stat = fs.stat(s, _);
		if (stat.isDirectory()) {
			fs.readdir(s, _).forEach_(_, function(_, f) {
				rm(_, s + '/' + f);
			});
			fs.rmdir(s, _);
		} else {
			fs.unlink(s, _);
		}
	}

	function trim(_, obj, tableMeta, options) {

		options = options || {};

		var result = Object.keys(obj).reduce_(_, function(_, o, k) {
			var v = obj[k];
			if (/^CAST\(AUUID_0/.test(k))
				k = "AUUID_0";
			if (v.iLob && v.iLob.read) {
				// oracle LOB
				v = require('ez-oracle').lob.reader(v).readAll(_);
			}
			var colShortName = k.substring(0, k.lastIndexOf('_'));

			var columnMeta;
			if (tableMeta) {
				columnMeta = tableMeta.columns[colShortName];
			}

			var isArray = (obj[colShortName + '_1'] !== undefined);
			if (isArray) {
				// We assume that the items will be in the right order XXX_0, XXX_1, XXX_2, ...
				o[colShortName] = o[colShortName] || [];
				o[colShortName].push(options.formatValues ? encodeValueToJsonString(v, columnMeta, driver) : v);
			} else {
				// Note : we keep all the values, including 0 and " " because these values will be needed
				// when transforming json files into .dat files
				o[colShortName] = options.formatValues ? encodeValueToJsonString(v, columnMeta, driver) : v;
			}
			return o;
		}, {});
		return result;
	}

	function executeSql(_, sql, args, tableMeta, options) {
		//		trace && trace("SQL: " + sql + "\nARGS: " + args);
		try {
			return driver.reader(_, sql, args).map(function(_, record) {
				return trim(_, record, tableMeta, options);
			}).toArray(_);
		} catch (ex) {
			console.error(ex.stack);
			throw new Error("SQL error: " + ex.message + " while executing: " + sql + " with args: " + args);
		}
	}

	function buildKey(_, keys, where) {
		if (!Array.isArray(keys))
			keys = keys.split(',');
		return keys.map_(_, function(_, c, i) {
			if (where)
				return c + '_0=' + driver.param(i);
			else
				return (~keys.indexOf('_0') ? c : c + '_0');
		}).join(where ? ' and ' : ',');
	}

	function buildExecute(_, tableMeta, select, tableName, orderBy, keys, where, textLinks, options) {
		if (!Array.isArray(select) && !~select.indexOf('_0'))
			select = buildKey(_, select);
		if (!where && keys)
			where = Object.keys(keys).join(',');
		// trace && trace(tableName, orderBy, keys, where);
		var sqlQuery = "select " + select + " from " + tableName;
		if (where)
			sqlQuery += " where " + buildKey(_, where, 1);
		if (orderBy)
			sqlQuery += " order by " + buildKey(_, orderBy);
		var args;
		if (keys)
			args = Object.keys(keys).map_(_, function(_, c) {
				return keys[c] || '';
			});
		else
			args = [];
		// console.log(">>>> " + sqlQuery + "    ///   " + JSON.stringify(args));
		var results = executeSql(_, sqlQuery, args, tableMeta, options);
		// console.log(results);
		if (textLinks) {
			results.forEach_(_, function(_, result) {
				textLinks.forEach_(_, function(_, textLink) {
					result["##comments##"] = result["##comments##"] || {};
					result["##texts##"] = result["##texts##"] || {};
					if (result[textLink]) {
						result["##texts##"][textLink] = [];
						var textIds = Array.isArray(result[textLink]) ? result[textLink] : [result[textLink]];
						// We have to retrieve all the texts for this item
						// The texts are extracted from ATEXTE (where the NUMERO col matches the text-column of the entity,
						// INTITFIC_0 for ATABLE for instance)
						textIds.forEach_(_, function(_, textId, index) {
							var textResults = buildExecute(_, null, "LAN_0, TEXTE_0, COMMENT_0", "ATEXTE", null, {
								"NUMERO": textId
							}, null, null, options);

							var textElt = {};
							result["##texts##"][textLink].push(textElt);
							textResults.forEach(function(langItem) {
								if (config.langs.indexOf(langItem["LAN"]) == -1)
									return;
								textElt[langItem["LAN"]] = langItem["TEXTE"];
								if (langItem["COMMENT"]) {
									result["##comments##"][textLink] = result["##comments##"][textLink] || [];
									result["##comments##"][textLink][index] = result["##comments##"][textLink][index] || {};
									result["##comments##"][textLink][index][langItem["LAN"]] = langItem["COMMENT"];
								}
							});
						});
					} else {
						// No texts are available for this item
						// We still write an info to inform readers that this item is a localized text.
						// for instance, this information will be used when building patches from json files.
						result["##texts##"][textLink] = [{}];
					}
				});
			});
		}
		if (tableMeta && tableMeta.extraTables && tableMeta.extraTables.ATEXTRA) {
			results.forEach_(_, function(_, result) {
				var cols = Object.keys(tableMeta.extraTables.ATEXTRA.columns);

				driver.withConnection(_, function(_, cnx) {
					var txtQuery = "select ZONE_0 ZONE, LANGUE_0 LANG, TEXTE_0 TEXT, IDENT1_0 IDENT1, IDENT2_0 IDENT2 from ATEXTRA where CODFIC_0 = " + driver.param(0) + " AND IDENT1_0 = " + driver.param(1);
					// Here, we assume that the first property of keys contains the PK of the table we are querying
					var txtParams = [tableMeta.name, keys[Object.keys(keys)[0]]];
					var texts = driver.execute(_, cnx, txtQuery, txtParams);
					result["##extraTables##"] = result["##extraTables##"] || {};
					result["##extraTables##"].ATEXTRA = result["##extraTables##"].ATEXTRA || {};
					texts.forEach(function(text) {
						result["##extraTables##"].ATEXTRA[text.ZONE] = result["##extraTables##"].ATEXTRA[text.ZONE] || {};
						result["##extraTables##"].ATEXTRA[text.ZONE][text.IDENT2] = result["##extraTables##"].ATEXTRA[text.ZONE][text.IDENT2] || {};
						result["##extraTables##"].ATEXTRA[text.ZONE][text.IDENT2][text.LANG] = text.TEXT;
					});
				});
			});
		}
		return results;
	}

	/// Write a JSON file and returs the ABSOLUTE filename that was written
	function writeResource(_, res) {
		var absoluteFolder = path.join(config.solutionPath, config.metaSubFolder);
		res.path.split(path.sep).forEach_(_, function(_, s) {
			absoluteFolder = path.join(absoluteFolder, s);
			mkdir(_, absoluteFolder);
		});
		var absoluteFilename = path.join(absoluteFolder, res.name + ".json");
		try {
			fs.writeFile(absoluteFilename, JSON.stringify(res.data, null, '\t'), "utf8", _);
		} catch (ex) {
			console.error(ex.stack);
		}
		return absoluteFilename;
	}

	return {
		config: config,
		trace: trace,
		folderType: undefined,
		init: function(_, tracker) {
			var outputFolder = path.join(config.solutionPath, config.metaSubFolder);
			var msg = "Creating output: " + outputFolder;
			trace && trace(msg);
			if (tracker)
				tracker.phase = msg;

			mkdir(_, outputFolder);
			this.folderType = parseInt(buildExecute(_, null, "VALEUR", "ADOVAL", null, {
				"PARAM": "TYPDOS"
			})[0].VALEUR);
		},
		clean: function(_, tracker) {
			var outputFolder = config.metaSubFolder;
			var msg = "Cleaning output: " + outputFolder;
			trace && trace(msg);
			if (tracker)
				tracker.phase = msg;
			fs.readdir(outputFolder, _).forEach_(_, function(_, name) {
				if (name !== '.git')
					rm(_, outputFolder + "/" + name);
			});
		},
		check: function(_) {
			trace && trace("getting folder type");
			if (this.folderType !== 1 && !config.force) throw new Error("Bad folder type: " + this.folderType);
		},
		moduleNames: ["UNKNOWN", "SUPERV", "FINANCE", "BP", "EXTERNAL", //
			"SALES", "PURCHASES", "STOCKS", "CAPM", "COMMON", //
			"DEV", "INTERNAL", "SUPPORT", "MARKETING", "FA", //
			"HR", "SPE1", "SPE2", "SPE3", "SPE4", "TALENT"
		],

		getTableMeta: function(_, tableName, excludedColumnNames) {
			var meta = {
				name: tableName,
				columns: {}
			};
			trace && trace("loading columns definition for " + tableName);
			var query = "select TZ.CODZONE_0 ZONCOD, TZ.DIME_0 ZONDIM, TZ.CODTYP_0 ZONCODTYP, TZ.OPTION_0 ZONOPT";
			query += ",TP.TYPTYP_0 TYPTYP, TP.OPTION_0 TYPOPT, TP.TYPSELSYR_0 TYPSELSYR, TP.CODCLA_0 TYPCLA";
			query += " from ATABZON TZ";
			query += " left join ATYPE TP ON TP.CODTYP_0 = TZ.CODTYP_0";
			query += " where CODFIC_0 = '" + tableName + "'";
			query += " order by CODZONE_0";

			driver.withConnection(_, function(_, cnx) {
				var rows = driver.execute(_, cnx, query);
				rows.forEach_(_, function(_, row) {
					if (excludedColumnNames && ~excludedColumnNames.indexOf(row.ZONCOD))
						return;

					var colDef = {
						name: row.ZONCOD,
						dimension: row.ZONDIM,
						type: row.TYPTYP, // 1 = local menu, 2 = short integer, 3 = long integer, 4 = decimal, 5 = floating, 6 = double, 7 = string, ...
						codeType: row.ZONCODTYP, // AX1, AY, ...
					};
					if (row.ZONOPT && row.ZONOPT.trim().length)
						colDef.option = row.ZONOPT.trim();
					else if (row.TYPOPT && row.TYPOPT.trim().length)
						colDef.option = row.TYPOPT.trim();
					var extraTable = null;
					if (row.TYPSELSYR == 2) {
						// type = reference
						if (row.TYPCLA == 'ATEXTRA') {
							// This column is described in ATABZON but its content is not in the table itself but in ATEXTRA
							extraTable = 'ATEXTRA';
						}
					}
					if (extraTable) {
						if (!meta.extraTables)
							meta.extraTables = {};
						if (!meta.extraTables[extraTable])
							meta.extraTables[extraTable] = {
								name: extraTable,
								columns: {}
							};
						meta.extraTables[extraTable].columns[colDef.name] = colDef;
					} else
						meta.columns[colDef.name] = colDef;
				});
			});

			return meta;
		},

		getTableColumns: function(_, tableName, excludedColumnNames) {
			trace && trace("loading columns for " + tableName);
			return buildExecute(_, null, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
				'CODFIC': tableName
			}).map(function(elt) {
				if (excludedColumnNames && ~excludedColumnNames.indexOf(elt.CODZONE))
					return;
				var arr = [];
				for (var i = 0; i < elt.DIME; i++) {
					var s = elt.CODZONE + '_' + i;
					if (s === "AUUID_0" && sqlConfig.driver === "oracle") s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver					
					if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) arr.push(s);
				}
				return arr.join(',');
			}).filter(function(s) {
				return s;
			});
		},
		buildExecute: buildExecute,
		writeResource: writeResource,
		objVals: function(_, elt, objectTypes) {
			return Object.keys(elt).map_(_, function(_, k) {
				return (objectTypes && objectTypes[elt[k]] ? objectTypes[elt[k]] : elt[k]);
			}).join(' ');
		}
	};
};

exports.exportMetadata = function(_, config, tracker) {
	config.trace = config.trace || console.log;
	var exporter = require("etna-etl/lib/exporter").newExporter(_, {
		endpoint: config,
		trace: function(str) {
			if (tracker) tracker.phaseDetail = str;
			if (config.trace) config.trace(str);
		},
		dir: config.solutionPath + "/" + config.folderName + "/META",
		force: true, // for now!
		parallel: 1,
	});

	if (tracker) tracker.phase = "initializing";
	exporter.init(_);

	var entityExporter = require("etna-etl/lib/export-entity");
	var entities = getAllEntityDescriptors(_);
	entities.forEach_(_, function(_, entityResource) {
		if (tracker && tracker.abortRequested) return;
		if (tracker) tracker.phase = "exporting " + entityResource.entity.title;
		if (entityResource.entity.title === "contexts") {
			entityExporter.run(_, exporter, entityResource.entity, tracker);
		}
	});

};