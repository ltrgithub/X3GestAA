"use strict";

var fs = require('streamline-fs'),
	jsonHelper = require('scm-helper/lib/jsonHelper'),
	path = require('path'),
	flows = require('streamline-runtime').flows,
	encodeValueToJsonString = require('scm-helper/lib/jsonHelper').encodeValueToJsonString,
	getAllEntityDescriptors = require('scm-helper/lib/resourceManager').getAllEntityDescriptors;

exports.newExporter = function(_, config) {
	const MARK_comments = "##comments##";
	const MARK_texts = "##texts##";
	const MARK_extraTables = "##extraTables##";
	var trace = config.trace;
	config.langs = config.langs || ["ENG", "FRA"];
	config.endpoint = config.endpoint || [];
	var sqlConfig = config.endpoint.sql;
	if (!sqlConfig) {
		throw new Error("config.endpoint.sql missing ");
	}
	var driver = require('etna/lib/engine/drivers/' + sqlConfig.driver)(sqlConfig);
	var fsFunnel = flows.funnel(1);

	// Creates a directory and returns whether the creation succeeded
	function mkdir(_, s) {
		var result = true;
		if (!fs.exists(s, _)) {
			fsFunnel(_, function(_) {
				if (!fs.exists(s, _)) {
					try {
						fs.mkdir(s, _);
					} catch (err) {
						result = false;
					}
				}
			});
		}
		return result;
	}

	// Recursively removes a folder
	function rm(_, s) {
		if (!fs.exists(s, _)) {
			return;
		}
		trace && trace("Remove " + s);
		var stat = fs.stat(s, _);
		if (stat.isDirectory()) {
			fs.readdir(s, _).forEach_(_, function(_, f) {
				rm(_, path.join(s, f));
			});
			fs.rmdir(s, _);
		} else {
			fs.unlink(s, _);
		}
	}

	function trim(_, obj, tableMeta, options) {

		options = options || {};

		var result = Object.keys(obj).reduce_(_, function(_, o, k) {
			var v = obj[k];
			if (/^CAST\(AUUID_0/.test(k)) {
				k = "AUUID_0";
			}
			if (v.iLob && v.iLob.read) {
				// oracle LOB
				v = require('ez-oracle').lob.reader(v).readAll(_);
			}
			var colShortName = k.substring(0, k.lastIndexOf('_'));

			var columnMeta;
			if (tableMeta) {
				columnMeta = tableMeta.columns[colShortName];
			}

			var isArray = (obj[colShortName + '_1'] !== undefined);
			if (isArray) {
				// We assume that the items will be in the right order XXX_0, XXX_1, XXX_2, ...
				o[colShortName] = o[colShortName] || [];
				o[colShortName].push(options.formatValues ? encodeValueToJsonString(v, columnMeta, driver) : v);
			} else {
				// Note : we keep all the values, including 0 and " " because these values will be needed
				// when transforming json files into .dat files
				o[colShortName] = options.formatValues ? encodeValueToJsonString(v, columnMeta, driver) : v;
			}
			return o;
		}, {});
		return result;
	}

	function executeSql(_, sql, args, tableMeta, options) {
		//		trace && trace("SQL: " + sql + "\nARGS: " + JSON.stringify(args));
		try {
			return driver.reader(_, sql, args).map(function(_, record) {
				return trim(_, record, tableMeta, options);
			}).toArray(_);
		} catch (ex) {
			console.error(ex.stack);
			throw new Error("SQL error: " + ex.message + " while executing: " + sql + " with args: " + args);
		}
	}

	function buildKey(_, keys, where) {
		if (!Array.isArray(keys)) {
			keys = keys.split(',');
		}
		return keys.map_(_, function(_, c, i) {
			if (where) {
				return c + '_0=' + driver.param(i);
			} else {
				return (~keys.indexOf('_0') ? c : c + '_0');
			}
		}).join(where ? ' and ' : ',');
	}

	function buildExecute(_, tableMeta, select, tableName, orderBy, keys, where, textLinks, options) {
		if (!Array.isArray(select)) {
			select = select.split(',');
		}
		if (!~select[0].indexOf('_0')) {
			select = buildKey(_, select);
		}
		if (!where && keys) {
			where = Object.keys(keys).join(',');
		}
		// trace && trace(tableName, orderBy, keys, where);
		var sqlQuery = "select " + select + " from " + tableName;
		if (where) {
			sqlQuery += " where " + buildKey(_, where, 1);
		}
		if (orderBy) {
			if (!Array.isArray(orderBy))
				orderBy = orderBy.split(",");
			sqlQuery += " order by " + buildKey(_, orderBy);
		}
		var args;
		if (keys) {
			args = Object.keys(keys).map_(_, function(_, c) {
				return keys[c] || '';
			});
		} else {
			args = [];
		}
		// console.log(">>>> " + sqlQuery + "    ///   " + JSON.stringify(args));
		var results = executeSql(_, sqlQuery, args, tableMeta, options);
		if (textLinks && !options.specialExport) {
			results.forEach_(_, function(_, result) {
				textLinks.forEach_(_, function(_, textLink) {
					result[MARK_comments] = result[MARK_comments] || {};
					result[MARK_texts] = result[MARK_texts] || {};
					if (result[textLink]) {
						result[MARK_texts][textLink] = [];
						var textIds = Array.isArray(result[textLink]) ? result[textLink] : [result[textLink]];
						// We have to retrieve all the texts for this item
						// The texts are extracted from ATEXTE (where the NUMERO col matches the text-column of the entity,
						// INTITFIC_0 for ATABLE for instance)
						textIds.forEach_(_, function(_, textId, index) {
							var numero = jsonHelper.decodeValueFromJsonString(undefined, textId);
							var textResults = buildExecute(_, null, "LAN_0, TEXTE_0, COMMENT_0", "ATEXTE", null, {
								"NUMERO": numero.value,
							}, null, null, options);

							var textElt = {};
							result[MARK_texts][textLink].push(textElt);
							textResults.forEach(function(langItem) {
								if (config.langs.indexOf(langItem["LAN"]) == -1) {
									return;
								}
								textElt[langItem["LAN"]] = langItem["TEXTE"];
								if (langItem["COMMENT"]) {
									result[MARK_comments][textLink] = result[MARK_comments][textLink] || [];
									result[MARK_comments][textLink][index] = result[MARK_comments][textLink][index] || {};
									result[MARK_comments][textLink][index][langItem["LAN"]] = langItem["COMMENT"];
								}
							});
						});
					} else {
						// No texts are available for this item
						// We still write an info to inform readers that this item is a localized text.
						// for instance, this information will be used when building patches from json files.
						result[MARK_texts][textLink] = [{}];
					}
				});
			});
		}
		if (tableMeta && tableMeta.extraTables && tableMeta.extraTables.ATEXTRA) {
			results.forEach_(_, function(_, result) {
				var cols = Object.keys(tableMeta.extraTables.ATEXTRA.columns);

				driver.withConnection(_, function(_, cnx) {
					var txtQuery = "select ZONE_0 ZONE, LANGUE_0 LANG, TEXTE_0 TEXT, IDENT1_0 IDENT1, IDENT2_0 IDENT2 from ATEXTRA where CODFIC_0 = " + driver.param(0) + " AND IDENT1_0 = " + driver.param(1);
					// Here, we assume that the first property of keys contains the PK of the table we are querying
					var txtParams = [
						tableMeta.tableName,
						"" + keys[Object.keys(keys)[0]] // Force it to string (for instance ATABTAB as a numeric PK ... (NUMTAB))
					];
					var texts = driver.execute(_, cnx, txtQuery, txtParams);
					result[MARK_extraTables] = result[MARK_extraTables] || {};
					result[MARK_extraTables].ATEXTRA = result[MARK_extraTables].ATEXTRA || {};
					texts.forEach(function(text) {
						result[MARK_extraTables].ATEXTRA[text.ZONE] = result[MARK_extraTables].ATEXTRA[text.ZONE] || {};
						result[MARK_extraTables].ATEXTRA[text.ZONE][text.IDENT2] = result[MARK_extraTables].ATEXTRA[text.ZONE][text.IDENT2] || {};
						result[MARK_extraTables].ATEXTRA[text.ZONE][text.IDENT2][text.LANG] = text.TEXT;
					});
				});
			});
		}
		return results;
	}

	/// Write a JSON file and returs the ABSOLUTE filename that was written
	function writeResource(_, res) {
		var absoluteFolder = path.join(config.solutionPath, config.metaSubFolder);
		res.path.split(path.sep).forEach_(_, function(_, s) {
			absoluteFolder = path.join(absoluteFolder, s);
			if (!mkdir(_, absoluteFolder)) {
				throw new Error("Could not create folder " + absoluteFolder);
			}
		});
		var absoluteFilename = path.join(absoluteFolder, res.fileName + ".json");
		try {
			fs.writeFile(absoluteFilename, JSON.stringify(res.data, null, '\t'), "utf8", _);
		} catch (ex) {
			console.error(ex.stack);
		}
		return absoluteFilename;
	}

	return {
		config: config,
		trace: trace,
		folderType: undefined,
		init: function(_, tracker) {
			var outputFolder = path.join(config.solutionPath, config.metaSubFolder);
			var msg = "Creating output: " + outputFolder;
			trace && trace(msg);
			if (tracker) {
				tracker.phase = msg;
			}

			if (!mkdir(_, outputFolder)) {
				trace && trace("Could not create the folder " + outputFolder);
				return false;
			}
			this.folderType = parseInt(buildExecute(_, null, "VALEUR", "ADOVAL", null, {
				"PARAM": "TYPDOS"
			})[0].VALEUR);
			return true;
		},
		clean: function(_, tracker) {
			var outputFolder = path.join(config.solutionPath, config.metaSubFolder);
			var msg = "Cleaning output: " + outputFolder;
			trace && trace(msg);
			if (tracker) {
				tracker.phase = msg;
			}
			fs.readdir(outputFolder, _).forEach_(_, function(_, folderName) {
				if (folderName !== '.git') {
					rm(_, path.join(outputFolder, folderName));
				}
			});
		},
		check: function(_) {
			trace && trace("getting folder type");
			if (this.folderType !== 1 && !config.force) {
				throw new Error("Bad folder type: " + this.folderType);
			}
		},
		moduleNames: [
			"UNKNOWN",
			"SUPERV",
			"FINANCE",
			"BP",
			"EXTERNAL", //
			"SALES",
			"PURCHASES",
			"STOCKS",
			"CAPM",
			"COMMON", //
			"DEV",
			"INTERNAL",
			"SUPPORT",
			"MARKETING",
			"FA", //
			"HR",
			"SPE1",
			"SPE2",
			"SPE3",
			"SPE4",
			"TALENT"
		],

		getTableMeta: function(_, tableName, excludedColumnNames) {
			var meta = {
				tableName: tableName,
				columns: {}
			};
			trace && trace("loading columns definition for " + tableName);
			var query = "select TZ.CODZONE_0 ZONCOD, TZ.DIME_0 ZONDIM, TZ.CODTYP_0 ZONCODTYP, TZ.OPTION_0 ZONOPT";
			query += ",TP.TYPTYP_0 TYPTYP, TP.OPTION_0 TYPOPT, TP.TYPSELSYR_0 TYPSELSYR, TP.CODCLA_0 TYPCLA";
			query += " from ATABZON TZ";
			query += " left join ATYPE TP ON TP.CODTYP_0 = TZ.CODTYP_0";
			query += " where CODFIC_0 = '" + tableName + "'";
			query += " order by CODZONE_0";

			driver.withConnection(_, function(_, cnx) {
				var rows = driver.execute(_, cnx, query);
				rows.forEach_(_, function(_, row) {
					if (excludedColumnNames && ~excludedColumnNames.indexOf(row.ZONCOD)) {
						return;
					}

					var colDef = {
						columnName: row.ZONCOD,
						dimension: row.ZONDIM,
						type: row.TYPTYP, // 1 = local menu, 2 = short integer, 3 = long integer, 4 = decimal, 5 = floating, 6 = double, 7 = string, ...
						codeType: row.ZONCODTYP, // AX1, AY, ...
					};
					if (row.ZONOPT && row.ZONOPT.trim().length) {
						colDef.option = row.ZONOPT.trim();
					} else if (row.TYPOPT && row.TYPOPT.trim().length) {
						colDef.option = row.TYPOPT.trim();
					}
					var extraTable = null;
					if (row.TYPSELSYR == 2) {
						// type = reference
						if (row.TYPCLA == 'ATEXTRA') {
							// This column is described in ATABZON but its content is not in the table itself but in ATEXTRA
							extraTable = 'ATEXTRA';
						}
					}
					if (extraTable) {
						if (!meta.extraTables) {
							meta.extraTables = {};
						}
						if (!meta.extraTables[extraTable]) {
							meta.extraTables[extraTable] = {
								tableName: extraTable,
								columns: {}
							};
						}
						meta.extraTables[extraTable].columns[colDef.columnName] = colDef;
					} else {
						meta.columns[colDef.columnName] = colDef;
					}
				});
			});

			return meta;
		},

		getTableColumns: function(_, tableName, excludedColumnNames) {
			trace && trace("loading columns for " + tableName);
			return buildExecute(_, null, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
				'CODFIC': tableName
			}).map(function(elt) {
				if (excludedColumnNames && ~excludedColumnNames.indexOf(elt.CODZONE)) {
					return;
				}
				var arr = [];
				for (var i = 0; i < elt.DIME; i++) {
					var s = elt.CODZONE + '_' + i;
					if (s === "AUUID_0" && sqlConfig.driver === "oracle") {
						s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver
					}
					if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) {
						arr.push(s);
					}
				}
				return arr.join(',');
			}).filter(function(s) {
				return s;
			});
		},
		buildExecute: buildExecute,
		writeResource: writeResource,
		objVals: function(_, elt, objectTypes) {
			return Object.keys(elt).map_(_, function(_, k) {
				return (objectTypes && objectTypes[elt[k]] ? objectTypes[elt[k]] : elt[k]);
			}).join(' ');
		}
	};
};