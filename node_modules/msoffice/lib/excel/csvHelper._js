"use strict";

var url = require('url');
var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;

var tracer; // = console.log;

exports.generateCsv = function(_, ctx, options) {
	return _generateCsv(_, ctx, options);
};

function _generateCsv(_, ctx, options) {
	let parsedUrl = _parseRequestUrl(_, options.url);
	if (parsedUrl.errMsg) {
		tracer && tracer(parsedUrl.errMsg);
		return;
	}

	var $prototype = _getPrototype(_, parsedUrl);

	var $article = {
		$category: "worksheet",
		$layout: {}
	};
	_buildQueryArticle($article, $prototype);

	var items = _makeTablePrototype(_, $prototype.$properties, $article);

	var $resources = _fetchResource(_, parsedUrl);
	var newData = {
		$resources: $resources
	};

	var data = _makeTableData(newData, $prototype.$properties, items);

	tracer && tracer("data: " + JSON.stringify(data, null, 2));

	return data;
}

function _getPrototype(_, parsedUrl) {
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.getEntity(_, parsedUrl.dataset);
	return entity && entity.getPrototype(_, parsedUrl.representation);
}

function _fetchResource(_, parsedUrl) {
	var resources = [];
	var db = adminHelper.getCollaborationOrm(_);
	var entity = db.getEntity(_, parsedUrl.dataset, "$bulk");
	var cursor = db.createCursor(_, entity);
	var data;
	while (data = cursor.next(_)) {
		resources.push(data.serializeInstance(_));
	}
	return resources;
}

function _parseRequestUrl(_, requestUrl) {
	var parsed = url.parse(requestUrl, true);
	var segs = parsed.pathname.split('/');
	var result = {};

	if (segs.length < 6) {
		result.errMsg = "url incomplete";
		return result;
	}

	result.application = segs[3];
	result.contract = segs[4];
	result.dataset = segs[5];
	result.syraClass = segs[6];
	result.representation = parsed.query.representation;

	return result;
}

function _makeTablePrototype(_, $prototype, $item) {
	var proto = $prototype;
	var _item = $item;
	var items;

	while (_item && _item.$layout && (_item.$bind !== "$resources"))
		_item = _item.$layout.$items && _item.$layout.$items[0];
	if (!_item)
		return;

	items = (_item.$layout && _item.$layout.$items) || _item.$items ||
		Object.keys(proto).filter(function(prop) {
			return proto[prop].$isHidden !== true;
		}).map(function(prop) {
			return {
				$bind: prop
			};
		});

	return items.map(function(item) {
		var protoItem = proto[item.$bind];

		var sp = {
			_name: item.$bind.replace("$", "_"),
			_orgName: item.$bind,
			_title: protoItem.$title,
			_isExcluded: protoItem.$isExcluded
		};

		if (protoItem.$type == "application/x-reference" && protoItem.$item) {
			sp._type = protoItem.$type;
			sp._scale = (protoItem.$scale !== undefined) ? protoItem.$scale : null;

			if (protoItem.$item.$key !== "{$uuid}" && item.$reference && item.$reference.$value) {
				sp._bind = item.$reference.$value.$prop;
			}
		} else
		if (protoItem.$type == "application/x-quantity" && protoItem.$value) {
			var valueProp = protoItem.$value;
			sp._type = valueProp.$type;
			sp._scale = (valueProp.$scale !== undefined) ? valueProp.$scale : null;
		} else {
			sp._type = protoItem.$type;
			sp._scale = (protoItem.$scale !== undefined) ? protoItem.$scale : null;
		}
		return sp;
	}).filter(function(simpleProto) {
		return !simpleProto._isExcluded;
	});
}

function _makeTableData(data, $prototype, $tablePrototype) {
	var proto = $prototype;
	var items = $tablePrototype;

	return data.$resources.map(function(res) {
		return items.map(function(item) {
			var prop = res[item._orgName];
			var propProto = proto[item._orgName];
			var result = "";
			var record = res;

			if (res.$properties && res.$properties[item._orgName] && res.$properties[item._orgName].$isHidden) {
				return result;
			}

			// manage limited set of types
			switch (item._type) {
				case "application/x-string":
				case "application/x-integer":
				case "application/x-decimal":
				case "application/x-datetime":
				case "application/x-date":
				case "application/x-time":
				case "application/x-boolean":
					result = prop;
					break;
				case "application/x-choice":
					var ref = propProto.$value || propProto.$key;
					if (ref && ref.$enum) {
						for (var ii = 0, jj = ref.$enum.length; ii < jj; ii++) {
							if (ref.$enum[ii] && ref.$enum[ii].$value !== undefined && ref.$enum[ii].$value === prop) {
								result = ref.$enum[ii].$title;
								break;
							}
						}
					} else {
						result = prop;
					}
					break;
				case "application/x-reference":
					result = "";
					break;
				default:
					result = "";
			}
			if (record && propProto.$links && propProto.$links.$details)
				return result;
			else
				return result;
		});
	});
}

function _buildQueryArticle($article, $prototype) {
	var $defined = {};

	var $binds = Object.keys($prototype.$properties);
	var $array = [];
	var $more = [];

	for (var ii = 0, jj = $binds.length; ii < jj; ii++) {
		var $bind = $binds[ii];
		var $field = $prototype.$properties[$bind];
		if ($field && !$field.$isExcluded) {
			var $item = $defined[$bind] ? syra_site.clone($defined[$bind]) : {
				$bind: $bind
			};
			if ($field.$type == "application/x-array") {
				$array.push($item);
			} else {
				$more.push($item);
			}
		}
	}
	if ($more.length) {
		$article.$layout = {
			$items: $more.concat($array)
		};
	} else {
		$article.$layout.$items = $array;
	}
}