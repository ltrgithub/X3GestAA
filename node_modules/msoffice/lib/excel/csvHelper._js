"use strict";

var url = require('url');
var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;
var locale = require('streamline-locale');
var tracer; // = console.log;

exports.generateCsv = function(_, ctx, options) {
	return _generateCsv(_, ctx, options);
};

function _generateCsv(_, ctx, options) {
	let parsedUrl = _parseRequestUrl(_, options.url);
	if (parsedUrl.errMsg) {
		tracer && tracer(parsedUrl.errMsg);
		return;
	}

	let $prototype = _getPrototype(_, parsedUrl);
	let $protoItem = ($prototype.$properties.$resources && $prototype.$properties.$resources.$item) || $prototype;

	let $article = _buildQueryArticle($protoItem);
	let items = _makeTablePrototype(_, $protoItem.$properties, $article);

	let $resources = _fetchResource(_, parsedUrl);
	let newData = {
		$resources: $resources
	};

	let header = _makeTableHeader(items, $prototype.$localization);
	let data = ($resources && _makeTableData(newData, $protoItem.$properties, items, $prototype.$localization)) || [];
	data.splice(0, 0, header);

	tracer && tracer("tableData: " + JSON.stringify(data, null, 2));

	return data;
}

function _getPrototype(_, parsedUrl) {
	let db, entity, data;
	if (parsedUrl.contract === "collaboration") {
		db = adminHelper.getCollaborationOrm(_);
		entity = db.getEntity(_, parsedUrl.representationName);
		data = entity && entity.getPrototype(_, parsedUrl.representation);
	} else {
		let endpoint = adminHelper.getEndpoint(_, {
			application: parsedUrl.application,
			contract: parsedUrl.contract,
			dataset: parsedUrl.dataset
		});

		db = endpoint.getModel(_);
		entity = db.getEntity(_, parsedUrl.representationName, "$bulk");
		data = entity && entity.getPrototype(_, parsedUrl.representationName, "$bulk");
	}
	return data || {};
}

function _fetchResource(_, parsedUrl) {
	let resources;
	if (parsedUrl.contract === "collaboration") {
		resources = _fetchCollaborationResource(_, parsedUrl);
	} else {
		if (parsedUrl.syraClass.indexOf("QUERY(") === 0) {
			resources = _fetchQueryResource(_, parsedUrl);
		} else {
			resources = _fetchRepresentationResource(_, parsedUrl);
		}
	}
	return resources;
}

function _fetchCollaborationResource(_, parsedUrl) {
	let resources = [];

	let db = adminHelper.getCollaborationOrm(_);
	let entity = db.getEntity(_, parsedUrl.representationName, "$bulk");
	let cursor = db.createCursor(_, entity);

	var data;
	while (data = cursor.next(_)) {
		resources.push(data.serializeInstance(_));
	}
	return resources;
}

function _fetchRepresentationResource(_, parsedUrl) {
	let endpoint = adminHelper.getEndpoint(_, {
		application: parsedUrl.application,
		contract: parsedUrl.contract,
		dataset: parsedUrl.dataset
	});
	let handle = endpoint.getOrm(_);

	let client = handle.getClient(_);
	let url = handle._baseUrl + "/" + parsedUrl.syraClass + "?representation=" + parsedUrl.representationName + ".$bulk";
	let r = client.jsonSend(_, {
		head: {
			"accept": "application/json;vnd.sage=syracuse",
			"accept-language": locale.current || "en-US",
			method: "GET",
			url: url
		},
		body: {}
	});
	if (r.head.statusCode === 500) {
		return [];
	}
	return r.body.$resources;
}

function _fetchQueryResource(_, parsedUrl, nextUrl, resources) {
	let endpoint = adminHelper.getEndpoint(_, {
		application: parsedUrl.application,
		contract: parsedUrl.contract,
		dataset: parsedUrl.dataset
	});
	let handle = endpoint.getOrm(_);
	let client = handle.getClient(_);
	let url = nextUrl || (handle._baseUrl + "/" + parsedUrl.syraClass + "?" + parsedUrl.queryParams);

	let r = client.jsonSend(_, {
		head: {
			"accept": "application/json;vnd.sage=syracuse",
			"accept-language": locale.current || "en-US",
			method: "GET",
			url: url
		},
		body: {}
	});
	if (r.head.statusCode === 500) {
		return [];
	}

	resources = resources || [];
	resources = resources.concat(r.body.$resources);

	nextUrl = r.body.$links && r.body.$links.$next && r.body.$links.$next.$url;
	if (nextUrl) {
		nextUrl = handle._baseUrl + "/" + nextUrl.split('/')[1];

		resources = _fetchQueryResource(_, parsedUrl, nextUrl, resources);
	}
	return resources;
}

function _makeTablePrototype(_, $prototype, $item) {
	let proto = $prototype;
	let _item = $item;
	let items;

	while (_item && _item.$layout && (_item.$bind !== "$resources"))
		_item = _item.$layout.$items && _item.$layout.$items[0];

	if (!_item)
		return;

	items = (_item.$layout && _item.$layout.$items) || _item.$items ||
		Object.keys(proto).filter(function(prop) {
			return proto[prop].$isHidden !== true;
		}).map(function(prop) {
			return {
				$bind: prop
			};
		});

	return items.map(function(item) {
		let protoItem = proto[item.$bind];

		let sp = {
			_name: item.$bind.replace("$", "_"),
			_orgName: item.$bind,
			_title: protoItem.$title,
			_isExcluded: protoItem.$isExcluded
		};

		if (protoItem.$type == "application/x-reference" && protoItem.$item) {
			sp._type = protoItem.$type;
			sp._scale = (protoItem.$scale !== undefined) ? protoItem.$scale : null;

			if (protoItem.$item.$key !== "{$uuid}" && item.$reference && item.$reference.$value) {
				sp._bind = item.$reference.$value.$prop;
			}
		} else if (protoItem.$type == "application/x-quantity" && protoItem.$value) {
			let valueProp = protoItem.$value;
			sp._type = valueProp.$type;
			sp._scale = (valueProp.$scale !== undefined) ? valueProp.$scale : null;
		} else {
			sp._type = protoItem.$type;
			sp._scale = (protoItem.$scale !== undefined) ? protoItem.$scale : null;
		}
		return sp;
	}).filter(function(simpleProto) {
		return !simpleProto._isExcluded && simpleProto._type != "image" && simpleProto._type != "application/x-graph" && simpleProto._type != "application/x-array";
	});
}

function _makeTableHeader($tablePrototype, $localization) {
	let header = [];
	for (let ii = 0, jj = $tablePrototype.length; ii < jj; ii++) {
		let headerColumn = $tablePrototype[ii];
		let title = headerColumn._title || headerColumn._name;
		if ($localization && _isReference(title)) {
			title = $localization[_parseValue(title)] || title;
		}
		title && header.push('"' + title + '"');
	}
	return header;
}

function _makeTableData(data, $prototype, $tablePrototype, $localization) {
	let proto = $prototype;
	let items = $tablePrototype;

	return data.$resources.map(function(res) {
		return items.map(function(item) {
			let prop = res[item._orgName];
			let propProto = proto[item._orgName];
			let result = "";

			if (res.$properties && res.$properties[item._orgName] && res.$properties[item._orgName].$isHidden) {
				return result;
			}

			switch (item._type) {
				case "application/x-string":
				case "application/x-integer":
				case "application/x-decimal":
				case "application/x-datetime":
				case "application/x-date":
				case "application/x-time":
				case "application/x-boolean":
					result = _escapeCsv(prop);
					break;
				case "application/x-choice":
					result = _parseChoiceProperty(propProto, res, prop, $localization, item._orgName);
					break;
				case "application/x-reference":
					result = _parseReferenceProperty(propProto, res, prop, item);
					break;
				default:
					result = "";
			}
			return result;
		});
	});
}

function _buildQueryArticle($prototype) {
	let $article = {
		$category: "worksheet",
		$layout: {}
	};

	let $binds = Object.keys($prototype.$properties);
	let $array = [];
	let $more = [];

	for (let ii = 0, jj = $binds.length; ii < jj; ii++) {
		let $bind = $binds[ii];
		let $field = $prototype.$properties[$bind];
		if ($field && !$field.$isExcluded) {
			let $item = {
				$bind: $bind
			};
			if ($field.$type == "application/x-array") {
				$array.push($item);
			} else {
				$more.push($item);
			}
		}
	}

	if ($more.length) {
		$article.$layout = {
			$items: $more.concat($array)
		};
	} else {
		$article.$layout.$items = $array;
	}
	return $article;
}

function _parseReferenceProperty(propProto, res, prop, item) {
	let result;
	let record = prop;
	propProto = propProto.$item || {};
	let valueTemplate = item._bind || propProto.$value || propProto.$key;
	if (record && valueTemplate && _isReference(valueTemplate)) {
		valueTemplate = _parseValue(valueTemplate);
		if (record[valueTemplate]) {
			result = _escapeCsv(record[valueTemplate]);
		} else {
			let key = propProto[valueTemplate];
			result = key && res[_parseValue(key)];
		}
	} else {
		result = "";
	}
	return result;
}

function _parseChoiceProperty(propProto, res, prop, localization, name) {
	let result;
	let nameProp = prop;
	let ref = propProto.$value || propProto.$key;
	let $enum = ref && ref.$enum;
	if ($enum && $enum.length === 0) {
		nameProp = res[name];
		let enumProp = res.$properties && res.$properties[name];
		$enum = enumProp.$value && enumProp.$value.$enum;
	}
	if ($enum) {
		for (let ii = 0, jj = $enum.length; ii < jj; ii++) {
			if ($enum[ii] && $enum[ii].$value !== undefined && $enum[ii].$value === nameProp) {
				let titleRef = $enum[ii].$title;
				if (localization && titleRef && _isReference(titleRef)) {
					titleRef = _parseValue(titleRef);
					result = _escapeCsv(localization[titleRef]);
				} else {
					result = titleRef;
				}
				break;
			}
		}
	} else {
		result = nameProp;
	}
	return result;
}

function _parseRequestUrl(_, requestUrl) {
	let parsed = url.parse(requestUrl, true);
	let segs = parsed.pathname.split('/');
	let result = {};

	if (segs.length < 6) {
		result.errMsg = "url incomplete";
		return result;
	}

	result.application = segs[2];
	result.contract = segs[3];
	result.dataset = segs[4];
	result.syraClass = segs[5];
	result.requestUrl = requestUrl;
	result.representation = parsed.query.representation;
	result.representationName = result.representation.split('.')[0];

	let keys = Object.keys(parsed.query);
	result.queryParams = "";
	for (let ii = 0, jj = keys.length; ii < jj; ii++) {
		let key = keys[ii];
		if (key !== "format") {
			let nvp = ((ii > 0) ? "&" : "") + key + "=" + parsed.query[key];
			result.queryParams += nvp;
		}
	}
	return result;
}

function _parseValue(value) {
	return value && value.slice(1, -1);
}

function _isReference(value) {
	return value && value.startsWith('{');
}

function _isFormula(data) {
	return (data && data[0] && /[0-9=\+-\/\*]/.test(data[0])) || false;
}

function _escapeCsv(data) {
	return (_isFormula(data) ? '="' : '"') + (data || "") + '"';
}