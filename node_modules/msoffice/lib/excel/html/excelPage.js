"use strict";
var helpers = require('syracuse-core/lib/helpers');
var DesktopPage = require("syracuse-ui/lib/page/desktopPage").DesktopPage;

function ExcelPage(){

}

exports.ExcelPage = helpers.defineClass(ExcelPage, DesktopPage, {
    loadBox: function(){
        this.isAutoInsertFieldDisabled = true;
        return DesktopPage.prototype.loadBox.call(this);
    },
    drawPage: function(){
        this.$excelTablePrototype = this._makeExcelTablePrototype(this.$prototype.$properties.$resources.$item.$properties, this.$item);
        syra_site.addGrid(this);
    },
    _makeExcelTablePrototype: function($prototype, $item){
        var self = this;
        var proto = $prototype;
        var _item = $item;
        var items;
        if (self.$prototype.fields) {
            items = self.$prototype.fields.map(function(f){
                return {
                    $bind: f
                };
            });
        }
        else {
            // get to "$resources" layout
            while (_item && _item.$layout && (_item.$bind !== "$resources")) 
                _item = _item.$layout.$items && _item.$layout.$items[0];
            if (!_item) 
                return;
            // get column list as string array 
            // TODO : properly manage $resource node
            items = (_item.$layout && _item.$layout.$items) || _item.$items ||
            Object.keys(proto).filter(function(prop){
                return proto[prop].$isHidden !== true;
            }).map(function(prop){
                return {
                    $bind: prop
                };
            });
        }
        
        return items.map(function(item){
            var protoItem = proto[item.$bind];
            // use undescore instead of $ as cannot have properties with $ in VSTO
            
            var sp = {
                _name: item.$bind.replace("$", "_"), // escape $ properties
                _orgName: item.$bind, // temporary storage of original name
                _title: syra_expression.parse(self, protoItem.$title),
                _isExcluded: protoItem.$isExcluded
            };
            
            if (protoItem.$type == "application/x-reference" && protoItem.$item) {
                self._initializeReferenceField(item, protoItem.$item);
                sp._type = protoItem.$type;
                sp._scale = (protoItem.$scale !== undefined) ? protoItem.$scale : null;
                
                if (protoItem.$item.$key !== "{$uuid}" && item.$reference && item.$reference.$value) {
                    sp._bind = item.$reference.$value.$prop;
                }
            }
            else 
                if (protoItem.$type == "application/x-quantity" && protoItem.$value) {
                    var valueProp = protoItem.$value;
                    sp._type = valueProp.$type;
                    sp._scale = (valueProp.$scale !== undefined) ? valueProp.$scale : null;
                }
                else {
                    sp._type = protoItem.$type;
                    sp._scale = (protoItem.$scale !== undefined) ? protoItem.$scale : null;
                }
            return sp;
        }).filter(function(simpleProto){
            return !simpleProto._isExcluded;
        });
    },
    _makeExcelTableData: function(data, $prototype, $excelTablePrototype){
        var proto = $prototype;
        var items = $excelTablePrototype;
        var self = this;
        
        return data.$resources.map(function(res){
            return items.map(function(item){
                var prop = res[item._orgName];
                var propProto = proto[item._orgName];
                var result = "";
                var record = res;
                
                if (res.$properties && res.$properties[item._orgName] && res.$properties[item._orgName].$isHidden) {
                    return result;
                }
                
                // manage limited set of types
                switch (item._type) {
                    case "application/x-string":
                    case "application/x-integer":
                    case "application/x-decimal":
                    case "application/x-datetime":
                    case "application/x-date":
                    case "application/x-time":
                    case "application/x-boolean":
                        result = prop;
                        break;
                    case "application/x-choice":
                        var ref = propProto.$value || propProto.$key;
                        if (ref && ref.$enum) {
                            for (var ii = 0, jj = ref.$enum.length; ii < jj; ii++) {
                                if (ref.$enum[ii] && ref.$enum[ii].$value !== undefined && ref.$enum[ii].$value === prop) {
                                    result = syra_expression.parse(self, ref.$enum[ii].$title);
                                    break;
                                }
                            }
                        }
                        else {
                            result = prop;
                        }
                        break;
                    case "application/x-reference":
                        record = prop;
                        propProto = propProto.$item || {};
                        var valueTemplate = item._bind || propProto.$value || propProto.$key;
                        result = (record && valueTemplate && (syra_expression.parse(self.$grid.$record, valueTemplate, record) || syra_expression.parse(self.$grid.$record, valueTemplate, res))) || "";
                        break;
                    default:
                        result = "";
                }
                if (record && propProto.$links && propProto.$links.$details) 
                    return [result, document.location.protocol + "//" + document.location.host + syra_site.$syracuseMainPageUrl +
                    "?url=" +
                    encodeURIComponent(syra_expression.parse(self.$grid.$record, propProto.$links.$details.$url, res, undefined, item._orgName))];
                else 
                    return result;
            });
        });
    },
    _initializeReferenceField: function(item, protoItem){
        item.$reference = {};
        this._parseSettings(item, protoItem, "$title");
        this._parseSettings(item, protoItem, "$value");
    },
    _parseSettings: function(item, protoItem, $property){
        var setting = item.$reference[$property] = {
            $itemProp: protoItem[$property] ? syra_expression.extractCode(protoItem[$property]) : $property
        };
        setting.$prop = protoItem[setting.$itemProp];
    },
    createExcelTableShell: function(linesCount){
        return (syra_site.isExcelLoaded && external.ResizeTable(this.$prototype.$datasourceName, JSON.stringify(this.$excelTablePrototype), linesCount, this.$prototype.cellAddress || "")) || !syra_site.isExcelLoaded;
    },
    applyChange: function(newData){
        // send to excel
        var self = this;
        var representation = this;
        var res = true;
        // make header
        var proto = representation.$prototype.$properties.$resources.$item.$properties;
        var dsName = representation.$prototype.$datasourceName;
        var items = self.$excelTablePrototype;
        // make data as array
        var data = self._makeExcelTableData(newData, proto, items);
        
        try {
            if (syra_site.isExcelLoaded && newData && newData.$startIndex && dsName && external.UpdateTable(dsName, JSON.stringify(items), JSON.stringify(data), newData.$startIndex - 1)) {
                // save datasource to document
                syra_site.excelDocument.updateDatasourceToDocument(representation.$prototype.$datasource, representation.$prototype.$datasourceName);
            }
            else 
                res = false;
        } 
        catch (err) {
            // do nothing
        }
        return res;
    }
});
