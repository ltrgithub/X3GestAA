"use strict";

var zip = require('streamline-zip');
var adminHelper = require("../../../../src/collaboration/helpers").AdminHelper;
var helpers = require('@sage/syracuse-core').helpers;

exports.DocxHelper = {

	/**
	 *  extract the docx buffer in document
	 * extract custom data if available -> call onCustomDataRead
	 * call onCustomDataWrite
	 * Write new document to response
	 * 
	 */
	serve_docx_buffer: function(_, response, document, onCustomDataRead, onCustomDataWrite) {
		var word_rels_document_xml_rels_name = "word/_rels/document.xml.rels";
		var content_typesName = "[Content_Types].xml";
		var word_rels_document_xml_rels;
		var content_types;

		var customXmlFile;
		var customXmlFiles = [];
		var xmlData;
		var customDataXml;

		var archive = new zip.Zip(response);

		new zip.Unzip(
			document,

			function(filename, filecontent, headers, _) {
				var customXmlNum;
				customXmlNum = filename.match(/customXml\/item([0-9]*?)\.xml/);

				if (customXmlNum && customXmlNum[1]) {
					customXmlFiles.push(customXmlNum);
					xmlData = filecontent.toString("utf8");
					if (xmlData.match(/<SyracuseOfficeCustomData>.*<\/SyracuseOfficeCustomData>/)) {
						customXmlFile = filename;
						onCustomDataRead(_, xmlData);
					} else {
						archive.add(_, {
							name: filename,
							data: filecontent
						});
					}
				} else if (filename === word_rels_document_xml_rels_name) {
					// Maybe this file has to be modified later, so don't add it to archive yet
					word_rels_document_xml_rels = filecontent;
				} else if (filename === content_typesName) {
					content_types = filecontent;
				} else {
					archive.add(_, {
						name: filename,
						data: filecontent
					});
				}
			}).unzip(_);

		customDataXml = onCustomDataWrite(_);
		if (customXmlFile) { // There is already a custom XML-File, just change the content
			archive.add(_, {
				name: customXmlFile,
				data: new Buffer(customDataXml)
			});
		} else {
			var newFileNum = 0;
			var rid = 0;
			var rels = word_rels_document_xml_rels.toString();

			while (customXmlFiles.indexOf(newFileNum++) >= 0); // Generate new unique filename for customXml
			while (rels.indexOf("Id=\"rId" + (rid++) + "\"") >= 0); // Generate new unique relation id for customXml

			// modify document.xml.rels
			var newRel = '<Relationship Id="rId' + rid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml" Target="../customXml/item' + newFileNum + '.xml"/>';
			word_rels_document_xml_rels = new Buffer(rels.replace("</Relationships>", newRel + "</Relationships>"));

			// Modify [Content_Types].xml
			content_types = new Buffer(content_types.toString().replace("</Types>", '<Override PartName="/customXml/itemProps' + newFileNum + '.xml" ContentType="application/vnd.openxmlformats-officedocument.customXmlProperties+xml"/></Types>'));

			var uid = helpers.uuid.generate().toUpperCase();
			var itemProps = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n' +
				'<ds:datastoreItem ds:itemID="{' + uid + '}" xmlns:ds="http://schemas.openxmlformats.org/officeDocument/2006/customXml"><ds:schemaRefs/></ds:datastoreItem>';

			archive.add(_, {
				name: "customXml/item" + newFileNum + ".xml",
				data: new Buffer(customDataXml)
			});
			archive.add(_, {
				name: "customXml/itemProps" + newFileNum + ".xml",
				data: new Buffer(itemProps)
			});
			archive.add(_, {
				name: "customXml/_rels/item" + newFileNum + ".xml.rels",
				data: new Buffer('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
					'<Relationship Id="rId' + rid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps" Target="itemProps' + newFileNum + '.xml"/></Relationships>')
			});
		}

		if (word_rels_document_xml_rels) archive.add(_, {
			name: word_rels_document_xml_rels_name,
			data: word_rels_document_xml_rels
		});
		if (content_types) archive.add(_, {
			name: content_typesName,
			data: content_types
		});

		archive.finish(_);
	},
	serve_docx_dir: function(_, response, tplPath, customDataXml) {
		new zip.Zip(response, {
			filter: function(_, name, entry) {
				return ['.svn', '.checksums', '.git'].indexOf(name) < 0;
			},
			transform: function(_, contents, entry) {
				if (entry.name !== 'customXml/item1.xml') return contents;
				return new Buffer(customDataXml);
			}
		}).add(_, {
			path: __dirname + tplPath
		}).finish(_);
	},
	get_template: function(_, doc_uuid) {
		var doc = {};
		var filter = {
			jsonWhere: {
				$uuid: doc_uuid
			}
		};
		var db = adminHelper.getCollaborationOrm(_);
		var docEntity = db.model.getEntity(_, "msoWordTemplateDocument");
		var documentInstance = db.fetchInstance(_, docEntity, filter);
		if (!documentInstance) {
			throw new Error("Unable to read document content");
		}
		doc.originalFileName = documentInstance.fileName(_);
		var content = documentInstance.content(_);
		if (!content.fileExists(_)) {
			throw new Error("Unable to read document content");
		}
		var document = content.createReadableStream(_).readAll(_);
		doc.content = document;
		return doc;
	},
	is_docx_format: function(_, buffer) {
		// header bytes of all xml based office documents (docx, xlsx, ...)
		// 50 4b 03 04 (This is actually a zip file header)
		return (buffer[0] == 0x50 && buffer[1] == 0x4b && buffer[2] == 0x03 && buffer[3] == 0x04);
	},
	get_supported_locales: function(_) {
		var db = adminHelper.getCollaborationOrm(_);
		var localePrefs = db.fetchInstances(_, db.model.getEntity(_, "localePreference"));

		return localePrefs.map_(_, function(_, e) {
			return {
				name: e.code(_),
				nativeName: e.description(_),
				englishName: e.description(_)
			};
		});
	},
	// Only used for testing
	get_doc: function(_, doc_uuid) {
		var doc = {};
		var filter = {
			jsonWhere: {
				$uuid: doc_uuid
			}
		};
		var db = adminHelper.getCollaborationOrm(_);
		var docEntity = db.model.getEntity(_, "document");
		var documentInstance = db.fetchInstance(_, docEntity, filter);
		if (!documentInstance) {
			throw new Error("Unable to read document content");
		}
		doc.originalFileName = documentInstance.fileName(_);
		var content = documentInstance.content(_);
		if (!content.fileExists(_)) {
			throw new Error("Unable to read document content");
		}
		var document = content.createReadableStream(_).readAll(_);
		doc.content = document;
		return doc;
	},
};

// Writable Stream that is intended to be used with janzip only and stored the result in memory
exports.DocxHelper.MemoryOutStream = helpers.defineClass(function() {
	this.writable = true;
	this.chunks = [];
	this.len = 0;
	this.emitter = {
		on: function(event) {},
		emit: function(event) {}
	};
}, null, {
	write: function(_, buffer) {
		this.chunks.push(new Buffer(buffer));
		this.len += buffer.length;
	},
	content: function(_) {
		return Buffer.concat(this.chunks, this.len);
	},
	close: function() {}
});