"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var registry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var util = require("util");
var fs = require('fs');
var PrintClient = require('./PrintClient').PrintClient;

function getClient(_, context) {
	if (!context.printServer)
		throw new Error('No print server registred in context.');
	var hostname = context.printServer.hostname;
	var port = context.printServer.port;
	if (!context.printClient) {
		context.printClient = new PrintClient(_, hostname, port);
	}
	return context.printClient;
}

function getDiagnose(severity, message) {
	return [JSON.stringify({
	    $diagnoses: [{
	        severity: severity,
	        message: message
	    }]
	})];
}


//URL is http://host/print/localhost:1890
var _serverMap = {
	walk: function(_, context, server, id) {
		console.log("Server: "+server);
		var parts = server.split(':');
		context.printServer = {
			hostname: parts[0],
			port: parts[1]
		}

		return _dispatch(_, context, _serviceMap);
	}
}

//URL is http://host/print/localhost:1890/$service('id')
var _serviceMap = {
		getState: function(_, context, id) {
			var _status = {
				99: locale.format(module, "unexpectedError"),
				98: locale.format(module, "unknowJob"),
				97: locale.format(module, "internalError"),
				0: locale.format(module, "jobStarted"),
				1: locale.format(module, "readDbPending"),
				2: locale.format(module, "readFinished"),
				3: locale.format(module, "readCanceled"),
				4: locale.format(module, "jobStacked"),
				5: locale.format(module, "jobFinished"),
				6: locale.format(module, "jobFailed"),
				7: locale.format(module, "jobCanceled"),
			}
            var headers = {
				"content-type": "application/json"
			};
			var cli;
			try {
				cli = getClient(_, context);
				var result = cli.getState(_, id);
	            var body = {
	            	phase: _status[result.code]
	            };
	            if (result.message) body.phaseDetail = result.message;
	            
	            var baseUrl = context.segments.slice(0,3).join('/');

	            if (result.code >= 0 && result.code < 5) {
	            	headers.location = baseUrl + "/$getState('"+id+"')";
	            	body.pollingMillis = 1000;
	            	context.reply(_, 202, body, headers);
	            }
	            else if (result.code >= 5 && result.code < 8) {
	            	headers.location = baseUrl + "/$getReport('"+id+"')";
	            	cli.disconnect(_);
	            	context.reply(_, 201, body, headers);
	            } else {
	            	cli.disconnect(_);
	            	context.reply(_, 500, getDiagnose('error', result.message), headers);
	            }
			} catch(e) {
            	if (cli) cli.disconnect(_);
            	context.reply(_, 500, getDiagnose('error', e.message), headers);
			}
		},
		getReport: function(_, context, id) {
			var cli;
			try {
				cli = getClient(_, context);
				var result = cli.getReport(_, id);
	            var headers = {
    				"content-type": result.mimeType
    			};
	            context.response.writeHead(200, headers);
	            context.response.end(result.binary, 'binary');
			} catch(e) {
	            var headers = {
    				"content-type": "application/json"
    			};
            	context.reply(_, 500, getDiagnose('error', e.message), headers);
			} finally {
				if (cli) cli.disconnect(_);
			}
		},
		cancelReport: function(_, context, id) {
            var headers = {
    				"content-type": "application/json"
    			};
            var cli;
			try {
				cli = getClient(_, context);
				var result = cli.cancelReport(_, id);
            	context.reply(_, 200, getDiagnose('info', locale.format(module, "jobCanceled")), headers);
			} catch(e) {
            	context.reply(_, 500, getDiagnose('error', e.message), headers);
			} finally {
				if (cli) cli.disconnect(_);
			}
		}
	}


function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	}
}


function _dispatch(_, context, map) {

	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		console.log("Pair: "+JSON.stringify(pair));
		if (pair.name[0] == '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}



function _logRequest(_, context) {
	if(!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity("navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var protocol = context.walkUrl();
		if (protocol != "print") throw new Error(locale.format(module, "badUrl"));
		
		// fire and forget log call
		_logRequest(null, context);
		
		_dispatch(_, context, _serverMap);
	} catch (ex) {
		if (ex.httpStatus) {
			return context.reply(_, ex.httpStatus, ex.message + "\n" + ex.stack);
		} else if (ex.stack) {
			console.error(ex.message + "\n" + ex.stack);
			return context.reply(_, 500, ex.message + "\n" + ex.stack);
		} else {
			console.error("CAUGHT NON ERROR: " + ex)
			return context.reply(_, 500, ex.toString());
		}
	}
}


exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + err.stack);
		}
	}
}