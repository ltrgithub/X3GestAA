"use strict";

function fixOptions(options) {
	options = options || {};
	options.allowedTags = (options.allowedTags || []).concat( //
	['h1', 'h2', 'h3', 'h4', 'h5', 'h6', //
	'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', //
	'b', 'i', 'strong', 'em', 'strike', 'code', //
	'hr', 'br', 'div', 'pre', //
	'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre']);
	options.allowedAttributes = (options.allowedAttributes || []).concat( //
	['class', 'href', 'src', 'name', 'target']);
	options.allowedSchemes = (options.allowedSchemes || []).concat( //
	['http', 'https', 'mailto']);
	return options;
}

function map(array) {
	return array.reduce(function(map, key) {
		map[key] = true;
		return map;
	}, {});
}

function escapeText(str) {
	return str.replace(/>/g, '&gt;');
}

function escapeComment(str) {
	return str.replace(/-->/g, '__>');
}

function escapeStyle(str) {
	// brutal: will cripple all occurrences of javascript, expression and url
	return str.replace(/\/\*.*?\*\//g, '').replace(/(\\|\b)(j\\?a\\?v\\?a\\?s\\?c\\?r\\?i\\?p\\?t|e\\?x\\?p\\?r\\?e\\?s\\?s\\?i\\?o\\?n|u\\?r\\?l)\b/ig, 'disabled-$1$2');
}

function escapeType(str) {
	// cripple type="text/javascript"
	return str.replace(/javascript/i, "disabled-javascript")
}

exports.escaper = function(options) {
	options = fixOptions(options);
	var allowedTags = map(options.allowedTags);
	var allowedAttributes = map(options.allowedAttributes);
	var allowedSchemes = map(options.allowedSchemes);
	var urlAttributes = /^(href|src|dynsrc|lowsrc|background)$/i;
	var preserve = options.preserve;
	var warn = options.warn;

	function checkChange(oldVal, newVal, prefix) {
		if (warn && newVal !== oldVal) warn(prefix + ": " + oldVal + " -> " + newVal);
		return newVal;
	}

	function escapeValue(key, val) {
		if (key === 'style') return checkChange(val, escapeStyle(val), "sanitized style");
		if (key === 'type') return checkChange(val, escapeType(val), "sanitized type attribute");
		return val;
	}

	function create() {
		var result = "";
		var inside = "text";

		function skipTillMarker(frag, marker, repl) {
			var i = frag.indexOf(marker);
			if (i >= 0) {
				if (preserve) result += escapeComment(frag.substring(0, i)) + repl + '-->';
				result += escapeText(frag.substring(i + marker.length));
				inside = "text";
			} else {
				if (preserve) result += escapeComment(frag);
			}
			return result;
		}

		function skipTillClosing(frag, tag, allowed) {
			var re = new RegExp('^/' + tag + '>', 'i');
			var m = re.exec(frag);
			if (m) {
				if (allowed) result += '</' + tag + '>';
				else if (preserve) result += '</' + tag + '>-->'
				result += escapeText(frag.substring(m[0].length));
				inside = "text";
			} else {
				if (allowed) result += escapeValue(tag, '<' + frag)
				else if (preserve) result += escapeComment('<' + frag);
			}
			return result;
		}

		function reject(frag, warn) {
			if (warn) warn("malformed element: " + frag);
			if (preserve) result += '<!--<' + escapeComment(frag) + '-->';
			return result;
		}

		function allowedValue(atb, val) {
			if (urlAttributes.test(atb)) {
				var colon = val.indexOf(':');
				if (colon < 0 || !allowedSchemes[val.substring(0, colon)]) return false;
			}
			return true;
		}

		function escapeTag(tag, closing, atbs, autoClosed) {
			if (closing) {
				result += '</' + tag + '>';
				atbs = atbs.trim();
				if (preserve && atbs) result += '<!--@' + escapeComment(atbs) + '-->'
				return;
			}
			result += '<' + tag;
			var end = 0;
			var re = /^\s*(\w+)(?:\s*=\s*(?:(["'])(.*?)\2|()([\w_-]+)))?/,
				m;
			while (m = re.exec(atbs)) {
				atbs = atbs.substring(m[0].length);
				var atb = m[1].toLowerCase();
				var quote = m[2] || '"';
				var val = m[3] || m[5];
				if (!allowedAttributes[atb] || !allowedValue(atb, val)) {
					if (warn) warn("forbidden attribute: " + atb);
					if (preserve) atb = "disabled-" + atb;
					else continue;
				}
				result += ' ' + atb + (val === undefined ? '' : '=' + quote + escapeValue(atb, val) + quote);
			}
			if (autoClosed) result += '/>';
			else result += '>';
			atbs = atbs.trim();
			if (warn && atbs) warn("malformed attribute: " + atbs);
			if (preserve && atbs) {
				result += '<!--@' + escapeComment(atbs) + '-->';
			}
		}

		return function(frag) {
			result = "";
			if (inside === "comment") return skipTillMarker('<' + frag, '-->', '');
			if (inside === "cdata") return skipTillMarker('<' + frag, ']]>', ']]');
			if (inside === "script") return skipTillClosing(frag, 'script');
			if (inside === "style") return skipTillClosing(frag, 'style', allowedTags.style);

			if (/^!--/.test(frag)) {
				inside = "comment";
				if (preserve) result += '<!-- '; // extra space marks as original comment for roundtripping
				return skipTillMarker(frag.substring(3), '-->', '');
			}
			if (/^!\[CDATA\[/.test(frag)) {
				inside = "cdata";
				if (warn) warn("forbidden CDATA");
				if (preserve) result += '<!--'
				return skipTillMarker(frag.substring(1), ']]>', ']]');
			}
			if (/^script\b/i.test(frag)) {
				inside = "script";
				if (warn) warn("forbidden *** SCRIPT *** element");
				if (preserve) result += '<!--';
				return skipTillClosing(frag, 'script');
			}
			if (/^style\b/i.test(frag)) {
				inside = "style";
				if (!allowedTags.style && warn) warn("forbidden STYLE element");
				if (preserve && !allowedTags.style) result += '<!--'
				return skipTillClosing(frag, 'style', allowedTags.style);
			}
			// Special contents have been intercepted.
			// Reject malformed tags
			var end = frag.indexOf('>');
			if (end < 0) return reject(frag, warn); // not closed
			var m = /^(\/?)(\w+)/.exec(frag);
			if (!m) return reject(frag, warn); // invalid syntax: tag name not found
			var tag = m[2].toLowerCase();
			if (!allowedTags[tag]) {
				if (warn && !m[1]) warn("forbidden " + tag.toUpperCase() + " element");
				if (preserve) reject(frag.substring(0, end + 1));
				escapeText(frag.substring(0, end + 1));
			} else {
				// tag is allowed
				var autoClosed = frag[end - 1] === '/';;
				escapeTag(tag, m[1], frag.substring(m[1].length + tag.length, autoClosed ? end - 1 : end), autoClosed);
			}
			result += escapeText(frag.substring(end + 1));
			return result;
		};
	};

	if (options.streaming) {
		return (function() {
			var process;
			return function(text) {
				if (text.indexOf('<') >= 0) throw new Error('internal error: bad HTML fragment');
				if (!process) {
					process = create();
					return escapeText(text);
				} else {
					return process(text);
				}
			}
		})();
	} else {
		return function(text) {
			var process = create();
			var frags = text.split('<');
			var result = escapeText(frags[0]);
			return frags.slice(1).reduce(function(r, frag) {
				return r + process(frag);
			}, result);
		};
	}
}