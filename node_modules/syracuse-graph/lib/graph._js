"use strict";

var locale = require("syracuse-core/lib/locale");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var flows = require('streamline-runtime').flows;

function _addNode(_, instance, maps) {
	// create related instance node
	var instNode;
	if (!(instNode = maps.instNodesMap[instance.$uuid])) {
		instNode = maps.instNodesMap[instance.$uuid] = {
			$category: maps.nodes[instance._meta.name].$index,
			$uuid: instance.$uuid
		};
		// add template properties
		var template = new resourceProxy.Template(maps.nodes[instance._meta.name].$prototype.$properties.$value);
		(template.matches || []).forEach_(_, function(_, match) {
			var propName = match.substring(1, match.length - 1);
			instNode[propName] = instance[propName](_);
		});
	}
}

function _addNodes(_, instance, relName, relMap, walked, maps, includeInst) {
	function _addLink(_, relatedInst) {
		if (!relatedInst) return;
		//
		_addNode(_, relatedInst, maps);
		// make link
		includeInst && maps.instLinks.push({
			$path: walked, // temp
			$category: maps.links[walked].$index,
			$source: maps.instNodesMap[instance.$uuid],
			$target: maps.instNodesMap[relatedInst.$uuid]
		});
		// walk
		flows.eachKey(_, relMap, function(_, locRelName, locRelMap) {
			_addNodes(_, relatedInst, locRelName, locRelMap, walked + "." + locRelName, maps, true);
		});
	}
	//
	if (!instance) return;
	if (relName[0] === "$") return;
	// add
	var rel = instance._meta.$relations[relName];
	if (!rel) throw new Error(locale.format(module, "relationNotFound", relName, instance._meta.name));
	//
	var relInst = instance[relName](_);
	if (rel.isPlural) relInst.toArray(_).forEach_(_, function(_, item) {
		_addLink(_, item);
	});
	else {
		_addLink(_, relInst);
	}
}

exports.replyGraph = function(_, context) {
	// syracuse entities !!!
	// use context.instance, context.graphName
	//
	var entity = context.entity;
	var prop = context.entity.$properties[context.graphName];
	if (!prop) throw new Error(locale.format(module, "propertyNotFound", context.graphName, entity.name));
	//
	if (!context.instance) throw new Error(locale.format(module, "instanceNotFound", context.entity.name, context.instanceId));
	// get categories
	var maps = prop.getGraphRelationsMaps(_);
	var i = 0;
	flows.eachKey(_, maps.nodes, function(_, nodeName, node) {
		node.$index = i++;
	});
	i = 0;
	flows.eachKey(_, maps.links, function(_, linkName, link) {
		link.$index = i++;
	});
	//
	maps.instNodesMap = {};
	maps.instLinks = [];
	// add first node
	if (prop.$includeSelf !== false) _addNode(_, context.instance, maps);
	// scan relations
	flows.eachKey(_, prop.$relations, function(_, relName, relation) {
		_addNodes(_, context.instance, relName, relation, relName, maps, (prop.$includeSelf !== false));
	});
	//
	var resource = {};
	// make an array out of nodes map. $index will be used to convert links references
	var index = 0;
	var nodes = Object.keys(maps.instNodesMap).map(function(key) {
		maps.instNodesMap[key].$index = index++;
		return maps.instNodesMap[key];
	});
	// convert link references
	resource.$links = maps.instLinks.map(function(link) {
		link.$source = link.$source.$index;
		link.$target = link.$target.$index;
		return link;
	});
	// delete $index technical value
	resource.$nodes = nodes.map(function(node) {
		delete node.$index;
		return node;
	});
	//
	context.reply(_, 200, resource);
};