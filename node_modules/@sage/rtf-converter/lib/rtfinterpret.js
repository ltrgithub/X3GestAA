"use strict";

var rtfparser = require('syracuse-rtf/lib/rtfparse');

exports.interpret = function(root) {

	var group;
	var documentModel = {
		deffont: "",
		fonts: {},
		colors: [],
		styles: {},
	};
	var fontfamgroups = {
		fnil: "Sans-serif",
		froman: "Sans-serif",
		fswiss: "Serif",
		fmodern: "Monospace",
		fscript: "Cursive",
		fdecor: "Cursive"
	};

	var supported = ["rtf", "ansi", "ansicpg", "deff", "fonttbl", "colortbl", "stylesheet", //
		"fs", "f", "cf", "highlight", "i", //
		"b", "ul", "strike", "plain", //
		"qc", "ql", "qr", "qj", "par", "pard", "pn"
	];

	function interpretFont(features, index, fonts) {
		var fname = features[0].word + features[0].arg;
		var font = (documentModel.fonts[fname] = {});
		for (var i = 1; i < features.length; i++) {
			interpretFontFeature(features[i], font);
		}
	}

	function interpretFontFeature(feature, font) {
		var sep;
		if (typeof feature == "string" && (sep = feature.indexOf(';')) > 0) {
			font.name = feature.substring(0, sep);
		}
	}

	function interpretStylesheet(features, index, styles) {
		var fname, style;
		if (features[0].word) {
			fname = features[0].word + features[0].arg;
			style = (documentModel.styles[fname] = {});
			for (var i = 1; i < features.length; i++) {
				interpretStyleFeature(features[i], style);
			}
		}
	}

	function interpretStyleFeature(feature, style) {
		var sep;
		if (typeof feature == "string" && (sep = feature.indexOf(';')) > 0) {
			style.name = feature.substring(0, sep);
		}
	}

	function interpretControl(node, parent, index) {
		switch (node.word) {
			case "rtf":
			case "ansi":
			case "ansicpg":
				break;
			case "stylesheet":
				parent.slice(1).filter(function(item) {
					// keep only arrays, remove newlines
					return Array.isArray(item);
				}).forEach(interpretStylesheet);
				//documentModel.stylesheet ="";
				break;
			case "deff":
				documentModel.deffont = "f" + node.arg;
				break;
			case "fonttbl":
				parent.slice(1).filter(function(item) {
					// keep only arrays, remove newlines
					return Array.isArray(item);
				}).forEach(interpretFont);
				break;
			case "colortbl":
				// semicolon counts for one item => skip 2 items first
				var i = 1;
				if (parent[i] === ';') {
					documentModel.colors.push([0, 0, 0]);
					i++;
				}
				while (i < parent.length) {
					documentModel.colors.push([parent[i].arg, parent[i + 1].arg, parent[i + 2].arg]);
					i += 4; // skip semicolon too
				} // while
				break;

			case "*":
				/*console.log(parent[index+1].word) ;*/
				if (supported.indexOf(parent[index + 1].word) == -1) parent.splice(index, parent.length - index);
				break;
		} //switch

	}

	function interpretNode(node, index, array) {
		if (Array.isArray(node)) {
			// child nodes will receive node as array argument.
			node.forEach(interpretNode);
		} else if (typeof node === "object") {
			interpretControl(node, array, index);
		}
	}

	/* on copie fonts et colors dans styles */
	interpretNode(root);
	return documentModel;
};