"use strict";

import * as iconv from './iconv';

var lowerLetter = {},
	digit = {},
	LF = '\n'.charCodeAt(0),
	SP = ' '.charCodeAt(0),
	BSLASH = '\\'.charCodeAt(0),
	OPEN = '{'.charCodeAt(0),
	CLOSE = '}'.charCodeAt(0),
	DASH = '-'.charCodeAt(0),
	QUOTE = "\'".charCodeAt(0),
	STAR = "*".charCodeAt(0),
	ACTUALQUOTE = "\\'";

var encodingCharsets = {
	'77': '10000', //Mac ,macintosh Î÷Å·×Ö·û(Mac)
	'128': '932', //Shift Jis ,ANSI/OEM - Japanese, Shift-JIS 
	'130': '1361', //Johab,Korean (Johab) 
	'134': '936', //GB2312
	'136': '10002', //Big5
	'161': '1253', //Greek
	'162': '1254', //Turkish
	'163': '1258', //Vietnamese,ANSI/OEM - Vietnamese 
	'177': '1255', //Hebrw
	'178': '864', //Arabic
	'179': '864', //Arabic Traditional
	'180': '864', //Arabic user
	'181': '864', //Hebrew user
	'186': '775', //Baltic
	'204': '866', //Russian
	'222': '874', //Thai
	'255': '437' //OEM
};

(function() {
	function add(clas, chs, i) {
		chs.split('').forEach(function(ch) {
			clas[ch.charCodeAt(0) + (i || 0)] = true;
		});
	}
	for (var i = 0; i <= 9; i++) add(digit, '0', i);
	for (var i = 0; i < 26; i++) add(lowerLetter, 'a', i);
})();

function builder(error) {
	var level = 0,
		createfontlist = false,
		fonts = [],
		font;
	return {
		open: function() {
			if (createfontlist) {
				level++;
			}
		},
		close: function() {
			if (createfontlist) {
				level--;
				if (level === 0) createfontlist = false;
			}
		},
		control: function(word, arg) {
			var obj = {
				word: word
			};
			if (arg != null) obj.arg = arg;
			if (word == 'fonttbl') {
				createfontlist = true;
				level++;
			}
			if (createfontlist) {
				switch (word.toLowerCase()) {
					case "f":
						font = fonts[arg] = new Object;
						break;
					case "fcharset":
						font.charset = arg;
						break;
					case "cpg":
						font.codepage = arg;
						break;
				}
			}
		},
		getFont: function(index) {
			return createfontlist ? undefined : fonts && fonts[index];
		}
	};
}

exports.parse = function(str) {
	if (!(str.indexOf(ACTUALQUOTE) > 0 && str.search(/fcharset[1-9]/i) > 0)) {
		return str;
	}

	str = str.replace(/\r\n/g, '\n');
	var pos = 0,
		posi = 0,
		begText = 0,
		len = str.length,
		line = 1,
		bld = builder(error),
		currFont,
		startpos = 0,
		replacementText = '';

	function error(msg) {
		var end = str.indexOf(/[\n>]/, pos);
		if (end < 0) end = str.length;
		return new Error("Invalid RTF: " + msg + " at line " + line + " near " + str.substring(pos, end));
	}

	while (pos < len) {
		var ch = str.charCodeAt(pos);
		switch (ch) {
			case BSLASH:
				var beg = ++pos;
				while (lowerLetter[ch = str.charCodeAt(pos)]) pos++;
				if (pos > beg) {
					var word = str.substring(beg, pos),
						arg = undefined;
					if (ch === DASH || digit[ch]) {
						beg = pos;
						pos++;
						while (digit[ch = str.charCodeAt(pos)]) pos++;
						arg = parseInt(str.substring(beg, pos), 10);
					}
					if (ch === SP || ch === LF || (word === "u" && ch !== BSLASH && ch !== OPEN && ch !== CLOSE)) {
						pos++;
					}
					if (word.toLowerCase() === 'f') currFont = bld.getFont(arg);
					bld.control(word, arg);
				} else if (ch === QUOTE) {
					if (currFont && currFont.charset && currFont.charset !== 0 && encodingCharsets[currFont.charset]) {
						var symb = str.substring(pos + 1, pos + 3);
						startpos = pos - 1;
						pos = pos + 3;
						//Cater for multibyte symbols
						while (str.charCodeAt(pos) === BSLASH && str.charCodeAt(pos + 1) === QUOTE) {
							symb += str.substring(pos + 2, pos + 4);
							pos = pos + 4;
						}
						var decodedText = iconv.decode(new Buffer(symb, "hex"), encodingCharsets[currFont.charset]);
						posi = 0;
						replacementText = '\\uc0';
						while (posi < decodedText.length) {
							replacementText += '\\u' + decodedText.charCodeAt(posi);
							posi++;
						}
						replacementText = replacementText + ' ';
						str = str.substring(0, startpos) + replacementText + str.substring(pos, str.length);
					}
				}
				begText = pos;
				break;
			case OPEN:
				bld.open();
				begText = ++pos;
				break;
			case CLOSE:
				bld.close();
				begText = ++pos;
				break;
			case LF:
				line++;
				begText = ++pos;
				break;
			default:
				pos++;
		}
	}
	return str;
};