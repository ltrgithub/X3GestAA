"use strict";
let _ext = require('@sage/syracuse-ui/lib/extend/extendGateway');
let _d3 = require('./deps/index');
let _ressourcePath = "/@sage/ui-d3-graph/public/";
let _locale = require('streamline-locale');
let _d3Slider = require('./d3RangeSlider');
let _axisDays = require('./gantt/axisDays');
let _axisMonths = require('./gantt/axisMonths');
let _toolTip = require('./gantt/taskToolTip');
let _sliderSettingsPath = '/@sage/ui-d3-graph/public/gantt/d3SliderSettings.json';
let _d3Scrollbar = require('./d3ScrollBar');

exports.stylesheets = [_ressourcePath + "ui-d3-graph.css"];

if (!Array.prototype.find) {
	Array.prototype.find = function (predicate) {
		if (this == null) {
			throw new TypeError('Array.prototype.find called on null or undefined');
		}
		if (typeof predicate !== 'function') {
			throw new TypeError('predicate must be a function');
		}
		var list = Object(this);
		var length = list.length >>> 0;
		var thisArg = arguments[1];
		var value;

		for (var i = 0; i < length; i++) {
			value = list[i];
			if (predicate.call(thisArg, value, i, list)) {
				return value;
			}
		}
		return undefined;
	};
}
_d3.selection.prototype.moveToFront = function () {
	return this.each(function () {
        this.parentNode.appendChild(this);
	});
};

_d3.selection.prototype.moveToBack = function () {
    return this.each(function () {
        var firstChild = this.parentNode.firstChild;
        if (firstChild) {
            this.parentNode.insertBefore(this, firstChild);
        }
    });
};

class Gantt {
    constructor(context) {
        this.context = context;
		this.locale = _locale.resources(module)();
    }
    setValue(data, metaData, parentDataRecord) {
		let self = this;
        if (data) {
			self.metaData = metaData; 
			_d3.json(_sliderSettingsPath, function (error, json) {
				if (json) {
					self.sliderSettings = json;
					self._processDataIn(data, self._applyMetadata(metaData));
					self._initialise();
					self._render();
				}
			});
		}
    }
	_applyMetadata(_metaData) {
		//check if prototype data in context or metaData (UI test page scenario)
		return this.context.prototype && this.context.prototype.$item ? this.context.prototype : (_metaData && _metaData.$properties && _metaData.$item) ? _metaData : null;
	}

	resize(sizer) {
		this._render(sizer);
	}
    dispose() {

    }
	//----------------------------- INITIALISATION -------------------------------------------
	_initTimeDomain() {
		if (this.tasks === undefined || this.tasks.length < 1) {
            this.minDate = _d3.time.day.offset(new Date(), -3);
            this.maxDate = _d3.time.hour.offset(new Date(), +3);
            return;
        }
        this.minDatestamp = _d3.min(this.tasks, d => d.startDate).getTime();
        this.maxDatestamp = _d3.max(this.tasks, d => d.endDate).getTime();
        this.minDate = new Date(this.minDatestamp - 8.64e7);
        this.maxDate = new Date(this.maxDatestamp + 8.64e7);
	}
	_initialise() {

		this.margin = {
            top: 20,
            right: 40,
            bottom: 80,
            chart: 150,
            left: 15,
			axis: 10,
			bars: 5
        };
		this._sizingAspectRatio = 0.7;
        this._maxBarHeight = 20;//250;	//Max height of bars
		this.dataPos = 0;
	}
	//----------------------------- MAIN GRAPH RENDERING -------------------------------------------
	_redraw(start) {
						
		var svg = _d3.select("svg");
		// var ganttChartGroup = svg.select(".gantt-chart-canvas");
		var rect = svg.select(".gantt-chart-canvas").selectAll("rect").data(this.tasks, d => d.startDate + d.taskName + d.endDate);
		rect
			.enter()
			.insert("rect")
			.attr("class", "bar");
		rect
			.transition()
			.attr("transform", d => "translate(" + this.xScale(d.startDate) + "," + this.yScale(d.taskName) + ")")
			.attr("height", d => _d3.min([this.yScale.rangeBand() - 5, this._maxBarHeight]))
			.attr("width", d => this.xScale(d.endDate) - this.xScale(d.startDate));
		rect.exit().remove();

		this._renderAxis();

	}

	_updateZoomFromChart() {

		this.zoom.x(this.xScale);

		let fullDomain = this.maxDate - this.minDate;
		let currentDomain = this.xScale.domain()[1] - this.xScale.domain()[0];

		let minScale = currentDomain / fullDomain;
		let maxScale = minScale * 30;

		this.zoom.scaleExtent([minScale, maxScale]);
	}

	//------------------------------------------------------------------------
	//							Axis
	//------------------------------------------------------------------------

	_initTimeAxis() {
		this.gridMonths = this.svgAxis.append("g").attr("class", "gantt-month-ticks");

		this.axisMonths = this.svgAxis.append("g").attr("class", "gantt-axis months")//;
			.attr('transform', 'translate(' + this.margin.chart + ',' + this.margin.axis + ')');

		let axisDaysYPos = this.margin.top + this.margin.axis;
		this.axisDays = this.svgAxis.append("g").attr("class", "gantt-axis days")//;
			.attr('transform', 'translate(' + this.margin.chart + ',' + axisDaysYPos + ')');
		let axisDaysCallback = function (process, dstart, dend) { }; //Should we want a callback for axis

		//Initialise and render the days and months axis
		this.axisMonths = _axisMonths.create(this.xScale, null);
		this.axisDays = _axisDays.create(this.xScale, axisDaysCallback);

		this.axisMonths.height = _d3.select('.gantt-axis.months').node().getBBox().height;
		this.axisDays.height = _d3.select('.gantt-axis.days').node().getBBox().height;
	}

	_renderAxis() {
		let self = this;
		self.axisDays.render();
		self.axisMonths.render();
		this._renderMonthTicks();
	}

	/**********************   Months Axis  ********************************* */
	_renderMonthTicks() {

		let self = this;
		let top = self.margin.axis;
		let left = self.margin.chart;
		self.xAxis.ticks(_d3.time.months, 1);
		_d3.select('.gantt-month-ticks').transition().attr('transform', 'translate(' + left + ',0)').call(self.xAxis);

		self.xAxis.tickSize(self.chartHeight);

		let data = self.xScale.ticks(_d3.time.months);
		let tick = _d3.select('.gantt-month-ticks').selectAll('.tick').data(data, d => d.getTime());
		let scale1 = self.xScale.copy();

		let scale0 = (self._renderMonthTicks && self._renderMonthTicks.scale) || scale1;
		let tickEnter = tick.enter().append('line');
		let tickUpdate = tick;
		let tickExit = tick.exit();

		self._renderMonthTicks.scale = scale1;

		// ENTER
		tickEnter.attr('class', 'tick')
			.attr('y2', self.chartHeight)//canvasHeight)
			.attr('transform', function (d) { return 'translate(' + scale0(d) + ', 0)'; });

		// UPDATE
		tickUpdate.attr('transform', function (d) { return 'translate(' + scale0(d) + ', 0)'; })
			.attr('y2', self.chartHeight);//canvasHeight);

		// EXIT
		tickExit.attr('transform', function (d) { return 'translate(' + scale0(d) + ', 0)'; })
			.remove();

		var axis = _d3.select(".axis.days");
		axis.moveToFront();
	}
	//------------------------------------------------------------------------
	//							MAIN CHART
	//------------------------------------------------------------------------
	_render(sizer) {

		let self = this;
		if (this.ganttData) {
			
			let _zoomHandler = function () {
				//Do not allow zooming to go beyond min and max dates in x domain
				if (self.xScale.domain()[0] < self.minDate) {
					let x = self.zoom.translate()[0] - self.xScale(self.minDate) + self.xScale.range()[0];
					self.zoom.translate([x, 0]);
				} else if (self.xScale.domain()[1] > self.maxDate) {
					let x = self.zoom.translate()[0] - self.xScale(self.maxDate) + self.xScale.range()[1];
					self.zoom.translate([x, 10]);
				}
				//Redraw main chart
				self._redraw();
				//Update the viewport in the navigation chart
				self._updateRangeSliderFromChart();

				self._renderAxis();
			};
			
			//--------------------- Setup Container ------------------------------
			syra_dom.toggleClass(this.context.div,"gantt-context", true);
			let slot = this.context.div;
			_ext.dom.empty(slot);
			let ganttFrame = syra_dom.div("svg-container");
			slot.appendChild(ganttFrame);
			if (sizer) {
				this.size = sizer.size;
			}
			this._width = Math.round(slot.clientWidth);
			if(this._width === 0) return;
			//--------------------- Tasks ------------------------------
			this.tasks = this.ganttData.resources;
			//Get distinct list of task types
			let taskTypes = this.tasks.map(o => o.taskName);
			this.taskTypes = taskTypes.filter(function (item, i, ar) { return ar.indexOf(item) === i; });
			
			//Size Gantt
			this._height = self.size ? self.size.height : Math.round(self._width * this._sizingAspectRatio);

			//This is the height if render all the tasks
			let canvasHeight = this.taskTypes.length * (this._maxBarHeight + (2 * this.margin.bars));
			this._sliderHeight = this.sliderSettings.height + this.sliderSettings.margin.top + this.sliderSettings.margin.bottom;
			//This is the estimated size based on the size of the tasks and approximate size of the other components
			let calculatedHeight = canvasHeight + this.margin.top + 75 + this.margin.bottom + this._sliderHeight; //15 = approximate height of legend
			this._height = Math.round(Math.min(self._height, Math.max(_ext.page.getBodySize(self.context).height * this._sizingAspectRatio, calculatedHeight)));

			this.svgDOM = _d3.select(".svg-container").append("svg")
				.attr("viewBox", "0 0 " + this._width + " " + this._height)
				.attr("height", this._height)
				.attr("width", this._width)
				.classed("svg-content-responsive", true);

			//--------------------- Time Domain -------------------------
			//Setup the time domain for the time axis
			this._initTimeDomain();

			//--------------------- Legend ------------------------------
			//Render the legend
			this._renderLegend();

			//--------------------- Chart Container --------------------
			self.chartHeight = (self._height - self.margin.top - self.legend._height - self.margin.bottom - self.sliderSettings.height);

			this.svgAxis = this.svgDOM.append('svg')
				.attr('class', 'gantt-chart-container')
				.attr('width', this._width - this.margin.right - this.margin.left)
				.attr('height', self.chartHeight)
				.attr('x', this.margin.left)
				.attr('y', self.legend._height + this.margin.top);

			//---------------------SCALES AND AXIS ------------------------------
			// x scales and axis
			this.xScale = _d3.time.scale()
				.domain([this.minDate, this.maxDate])
				.range([0, this._width - this.margin.right - this.margin.left - this.margin.chart]);

			this.xAxis = _d3.svg.axis().scale(this.xScale).tickSize(0, 0, 0);

			this._initTimeAxis();
			
			//This is the actual height that we have to render the tasks
			let graphHeight = self.chartHeight - self.axisDays.height - self.axisMonths.height;
			let graphWidth = this._width - this.margin.chart - this.margin.right - this.margin.left;
			
			this.xAxis
				.tickSize(graphHeight, graphHeight)
				.tickFormat('');

			
			this.yScale = _d3.scale.ordinal().domain(this.taskTypes).rangeRoundBands([0, canvasHeight], 0.1);
			this.yAxis = _d3.svg.axis()
				.scale(this.yScale)
				.orient('left');


			//---------------------RENDER CHART ---------------------------------
			//If the viewable height is less than the total height required we need to add a scrollbar
			canvasHeight > graphHeight && this._renderScrollBar(graphHeight, canvasHeight);
			
			let plotChart = self.svgAxis.append("g")
				.attr("class", "gantt-plot-area")
				.attr("width", graphWidth)
				// .attr("width", this._width - this.margin.chart - this.margin.right - this.margin.left)
				.attr("height", graphHeight)
				.attr('transform', 'translate(' + this.margin.chart + ',' + (self.axisDays.height + self.axisMonths.height) + ')');

			let plotArea = plotChart.append('defs');

			plotArea.append("clipPath")
				.attr('id', 'clip')
				.append("rect")
				.attr("width", graphWidth)
				.attr("height", self.chartHeight);

			plotChart.append("g")
				.attr("class", "gantt-chart-canvas")
				.attr("clip-path", "url(#clip)");
			
			//--------------------- Task Tool Tip ---------------------------------
			this._toolTip = _toolTip.create(this.locale);

			//--------------------- Main chart Grid ---------------------------------
			var rect = plotChart.select(".gantt-chart-canvas").append('g').attr('class', 'gantt-bar-container').selectAll("rect").data(this.tasks, d => d.startDate + d.taskName + d.endDate);

			rect.enter()
				.insert("rect")
				.attr("class", function (d) {
					let taskType = self.ganttData.taskTypesEnum && self.ganttData.taskTypesEnum.find(o => o.$title == d.taskType);
					return "gantt-bar gantt-task-type-" + (taskType ? taskType.$value : "other");
				})
				.on('mouseenter', function (d) {
					self._toolTip.onMouseOver(d, self.locale);
				}) //Show the tooltip
				.on('mouseleave', function (d) {
					self._toolTip.onMouseOut();
				});//Hide the tooltip		

			rect.attr("transform", "translate(0)")
				.transition()
				.attr("transform", d => "translate(" + this.xScale(d.startDate) + "," + this.yScale(d.taskName) + ")")
				.attr("height", d => _d3.min([this.yScale.rangeBand() - 5, this._maxBarHeight]))
				.attr("width", d => this.xScale(d.endDate) - this.xScale(d.startDate));

			//--------------------- Y AXIS ----------------------------------------
			
			
			this.yAxisGroup = plotChart.append("g")
				.attr("class", "gantt-y-axis");

			this.yAxisGroup.append('g')
				.attr('class', 'tick-container')
				.call(this.yAxis);

			plotArea.append("clipPath")
				.attr('id', 'y-clip')
				.append("rect")
				.attr("width", this.margin.chart)
				.attr("height", self.chartHeight)
				.attr("transform", "translate(" + (this.margin.chart * -1) + ", 0)");			

			this.yAxisGroup.attr("clip-path", "url(#y-clip)");

			//Add the y-axis heading
			let axisHeading = this.svgAxis.append("text")
				.attr("class", "gantt-axis-heading")
				.attr("y", 11);
				// no static people label since it's also used for manufactoring where "People" labe is wrong.
				// There is an epic to make this label dynamic in the future
				//.text(self.locale.gantt_peopleAssisgned);

			let textWidth = _d3.select('.gantt-axis-heading').node().getBBox().width;//Width of heading text
			axisHeading.attr("x", (this.margin.chart - textWidth) / 2); //Align in centre
			//--------------------- Grid Ticks ------------------------------------
			this._renderMonthTicks();

			//--------------------- Slider ----------------------------------------
			this._renderSlider(this._height - this.margin.bottom);

			//---------------------MAIN CHART ZOOM---------------------------------
			//Add an area overlay the main chart so we can zoom / pan anywhere on the chart
			//This pane is used for the mouse zooming on the main chart	
			var drw = self.svgAxis.append("rect")
				.attr("class", "gantt-pane gantt-border")
				.attr("width", this._width - this.margin.right - this.margin.chart - this.margin.left)
				.attr("height", self.chartHeight)//height - this.margin.top - this.margin.bottom)
				.attr("transform", "translate(" + this.margin.chart + ", 0)");


			//We need to move the pane behind so we can select task objects for details
			drw.moveToBack();

			this.zoom = _d3.behavior.zoom()
				.x(this.xScale)
				.on('zoom', _zoomHandler);

			self.svgAxis.select("rect.gantt-pane").call(this.zoom);

			_d3.select(".gantt-chart-canvas").selectAll("rect.gantt-bar").call(this.zoom);

			//-------------------- SYNCRONISE --------------------------------
			//Redraw to syncronise domains and zoom extents of both charts
			this._redraw();
			this._updateRangeSliderFromChart();
			//Update the extent for the zooming on the main chart
			this._updateZoomFromChart();
			this._addBorders();
		}


	}
	_addBorders() {
		let self = this;
		self.svgAxis.append('rect')
			.attr('x', 0)
			.attr('y', 0)
			.attr('class', 'gantt-border')
			.attr('width', this._width - this.margin.right - this.margin.left)
			.attr('height', this.chartHeight);

		self.svgAxis.append('rect')
			.attr('x', 0)
			.attr('y', 0)
			.attr('class', 'gantt-border')
			.attr('width', this._width - this.margin.right - this.margin.left)
			.attr('height', 15);

		self.svgAxis.append('rect')
			.attr('x', this.margin.chart)
			.attr('y', 0)
			.attr('class', 'gantt-border')
			.attr('width', this._width - this.margin.right - this.margin.left - this.margin.chart)
			.attr('height', 30);
	}
	_renderScrollBar(height, scrollViewSize) {
		
		let self = this;
		let xPos = this._width - this.margin.right;
		let yPos = self.legend._height + this.margin.top + self.axisDays.height + self.axisMonths.height - 10; //10 to align to canvas
		
		let verticalScrollBar = self.svgDOM.append("g")
			.attr("class", "gantt-vert-scroll-container")
			.attr("width", 20)
			.attr("height", height + this.margin.axis)
			.attr('transform', 'translate(' + xPos + ',' + yPos + ')');
		
		var callback = function (process, yPos) {
			if(process==='dragend'){
				//move the canvas chart
				_d3.select(".gantt-bar-container").attr('transform', 'translate(0,' + (yPos * -1) + ')');
				_d3.select(".tick-container").attr('transform', 'translate(0,' + (yPos * -1) + ')');
			}
		};
		
		let scollbarSettings = {
			containerId: 'gantt-vert-scroll-container',
			isVertical: true,
			itemCount: this.tasks.length,
			itemSize: (this._maxBarHeight + (2 * this.margin.bars)),
			width: 10,
			length: height + this.margin.axis,
			scrollviewSize: scrollViewSize
		};

		this.scrollbar = _d3Scrollbar.create(scollbarSettings, callback);
		

	}
	//------------------------------------------------------------------------
	//							LEGEND
	//------------------------------------------------------------------------
	_renderLegend() {
		let self = this;
		//Legend member
		let member = {
			rectWidth: 10,
			height: 10,
			margin: 5
		};
		let legendContainerWidth = this._width - this.margin.right - this.margin.chart - this.margin.left;

		let xPos = this.margin.chart + this.margin.left;
		let yPos = this.margin.top;
		let row = 1;

		this.legend = this.svgDOM.append("g")
			.attr("class", "gantt-legend-container")
			.attr("width", legendContainerWidth)
			.attr("transform", "translate(" + xPos + ", " + yPos + ")");

		let itemX = 0, itemY = member.margin;
		let itemCount = (this.ganttData.taskTypesEnum).length;

		for (let m = 0; m < itemCount; m++) {

			let type = this.ganttData.taskTypesEnum[m];

			let item = this.legend.append("g")
				.attr("class", "gantt-legend")
				.attr("id", "gantt-task-type-" + type.$value)
				.style('cursor', 'pointer')
				.on('click', function (d) {
					//Hide and show rects in chart when clicking on legend
					if (this.style.opacity === "" || this.style.opacity === "1") {
						this.style.opacity = "0.4";
					} else {
						this.style.opacity = "1";
					}
					var ganttChartGroup = _d3.select("svg").select(".gantt-chart-canvas");
					//Get all rects of task type and toggle class hidden
					var rect = ganttChartGroup.selectAll("rect." + this.id).classed("hidden", this.style.opacity != "1");
				});

			item.append("rect")
				.attr("class", "gantt-task-type-" + type.$value)
				.attr("x", member.margin)
				.attr("width", member.height)
				.attr("height", member.height);

			var legendText = item.append("text")
				.attr("class", "gantt-task-type-heading")
				.attr("x", (2 * member.margin) + member.height)
				.attr("y", member.height - 2)
				.text(function (d) {
					if ((type.$title).length > 20)
						return (type.$title).substring(0, 20) + "..."; //limit length of legend text
					else
						return type.$title;
				});
			//Each legend item contains a rect box and text with a margin on either side
			let legendWidth = legendText.node().getBBox().width + (3 * member.margin) + member.height;

			if (itemX + legendWidth > legendContainerWidth && m <= itemCount - 1) {
				row++;
				itemX = 0;
				itemY += member.height + member.margin;
			}

			item.attr("transform", "translate(" + itemX + ", " + itemY + ")");

			itemX += legendWidth;

		}
		row++; //Add an additional row for spacing between the legend and the main chart's canvas
		this.legend._height = (row * (member.height + member.margin)) + member.margin;

	}

	//------------------------------------------------------------------------
	//							SLIDER
	//------------------------------------------------------------------------
	_updateRangeSliderFromChart() {
		//if zoomed on chart update the slider range
		this.navigator.setHandles(this.xScale.domain()[0], this.xScale.domain()[1]);
	}

	_onBrush(dstart, dend) {
		//Resize the main charts xAxis domain
		this.xScale.domain([dstart, dend]).nice();//(self.viewport.empty() ? self.navXScale.domain() : self.viewport.extent());
		//Now we can redraw the main chart
		this._redraw();
		this._renderAxis();
	}
	_onBrushEnd() {
		this._updateZoomFromChart();
	}

	_renderSlider(y) {

		let self = this;

		//Configure specific wettings for slider
		this.sliderSettings.width = this._width - this.margin.right - this.margin.left - this.margin.chart;
		this.sliderSettings.minDate = this.minDate;
		this.sliderSettings.maxDate = this.maxDate;

		this.navChart = self.svgDOM;

		let yPos = y + this.legend._height;
		let xPos = this.margin.left + this.margin.chart;
		let navSvg = this.navChart.append("g")
			.attr("class", "gantt-slider-container")
			.attr("transform", "translate(0)")
			.attr("transform", "translate(" + xPos + ", " + yPos + ")");


		var callback = function (process, dstart, dend) {
			if (process == 'dragstart') {
				_d3.select('.gantt-chart-canvas').selectAll("rect").attr('opacity', 0.5);
			}
			else if (process === 'move') {
				self._onBrush(dstart, dend);
			} else if (process === 'dragend') {
				_d3.select('.gantt-chart-canvas').selectAll("rect").attr('opacity', 1);
				self._onBrushEnd();
			}
		};

		this.navigator = _d3Slider.create(this.tasks, this.sliderSettings, callback);

	}

	//------------------------------------------------------------------------
	//								DATA FORMATING
	//------------------------------------------------------------------------
	_getFormatedDate(_date, _duration) {
		//Convert 'yyyyMMddHHmm' string to date object
		let year = _date.substring(0, 4);
		let month = _date.substring(4, 6);
		let day = _date.substring(6, 8);
		let hour = _date.substring(8, 10);
		let minut = _date.substring(10, 12);
		year = year * 1;
		month = month * 1;
		day = day * 1;
		hour = hour * 1;
		minut = minut * 1;
		let d = _ext.culture.datetime.make(year, month, day, hour, minut);
		let durationInt = _duration ? parseFloat(_duration) : 0;
		d = d.addDayFractions(durationInt);
		return new Date(d._value);
	}
	_value(k, r, checkRaw, mustRaw, x3map) {
		let val, rawV, key = x3map[k], p = key && this.currentData.$properties[key];
		if (mustRaw && r.$rawV && (rawV = r.$rawV[key]) && rawV.v !== undefined) {
			val = rawV.v;
		}
		else {
			val = key && r[key];
			if (!val && checkRaw && r.$rawV && (rawV = r.$rawV[key]) && rawV.v !== undefined) {
				val = rawV.v;
			}
		}
		return p && val && ("" + val);

	}
	_getEnumeration(_item) {
		let enumerator = _item.$value && _item.$value.$enum ? _item.$value.$enum.slice() : [], //Used for UI test page case
		$fusionController = syra_fusion.syraUtil.getFusionController(this.context.field),
		fusionSess = $fusionController ? $fusionController.getSession() : null,
		enumArray = (fusionSess && _item.$mnu) && fusionSess.getMenloc(_item.$mnu);
		return  enumArray ?  enumArray.map(function(x, index) {
			return {
				$value: index + 1,
				$title: x
				
			};
		}) : enumerator;
	}
	_processDataIn(_data, _meta) {

		this.ganttData = {}; //this will store the formated data used to render the gantt chart
		this.currentData = this.currentData || {};
		this.currentData.$diagnosis = _meta && _meta.$diagnosis ? _meta.$diagnosis : _data && _data.$diagnosis ? _data.$diagnosis : null;
		if (_data) {
			this.currentData.$resources = _data; //original raw data from server
			let prototype = _meta || null;
			if (prototype) {
				if (prototype && prototype.$item.$properties) {
					//Get properties and bindings of raw data fields
					this.currentData.$properties = prototype.$item.$properties;
					this.$decorator = prototype.$decorator;
				}
			}
			//Get the raw data binding / mapping
			let $resources = this.currentData.$resources;
			let $properties = this.currentData.$properties || {};
			let x3Map = this.$decorator ? (this.$decorator.$bindings || this.$decorator.$mappings) : {};
			//Get the task type enum
			let taskTypeProp = $properties[x3Map["TYPDAY"]] || {};
			this.ganttData.taskTypesEnum = this._getEnumeration(taskTypeProp);

			// this.ganttData.taskTypesEnum = taskTypeProp.$value && taskTypeProp.$value.$enum.slice();
			//Add Other task so it is rendered in the legend
			// for(let k = 0; k< 20; k++){
			// this.ganttData.taskTypesEnum.push({
			// 	$value: "other" + k,
			// 	$title: "Other text goes here"
			// });

			// }
			this.ganttData.taskTypesEnum.push({
				$value: "other",
				$title: this.locale.gantt_otherTask
			});

			//Get taskMap = this is an array of ID mapped to taskName as name of task is only in first tasks object in array
			let taskNameIDMap = $resources.filter(o => o[x3Map["LIB"]] !== "").map(o => {
				return {
					id: o[x3Map["KEY"]],
					taskName: o[x3Map["LIB"]]
				};
			}); //This must be a unique set => originally used es6 Set but not IE supported
			
			
			// let taskNameIDMap = [...new Set($resources.filter(o => o.DB3 != "").map(o => {
			//     return {
			//         id: o.DB2,
			//         taskName: o.DB3
			//     };
			// }))];

			let cols = ["KEY", "DATDI", "DURI", "TYPDAY", "ELAP"];// we do not do "LIB" as this is return by tasknameIDMap,

			let formatedData = [], libKey = x3Map["LIB"];
			for (let i = 0; i < $resources.length; i++) {
				let r = $resources[i];
				if (r.$rawV[libKey].v === "") { //We process objects where LIB (i.e task name is not present) - based on x3 model
					let label = "", key, typ = "", sdate = "", dur = "", elapse = "";
					let task = {};
					for (let k = 0; k < cols.length; k++) {
						let col = cols[k];
						let value = this._value(col, r, col == "KEY" || col == "LIB", col == "DURI" || col == "ELAP", x3Map);
						switch (col) {
							case "KEY":
								key = value;
								break;
							case "LIB":
								label = value;
								break;
							case "DATDI":
								sdate = value;
								break;
							case "DURI":
								dur = value;
								break;
							case "TYPDAY":
								typ = value;
								break;
							case "ELAP":
								elapse = value;
								break;
						}
					}
					task.key = key;
					//not supported by IE
					// let taskNameID = taskNameIDMap.indexOf(o => o.id == key);

					let taskNameID = taskNameIDMap.find(o => o.id == key);
					task.taskName = taskNameID != null ? taskNameID.taskName : "";
					task.startDate = this._getFormatedDate(sdate);
					task.endDate = this._getFormatedDate(sdate, elapse);
					task.duration = dur;
					let taskType = this.ganttData.taskTypesEnum && this.ganttData.taskTypesEnum.find(o => o.$value == typ);
					task.taskType = taskType ? taskType.$title : this.locale.gantt_otherTask;//"Other";
					formatedData.push(task);
				}
				//iterate through each of the cols and get values
			}
			this.ganttData.resources = formatedData;
		}

	}
}
exports.isResizable = true;
exports.create = function (context) {
    return new Gantt(context);
};
