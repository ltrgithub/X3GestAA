let _d3 = require('../deps/index');
let _ressourcePath = "/ui-d3-graph/public/";
let _locale = require('streamline-locale');

class AxisMonths {
    constructor(xScale, callback) {
        this.xScale = xScale;
        this._initialise();
        this._render();
    }

    dispose() { }

    render() {
        this._render();
    }

    _render() {
        this._renderMonthNames();
    }

    _initialise() {
        var self = this;
        let top = self.top;
        let left = self.left;
        self.axisMonths = _d3.select('.gantt-axis.months');

        self.axisMonths.append('g')
            .attr('class', 'month-names')
            .attr('transform', 'translate(0, 0)');

    }

    // _renderMonthNames(eventType) {
    _renderMonthNames() {
        let self = this;

        let visibleMonths = self._getVisibleMonths();
        let monthName = _d3.select('.month-names').selectAll('.name').data(visibleMonths, d => d.getTime());
        let nameEnter = monthName.enter();
        let nameUpdate = monthName;
        let nameExit = monthName.exit();
        let scale0 = self.xScale;

        // ENTER
        nameEnter
            .append('text')
            .attr('class', 'name')
            .text(function (d) { return _d3.time.format('%B %Y')(d); })
            .call(self._setTextPosition, scale0);


        nameUpdate = nameUpdate.transition().duration(500);
        nameExit = nameExit.transition().duration(500);

        // UPDATE
        nameUpdate
            .call(self._setTextPosition, scale0);

        // EXIT
        nameExit
            .attr('opacity', 1e-6)
            .call(self._setTextPosition, scale0)
            .remove();

    }

    _getVisibleMonths() {
        let self = this;
        let domain = self.xScale.domain();
        var time = _d3.time.month.floor(domain[0]),
            end = _d3.time.month.floor(domain[1]),
            times = [time];
        while (time < end) {
            time = _d3.time.month.offset(time, 1);
            times.push(time);
        }
        return times;

    }
    _getVisibleDays() {
        let self = this;
        let domain = self.xScale.domain();
        times.push(_d3.time.day.floor(domain[0]));
        times.push(_d3.time.day.floor(domain[1]));
        return times;
    }

    _setTextPosition(selection, scale) {
        let self = this;
        // let dayToPixels = function (days, timeScale) {
        //     let d1 = new Date();
        //     timeScale || (timeScale = scale);
        //     return timeScale(_d3.time.day.offset(d1, days)) - timeScale(d1);
        // }
        
        //Get the start and end date displayed
        let domain = scale.domain();
        let dtStart = _d3.time.day.floor(domain[0]);
        let dtEnd =  _d3.time.day.floor(domain[1]);


        selection.each(function (d) {
            let width = this.getBBox().width; //width of the month text
            let minPos = 0, padding = 3, x, opacity = 1;
            let maxPos = scale.range()[1]; //x coordinate of max date in visible time domain
            
            let endOfMonth = _d3.time.month.offset(d, 1); 
            let rangeStart = d > dtStart ? d : dtStart; 
            let rangeEnd = endOfMonth > dtEnd ? dtEnd : endOfMonth;
            

            x = scale(rangeStart) + ((scale(rangeEnd) - scale(rangeStart))/ 2) - width / 2;
            //Check if the month is beyond the visible time domain
            if (x < minPos || x + width > maxPos) {
                opacity = 0.1;
            } 

            _d3.transition(_d3.select(this))
                .attr('y', 1)
                .attr('x', x)
                .attr('opacity', opacity);
        });
    }

    // _daysToPixels(days, timeScale) {
    //     //method return a relative pixel size based on the number of days
    //     let d1 = new Date();
    //     timeScale || (timeScale = this.xScale);
    //     return timeScale(_d3.time.day.offset(d1, days)) - timeScale(d1);
    // }


}
exports.create = function (xScale, callback) {
    return new AxisMonths(xScale, callback);
};