"use strict";
var _ext = require('syracuse-ui/lib/extend/extendGateway');
var _d3 = require('./deps/index');
var _colors = ["#024731", "#69923a", "#a8b400", "#3a3565", "#652d86", "#c1afe5"];
var _idIndex = 0;

var ForceLayout = function(context){
    context.div.className = "s-ui-d3-force-field";
    this.selectedCategories = {};
    this.context = context;
};

ForceLayout.prototype._render = function(sizer){
    var self = this;
    if (self.dataset) {
        if (self.dataset.$properties) {
            _ext.data.applyDelta(self.context, self.context.prototype, self.dataset.$properties);
        }
        var slot = self.context.div;
        _ext.dom.empty(slot);
        self.$$svg = _d3.select(_ext.dom.div("s-ui-d3-force-svg-wrap", slot)).append("svg");
        var svgDom = self.$$svg.node();
        
        if (sizer) {
            self.size = sizer.size;
        }
        self._width = Math.round(slot.clientWidth);
        self._height = self.size ? self.size.height : Math.round(self._width * 0.8);
        self._height = Math.round(Math.min(self._height, _ext.page.getBodySize(self.context).height * 0.9));
        
        svgDom.setAttribute("width", self._width);
        svgDom.setAttribute("height", self._height);
        self._width = 500;
        self._height = 400;
        svgDom.setAttribute("viewBox", "0 0 " + self._width + " " + self._height);
        svgDom.setAttribute("perserveAspectRatio", "xMinYMin");
        
        
        self._renderLegend();
        self.$nodes = [];
        self.$links = [];
        self.$force = _d3.layout.force() //
.linkStrength(2) //
.gravity(0.4) //
.friction(0.8) //
.charge(-500) //
.linkDistance(self._height / 4) //
        //.linkDistance(self._height / 3) //
        //.linkDistance([250])
        //.charge([-1500])
        //.gravity(0.3)
        
        .size([self._width, self._height]) //
.nodes(self.$nodes) //
.links(self.$links);

			//Define the toolTip slot
			self.graphTip = {
				slot: null,
				data: null
			};
			self.graphTip.slot = _ext.dom.div("s-ui-d3-force-tip hidden", slot);// syra_dom.addDiv("s-ui-d3-force-tip hidden", self.domItem);

        
        self._updateGraph();
        
        self.$force.on("tick", function(){
            self.linkElements &&
            self.linkElements.attr("x1", function(d){
                return d.source.x;
            }).attr("y1", function(d){
                return d.source.y;
            }).attr("x2", function(d){
                return d.target.x;
            }).attr("y2", function(d){
                return d.target.y;
            });
            if (self.nodeElements) {
                self.nodeElements.attr("cx", function(d){
                    return d.x;
                }).attr("cy", function(d){
                    return d.y;
                });
                self.nodeElements.attr("transform", function(d){
                    return "translate(" + d.x + "," + d.y + ")";
                });
            }
            self.textElements &&
            self.textElements.attr("dx", function(d){
                var dx = d.$item.$category == 0 ? 30 : 15;
                return (d.x >= self._width / 2) ? dx : -((d.value.length * 6) + dx);
            });
        });
    }
};

ForceLayout.prototype._renderLegend = function(sizer){
    var self = this;
    var member = {
        height: 12,
        width: 80,
        margin: 5
    };
    var cols = 4, margin = 10;
    var $nodeCategories = self.context.prototype.$nodeCategories || [];
    var rowCount = Math.ceil(($nodeCategories).length / cols);
    var left = Math.round((self._width - 2 * margin - (cols * (member.width + member.margin))) / 2);
    var top = self._height - (rowCount * member.height + 2 * member.margin + 2 * margin);
    var itemX = member.margin, itemY = member.margin;
    var crtRow = 0, crtCol = 0;
    // container should be an SVG
    self.categories = {};
    var i = 0;
    var svgLegend = self.$$svg.append("svg:g").attr("class", "s-ui-d3-force-svg-legend-container").attr("transform", "translate(" + left + "," + top + ")");
    $nodeCategories.forEach(function($categ){
        var $selected = self.selectedCategories[$categ.$title];
        if ($selected === undefined) {
            $selected = self.selectedCategories[$categ.$title] = $categ.$selected;
        }
        var category = self.categories[$categ.$title] = {
            item: svgLegend.append("svg:rect").attr("class", "s-ui-d3-force-svg-legend-check").attr("category", $categ.$title).attr("x", itemX).attr("y", itemY).attr("width", member.height).attr("height", member.height).attr("rx", 2).attr("ry", 2)
        };
        category.item.style("fill", function(d){
            return _colors[i++];
        });
        var textId = "ui_d3_graph_force_layout" + (++_idIndex);
        category.item.attr("text-node-id", textId);
        category.text = svgLegend.append("svg:text").attr("id", textId).attr("category", $categ.$title).attr("class", "s-ui-d3-force-legend-nodetext").attr("x", itemX + member.margin * 2 + member.height).attr("y", itemY + member.height - 3).text($categ.$title);
        !$selected && category.text.attr("class", "s-ui-d3-force-legend-nodetext-unselected");
        category.text.on("click", function(d){
            var name = this.attributes["category"].nodeValue;
            self.selectedCategories[name] = !self.selectedCategories[name];
            svgLegend.select("#" + this.id).classed("s-ui-d3-force-legend-nodetext-unselected", !self.selectedCategories[name]);
            self._updateGraph();
        });
        category.item.on("click", function(d){
            var name = this.attributes["category"].nodeValue;
            self.selectedCategories[name] = !self.selectedCategories[name];
            svgLegend.select("#" + this.attributes["text-node-id"].nodeValue).classed("s-ui-d3-force-legend-nodetext-unselected", !self.selectedCategories[name]);
            self._updateGraph();
        });
        if (crtCol++ == cols - 1) {
            crtCol = 0;
            crtRow++;
        }
        itemX = crtCol * (member.width + member.margin) + member.margin;
        itemY = crtRow * (member.height + member.margin) + member.margin;
    });
};

ForceLayout.prototype._updateGraph = function(){
    var self = this;
    self.nodeElements && self.nodeElements.on("click", null);
    self.$$svg.selectAll("g.s-ui-d3-force-node").remove();
    self.$$svg.selectAll("line.s-ui-d3-force-link").remove();
    var nodes = (self.dataset.$nodes || []).map(function(node, i){
        var proto = self.context.prototype.$nodeCategories[node.$category];
        return (self.selectedCategories[proto.$title]) ? {
            value: _ext.data.parseExpression(self.context, proto.$prototype.$properties.$value, node),
            title: proto.$title,
            $field: proto,
            $item: node,
        } : null;
    });
    self.$links = (self.dataset.$links || []).filter(function(link){
        return (nodes[link.$source] && nodes[link.$target]);
    }).map(function(link){
        return {
            source: nodes[link.$source],
            target: nodes[link.$target],
            $field: self.context.prototype.$linkCategories[link.$category]
        };
    });
    self.$nodes = nodes.filter(function(node){
        return node != null;
    });
    
    self.$force.nodes(self.$nodes).links(self.$links).start();
    var link = self.$$svg.selectAll("line.s-ui-d3-force-link").data(self.$links);
    // select missing links, create lines
    self.linkElements = link.enter().insert("svg:line", ".node").attr("class", "s-ui-d3-force-link").attr("x1", function(d){
        return d.source.x;
    }).attr("y1", function(d){
        return d.source.y;
    }).attr("x2", function(d){
        return d.target.x;
    }).attr("y2", function(d){
        return d.target.y;
    });
    
    // nodes
    // make nodes as groups to allow text elements grouped with circles
    var node = self.$$svg.selectAll("g.s-ui-d3-force-node").data(self.$nodes);
    // create nodes
    self.nodeElements = node.enter().append("svg:g").attr("class", "s-ui-d3-force-node").call(self.$force.drag);
    // add circle element
    self.nodeElements.append("circle").attr("class", "s-ui-d3-force-node").attr("r", function(d){
        return (d.$item.$category == 0) ? 20 : 10;
    }).style("fill", function(d){
        return _colors[d.$item.$category];
    }).on("click", function(d){
        var $links = d.$field.$prototype && d.$field.$prototype.$links;
        if ($links && $links.$default) {
            _ext.menu.fire(self.context, {
                $link: $links.$default,
                dataset: d.$item
            });
        }
    }).on('mouseover', function(d) { //Show the tooltip

			if (self.graphTip.data == d || this.style.opacity == "0") {
				return;
			}
			//Store which data element we are displaying data for
			self.graphTip.data = d;

			//Clear the contents of the tooltip
			var slot = _d3.select(".s-ui-d3-force-tip").selectAll("*").remove();
            
			//Add the task details to the tool tip
			_d3.select(".s-ui-d3-force-tip").append("div").attr("class", "s-ui-d3-force-tiptext").text(d.title + ": " + d.value);

			//Position and show the tooltip			
			var parentDomBounds = self.context.div.getBoundingClientRect();
			_d3.select(".s-ui-d3-force-tip")
				.style("left", (_d3.event.pageX - parentDomBounds.left) + "px")
				.style("top", (_d3.event.pageY - parentDomBounds.top - 50) + "px")
				.classed("hidden", false);

		}).on('mouseout', function() { //Hide the tooltip
			self.graphTip.data = null;
			_d3.select(".s-ui-d3-force-tip")
				.classed("hidden", true);
		});
    
    self.textElements = self.nodeElements.append("svg:text").attr("class", "s-ui-d3-force-nodetext").attr("dx", 12).attr("dy", ".35em").text(function(d){
        return d.value;
    });
};

ForceLayout.prototype.setValue = function(value){
    if (value && typeof(value) === 'object') {
        var self = this, fetch;
        if (!self.$lazyUrl) {
            self.$lazyUrl = self.context.prototype.$url;
            fetch = !!self.$lazyUrl;
        }
        if (value && value.$url && self.$lazyUrl != value.$url) {
            self.$lazyUrl = value.$url;
            fetch = true;
        }
        if (fetch) {
            _ext.data.fetch(self.context, {
                $url: self.$lazyUrl
            }, function(dataset, response){
                self.dataset = dataset;
                self._render();
            });
        }
        else {
            if (value.$nodes || value.$links) {
                self.dataset = value;
                self._render();
            }
        }
    }
};

ForceLayout.prototype.resize = function(sizer){
    this._render(sizer);
};

ForceLayout.prototype.dispose = function(){
    if (this.$force) {
        this.$force.stop();
        this.$force.on("tick", null);
    }
    if (this.categories) {
        var ids = Object.keys(this.categories);
        for (var ii = 0, jj = ids.length; ii < jj; ii++) {
            var cat = this.categories[ids[ii]];
            cat.item && cat.item.on("click", null);
            cat.text && cat.text.on("click", null);
        }
    }
    this.nodeElements && this.nodeElements.on("click", null);
};

exports.isResizable = true;
exports.stylesheets = ["/ui-d3-graph/public/ui-d3-graph.css"];
exports.create = function(context){
    return new ForceLayout(context);
};
