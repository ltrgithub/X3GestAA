"use strict";

let _d3 = require('./deps/index');
let _ressourcePath = "/@sage/ui-d3-graph/public/";
let _locale = require('streamline-locale');

exports.stylesheets = [_ressourcePath + "ui-d3-graph.css"];

class d3RangeSlider {

	constructor(dataset, settings, callback) { //Todo
        let self = this;
		this.elements = {
			min: { value: 0 },
			max: { value: settings.width }
		};
		if (settings.minDate || settings.maxDate) {

			this.settings = {
				containerId: settings.containerId,
				min: 0,
				max: settings.width,
				minDate: settings.minDate,
				maxDate: settings.maxDate,
				radius: settings.radius,
				offset: Math.floor(settings.radius / 2),
				color: settings.color,
				opacity: {
					full: 1.0,
					medium: 0.8,
					half: 0.5,
					light: 0.3
				},
				callback: callback
			};
			this.timeScale = _d3.time.scale()
				.domain([this.settings.minDate, this.settings.maxDate])
				.range([0, this.settings.max]);

			//Allow slider to zoom in to max a day resolution
			this.maxZoom = this.timeScale(new Date(this.settings.minDate.getTime() + 86400000));
			//Format for date text
			this.dateTimeFormat = _d3.time.format("%d %b %Y, %Hh%M");

			this.locale = _locale.resources(module)();
			this._init();

		}
    }
    dispose() { }

	setHandles(startDate, endDate) {
		let xMin = this.timeScale(startDate);
		let xMax = this.timeScale(endDate);
		this._move(this.elements.$min, xMin);
		this._move(this.elements.$max, xMax);
	}

	_translator(x) {
		let self = this;
		let ret = {
			x: x,
			value: self.timeScale.invert(x),
			text: null
		};
		if (ret.value) {
			ret.text = self.dateTimeFormat(ret.value);
		};
		return ret;
	}
	_move(handle, x, runCallback) {
        let self = this;


        var resetBar = function (x, width) {
			//no error checking
			self.elements.$bar.attr({
				x: Math.max(x - self.settings.offset, 0), width: Math.max(width, 0)
			});
        };

		if (handle == self.elements.$min) {
			if (x >= self.settings.min && x <= (self.elements.max.value - self.maxZoom)) {
				self.elements.min.value = x;
				self.elements.$min.attr('cx', x);
				// self.elements.$minText.attr('x', x).text(self.settings.translater.apply(self, [x]).text);
				resetBar(x, self.elements.max.value - x);
				runCallback && self._runCallback('move');
			}

		} else if (handle == self.elements.$max) {
			if (x >= (self.elements.min.value + self.maxZoom) && x <= self.settings.max) {
				self.elements.max.value = x;
				self.elements.$max.attr('cx', x);
				// self.elements.$maxText.attr('x', x).text(self.settings.translater.apply(self, [x]).text);
				resetBar(self.elements.min.value, x - self.elements.min.value);
				runCallback && self._runCallback('move');
			}
		}
	}
	_runCallback(process) {
		let self = this;
		if (self.settings.callback) {
			self.settings.callback.apply(self, [
				process,
				self._translator.apply(self, [self.elements.min.value]).value,
				self._translator.apply(self, [self.elements.max.value]).value
            ]);
		}
	}

	_dragstart(_element) {
		let self = this;
		_element.attr('fill-opacity', self.settings.opacity.full);
        //   $text.attr('fill-opacity', self.settings.full);
		self.elements.$bar.attr('fill-opacity', self.settings.opacity.light);
        self._runCallback('dragstart');
	}

	_dragend(_element) {

		let self = this;

		_element.attr('fill-opacity', self.settings.opacity.full);
        //   $text.attr('fill-opacity', self.settings.medium);
		self.elements.$bar.attr('fill-opacity', self.settings.opacity.full);
        self._runCallback('dragend');
	}

    _init() {

		let self = this;

		var g = _d3.select('.' + this.settings.containerId);

        //draw the line
        g.append('line')
            .attr('x1', this.settings.min)
            .attr('y1', this.settings.radius)
            .attr('x2', this.settings.max)
            .attr('y2', this.settings.radius)
            .attr('stroke-width', 1)
            .attr('stroke', '#cfcfcf');

		//build the bar
		let drag$Bar = _d3.behavior.drag().origin(function () {
			let t = _d3.select(this);
			return { x: t.attr('x'), y: t.attr('y') };
		})
			.on('drag', function () {
				let rect = _d3.select(this);
				let width = rect.attr('width');
				let $max = _d3.event.x + parseFloat(width);

				if (_d3.event.x >= self.settings.min && (_d3.event.x + parseFloat(width)) <= self.settings.max) {
					_d3.select(this).attr('x', _d3.event.x);
					self._move(self.elements.$min, _d3.event.x, true);
					self._move(self.elements.$max, $max, true);

				}
			})
			.on('dragend', function () {
				self._dragend(self.elements.$min);
				self._dragend(self.elements.$max);

			});


		this.elements.$bar = g.append('rect')
			.attr('class', 's-ui-d3-slider-bar')
			.attr('x', this.settings.offset)
			.attr('width', this.settings.max - (this.settings.offset * 2))
			.attr('y', this.settings.offset + 1)
			.attr('height', 3)
			.attr('fill', this.settings.color)
			.attr('fill-opacity', this.settings.opacity.full)
			.attr('cursor', 'e-resize')			
			.call(drag$Bar)
			.on('mouseover', function(d) {
				_d3.select(this).attr('height', 6);
			})
			.on('mouseout', function(d) {
				_d3.select(this).attr('height', 3)
			});

		//build the handles
		this.elements.$min = g.append('circle')
			.style('cursor', 'pointer')
			.attr('cx', this.settings.min)
			.attr('cy', this.settings.radius)
			.attr('r', this.settings.radius)
			.attr('fill', this.settings.color)
			.attr('fill-opacity', this.settings.opacity.full);

		this.elements.$max = g.append('circle')
			.style('cursor', 'pointer')
			.attr('cx', this.settings.max)
			.attr('cy', this.settings.radius)
			.attr('r', this.settings.radius)
			.attr('fill', this.settings.color)
			.attr('fill-opacity', this.settings.opacity.full);

		//This can be uncommented to add text for the min and max bars

		// this.elements.$minText = g.append('text')
		// 	.attr('x', this.settings.min)
		// 	.attr('y', this.settings.radius * 3 + this.settings.offset)
		// 	.attr('fill', 'black')
		// 	.attr('fill-opacity', this.settings.opacity.medium)
		// 	.attr('text-anchor', 'middle')
		// 	.text(self.translator.apply(self, [this.settings.min]).text);

		// this.elements.$maxText = g.append('text')
		// 	.attr('x', this.settings.max)
		// 	.attr('y', this.settings.radius * 3 + this.settings.offset)
		// 	.attr('fill', 'black')
		// 	.attr('fill-opacity', this.settings.opacity.medium)
		// 	.attr('text-anchor', 'middle')
		// 	.text(this.translator.apply(self, [this.settings.max]).text);

		this.elements.$min.call(_d3.behavior.drag()
			.on('dragstart', function (d) {
				self._dragstart(self.elements.$min);
			})
			.on('drag', function () {
				self._move(self.elements.$min, _d3.event.x, true);
			})
			.on('dragend', function () {
				self._dragend(self.elements.$min);
			}));


		this.elements.$max.call(_d3.behavior.drag()
			.on('dragstart', function (d) {
				self._dragstart(self.elements.$max);
			})
			.on('drag', function () {
				self._move(self.elements.$max, _d3.event.x, true);
			})
			.on('dragend', function () {
				self._dragend(self.elements.$max);
			}));
    }

}


exports.create = function (dataset, settings, callback) {
    return new d3RangeSlider(dataset, settings, callback);
};
