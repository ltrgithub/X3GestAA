"use strict";
var _ext = require('syracuse-ui/lib/extend/extendGateway');
var _chartMenu = require("./menu/chartMenu");
var debug = false;
var STROKE_WIDTH = 'stroke-width', IMAGE_PLACEHOLER = "$placeholder", UNDEFINED;
var MIN_WIDTH = 50, CHART_SPACING_LEFT = 45, CHART_SPACING_TOP = 45;

require('./deps/highcharts/highcharts.src');
require('./deps/highcharts/highcharts-more.src');
require('./deps/highcharts/modules/exporting.src');
Highcharts.theme = require('./highchartTheme').theme;
Highcharts.setOptions(Highcharts.theme);
var _orgOptions = Highcharts.getOptions().orgChart;

function _getInteractDec(){
    return {
        "spgm": "AMAJHIER:MAJHIER",
        "params": [{
            "dim": 1,
            "typ": "STRU",
            "siz": 1
        }, {
            "dim": 1,
            "typ": "INT",
            "siz": 0
        }, {
            "dim": 1,
            "typ": "INT",
            "siz": 0
        }, {
            "dim": 1,
            "typ": "INT",
            "siz": 0
        }, {
            "dim": 1,
            "typ": "STRU",
            "siz": 100
        }, {
            "dim": 1,
            "typ": "INT",
            "siz": 0
        }]
    };
}

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj){
    return obj !== UNDEFINED && obj !== null;
}

// For interaction with X3 the following subprog from AMAJHIER is used
// Subprog MAJHIER(CODACT,NLI,FATHVAL,RANGNIV,MESSAGE,CODRET)
// #     CODACT  : Action code
// #           D : Delete
// #           M : Modify
// #           E : Click on a leaf element
// #     NLI     : Line number of the element (1..n)
// #     FATHVAL : Line number of the parent element (1..n)
// #     RANGNIV : Where to move
// #           0 : As a child of the target
// #          -1 : As a sibling before the target
// #           1 : As a sibling after the target
// #     MESSAGE : Message
// #     CODRET  : Return status: 1 if OK
//
// changing parent ==> AMAJHIER.MAJHIER("M", node, parent, RANGNIV=(-1 or 1) when ?, "", -1)
// double-click ==> AMAJHIER.MAJHIER("E",node,"", 0, "", -1)
//
// MODHIE => !$allowMove
// EXECFL => $allowDoubleClick
// PINTER => $interact
// SIZEB  => $boxSize
//        Format : H,W or H,W,S
//             H : Height in pixel
//             W : Width in pixel
//             S : Text height in pixel, defauly is 20px
// styles => $style

var _reparenter = {
    left: function(node, target){
        return this.sibling(node, target, 0, -1);
    },
    right: function(node, target){
        return this.sibling(node, target, 1, 1);
    },
    sibling: function(node, target, n, r){
        if (!target.parent) {
            return null;
        }
        var i = node.parent.children.indexOf(node), parent = target.parent;
        node.parent.children.splice(i, 1);
        node.parent = parent;
        i = parent.children.indexOf(target);
        parent.children.splice(i + n, 0, node);
        return r;
    },
    bottom: function(node, target){
        if (node.parent === target) {
            return null;
        }
        var i = node.parent.children.indexOf(node);
        node.parent.children.splice(i, 1);
        node.parent = target;
        target.children.splice(0, 0, node);
        return 0;
    }
};

function traverse(node, visitor){
    visitor(node);
    // visit children
    node.children.forEach(function(child){
        traverse(child, visitor);
    });
}


function _clearNode(node){
    if (node) {
        var children = node.children || [];
        children.forEach(_clearNode);
        delete node.rect;
        node.slot && node.slot.destroy && node.slot.destroy();
        delete node.slot;
        node.junction && node.junction.destroy && node.junction.destroy();
        if (node.children) {
            node.children.length = 0;
        }
        delete node.junction;
        delete node.children;
        delete node.parent;
        delete node.id;
        delete node.parentId;
    }
}

function OrgChartWidget(item, chart){
    this.item = item;
    this.chart = chart;
    this.useHtml = false;
    this.scaleX = 1.0;
    this.scaleY = 1.0;
    this.xMax = 0;
    this.yMax = 0;
}

OrgChartWidget.prototype = {
    // see http://jsfiddle.net/7UsbM/7/ for drag'n drop
    draw: function(root){
        var self = this;
        var renderer = self.chart.renderer;
        var options = self.chart.options;
        var $decorator = self.item.context.prototype.$decorator;

        var bbox = null, tree = renderer.g("tree").attr({
            scaleX: this.scaleX,
            scaleY: this.scaleY
        }).add(), dropMarker = renderer.rect(-999, -999, 10, 10).attr({
            'stroke-width': _orgOptions.dropMarker.borderWidth,
            stroke: _orgOptions.dropMarker.borderColor,
            fill: _orgOptions.dropMarker.backgroundColor,
            'fill-opacity': _orgOptions.dropMarker.backgroundOpacity
        }).add(tree), workerNoImage = self._nodeSlot("", -999, -999).add(tree), worker = self._nodeSlot("", -999, -999, IMAGE_PLACEHOLER).add(tree), // create the label
 tooltip = renderer.label('', 0, 0, null, null, null, true, null, 'tooltip').attr({
            // padding: padding,
            fill: _orgOptions.tooltip.backgroundColor,
            'fill-opacity': _orgOptions.tooltip.backgroundOpacity,
            stroke: _orgOptions.tooltip.borderColor,
            'stroke-width': _orgOptions.tooltip.borderWidth,
            r: _orgOptions.tooltip.borderRadius,
            zIndex: 8
        }).css(_orgOptions.tooltip.style).hide().add(tree);

        var hasTouch = 'ontouchstart' in window, START = 'mousedown', MOVE = 'mousemove', END = 'mouseup';

        if (hasTouch) {
            START = 'touchstart';
            MOVE = 'touchmove';
            END = 'touchend';
        }

        var interactDesc = _getInteractDec();
        interactDesc.spgm = ($decorator.$interact || "AMAJHIER") + ":MAJHIER";

        function normalizeEvent(e){
            var props = ['clientX', 'clientY', 'pageX', 'pageY'], i, l, n;

            if (['touchstart', 'touchmove', 'touchend'].indexOf(e.type) > -1) {
                for (i = 0, l = props.length; i < l; i++) {
                    n = props[i];
                    e[n] = e.originalEvent.targetTouches[0][n];
                }
            }

            return e;
        }

        function positionNode(node, left, top){
            var x = 0, y = 0, vGap = 10, hGap = 10, cw = 0;

            node.rect = node.rect || {};
            bbox = (node.image ? worker : workerNoImage).attr({
                text: node.desc,
                // image: node.image
            }).getBBox();
            node.rect.width = Math.max(Math.ceil(bbox.width), MIN_WIDTH);
            node.rect.height = Math.ceil(bbox.height);
            if (node.children.length > 0) {
                x = left;
                // the top coordinate of children
                y = top + node.rect.height + vGap;
                node.children.forEach(function(child){
                    cw = positionNode(child, x, y);
                    // the left coordinate of the next child
                    x += cw + hGap;
                });
                // center Node between Left and(x - GapH) with top coordinate at Top
                node.rect.x = Math.abs(left + (x - hGap) - node.rect.width) / 2;
                node.rect.y = top;
                self.xMax = Math.max(self.xMax || 0, node.rect.x + node.rect.width);
                self.yMax = Math.max(self.yMax || 0, node.rect.y + node.rect.height);
                // width of tree rooted at Node
                return Math.max(node.rect.width, x - hGap - left);
            }
            else {
                // position Node with top-left coordinate at (Left, Top)
                node.rect.x = left;
                node.rect.y = top;
                self.xMax = Math.max(self.xMax || 0, node.rect.x + node.rect.width);
                self.yMax = Math.max(self.yMax || 0, node.rect.y + node.rect.height);
                return node.rect.width;
            }
        }

        function showDropMarker(node, dropHint){
            var x = node.slot.x, y = node.slot.y, w = node.slot.width, h = node.slot.height, size = 5, margin = 2;
            switch (dropHint) {
                case "left":
                    x -= (size + margin);
                    w = size;
                    break;
                case "right":
                    x += w + margin;
                    w = size;
                    break;
                case "bottom":
                    y += h + margin;
                    h = size;
                    break;
            }
            dropMarker.toFront().attr({
                x: x,
                y: y,
                width: w,
                height: h
            }).show();
        }

        function hideDropMarker(){
            dropMarker.hide();
            if (drag)
                delete drag.dropHint;
            tooltip.hide();
        }

        function drawNode(node, parent){
            parent = parent || node.parent;
            var rect = node.rect, pRect = parent ? parent.rect : rect;
            var p1 = {
                x: rect.x + rect.width / 2,
                y: rect.y
            }, p2 = {
                x: pRect.x + pRect.width / 2,
                y: pRect.y + pRect.height
            };
            // draw Node into the rectangle
            if (parent) {
                node.junction && node.junction.renderer && node.junction.destroy();
                node.junction = renderer.path(['M', p1.x, p1.y, 'L', p1.x, (p1.y + p2.y) / 2, 'L', p2.x, (p1.y + p2.y) / 2, 'L', p2.x, p2.y]).attr({
                    'stroke-width': _orgOptions.junction.lineWidth,
                    stroke: _orgOptions.junction.lineColor
                }).add(tree);
            }
            node.slot && node.slot.renderer && node.slot.destroy();
            var nodeSlot = node.slot = self._nodeSlot(node.desc, rect.x, rect.y, node.image).add(tree);

            Highcharts.addEvent(nodeSlot.element, 'mouseenter', function(e){
                if (drag && drag.node && drag.node !== node) {
                    drag.target = node;
                }
                self.chart.hoverNode = node;
                showTooltip(e);
                nodeSlot.attr('fill', _orgOptions.node.hover.backgroundColor);
                nodeSlot.css({
                    color: _orgOptions.node.hover.textColor
                });
            });
            Highcharts.addEvent(nodeSlot.element, 'mouseleave', function(e){
                if (drag && drag.target) {
                    delete drag.target;
                }
                hideDropMarker();
                tooltip.hide();
                delete self.chart.hoverNode;
                nodeSlot.attr('fill', _orgOptions.node.backgroundColor);
                nodeSlot.css({
                    color: _orgOptions.node.textColor
                });
            });
            Highcharts.addEvent(nodeSlot.element, 'dblclick', function(e){
                onDoubleClick(node);
            });
            // Highcharts.addEvent(nodeSlot.element, 'click', function(e) {
            // 	setTimeout(function() {
            // 		onClick(node, e);
            // 	}, 100);
            // });
            nodeSlot.on('click', function(e){
                setTimeout(function(){
                    onClick(node, e);
                }, 100);
            });

            // draw children
            node.children.forEach(function(child){
                drawNode(child, node);
            });
        }

        var container = self.chart.container, $container = $(container), drag, initDrag = {
            x: 0,
            y: 0
        };

        function initStartDrag(e){ //onmousedown
            var scrollview = self.item.context.div;
            self.scrollViewRect = syra_dom.getBoundingClientRect(scrollview);
            self.scrollViewRect.item = scrollview;
            self.scrollViewRect.scrollWidth = scrollview.scrollWidth;
            self.scrollViewRect.scrollHeight = scrollview.scrollHeight;
            initDrag = {
                x: e.pageX,
                y: e.pageY
            };
        }

        function startDrag(e){ //move if initdrag
            e = normalizeEvent(e);
            var hoverNode = self.chart.hoverNode;
            // if (hoverNode && hoverNode.series.options.draggable) {
            if (hoverNode) {
                tooltip.hide();
                drag = {
                    node: hoverNode,
                    x: e.pageX,
                    y: e.pageY
                };
                traverse(drag.node, function(node){
                    if (!node)
                        return;
                    node.slot.element.parentNode.insertBefore(node.slot.element, worker.element.nextSibling);
                    node.drag = {
                        slot: {
                            x: node.slot.translateX,
                            y: node.slot.translateY
                        }
                    };
                    if (node.junction) {
                        node.drag.junction = {
                            x: node.junction.translateX || 0,
                            y: node.junction.translateY || 0
                        };
                    }
                });
            }
        }

        function dragSnapshotClear(tree){
            traverse(tree, function(node){
                node.drag && delete node.drag;
                node.children.forEach(function(child){
                    dragSnapshotClear(child);
                });
            });
        }

        function move(e){
            if ((initDrag.x || initDrag.y) && ((initDrag.x - e.pageX) || (initDrag.y - e.pageY))) {
                startDrag(e);
                initDrag = {
                    x: 0,
                    y: 0,
                    scrollOffsetleft: self.scrollViewRect.item.scrollLeft
                };
            }
            var parentOffset, dropHint, pos;
            e = normalizeEvent(e);
            if (drag && drag.node) {
                self.scrollViewRect && syra_pageBuilder.autoScroll(self.scrollViewRect, e);
                //Reposition the dragged node if autoscrolled
                e.pageX += (self.scrollViewRect.item.scrollLeft - initDrag.scrollOffsetleft);

                var delta = {
                    x: e.pageX - drag.x,
                    y: e.pageY - drag.y
                };
                if (drag.target) {
                    parentOffset = $container.offset();
                    //or $(this).offset(); if you really just want the current element's offset
                    pos = {
                        x: e.pageX - parentOffset.left,
                        y: e.pageY - parentOffset.top
                    };
                    var rect = drag.target.rect;
                    if (!drag.target.parent) {
                        dropHint = "bottom";
                    }
                    else
                        if (pos.y > rect.y + rect.height / 2) {
                            dropHint = "bottom";
                        }
                        else
                            if (pos.x < rect.x + rect.width / 2) {
                                dropHint = "left";
                            }
                            else {
                                dropHint = "right";
                            }
                    if (dropHint !== drag.dropHint) {
                        drag.dropHint = dropHint;
                        showDropMarker(drag.target, dropHint);
                    }
                }
                drag.node.junction && drag.node.junction.hide();
                traverse(drag.node, function(node){
                    node.junction && node.drag.junction && node.junction.translate(node.drag.junction.x + delta.x, node.drag.junction.y + delta.y);
                    node.slot.translate(node.drag.slot.x + delta.x, node.drag.slot.y + delta.y);
                });
            }
            else
                if (self.chart.hoverNode) {
                    showTooltip(e);
                }
        }

        function showTooltip(e){
            var hoverNode = self.chart.hoverNode, parentOffset = $container.offset(), pos = {
                x: e.pageX - parentOffset.left + 20,
                y: e.pageY - parentOffset.top
            };
            self.chart.hoverNode.tooltipDesc &&
            tooltip.attr({
                text: self.chart.hoverNode.tooltipDesc
            }).translate(pos.x, pos.y).show();
        }

        function restorePosition(tree){
            traverse(tree, function(node){
                if (node.drag) {
                    if (node.drag.slot) {
                        node.slot.translate(node.drag.slot.x, node.drag.slot.y);
                    }
                    if (node.drag.junction) {
                        node.junction.translate(node.drag.junction.x || 0.001, node.drag.junction.y || 0.001);
                    }
                }
            });
        }

        function drop(e){
            var dropHint;
            if (drag && drag.node) {
                e._debug = debug;
                if (drag && drag.target) {
                    dropHint = drag.dropHint;
                }
                if (dropHint) {
                    reparent(drag.node, drag.target, dropHint);
                }
                else {
                    restorePosition(drag.node);
                }

                if (drag) {
                    hideDropMarker();
                    dragSnapshotClear(drag.node);
                    drag.node.junction && drag.node.junction.show();
                    drag = undefined;
                }
            }
        }

        function reparent(node, target, dropHint){
            var rank = _reparenter[dropHint](node, target);
            if (rank === null) {
                restorePosition(node);
                return;
            }
            traverse(root, function(node){
                node.rect = undefined;
                node.slot.renderer && node.slot.destroy();
                node.junction && node.junction.destroy();
            });
            drawTree();
            onReparent(node, target, rank);
        }

        function drawTree(){
            // traverse(root, function(node) {
            // 	for (var p = node.parent, indent = ""; p; indent += "  ", p = p.parent);
            // 	console.log(indent + node.desc + "@" + node.id);
            // });
            positionNode(root, CHART_SPACING_LEFT, CHART_SPACING_TOP);
            drawNode(root);
            self.size = {
                width: (self.xMax + CHART_SPACING_LEFT) * self.scaleX,
                height: (self.yMax + CHART_SPACING_TOP) * self.scaleY
            };
            // width minus 1 because of scrollbar issue on firefox
            self.chart.setSize(Math.max(self.item.context.div.clientWidth, self.size.width) - 1, self.size.height);
            self.chart.redraw();
        }

        function onClick(node, event){
            initDrag = {
                x: 0,
                y: 0
            };
            var picker = self.item.getElement(null, node.i);
            _chartMenu.openMenu(self.item, node.i, picker && picker.lastChild);
        }

        function onDoubleClick(node){
            // X3 table are 1 base
            // Notify only if on a leaf
            if (($decorator.$allowDoubleClick !== false) && node.children.length === 0) {
                _ext.classic.onBlockExRpc(self.item.context, interactDesc, ["E", node.i + 1, 0, 0, "", -1]);
            }
        }

        function onReparent(node, parent, rank){
            _ext.classic.onBlockExRpc(self.item.context, interactDesc, ["M", node.i + 1, parent.i + 1, rank, "", -1]);
        }

        // self.chart.redraw(); // kill animation (why was this again?)
        if ($decorator.$allowMove !== false) {
            Highcharts.addEvent(container, START, initStartDrag);
            Highcharts.addEvent(container, MOVE, move);
            Highcharts.addEvent(document, END, drop);
            Highcharts.addEvent(container, 'mouseleave', drop);
        }

        drawTree();
    },

    redraw: function(){
    },

    _nodeSlot: function(str, x, y, img){
        return this._nodeElement(str, x, y, img, null, null).attr({
            // r: 5,
            // y: 30,
            // height: 60,
            fill: _orgOptions.node.backgroundColor,
            'stroke-width': _orgOptions.node.borderWidth,
            stroke: _orgOptions.node.borderColor
        }).css({
            color: _orgOptions.node.textColor,
            fontSize: '10px',
            fontWeight: _orgOptions.node.fontWeight,
            'text-align': 'center'
        });
    },

    _nodeElement: function(str, x, y, img){
        var renderer = this.chart.renderer, wrapper = renderer.g("node"), // text = renderer.text('', 0, 0, true).attr({
 text = renderer.text('', 0, 0, this.useHtml).attr({
            zIndex: 1
        }), image, imgBox, box, bBox = {}, alignFactor = 0, padding = 2, paddingLeft = 0, width, height, wrapperX, wrapperY, crispAdjust = 0, deferredAttr = {}, baselineOffset, attrSetters = wrapper.attrSetters, needsBox;

        /**
         * This function runs after this element is added to the DOM (when the bounding box is
         * available), and after the text of the label is updated to detect the new bounding
         * box and reflect it in the border box.
         */
        function updateBoxSize(){
            var boxX, boxY, style = text.element.style, textBBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && text.getBBox();

            bBox.width = (width || textBBox.width);
            bBox.height = (height || textBBox.height);

            if (img) {
                imgBox = {
                    x: padding,
                    y: padding,
                    width: Math.max(bBox.width, 32),
                    height: 32
                };
                bBox.width = imgBox.width;
                bBox.height += imgBox.height + padding;
            }
            wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
            wrapper.height = (height || bBox.height || 0) + 2 * padding;

            // update the label-scoped y offset
            baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;

            if (needsBox) {
                // create the border box if it is not already present
                if (!box) {
                    // boxX = Math.round(-alignFactor * padding);
                    boxX = 0;
                    // boxY = baseline ? -baselineOffset : 0;
                    boxY = 0;

                    wrapper.box = box = renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
                    // box.attr('fill', NONE).add(wrapper);
                    box.add(wrapper);
                }

                // apply the box attributes
                box.attr(Highcharts.extend({
                    width: Math.round(wrapper.width),
                    height: Math.round(wrapper.height)
                }, deferredAttr));
                deferredAttr = null;
            }
            if (img && !image && (img !== IMAGE_PLACEHOLER)) {
                image = renderer.image(img, imgBox.x, imgBox.y, bBox.width, imgBox.height).attr({
                    preserveAspectRatio: 'xMidYMid'
                }).add(wrapper);
            }
        }

        /**
         * This function runs after setting text or padding, but only if padding is changed
         */
        function updateTextPadding(){
            var styles = wrapper.styles, textAlign = styles && styles.textAlign, x = paddingLeft + padding * (1 - alignFactor), y;

            // determin y based on the baseline
            // y = baseline ? 0 : baselineOffset;
            y = baselineOffset;

            // compensate for alignment
            if (defined(width) && (textAlign === 'center' || textAlign === 'right')) {
                x += {
                    center: 0.5,
                    right: 1
                }[textAlign] *
                (width - bBox.width);
            }

            if (img) {
                // x += padding;
                y += padding + imgBox.height;
            }

            // update if anything changed
            if (x !== text.x || y !== text.y) {
                text.attr({
                    x: x,
                    y: y
                });
            }

            // record current values
            text.x = x;
            text.y = y;
        }

        /**
         * Set a box attribute, or defer it if the box is not yet created
         * @param {Object} key
         * @param {Object} value
         */
        function boxAttr(key, value){
            if (box) {
                box.attr(key, value);
            }
            else {
                deferredAttr[key] = value;
            }
        }

        function getSizeAfterAdd(){
            text.add(wrapper);
            wrapper.attr({
                text: str,
                // alignment is available now
                x: x,
                y: y
            });

            // if (box && defined(anchorX)) {
            //     wrapper.attr({j
            //         anchorX: anchorX,
            //         anchorY: anchorY
            //     });
            // }
        }

        /**
         * After the text element is added, get the desired size of the border box
         * and add it before the text in the DOM.
         */
        //Highcharts.addEvent(wrapper, 'add', getSizeAfterAdd);
        wrapper.onAdd = getSizeAfterAdd;
        /*
         * Add specific attribute setters.
         */
        // only change local variables
        wrapper.widthSetter = function(value){
            // attrSetters.width = function(value) {
            width = value;
            return false;
        };
        wrapper.heightSetter = function(value){
            height = value;
            return false;
        };
        wrapper.paddingSetter = function(value){
            if (defined(value) && value !== padding) {
                padding = value;
                updateTextPadding();
            }
            return false;
        };
        wrapper.paddingLeftSetter = function(value){
            if (defined(value) && value !== paddingLeft) {
                paddingLeft = value;
                updateTextPadding();
            }
            return false;
        };

        // change local variable and set attribue as well
        wrapper.alignSetter = function(value){
            alignFactor = {
                left: 0,
                center: 0.5,
                right: 1
            }[value];
            return false; // prevent setting text-anchor on the group
        };

        // apply these to the box and the text alike
        wrapper.textSetter = function(value, key){
            if (value !== undefined) {
                text.textSetter(value);
            }
            // text.attr(key, value);
            updateBoxSize();
            updateTextPadding();
            return false;
        };

        // apply these to the box but not to the text
        wrapper[STROKE_WIDTH + "Setter"] = function(value, key){
            needsBox = true;
            crispAdjust = value % 2 / 2;
            boxAttr(key, value);
            return false;
        };
        wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function(value, key){
            if (key === 'fill') {
                needsBox = true;
            }
            boxAttr(key, value);
            return false;
        };
        // attrSetter.anchorX = function(value, key) {
        //     anchorX = value;
        //     boxAttr(key, value + crispAdjust - wrapperX);
        //     return false;
        // };
        // attrSetter.anchorY = function(value, key) {
        //     anchorY = value;
        //     boxAttr(key, value - wrapperY);
        //     return false;
        // };
        // rename attributes
        wrapper.xSetter = function(value){
            wrapper.x = value; // for animation getter
            value -= alignFactor * ((width || bBox.width) + padding);
            wrapperX = Math.round(value);

            wrapper.attr('translateX', wrapperX);
            return false;
        };
        wrapper.ySetter = function(value){
            wrapperY = wrapper.y = Math.round(value);
            wrapper.attr('translateY', wrapperY);
            return false;
        };

        // Redirect certain methods to either the box or the text
        var baseCss = wrapper.css;
        return Highcharts.extend(wrapper, {
            /**
             * Pick up some properties and apply them to the text instead of the wrapper
             */
            css: function(styles){
                if (styles) {
                    var textStyles = {};
                    styles = Highcharts.merge(styles); // create a copy to avoid altering the original object (#537)
                    Highcharts.each(['fontSize', 'fontWeight', 'fontFamily', 'color', 'lineHeight', 'width'], function(prop){
                        if (styles[prop] !== UNDEFINED) {
                            textStyles[prop] = styles[prop];
                            delete styles[prop];
                        }
                    });
                    text.css(textStyles);
                }
                return baseCss.call(wrapper, styles);
            },

            /**
             * Return the bounding box of the box, not the group
             */
            getBBox: function(){
                return {
                    width: bBox.width + 2 * padding,
                    height: bBox.height + 2 * padding,
                    x: bBox.x - padding,
                    y: bBox.y - padding
                };
            },

            /**
             * Apply the shadow to the box
             */
            shadow: function(b){
                if (box) {
                    box.shadow(b);
                }
                return wrapper;
            },

            /**
             * Destroy and release memory.
             */
            destroy: function(){
                //Highcharts.removeEvent(wrapper, 'add', getSizeAfterAdd);
                wrapper.onAdd = null;
                // Added by button implementation
                Highcharts.removeEvent(wrapper.element, 'mouseenter');
                Highcharts.removeEvent(wrapper.element, 'mouseleave');

                if (text) {
                    text = text.destroy();
                }
                if (box) {
                    box = box.destroy();
                }
                // Call base implementation to destroy the rest
                Highcharts.SVGElement.prototype.destroy.call(wrapper);

                // Release local pointers (#1298)
                wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = getSizeAfterAdd = null;
            }
        });
    }
};

var OrgChart = function(context){
    this.context = context;
    context.prototype.$properties = context.prototype.$item && context.prototype.$item.$properties;
};


OrgChart.prototype._createChart = function(){
    var self = this;
    if (self._isDelta()) {
        _clearNode(self.head);
        self.head = {
            children: []
        };
        if (self.dataset && self.dataset.length > 0) {
            self._buildTree();
        }
        var root = ((self.head || {}).children || [])[0];
        if (root) {
            delete self.orgWidget;
            // add scrolls
            self.context.div.style.overflow = "auto";
            self._chart = new Highcharts.Chart({
                chart: {
                    renderTo: self.context.div,
                    events: {
                        load: function(){
                            self.orgWidget = new OrgChartWidget(self, this);
                            self.orgWidget.draw(root);
                        },
                        redraw: function(){
                            self.orgWidget.redraw();
                        },
                        click: function(event){
                            _ext.popup.closeAll();
                        },
						afterPrint: function(event){
                           syra_site && syra_site.resizeItem();
                        }
                    },
                    spacingTop: 15,
                    marginTop: 0
                },
                title: {
                    text: ''
                },
                navigation: {
                    buttonOptions: {
                        align: "left"
                    }
                },
                exporting: {
                    type: 'image/png',
                    // url: 'http://export.highcharts.com/',
                    buttons: {
                        contextButton: {
                            symbol: 'menu',
                            _titleKey: 'contextButtonTitle',
                            menuItems: [{
                                text: 'Print chart',
                                onclick: function(){
                                    this.print(self.context.field);
                                }
                            }]
                        }
                    }
                }
            });
        }
    }
};

OrgChart.prototype._isDelta = function(){
    if (this.dataset && this.dataset.length) {
        var a = 1, b = 0, text = JSON.stringify(this.dataset).replace(/"\$uuid":"?[-A-Z0-9]*[-A-Z0-9]"?,/ig, "");
        for (var index = 0, jj = text.length; index < jj; ++index) {
            a = (a + text.charCodeAt(index)) % 65521;
            b = (b + a) % 65521;
        }
        var cn = (b << 16) | a;
        if (this.checkNum != cn) {
            this.checkNum = cn;
            return true;
        }
    }
    return false;
};

OrgChart.prototype._buildTree = function(){
    var self = this;
    var imageBaseUrl = null;
    var $bindings = self.context.prototype.$decorator.$bindings;
    var binds = Object.keys($bindings).map(function(k){
        return $bindings[k];
    });
    if (_ext.classic.getController(self.context)) {
        var uri = self.context.field.page.urlSeg.uri;
        imageBaseUrl = uri && uri.replace(/\$sessions/, '$files') + "/RES/";
    }
    else {
        // imageBaseUrl = "/syracuse-ui/themes/desktop/highcharts/";
    }

    // the root node
    var parent, node, parentId, idx, parentMap = {};
    // First create a map with potential valid parent
    parentMap[""] = self.head;
    self.dataset.forEach(function(e, i, a){
        var id = e[$bindings.$parent];
        if (id && !parentMap[id]) {
            parentMap[id] = {
                children: [],
                id: id
            };
        }
    });
    self.dataset.forEach(function(e, i, a){
        // WARNING: id can be a duplicate key
        var id = e[$bindings.$id || $bindings.$clientId];

        if (id) {
            var data = $bindings.$data &&
            $bindings.$data.map(function($bind){
                return e[$bind];
            }) ||
            [];

            parentId = e[$bindings.$parent];
            parent = parentMap[parentId];

            node = parentMap[id] || {};
            node.children = node.children || [];
            node.id = node.id || id;
            node.i = node.i || i;
            node.parentId = parentId;
            if (!node.parent) {
                node.parent = parent;
                node.desc = ($bindings.$title ? e[$bindings.$title] : "") + ((data.length && $bindings.$title) ? "<br/>" : "") + data.join(" ");
                node.tooltipDesc = e[$bindings.$description];
                // '<span style="font-size: 9pt; font-style:italic;">' + e[$bindings.$description] + '</span>';
                var image = e[$bindings.$image];
                node.image = image && imageBaseUrl && (imageBaseUrl + image);
                node.values = [];
                Object.keys(e).forEach(function(k){
                    if (k.charAt(0) != "$" && binds.indexOf(k) == -1) {
                        node.values.push(e[k]);
                    }
                });
            }
            parent.children.push(node);
        }
    });
    var root = ((self.head || {}).children || [])[0];
    root && root.parent && delete root.parent;
    root && self._normalizeNode(root, 0); // in some case root is null ??? must be investigated to know why
};

OrgChart.prototype._normalizeNode = function(node, i){
    var children = node.children || [], parent = node.parent, n;
    if (node.seen) {
        n = {
            children: [],
            id: node.id,
            i: node.i,
            desc: node.desc,
            tooltipDesc: node.tooltipDesc,
            image: node.image,
            values: node.values
        };
        if (parent) {
            parent = parent.seen && parent.seen.n || parent;
            parent.children[i] = n;
            n.parent = parent;
        }
        node.seen.n = n;
    }
    else {
        node.seen = {};
    }
    if (children) {
        for (var ii = 0, jj = children.length; ii < jj; ii++) {
            this._normalizeNode(children[ii], ii);
        }
    }
    delete node.seen.n;
};

function _resize(widget){
    // width minus 1 because of scrollbar issue on firefox
    var size = {
        width: Math.max(widget.orgWidget.size.width, widget.context.div.clientWidth) - 1,
        height: widget.orgWidget.size.height || widget.context.div.style.clientHeight || widget.context.div.clientHeight
    };
    widget._chart.setSize(size.width, size.height);
    widget._chart && widget._chart.redraw();
}

OrgChart.prototype.resize = function(){
    var self = this;
    if (self._chart && self._chart.container) {
        clearTimeout(self.resizeTimeout);
        if (!self._chart.isResizing) {
            self.resizeTimeout = setTimeout(function(){
                _resize(self);
            }, 100);
        }
        else {
            _resize(self);
        }
    }
};

OrgChart.prototype.getElement = function(from, index){
    from = from || this.head;
    if (from.i === index) {
        return from.slot.element;
    }
    for (var ii = 0, jj = from.children.length; ii < jj; ii++) {
        var found = this.getElement(from.children[ii], index);
        if (found)
            return found;
    }
    return false;
};

OrgChart.prototype.setValue = function(dataset){
    this.dataset = dataset;
    this.dataset && this._createChart();
};

OrgChart.prototype.dispose = function(){
    this._chart && this._chart.renderer.destroy();
};

exports.create = function(context){
    return new OrgChart(context);
};
