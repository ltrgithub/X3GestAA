"use strict";
var _ext = require('@sage/syracuse-ui/lib/extend/extendGateway');
var _chartMenu = require("./menu/chartMenu");
var _locale = require('streamline-locale');

require('./deps/highcharts/highcharts.src');
require('./deps/highcharts/highcharts-more.src');
require('./deps/highcharts/draggable-legend');
require('./deps/highcharts/modules/exporting.src');
Highcharts.theme = require('./highchartTheme').theme;
Highcharts.setOptions(Highcharts.theme);

var _style = (function() {
	var map = {
		xy: "line",
		point: "scatter",
		stick: "column",
		radar: "spiderweb"
	};

	return function($style) {
		return $style && (map[$style] || $style);
	};
})();

function delayed(obj, name, cb, delay) {
	var tm = "timer_" + name;
	if (obj[tm])
		clearTimeout(obj[tm]);
	obj[tm] = setTimeout(cb, delay || 100);
}

function mergeChanges(update, chartSerie, serie) {
	["name", "type", "color", "visible"].map(function(key) {
		if (chartSerie[key] !== serie[key]) {
			update[key] = serie[key];
		}
	});
}

function _mergeMetaData(widget, metadata) {
	var m = {};
	if (metadata) {
		if (metadata.$cube)
			m.$cube = metadata.$cube;
		if (metadata.$axes)
			m.$axes = metadata.$axes;
		if (metadata.$style)
			m.$style = metadata.$style;
		if (metadata.$color)
			m.$color = metadata.$color;
	}
	widget.currentMetaData = Highcharts.merge(widget.currentMetaData || {}, m);
	var $cube = widget.currentMetaData && widget.currentMetaData.$cube;
	var $measures = $cube && $cube.$measures;
	if ($measures) {
		var $properties = metadata && metadata.$item && metadata.$item.$properties;
		if ($properties) {
			var keys = Object.keys($measures);
			for (var ii = 0, jj = keys.length; ii < jj; ii++) {
				var key = keys[ii];
				var $measure = $measures[key];
				if ($measure && $properties[key] && $properties[key].$title) {
					$measure.$title = $properties[key].$title;
				}
			}
		}
	}
	return widget.currentMetaData;
}

function _processMeasures(widget, metaData, init) {
	_mergeMetaData(widget, metaData);
	var $properties = widget.context.prototype.$properties;

	// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
	// we used all the measures defined in the cube
	var proto = widget.currentMetaData;
	var $cube = proto.$cube
	var $measures = $cube && $cube.$measures
	var measures = $measures;
	if ($measures) {
		if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
			measures = {};
			var codes = proto.$axes[1].$members[0][0];
			for (var ii = 0, jj = codes.length; ii < jj; ii++) {
				var measureCode = codes[ii];
				measures[measureCode] = $measures[measureCode];
			}
		}
	}

	if (measures) {
		var icolor = 0;
		var keys = Object.keys(measures);
		for (var ii = 0, jj = keys.length; ii < jj; ii++) {
			var key = keys[ii];
			var $measure = measures[key];
			// Because duplicate properties is possible for cube definition... we keep the last defined
			var code = ($measure.$property || key);
			var measure = Highcharts.merge($properties[code], $measure);
			if (metaData && metaData.$item && metaData.$item.$properties) {
				measure = Highcharts.merge(measure, metaData.$item.$properties[code]);
			}
			// measures[key] = measure;
			var serie = widget._meta.series[code];

			if (init) {
				_ensureFormatter(measure);
				serie = widget._meta.series[code] = {
					options: {
						id: '#s-' + code,
						// legendIndex: "",
						name: _ext.localizeText(widget.context, measure.$title) || String.fromCharCode(160),
						// visible: measure.$title !== "" && !!(!widget._meta.displaysOneMeasure || measure.$isDefault)
					},
					measure: measure
				};
			}
			if (serie) {
				// X3 does not set $style on serie, only client/authoring does
				// So if there is nothing on serie level, we use the global style set by X3
				var serieStyle = measure.$style || $cube.$style;
				serie.isHidden = measure.$title === "";
				serie.options.type = _style(serieStyle);
				serie.options.color = measure.$color || Highcharts.theme.colors[icolor++];
				serie.options.name = _ext.localizeText(widget.context, measure.$title) || String.fromCharCode(160);
				serie.options.visible = measure.$title !== "" && !!(!widget._meta.displaysOneMeasure || measure.$isDefault);
			}
			if (measure.$isStacked || measure.$stackingGroup) {
				serie.options.stack = measure.$stackingGroup || 0; // a stack ID
				widget._meta.stacking = measure.$isNormalized ? 'percent' : widget._meta.stacking || 'normal';
			}
		}
	}
}

function _isCubeValid(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
		proto.$axes[0].$hierarchies &&
		proto.$axes[0].$hierarchies.length > 0);
}

function _processAxes(widget, proto, init) {
	var cube = widget.context.prototype.$cube;
	if (_isCubeValid(cube, proto)) {
		var currAxisHier = 0,
			axis0 = proto.$axes && proto.$axes[0];
		// TODO: review this
		// Get axis analysis
		var mainHLevelsTab = null;
		if (axis0) {
			var keys = Object.keys(axis0.$hierarchies);
			for (var ii = 0, jj = keys.length; ii < jj; ii++) {
				var key = keys[ii];
				var hierarchy = axis0.$hierarchies[key];
				if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
					mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
					if (mainHLevelsTab) {
						widget._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
						currAxisHier = key;
					}
				}
			}
			if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
				mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
				if (mainHLevelsTab && mainHLevelsTab.length > 0)
					widget._meta.xAxis[0].code = mainHLevelsTab[0];
			}
			// Get drill definition
			var properties;
			for (var ii = 0, jj = axis0.$hierarchies.length; ii < jj; ii++) {
				var hierarchie = axis0.$hierarchies[ii];
				properties = cube.$hierarchies[hierarchie[0]].$properties;
				_.each(properties, function(property) {
					this.levelsProperties[this.maxLevel++] = property;
				}, widget._meta.drill);
			}

			if (axis0.$members) {
				_.each(axis0.$members, function(tuple) {
					_.each(tuple, function(value) {
						if (value.length > 0) {
							this.members[(this.currLevel++) - 1] = value[0];
						}
					}, this);
				}, widget._meta.drill);
			}
		}
		widget._meta.drill.code = proto.$codeStat || "UNKNOWN";
		widget._meta.drill.axis0FieldCode = widget._meta.xAxis[0].code || "";
		widget._meta.drill.maxLevel = Math.max(widget._meta.drill.maxLevel, widget._meta.drill.minLevel);
	}
}

function _ensureFormatter(measure) {
	measure.formatApi = measure.formatApi || _ext.culture.api[measure.$type];
	measure.formatObj = measure.formatObj || _ext.culture.format.getNumberFormatObj(measure.$type);
	measure.localeFormat = measure.localeFormat || measure.$format || measure.formatObj.numFormat;
}

function _applyLinks(widget, prop, col) {
	var obj = col && prop && prop[col];
	if (obj) {
		var keys = Object.keys(obj);
		for (var ii = 0, jj = keys.length; ii < jj; ii++) {
			var key = keys[ii];
			var link = obj[key];
			var lnk = widget._meta.links[key];
			if (lnk) {
				var props = Object.keys(link);
				for (var mm = 0, kk = props.length; mm < kk; mm++) {
					lnk[props[mm]] = link[props[mm]];
				}
			} else {
				widget._meta.links[key] = {
					"type": col,
					"id": key,
					"link": link,
					"title": _ext.localizeText(widget.context, link.$title)
				};
			}
		}
	}
}

function _pushData(widget, serie, categoryName, key, data) {
	var val = parseFloat(data.$rawV && data.$rawV[key] && data.$rawV[key].v || data[key]) || 0;
	if (widget.useLogarithmicAxis) {
		widget.maxValue = Math.max(widget.maxValue || -Infinity, val);
		widget.minValue = Math.min(widget.maxValue || Infinity, val);
	}
	serie.data.push([categoryName, val]);
}

function _settingsFromValue(widget) {
	var $cube = widget.currentMetaData.$cube,
		icolor = 0,
		settings;
	var dataset = widget.dataset;
	settings = {
		categories: [],
		series: {}
	};
	if ($cube.$style === "spiderweb") {
		settings.categories = Object.keys(widget._meta.series).map(function(key) {
			return widget._meta.series[key].options.name;
		});
		dataset &&
			dataset.reduce(function(res, current) {
				var serie = {
					name: _getMeasureLabel(widget, current, widget._meta.xAxis[0].code),
					color: Highcharts.theme.colors[icolor++],
					data: [],
					pointPlacement: 'on'
				};
				if (serie.name) {
					serie.id = "#s-" + serie.name;
					var keys = Object.keys(widget._meta.series);
					for (var ii = 0, jj = keys.length; ii < jj; ii++) {
						var key = keys[ii];
						if (!widget._meta.series[key].isHidden)
							_pushData(widget, serie, key, key, current);
					}
					res.series[serie.name] = serie;
				}
				return res;
			}, settings);
	} else {
		dataset &&
			dataset.reduce(function(res, current) {
				var $bindSelector = widget.currentMetaData.$cube.$displaySelector;
				var displaySelectoValue = $bindSelector ? (current[$bindSelector] == "0" || current[$bindSelector] == "") : true;
				var categoryName = _getMeasureLabel(widget, current, widget._meta.xAxis[0].code);
				if (categoryName != null) {
					if (displaySelectoValue) {
						res.categories.push(categoryName);
					}
					var keys = Object.keys(widget._meta.series);
					for (var ii = 0, jj = keys.length; ii < jj; ii++) {
						var key = keys[ii];
						var meta = widget._meta.series[key];
						var serie = res.series[key];
						if (!serie) {
							serie = _ext.data.clone(meta.options);
							serie.data = [];
							res.series[key] = serie;
						}
						if (displaySelectoValue) {
							_pushData(widget, serie, categoryName, key, current);
						}
					}
				}
				return res;
			}, settings);
	}
	return settings;
}

function _canDrill(meta, up) {
	var i = meta.drill.currAxisHier,
		stack = meta.drill.stack,
		proto = stack[0],
		axis0 = proto.$axes && proto.$axes[0],
		hierarchies = axis0.$hierarchies || [];
	return up && (meta.drillUpLink || stack.length > 1) || !up && (meta.drillDownLink || (axis0 && i < hierarchies.length - 1));
}

function _drill(widget, serie, up) {
	var cube = widget.context.prototype.$cube;
	var meta = widget._meta,
		i = meta.drill.currAxisHier,
		stack = meta.drill.stack;

	if (up && meta.drillUpLink) {
		return _chartMenu.execLink(widget.context,widget.context.field.attachedField, meta.drillUpLink);
	} else
	if (!up && meta.drillDownLink) {
		return _chartMenu.execLink(widget.context,widget.context.field.attachedField, meta.drillDownLink, serie.x);
	}

	if (up) {
		// already on top ?
		if (stack.length < 2)
			return;
		stack.shift();
		meta.drill.currAxisHier--;
		_showDrillUp(widget, meta.drill.currAxisHier > 0);

		var proto = stack[0]
		_ext.data.fetch(widget.context, {
			jsonParams: {
				$axes: proto.$axes,
				$slicer: proto.$slicer
			}
		});
		return;
	}

	var proto = stack[0],
		axis0 = proto.$axes && proto.$axes[0];

	// no axis or reach the end of drilling
	if (!_canDrill(widget._meta, up)) {
		return;
	}

	var members = axis0.$members = (axis0.$members || []);

	stack.unshift(_ext.data.clone(proto, true));
	proto = stack[0];

	axis0 = proto.$axes && proto.$axes[0];
	members = axis0.$members;
	var hierarchies = axis0.$hierarchies;

	var hierName = hierarchies[i][0],
		cubeHier = cube.$hierarchies[hierName];
	if (hierarchies[i][2] == (cubeHier.$properties ? cubeHier.$properties.length - 1 : -1)) {
		hierarchies[i].splice(1, 2, 0, 0);
		hierarchies[i + 1].splice(1, 2, 1, 0);
		meta.drill.currAxisHier++;
	} else {
		hierarchies[i][2]++;
	}
	if (members.length < i + 1) {
		members[i] = [];
	}
	var rawData = widget.dataset && widget.dataset[serie.x],
		member = rawData && (rawData[hierName] + "");

	// use the raw data from the dataset instead of serie.name because article one can be formatted
	members[i].push([member]);
	_showDrillUp(widget, meta.drill.currAxisHier > 0);
	_ext.data.fetch(widget.context, {
		jsonParams: {
			$axes: proto.$axes,
			$slicer: proto.$slicer
		}
	});
}

function _showDrillUp(widget, show) {
	//     if (show) {
	//         widget._drillUpGroup.show();
	//     } else {
	//         widget._drillUpGroup.hide();
	//     }
	// TODO: Does not work. Find an alternative
	// -----------------------------------------
	// var drillElt = widget._chart.exportSVGElements && widget._chart.exportSVGElements.filter(function(e) {
	//     return e.id === "drillUp";
	// });
	// if (!(drillElt[0] && drillElt[0].element)) return;
	// if (show) {
	//     drillElt[0].element.removeAttribute("display");
	// } else {
	//     drillElt[0].element.setAttribute("display", "none");
	// }
}

function _highlight(widget) {
	$(widget._chart.series).each(function(i, serie) {
		if (serie.legendItem) {
			serie.legendItem.element.onmouseover = function() {
				highlight(widget._chart.series, serie.index, true);
			};
			serie.legendItem.element.onmouseout = function() {
				highlight(widget._chart.series, serie.index, false);
			};
		}
	});

	function highlight(series, index, hil) {
		var s = (widget._chart.options.chart.type === "area") ? series[index].area.element.style : null;
		if (hil) {
			series[index].group.toFront();
			if (s) {
				s.fillOpacity = "0.6";
			}
		} else {
			if (s) {
				s.fillOpacity = "";
			}
		}
	}
}

function _displayLegend(widget, display) {
	var legend = widget._chart.legend;
	if (legend && legend.options && legend.options.enabled) {
		if (display) {
			legend.group.show();
			legend.box.show();
			_highlight(widget);
		} else {
			legend.group.hide();
			legend.box.hide();
		}
		widget.displayLegend = legend.display = display;
	}
}

function _setType(widget, serie, type, size, innerSize) {
	var chart = serie.chart;
	var s = {
		id: serie.options.id,
		type: type,
		name: serie.name,
		data: serie.options.data,
		visible: serie.visible,
		stack: serie.stack,
		color: serie.color
	};
	var opt = {
		type: type
	};

	if (type === "spiderweb") {
		// chart.polar = true;
		// chart.type = 'area';
		// delete options.xAxis[0].title;
		// options.xAxis[0] = Highcharts.merge(options.xAxis[0], {
		//     tickmarkPlacement: 'on',
		//     lineWidth: 0
		// });
		// delete options.xAxis[0].labels;
		// delete options.yAxis;
		// options.yAxis = {
		//     gridLineInterpolation: 'polygon',
		//     lineWidth: 0,
		//     // min: 0
		// };
	} else
	if (type === "pie") {
		opt = s;
		opt.size = size + "%";
		opt.innerSize = innerSize + "%";
		opt.showInLegend = false;
		opt.dateLabels = {
			enabled: false
		};
		widget._meta.cache = widget._meta.cache || {};
		widget._meta.cache.xAxis = chart.xAxis;
		delete chart.xAxis;
	} else
	if (!chart.xAxis) {
		s.showInLegend = true;
		s.dateLabels = {
			enabled: true
		};
		chart.xAxis = widget._meta.cache.xAxis;
	}
	serie.remove();
	chart.addSeries(s, false);
	// serie.update(opt);
}


function _getMeasureLabel(widget, measure, code) {
	var context = widget.context;
	var label = _ext.localizeText(context, measure.$title);
	if (!label) {
		var widget = context.prototype.$properties[code];
		if (!widget)
			return null;
		switch (widget.$type) {
			case "application/x-choice":
				label = measure[code];
				widget.$value.$enum.some(function(element, i, array) {
					if (element.$value === label) {
						label = _ext.localizeText(context, element.$title);
						return true;
					}
					return false;
				});
				break;
			case "application/x-date":
				widget.formatApi = widget.formatApi || _ext.culture.api[widget.$type];
				widget.localeFormat = widget.localeFormat || _ext.culture.format.getDate(widget.$format);
				label = _ext.culture.datetime.parse(measure[code]).toString(widget.localeFormat);
				break;
			case "application/x-integer":
			case "application/x-decimal":
				widget.formatApi = widget.formatApi || _ext.culture.api[widget.$type];
				widget.formatObj = widget.formatObj || _ext.culture.format.getNumberFormatObj(widget.$type);
				widget.localeFormat = widget.localeFormat || widget.$format || widget.formatObj.numFormat;
				label = widget.formatApi.format(measure[code], widget.localeFormat);
				break;
			default:
				label = "" + measure[code];
				break;
		}
	}
	return label;
}

function _selectChartMeasure(widget) {
	var slot = widget.context.div;
	var comboDiv = slot.getElementsByClassName("s-high-chart-combo")[0];
	slot.style.position = "relative";

	var rect = slot.getBoundingClientRect();
	var graphElement = slot.getElementsByClassName("highcharts-grid");
	var graphRect = graphElement.length ? graphElement[0].getBoundingClientRect() : rect;

	if (comboDiv) {
		comboDiv.style.left = (graphRect.left - rect.left) + 10 + "px";
		return;
	}

	comboDiv = document.createElement("div");
	comboDiv.className = "s-high-chart-combo";
	comboDiv.style.left = (graphRect.left - rect.left) + 10 + "px";
	slot.appendChild(comboDiv);

	var $enums = [];
	for (var ii = 0, jj = widget._chart.series.length; ii < jj; ii++) {
		var serie = widget._chart.series[ii];
		$enums.push({
			$value: ii,
			$title: serie.name
		});
		serie.setVisible(ii === 0, true);
	}

	widget.choice = _ext.item.add(widget.context, comboDiv, {
		$title: widget.locale.highCharts_select_measure,
		$bind: "$seriesChoice",
		$category: "field",
		$isEditMode: true,
		$inplace: false,
		$format: "$combo",
		$field: {
			$type: "application/x-choice",
			$maxLength: 15,
			$value: {
				$type: "application/x-string",
				$enum: $enums
			}
		}
	});

	widget.choice.onFieldInputEvent = function(event) {
		if (event.type == "change") {
			var newValue = this.getValue(event);
			if (newValue != this.currentValue) {
				for (var ii = 0, jj = widget._chart.series.length; ii < jj; ii++) {
					widget._chart.series[ii].setVisible(ii === newValue, true);
				}
				widget.resize();
				this.currentValue = newValue;
				saveWidgetChoice(widget, newValue);
			}
		}
	};

	widget.choice.chart = widget._chart;
	widget.choice.setValue(getWidgetChoice(widget));
	widget.choice.setDatasetValue = function(selectedIndex) {
		for (var ii = 0, jj = widget._chart.series.length; ii < jj; ii++) {
			widget._chart.series[ii].setVisible(ii == selectedIndex, true);
		}
	};
	widget.choice.setDatasetValue(getWidgetChoice(widget));
}

function getWidgetChoice(widget) {
	return !sessionStorage.getItem("uichart-highchart_" + widget.context.field.page.urlSeg.uri) ?
		0 : parseInt(sessionStorage.getItem("uichart-highchart_" + widget.context.field.page.urlSeg.uri));
};

function saveWidgetChoice(widget, val) {
	sessionStorage.setItem("uichart-highchart_" + widget.context.field.page.urlSeg.uri, val);
};

function _onMeasureClick(widget, options) {
	var event = options.event || {},
		data = options.data || {};
	if (!widget.context.field.attachedField.$isDisabled) {
		if (widget.context.field.page.isFusionPage) {
			_chartMenu.openMenu(widget, data.x, event.target);
		} else {
			// no longer drill up if shiftKey is pressed
			if (!event.shiftKey)
				_drill(widget, data, event.shiftKey);
		}
	}
}

function _getOptions(widget, proto) {
	var $cube = widget.currentMetaData.$cube;
	var defOptions = Highcharts.getOptions();
	var buttons = defOptions.exporting.buttons;
	var measuresTitle = widget.context.field.page.externalAdapter.getFieldEvalTitle(widget) || [];
	var axe = proto.$axes && proto.$axes[0] || {};
	var axeTitle = axe.$hierarchies && measuresTitle[axe.$hierarchies[0][0]] || axe.$title,
		enuml;
	var options = {
		chart: {
			renderTo: widget.context.div,
			events: {
				afterPrint: function(event) {
					syra_site && syra_site.resizeItem();
				}
			},
			// marginLeft: 30,
			// marginRight: 150,
			// witdh: widget.context.div.clientWidth,
			// height: widget.context.div.style.clientHeight
			zoomType: 'x',
			ignoreHiddenSeries: false
		},
		lang: {
			showHideLegend: widget.locale.highCharts_showHideLegend,
			drillDown: widget.locale.highCharts_drillDown,
			drillUp: widget.locale.highCharts_drillUp,
			downloadPNG : widget.locale.highCharts_downloadPNG,
			downloadJPEG: widget.locale.highCharts_downloadJPEG,
			downloadPDF: widget.locale.highCharts_downloadPDF,
			downloadSVG: widget.locale.highCharts_downloadSVG
		},
		legend: {
			layout: 'vertical',
			verticalAlign: 'top',
			y: 60,
			x: -10,
			floating: true,
			draggable: true,
			zIndex: 20
		},
		title: ($cube && _ext.localizeText(widget.context, $cube.$title)) || '',

		xAxis: [{
			categories: [],
			title: {
				text: _ext.localizeText(widget.context, axeTitle)
			},
			labels: {
				rotation: -45,
				// style: {
				//     fontSize: '13px',
				//     fontFamily: 'Verdana, sans-serif'
				// }
			}
		}],

		yAxis: [{
			title: {
				text: ''
			},
			labels: {}
			// type: 'logarithmic',
		}],

		plotOptions: {
			series: {
				cursor: 'pointer',
				events: { // legendItemClick: function(e) {
					//     // use e.mousePageX and e.mousePageY for mouse coordinates
					//     console.log("legendItemClick: (" + e.mousePageX + ", " + e.mousePageY + ")");
					// }
				},
				point: {
					events: {
						click: function(event) {
							var s = this;
							setTimeout(function() {
								_onMeasureClick(widget, {
									data: s,
									event: event
								});
							}, 100);
						}
					}
				},
				stacking: widget._meta.stacking
			}
		},

		tooltip: {
			formatter: function() {
				var seriesMeta = widget._meta.series,
					serie = this.key && seriesMeta[this.key] || seriesMeta[this.series.options.id.slice(3)],
					measure = serie && serie.measure,
					data = this.series.processedYData,
					y = this.y;

				measure && _ensureFormatter(measure);

				var label = this.series.name || measure && measure.$title,
					mformat = measure && measure.formatApi,
					mlocale = measure && measure.localeFormat;
				label = (label ? label + "<br>" : "") + (this.x || this.key) + ': <b> ' + (mformat ? mformat.format(y, mlocale) : y) + '</b>';
				if (measure && (measure.$isNormalized) && data.length > 0) {
					var sum = data.reduce(function(a, b) {
						return a + b;
					});
					label += ' (' + (mformat ? mformat.format(y / sum * 100, mlocale) : y / sum * 100) + '%)';
				}

				if (_canDrill(widget._meta, false)) {
					label += '<br/><span style="font-size: 10px; font-style:italic;">' + widget.locale.highCharts_clickToDrill + '</span>';
				}
				return label;
			}
		},

		series: [],
	};
	if (Highcharts.theme.version[0] >= 3) {
		// For Highcarts 3.0.0
		options.exporting = {
			//enabled: true,
			//filename: 'chart',
			type: 'image/png',
			url: 'http://export.highcharts.com/',
			//width: undefined, // docs
			//scale: 2 // docs
			buttons: {
				contextButton: { // docs
					//x: -10, // docs: x is different now
					symbol: 'menu',
					_titleKey: 'contextButtonTitle',
					menuItems: [{
						textKey: 'showHideLegend',
						onclick: function() {
							setTimeout(function() {
								widget._chart && widget._chart.legend && _displayLegend(widget, !widget._chart.legend.display);
							}, 100);
						}
					}, {
						separator: true
					}, {
						textKey: 'drillUp',
						onclick: function() {
							setTimeout(function() {
								_drill(widget, null, true);
							}, 100);
						}
					}]
				}
			}
		};
		var menuItems = options.exporting.buttons.contextButton.menuItems;
		menuItems.push({
			separator: true
		});
		menuItems.push({
			text: widget.locale.highCharts_print,
			onclick: function() {
				this.print(widget.context.field);
			}
		});
		menuItems.push({
			separator: true
		});
		menuItems.push({
			textKey: 'downloadPNG',
			onclick: function() {
				this.exportChart();
			}
		});
		menuItems.push({
			textKey: 'downloadJPEG',
			onclick: function() {
				this.exportChart({
					type: 'image/jpeg'
				});
			}
		});
		menuItems.push({
			textKey: 'downloadPDF',
			onclick: function() {
				this.exportChart({
					type: 'application/pdf'
				});
			}
		});
		menuItems.push({
			textKey: 'downloadSVG',
			onclick: function() {
				this.exportChart({
					type: 'image/svg+xml'
				});
			}
		});

	}

	if (options.xAxis[0].title.text !== options.title) {
		options.xAxis[0].title.text = options.title + (options.xAxis[0].title.text ? ' / ' + options.xAxis[0].title.text : '');
	}

	if ($cube.$style === "spiderweb") {
		if ($cube.$mnu) {
			var $fusionController = _ext.classic.getController(widget.context);
			var fusionSess = $fusionController ? $fusionController.getSession() : null;
			enuml = fusionSess && $cube.$mnu ? fusionSess.getMenloc($cube.$mnu) : null;
		}
		options.chart.polar = true;
		options.chart.type = 'area';
		delete options.xAxis[0].title;
		options.xAxis[0] = Highcharts.merge(options.xAxis[0], {
			tickmarkPlacement: 'on',
			lineWidth: 0
		});
		delete options.xAxis[0].labels;
		delete options.yAxis;
		delete options.tooltip;
		options.yAxis = {
			gridLineInterpolation: 'polygon',
			lineWidth: 0,
			min: 0,
			labels: {
				x: 6,
				y: 4,
				formatter: function() {
					return ((enuml && enuml[this.value - 1]) ? enuml[this.value - 1] : " ");
				}
			},
		};
		options.chart.events = {
			click: function() {
				this.tooltip.hide();
			}
		};
		options.tooltip = {
			formatter: function() {
				return this.series.name;
			},
			hideDelay: 0,
			animation: false
		};
		if (enuml) {
			options.yAxis.showLastLabel = true;
			options.yAxis.tickInterval = 1;
		}
		if ($cube.$scale) {
			options.yAxis.max = parseInt($cube.$scale, 10);
		}
	} else {
		options.chart.type = widget._meta.defaultStyle;
	}
	return options;
}

function _createChart(widget, settings) {
	var options = Highcharts.merge(Highcharts.getOptions(), _getOptions(widget, widget.context.prototype));
	var hasBar;
	var RTLalign = _ext.context.isRTL ? "left" : "right";
	if (settings) {
		options.xAxis[0].categories = settings.categories;

		var keys = Object.keys(settings.series);
		for (var ii = 0, jj = keys.length; ii < jj; ii++) {
			var key = keys[ii];
			var serie = _ext.data.clone(settings.series[key]),
				serieMeta = widget._meta.series[key];
			if (options.chart.polar && serie && serie.type) {
				delete serie.type;
			}
			if (!(serieMeta && serieMeta.isHidden)) {
				if (serie.type == "bar") {
					hasBar = true;
				}
				options.series.push(serie);
			}
		}
	} else {
		var keys = Object.keys(widget._meta.series);
		for (var ii = 0, jj = keys.length; ii < jj; ii++) {
			var key = keys[ii];
			var metaSerie = widget._meta.series[key];
			var serie = _ext.data.clone(metaSerie.options);
			if (options.chart.polar && serie && serie.type) {
				delete serie.type;
			}
			serie.data = [0];
			if (!metaSerie.isHidden) {
				if (serie.type == "bar") {
					hasBar = true;
				}
				options.series.push(serie);
			}
		}
	}
	options.navigation = options.navigation || {};
	options.navigation.buttonOptions = options.navigation.buttonOptions || {};
	options.navigation.buttonOptions.align = RTLalign;

	options.legend = options.legend || {};
	options.legend.useHTML = _ext.context.isRTL;
	options.legend.align = RTLalign;
	options.legend.rtl = _ext.context.isRTL;

	if (options.tooltip) {
		options.tooltip.useHTML = _ext.context.isRTL;
	}
	var xAxis = options.xAxis = options.xAxis && options.xAxis[0];
	if (xAxis && xAxis.title) {
		options.series && (options.series.length == 1) && (xAxis.title.text = options.series[0].name);
		xAxis.title.useHTML = _ext.context.isRTL;
	}
	var yAxis = options.yAxis = options.yAxis && options.yAxis[0];
	if (yAxis) {
		if (yAxis.title) {
			yAxis.title.useHTML = _ext.context.isRTL;
		}
		if (yAxis.labels) {
			yAxis.labels.useHTML = _ext.context.isRTL;
		}
	}
	if (hasBar) {
		if (xAxis) {
			xAxis.opposite = _ext.context.isRTL;
			if (xAxis.labels) {
				xAxis.labels.align = RTLalign;
				xAxis.labels.useHTML = _ext.context.isRTL;
			}
		}
		if (yAxis) {
			yAxis.reversed = _ext.context.isRTL;
			if (yAxis.labels) {
				yAxis.labels.align = RTLalign;
			}
		}
	} else {
		if (xAxis) {
			xAxis.reversed = _ext.context.isRTL;
			if (xAxis.labels) {
				xAxis.labels.align = RTLalign;
			}
		}
		if (yAxis) {
			yAxis.opposite = _ext.context.isRTL;
			if (yAxis.labels) {
				yAxis.labels.align = RTLalign;
			}
		}

	}
	if (widget.useLogarithmicAxis) {
		if ((widget.maxValue || 0) / (widget.minValue || 1) > 10) {
			options.yAxis.type = 'logarithmic';
		}
	}
	widget._chart = new Highcharts.Chart(options);

	var legend = widget._chart.legend;
	widget.displayLegend = widget.currentMetaData.$cube.$displaysOneMeasure ? false : legend && legend.display;

	var chartSeries = widget._chart.series,
		serie, serieMeta;
	for (var j = chartSeries.length - 1; j >= 0; j--) {
		serie = chartSeries[j];
		serieMeta = serie && serie.options.id && widget._meta.series[serie.options.id.slice(3)];
		if (serieMeta && serieMeta.measure) {
			serieMeta.measure.$color = serieMeta.options.color = serie.color;
		}
	}

	_showDrillUp(widget, false);

	if (widget.currentMetaData.$cube.$displaysOneMeasure) {
		_selectChartMeasure(widget);
	}
}

function _setSerie(widget, id) {
	widget._chart.series.map(function(s) {
		s.hide();
	});
	widget._chart.get(id).show();
}

function _getLink(widget, name) {
	var link = widget._meta.links && widget._meta.links[name];
	if (link) {
		var links = {};
		links[link.id] = _ext.data.clone(link.link);
		return {
			$item: {
				$links: links
			}
		};
	}
}

function _processMeta(widget, metaData, init) {
	_processMeasures(widget, metaData, init);
	var xAxis = widget._meta.xAxis && widget._meta.xAxis[0];
	widget._meta.links = widget._meta.links || {};
	metaData.$links = metaData.$links || {};
	_applyLinks(widget, metaData, "$links");
	_applyLinks(widget, metaData, "$actions");
	_applyLinks(widget, metaData.$item, "$links");
	if (xAxis && xAxis.code && metaData.$properties && metaData.$properties[xAxis.code].$thumb && metaData.$properties[xAxis.code].$thumb.$links) {
		_applyLinks(widget, metaData.$properties[xAxis.code].$thumb, "$links");
	}
	widget._meta.drillDownLink = _getLink(widget, "$drillDown");
	widget._meta.drillUpLink = _getLink(widget, "$drillUp");
	_processAxes(widget, metaData, init);
}

function Chart(context) {
	this.context = context;
	this.locale = _locale.resources(module)();
	this.useLogarithmicAxis = false;
	var prototype = this.context.prototype;
	prototype.$properties = prototype.$item && prototype.$item.$properties;
	this.dataset = null;
	// article._cube = cube(article);
	_mergeMetaData(this, prototype);
	_mergeMetaData(this, this.context.design);
	this._meta = {
		xAxis: [{}],
		series: {},
		displaysOneMeasure: this.currentMetaData && this.currentMetaData.$displaysOneMeasure,
		hasMeasureSelector: this.currentMetaData && this.currentMetaData.$hasMeasureSelector,
		hasStyleSelector: this.currentMetaData && this.currentMetaData.$hasStyleSelector,
		defaultStyle: _style(this.currentMetaData.$style) || 'column',
		drill: {
			minLevel: 1,
			maxLevel: 0,
			currLevel: 1,
			currAxisHier: 0,
			levelsProperties: [],
			members: [],
			stack: [{
					$axes: prototype.$axes,
					$item: prototype.$item,
					$slicer: prototype.$slicer
				}]
				/*              code: prototype.$codeStat || "UNKNOWN",
				 axis0FieldCode: self._meta.xAxis[0].code || ""*/
		}
	};
	_processMeta(this, prototype, true);
	this.applyDesignMeta(this.context.design);
}

Chart.prototype._redraw = function() {
	if (this._chart) {
		if (!this.context.div || this.context.div.style.display === "none") {
			return;
		}
		this._chart.redraw();
		_displayLegend(this, this.displayLegend);
	}
};

Chart.prototype.setValue = function(dataset, metaData) {
	this.dataset = dataset;
	metaData && _processMeta(this, metaData);
	var settings;
	if (this.dataset && this.dataset.length > 0) {
		settings = _settingsFromValue(this);
	}
	if (settings) {
		if (!this._chart) {
			_createChart(this, settings);
		} else {
			this._chart.xAxis && this._chart.xAxis[0].setCategories(settings.categories, false);
			var series = this._chart.series;
			if (series && series.length == 1 && series[0].name) {
				this._chart.xAxis && this._chart.xAxis[0].options && this._chart.xAxis[0].options.title && (this._chart.xAxis[0].options.title.text != series[0].name) && (this._chart.xAxis[0].options.title.text = series[0].name);
			}
			if (this._chart.options.chart.polar) {
				for (var j = series.length - 1; j >= 0; j--) {
					series[j].remove(false);
				}
			}
			if (!series || series.length === 0) {
				var keys = Object.keys(settings.series);
				for (var ii = 0, jj = keys.length; ii < jj; ii++) {
					var key = keys[ii];
					if (!settings.series[key].isHidden) {
						this._chart.addSeries(settings.series[key], false);
					}
				}
			} else {
				var toRemove = [];
				for (var ii = 0, len = series.length; ii < len; ii++) {
					var chartSerie = series[ii],
						key = chartSerie.options.id.slice(3),
						serie = settings.series[key],
						update = {};
					// Update series options before setting new data because of an Highcharts issue that restores old values
					mergeChanges(update, chartSerie, serie);
					if (Object.keys(update).length) {
						chartSerie.update(update, false);
					}
					if (serie.isHidden) {
						toRemove.push(chartSerie);
					} else {
						chartSerie.setData(serie.data, false);
					}
					// serie.data = [];
				}
				toRemove.map(function(s) {
					s.remove();
				});
			}
			if (this.useLogarithmicAxis) {
				var yAxisType = 'linear';
				if ((this.maxValue || 0) / (this.minValue || 1) > 10) {
					yAxisType = 'logarithmic';
				}
				if (this._chart.yAxis[0].type !== yAxisType) {
					this._chart.yAxis[0].update({
						type: yAxisType
					});
				}
			}
			this._redraw();
		}
	} else {
		if (this._chart) {
			this._chart.destroy();
			this._chart = null;
		}
	}
	_showDrillUp(this, false);
};

function _resizeChart(widget) {
	if (widget._chart) {
		var height = Math.max(widget._chart.chartHeight || widget.context.div.clientHeight, 250);
		widget._chart.setSize(widget.context.div.clientWidth, height);
		widget._redraw();
		if (widget.currentMetaData.$cube.$displaysOneMeasure) {
			_selectChartMeasure(widget);
		}
	}
}

Chart.prototype.resize = function() {
	var self = this;
	if (self._chart && self._chart.container) {
		clearTimeout(self.resizeTimeout);
		if (!self._chart.isResizing) {
			self.resizeTimeout = setTimeout(function() {
				_resizeChart(self);
			}, 100);
		} else {
			_resizeChart(self);
		}
	}
};

Chart.prototype.applyDesignMeta = function(metadata) {
	_processMeasures(this, metadata);
	if (this._chart) {
		var designMeta = this.currentMetaData,
			needRefresh = false,
			needInverted = false;
		if (this._meta) {
			if (designMeta.$style) {
				var keys = Object.keys(this._meta.series);
				var size = 80,
					slice = Math.round(size / keys.length);
				for (var ii = 0, jj = keys.length; ii < jj; ii++) {
					var key = keys[ii];
					var metaSerie = this._meta.series[key];
					metaSerie.type = designMeta.$style;
					if (this._chart) {
						var serie = this._chart.get(metaSerie.options.id);
						if (serie) {
							_setType(this, serie, designMeta.$style, size, size - slice);
							size -= slice;
						}
					}
				}
				this._redraw();
			}
			var $measures = designMeta.$cube && designMeta.$cube.$measures;
			if ($measures) {
				var keys = Object.keys($measures);
				for (var ii = 0, jj = keys.length; ii < jj; ii++) {
					var key = keys[ii];
					var $measure = $measures[key];
					var metaSerie = this._meta.series[key];
					var serie = this._chart.get(metaSerie.options.id);
					if (serie) { //Hack lv to avoid error. waiting best fix if necessary (change style is not used for this)
						if ($measure.$style || $measure.$color) {
							needRefresh = true;
							var newOpt = {};
							if ($measure.$style) {
								newOpt.type = _style($measure.$style);
							}
							if ($measure.$color) {
								newOpt.color = $measure.$color;
							}
							serie.update(newOpt, false);
						}
					}
				}
				// Default Highcharts behavior is to invert axes if a serie of bar type is present among all series
				this._chart.series.forEach(function(s) {
					needInverted = needInverted || s.type === "bar";
				});
				if (this._chart.inverted ? !needInverted : needInverted) {
					this._chart.destroy();
					this._chart = null;
					_createChart(this, _settingsFromValue(this));
				} else {
					needRefresh && this._redraw();
				}
			}
		}
	}
};

Chart.prototype.dispose = function() {
	this.resizeTimeout && clearTimeout(this.resizeTimeout);
	this._chart && this._chart.destroy();
};

exports.create = function(context) {
	return new Chart(context);
};