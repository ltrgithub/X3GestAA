"use strict";

var _ext = require('syracuse-ui/lib/extend/extendGateway');
require("./deps/cleditor/jquery.cleditor");
var _locale = require('streamline-locale');
var _rtf = require("@sage/rtf-converter");
var _buttons = require('./richEditWidget/richEditButtons');

var _htmlStyles = [
	["paragraph", "<p>"],
	["h4", "<h4>"],
	["h5", "<h5>"]
];
var _extendColors = ["BF7F00", "7F0000"];

function _finalizeRawText(text) {
	return text ? text.replace(/<\/pre><pre>/gi, "\n").replace(/<pre>/gi, "").replace(/<\/pre>/gi, "") : "";
}

function _sanitize(html) {
	return _rtf.toHtml(_rtf.fromHtml(_sanitizeHtml(html)));
}

function _sanitizeHtml(html) {
	return _ext.context.developpementMode ? html : html_sanitize(html, uriRewriter);
}

function uriRewriter(uri) {
	return uri;
}

function _checksum(text) {
	var a = 1,
		b = 0;
	for (var index = 0; index < text.length; ++index) {
		a = (a + text.charCodeAt(index)) % 65521;
		b = (b + a) % 65521;
	}
	return (b << 16) | a;
	// return md5(text);
}

var _editorHelpers = {
	htmlEscapeMap: {
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;',
		'"': '&quot;',
		'/': '&#x2F;',
		'`': '&#x60;'
	},
	createEscaper: function(map) {
		var escaper = function(match) {
			return map[match];
		};
		var source = '(?:' + Object.keys(map).join('|') + ')';
		var testRegexp = RegExp(source);
		var replaceRegexp = RegExp(source, 'g');
		return function(string) {
			string = string == null ? '' : '' + string;
			return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
		};
	},
	objInvert: function(obj) {
		var result = {},
			keys = Object.keys(obj),
			i, length = keys.length;
		for (i = 0; i < length; i++) {
			result[obj[keys[i]]] = keys[i];
		}
		return result;
	}
};
if (!String.prototype.endsWith) {
	String.prototype.endsWith = function(suffix) {
		return this.length >= suffix.length && this.substr(this.length - suffix.length) == suffix;
	};
}

function RichEdit(context) {
	this.context = context;
	this.locale = _locale.resources(module)();
	this.isRtfMimeType = this.context.prototype.$type == "text/rtf";
	context.design.$isTopLabelAlignment = true;
	context.design.$isAutoSizeDisabled = true;
	context.design.$isAutoSize = true;
	this._cache = {};
	this.$maxLength = context.prototype.$maxLength || context.prototype.$maxByteLength;
	this.hasRawCapability = context.prototype.$capabilities && (context.prototype.$capabilities.indexOf("raw") >= 0);
	this.isRawAllowed = this.isRtfMimeType && this.hasRawCapability;

	this._setLazyUrl();
	this.$contentType = context.prototype.$type === 'application/x-document' && context.prototype.$contentType || context.prototype.$type;

	context.div.setAttribute("id", context.id + "-data");
	this._caret = document.createElement("div");
	this._caret.id = context.id + "-caret";
	_ext.dom.hide(this._caret, true);
	context.div.appendChild(this._caret);

	this.textArea = document.createElement("textarea");
	this.textArea.setAttribute("spellcheck", false);
	this.textArea.setAttribute("autocorrect", "off");
	this.textArea.setAttribute("name", this.textArea.id = "html-editor-" + context.id);
	this.textArea.syraItem = this.textArea.syrainout = context.id;
	context.div.appendChild(this.textArea);
	context.design.$rows && this.textArea.setAttribute("rows", context.design.$rows);

	this._load();
}

RichEdit.prototype.defaultOptions = {
	"fontSize": _rtf.getDefaultFontSize(),
	"fontFace": _rtf.getDefaultFontFace()
};
RichEdit.prototype._refreshEditor = function() {
	var editor = this._editor;
	if (editor && editor.$frame) {
		editor.refresh();
		this._fitToContent();
		this.bindEvent && this._bindInput(true);
	}
};

RichEdit.prototype._fitToContent = function() {
	var editor = this._editor;
	var frame = editor && editor.$frame && editor.$frame[0];
	if (frame) {
		var childDoc = frame && frame.contentWindow && frame.contentWindow.document;
		if (childDoc && childDoc.body) {
			if (!this.context.editable) {
				this.context.div.style.width = "100%";
			}
			frame.style.width = "100%";
			var height = (childDoc.body.scrollHeight) + 17 + "px"; //40 is security margin for iframe
			frame.style[this.context.editable ? "minHeight" : "height"] = height;
		}
	}
};

RichEdit.prototype._disable = function(disabled) {
	if (this._editor) {
		this._editor.disable(disabled);
		if (this._editor.disabled && !this.context.editable)
			this._editor.$toolbar.hide();
	}
};

RichEdit.prototype.getCaretPosition = function() {
	if (!(this.context.editable && ((this._editor || {}).doc || {}).body && this._caret)) {
		return -1;
	}
	var sel = this._getSelection(this._editor),
		caretPos, range, contents;
	try {
		range = this._editor.doc.createRange();
		range.setStart(this._editor.doc.body, 0);
		sel.focusNode && range.setEnd(sel.focusNode, sel.focusOffset);
		contents = range.cloneContents();
	} catch (e) {
		return -1;
	}
	if (contents) {
		$(this._caret).append(contents);
		this._caret.innerHTML = this._caret.innerHTML.replace(/<br\s*[\/]?>/gi, "\n");
		caretPos = this._caret.textContent.length;
		_ext.dom.empty(this._caret);
	}
	return caretPos || 0;
};

RichEdit.prototype._normalizeRawText = function(text) {
	return text.replace(/&nbsp;/gi, " ").replace(/<br\s*[\/]?>/gi, "\r\n").replace(/<p>/gi, "\r\n");
};

RichEdit.prototype._fixHtml = function(html) {
	return html.replace(/<br\s*[\/]?>$/gi, "").replace(/<p><\/p>/gi, "");
};

RichEdit.prototype._setLazyUrl = function(value) {
	this.$lazyUrl = _ext.data.parseExpression(this.context, (value && value.$url) || this.context.prototype.$url);
};

RichEdit.prototype._getSelection = function(editor) {
	// supported by all browsers including ie9
	var elt = editor.sourceMode() ? document : editor.$frame[0].contentWindow,
		sel;
	if (elt) {
		if (elt && elt.getSelection) {
			sel = elt.getSelection();
		}
		if (!sel && elt.selection)
			sel = elt.selection.createRange();
	}
	return sel;
};


RichEdit.prototype._finalizeCreate = function() {
	var self = this;
	self.onStateChanged(self.context.prototype);
	self.onStateChanged(self.context.field);
	if (self.context.field.$valueStyle) {
		self._editor.options.bodyStyle = self.context.field.$valueStyle;
	}
	self._refreshEditor();

	// Intercept paste event to get the opportunity of sanitizing the contents
	self.isRtfMimeType &&
		$(self._editor.doc.body).bind('paste', function(e) {
			// this code corrupts the undo stack!!!
			var pastedText;
			if (e && e.clipboardData && e.clipboardData.getData) {
				if (/text\/html/.test(e.clipboardData.types)) {
					pastedText = e.clipboardData.getData('text/html');
				} else
					if (/text\/plain/.test(e.clipboardData.types)) {
						pastedText = e.clipboardData.getData('text/plain');
					} else {
						pastedText = "";
					}
			} else
				if (window.clipboardData && window.clipboardData.getData) { // IE
					pastedText = window.clipboardData.getData('Text');
				} else {
					var el = $(this);
					// Hiding the underlying element causes some unpredictable behavior
					setTimeout(function() {
						var text = $(el).html();
						if (text) {
							$(el).html(_sanitize(text));
						}
						// display && el.css('display', display);
					}, 300);
				}
			if (pastedText) {
				$(this).html(_sanitize(pastedText));
				e.preventDefault();
				e.stopPropagation();
			}

		});

	self._bindInput(true);
};


RichEdit.prototype._setContent = function(contents, saveStyles) {
	this._isRaw = false;
	if (!contents || contents.length === 0 || typeof (contents) === 'object') {
		// No contents, assume we want to edit Rich Text or HTML
	} else {
		switch (this.context.prototype.$type) {
			case "text/rtf":
				if (contents.match(/^\s*{\\(u|)rtf/)) {
					contents = _rtf.toHtml(this.htmlEscape(contents));
				} else
					if (this.isRawAllowed) {
						this._isRaw = true;
						if (!contents.match(/<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i)) {
							// Not an HTML contents, so wrap it in <pre> tag
							contents = "<pre>" + this.htmlEscape(contents) + "</pre>";
						}
					} else {
						_ext.alert.error(this.context, _locale.format(this.locale.errorRtfExpected, contents));
						return;
					}
				break;
			case "text/html":
				// contents as is
				break;
		}
	}
	if (saveStyles && contents) {
		this.$$savedStyles = $("<div>").append(contents).find('style');
	}
	this._setContentRawEdit(contents);
	!this.context.editable && this.onStateChanged(this.context.field);
};

RichEdit.prototype._getContentRawEdit = function() {
	var editor = this._editor;
	if (editor && editor.doc) {
		if (editor.doc.body) {
			return this._fixHtml(editor.doc.body[editor.options.noValueOnload ? "outerHTML" : "innerHTML"] || "");
		} else {
			if (editor.$area) {
				// iframe is not yet created so return the textarea content
				return this._fixHtml(editor.$area[0].innerHTML || "");
			}
		}
	}
};
RichEdit.prototype._setContentRawEdit = function(contents) {
	if (this._editor && this._editor.$area) {
		this._editor.$area.val(contents || '');
		this._editor.updateFrame();
	}
};
RichEdit.prototype._getContentPersistent = function(contents) {
	if (!this.context.editable)
		return null;

	if (contents === undefined) {
		contents = this._getContentRawEdit();
	}
	if (contents === undefined) {
		return null;
	}
	var hash = _checksum(contents);
	if (hash === this._cache.checksum) {
		if (!this._isRaw || contents.indexOf('<pre>') < 0)
			return this._cache.value;
	}
	this._cache.raw = contents;
	this._cache.checksum = hash;
	if (this._editor.options.noValueOnload) {
		if (contents.indexOf("body") >= 0) {
			contents = contents.replace('<body', '<div');
			contents = contents.replace('<\body>', '<\div>');
		}
	}
	if (this.$$savedStyles) {
		var $$contents = $('<div>').append(contents);
		if ($$contents.find('style').length === 0) {
			$$contents.prepend(this.$$savedStyles);
			contents = $$contents.html();
		}
	}
	if (this._isRaw) {
		if (contents.indexOf('<pre>') == 0) {
			contents = this._normalizeRawText(contents);
			if (contents.indexOf('<pre>') != 0) {
				var preElement = document.createElement('pre');
				preElement.innerHTML = contents;
				contents = preElement.outerHTML;
			}
		} else {
			var preElement = document.createElement('pre');
			preElement.innerHTML = contents;
			contents = this._normalizeRawText(preElement.outerHTML);
		}
		contents = this.htmlUnescape(contents);
	} else {
		if (this.isRtfMimeType) {
			contents = (contents || "").length === 0 ? "" : _rtf.fromHtml(contents);
		}
	}
	this._cache.value = contents;
	return contents;
};


RichEdit.prototype._bindInput = function(bind) {
	var self = this;
	self.bindEvent = bind;
	var doc = self._editor && self._editor.doc;
	if (doc) {
		var $$input = $(doc.body);
		var $$inputWindow = _ext.context.browser.isFireFox ? $(doc) : $(self._editor.$frame[0].contentWindow);
		if (bind) {
			$$input.on("change focusin focusout", function(event) {
				self.context.onFieldInputEvent(event);
				event.stopPropagation();
			});
			$$input.on("keydown keypress keyup", function(event) {
				if (_ext.keyboard[event.type]) {
					if (!(event.type == "keypress" && _ext.keyboard.getKeyName(event.keyCode) == "enter")) {
						_ext.keyboard[event.type](event, self.context.field);
					}
				} else {
					self.context.onFieldInputEvent(event);
				}
				event.stopPropagation();
			});
			$$inputWindow.on("click", function(event) {
				self.context.onFieldInputEvent(event);
				event.stopPropagation();
			});
			$$inputWindow.focus(function(event) {
				$$input.trigger("focusin");
				event.stopPropagation();
			});
			$$inputWindow.blur(function(event) {
				if (self.isDirty(_ext.context.browser.isMSIE)) { //dirty
					$$input.trigger("change");
				}
				$$input.trigger("focusout");
				event.stopPropagation();
			});
		} else {
			$$input.off();
			$$inputWindow.off();
		}
	}
};

RichEdit.prototype.validate = function(errors, value) {
	if (this.currentValue && this.$maxLength && this.currentValue.length > this.$maxLength) {
		errors.push(_locale.format(this.locale.errorMaxLength, this.$maxLength));
	}
};

RichEdit.prototype.getInputValue = function() {
	var value = "";
	if (this.context.editable && this._editor && this._editor.$area) {
		value = this._getContentPersistent();
		if (this._isRaw && value) {
			value = _finalizeRawText(value);
			value = this.fixEmptyPre(value);
		}
	}
	return value;
};

RichEdit.prototype.setValue = function(value) {
	var self = this;
	self._setLazyUrl(value);
	self._editor.options.noValueOnload = !value;
	if (self.$lazyUrl && value && typeof (value) === 'object') {
		// lazy loading
		self.$contentType = value.$contentType || (self.context.prototype.$type === 'application/x-document' && self.context.prototype.$contentType || self.context.prototype.$type);
		_ext.ajax.get({
			url: self.$lazyUrl,
			contentType: self.$contentType,
			accept: self.$contentType,
			success: function(data, response) {
				self.setValue(data);

			},
			error: function(error) {
				self.context.invalidate(error.message);
			}
		});
	} else {
		try {
			if (value !== undefined && self.currentValue != value) {
				self._setContent(value, true);
				if (self.context.editable) {
					self.currentValue = self._getContentPersistent();
				} else {
					self.currentValue = value;
					self._fitToContent();
				}
				if (!self._isDirty) {
					self._cache.dirtyChecksum = self._cache.checksum;
				}
			}
		} catch (error) {
			self.context.invalidate(error.message);
		} !self.context.editable && self._disable(self._editor.disabled);
	}
};

RichEdit.prototype.setInputFocus = function(select) {
	if (this.context.editable && this._editor) {
		if (!this.isCreated) {
			this._isFocusRequested = true;
		} else {
			this._editor.focus();
			return true;
		}
	}
};

RichEdit.prototype.applyShortCut = function(shortcuts, event) {
	if (shortcuts.enter || shortcuts.backspace || shortcuts.down || shortcuts.up)
		return true;
	return false;
};

RichEdit.prototype.resize = function() {
	if (!this.isCreated) {
		this.isCreated = true;
		this._finalizeCreate();
		if (this._isFocusRequested) {
			this._editor.focus();
			delete this._isFocusRequested;
		}
	}
	this._refreshEditor();
};

RichEdit.prototype.onStateChanged = function(state) {
	var disabled;
	if (state.$isEditMode !== undefined) {
		disabled = !state.$isEditMode;
	}
	if (disabled === undefined || !disabled) {
		// If the editor is not in edit mode, we can check the $isDisabled meta
		if (state.$isDisabled !== undefined) {
			disabled = state.$isDisabled;
		}
	}
	if (disabled === undefined || !disabled) {
		// If the editor is not in edit mode and not already disabled by meta, we can check the $isReadOnly meta
		if (state.$isReadOnly !== undefined) {
			disabled = state.$isReadOnly
		}
	}
	if (disabled !== undefined) {
		this._disable(disabled);
	}
};

RichEdit.prototype.dispose = function() {
	if (this.resizeSelector) {
		$(window).unbind(this.resizeSelector);
	}
	this._bindInput(false);
	if (this._editor) {
		this._editor.hidePopups();
		this._editor.dispose();
	}
};

RichEdit.prototype._load = function() {
	var self = this;

	//TODO :
	//A revoir : pourquoi un url particulieret ne pas traiter les datas editeur lazyload comme n'importe qu'elle autre
	self.context.field.notifyFieldChange = function(newValue) {
		if (self._editor.disabled) {
			return false;
		}
		self._setLazyUrl();
		self.context.field.currentValue = newValue;
		self.currentValue = newValue;
		if (self.$lazyUrl) {
			if (self.context.field.page.isServerNotifyDisabled) {
				syra_dataset.setFieldValue(self.context.field, newValue);
			} else {
				_ext.ajax.put({
					url: self.$lazyUrl,
					contentType: self.$contentType,
					accept: self.$contentType,
					data: newValue,
					success: function(data, response, requestUrl) { }
				});
			}
			return false; //disable default notifyFieldChange
		}
		return true;
	};

	var $buttons = jQuery.cleditor.buttons;
	var ids = Object.keys($buttons);
	for (var ii = 0, jj = ids.length; ii < jj; ii++) {
		var title = self.locale[ids[ii]];
		if (title) {
			$buttons[ids[ii]].title = title;
		}
	}
	for (var ii = 0, jj = _htmlStyles.length; ii < jj; ii++) {
		var style = _htmlStyles[ii];
		style[0] = self.locale[style[0]] || style[0];
	}
	var _colors = jQuery.cleditor.defaultOptions.colors + " " + _extendColors.join(" ");
	var _fonts = jQuery.cleditor.defaultOptions.fonts.split(",");
	if (_fonts.indexOf("MS Sans Serif") < 0) {
		_fonts.push("MS Sans Serif");
	}
	_fonts = _fonts.sort().join(",");
	if (!$buttons.rawMode) {
		_buttons.rawMode(self, $buttons);
		_buttons.insertTable(self, $buttons);
		_buttons.link(self, $buttons);
		_buttons.color(self, $buttons);
		_buttons.size(self, $buttons);
		_buttons.font(self, $buttons);
		_buttons.extendSize(self, $buttons);
		_buttons.misc(self, $buttons);
	}
	self._editor = $(self.textArea).cleditor({
		width: self.context.design.$textWidth || "auto",
		height: self.context.design.$textHeight || "auto",
		controls: "bold italic underline strikethrough subscript superscript | font size style | color" + //
		" highlight removeformat | bullets" + //
		// " numbering" +
		" | insertTable " + //
		" | outdent indent alignleft center alignright justify" + //
		" | undo redo | rule image link unlink" + //
		" | cut copy paste pastetext" + //
		// condition source feature to development mode to prevent xss attack
		" | print" +
		(_ext.context.developpementMode ? " source" : "") +
		" rawMode " + //
		" | extendSize",
		colors: _colors,
		docCSSFile: "../../ui-text/public/richEditWidget/richEdit-doc.css",
		fonts: _fonts,
		bodyStyle: _ext.context.isRTL ? "direction:rtl" : "",
		// sizes in the font size popup
		sizes: _buttons.fontSizes,
		styles: _htmlStyles,
		useCSS: true,
		isRtfMimeType: self.isRtfMimeType,
		_widget: self,
		_isRaw: function() {
			return self.isRawAllowed && self._isRaw;
		},
		_setRaw: function(v) {
			if (self.isRawAllowed)
				self._isRaw = v;
		},
		_sanitizeHtml: _sanitizeHtml,
		// Handlers
		updateFrame: function(html) {
			return self.context.editable ? _sanitizeHtml(html) : html;
		},
		updateTextArea: function(html) {
			if (self.context.editable) {
				html = _sanitizeHtml(html);
			}
			var newValue = self.isRtfMimeType ? _rtf.fromHtml(html) : html;
			var updated = syra_form.update(self.context.field, newValue);
			if (!updated) {
				if (self.context.field.notifyFieldChange) {
					self.context.field.notifyFieldChange(newValue);
				}
			}
			return html;
		}
	})[0];
};


//this.$isReadOnly
//function _bindInput(widget, bind)

RichEdit.prototype.highlightOnFocus = function(on, event) {
	Field.prototype.highlightOnFocus.call(this, on, event);
	on && this.setInputFocus();
};
RichEdit.prototype.onDirtyChanged = function(dirty) {
	if (!dirty) {
		var contents = this._getContentPersistent(); // to compute checksum;
		this._cache.dirtyChecksum = this._cache.checksum;
		this.context.editable && !this._isRaw && this._setContentRawEdit(_rtf.toHtml(this.context.prototype.$type != "text/html" ? this.htmlEscape(contents) : contents));
	}
};
RichEdit.prototype.isDirty = function(dontHidePopup) {
	// Get the current content to compute the checksum
	if (this._editor && !dontHidePopup) {
		this._editor.hidePopups();
	}
	var value = this._getContentPersistent();
	return (this._cache.dirtyChecksum != this._cache.checksum);
};

RichEdit.prototype.getEditorInnerText = function(el, win) {
	if (el.innerText !== undefined) {
		return el.innerText.replace(/\x0A/g, "\n");
	} else {
		win = win || window;
		var doc = win.document,
			sel, range, prevRange, selString;
		if (win.getSelection && doc.createRange) {
			sel = win.getSelection();
			if (sel.rangeCount) {
				prevRange = sel.getRangeAt(0);
			}
			range = doc.createRange();
			range.selectNodeContents(el);
			sel.removeAllRanges();
			sel.addRange(range);
			selString = sel.toString();
			sel.removeAllRanges();
			prevRange && sel.addRange(prevRange);
		} else if (doc.body.createTextRange) {
			range = doc.body.createTextRange();
			range.moveToElementText(el);
			range.select();
		}
		return selString.replace(/\x0A{2}/g, "\n");
	}
};
RichEdit.prototype.htmlEscape = _editorHelpers.createEscaper(_editorHelpers.htmlEscapeMap);
RichEdit.prototype.htmlUnescape = _editorHelpers.createEscaper(_editorHelpers.objInvert(_editorHelpers.htmlEscapeMap));
RichEdit.prototype.fixEmptyPre = function(value) {
	return value.charCodeAt(0) == 1 ? value.substring(1) : value;
};

exports.stylesheets = ["/ui-text/public/richEditWidget/richEdit.css"];
exports.create = function(context) {
	return new RichEdit(context);
};