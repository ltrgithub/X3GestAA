"use strict";
import * as Endpoint from '../profile/endpoint';
import * as UrlParameter from './urlParameter';

class SdataProtocol {
    public id = "sdata";
    private _path = "/" + this.id + "/";
    private _pathLength = this._path.length;
    parse(urlObj: Url): boolean {
        let index = urlObj.url.indexOf(this._path);
        if (index >= 0) {
            urlObj.endpoint = Endpoint.fromUrlString(urlObj.url.slice(index + this._pathLength));
            return true;
        }
    }
}

interface IClassicParams {
    fullCode: string,
    functionCode: string,
    transaction: string
}

class ClassicProtocol {
    public id = "trans";
    private _path = "/" + this.id + "/";
    private _pathLength = this._path.length;
    parse(urlObj: Url): boolean {
        let index = urlObj.url.indexOf(this._path);
        if (index >= 0) {
            urlObj.endpoint = Endpoint.fromUrlString(urlObj.url.slice(index + this._pathLength));
            this.setClassicParams(urlObj);
            return true;
        }
    }
    replaceFullCode(urlObj: Url, newFullCode: string) {
        if (urlObj.params.f) {
            let parts = urlObj.params.f.split("/");
            parts[0] = newFullCode;
            urlObj.params.f = parts.join("/");
            this.setClassicParams(urlObj);
            urlObj.stringify();
        }
    }
    private setClassicParams(urlObj: Url) {
        if (urlObj.params.f) {
            let fullCode = urlObj.params.f.split("/")[0]
            let parts = fullCode.split("~");
            urlObj.classicParams = {
                fullCode: fullCode,
                functionCode: parts[0],
                transaction: (parts.length > 1) && parts[1]
            };
        }
    }
}

const protocol = {
    sdata: new SdataProtocol(),
    classic: new ClassicProtocol()
};


export class Url {
    static addHost(url: string): string {
        let parts;
        let reg = new RegExp('^(?:f|ht)tp(?:s)?\://([^/]+)', 'im');
        try {
            parts = url.match(reg);
        }
        catch (error) {
        }
        if (!parts) {
            let href = window.location.href;
            url = href.slice(0, href.indexOf(window.location.host) + window.location.host.length) + url;
        }
        return url;
    }
    static ensureProxy(url: string) {
        var lower = url.toLowerCase();
        if (lower.indexOf(window.location.protocol) == 0 && lower.indexOf(window.location.protocol + "//" + window.location.host) != 0) {
            url = "/proxy" + UrlParameter.encode(url);
        }
        return url;
    }

    url: string;
    uri: string;
    private _host: string;
    private _params: any;
    classicParams: IClassicParams;
    endpoint: Endpoint.IEndpointKey;
    private _representationRoot: string;
    private _facet: string;

    constructor(url: string) {
        if (/#$/.test(url)) {
            url = url.substring(0, url.length - 1);
        }
        this.url = url;
        let limit = this.url.indexOf('?');
        this.uri = limit >= 0 ? url.slice(0, limit) : url;
        let params = limit >= 0 ? this.url.slice(limit + 1).split('&') : [];
        for (let param of params) {
            let hash = param.split("=");
            this.params[hash[0]] = decodeURIComponent(hash[1]);
        }
        if (!protocol.sdata.parse(this)) {
            protocol.classic.parse(this);
        }

        if (this.params.representation) {
            let ii = this.params.representation.indexOf("#");
            if (ii >= 0) {
                this.params.representation = this.params.representation.slice(0, ii);
            }
            let result = this.params.representation.split(".");
            this._representationRoot = result[0];
            this._facet = result[1];
        }
    }

    get isRepresentationUrl(): boolean {
        if (this.isFusion || (this.params && this.params.representation)) {
            return (this.url.indexOf("/$files/") < 0) && (this.url.search("/$shared/") < 0);
        }
        return false;
    }
    //compatibility for classicPage, do not use it
    get $url(): string {
        return this.url;
    }
    set $facet(newFacet: string) {
        this._facet = newFacet;
    }

    get representationRoot(): string {
        return this._representationRoot;
    }
    get $facet(): string {
        return this._facet;
    }
    get params(): any {
        if (!this._params) {
            this._params = {};
        }
        return this._params;
    }
    set params(value: any) {
        this._params = value;
    }
    ensureHost() {
        let host = this.host;
        if (!host) {
            let href = window.location.href;
            this._host = href.slice(0, href.indexOf(window.location.host) + window.location.host.length);
            this.url = this._host + this.url;
            this.uri = this._host + this.uri;
        }
    }
    get href(): string {
        return this.isRepresentationUrl ? UrlParameter.encode(this.url) : this.url;
    }
    get host(): string {
        if (!this._host) {
            try {
                let parts = this.url.match(new RegExp('^(?:f|ht)tp(?:s)?\://([^/]+)', 'im'));
                this._host = parts && parts[1].toString();
            }
            catch (error) { }
        }
        return this._host;
    }
    set host(value: string) {
        this._host = value;
    }
    get isSyracuse(): boolean {
        return this.host ? this.host == window.location.host : true; //no host == relative
    }
    get isFusion(): boolean {
        return !!this.classicParams;
    }
    get role(): string {
        return this.params && this.params.role;
    }
    set role(roleId: string) {
        this.params.role = roleId;
    }
    get profile(): string {
        return this.params && this.params.profile;
    }
    set profile(profileJsurl: string) {
        this.params.profile = profileJsurl;
    }
    stringify(): string {
        if (this.endpoint) {
            let parts = this.uri.split("/");
            for (let ii = 0, jj = parts.length; ii < jj; ii++) {
                switch (parts[ii].toLowerCase()) {
                    case "sdata":
                    case "trans":
                        parts[ii + 1] = this.endpoint.application;
                        parts[ii + 2] = this.endpoint.contract;
                        parts[ii + 3] = this.endpoint.dataset;
                        this.uri = parts.join("/");
                        ii = jj; //end loop
                        break;
                }
            }
        }
        if (this.params) {
            let paramString = "";
            for (let key in this.params) {
                paramString += "&" + key + "=" + encodeURIComponent(this.params[key]);
            }
            this.url = this.uri + "?" + paramString.slice(1);
        }
        return this.url;
    }
    //only used in syra bookmarl => wait full move in REACT
    replaceClassicFullCode(newFullCode: string) {
        protocol.classic.replaceFullCode(this, newFullCode);
    }
    match(compare: Url, checkParams?: boolean) {
        if (this.classicParams) {
            return compare.classicParams && (compare.classicParams.fullCode == this.classicParams.fullCode);
        }
        else {
            if (compare.uri == this.uri) {
                if (!checkParams) return true;
                if (!compare.params && !this.params) {
                    return true;
                }
                else {
                    if (compare.params && this.params) {
                        let keys = Object.keys(this.params);
                        if (keys.length == Object.keys(compare.params).length) {
                            for (let key of keys) {
                                if (this.params[key] != compare.params[key]) {
                                    return false;
                                }
                            }
                            return true;
                        }
                    }
                }
            }
        }
    }
}