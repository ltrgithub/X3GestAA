"use strict";
import * as Sdata from '../../dataStore/sdata';
import { getLocalString } from '../../culture/localString';
import * as syra_url from '../../syra/utility/syra_url';
import { Url } from '../../route/url';

type VariantKey = "menuItem" | "menuBlock";

export interface ISitemapItem extends ISitemapEntity {
    title: string,
    variantKey: VariantKey,
    dispose: () => void
}

export interface IEntity {
    $uuid: string,
    title: string,
    description?: string
}

export interface ISitemapEntity {
    dataset: IEntity,
    navParent: any,
    articleParent: any,
    page: any
}

export interface ISitemapItem extends ISitemapEntity {
    variantKey: VariantKey,
    dispose: () => void
}

const executeIds = ["$execute_$query", "$execute_$details", "$execute_$edit", "$execute_$cube"];

interface ICodeMenu {
    href: string,
    $url: string,
    description: string,
    title: string
}
interface IMenuItem extends IEntity, Sdata.IMenu {
    convergenceFunction?: string
    entity?: string,
    representation?: string,
    $links: any
}
interface ISingleField {
    $variantItemKey: string,
    variantItem: ISitemapItem
}

interface IMenuBlock extends IEntity {
    items: IEntity[]
};


export class SitemapMenu implements ISitemapItem {
    _url: Url;
    bookmarked: boolean;
    articleParent: any;
    submodule: any;
    dataset: IMenuItem;
    $url: string;
    codeMenu: ICodeMenu;
    singleField: ISingleField;
    $item: any;
    $disabled: boolean;
    page: any;
    //set from executeUrl
    href: string;
    $title: string;
    $description: string;
    private $execute: any;

    constructor(public navParent: any, public variant_dataset: any) {
        this.page = navParent.page;
        this.articleParent = this.submodule = navParent.submodule || navParent;
        this.dataset = variant_dataset.menuItem;
        if (this.dataset && this.dataset.$links) {
            for (let executeId of executeIds) {
                this.$execute = this.dataset.$links[executeId];
                if (this.$execute) {
                    this.$execute.$title = this.$execute.$title;
                    if (this.dataset.convergenceFunction) {
                        this.$execute.$description = getLocalString("sitemap_function") + ": " + this.dataset.convergenceFunction;
                    } else {
                        if (this.dataset.entity) {
                            this.$execute.$description = getLocalString("sitemap_entity") + ": " + this.dataset.entity;
                            if (this.dataset.entity != Sdata.pluralize(this.dataset.representation || "")) {
                                this.$execute.$description += " (" + getLocalString("sitemap_representation") + ": " + this.dataset.representation + ")";
                            }
                        }
                    }
                    for (let key in this.$execute) {
                        (this as any)[key] = this.$execute[key];
                    }
                    break;
                }
            }
        }
    }
    get url(): Url {
        if (!this._url) {
            this.tempSyraMenu();
        }
        return this._url;
    }
    private tempSyraMenu() {
        this.$url = this.$execute.$url;
        syra_url.setHref(this);
        this._url = new Url(this.$url);
        this.codeMenu = {
            href: this.href,
            $url: this.$url,
            description: this.description,
            title: this.title
        };
        this.singleField = {
            $variantItemKey: this.variantKey,
            variantItem: this
        };
        this.$item = {};
    }
    get $uuid(): string {
        return this.dataset.$uuid;
    }
    get title(): string {
        return this.$title || this.dataset.title;
    }
    get description(): string {
        return this.$description || this.dataset.description;
    }
    get isMenuItem(): boolean {
        return true;
    }
    get variantKey(): VariantKey {
        return "menuItem";
    }
    dispose() {
    }
}

export class SitemapBlock implements ISitemapItem {
    articleParent: any;
    submodule: any;
    record: any;
    dataset: IMenuBlock;
    children: ISitemapItem[];
    collapsed: boolean;
    page: any;
    constructor(public navParent: any, public variant_dataset: any) {
        this.page = navParent.page;
        this.submodule = navParent.submodule || navParent;
        this.articleParent = this.navParent;
        this.record = this.dataset = variant_dataset.menuBlock;
        this.submodule.addChildren(this.dataset.items, this);
    }
    get variantKey(): VariantKey {
        return "menuBlock";
    }
    get title(): string {
        return this.dataset.title;
    }
    get $uuid(): string {
        return this.dataset.$uuid;
    }
    dispose() {
        if (this.children) {
            for (let child of this.children) {
                child.dispose();
            }
        }
    }
}


export function setMenuDescription(menu: IMenuItem): string {
    let description: string;
    if (menu.convergenceFunction) {
        description = getLocalString("sitemap_function") + ": " + menu.convergenceFunction;
    } else {
        if (menu.entity) {
            description = getLocalString("sitemap_entity") + ": " + menu.entity;
            if (menu.entity != Sdata.pluralize(menu.representation || "")) {
                description += " (" + getLocalString("sitemap_representation") + ": " + menu.representation + ")";
            }
        }
    }
    return description || menu.$description;
}