import TestHelper from '../../../../__tests__/testHelper';
import * as React from 'react';
import * as Enzyme from 'enzyme';
import * as BookmarkController from '../../../bookmark/bookmarkController';
import { SitemapMenu } from '../../items';
import { SitemapPageController, IProps } from '../sitemapPageController';
import { Profile } from '../../../../profile/profile';
import { syra_menus } from '../../../../syra/utility/syra_menus';
import * as Dom from '../../../../utility/html/dom';


describe('sitemapPageController', function () {
    let profile: Profile;
    let component: Enzyme.ReactWrapper<IProps, any>;

    beforeEach(() => {
        profile = TestHelper.fixtures.getProfilePopulated();
        component = Enzyme.mount(<SitemapPageController profile={profile} />);
        jest.spyOn(Dom, 'scrollTo').mockReturnThis();
    });

    afterEach(() => {
        component.unmount();
        component = null;
        jest.resetModules();
        jest.resetModuleRegistry();
        jest.resetAllMocks();
    });

    it('should compare to snapshot', () => {
        let component = Enzyme.render(<SitemapPageController profile={profile} />);
        expect(component).toMatchSnapshot();
    });

    it('should add "href" attribute to link elements to support new window browser operations', () => {
        let menuLink = component.find('.s_sitemap_menu_link').at(10);
        expect(menuLink.getDOMNode().getAttribute('aria-label')).toBe('Global settings');
        expect(decodeURIComponent(menuLink.getDOMNode().getAttribute('href'))).toBe('?url=/sdata/syracuse/collaboration/syracuse/settings(code eq \'settings\')?representation=setting.$details');

        menuLink = component.find('.s_sitemap_menu_link').at(20);
        expect(menuLink.getDOMNode().getAttribute('aria-label')).toBe('Roles');
        expect(decodeURIComponent(menuLink.getDOMNode().getAttribute('href'))).toBe('?url=/sdata/syracuse/collaboration/syracuse/roles?representation=role.$query');


        menuLink = component.find('.s_sitemap_menu_link').at(44);
        expect(menuLink.getDOMNode().getAttribute('aria-label')).toBe('Menu Modules');
        expect(decodeURIComponent(menuLink.getDOMNode().getAttribute('href'))).toBe('?url=/sdata/syracuse/collaboration/syracuse/menuModules?representation=menuModule.$query');
    });

    describe('Interacions', () => {

        it('should trigger a navigation event on menu link click', () => {
            let spy = jest.spyOn(syra_menus.click, 'fire');
            let menuLink = component.find('.s_sitemap_menu_link').at(0);

            expect(spy).not.toBeCalled();
            menuLink.simulate('click');
            expect(spy).toHaveBeenCalledTimes(1);

            expect(spy.mock.calls[0][0].menu).toBeInstanceOf(SitemapMenu);

            spy.mockClear();
            spy.mockRestore();
        });

        describe('Bookmarks', () => {

            it('should display bookmark icon on hover', () => {
                expect(component.find('.s_sitemap_menu').length).toBe(70);

                let menuItem = component.find('.s_sitemap_menu').at(4);
                let bookmarkContainer = menuItem.find('.s_sitemap_bookmark').first();

                expect(bookmarkContainer).not.toHaveClassName('s_sitemap_bookmark_visble');
                menuItem.simulate('mouseEnter');
                expect(bookmarkContainer).toHaveClassName('s_sitemap_bookmark_visble');
                menuItem.simulate('mouseLeave');
                expect(bookmarkContainer).not.toHaveClassName('s_sitemap_bookmark_visble');
            });

            it('should save bookmark on star icon click', () => {
                let spy = jest.spyOn(BookmarkController, 'toggleMenu').mockImplementation(jest.fn());

                expect(component.find('.s_sitemap_menu').length).toBe(70);

                let menuItem = component.find('.s_sitemap_menu').at(4);
                let bookmarkContainer = menuItem.find('.s_sitemap_bookmark').first()

                expect(bookmarkContainer).not.toHaveClassName('s_sitemap_bookmark_visble');
                menuItem.simulate('mouseEnter');

                expect(spy).not.toBeCalled();
                bookmarkContainer.simulate('click');
                expect(spy).toHaveBeenCalledTimes(1);

                let firstCallArgs = spy.mock.calls[0];
                expect(firstCallArgs.length).toBe(5);
                expect(firstCallArgs[0]).toBe(profile);
                expect(firstCallArgs[1].url).toBe('/sdata/syracuse/collaboration/syracuse/hosts?representation=host.$query');
                expect(firstCallArgs[2]).toBe('Hosts');
                expect(firstCallArgs[3]).toBe('sitemap_entity: hosts');

                spy.mockClear();
            });

            it('should change the bookmark state after a successful operation', () => {
                let toggleMenuSpy = jest.spyOn(BookmarkController, 'toggleMenu');
                toggleMenuSpy.mockImplementation(jest.fn());
                let matchBookmarkSpy = jest.spyOn(profile.bookmarks, 'matchBookmark');
                matchBookmarkSpy.mockImplementation(() => true);

                expect(component.find('.s_sitemap_menu').length).toBe(70);

                let menuItem = component.find('.s_sitemap_menu').at(1);
                let bookmarkContainer = menuItem.find('.s_sitemap_bookmark').first();

                expect(bookmarkContainer).not.toHaveClassName('s_sitemap_bookmark_visble');
                menuItem.simulate('mouseEnter');
                expect(toggleMenuSpy).not.toBeCalled();
                bookmarkContainer.simulate('click');
                expect(toggleMenuSpy).toHaveBeenCalledTimes(1);

                let firstCallArgs = toggleMenuSpy.mock.calls[0];
                expect(firstCallArgs.length).toBe(5);
                expect(firstCallArgs[4] instanceof Function).toBe(true);

                expect(bookmarkContainer.find('i').text()).toBe('star_empty');

                firstCallArgs[4]();

                expect(matchBookmarkSpy).toHaveBeenCalledTimes(1);
                expect(bookmarkContainer.find('i').text()).toBe('star');

                toggleMenuSpy.mockClear();
                toggleMenuSpy.mockRestore();
                matchBookmarkSpy.mockRestore();
            });
        });

        describe('Toggle items', () => {

            function matchNodeVisibility(item: any, visible: boolean) {
                let display = item.getDOMNode().style.display;
                return display == (visible ? "" : "none");
            }
            function expectNodeVisibility(item: any, visible: boolean) {
                expect(matchNodeVisibility(item,visible)).toBe(true);
            }
            function expectVisibility(items: any, visible: boolean) {
                let matched = 0;
                items.forEach((submodule: any) => {
                    if (matchNodeVisibility(submodule, visible)) {
                        matched++;
                    }
                });
                expect(matched).toBe(items.length);
            }

            it('should toggle all items using the "collapse all" / "expand all" buttons', () => {
                let collapseAllButton = component.find('.s_sitemap_button').at(0);
                let expandAllButton = component.find('.s_sitemap_button').at(1);
                let submodules: any = component.find('.s_sitemap_submodules');
                let count = submodules.length;

                expect(collapseAllButton.getDOMNode().getAttribute('aria-label')).toBe('sitemap_collapseAll');
                expect(expandAllButton.getDOMNode().getAttribute('aria-label')).toBe('sitemap_expandAll');

                collapseAllButton.simulate('click');
                expectVisibility(submodules, false);

                expandAllButton.simulate('click');
                expectVisibility(submodules, true);
            });

            it('should toggle all underlying items on module header click', () => {
                expect(component.find('.s_sitemap_menu_link').length).toBe(70);
                let moduleContainer: Enzyme.ReactWrapper<Enzyme.HTMLAttributes, any>;

                // First module
                moduleContainer = component.find('.s_sitemap_module').at(0);
                expect(moduleContainer.find('.s_sitemap_menu_link').length).toBe(69);
                moduleContainer.find('.s_sitemap_module_link').simulate('click');
                expectVisibility(moduleContainer.find('.s_sitemap_submodules'), false);

                // Second module
                moduleContainer = component.find('.s_sitemap_module').at(1);
                expect(moduleContainer.find('.s_sitemap_menu_link').length).toBe(1);
                moduleContainer.find('.s_sitemap_module_link').simulate('click');
                expectVisibility(moduleContainer.find('.s_sitemap_submodules'), false);
            });

            it('should toggle all underlying items on submodule header click', () => {
                expect(component.find('.s_sitemap_menu_link').length).toBe(70);

                let subModuleContainer: Enzyme.ReactWrapper<Enzyme.HTMLAttributes, any>;

                // First submodule
                subModuleContainer = component.find('.s_sitemap_submodule').at(0);
                expectNodeVisibility(subModuleContainer.find('.s_sitemap_submodule_row'), true);

                subModuleContainer.find('.s_sitemap_submodule_link').simulate('click');
                expectNodeVisibility(subModuleContainer.find('.s_sitemap_submodule_row'), false);

                subModuleContainer.find('.s_sitemap_submodule_link').simulate('click');
                expectNodeVisibility(subModuleContainer.find('.s_sitemap_submodule_row'), true);

                // Second submodule
                subModuleContainer = component.find('.s_sitemap_submodule').at(1);
                expectNodeVisibility(subModuleContainer.find('.s_sitemap_submodule_row'), true);
                subModuleContainer.find('.s_sitemap_submodule_link').simulate('click');
                expectNodeVisibility(subModuleContainer.find('.s_sitemap_submodule_row'), false);
                subModuleContainer.find('.s_sitemap_submodule_link').simulate('click');
                expectNodeVisibility(subModuleContainer.find('.s_sitemap_submodule_row'), true);
            });

            it('should toggle all underlying items on menu block header click', () => {
                expect(component.find('.s_sitemap_menu_link').length).toBe(70);

                let menuBlockContainer: Enzyme.ReactWrapper<Enzyme.HTMLAttributes, any>;

                menuBlockContainer = component.find('.s_sitemap_menublock').at(0);
                expect(menuBlockContainer.find('.s_sitemap_menu_link').length).toBe(3);
                menuBlockContainer.find('.s_sitemap_menublock_link').simulate('click');
                expectNodeVisibility(menuBlockContainer.find('.s_sitemap_menublock_body'), false);
                menuBlockContainer.find('.s_sitemap_menublock_link').simulate('click');
                expectNodeVisibility(menuBlockContainer.find('.s_sitemap_menublock_body'), true);
            });
        });
    });

    describe('Search helper functions', () => {
        let testee: SitemapPageController;

        beforeEach(() => {
            testee = component.instance() as SitemapPageController;
        });

        it('should update search results based on search expression', () => {
            expect(testee.search.searchTotalResults).toBe(0);

            testee.onSearch('User');

            expect(testee.search.searchTotalResults).toBe(3);
            expect(testee.search.searchCurrentIndex).toBe(0);
        });

        it('should step items on search results interate', () => {
            expect(testee.search.searchTotalResults).toBe(0);

            testee.onSearch('User');

            expect(testee.search.searchTotalResults).toBe(3);
            expect(testee.search.searchCurrentIndex).toBe(0);
            expect(testee.onSearchResultIterate('next')).toBe(1);

            expect(testee.search.searchCurrentIndex).toBe(1);
            expect(testee.onSearchResultIterate('next')).toBe(2);
            expect(testee.search.searchCurrentIndex).toBe(2);
            expect(testee.onSearchResultIterate('prev')).toBe(1);
            expect(testee.search.searchCurrentIndex).toBe(1);
        });

        it('should step to the first item on stepping up from the last one', () => {
            expect(testee.search.searchTotalResults).toBe(0);

            testee.onSearch('User');

            expect(testee.onSearchResultIterate('next')).toBe(1);
            expect(testee.onSearchResultIterate('next')).toBe(2);
            expect(testee.onSearchResultIterate('next')).toBe(0);
        });

        it('should step to the last item on stepping down from the first item', () => {
            expect(testee.search.searchTotalResults).toBe(0);
            testee.onSearch('User');
            expect(testee.onSearchResultIterate('prev')).toBe(2);
        });

        it('should reset search results and indexes on clear search', () => {
            expect(testee.search.searchTotalResults).toBe(0);
            testee.onSearch('User');
            expect(testee.onSearchResultIterate('next')).toBe(1);
            expect(testee.search).toEqual({
                "searchCurrentIndex": 1,
                "searchCurrentItem": { "occurence": 1, "uuid": "234de8fb-57cf-4333-8956-d608d215734a" },
                "searchFilter": "User",
                "searchRegex": /User/gi,
                "searchTotalResults": 3
            });

            testee.onClearSearch();

            expect(testee.search).toEqual({
                searchFilter: '',
                searchRegex: /(?:)/gi,
                searchCurrentItem: null,
                searchCurrentIndex: 0,
                searchTotalResults: 0
            });
        });


        it('should apply css class on currently highlighted element', () => {
            const getElementMock = jest.spyOn(document, 'getElementById');
            const fakeNode1 = document.createElement('div');
            fakeNode1.setAttribute('id', '23fc4c9c-4496-4b7a-98c9-4c3b04539299');
            const fakeNode1Span = document.createElement('span')
            fakeNode1.appendChild(fakeNode1Span);

            const fakeNode2 = document.createElement('div');
            fakeNode2.setAttribute('id', '234de8fb-57cf-4333-8956-d608d215734a');
            const fakeNode2Span = document.createElement('span')
            fakeNode2.appendChild(fakeNode2Span);

            getElementMock.mockImplementation((id: string) => id === '23fc4c9c-4496-4b7a-98c9-4c3b04539299' ? fakeNode1 : fakeNode2);
            expect(testee.search.searchTotalResults).toBe(0);

            expect(fakeNode1Span.className.trim()).toEqual('');
            expect(fakeNode2Span.className.trim()).toEqual('');
            testee.onSearch('User');

            expect(fakeNode1Span.className.trim()).toEqual('s_link_highlight_text_focus');
            expect(fakeNode2Span.className.trim()).toEqual('');

            testee.onSearchResultIterate('next');

            expect(fakeNode1Span.className.trim()).toEqual('');
            expect(fakeNode2Span.className.trim()).toEqual('s_link_highlight_text_focus');

            getElementMock.mockClear();
        });

    });
});

