import * as React from 'react'
import * as Enzyme from 'enzyme'
import { SearchBar, ISearchBarProps } from '../searchBar';
import { Link } from '../../../../link/link';

describe("SearchBar", () => {
    const defaultProps = { onSearch: () => { }, onClearSearch: () => { }, onSearchResultIterate: () => 0, searchTotalResults: 0 }

    describe("Snapshots", () => {
        const render: (props: ISearchBarProps) => Cheerio = (props) => Enzyme.render(<SearchBar {...props} />)

        it("should compare snapshot scenario: No results", () => {
            expect(render(defaultProps)).toMatchSnapshot()
        });

        it("should compare snapshot scenario: Some results", () => {
            expect(render({ ...defaultProps, searchTotalResults: 3 })).toMatchSnapshot()
        });
    });

    describe("Interactions", () => {

        const mount: (props: ISearchBarProps) => [Enzyme.ReactWrapper<SearchBar, any>, any] =
            (props: ISearchBarProps) => {
                const wrapper: Enzyme.ReactWrapper<SearchBar, any> = Enzyme.mount(<SearchBar {...props} />);
                return [wrapper, (wrapper.instance() as any)];
            };

        it("should set currentIndex & value in constructor", () => {
            const [, instance] = mount(defaultProps);
            expect(instance.currentIndex).toBe(0);
            expect(instance.value).toBe("");
        });

        it("should be able to bypass value>=3 characters requirement if user press Enter", () => {
            const props = { ...defaultProps, onSearch: jest.fn() }
            const spy: jest.SpyInstance<any> = jest.spyOn(props, "onSearch");
            const [wrapper, instance] = mount(props);
            const input = wrapper.find('.s_sitemap_search_input');

            instance.input = { value: "a" };
            instance.value = "a";
            input.simulate('keyPress', { key: 'Enter' });
            expect(spy).toBeCalledWith("a");
            spy.mockReset();

            instance.input = { value: "" };
            instance.value = "";
            input.simulate('keyPress', { key: 'Enter' });
            expect(spy).not.toBeCalled();
            spy.mockReset();
            spy.mockClear();

        });

        it("should call onChange for every search input change", () => {

            const [wrapper, instance] = mount(defaultProps);
            const spy: jest.SpyInstance<any> = jest.spyOn(instance, "onChange");
            wrapper.update(); /* if you use class properties instead of manual this.bind in the component, you have to forceUpdate for spies to work (https://github.com/airbnb/enzyme/issues/944) */
            const input: any = wrapper.find('.s_sitemap_search_input');

            const simulateChangeInputValue = (value: string) => {
                input.getNode().value = value;
                input.simulate('change');
                expect(instance.input.value).toBe(value);
                expect(instance.value).toBe(value);
            }

            expect(spy.mock.calls.length).toBe(0);
            simulateChangeInputValue('a');
            simulateChangeInputValue('ab');
            simulateChangeInputValue('abc');
            simulateChangeInputValue('abcd');
            expect(spy.mock.calls.length).toBe(4);

            spy.mockClear();
            spy.mockReset();
        });
        it("should call a 200ms timeout where the search is invoked if value meets the requirements (>=3 characters, >=1 for exotic languages)", () => {
            jest.useFakeTimers();
            const props = { ...defaultProps, onClearSearch: jest.fn() };
            const onClearSearchSpy: jest.SpyInstance<any> = jest.spyOn(props, "onClearSearch");
            const [, instance] = mount(props);
            const onSearchSpy: jest.SpyInstance<any> = jest.spyOn(instance, "search");
            expect(instance.searchTimeout).toBeUndefined();

            instance.onChange();
            instance.value = "ab";
            jest.runTimersToTime(200);
            expect(onClearSearchSpy).toBeCalled();
            expect(onSearchSpy).not.toBeCalled();
            onClearSearchSpy.mockReset();
            onSearchSpy.mockReset();

            instance.onChange();
            instance.value = "abc";
            jest.runTimersToTime(200);
            expect(onClearSearchSpy).not.toBeCalled();
            expect(onSearchSpy).toBeCalled();
            onClearSearchSpy.mockReset();
            onSearchSpy.mockReset();

            instance.onChange();
            instance.value = "äºº"
            jest.runTimersToTime(200);
            expect(onClearSearchSpy).not.toBeCalled();
            expect(onSearchSpy).toBeCalled();
            onClearSearchSpy.mockClear();
            onSearchSpy.mockClear();

            expect(instance.searchTimeout).toBeNull();

        });

        it("should only do the search for the last value in the 200ms time span", () => {
            jest.useFakeTimers();
            const [wrapper, instance] = mount(defaultProps);
            const onSearchSpy: any = jest.spyOn(instance, "search");
            const input: any = wrapper.find('.s_sitemap_search_input');

            const simulateChangeInputValue = (value: string) => {
                input.getNode().value = value;
                input.simulate('change');
                expect(instance.input.value).toBe(value);
                expect(instance.value).toBe(value);
            }
            simulateChangeInputValue("a");
            simulateChangeInputValue("ab");
            simulateChangeInputValue("abc");
            simulateChangeInputValue("abcd");
            simulateChangeInputValue("abcde");

            expect(onSearchSpy).not.toBeCalled();
            jest.runTimersToTime(200);
            expect(instance.value).toBe("abcde");
            expect(onSearchSpy).toBeCalled();
            expect(onSearchSpy).toHaveBeenCalledTimes(1);
            expect(onSearchSpy).not.toHaveBeenCalledTimes(5);
        });

        it("should clear pending timeout on unmount", () => {
            const [wrapper, instance] = mount(defaultProps);
            const switchSearchTimerSpy: jest.SpyInstance<any> = jest.spyOn(instance, "switchSearchTimer");
            expect(instance.searchTimeout).toBeUndefined();
            wrapper.unmount();
            expect(switchSearchTimerSpy).toBeCalledWith(false);
            expect(instance.searchTimeout).toBeNull();
        })

        it("should move around results with the arrow buttons, and display should be synchonized", () => {
            const props = { ...defaultProps, onSearchResultIterate: jest.fn(), searchTotalResults: 3 }
            const onSearchResultIterate: jest.SpyInstance<any> = jest.spyOn(props, "onSearchResultIterate");
            onSearchResultIterate.mockImplementation(
                (direction: string) => {
                    if (direction === "prev") {
                        if (instance.currentIndex === 0) return (wrapper.props() as any)['searchTotalResults'] - 1;
                        else return instance.currentIndex - 1;
                    } else {
                        if (instance.currentIndex === (wrapper.props() as any)['searchTotalResults'] - 1) return 0;
                        else return instance.currentIndex + 1;
                    }
                }
            );
            const [wrapper, instance] = mount(props);
            const prevBtn = wrapper.find(Link).at(1);
            prevBtn.simulate('click');
            expect(onSearchResultIterate).toBeCalledWith('prev');
            const nextBtn = wrapper.find(Link).first();
            nextBtn.simulate('click');
            expect(onSearchResultIterate).toBeCalledWith('next');
            expect(instance.currentIndex).toBe(0);
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("1 of 3");
            nextBtn.simulate('click');
            nextBtn.simulate('click');
            expect(instance.currentIndex).toBe(2);
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("3 of 3");
            nextBtn.simulate('click');
            expect(instance.currentIndex).toBe(0)
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("1 of 3");
            prevBtn.simulate('click')
            expect(instance.currentIndex).toBe(2);
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("3 of 3");
            prevBtn.simulate('click');
            prevBtn.simulate('click');
            expect(instance.currentIndex).toBe(0);
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("1 of 3");
        });

        it("should have prev & next buttons disabled when there is no results", () => {
            const props = { ...defaultProps, searchTotalResults: 0 };
            const [wrapper,] = mount(props);
            const nextBtn = wrapper.find(Link).first();
            expect(nextBtn).toBeDisabled();
            const prevBtn = wrapper.find(Link).at(1);
            expect(prevBtn).toBeDisabled();
            const input: any = wrapper.find('.s_sitemap_search_input');
            input.getNode().value = "abcde";
            input.simulate('change');
            (wrapper as any).setProps({ 'searchTotalResults': 3 });
            expect(nextBtn).not.toBeDisabled();
            expect(prevBtn).not.toBeDisabled();
        });

        it("should have three children buttons (prev, next and close)", () => {
            const props = { ...defaultProps, searchTotalResults: 3 };
            const [wrapper,] = mount(props);
            const nextBtn = wrapper.find(Link).first();
            expect(nextBtn).not.toBeDisabled();
            expect(nextBtn.props()['icon']).toBe('dir_down');
            const prevBtn = wrapper.find(Link).at(1);
            expect(prevBtn).not.toBeDisabled();
            expect(prevBtn.props()['icon']).toBe('dir_up');
            const close = wrapper.find(Link).at(2);
            expect(close.props()['icon']).toBe('magnifying_glass');
        });

        it("should clear value when user clicks close icon", () => {
            const [wrapper, instance] = mount(defaultProps);
            const clearSpy: jest.SpyInstance<any> = jest.spyOn(instance, "clear");
            const close = wrapper.find(Link).at(2);
            close.simulate('click');
            expect(clearSpy).not.toBeCalled();
            expect(close.props()['icon']).toBe('magnifying_glass');
            const input: any = wrapper.find('.s_sitemap_search_input');
            input.getNode().value = "abcde";
            input.simulate('change');
            wrapper.update();
            expect(close.props()['icon']).toBe('close');
            close.simulate('click');
            expect(clearSpy).toBeCalled();
            expect(instance.value).toBe('');
            expect(instance.currentIndex).toBe(0);
        });

    });

});