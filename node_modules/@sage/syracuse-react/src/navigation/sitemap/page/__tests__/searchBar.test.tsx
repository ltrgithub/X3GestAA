import * as React from 'react'
import * as Enzyme from 'enzyme'
import {SearchBar, ISearchBarProps} from '../searchBar';
import { Link } from '../../../../link/link';

describe("SearchBar", () => {
    const defaultProps = {onSearch: ()=>{}, onClearSearch: ()=>{}, onSearchResultIterate: ()=>0, searchTotalResults: 0}

    describe("Snapshots", () => {
        const render: (props: ISearchBarProps) => Cheerio = (props) => Enzyme.render(<SearchBar {...props} />)

        it("should compare snapshot scenario: No results" , () => {
            expect(render(defaultProps)).toMatchSnapshot()
        });

        it("should compare snapshot scenario: Some results" , () => {
            expect(render({...defaultProps, searchTotalResults: 3})).toMatchSnapshot()
        });
    });

    describe("Interactions", ()=>{

        const mount: (props: ISearchBarProps) => [Enzyme.ReactWrapper<SearchBar, any>, any] =
            (props:any) => {
                const wrapper:Enzyme.ReactWrapper<SearchBar, any> = Enzyme.mount(<SearchBar {...props} />);
                return [wrapper, (wrapper.instance() as any)];
            };

        it("should set currentIndex & value in constructor", ()=> {
            const [,instance] = mount(defaultProps);
            expect(instance.currentIndex).toBe(0);
            expect(instance.value).toBe("");
        });

        it("should be able to bypass value>=3 characters requirement if user press Enter", ()=>{
            const props = {...defaultProps, onSearch: jest.fn()}
            const spy:any = jest.spyOn(props, "onSearch");
            const [wrapper,instance] = mount(props);
            const input = wrapper.find('.s_sitemap_search_input').at(0);

            instance.input = {value:"a"};
            instance.value = "a";
            input.simulate('keyPress', { key: 'Enter' });
            expect(spy).toBeCalledWith("a");
            spy.mockReset();

            instance.input = {value:""};
            instance.value = "";
            input.simulate('keyPress', { key: 'Enter' });
            expect(spy).not.toBeCalled();
            spy.mockReset();
            spy.mockClear();

        });

        it("should call onChange for every search input change", ()=>{

            const [wrapper, instance] = mount(defaultProps);
            const spy:any = jest.spyOn(instance, "onChange");
            wrapper.update(); /* if you use class properties instead of manual this.bind in the component, you have to forceUpdate for spies to work (https://github.com/airbnb/enzyme/issues/944) */
            const input = wrapper.find('.s_sitemap_search_input').at(0);

            const simulateChangeInputValue = (value:string) => {
                instance.input = {value}; /* mock the input ref */
                input.simulate('change', { target: { value } });
                expect(instance.value).toBe(value);
            }

            expect(spy.mock.calls.length).toBe(0);
            simulateChangeInputValue('a');
            simulateChangeInputValue('ab');
            simulateChangeInputValue('abc');
            simulateChangeInputValue('abcd');
            expect(spy.mock.calls.length).toBe(4);

            spy.mockClear();
            spy.mockReset();
        });
        it("should call a 200ms timeout where the search is invoked if value meets the requirements (>=3 characters, >=1 for exotic languages)", ()=>{
            jest.useFakeTimers();
            const props = {...defaultProps, onClearSearch: jest.fn()};
            const onClearSearchSpy:any = jest.spyOn(props, "onClearSearch");
            const [, instance] = mount(props);
            const onSearchSpy:any = jest.spyOn(instance, "search");
            expect(instance.searchTimeout).toBeUndefined();

            instance.onChange();
            instance.value = "ab";
            jest.runTimersToTime(200);
            expect(onClearSearchSpy).toBeCalled();
            expect(onSearchSpy).not.toBeCalled();
            onClearSearchSpy.mockReset();
            onSearchSpy.mockReset();

            instance.onChange();
            instance.value = "abc";
            jest.runTimersToTime(200);
            expect(onClearSearchSpy).not.toBeCalled();
            expect(onSearchSpy).toBeCalled();
            onClearSearchSpy.mockReset();
            onSearchSpy.mockReset();

            instance.onChange();
            instance.value = "人物"
            jest.runTimersToTime(200);
            expect(onClearSearchSpy).not.toBeCalled();
            expect(onSearchSpy).toBeCalled();
            onClearSearchSpy.mockClear();
            onSearchSpy.mockClear();

            expect(instance.searchTimeout).toBeNull();

        });

        it("should only do the search for the last value in the 200ms time span", ()=>{
            const [, instance] = mount(defaultProps);
            const onSearchSpy:any = jest.spyOn(instance, "search");
            instance.onChange();
            instance.value = "a";
            instance.onChange();
            instance.value = "ab"
            instance.onChange();
            instance.value = "abc"
            expect(onSearchSpy).not.toBeCalled();
            jest.runTimersToTime(200);
            expect(instance.value).toBe("abc");
            expect(onSearchSpy).toBeCalled();
            expect(onSearchSpy).toHaveBeenCalledTimes(1);
            expect(onSearchSpy).not.toHaveBeenCalledTimes(3);
        });

        it("should clear pending timeout on unmount", ()=>{
            const [wrapper, instance] = mount(defaultProps);
            const switchSearchTimerSpy:any = jest.spyOn(instance, "switchSearchTimer");
            wrapper.unmount();
            expect(switchSearchTimerSpy).toBeCalledWith(false);
            expect(instance.searchTimeout).toBeNull();
        })

        it("should move around results with the arrow buttons, and display should be synchonized", ()=>{
            const props = {...defaultProps, onSearchResultIterate: jest.fn(), searchTotalResults: 3}
            const onSearchResultIterate:any = jest.spyOn(props, "onSearchResultIterate")
                .mockImplementation((direction:string)=>{
                    if(direction === "prev"){
                        if(instance.currentIndex === 0 ){
                            return (wrapper.props() as any)['searchTotalResults']-1;
                        }else{
                            return instance.currentIndex-1;
                        }
                    }else{
                        if(instance.currentIndex === (wrapper.props() as any)['searchTotalResults']-1){
                            return 0;
                        }else{
                            return instance.currentIndex+1;
                        }
                    }
                })
            const [wrapper, instance] = mount(props);
            const prev = wrapper.find(Link).at(1);
            prev.simulate('click');
            expect(onSearchResultIterate).toBeCalledWith('prev');
            const next = wrapper.find(Link).at(0);
            next.simulate('click');
            expect(onSearchResultIterate).toBeCalledWith('next');
            expect(instance.currentIndex).toBe(0);
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("1 of 3");
            next.simulate('click');
            next.simulate('click');
            expect(instance.currentIndex).toBe(2);
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("3 of 3");
            next.simulate('click');
            expect(instance.currentIndex).toBe(0)
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("1 of 3");
            prev.simulate('click')
            expect(instance.currentIndex).toBe(2);
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("3 of 3");
            prev.simulate('click');
            prev.simulate('click');
            expect(instance.currentIndex).toBe(0);
            expect(wrapper.find(".s_sitemap_search_records").text()).toBe("1 of 3");
        });

        it("should have prev & next buttons disabled when there is no results", ()=>{
            const props = {...defaultProps, searchTotalResults: 0};
            const [wrapper, ] = mount(props);
            const next = wrapper.find(Link).at(0);
            expect(next).toBeDisabled();
            const prev = wrapper.find(Link).at(1);
            expect(prev).toBeDisabled();
        });

        it("should have three children buttons (prev, next and close)", ()=>{
            const props = {...defaultProps, searchTotalResults: 3};
            const [wrapper, ] = mount(props);
            const next = wrapper.find(Link).at(0);
            expect(next).not.toBeDisabled();
            expect(next.props()['icon']).toBe('dir_down');
            const prev = wrapper.find(Link).at(1);
            expect(prev).not.toBeDisabled();
            expect(prev.props()['icon']).toBe('dir_up');
            const close = wrapper.find(Link).at(2);
        });

        it("should clear value when user clicks close icon", ()=>{
            const [wrapper, instance] = mount(defaultProps);
            const clearSpy:any = jest.spyOn(instance, "clear");
            const close = wrapper.find(Link).at(2);
            close.simulate('click');
            expect(clearSpy).not.toBeCalled();
            expect(close.props()['icon']).toBe('magnifying_glass');
            instance.value = "abcde";
            wrapper.update();
            expect(close.props()['icon']).toBe('close');
            close.simulate('click');
            expect(clearSpy).toBeCalled();
            expect(instance.value).toBe('');
            expect(instance.currentIndex).toBe(0);
        });

    });

});