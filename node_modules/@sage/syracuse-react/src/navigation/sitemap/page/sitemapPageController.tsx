"use strict";
import * as React from 'react';
import * as Dom from '../../../utility/html/dom';
import SitemapPage from './sitemapPage';
import { SitemapModule, SitemapSubmodule } from '../groups';
import { SitemapMenu, SitemapBlock, ISitemapItem } from '../items';
import * as BookmarkController from '../../bookmark/bookmarkController';
import { Profile } from '../../../profile/profile';
import * as Storage from '../../../utility/storage/storage';
import { syra_menus } from '../../../syra/utility/syra_menus';
import { ISitemapSearchResult, ISitemapSearch } from './props';

export interface IModulePositions {
    module: SitemapModule,
    offsetTop: number
}

export interface IProps {
    profile: Profile,
    onMounted?: () => void
}



export class SitemapPageController extends React.Component<IProps, {}>{
    timeout: number;
    page: SitemapPage;
    modulesBody: HTMLElement;
    modulePositions: IModulePositions[];
    _selectedModule: SitemapModule;
    search: ISitemapSearch;
    searchResults: ISitemapSearchResult[];


    constructor(props: IProps, context: any) {
        super(props, context);
        for (let mod of this.props.profile.sitemap.modules) {
            for (let submodule of mod.submodules) {
                this.walkItems(submodule.children);
            }
        }
        this.clearSearchResults();
    }

    componentDidMount() {
        let selectedId = Storage.local.get("sitemap_selectedModule");
        let selectedMod: SitemapModule;
        for (let mod of this.props.profile.sitemap.modules) {
            if (mod.$uuid == selectedId) {
                selectedMod = mod;
                break;
            }
        }
        this.selectModule(selectedMod || this.props.profile.sitemap.modules[0], true);
        this.calculatePosition();
        this.props.onMounted && this.props.onMounted();
    }
    walkItems(items: ISitemapItem[]) {
        for (let item of items) {
            if (item.variantKey == "menuBlock") {
                this.walkItems((item as SitemapBlock).children);
            }
            else {
                this.matchMenuBookmark(item as SitemapMenu);
            }
        }
    }
    matchMenuBookmark(menu: SitemapMenu) {
        menu.bookmarked = !!this.props.profile.bookmarks.matchBookmark(menu.url);
    }
    onSwitchBookmark = (menu: SitemapMenu) => {
        BookmarkController.toggleMenu(this.props.profile, menu.url, menu.title, menu.description, () => {
            this.matchMenuBookmark(menu);
            this.setState({});
        });
    }
    componentDidUpdate() {
        this.calculatePosition();
        (this.searchResults.length > 0) && this.hightlightCurrentSearchResult(true);
    }
    calculatePosition() {
        let modules = this.props.profile.sitemap.modules;
        if (modules) {
            this.modulePositions = [];
            this.modulesBody = document.getElementById("s_sitemap_modules");
            if (this.modulesBody) {
                let offsetTop = this.modulesBody.offsetTop;
                for (let module of modules) {
                    let elementTop = document.getElementById(module.$uuid).offsetTop;
                    this.modulePositions.push({
                        module: module,
                        offsetTop: elementTop - offsetTop - 5
                    })
                }
            }
        }
    }
    searchPosition(x: number, low: number, high: number): SitemapModule {
        //This search method is a binary search
        if (high <= low)
            return this.modulePositions[(x >= this.modulePositions[low].offsetTop) ? low : low - 1].module;
        let mid = Math.round((low + high) / 2);

        if (x == this.modulePositions[mid].offsetTop)
            return this.modulePositions[mid].module;

        if (x > this.modulePositions[mid].offsetTop)
            return this.searchPosition(x, mid + 1, high);
        return this.searchPosition(x, low, mid - 1);
    }

    onModuleBodyScroll = () => {
        if (this.modulesBody) {
            clearTimeout(this.timeout);
            let mod = this.searchPosition(this.modulesBody.scrollTop, 0, this.modulePositions.length - 1);
            if (mod != this.selectedModule) {
                this.selectModule(mod);
            }
        }
    }
    componentWillUnmount() {
        clearTimeout(this.timeout);
        this.modulePositions = this.modulesBody = null;
        this._selectedModule = null;
        this.search = null;
        this.searchResults = null;

    }
    get selectedModule(): SitemapModule {
        return this._selectedModule;
    }
    onSelectModule = (mod: SitemapModule) => {
        this.selectModule(mod, true);
    }
    selectModule(mod: SitemapModule, scrollTo?: boolean) {
        Storage.local.set("sitemap_selectedModule", mod.$uuid);
        mod.selected = true;
        if (this._selectedModule) {
            this._selectedModule.selected = false;
        }
        this._selectedModule = mod;
        this.page && this.page.refreshBar();
        if (scrollTo) {
            clearTimeout(this.timeout);
            this.timeout = window.setTimeout(() => Dom.scrollTo(this.selectedModule.$uuid, "v"), 100);
        }
    }
    onMenuClick = (menu: SitemapMenu, event: MouseEvent) => {
        if (!menu.$disabled) {
            //temp syra
            let temp = menu.url; //enure tempSyraMenu
            syra_menus.click.fire({
                menu: menu,
                event: event
            }, event);
        }
    }
    onModuleCollapse = (module: SitemapModule) => {
        module.collapsed = !module.collapsed;
        this.setState({});
    }
    onSubModuleCollapse = (submodule: SitemapSubmodule) => {
        submodule.collapsed = !submodule.collapsed;
        this.setState({});
    }
    onMenuBlockCollapse = (menuBlock: SitemapBlock) => {
        menuBlock.collapsed = !menuBlock.collapsed;
        this.setState({});
    }
    collapseMenuBlock(menuBlock: SitemapBlock, collapse: boolean, propagate: boolean) {
        menuBlock.collapsed = collapse;
        for (let item of menuBlock.children) {
            if (item.variantKey == "menuBlock") {
                this.collapseMenuBlock(item as SitemapBlock, collapse, true);
            }
        }
    }
    onCollapseAllModules = (collapse: boolean) => {
        for (let mod of this.props.profile.sitemap.modules) {
            mod.collapsed = collapse;
            for (let submod of mod.submodules) {
                submod.collapsed = collapse;
                for (let item of submod.children) {
                    if (item.variantKey == "menuBlock") {
                        this.collapseMenuBlock(item as SitemapBlock, collapse, true);
                    }
                }
            }
        }
        this.setState({});
    }

    traverseModules(sitemapObject: any, objType: string) {
        for (let obj of sitemapObject) {
            //This regexp will find all occurences of string in the title
            let matches = obj.title.match(this.search.searchRegex);
            if (matches && matches.length > 0) {

                for (let i in matches) {
                    //we need to push two of each for the modules type
                    //as the module titles are rendered in the module bar
                    //and the main content slot 
                    objType === 'modules' && this.searchResults.push({
                        uuid: obj.$uuid + "_bar",
                        occurence: parseInt(i) + 1
                    });

                    this.searchResults.push({
                        uuid: obj.$uuid,
                        occurence: parseInt(i) + 1
                    });
                }
                this.expandParentsUpTree(obj);
            }

            obj.submodules && this.traverseModules(obj.submodules, 'submodules');
            obj.children && this.traverseModules(obj.children, 'children')
        }
    }
    expandParentsUpTree(obj: any) {
        if (obj.navParent) {
            let navParent = obj.navParent;
            navParent.collapsed && (navParent.collapsed = false);
            this.expandParentsUpTree(navParent);
        }
    }



    clearSearchResults(text?: string) {
        let searchExpr = text ? text : "";
        searchExpr = searchExpr.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        this.searchResults = [];
        this.search = {
            searchFilter: searchExpr,
            searchRegex: new RegExp(searchExpr, "gi"),
            searchCurrentItem: null,
            searchCurrentIndex: 0,
            searchTotalResults: 0
        }
    }

    onSearch = (text: string) => {
        this.clearSearchResults(text);
        this.traverseModules(this.props.profile.sitemap.modules, 'modules');
        if (this.searchResults.length > 0) {
            this.search.searchCurrentIndex = 0;
            this.search.searchCurrentItem = this.searchResults[this.search.searchCurrentIndex];
            this.search.searchTotalResults = this.searchResults.length;
            Dom.scrollTo(this.search.searchCurrentItem.uuid, "v");
        }
        this.setState({});
    }

    onClearSearch = () => {
        this.clearSearchResults();
        this.setState({});
    }


    hightlightCurrentSearchResult(isFocused: boolean) {
        let node = this.searchResults[this.search.searchCurrentIndex];
        let resultElement = document.getElementById(node.uuid);
        if (resultElement) {
            let nodes = resultElement.getElementsByTagName("span");
            for (let ii = 0, k = 1; ii < nodes.length; ii++) {
                let child = nodes[ii];
                if (k == node.occurence) {
                    child.className = isFocused ? (child.className + " s_link_highlight_text_focus") : (child.className.replace("s_link_highlight_text_focus", ""));
                    break;
                }
                k++;
            }

        }
    }

    onSearchResultIterate = (direction: string): number => {
        if (this.searchResults.length > 0) {
            this.hightlightCurrentSearchResult(false);
            if (direction === 'next') {
                if (++this.search.searchCurrentIndex >= this.searchResults.length)
                    this.search.searchCurrentIndex = 0; //loop to first element
            } else {
                if (--this.search.searchCurrentIndex < 0)
                    this.search.searchCurrentIndex = this.searchResults.length - 1; //loop to last element
            }
            this.search.searchCurrentItem = this.searchResults[this.search.searchCurrentIndex];
            Dom.scrollTo(this.search.searchCurrentItem.uuid, "v");
            this.hightlightCurrentSearchResult(true);
        }
        return this.search.searchCurrentIndex;
    }

    render() {
        return <SitemapPage
            ref={(page) => this.page = page}
            userFirstName={this.props.profile.greeting}
            onMenuClick={this.onMenuClick}
            modules={this.props.profile.sitemap.modules}
            onCollapseAllModules={this.onCollapseAllModules}
            onSelectModule={this.onSelectModule}
            onModuleBodyScroll={this.onModuleBodyScroll}
            onModuleCollapse={this.onModuleCollapse}
            onSubModuleCollapse={this.onSubModuleCollapse}
            onMenuBlockCollapse={this.onMenuBlockCollapse}
            onSwitchBookmark={this.onSwitchBookmark}
            onSearch={this.onSearch}
            onSearchResultIterate={this.onSearchResultIterate}
            onClearSearch={this.onClearSearch}
            searchResult={this.search}
        />;
    }
}