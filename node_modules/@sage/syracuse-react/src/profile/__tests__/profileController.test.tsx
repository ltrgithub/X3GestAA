import TestHelper from '../../__tests__/testHelper';
import * as React from 'react';
import * as Enzyme from 'enzyme';
import * as Actions from './../actions';
import * as BookmarkController from '../../navigation/bookmark/bookmarkController';
import * as transitionHelper from '../../utility/html/transitionHelper';
import * as overHelper from '../../over/overHelper';
import { route } from '../../route/route';
import { site } from './../../utility/html/dom';
import { IEndpoint } from './../endpoint';
import { ProfileController, IProps } from '../profileController';
import { Profile, IRole } from '../../profile/profile';
import { OfficeController } from '../../office/officeController';

describe('ProfileController', () => {
    let profile: Profile;
    let component: Enzyme.ReactWrapper<IProps, any>;
    let props: IProps;
    let actionsGetProfileMock: jest.Mock<() => Promise<Profile>>;
    let actionsLoadLocalStringsMock: jest.Mock<() => Promise<any>>;
    let actionsGetSitemapMock: jest.Mock<(profile: Profile) => void>;
    let bookmarkControllerFetchMock: any;
    let actionsLoadDefaultLocalStringsMock: jest.Mock<() => void>;
    let overHelperPositionMock: jest.Mock<(node: HTMLElement, options: overHelper.IPosition) => void>;

    beforeEach(() => {
        profile = TestHelper.fixtures.getProfilePopulated();
        props = {
            profile,
            searchFacet: false,
            office: null,
            classicMode: false,
            bookmarkDisabled: false,
            onLogout: jest.fn(),
            onReady: jest.fn(),
            mainPageBookmark: null,
            onSwitchApplicationMode: jest.fn(),
            onBookmarked: jest.fn(),
            onBookmarkClick: jest.fn(),
        };

        actionsLoadDefaultLocalStringsMock = jest.spyOn(Actions, 'loadDefaultLocalStrings').mockImplementation(jest.fn());
        actionsGetProfileMock = jest.spyOn(Actions, 'getProfile').mockImplementation(TestHelper.returnPromise<Profile>(profile));
        actionsGetSitemapMock = jest.spyOn(Actions, 'getSitemap').mockImplementation(TestHelper.returnPromise<Profile>(profile));
        actionsLoadLocalStringsMock = jest.spyOn(Actions, 'loadLocalStrings').mockImplementation(TestHelper.returnPromise<any>(true));
        bookmarkControllerFetchMock = jest.spyOn(BookmarkController, 'fetch').mockImplementation(TestHelper.returnPromise<void>(null));
        overHelperPositionMock = jest.spyOn(overHelper, 'position').mockImplementation(jest.fn());

        TestHelper.cleanPopups();

    });

    afterEach(() => {
        actionsLoadDefaultLocalStringsMock.mockClear();
        actionsGetProfileMock.mockClear();
        actionsLoadLocalStringsMock.mockClear();
        bookmarkControllerFetchMock.mockClear();
        actionsGetSitemapMock.mockClear();
        overHelperPositionMock.mockClear();
    });

    describe('Snapshots', () => {

        it('should compare to snapshot in default mode', () => {
            let component = Enzyme.render(<ProfileController {...props} />);
            expect(component).toMatchSnapshot();
        });

        it('should compare to snapshot in office mode', () => {
            props.office = new OfficeController('msoffice/lib/word');
            let component = Enzyme.render(<ProfileController {...props} />);
            expect(component).toMatchSnapshot();
        });

        it('should compare to an empty snapshot if not profile object provided', () => {
            props.profile = null;
            let component = Enzyme.render(<ProfileController {...props} />);
            expect(component).toMatchSnapshot();
        });
    });

    describe('Interactions', () => {
        let component: Enzyme.ReactWrapper<IProps, any>;

        beforeEach(() => {
            component = Enzyme.mount(<ProfileController {...props} />);
            component.instance().forceUpdate();
            jest.useFakeTimers();
        });

        afterEach(() => {
            jest.useRealTimers();
        });

        describe('Sitemap', () => {

            it('should open the sitemap on the compass icon click', () => {
                const compassSitemapButton = component.find('.s_profile_bar_iconlink_sitemap a');
                const sitemapContainer = document.querySelector('.s_sitemap_popup_root');
                const sitemap = document.querySelector('.s_sitemap_page');
                expect(sitemapContainer.classList.contains('s_sitemap_popup_root_hidden')).toBe(true);
                expect(sitemap.classList.contains('s_sitemap_page_moving_in')).toBe(false);
                compassSitemapButton.simulate('click');
                jest.runAllImmediates();
                expect(sitemapContainer.classList.contains('s_sitemap_popup_root_hidden')).toBe(false);
                expect(sitemap.classList.contains('s_sitemap_page_moving_in')).toBe(true);
            });

        });

        describe('Select Endpoint', () => {
            let actionsGetEndpointsMock: jest.Mock<(profile: Profile) => Promise<IEndpoint[]>>;
            let actionsChangeEndpointMock: jest.Mock<(profile: Profile, endpoint: IEndpoint) => Promise<void>>;
            let routeGoToHomeMock: jest.Mock<(replace?: boolean) => void>;

            beforeEach(() => {
                actionsGetEndpointsMock = jest.spyOn(Actions, 'getEndpoints').mockImplementation(TestHelper.returnPromise<IEndpoint[]>(profile.endpoints));
                actionsChangeEndpointMock = jest.spyOn(Actions, 'changeEndpoint').mockImplementation(TestHelper.returnPromise<void>(null));
                routeGoToHomeMock = jest.spyOn(route, 'gotoHome').mockImplementation(() => { });
            });

            afterEach(() => {
                actionsGetEndpointsMock.mockClear();
                actionsChangeEndpointMock.mockClear();
                routeGoToHomeMock.mockClear();
            });

            it('should open the select endpoint menu on click', () => {
                expect(document.querySelector('.s_popup')).toBeNull();
                component.find('.s_profile_bar_textlink_endpoint').simulate('click');
                expect(document.querySelector('.s_popup')).not.toBeNull();
                component.find('.s_profile_bar_textlink_endpoint').simulate('click');
                expect(document.querySelector('.s_popup')).toBeNull();
            });

            it('should call the actions to change the endpoint on selection a new endpoint', () => {
                component.find('.s_profile_bar_textlink_endpoint').simulate('click');
                let menuItems: NodeListOf<Element> = document.querySelectorAll('.s_popup .s_profile_bar_list_item');
                expect(menuItems.length).toBe(3);
                expect(actionsChangeEndpointMock).not.toBeCalled();

                TestHelper.simulate.click(menuItems.item(0));

                expect(actionsChangeEndpointMock).toHaveBeenCalledTimes(1);
                expect(actionsChangeEndpointMock).toBeCalledWith(profile, profile.endpoints[0]);
            });

            it('should call the actions to change the endpoint on selection a new endpoint', () => {
                component.find('.s_profile_bar_textlink_endpoint').simulate('click');
                let menuItems: NodeListOf<Element> = document.querySelectorAll('.s_popup .s_profile_bar_list_item');
                expect(menuItems.length).toBe(3);
                expect(actionsChangeEndpointMock).not.toBeCalled();

                TestHelper.simulate.click(menuItems.item(0));

                expect(actionsChangeEndpointMock).toHaveBeenCalledTimes(1);
                expect(actionsChangeEndpointMock).toBeCalledWith(profile, profile.endpoints[0]);
            });
        });

        describe('Select Roles', () => {
            let actionsGetRolesMock: jest.Mock<(profile: Profile) => Promise<IRole[]>>;
            let actionsChangeRolesMock: jest.Mock<(profile: Profile, role: IRole) => Promise<void>>;
            let routeRenderCurrentUrlMock: jest.Mock<(replace?: boolean) => void>;

            beforeEach(() => {
                actionsGetRolesMock = jest.spyOn(Actions, 'getRoles').mockImplementation(TestHelper.returnPromise<IRole[]>(profile.roles));
                actionsChangeRolesMock = jest.spyOn(Actions, 'changeRole').mockImplementation(TestHelper.returnPromise<void>(null));
                routeRenderCurrentUrlMock = jest.spyOn(route, 'renderCurrentUrl').mockImplementation(jest.fn());
            });

            afterEach(() => {
                actionsGetRolesMock.mockClear();
                actionsChangeRolesMock.mockClear();
                routeRenderCurrentUrlMock.mockClear();
            });

            it('should open the select roles menu on click', () => {
                expect(document.querySelector('.s_popup')).toBeNull();
                component.find('.s_profile_bar_textlink_role').simulate('click');
                expect(document.querySelector('.s_popup')).not.toBeNull();
                component.find('.s_profile_bar_textlink_role').simulate('click');
                expect(document.querySelector('.s_popup')).toBeNull();
            });

            it('should call the actions to change the role on selection a new role', () => {
                component.find('.s_profile_bar_textlink_role').simulate('click');
                let menuItems: NodeListOf<Element> = document.querySelectorAll('.s_popup .s_profile_bar_list_item');
                expect(menuItems.length).toBe(3);
                expect(actionsChangeRolesMock).not.toBeCalled();

                TestHelper.simulate.click(menuItems.item(0));

                expect(actionsChangeRolesMock).toHaveBeenCalledTimes(1);
                expect(actionsChangeRolesMock).toBeCalledWith(profile, profile.roles[0]);
            });
        });

        describe('Select Locale', () => {

        });

        describe('Select Theme', () => {

        });
    });
});

