import * as React from 'react';
import { shallow, mount, render } from 'enzyme';
import { renderToJson } from 'enzyme-to-json';
import { IFieldProps } from '../../field';
import { ChoiceField, ChoiceRadios } from '../choiceField';
import { Radio, IProps } from '../radio';
//import { spy } from 'sinon';
import { jsdom } from 'jsdom';
import * as Sdata from '../../../../dataStore/sdata';

var document: Document = jsdom("<html></html>");

describe('Test Suite for choiceField', () => {

    let props: IFieldProps;
    const c: Sdata.IChoiceEnumItem[] = [{ $value: 1, $title: 'one' }, { $value: 2, $title: 'two' }]

    it('<ChoiceField /> hidden renders correctly', () => {
        props = { hidden: true, value: 'the value' };
        const wrapper = shallow(<ChoiceField {...props} />);
        expect(wrapper.contains(<noscript />)).toEqual(true);
    });

    it('<ChoiceRadios /> calls shouldComponentUpdate once', (t) => {
        setTimeout(t, 250);
        const spy = jest.fn();
        const s = spy(ChoiceRadios.prototype, 'shouldComponentUpdate');
        props = { editable: true, value: 'the value' };
        const wrapper = mount(<ChoiceRadios {...props} choices={c} />);
        expect(s.callCount).toEqual(0);
        wrapper.setState({ $value: 2 });
        expect(s.callCount).toEqual(1);
    });

    let props2: IProps;
    it('<Radio /> calls onChange once', (t) => {
        setTimeout(t, 250);
        const onChange = jest.fn();
        props2 = {
            id: 'radio_1',
            value: 'this value',
            title: 'this tile',
            checked: false,
            disabled: false,
            readOnly: false,
            onChange: onChange
        }
        const wrapper = shallow(<Radio {...props2} />);
        expect(wrapper).toHaveLength(1);
        const radio = wrapper.find('.s_choice_rd_input');
        radio.simulate('change');
        expect(onChange.mock.calls).toBeTruthy();
    });

    //sinon-----------------------

    // it('<ChoiceRadios /> calls shouldComponentUpdate once', (t) => {
    //     setTimeout(t, 250);
    //     const s = spy(ChoiceRadios.prototype, 'shouldComponentUpdate');
    //     props = { editable: true, value: 'the value' };
    //     const wrapper = mount(<ChoiceRadios {...props} choices={c} />);
    //     expect(s.callCount).toEqual(0);
    //     wrapper.setState({ $value: 2 });
    //     expect(s.callCount).toEqual(1);
    // });

    // let props2: IProps;
    // it('<Radio /> calls onChange once', (t) => {
    //     setTimeout(t, 250);
    //     const onChange = spy();
    //     props2 = {
    //         id: 'radio_1',
    //         value: 'this value',
    //         title: 'this tile',
    //         checked: false,
    //         disabled: false,
    //         readOnly: false,
    //         onChange: onChange
    //     }
    //     const wrapper = shallow(<Radio {...props2} />);
    //     expect(wrapper).toHaveLength(1);
    //     const radio = wrapper.find('.s_choice_rd_input');
    //     radio.simulate('change');
    //     expect(onChange.called).toBeTruthy();
    // });

    //sinon-------------------------------------

    it('<ChoiceRadios /> compare to snapshot', () => {
        props = { editable: true, value: 'the value' };
        const wrapper = render(<ChoiceRadios {...props} choices={c} />);
        const json = renderToJson(wrapper);
        expect(json).toMatchSnapshot();
    });

});