"use strict";
import * as Sdata from '../dataStore/sdata';
import { Url } from '../route/url';
import { syra_fusion } from '../syra/utility/syra_fusion';
import * as UUID from '../utility/uuid';
import { Response } from './ajaxResponse';
import { lock, unlock } from '../over/lock/lockController';

const jsurl = require("jsurl");

export class AjaxResponse extends Response { };

export interface IAjaxObserver {
	onAjaxSend: (ajax: Ajax) => boolean,
	onAjaxResponse: (response: AjaxResponse) => boolean
}

export class AjaxObserver {
	handlers: IAjaxObserver[] = [];
	onSend(ajax: Ajax): boolean {
		let ok = true;
		for (let handler of this.handlers) {
			if (handler.onAjaxSend(ajax) === false) {
				ok = false;
			}
		}
		return ok;
	}
	onResponse(response: AjaxResponse) {
		let ok = true;
		for (let handler of this.handlers) {
			if (handler.onAjaxResponse(response) === false) {
				ok = false;
			}
		}
		return ok;
	}
	subscribe(handler: IAjaxObserver) {
		if (this.handlers.indexOf(handler) < 0) {
			this.handlers.push(handler);
		}
	}
	unsubscribe(handler: IAjaxObserver) {
		let index = this.handlers.indexOf(handler);
		(index >= 0) && this.handlers.splice(index, 1);
	}
}

let watcher: IAjaxObserver;

export function bindAjaxWatcher(observer: IAjaxObserver) {
	watcher = observer;
}

let _retryOnError: number = 3;

export interface IAjaxProps {
	url: string;
	method?: Sdata.HttpMethodType,
	headers?: any,
	data?: any,
	$etag?: number,
	accept?: string,
	contentType?: string,
	jsonParams?: any,
	params?: any,
	syncRqst?: any,
	ajaxQuery?: any,
	isAborted?: boolean,
	page?: any,
	lock?: boolean,
	end?(response: AjaxResponse): void
};

export const ajaxObserver = new AjaxObserver();

export class Ajax {
	dataType: string;
	method: string;
	headers: any;
	url: string;
	urlSeg: Url;
	sendData: any;
	props: IAjaxProps;
	private tryCount: number
	private jquerySettings: JQueryAjaxSettings;
	private ended: boolean;
	static setup(languageCode: string, retryOnError?: number) {
		_retryOnError = retryOnError || _retryOnError;
		$.ajaxSetup({
			headers: {
				"Accept-Language": languageCode
			}
		});
	}

	private applyParameters(params: any) {
		let paramObj: any = {};
		let paramsStart = this.url.lastIndexOf("?");
		if (paramsStart >= 0) {
			let parts = this.url.slice(paramsStart + 1).split("&");
			for (let part of parts) {
				let valueStart = part.indexOf("=");
				paramObj[part.substring(0, valueStart)] = part.substring(valueStart + 1);
			}
			this.url = this.url.substring(0, paramsStart);
		}
		for (let key in params) {
			if (params[key] === null) {
				delete paramObj[key];
			} else {
				if (params[key] !== undefined) {
					paramObj[key] = encodeURIComponent(params[key]);
				}
			}
		}
		let paramString = "";
		for (let key in paramObj) {
			paramString += "&" + key + "=" + paramObj[key];
		}
		this.url += "?" + paramString.slice(1);
	}

	private onSuccess = (data: any, textStatus: any, jqXHR: JQueryXHR) => {
		this.ended = true;
		this.props.lock && unlock();
		let response = new AjaxResponse(this, jqXHR, data, true);
		watcher && watcher.onAjaxResponse(response);
		if (ajaxObserver.onResponse(response)) {
			!response.aborted && this.props.end && this.props.end(response);
		}
		response.dispose();
		response = null;
		// timer to handle convergence session disconnection in case of timeout
		syra_fusion && syra_fusion.updateRequestTimer();

	}
	private onErorr = (jqXHR: JQueryXHR, textStatus: any, errorThrown: any) => {
		this.ended = true;
		this.props.lock && unlock();
		let response = new AjaxResponse(this, jqXHR, null, false, errorThrown);
		watcher && watcher.onAjaxResponse(response);
		if (ajaxObserver.onResponse(response)) {
			switch (jqXHR.status) {	
				// retry error
				case 408: //timeout
				case 502: //proxy error
				case 503: // service unvailable
				case 504: //timeout
				case 12152: //invalid response
				case 12001: // out of handle
				case 12156:
					if (this.tryCount--) {
						response.dispose();
						this._send();
						return;
					}
					break;
			}
			!response.aborted && this.props.end && this.props.end(response);
		}
		response.dispose();
	}
	private _send() {
		this.url = Url.ensureProxy(this.url);
		this.props.lock && lock();
		if (ajaxObserver.onSend(this)) {
			watcher && watcher.onAjaxSend(this);
			//setTimeout(() => {
			this.props.ajaxQuery = $.ajax(this.jquerySettings = {
				url: this.url, // add retryid for post request
				type: this.method,
				dataType: this.dataType,
				data: this.sendData,
				contentType: this.headers["content-type"],
				async: this.props.syncRqst ? false : true,
				beforeSend: (jqXHR: JQueryXHR, settings: any) => {
					if (this.headers) {
						for (let key in this.headers) {
							jqXHR.setRequestHeader(key, this.headers[key]);
						}
					}
				},
				complete: () => {
					delete this.props.ajaxQuery;
				},
				success: this.onSuccess,
				error: this.onErorr
			});
			//}, this.method == "PUT" ? 2000 : 1);
		}
	}

	send(props: IAjaxProps) {
		this.method = props.method = props.method || "GET";
		this.props = props;
		props.url = props.url || "";
		this.urlSeg = new Url(this.url = props.url);
		this.headers = this.headers || {};
		if (props.headers) {
			for (let prop in props.headers) {
				this.headers[prop] = props.headers[prop];
			}
		}
		if (this.method == "POST" || this.method == "PUT") {
			props.params = props.params || {};
			if (!props.params.trackingId) {
				props.params.trackingId = UUID.generate();
			}
		}

		this.headers.Accept = props.accept || "application/json;vnd.sage=syracuse; charset=utf-8";

		if (props.contentType) {
			this.headers["content-type"] = props.contentType;
		}
		if (!this.dataType) {
			this.dataType = this.headers["Accept"] || this.headers["content-type"] || "text/html";
			this.dataType = (this.dataType.indexOf("application/json") != -1) ? "json" : "text";
		}
		if (!this.headers["content-type"]) {
			this.headers["content-type"] = this.dataType === "json" ? "application/json" : "";
		}

		if (props.data) {
			this.sendData = this.dataType === "json" ? JSON.stringify(props.data) : props.data;
		}
		if (props.jsonParams) {
			props.params = props.params || {};
			for (let key in props.jsonParams) {
				props.params[key] = jsurl.stringify(props.jsonParams[key]);
			}
		}
		if (props.params && this.url) {
			// network breakdown - add for non get query a unique identifier
			this.applyParameters(props.params);
		}
		if (props.$etag) {
			this.headers["If-Match"] = props.$etag;
		}
		if (["GET", "POST", "DELETE", "PUT"].indexOf(this.method) < 0) {
			this.headers["X-HTTP-Method-Override"] = this.method;
			this.method = "POST";
		}

		let retryId = this.method !== "GET" ? UUID.generate("") : null;
		if (retryId && this.url) {
			this.url += (this.url.indexOf('?') !== -1) ? "&retryId=" + retryId : "?retryId=" + retryId;
		}
		if (this.url) {
			this.tryCount = _retryOnError - 1;
			this._send();
		}
	}
	del(props: IAjaxProps) {
		props.method = "DELETE";
		this.send(props);
	}
	get(props: IAjaxProps) {
		props.method = "GET";
		this.send(props);
	}
	post(props: IAjaxProps) {
		props.method = "POST";
		this.send(props);
	}
	put(props: IAjaxProps) {
		props.method = "PUT";
		if (props.data && props.data.$etag) {
			props.$etag = props.data.$etag;
		}
		this.send(props);
	}
	abort() {
		if (!this.ended) {
			this.props && this.props.ajaxQuery && this.props.ajaxQuery.abort();
		}
	}
	dispose() {
		this.abort();
	}
}