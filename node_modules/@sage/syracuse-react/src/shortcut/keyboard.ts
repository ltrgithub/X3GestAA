"use strict";
import { syra_site } from '../syra/utility/syra_site';
import { syra_item } from '../syra/utility/syra_item';
import * as syra_tip from '../over/syra_tip';
import * as SyraModal from '../over/modal/syraModal';
import * as keyMap from './keyMap';
import { KeySequence } from './keySequence';
import * as syra_shortcut from './syra_shortcut';
import { BLACK_HOLE_ID , onLockRecordKeyEvent} from '../over/lock/lockController'

//tester popupMenu

let keySequence = new KeySequence();

function _findItem(target: any) {
    var item;
    if (!item) {
        var topPage = SyraModal.getMostOverPage();
        item = target.syraKeyTarget ? syra_item.get(target.syraKeyTarget) : syra_item.findItem(target);
        if (topPage && item && !item.disposed && (item.page != topPage)) {
            item = null;
        }
        if (!item || item.disposed) {
            item = topPage || syra_site.mainPage;
        }
        if (!item || item.disposed) {
            item = syra_site;
        }
    }
    return item;
}

export class Keyboard {
    constructor() {
        document.addEventListener("keydown", this.keydown, false);
        document.addEventListener("keypress", this.keypress, false);
        document.addEventListener("keyup", this.keyup, false);
    }
    get keyCodeNameMap(): any {
        return keyMap.names;
    }
    get keyCodeMap(): any {
        return keyMap.codes;
    }
    release() {
        keySequence.reset();
    }
    keydown = (event: KeyboardEvent, targetItem?: any, playback?: boolean) => {
        let item = targetItem || _findItem(event.target);
        event = event || (window.event as KeyboardEvent);

        onLockRecordKeyEvent(event, "keydown", playback);
        let keyName = keySequence.onKeydown(event);

        // Quick access first...
        if (syra_shortcut.quick.keydown(keySequence, item, keyName, event)) {
            return this.preventDefault(event);
        }

        while (item) {
            if (syra_shortcut.keydown(item, keySequence, event)) {
                if (keySequence.tab || keySequence.esc) {
                    if (keySequence.map.f1) {
                        keySequence.reset(); // because in this case keyup isn't exec (new browser opened);
                    }
                    return this.preventDefault(event);
                }
                break;
            }
            item = item.articleParent;
        }
        this.neutralizeDuringLock(event);
    }
    keypress = (event: KeyboardEvent, item?: any, playback?: boolean) => {
        event = event || (window.event as KeyboardEvent);
        onLockRecordKeyEvent(event, "keypress", playback, keySequence.esc);
        let charCode;
        if (event.which == null) {
            charCode = String.fromCharCode(event.keyCode); // old IE
        } else {
            if (event.which != 0 && event.charCode != 0) {
                charCode = String.fromCharCode(event.which);
            }
            if (keySequence.esc) {
                var funcKey = charCode || event.keyCode;
                if (funcKey && funcKey >= 112 && funcKey <= 123) {
                    return false;
                }
            }
        }
        if (charCode !== undefined && !keySequence.esc) {
            item = item || _findItem(event.target);
            if (item.validateKeyPress && !item.validateKeyPress(charCode, event, keySequence.map)) {
                return this.preventDefault(event);
            }
            syra_tip.fieldTip.onKeyPress(item, event, charCode);
        }
        this.neutralizeDuringLock(event);
    }

    keyup = (event: KeyboardEvent, item?: any, playback?: boolean) => {
        event = event || (window.event as KeyboardEvent);
        onLockRecordKeyEvent(event, "keyup", playback);
        if (keySequence) {
            item = item || _findItem(event.target);
            if (event.keyCode == keyMap.names.esc) {
                !keySequence.isEnabled && syra_shortcut.applyEscape(item, keySequence, event);
                keySequence.reset();
            } else {
                keySequence.onKeyup(event);
                if (!keySequence.esc && item.isField) {
                    syra_tip.fieldTip.onKeyUp(item, event);
                    if (item.onKeyUp) {
                        item.onKeyUp(event);
                    } else {
                        if (item.page.isFusionPage && item.onFieldInputEvent) {
                            item.onFieldInputEvent(event);
                            event.stopPropagation();
                            return;
                        }
                    }
                }
            }
        }
        this.neutralizeDuringLock(event);
    }
    private neutralizeDuringLock(event: KeyboardEvent) {
        if ((event.target as any).id == BLACK_HOLE_ID) {
            switch (event.keyCode) {
                case keyMap.names.esc:
                case keyMap.names.backspace:
                case keyMap.names.tab:
                    this.preventDefault(event);
                    break;
            }
        }
    }
   
    preventDefault(event: KeyboardEvent) {
        event.returnValue = false;
        event.preventDefault();
        event.stopPropagation();
        return false;
    }
    dispose() {
        document.removeEventListener("keydown", this.keydown);
        document.removeEventListener("keypress", this.keydown);
        document.removeEventListener("keyup", this.keyup);
    }
}