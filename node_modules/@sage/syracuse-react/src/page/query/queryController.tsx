"use strict";
import * as React from 'react';
import { Url } from '../../route/url';
import { IPageLoadError } from '../pageLoader';
import { AlertPage } from '../../alert/page/alertPage';
import { IPageProps } from '../page';
import { SyraPage, ISyraPageState } from '../syraPage';
import * as Sdata from '../../dataStore/sdata';
import { SyraMainPage } from '../syraMainPage'
import * as Storage from '../../utility/storage/storage';
import { syra_form } from '../../syra/utility/syra_form';
import { route } from '../../route/route';

export class QueryController extends React.Component<IPageProps, ISyraPageState> {
    static complete(syraMenu: any) {
        let url = new Url(syraMenu.$url);
        let params: any = Storage.session.getJson(url.uri);
        if (params) {
            if (!url.params) {
                url.params = {};
            }
            let changed;
            for (let key in params) {
                if (url.params[key] == undefined) {
                    changed = true;
                    url.params[key] = params[key];
                    if (syraMenu.$sourceUrl) {
                        syraMenu.$sourceUrl += "&" + key + "=" + encodeURIComponent(params[key]);
                    }
                }
            }
            if (changed) {
                syraMenu.$url = url.stringify();
            }
        }
    }
    syraPage: SyraPage;
    componentDidMount() {
        if (this.props.onMainPageLoaded) {
            this.props.sdataUrl.ensureHost();
            Storage.session.setJson(this.props.sdataUrl.uri, null);
        }
        this.syraPage = new SyraPage();
        this.syraPage.fetchRepresentation(this.props.sdataUrl, (error) => {
            if (error) {
                this.notifyLoadError(error);
            }
            else {
                this.syraPage.fetchData((diagnoses: Sdata.IDiagnose[]) => {
                    if (diagnoses) {
                        this.notifyLoadError({
                            diagnoses: diagnoses
                        });
                    }
                    else {
                        this.syraPage.loadSyraPage(() => this.forceUpdate());
                    }
                });
            }
        });
    }
    notifyLoadError(error: IPageLoadError) {
        this.setState({
            loadError: error
        });
    }
    onViewMount = (body: HTMLElement) => {
        this.syraPage.slotDidMount(body);
        if (this.props.onMainPageLoaded) {
            this.syraPage.addHistoryLinks();
            syra_form.showLastSavingDiagnoses(this.syraPage.page);
            this.props.onMainPageLoaded(this.syraPage.title, this.syraPage.description, this.syraPage.page);
        }
    }
    componentWillUnmount() {
        if (this.syraPage) {
            if (this.props.onMainPageLoaded && this.syraPage.page) {
                Storage.session.setJson(this.props.sdataUrl.uri, this.syraPage.page.urlSeg.params);
            }
            this.syraPage.dispose();
        }
    }
    render() {
        if (this.state && this.state.loadError) {
            return <AlertPage {...this.state.loadError} />;
        }
        else {
            if (this.syraPage && this.syraPage.page) {
                return <SyraMainPage onDidMount={this.onViewMount} onResize={this.syraPage.onResize} />;
            }
        }
        return null;
    }
}