"use strict";
import * as React from 'react';
import * as ReactDom from 'react-dom';
import * as Events from '../../event/events';
import './dragger.less';

export interface IDragging {
    startX: number,
    startY: number,
    pageX: number,
    pageY: number,
    deltaX: number,
    deltaY: number
}

class DragController implements IDragging {

    private onStop: () => void;
    private onDrag: () => void
    private body: HTMLElement;
    public pageX: number;
    public pageY: number;
    public startX: number;
    public startY: number;
    public deltaX: number;
    public deltaY: number;
    private timeout: number;

    constructor(private dragger: Dragger) {
        let node = ReactDom.findDOMNode(this.dragger);
        this.body = node.parentNode as HTMLElement;
    }
    start(pageX: number, pageY: number, onStop: () => void) {
        if (this.body) {
            this.onStop = onStop;
            this.pageX = this.startX = pageX;
            this.pageY = this.startY = pageY;
            let rect = this.body.getBoundingClientRect();
            this.subscribeEvents(true);
        }
    }
    subscribeEvents(subscribe: boolean) {
        if (subscribe) {
            this.timeout = window.setTimeout(() => {
                Events.mousemove.subscribe(this.onMousemove);
            });
            Events.mouseup.subscribe(this.onMouseup);
        }
        else {
            Events.mousemove.unsubscribe(this.onMousemove);
            Events.mouseup.unsubscribe(this.onMouseup);
        }
    }
    private onMousemove = (event: MouseEvent) => {
        event.preventDefault();
        this.pageX = event.pageX;
        this.pageY = event.pageY;
        this.deltaX = event.pageX - this.startX;
        this.deltaY = event.pageY - this.startY;
        this.dragger.props && this.dragger.props.onDrag(this);
    }
    private onMouseup = (event: MouseEvent) => {
        this.subscribeEvents(false);
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
            this.dragger.props && this.dragger.props.onDrag(this);
        }
        this.onStop();
        this.dispose();
    }
    dispose() {
        this.timeout && clearTimeout(this.timeout);
        this.subscribeEvents(false);
    }
}


export interface IDraggerProps {
    onStart?: (dragging: IDragging) => void,
    onDrag: (dragging: IDragging) => void,
    onStop?: (dragging: IDragging) => void
}
export class Dragger extends React.Component<IDraggerProps, {
    isDragging: boolean
}>  {

    controller: DragController;

    constructor(props: any, context: any) {
        super(props, context);
        this.state = {
            isDragging: false
        };
    }

    onMouseDown = (event: React.MouseEvent<HTMLDivElement>) => {
        event.preventDefault();

        this.setState({
            isDragging: true
        });
        this.controller = new DragController(this);
        this.controller.start(event.pageX, event.pageY, this.handleStop);
        event.stopPropagation();
        this.props.onStart && this.props.onStart(this.controller);
    }
    handleStop = () => {
        this.props.onStop && this.props.onStop(this.controller);
        this.setState({
            isDragging: false
        });
        document.body.style.cursor = "";
        this.disposeController();
    }

    disposeController() {
        this.controller && this.controller.dispose();
        this.controller = null;
    }

    render() {
        return <div className='s_dragger' onMouseDown={this.onMouseDown}>
            {this.props.children}
        </div>;
    }
}