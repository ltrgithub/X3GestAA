"use strict";
import * as React from 'react';
import * as Dom from '../../../utility/html/dom';
import * as Events from '../../../event/events';

const thumbMargin = 2;

export class ScrollAxe {
	visible: boolean;
	private thumb: HTMLDivElement;
	private track: HTMLDivElement;
	private cssTrack: string;
	private cssThumb: string;
	private listener_mousedown: (ev: MouseEvent) => any;
	private listener_mouseup: (ev: MouseEvent) => any;
	private ratio: number;
	private startPos: number;
	private startScroll: number;
	private content: HTMLElement;
	private verticalDirection: boolean;

	constructor(direction: "x" | "y") {
		this.cssTrack = "s_scrollbar_track_" + direction;
		this.cssThumb = "s_scrollbar_thumb_" + direction;
		this.verticalDirection = direction == "y";

	}
	moveThumb() {
		if (this.verticalDirection) {
			if (this.ratio) {
				this.thumb.style.top = (Math.round(this.ratio * this.content.scrollTop) + thumbMargin) + "px";
			}
		}
		else {
			if (this.ratio) {
				this.thumb.style.left = (Math.round(this.ratio * this.content.scrollLeft) + thumbMargin) + "px";
			}
		}
	}
	private listen_mouseEvents(bind: boolean) {
		if (this.track) {
			if (bind) {
				if (!this.listener_mousedown) {
					this.track.addEventListener("mousedown", this.listener_mousedown = (ev: MouseEvent) => {
						this.startDrag(ev);
					}, false);
				}
				if (!this.listener_mouseup) {
					this.content.ownerDocument.addEventListener("mouseup", this.listener_mouseup = (ev: MouseEvent) => {
						this.endDrag();
					}, false);
				}
			} else {
				this.listener_mousedown && this.track.removeEventListener("mousedown", this.listener_mousedown);
				this.listener_mouseup && this.content.ownerDocument.removeEventListener("mouseup", this.listener_mouseup);
				delete this.listener_mousedown;
				delete this.listener_mouseup;
			}
		}

	}

	resize(content: HTMLElement) {
		this.content = content;
		this.visible = false;
		if (this.verticalDirection) {
			if (this.content.clientHeight != this.content.scrollHeight) {
				this.track.style.height = this.content.clientHeight + "px";
				this.ratio = this.content.clientHeight / this.content.scrollHeight;
				this.moveThumb();
				this.thumb.style.height = (Math.floor(this.ratio * (this.content.clientHeight - thumbMargin)) - thumbMargin) + "px";
				this.visible = true;
			}
		}
		else {
			if (this.content.clientWidth != this.content.scrollWidth) {
				this.track.style.width = this.content.clientWidth + "px";
				this.ratio = this.content.clientWidth / this.content.scrollWidth;
				this.moveThumb();
				this.thumb.style.width = (Math.floor(this.ratio * (this.content.clientWidth - thumbMargin)) - thumbMargin) + "px";
				this.visible = true;
			}
		}
		this.track.style.display = this.visible ? "" : "none";
		this.listen_mouseEvents(this.visible);
	}
	handleMouseMove = (event: MouseEvent) => {
		event.preventDefault();
		if (this.verticalDirection) {
			this.content.scrollTop = this.startScroll + ((event.pageY - this.startPos) / this.ratio);
		}
		else {
			this.content.scrollLeft = this.startScroll + ((event.pageX - this.startPos) / this.ratio);
		}
	}
	handleMouseUp = () => {
		this.endDrag();
	}
	private startDrag(ev: MouseEvent) {
		ev.preventDefault();
		if (ev.target == this.thumb) {
			if (this.verticalDirection) {
				this.startPos = ev.pageY;
				this.startScroll = this.content.scrollTop;
			}
			else {
				this.startPos = ev.pageX;
				this.startScroll = this.content.scrollLeft;
			}
			ev.stopPropagation();
			this.track.className = this.cssTrack + " " + Dom.css.active;
			Events.mousemove.subscribe(this.handleMouseMove);
		} else {
			let trackRect = this.track.getBoundingClientRect();
			if (this.verticalDirection) {
				this.content.scrollTop = (ev.pageY - trackRect.top) / this.ratio;
			}
			else {
				this.content.scrollLeft = (ev.pageX - trackRect.left) / this.ratio;
			}
		}
	}

	private endDrag() {
		this.activate(false);
		Events.mousemove.unsubscribe(this.handleMouseMove)
	}
	activate(active: boolean) {
		this.track.className = this.cssTrack + (active ? (" " + Dom.css.active) : "");
	}
	render() {
		return <div className={this.cssTrack} style={{
			display: this.visible ? "" : "none"
		}} ref={(node) => this.track = node}>
			<div className={this.cssThumb} ref={(node) => this.thumb = node} />
		</div>
	}
	dispose() {
		this.endDrag();
		this.listen_mouseEvents(false);
		this.thumb = this.track = null;
	}
}