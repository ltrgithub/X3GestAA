"use strict";
import * as React from 'react';
import * as Dom from '../../../utility/html/dom';
import * as Events from '../../../event/events';

// See scrollbar.less too!
const thumbMinSize = 20;

export class ScrollAxe {
	visible: boolean;
	private thumb: HTMLDivElement;
	private track: HTMLDivElement;
	private listener_mousedown: (ev: MouseEvent) => any;
	private listener_mouseup: (ev: MouseEvent) => any;
	private ratio: number; // Relation of view height / content height
	private startPos: number;
	private startScroll: number;
	private thumbSize: number;
	private thumbPosRatio: number; // Ratio for thumb pos to scroll pos computation
	private content: HTMLElement;
	private verticalDirection: boolean;
	private highlighted: boolean;
	private _cssTrack: string;
	private _cssThumb: string;

	constructor(direction: "x" | "y", css: string) {
		this.verticalDirection = direction == "y";
		this._cssTrack = "s_scrollbar_track_" + direction;
		this._cssThumb = "s_scrollbar_thumb_" + direction;
		if (css) {
			this._cssTrack = css + " " + this._cssTrack;
			this._cssThumb = css + " " + this._cssThumb;
		}
	}
	moveThumb() {
		if (this.verticalDirection) {
			if (this.thumbPosRatio) {
				this.thumb.style.top = Math.round(this.thumbPosRatio * this.content.scrollTop) + "px";
			}
		}
		else {
			if (this.thumbPosRatio) {
				this.thumb.style.left = Math.round(this.thumbPosRatio * this.content.scrollLeft) + "px";
			}
		}
	}
	private listen_mouseEvents(bind: boolean) {
		if (this.track) {
			if (bind) {
				if (!this.listener_mousedown) {
					this.track.addEventListener("mousedown", this.listener_mousedown = (ev: MouseEvent) => {
						this.startDrag(ev);
					}, false);
				}
				if (!this.listener_mouseup) {
					this.content.ownerDocument.addEventListener("mouseup", this.listener_mouseup = (ev: MouseEvent) => {
						this.endDrag();
					}, false);
				}
			} else {
				this.listener_mousedown && this.track.removeEventListener("mousedown", this.listener_mousedown);
				this.listener_mouseup && this.content.ownerDocument.removeEventListener("mouseup", this.listener_mouseup);
				delete this.listener_mousedown;
				delete this.listener_mouseup;
			}
		}

	}

	resize(content: HTMLElement) {
		this.content = content;
		this.visible = false;
		if (this.verticalDirection) {
			if (this.content.clientHeight != this.content.scrollHeight) {
				this.track.style.height = this.content.clientHeight + "px";
				this.ratio = this.content.clientHeight / this.content.scrollHeight;
				this.thumbSize = Math.max(Math.floor(this.ratio * this.content.clientHeight), thumbMinSize);
				this.thumbPosRatio = (this.content.clientHeight - this.thumbSize) / (this.content.scrollHeight - this.content.clientHeight);
				this.moveThumb();
				this.thumb.style.height = this.thumbSize + "px";
				this.visible = true;
			}
		}
		else {
			if (this.content.clientWidth != this.content.scrollWidth) {
				this.track.style.width = this.content.clientWidth + "px";
				this.ratio = this.content.clientWidth / this.content.scrollWidth;
				this.thumbSize = Math.max(Math.floor(this.ratio * this.content.clientWidth), thumbMinSize);
				this.thumbPosRatio = (this.content.clientWidth - this.thumbSize) / (this.content.scrollWidth - this.content.clientWidth);
				this.moveThumb();
				this.thumb.style.width = this.thumbSize + "px";
				this.visible = true;
			}
		}
		this.track.style.display = this.visible ? "" : "none";
		this.listen_mouseEvents(this.visible);
	}
	handleMouseMove = (event: MouseEvent) => {
		event.preventDefault();
		if (this.verticalDirection) {
			this.content.scrollTop = this.startScroll + ((event.pageY - this.startPos) / this.thumbPosRatio);
		}
		else {
			this.content.scrollLeft = this.startScroll + ((event.pageX - this.startPos) / this.thumbPosRatio);
		}
	}
	handleMouseUp = () => {
		this.endDrag();
	}
	private startDrag(ev: MouseEvent) {
		ev.preventDefault();
		if (ev.target == this.thumb) {
			if (this.verticalDirection) {
				this.startPos = ev.pageY;
				this.startScroll = this.content.scrollTop;
			}
			else {
				this.startPos = ev.pageX;
				this.startScroll = this.content.scrollLeft;
			}
			ev.stopPropagation();
			this.activate(true);
			Events.mousemove.subscribe(this.handleMouseMove);
		} else {
			let trackRect = this.track.getBoundingClientRect();
			if (this.verticalDirection) {
				this.content.scrollTop = (ev.pageY - trackRect.top) / this.thumbPosRatio;
			}
			else {
				this.content.scrollLeft = (ev.pageX - trackRect.left) / this.thumbPosRatio;
			}
		}
	}

	private endDrag() {
		this.activate(false);
		Events.mousemove.unsubscribe(this.handleMouseMove)
	}
	get cssTrack(): string {
		return this._cssTrack + (this.highlighted ? " s_scrollbar_track_on" : "");
	}
	get cssThumb(): string {
		return this._cssThumb + (this.highlighted ? " s_scrollbar_thumb_on" : "");
	}
	highlight(on: boolean) {
		this.highlighted = on;
		if (this.track) {
			this.track.className = this.cssTrack;
		}
		if (this.thumb) {
			this.thumb.className = this.cssThumb;
		}
	}
	activate(active: boolean) {
		this.track.className = this.cssTrack + (active ? (" " + Dom.css.active) : "");
	}
	render() {
		return <div className={this.cssTrack} style={{
			display: this.visible ? "" : "none"
		}} ref={(node) => this.track = node}>
			<div className={this.cssThumb} ref={(node) => this.thumb = node} />
		</div>
	}
	dispose() {
		this.endDrag();
		this.listen_mouseEvents(false);
		this.thumb = this.track = null;
	}
}