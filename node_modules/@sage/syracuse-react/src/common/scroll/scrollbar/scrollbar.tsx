"use strict";
import * as React from 'react';
import * as Events from '../../../event/events';
import { ScrollAxe } from './scrollAxe';
import './scrollbar.less';

export default class Scrollbar extends React.Component<{
	onScroll?: (ev: UIEvent) => any;
	width?: string;
	height?: string;
	isAutoOverflow?: boolean
}, {}> {
	private slot: HTMLElement;
	private content: HTMLElement;
	private scroll_y: ScrollAxe;
	private scroll_x: ScrollAxe;
	private listener_wheel: (ev: WheelEvent) => any;
	private listener_scroll: (ev: UIEvent) => any;
	private timeout_resize: number;
	private isTrackHidden: boolean;

	constructor(props: any, context: any) {
		super(props, context);
		this.isTrackHidden = true;
		this.scroll_y = new ScrollAxe("y");
		this.scroll_x = new ScrollAxe("x");
	}
	getLineHeight = (el: EventTarget) => {
		let htmlEl = el as HTMLElement;
		if (htmlEl)
			return parseInt(window.getComputedStyle(htmlEl).lineHeight, 10);
		else
			return 20;
	}
	handleWheel = (ev: WheelEvent) => {
		if (ev.deltaMode === 0) //pixel
		{
			this.content.scrollTop += ev.deltaY;
			this.content.scrollLeft += ev.deltaX;
		}
		else { //line
			let h = this.getLineHeight(ev.target);
			this.content.scrollTop += ev.deltaY * h;
			this.content.scrollLeft += ev.deltaX * h;
		}
	}
	handleScroll = (ev: UIEvent) => {
		this.scroll_y.moveThumb();
		this.scroll_x.moveThumb();
		this.props.onScroll && this.props.onScroll(ev);
	}
	private listen_wheel(on: boolean) {
		if (this.content) {
			if (on) {
				if (!this.listener_wheel) {
					this.content.addEventListener("wheel", this.listener_wheel = this.handleWheel, false);
				}
			} else {
				this.listener_wheel && this.content.removeEventListener("wheel", this.listener_wheel);
				delete this.listener_wheel;
			}
		}
	}

	scroll(on: boolean) {
		if (this.content) {
			if (on) {
				if (!this.listener_scroll) {
					this.content.addEventListener("scroll", this.listener_scroll = this.handleScroll, false);
				}
			} else {
				this.listener_scroll && this.content.removeEventListener("scroll", this.listener_scroll);
				delete this.listener_scroll;
			}
		}
	}
	resize = () => {
		clearTimeout(this.timeout_resize);
		this.timeout_resize = window.setTimeout(() => {
			if (!this.content || !this.content.parentNode) {
				this.content = this.slot.childNodes[0] as HTMLElement;
				if (this.props.isAutoOverflow) {
					this.content.style.overflow = "auto";
					this.content.style.marginRight = "-20px";
					this.content.style.paddingRight = "20px";

				} else {
					this.content.style.overflow = "hidden";
				}
			}
			this.scroll_y.resize(this.content);
			this.scroll_x.resize(this.content);
			this.listen_wheel(this.scroll_x.visible || this.scroll_y.visible);
			this.scroll(this.scroll_x.visible || this.scroll_y.visible);
		}, 100);
	}
	componentWillUpdate() {
		clearTimeout(this.timeout_resize);
	}
	componentDidUpdate() {
		this.resize();
	}
	componentDidMount() {
		Events.resize.subscribe(this.resize);
	}
	componentWillUnmount() {
		clearTimeout(this.timeout_resize);
		Events.resize.unsubscribe(this.resize);

		this.scroll_y.dispose();
		this.scroll_x.dispose();
		this.scroll_y = this.scroll_x = null;
		this.listen_wheel(false);
		this.scroll(false);
	}
	render() {
		let style: any = {};
		if (this.props.width) {
			style.width = this.props.width;
		}
		if (this.props.height) {
			style.height = this.props.height;
		}
		return <div className='s_scrollbar_slot' ref={(node) => this.slot = node} style={style}>
			{this.props.children}
			{this.scroll_y.render()}
			{this.scroll_x.render()}
		</div>
	}
}