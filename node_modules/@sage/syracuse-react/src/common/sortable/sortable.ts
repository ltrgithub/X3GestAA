"use strict";
import * as Dom from '../../utility/html/dom';
import * as Events from '../../event/events';
import { getLocalString } from '../../culture/localString';
import { syra_site } from '../../syra/utility/syra_site';
import * as overHelper from '../../over/overHelper';
import './sortable.less';

interface IDragContext extends ClientRect {
	after: boolean
}

interface IScrollContext extends ClientRect {
	item: HTMLElement,
	scrollWidth: number,
	scrollHeight: number
}

export interface ISortableProps {
	root?: HTMLElement,
	htmlMode?: boolean,
	scrollview?: HTMLElement,
	horizontal?: boolean,
	start?: (node: HTMLElement) => boolean,
	end: (node: HTMLElement, target: HTMLElement, after: boolean) => void,
	getMovedNode?: (node: HTMLElement) => HTMLElement,
	dragText: (node: HTMLElement) => string
}

// To do clean syra_site and syra_page

export class Sortable {
	private root: HTMLElement;
	private info: HTMLElement;
	private cue: HTMLElement;
	private scrollViewRect: IScrollContext;
	private boundary: ClientRect;
	private target: HTMLElement;
	private dragContext: IDragContext;
	private zIndex: number;

	constructor(private node: HTMLElement, private props: ISortableProps) {
		if (!props.start || (props.start(node) !== false)) {
			this.node = node;
			this.root = props.root || Dom.getParentByTag(node, "UL");
			this.boundary = this.root.getBoundingClientRect();
			let scrollview = props.scrollview || this.root;
			this.scrollViewRect = Dom.getBoundingClientRect(scrollview);
			this.info = Dom.div("s_sortable_info_ok", Dom.site.slot);
			this.info.textContent = props.dragText && props.dragText(node) || getLocalString("flMoveItem");
			this.cue = Dom.div("s_sortable_cue", Dom.site.slot);
			let zIndex = overHelper.bindZindex();
			this.info.style.zIndex = zIndex.toString();
			this.cue.style.zIndex = zIndex.toString();
			this.scrollViewRect.item = scrollview;
			this.scrollViewRect.scrollWidth = scrollview.scrollWidth;
			this.scrollViewRect.scrollHeight = scrollview.scrollHeight;
			document.body.style.cursor = this.props.horizontal ? "e-resize" : "n-resize";
			this.subscribeEvents(true);
		} else {
			this.dispose();
		}
	}
	moveNode(event: MouseEvent, target: HTMLElement, isOut?: boolean) {
		let move = target && this.node != target && !this.node.contains(target);
		let top = Math.max(event.pageY, this.boundary.top);
		let left = Math.max(event.pageX, this.boundary.left);
		top = Math.min(top, this.boundary.bottom);
		left = Math.min(left, this.boundary.right);

		this.target = (!isOut && move) ? target : null;
		this.info.className = this.target == null ? "s_sortable_info" : "s_sortable_info_ok";
		this.moveCue(event);

		this.info.style.top = top + 15 + "px";
		this.info.style.left = left + 15 + "px";
	}
	moveCue(event: MouseEvent) {
		if (event && this.target) {
			this.dragContext = Dom.getBoundingClientRect(this.target);

			//calculateDropBoundary
			let xmargin = (this.dragContext.width * 0.25);
			let ymargin = (this.dragContext.height * 0.25);

			let after = false;
			let style = this.cue.style;
			if (this.props.horizontal) {
				let right = this.dragContext.left + this.dragContext.width - xmargin;
				after = event.pageX > right;
				style.top = (this.dragContext.top - 3) + "px";
				style.left = (this.dragContext.left + (after ? (this.dragContext.width + 3) : (-3))) + "px";
				style.width = "2px";
				style.height = this.dragContext.height + 6 + "px";

			} else {
				let bottom = this.dragContext.top + this.dragContext.height - ymargin;
				style.top = ((after = event.pageY > bottom) ? (bottom + ymargin) : this.dragContext.top) + "px";
				style.left = this.dragContext.left + "px";
				style.height = "2px";
				style.width = this.dragContext.width + "px";
			}
			this.dragContext.after = after;
			Dom.hide(this.cue, false);
		} else {
			Dom.hide(this.cue, true);
		}
	}
	private handleMousemove = (event: MouseEvent) => {
		event.preventDefault();
		if (event.target && this.root.contains(event.target as Node)) {
			let target = event.target as HTMLElement;
			let node = this.props.getMovedNode ? this.props.getMovedNode(target) : Dom.getParentByTag(target, "LI", this.root);
			if (node) {
				this.moveNode(event, node);
				event.stopPropagation();
				return;
			}
		}
		if (event.target != this.cue) {
			this.moveNode(event, null, true);
		}
	}
	private handleMouseup = (event: MouseEvent) => {
		this.end();
		syra_site.ignoreClick = event.target;
	}
	subscribeEvents(subscribe: boolean) {
		if (subscribe) {
			Events.mousemove.subscribe(this.handleMousemove);
			Events.mouseup.subscribe(this.handleMouseup);
		}
		else {
			Events.mousemove.unsubscribe(this.handleMousemove);
			Events.mouseup.unsubscribe(this.handleMouseup);
		}
	}
	end() {
		document.body.style.cursor = "";
		this.subscribeEvents(false);
		if (this.target) {
			if (this.props.htmlMode) {
				this.target.parentNode.insertBefore(this.node, this.dragContext.after ? this.target.nextSibling : this.target);
			}
			this.props.end && this.props.end(this.node, this.target, this.dragContext.after);
			this.target = null;
		}
		this.dispose();
	}
	dispose() {
		this.zIndex && overHelper.unbindZindex();
		this.subscribeEvents(false);
		Dom.remove(this.info);
		Dom.remove(this.cue);
		this.info = this.cue = this.scrollViewRect = this.target = null;
	}
}