"use strict";
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { Link, ILinkProp } from '../../link/link';
import { Popup, IPopupProps, PopupCloseBy } from './popup';
import { KeySpot } from '../../shortcut/keySpot';

interface IPopupLinkBody {
    my?: string,
    at?: string,
    closeBy?: PopupCloseBy[],
    onClose?: () => void,
    onResize?: (maxHeight: number) => void,
    render: () => any
}

export interface IPopupLinkProps extends ILinkProp {
    popup: IPopupLinkBody,
    onTogglePopup?: (opened: boolean) => void
}

interface IPopupLinkState {
    opened: boolean
}

export class PopupLink extends React.Component<IPopupLinkProps, IPopupLinkState>{
    keySpot: KeySpot;
    popup: Popup;

    onClose = () => {
        this.setState({
            opened: false
        });
    }
    get opened(): boolean {
        return this.state && this.state.opened;
    }
    togglePopup = (open?: boolean) => {
        if ((open === undefined) || (open != this.opened)) {
            this.props.onTogglePopup && this.props.onTogglePopup(!this.opened);
            this.setState({
                opened: !this.opened
            });
        }
    }
    componentWillUnmount() {
        this.bindEscape(false);
        this.popup = null;
    }
    onEscape = () => {
        this.onClose();
        (ReactDom.findDOMNode(this) as HTMLElement).focus();
        return true;
    }
    bindEscape(bind: boolean) {
        if (bind) {
            if (!this.keySpot) {
                this.keySpot = new KeySpot("PopupLink", () => { return true; });
                this.keySpot.bindEscape(() => this.onEscape());
            }
        }
        else {
            this.keySpot && this.keySpot.dispose();
            this.keySpot = null;
        }
    }
    componentWillUpdate(nextProps: IPopupLinkProps, nextState: IPopupLinkState) {
        nextState && this.bindEscape(nextState.opened);
    }
    componentDidUpdate(prevProps: IPopupLinkProps, prevSate: IPopupLinkState) {
        if ((prevSate && prevSate.opened) && !this.state.opened) {
            this.props.popup.onClose && this.props.popup.onClose();
        }
    }
    renderPopup(): any {
        return <Popup
            ref={(node) => { this.popup = node }}
            my={this.props.popup.my}
            at={this.props.popup.at}
            closeBy={this.props.popup.closeBy}
            onResize={this.props.popup.onResize}
            of={this}
            onClose={this.onClose}>
            {this.props.popup.render()}
        </Popup>;
    }
    render() {
        return <Link {...this.props as ILinkProp} onClick={this.togglePopup}>
            {this.props.children}
            {this.opened && this.renderPopup()}
        </Link>;
    }
}