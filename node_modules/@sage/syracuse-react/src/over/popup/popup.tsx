"use strict";
import * as React from 'react';
import * as ReactDom from 'react-dom';
import * as Events from '../../event/events';
import * as Dom from '../../utility/html/dom';
import * as qualityController from '../../quality/qualityController';
import * as overHelper from '../overHelper';
import './popup.less';

const AUTOCLOSE_OUT = 1000;

export type PopupCloseBy = "outOver" | "outClick" | "inClick";

export interface IPopupProps {
	className?: string,
	my?: string,
	at?: string,
	of?: React.ReactInstance,
	syraof?: HTMLElement // temp for syragate
	closeBy?: PopupCloseBy[], //not defined "outOver" and "outClick" by default. if explicitely null, no auto close 
	onResize?: (maxHeight: number) => void,
	onClose: () => void,
	htmlBody?: HTMLElement,
	width?: number
}

export class Popup extends React.Component<IPopupProps, {}> {
	private root: HTMLElement;
	private autoCloseTimeout: number;
	private in: boolean;

	get ofNode(): HTMLElement {
		return this.props.syraof || ReactDom.findDOMNode(this.props.of) as HTMLElement;
	}
	onClose = (event: MouseEvent) => {
		if (this.root) {
			let target = event.target as Node;
			let of = this.ofNode;
			if (!this.in && (!of
				|| ((this.root != target) && (of != target) && !of.contains(target) && !this.root.contains(target)))) {
				this.switchAutoCloseTimer(true, event.type == "click" ? 100 : AUTOCLOSE_OUT);
			}
			else {
				this.switchAutoCloseTimer(false);
			}
		}
	}
	onResize = () => {
		let maxHeight = Dom.site.body.height * 0.9;
		let maxWidth = Dom.site.body.width * 0.9;
		this.root.style.maxHeight = maxHeight + "px";
		this.root.style.maxWidth = maxWidth + "px";
		if (!this.props.htmlBody) {
			let body = this.root.firstChild as HTMLElement;
			if (body) {
				body.style.maxHeight = maxHeight + "px";
				body.style.maxWidth = maxWidth + "px";
				if (this.props.width) {
					body.style.width = this.props.width + "px";
				}
			}
		}
		this.props.onResize && this.props.onResize(maxHeight);
	}
	componentDidMount() {
		this.root = this.root || overHelper.createOverRoot("s_popup");
		this.root.setAttribute("data-s-dialog-modal", "false");
		let closeBy = this.props.closeBy;
		if (closeBy !== null) {
			//if not defined,  ["outOver", "outClick"] by default
			(!closeBy || closeBy.indexOf("outClick") >= 0) && Events.click.subscribe(this.onClose);
			if (!qualityController.robotMode && (!closeBy || closeBy.indexOf("outOver") >= 0)) {
				Events.mouseover.subscribe(this.onClose);
			}
		}
		Events.resize.subscribe(this.onResize);
		this.renderBody();
	}
	componentDidUpdate() {
		this.renderBody();
	}
	switchAutoCloseTimer(on: boolean, timeout?: number) {
		if (on) {
			if (!this.autoCloseTimeout) {
				this.autoCloseTimeout = window.setTimeout(() => {
					this.autoCloseTimeout = null;
					this.props.onClose();
				}, timeout);
			}
		}
		else {
			this.autoCloseTimeout && clearTimeout(this.autoCloseTimeout);
			this.autoCloseTimeout = null;
		}
	}
	onMouseEnter = () => {
		this.switchAutoCloseTimer(false);
		this.in = true;
	}
	onMouseLeave = () => {
		this.in = false;
	}
	renderBody() {
		if (this.props.htmlBody) {
			this.root.appendChild(this.props.htmlBody);
		}
		else {
			ReactDom.render(<div
				onMouseEnter={this.onMouseEnter}
				onMouseLeave={this.onMouseLeave}
				className={this.props.className || "s_popup_body"}>{this.props.children}
			</div>, this.root);
		}
		overHelper.position(this.root, {
			my: this.props.my || "left top",
			at: this.props.at || "left bottom",
			of: this.ofNode
		});
		this.onResize();
	}
	componentWillUnmount() {
		this.switchAutoCloseTimer(false);
		Events.click.unsubscribe(this.onClose);
		Events.mouseover.unsubscribe(this.onClose);
		Events.resize.unsubscribe(this.onResize);
		this.root = overHelper.removeOverRoot(this.root);
	}
	render(): any {
		return null;
	}
}