"use strict";
import * as Sdata from '../dataStore/sdata';
import { core } from '../syra/utility/core';

export interface ILocaleFormat {
    longDate?: string,
    shortDate?: string,
    longTime?: string,
    shortTime?: string,
    sortableDateTime?: string,
    longDatetime?: string,
    shortDatetime?: string,
    twoDigitYearMax?: number,
    numberGroupSize?: number,
    numberDecimalSeparator?: string,
    numberGroupSeparator?: string
}
export interface ILocalePreferences extends Sdata.IEntity, ILocaleFormat {
    code: string,
    description: string
}

interface IDateFormatPatterns {
    fullDateTime: string,
    sortableDateTime: string,
    universalSortableDateTime: string
}

interface INumberFormat {
    groupSize: number,
    decimalSeparator: string,
    groupSeparator: string,
    numFormat: string,
    "application/x-integer": string
}

const DEFAULT_LOCAL_CODE = "en-US";

class Culture {
    private datePatterns: IDateFormatPatterns;
    private _locale: ILocalePreferences
    private _numberFormat: INumberFormat;

    constructor() {
        this.datePatterns = core.dataTypes.date.resources().formatPatterns || {};
    }
    get localePreferences() {
        return this._locale;
    }
    set localePreferences(newLocale: ILocalePreferences) {
        this._locale = newLocale;
    }
    get languageCode(): string {
        return (this._locale && this._locale.code) || DEFAULT_LOCAL_CODE;
    }
    get date_long(): string {
        return (this._locale && this._locale.longDate) || "dd MMMM yyyy";
    }
    get date_short(): string {
        return (this._locale && this._locale.shortDate) || "yyyy-MM-dd";
    }
    get time_long(): string {
        return (this._locale && this._locale.longTime) || "HH:mm:ss";
    }
    get time_short(): string {
        return (this._locale && this._locale.shortTime) || "HH:mm";
    }
    get datetime_sortable(): string {
        return this.datePatterns.sortableDateTime || "yyyy-MM-ddTHH:mm:ss";
    }
    get datetime_full(): string {
        return (this._locale && this._locale.longDatetime) || this.datePatterns.fullDateTime || "dd MMMM yyyy HH:mm:ss";
    }
    get datetime_universal(): string {
        return (this._locale && this._locale.longDatetime) || this.datePatterns.universalSortableDateTime || "yyyy-MM-dd HH:mm:ssZ";
    }
    get datetime_default(): string {
        return (this._locale && this._locale.shortDatetime) || (this.date_short + " " + this.time_short);
    }
    get twoDigitYearMax(): number {
        return (this._locale && this._locale.twoDigitYearMax) || 2029;
    }
    get numberFormat(): INumberFormat {
        let groupSize = (this._locale && this._locale.numberGroupSize) || 3;
        let numFormat = "#,";
        for (let ii = 0; ii < groupSize; ii++) {
            numFormat += (ii == groupSize - 1) ? "0" : "#";
        }
        // numFormat default -> #,##0 (integer) or #,##0.## (decimal)
        numFormat += '.##';
        return this._numberFormat = {
            groupSize: groupSize,
            decimalSeparator: (this._locale && this._locale.numberDecimalSeparator) || ".",
            groupSeparator: (this._locale && this._locale.numberGroupSeparator) || ",",
            numFormat: numFormat,
            "application/x-integer": numFormat
        };
    }
    getFormatApi(type: string) {
        switch (type) {
            case Sdata.type.date:
                return core.dataTypes.date;
            case Sdata.type.datetime:
                return core.dataTypes.datetime;
            case Sdata.type.time:
                return core.dataTypes.time;
            case Sdata.type.integer:
                return core.dataTypes.integer;
            case Sdata.type.decimal:
                return core.dataTypes.decimal;
            case Sdata.type.real:
                return core.dataTypes.real;
        }
    }
    get date() {
        return core.dataTypes.date;
    }
    get datetime() {
        return core.dataTypes.datetime;
    }
    get time() {
        return core.dataTypes.time;
    }
    get integer() {
        return core.dataTypes.integer;
    }
    get decimal() {
        return core.dataTypes.decimal;
    }
    get real() {
        return core.dataTypes.real;
    }
    utcToLocal(value: string) {
        value = value.replace(/(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2}:\d{2})(Z|\s*GMT)/, "$1T$2Z");
        var dtLocal = core.dataTypes.datetime.parse(value);
        return dtLocal.toString(this.datetime_full);
    }
}


export const culture = new Culture();


class Format {
    private lengths: any;
    private _formats = {};
    private _directives = ["dirOne", "dirTwo", "dirThree"];

    constructor() {
        this.lengths = {};
    }
    getPattern(type: string, $displayFormat: string) { // return the corresponding date format
        switch (type) {
            case "application/x-date":
                return $displayFormat == "DD" ? culture.date_long : culture.date_short;
            case "application/x-time":
                return $displayFormat == "TT" ? culture.time_long : culture.time_short;
            case "application/x-datetime":
                switch ($displayFormat) {
                    case "F":
                        return culture.datetime_sortable;
                    case "FF":
                        return culture.datetime_full;
                    case "U":
                        return culture.datetime_universal;
                }
                return culture.datetime_default;
        }
        return $displayFormat || this.getNumberFormat(type);
    }
    getTwoDigitYearMax() {
        return culture.twoDigitYearMax;
    }
    getNumberFormat(type: string) {
        return (culture.numberFormat as any)[type] || culture.numberFormat.numFormat;
    }
    getNumberFormatObj(type: string) {
        return {
            numFormat: this.getNumberFormat(type),
            decimalSeparator: culture.numberFormat.decimalSeparator,
            groupSeparator: culture.numberFormat.groupSeparator,
            groupSize: culture.numberFormat.groupSize
        };
    }
    getLength(format: string) {
        var length = this.lengths[format];
        if (!length) {
            length = 0;
            let defined: any = {};
            for (var ii = 0, jj = format.length; ii < jj; ii++) {
                var val = format[ii];
                if (!defined[val]) {
                    switch (val) {
                        case "d":
                        case "D":
                        case "m":
                        case "M":
                        case "h":
                        case "H":
                            defined[val] = val;
                            length += 2;
                            break;
                        case "Y":
                        case "y":
                            defined[val] = val;
                            length += 4;
                            break;
                        default:
                            length++;
                    }
                }
            }
            this.lengths[format] = length;
        }
        return length;
    }
    private _setMaxLength(formatObj: any) {
        var maxLength = 0;
        for (var ii = 0, jj = this._directives.length - 1; ii < jj; ii++) {
            var dir = this._directives[ii];
            maxLength += formatObj[dir].count > 2 ? formatObj[dir].count : 2;
        }
        maxLength += 2;
        formatObj.maxLength = maxLength;
    }
    /**
 * Returns JSON formatObj with some properties :
 * - dirOne : first directive
 * - dirTwo : second ...
 * - dirThree : third ...
 * each directive has properties : *directive* (actual directive) and *count* (minimum digits)
 * - maxLenght : maximum possible date length according to the format
 * @param {String} format : date format
 * @return {Object} formatObj
 */
    processFormat(format: string) {
        var formatObj = (this._formats as any)[format];
        if (!formatObj) {
            let i = 0;
            let len = format.length;
            formatObj = (this._formats as any)[format] = {};
            while (i < len) {
                var c = format[i];
                switch (c) {
                    case "'":
                        i++;
                        var literal = '';
                        // going to the end of the following litteral or to the format end
                        for (; i < len; i++) {
                            if (format[i] === "'") {
                                i++;
                                // check wether the "'" is not doubled
                                if (format[i] === "'") {
                                    literal += "'";
                                } else
                                    break;
                            } else {
                                literal += format[i];
                            }
                        }
                        if (!formatObj.separator) {
                            formatObj.separator = literal;
                        }
                        break;
                    case "d":
                    case "M":
                    case "y":
                        var ch = format[i],
                            repeat = 1;
                        while (format[i + repeat] === ch) {
                            repeat++;
                        }
                        for (var mm = 0, kk = this._directives.length; mm < kk; mm++) {
                            var d = this._directives[mm];
                            if (!formatObj[d]) {
                                formatObj[d] = {};
                                formatObj[d].dir = c;
                                formatObj[d].count = repeat;
                                formatObj[d].max = repeat < 2 ? 2 : repeat;
                                break;
                            }
                        }

                        i += repeat;
                        break;
                    default:
                        if (!formatObj.separator) {
                            formatObj.separator = c;
                        }
                        i++;
                }
            }
            this._setMaxLength(formatObj);
        }
        return formatObj;
    }
}

export const format = new Format();