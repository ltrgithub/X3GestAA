global.syra_core = { dataTypes: { date: { resources: () => { return { formatPatterns: {} } } } } };

jest.mock('../../../utility/storage/storage', () => {
    return {
        local: {
            get: (key: string) => { return "c18d72c8-c04e-4a02-872a-8480439c4662" },
            set: (key: string, value: string) => { }
        }
    }
});

import * as React from 'react';
import * as Enzyme from 'enzyme';
import { shallow, mount, render } from 'enzyme';
import { renderToJson } from 'enzyme-to-json';
import { IDiagnose, IAlertPanel, Severity } from '../../alert';
import { AlertPanel } from '../alertPanel';
import *  as syra_router from '../../../route/syra_router';


describe('Test Suite for <AlertPanel />', () => {

    let generateDiagnoseElement = (severity: Severity): IDiagnose => {
        return {
            severity,
            message: 'Test Diagnose Panel Message'
        };
    }

    describe('Snapshots for Message Panel to show or not', () => {
        it('Should compare to snapshot if no error given', () => {
            const wrapper = render(<AlertPanel />);
            const json = renderToJson(wrapper);
            expect(json).toMatchSnapshot();
        });

        it('Should compare to snapshot if error given', () => {
            let diagnoses = [generateDiagnoseElement("error")];
            const wrapper = render(<AlertPanel diagnoses={diagnoses} />);
            const json = renderToJson(wrapper);
            expect(json).toMatchSnapshot();
        });
    });

    describe('Levels', () => {
        describe('Error', () => {
            let props: IAlertPanel;

            beforeEach(() => {
                props = {
                    diagnoses: [generateDiagnoseElement("error")]
                }
            });

            it('should render with the right icon and the message inside', () => {
                const component = Enzyme.mount(<AlertPanel {...props} />);
                expect(component.find('.s_alertpanel_diagnose_banner')).toHaveClassName('s_alert_banner_error');
                expect(component.find('.s_alertpanel_diagnose_msg').text()).toBe('Test Diagnose Panel Message');
            });

            it('should render the provided links', () => {
                const spy = jest.spyOn(syra_router, 'executeMenu').mockImplementation(jest.fn());

                props.links = {
                    "$link1": { "$title": "link1", "$url": "?$testLink1" },
                    "$link2": { "$title": "link2", "$url": "?$testLink2" },
                    "$link3": { "$title": "link3", "$url": "?$testLink3" }
                }

                const component = Enzyme.mount(<AlertPanel {...props} />);
                expect(component.find('.s_alertpanel_link').length).toBe(3);

                expect(spy).not.toHaveBeenCalled();
                component.find('.s_alertpanel_link').at(0).simulate('click');
                expect(spy).toHaveBeenCalledTimes(1);
                expect(spy.mock.calls[0][0]).toBe(props.links.$link1);
                component.find('.s_alertpanel_link').at(1).simulate('click');
                expect(spy).toHaveBeenCalledTimes(2);
                expect(spy.mock.calls[1][0]).toBe(props.links.$link2);
                component.find('.s_alertpanel_link').at(2).simulate('click');
                expect(spy).toHaveBeenCalledTimes(3);
                expect(spy.mock.calls[2][0]).toBe(props.links.$link3);
                spy.mockClear();
            });

            it('should render the show stack trace link', () => {
                props.diagnoses[0].stackTrace = "Stacktrace content";
                const component = Enzyme.mount(<AlertPanel {...props} />);

                expect(component.find('.s-alertpanel_toggle_details').length).toBeGreaterThan(0);
                expect(component.find('.s_alertpanel_technical').length).toBe(0);
            });

            it('should show the stack trace when the button is clicked', () => {
                props.diagnoses[0].stackTrace = "Stacktrace content";
                const component = Enzyme.mount(<AlertPanel {...props} />);

                expect(component.find('.s_alertpanel_technical').length).toBe(0);
                component.find('.s-alertpanel_toggle_details').simulate('click');
                expect(component.find('.s_alertpanel_technical').length).toBeGreaterThan(0);
            });

            it('should put the stacktrace on the clipboard when the copy button is clicked', () => {
                props.diagnoses[0].stackTrace = new Error().stack;
                const originalValue = window.getSelection;
                let selectNodeSpy = jest.fn();
                window.getSelection = () => {
                    return {
                        anchorNode: null,
                        anchorOffset: null,
                        baseNode: null,
                        baseOffset: null,
                        extentNode: null,
                        extentOffset: null,
                        focusNode: null,
                        focusOffset: null,
                        isCollapsed: null,
                        rangeCount: null,
                        type: null,
                        addRange: jest.fn(),
                        collapse: jest.fn(),
                        collapseToEnd: jest.fn(),
                        collapseToStart: jest.fn(),
                        containsNode: jest.fn(),
                        deleteFromDocument: jest.fn(),
                        empty: jest.fn(),
                        extend: jest.fn(),
                        getRangeAt: jest.fn(),
                        removeAllRanges: jest.fn(),
                        removeRange: jest.fn(),
                        selectAllChildren: jest.fn(),
                        setBaseAndExtent: jest.fn(),
                        setPosition: jest.fn(),
                    }
                }
                document.createRange = () => {
                    return {
                        collapsed: null,
                        commonAncestorContainer: null,
                        endContainer: null,
                        endOffset: null,
                        startContainer: null,
                        startOffset: null,
                        cloneContents: jest.fn(),
                        cloneRange: jest.fn(),
                        collapse: jest.fn(),
                        compareBoundaryPoints: jest.fn(),
                        createContextualFragment: jest.fn(),
                        deleteContents: jest.fn(),
                        detach: jest.fn(),
                        expand: jest.fn(),
                        extractContents: jest.fn(),
                        getBoundingClientRect: jest.fn(),
                        getClientRects: jest.fn(),
                        insertNode: jest.fn(),
                        selectNode: selectNodeSpy,
                        selectNodeContents: jest.fn(),
                        setEnd: jest.fn(),
                        setEndAfter: jest.fn(),
                        setEndBefore: jest.fn(),
                        setStart: jest.fn(),
                        setStartAfter: jest.fn(),
                        setStartBefore: jest.fn(),
                        surroundContents: jest.fn(),
                        toString: jest.fn(),
                        END_TO_END: null,
                        END_TO_START: null,
                        START_TO_END: null,
                        START_TO_START: null
                    }
                };
                
                const component = Enzyme.mount(<AlertPanel {...props} />);

                expect(component.find('.s_alertpanel_technical').length).toBe(0);
                component.find('.s-alertpanel_toggle_details').simulate('click');

                expect(selectNodeSpy).not.toBeCalled();
                component.find('.s_alert_copy').simulate('click');
                expect(selectNodeSpy).toHaveBeenCalledTimes(1);
                expect(selectNodeSpy.mock.calls[0][0].textContent).toContain(JSON.stringify(props.diagnoses[0].stackTrace));

                delete document.createRange;
                delete window.getSelection;
            });
        });

        describe('Warning', () => {
            let props: IAlertPanel;

            beforeEach(() => {
                props = {
                    diagnoses: [generateDiagnoseElement("warning")]
                }
            });

            it('Should compare to snapshot if warning given', () => {
                const wrapper = render(<AlertPanel {...props} />);
                const json = renderToJson(wrapper);
                expect(json).toMatchSnapshot();
            });

            it('should render with the right icon and the message inside', () => {
                const component = Enzyme.mount(<AlertPanel {...props} />);
                expect(component.find('.s_alertpanel_diagnose_banner')).toHaveClassName('s_alert_banner_warning');
                expect(component.find('.s_alertpanel_diagnose_msg').text()).toBe('Test Diagnose Panel Message');
            });
        });

        describe('Info', () => {
            let props: IAlertPanel;

            beforeEach(() => {
                props = {
                    diagnoses: [generateDiagnoseElement("info")],
                    onClose: jest.fn()
                };

                jest.useFakeTimers();
            });

            afterEach(() => {
                jest.useRealTimers();
            });

            it('Should compare to snapshot if info given', () => {
                const wrapper = render(<AlertPanel {...props} />);
                const json = renderToJson(wrapper);
                expect(json).toMatchSnapshot();
            });

            it('should render with the right icon and the message inside', () => {
                const component = Enzyme.mount(<AlertPanel {...props} />);
                expect(component.find('.s_alertpanel_diagnose_banner')).toHaveClassName('s_alert_banner_info');
                expect(component.find('.s_alertpanel_diagnose_msg').text()).toBe('Test Diagnose Panel Message');
            });

            it('should hide with the auto hide functionality enabled', () => {
                props.autoHide = true;
                const component = Enzyme.mount(<AlertPanel {...props} />);
                expect(props.onClose).not.toBeCalled();
                jest.runTimersToTime(4001);
                expect(props.onClose).toHaveBeenCalledTimes(1);
            });
        });

        describe('Success', () => {
            let props: IAlertPanel;

            beforeEach(() => {
                props = {
                    diagnoses: [generateDiagnoseElement("success")]
                }
            });

            it('Should compare to snapshot if success given', () => {
                const wrapper = render(<AlertPanel {...props} />);
                const json = renderToJson(wrapper);
                expect(json).toMatchSnapshot();
            });

            it('should render with the right icon and the message inside', () => {
                const component = Enzyme.mount(<AlertPanel {...props} />);
                expect(component.find('.s_alertpanel_diagnose_banner')).toHaveClassName('s_alert_banner_success');
                expect(component.find('.s_alertpanel_diagnose_msg').text()).toBe('Test Diagnose Panel Message');
            });

            it('should render the provided links', () => {
                const spy = jest.spyOn(syra_router, 'executeMenu').mockImplementation(jest.fn());

                props.links = {
                    "$link1": { "$title": "link1", "$url": "?$testLink1" },
                    "$link2": { "$title": "link2", "$url": "?$testLink2" }
                }

                const component = Enzyme.mount(<AlertPanel {...props} />);
                expect(component.find('.s_alertpanel_link').length).toBe(2);

                expect(spy).not.toHaveBeenCalled();
                component.find('.s_alertpanel_link').at(0).simulate('click');
                expect(spy).toHaveBeenCalledTimes(1);
                expect(spy.mock.calls[0][0]).toBe(props.links.$link1);
                component.find('.s_alertpanel_link').at(1).simulate('click');
                expect(spy).toHaveBeenCalledTimes(2);
                expect(spy.mock.calls[1][0]).toBe(props.links.$link2);
                spy.mockClear();
            });
        });

        describe('Multi', () => {
            let props: IAlertPanel;

            beforeEach(() => {
                props = {
                    diagnoses: [
                        generateDiagnoseElement("success"),
                        {
                            severity: 'error',
                            message: 'Test Diagnose Panel Message',
                            stackTrace: 'Stacktrace content'
                        },
                        generateDiagnoseElement("info"),
                        generateDiagnoseElement("error"),
                        generateDiagnoseElement("warning")
                    ]
                }
            });

            it('should render various panels according to the props correctly', () => {
                const component = Enzyme.mount(<AlertPanel {...props} />);
                expect(component.find('.s_alertpanel_diagnose').length).toBe(1);
                component.find('.s_alertpanel_more').simulate('click');
                expect(component.find('.s_alertpanel_diagnose').length).toBeGreaterThan(1);
            });
        });
    });
});
