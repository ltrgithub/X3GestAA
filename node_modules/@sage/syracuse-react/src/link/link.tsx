"use strict";
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { Icon } from '../common/icon/icon';
import * as Dom from '../utility/html/dom';
import { LinkTip } from './linkTip';
import * as Quality from '../quality/qualityController';

export type IconTextPosition = "left" | "right";
export interface ILinkProp {
	className: string,
	url?: string,
	title?: string,
	description?: string,
	onMouseDown?: (event: MouseEvent) => void,
	onMouseUp?: (event: MouseEvent) => void,
	onMouseEnter?: (props: ILinkProp, event: MouseEvent) => boolean,
	onMouseLeave?: (props: ILinkProp, event: MouseEvent) => void,
	onClick?: LinkClickHandler,
	shortcuts?: string[],
	value?: any,
	focus?: boolean,
	hidden?: boolean,
	disabled?: boolean,
	icon?: string,
	iconText?: IconTextPosition,
	highlightText?: string,
	highlightIndex?: number,
	id?: string
};

export type LinkClickHandler = (value: any, event: MouseEvent, props: ILinkProp) => void;

interface ILinkState {
	showTipTitle?: boolean,
	showTip?: boolean
}

export class Link extends React.Component<ILinkProp, ILinkState> {
	constructor(props: any, context: any) {
		super(props, context);
		this.state = {
			showTip: false
		};
	}
	get useTip(): boolean {
		return this.props.icon && !this.props.iconText; //icon defined and not iconText, only icon is visible
	}
	onClick = (event: MouseEvent) => {
		if (this.props.onClick) {
			event.preventDefault();
		}
		this.props.onClick(this.props.value, event, this.props);
	}
	onMouseEnter = (event: MouseEvent) => {
		let showTipTitle = this.useTip || (this.props.onMouseEnter && this.props.onMouseEnter(this.props.value, event));
		if (!showTipTitle) {
			let target = event.target as HTMLElement;
			showTipTitle = target.clientWidth != target.scrollWidth;
			if (!showTipTitle) {
				for (let ii = 0, jj = target.children.length; !showTipTitle && ii < jj; ii++) {
					let child = target.children[ii];
					showTipTitle = child.clientWidth != child.scrollWidth;
				}
			}
		}
		if (showTipTitle || this.props.shortcuts || this.props.description) {
			this.setState({
				showTipTitle: showTipTitle,
				showTip: true
			});
		}
	}
	onMouseLeave = (event: MouseEvent) => {
		this.props.onMouseLeave && this.props.onMouseLeave(this.props.value, event);
		if (this.state.showTip) {
			this.setState({
				showTip: false
			});
		}
	}
	focus() {
		(ReactDom.findDOMNode(this) as HTMLElement).focus();
	}
	componentDidUpdate() {
		this.props.focus && this.focus();
	}
	componentWillReceiveProps(nextProps: ILinkProp) {
		if (nextProps.disabled && this.state.showTip) {
			this.setState({
				showTip: false
			});
		}
	}
	componentDidMount() {
		this.props.focus && this.focus();
	}
	renderTip(): any {
		if (this.state.showTip) {
			return <LinkTip of={this}
				title={this.state.showTipTitle && this.props.title}
				description={this.props.description}
				shortcuts={this.props.shortcuts}
			/>;
		}
	}
	renderIcon() {
		return <Icon name={this.props.icon} className={this.props.className + "_i s_btn_i"} />;
	}
	renderIconMode(props: any) {
		if (this.props.iconText) {
			if (this.props.iconText != "right") {
				return <a  {...props}>
					{this.renderIcon()}{this.props.title}
					{this.props.children}
					{this.renderTip()}
				</a>;
			}
			else {
				return <a  {...props}>
					{this.props.title}{this.renderIcon()}
					{this.props.children}
					{this.renderTip()}
				</a>;
			}
		}
		else {
			if (this.props.icon != "css") {
				return <a  {...props}>
					{this.renderIcon()}
					{this.props.children}
					{this.renderTip()}
				</a>;
			}
			else {
				return <a  {...props}>
					{this.props.children}
					{this.renderTip()}
				</a>;
			}
		}
	}
	renderText(props: any) {
		return <a  {...props}>
			{this.renderTitle()}
			{this.props.children}
			{this.renderTip()}
		</a>;


		// return <a  {...props}>
		// 	{this.props.title}
		// 	{this.props.children}
		// 	{this.renderTip()}
		// </a>;
	}
	renderTitle() {
		let result;// = this.props.title;
		if (this.props.highlightText) {
			let regex = new RegExp("(" + this.props.highlightText + ")", "gi");
			let parts = this.props.title.split(regex);
			if (parts) {
				let field = [];
				for (let part of parts){
					if(part.toLowerCase() === this.props.highlightText.toLowerCase()){
						field.push(<mark>{part}</mark>);
					} else {
						field.push(part);
					}
				}
				return field;
				// return (
				// 	parts.map((part, i) =>
				// 		part.toLowerCase() === this.props.highlightText.toLowerCase() ?
				// 		<span key={i} className={part.toLowerCase() === this.props.highlightText.toLowerCase() ? "s_mark_text" : ""}>
				// 			{part}
				// 		</span> : {part})
				// );
			} 
						
						// <span key={i} className={part.toLowerCase() === this.props.highlightText.toLowerCase() ? "s_mark_text" : ""}>
						// 	{part}
						// </span>)

			// return <span> {parts.map((part, i) =>
			// 	<span key={i} style={part.toLowerCase() === this.props.highlightText.toLowerCase() ? { fontWeight: 'bold' } : {}}>
			// 		{part}
			// 	</span>)
			// } </span>;
			// if(this)
		}
		return this.props.title;
	}
	render() {
		if (this.props.hidden) {
			return null;
		}
		let props: any = {
			className: this.props.className,
			"aria-label": this.props.title
		};
		if (this.props.disabled) {
			props.disabled = true;
			props.className += " " + Dom.css.disabled;
		}
		else {
			props.href = this.props.url || "#";
			props.tabIndex = "0";
			props.onClick = this.onClick;
			props.onMouseEnter = this.onMouseEnter;
			props.onMouseLeave = this.onMouseLeave;
			props.onMouseUp = this.props.onMouseUp;
			props.onMouseDown = this.props.onMouseDown;
			if (this.props.id) {
				props.id = this.props.id;
			}
		}
		Quality.enabled && Quality.copyDataProps(this.props, props);
		return this.props.icon ? this.renderIconMode(props) : this.renderText(props);
	}
}