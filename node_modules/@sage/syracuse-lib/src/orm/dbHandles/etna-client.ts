import { _ } from 'streamline-runtime';
import { parse as urlParse } from 'url';
import * as ez from 'ez-streams';
import * as httpClient from '../../http-client/httpClient';

// definitions copied from @sage/etna
export type Dict<T> = { [name: string]: T; };

export interface EtnaConfig {
	session?: {
		userName?: string;
	}
}

export interface X3Session {
	userName: string;
	locale: string;
}

// local definitions
export interface ClientContext {
    userName?: string;
}

export interface JsonSendOptions {
    method?: string;
    head?: {
        url?: string;
        [name: string]: string;
    };
    payload: any;
}

export interface BulkReaderParams {
    url: string;
}

export interface Endpoint {
    getEtnaConfig(_: _, session: X3Session): EtnaConfig;
    dataset(_: _): string;
}

// proxy


export class EtnaOrmClient {
    config: EtnaConfig;
    dataset: string;
    userName: string;
    context: ClientContext;
    serviceUrl : string;
    startFunnel: <T>(_: _, fn: (_: _) => T) => T;

    constructor(config: EtnaConfig) {
        this.config = config;
        this.dataset = config.endpointName;
        this.userName = config.session.userName;
        this.context = this.context || {};
        this.startFunnel = _.funnel(1);
        this.serviceUrl = config.serviceUrl;
    }

    start(_: _) {
        // if etna port is not in config try to run etna in-process.
        if (this.serviceUrl) return;
        this.startFunnel(_, _ => {
            if (this.serviceUrl) return;
            // for now run etna server in-process
            const config = require('config');
            const range = [8250, 8299];
            const mainPath = `${this.config.solutionPath}/${this.config.folderName}/app`;
            var server = require(mainPath);
            for (var port = range[0]; port <= range[1]; port++) {
                try {
                    server.start(port);
                    this.serviceUrl = `http://localhost:${port}`;
                    console.log(`ETNA service started on ${this.serviceUrl}`)
                    return;
                } catch (ex) {
                    if (ex.code !== 'EADDRINUSE') throw ex;
                }
            }
            throw new Error(`cannot start etna server: all available ports are already in use`);
        });
    }
    etnaUrl(url: string) {
        return this.serviceUrl + url;
    }
    getSessionServiceLink(_: _, link: string) {
        switch (link) {
            case "$rights":
                return {
                    $url: "/sdata/x3/erp/" + this.dataset + "/ARIGHTS('" + this.userName + "')/$services/$rights"
                };
        }
        return null;
    }
    private headers(headers?: Dict<string>) {
        return Object.assign({
            'x-etna-config': new Buffer(JSON.stringify(this.config)).toString('base64'),
        }, headers || {});
    }
    jsonSend(_: _, options?: JsonSendOptions) {
        const url = this.etnaUrl(options.head.url);
        const headers = this.headers(options.head);
        const response = httpClient.httpRequest(_, {
            method: options.method || "GET",
            url: url,
            headers: headers,
        }).proxyConnect(_).write(_, options.payload || '').end().response(_);
        const body = response.readAll(_) || '';
        const result = {
            head: Object.assign({
                status: response.statusCode,
            }, response.headers),
            body: body.startsWith('{') ? JSON.parse(body) : body,
        };
        return result;
    }
    createBulkReader(_: _, params: BulkReaderParams) {
        const url = this.etnaUrl(params.url);
        const headers = this.headers();
        const response = httpClient.httpRequest(_, {
            method:"GET",
            url: url,
            headers: headers,
        }).proxyConnect(_).end().response(_);
        return response.reader.map((_, data) => JSON.parse(data));
    }
    disconnect(_: _) {
        const url = '/orm/session/' + this.config.session.id;
        const headers = this.headers();
        const response = httpClient.httpRequest(_, {
            method: "DELETE",
            url: url,
            headers: headers,
        }).proxyConnect(_).end().response(_);
        if (response.statusCode >= 400) throw new Error(`delete session failed: ${response.statusCode}`);
        response.readAll(_);
    }
    forward(_, request, response) {
        const headers = this.headers(request.headers);
        const req = httpClient.httpRequest(_, {
            url: this.etnaUrl(request.url),
            method: request.method,
            headers: headers,
        });
        request.reader.pipe(_, req.writer);
        const resp = req.response(_);
        response.writeHead(resp.statusCode, resp.headers);
        resp.reader.pipe(_, response.writer);
    }
};

const clients = {} as Dict<EtnaOrmClient>;

export function getClient(_: _, session: X3Session, endpoint: Endpoint) {
    const config = endpoint.getEtnaConfig(_, session);
    const dataset = endpoint.dataset(_);

    const client = clients[dataset] || (clients[dataset] = new EtnaOrmClient(config));
    client.start(_);

    client.context.userName = config.session.userName;
    return client;
};

export function etnaForward(_: _, context, ep) {
    const client = getClient(_, context.request.session, ep);
    client.forward(_, context.request, context.response);
}
