"use strict";

const locale = require('streamline-locale');
var datetime = require('@sage/syracuse-core').types.datetime;
import { AdminHelper as adminHelper } from '../collaboration/helpers';
var testOutput;
var testDb;
var timeoutFunction = null;
var nextRead;
var nextEvents = [];
import * as util from 'util';
import * as config from 'config';
import * as mock from '../load-balancer/mock';
import { flows } from 'streamline-runtime';
var  searchEngine = require('syracuse-search/lib/elasticSearch');
var tracer = (config.scheduler || {}).tracer;

// when a task is scheduled less than 500ms before its start time, it will be
// scheduled directly. This may imply that the same task will be scheduled twice.
// this array prevents simultaneous execution of the same task.
var justExecuted = [];


// when a task is scheduled less than 500ms before its start time, it will be
// scheduled directly. This may imply that the same task will be scheduled twice.
// this array prevents simultaneous execution of the same task.
var justExecuted = [];


/// !doc


// for unit tests: testing scheduler without real event and with test database
export function _setTestData(db1, output1) {
	testDb = db1;
	testOutput = output1;
};

// Insert item into array so that array remains sorted and does not contain duplicate items

// exported for unit tests
export function _insert(array, item) {
	var up = array.length;
	if (up === 0) {
		array[0] = item;
		return array;
	}
	var low = 0;
	var middle = array[0];
	while (up - low > 1) {
		var mid = ((up + low) >> 1);
		middle = array[mid];
		if (middle === item) return array;
		if (middle > item) up = mid;
		else low = mid + 1;
	}
	middle = array[low];
	if (middle === item) return array;
	if (middle > item) array.splice(low, 0, item);
	else array.splice(up, 0, item);
	return array;
}

// helper function to compute event's full key

function _getFullKey(_, event, key) {
	return event ? event.getEntity(_).name + "_" + event.computeKey() + "_" + (key || "") : key;
}



/// -------------
/// ## schedule function 
/// 
/// ``` javascript
/// scheduler.schedule(_, event, key, executionTime, parameters, mode);
/// ```
/// 
/// Schedule one instance of the given event.
/// 
/// 
/// * The `event` parameter represents the corresponding event (e. g. sending a certain email with a content template)
/// * The `key` parameter represents a key value for this instance. Scheduling a new event with the same key will replace 
///   the previously scheduled event
/// * The `executionTime` parameter contains the execution time. This can be a date string in ISO format or the number of milliseconds since 1 January 1970.
/// * The `parameters` parameter contains a JSON structure which serves for placeholders within the event text
/// * The `mode` parameter denotes how the event should be scheduled: "" without database change, "db" with database change, "cluster" schedule also on other servers in cluster.
///  
export function schedule(_, event, key, executionTime, parameters, mode) {
	var ts;
	var db = testDb || adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "eventTime");
	var now = Date.now();
	if (executionTime) {
		executionTime = new Date(executionTime).getTime();
	}
	if (!executionTime || (executionTime - now < 500)) {
		// execute it directly
		_execute(!_, event, _getFullKey(_, event, key), parameters);
		return;
	}
	if (mode) {
		// insert into database
		var fullKey = _getFullKey(_, event, key);
		var instances = _getInstances(_, db, entity, undefined, fullKey); // search for key
		if (instances.length > 0) {
			var execTime = instances[0].timestamp(_); // grab current timestamp to detect modification
			instances[0].lockInstanceRetry(_);
			try { // try-finally block to release lock in any case
				// load instance again - it may have been modified inbetween
				var instance = db.fetchInstance(_, entity, {
					jsonWhere: {
						$uuid: instances[0].$uuid
					}
				});
				// do change only when instance has not been changed or deleted inbetween
				// (this has then been done by another process)
				if (instance && instance.timestamp(_) === execTime) {
					instance.timestamp(_, +executionTime);
					instance.parameters(_, parameters);
					instance.save(_);
				}
			} finally {
				instances[0].unlockInstance(_);
			}
			for (var i = 1; i < instances.length; i++) {
				instances[i].deleteSelf(_);
			}
		} else {
			var instance = entity.createInstance(_, db, null);
			instance.timestamp(_, +executionTime);
			if (event) instance.event(_, event);
			instance.key(_, fullKey);
			instance.parameters(_, parameters);
			// newly created instance: can just be saved
			instance.save(_);
		}
	}
	// insert it into the array
	if (nextEvents.length === 0) {
		nextEvents.push(executionTime);
		timeoutFunction = flows.setTimeout(function(_) {
			_read(_, db, entity);
		}, executionTime - now);
		tracer && tracer("Next execution1 " + new Date(+executionTime));
	} else {
		// console.log("length "+nextEvents.length)
		if (nextEvents[0] > executionTime) {
			clearTimeout(timeoutFunction);
			timeoutFunction = flows.setTimeout(function(_) {
				_read(_, db, entity);
			}, executionTime - now);
			nextEvents.unshift(executionTime);
		} else {
			_insert(nextEvents, +executionTime);
		}
		tracer && tracer("Next execution2 " + new Date(+nextEvents[0]));
	}
	if (mode === "cluster") _notifyOthers(_);
	// console.log("TIMEOUT "+util.format(timeoutFunction)+" "+util.format(nextEvents))
};

/// -------------
/// ## remove function 
/// 
/// ``` javascript
/// scheduler.remove(_, event, key, mode);
/// ```
/// 
/// Remove scheduling of one instance of the given event.
/// 
/// 
/// * The `event` parameter represents the corresponding event (e. g. sending a certain email with a content template)
/// * The `key` parameter represents a key value for this instance.
/// * The `mode` parameter denotes how the event should be removed: "" without database change, "db" with database change, "cluster" remove also on other servers in cluster.
///  
export function remove(_, event, key, mode) {
	var db = testDb || adminHelper.getCollaborationOrm(_);
	var entity = db.model.getEntity(_, "eventTime");

	nextEvents.length = 0; // no execution of pending events
	if (timeoutFunction) clearTimeout(timeoutFunction);

	if (mode) {
		// remove from database
		var fullKey = _getFullKey(_, event, key);
		var instances = _getInstances(_, db, entity, undefined, fullKey); // search for key
		if (instances.length > 0) {
			instances.forEach_(_, function(_, instance) {
				instance.lockInstanceRetry(_);
				instance.deleteSelf(_);

				// Necessary??
				instance.unlockInstance(_);
			});
		}
	}

	if (mode === "cluster") _notifyOthers(_);
	// reload event queue as it has been emptied
	exports.scheduleAll(_);
};

/// -------------
/// ## scheduleAll function 
/// 
/// ``` javascript
/// scheduler.scheduleAll(_, event, data, mode);
/// ```
/// 
/// Replace all scheduled instances for this event
/// 
/// * The `event` parameter represents the corresponding event (e. g. sending a certain email with a content template)
/// * The `data` parameter contains an array of triples `[key, executionTime, parameters]`, where `key`, `executionTime`,
///   `parameters` have the same meaning as in the `schedule` function. Elements in this list with same key will replace
///   scheduled events. Scheduled events whose key does not appear any more in this list will be deleted. If the parameter
///   is empty (really empty, not just empty array), the scheduler will just be initialized.
/// * The `mode` parameter denotes how the event should be scheduled: "" without database change, "db" with database change, "cluster" schedule also on other servers in cluster.
///
export function scheduleAll(_, event, data, mode) {
	tracer && tracer("Schedule all");
	var db = testDb || adminHelper.getCollaborationOrm(_);
	searchEngine && searchEngine.checkUpdateVersion2(!_, db);

	var entity = db.model.getEntity(_, "eventTime");
	var ts;
	var now = Date.now();
	nextEvents.length = 0; // no execution of pending events
	if (timeoutFunction) clearTimeout(timeoutFunction);
	var tasks = {};
	var executeImmediately = [];
	var description = _getFullKey(_, event, "");
	// decide which tasks can be executed immediately	
	if (data) {
		data.forEach(function(item) {
			var fullKey = description + item[0];
			if (item[0] && fullKey in tasks) throw new Error(locale.format(module, "doubleKey"));
			var executionTime = item[1];
			tracer && tracer("Ex time " + executionTime + " now " + now);
			if (executionTime) {
				if (!(executionTime instanceof Date)) executionTime = new Date(executionTime);
				executionTime = executionTime.getTime();
			}
			if (!executionTime || executionTime - now < 500) {
				// 	execute it directly
				tracer && tracer("Execute immediately " + fullKey + " " + executionTime);
				executeImmediately.push(item);
				tasks[fullKey] = null;
			} else {
				item = [item[0], executionTime, item[2]];
				tasks[fullKey] = item;
			}
		});
		executeImmediately.forEach(function(item) {
			_execute(!_, event, item[0], item[2]);
		});
	};
	// use a cursor because there may be many instances
	var cursor = db.createCursor(_, entity);
	var instance;
	while (instance = cursor.next(_)) {
		var key = instance.key(_);
		// only look for correct instances
		var instanceEvent = instance.event(_);
		var instanceDescription = _getFullKey(_, instanceEvent, "");
		if (instanceDescription !== description) {
			_insert(nextEvents, +instance.timestamp(_));
			continue;
		}
		var item = tasks[key];
		if (data) {
			if (!item) { // task with same key does not exist any more or has just been executed
				if (mode) instance.deleteSelf(_);
				continue;
			}
			// update instance
			if (mode) {
				// lock instance to avoid external modifications
				var execTime = instance.timestamp(_);
				instance.lockInstanceRetry(_);
				try { // try-finally block to unlock instance
					// load instance again - it may have been modified inbetween
					var instance2 = db.fetchInstance(_, entity, {
						jsonWhere: {
							$uuid: instance.$uuid
						}
					});
					// do change only when instance has not been changed or deleted inbetween
					// (this has then been done by another process)
					if (instance2 && instance2.timestamp(_) === execTime) {
						instance2.timestamp(_, +item[1]);
						instance2.parameters(_, item[2]);
						instance2.save(_);
					}
				} finally {
					instance.unlockInstance(_);
				}
			}
		}
		if (item) _insert(nextEvents, +item[1]);
		tasks[key] = null;
		continue;
	}
	// new tasks for database
	Object.keys(tasks).forEach_(_, function(_, key) {
		var item = tasks[key];
		if (!item) return;
		if (mode) {
			var instance = entity.createInstance(_, db, null);
			instance.timestamp(_, +item[1]);
			if (event) instance.event(_, event);
			instance.key(_, key);
			instance.parameters(_, item[2]);
			// newly created instance: can just be saved
			instance.save(_);
		}
		if (item) _insert(nextEvents, +item[1]);
	});
	if (nextEvents.length > 0) {
		var nextExecution = nextEvents[0] - Date.now();
		if (nextExecution < 500) {
			_read(!_, db, entity);
		} else {
			timeoutFunction = flows.setTimeout(function(_) {
				_read(_, db, entity);
			}, nextExecution);
		}
		tracer && tracer("Next execution " + new Date(+nextEvents[0]));
	}
	if (mode === "cluster") _notifyOthers(_);
};

function _notifyOthers(_) {
	if ("mockServer" in config) {
		var options = {
			path: "/nannyCommand/notifyAll/patch/notificationAll",
			method: "PUT",
			hostname: "",
			port: 0,
			headers: {}
		};
		options.headers[mock.BALANCER_HEADER] = config.port;
		try {
			config.mockServer.mockClient.simpleRequest(options, "OK", _);
		} catch (e) {
			tracer && tracer("Error " + e.stack);
		}
	}
}




// read all instances from database or all with a given time

function _getInstances(_, db, entity, time, key) {
	// fetch user
	var whereClause;
	if (time) {
		whereClause = {
			timestamp: +time
		};
	} else if (key) {
		whereClause = {
			key: key
		};
	}
	tracer && tracer("before fetch" + util.format(whereClause), new Error().stack);
	var result = db.fetchInstances(_, entity, {
		jsonWhere: whereClause
	});
	tracer && tracer("after fetch" + result.length);
	return result;
}

// read list of future events, lock the corresponding instances in the database

function _read(_, db, entity) {
	var now = Date.now();
	timeoutFunction = null;
	tracer && tracer("READ");
	while (nextEvents.length > 0) {
		tracer && tracer(nextEvents[0] + " " + (nextEvents[0] - now));

		if (nextEvents[0] - now > 500) break;
		var nextEvent = nextEvents.shift();
		var instances = _getInstances(_, db, entity, nextEvent);
		instances.forEach_(_, function(_, instance) {
			try {
				tracer && tracer("Before lock " + new Date());
				instance.lockInstanceRetry(_);
				try {
					// find out whether instance still exists. If not, task has already been executed somewhere else
					var count = db.count(_, entity, {
						jsonWhere: {
							$uuid: instance.$uuid
						}
					});
					if (count) { // maybe instance does not exist any more: then event has already been handled by another process
						var event = instance.event(_);
						_execute(!_, event, instance.key(_), instance.parameters(_));
						instance.deleteSelf(_);
					}
				} catch (e) {
					console.error("Error in execution " + e.stack);
				} finally {
					try {
						tracer && tracer("Before unlock " + new Date());
					} finally {
						instance.unlockInstance(_);
					}
				}
			} catch (e1) {
				tracer && tracer("Instance locked: " + e1.stack);
			}
		});
	}
	if (nextEvents.length > 0) {
		timeoutFunction = flows.setTimeout(function(_) {
			_read(_, db, entity);
		}, nextEvents[0] - now);
	}
}

// execute a single event

function _execute(_, event, key, parameters) {
	tracer && tracer("Execute " + key);
	if (testOutput) {
		testOutput.push(parameters.test);
		return;
	}
	if (justExecuted.indexOf(key) < 0) {
		justExecuted.push(key);
		try {
			event.fire(_, key, parameters);
		} finally {
			var index = justExecuted.lastIndexOf(key);
			if (index >= 0) {
				justExecuted.splice(index, 1);
			}
		}
	} else {
		tracer && tracer("Ignore double event " + key);
	}
}