"use strict";

import * as locale from 'streamline-locale';

function firstProp(elt) {
	return elt.$properties[Object.keys(elt.$properties)[0]];
}

var _normalizerMap = {
	$X3Name: function(key, prop) {
		if (!prop.$X3Name && (key[0] === "b")) prop.$X3Name = "LeftList_" + key;
	},
	$xid: function(key, prop) {
		// do nothing, $xid should be there
	}
};

function fixPrototype(from, to) {
	return function(proto, $article) {
		var map = {};

		function fillMap(elt) {
			Object.keys(elt.$properties).forEach(function(key) {
				if (key.charAt(0) == "b") {
					return;
				}
				var prop = elt.$properties[key];
				_normalizerMap[from] && _normalizerMap[from](key, prop);
				if (prop[from]) {
					map[key] = prop[from];
				} else if (prop.$item && prop.$type === "application/x-array") {
					throw new Error("prototype conversion failed: missing " + key + "." + from);
					//var prop0 = firstProp(prop.$item);
					//if (prop0[from]) map[key] = "ARR_" + prop0[from];
					//else console.error("NO NAME 1 FOR " + key);
				} else {
					//console.log("NO NAME 2 FOR " + key);
				}
				prop[from] = undefined;
				if (prop.$item) fillMap(prop.$item);
			});
		}

		function fixProperties(elt) {
			elt.$properties = Object.keys(elt.$properties).reduce(function(result, key) {
				var prop = elt.$properties[key];
				var name = map[key];
				if (!name) {
					name = key;
				}
				result[name] = prop;
				if (name !== key) prop[to] = key;
				if (prop.$item) fixProperties(prop.$item);
				return result;
			}, {});
			elt.$convertState = from === '$X3Name' ? 'persistent' : 'volatile';
		}

		function fixArticle(art) {
			if (!art) return;
			if (Array.isArray(art)) art.forEach(fixArticle);
			else if (typeof art === 'object') {
				if (art.$bind != null) {
					if (map[art.$bind]) art.$bind = map[art.$bind];
					else return;
					//					else throw new Error("name missing for  " + art.$bind);
				}
				Object.keys(art).forEach(function(key) {
					if (key === '$fusionBar' || key === '$menus') return;
					if ((key === '$garbageFields') && art[key]) {
						art[key] = art[key].map(function(g) {
							return map[g];
						});
					}
					fixArticle(art[key]);
				});
			}
		}
		if (proto.$properties /* && firstProp(proto)[from]*/ ) {
			fillMap(proto);
			fixProperties(proto);
			fixArticle($article || proto.$article);
		}
	};
}

/// converts a prototype to the persistent form that we save in mongodb
exports.makePersistent = fixPrototype('$X3Name', '$xid');
/// converts a prototype to the volatile form that we use in the client
exports.makeVolatile = fixPrototype('$xid', '$X3Name');

function _warnNotFound(source, $localization, notFound) {
	if (!notFound) {
		notFound = notFound || [];
	}
	if (source && typeof(source) == 'object') {
		var properties = Object.keys(source);
		for (var ii = 0, jj = properties.length; ii < jj; ii++) {
			var property = properties[ii];
			var sourceValue = source[property];
			if (typeof(sourceValue) == 'object') {
				if (sourceValue != null) {
					if (Array.isArray(sourceValue)) {
						for (var mm = 0, kk = sourceValue.length; mm < kk; mm++) {
							_warnNotFound(sourceValue[mm], $localization, notFound);
						}
					} else {
						_warnNotFound(sourceValue, $localization, notFound);
					}
				}
			} else {
				if (sourceValue && sourceValue.indexOf && property == "$title") {
					if (sourceValue.indexOf("{@") === 0) {
						if (!sourceValue.match(/\{@.*100016\d\d\}/)) {
							var key = sourceValue.substr(1, sourceValue.length - 2);
							if (!$localization[key]) {
								notFound.push(key);
							}
						}
					}
				}
			}
		}
	}
	return notFound;
}

function findNewId(oldId, mapList, isField) {
	var newIds = Object.keys(mapList);
	var results = [];
	for (var ii = 0, jj = newIds.length; ii < jj; ii++) {
		if (mapList[newIds[ii]] == oldId) {
			results.push(newIds[ii]);
		}
	}
	if (results.length) {
		for (var ii = 0, jj = results.length; ii < jj; ii++) {
			switch (results[ii][1]) {
				case "F":
					if (isField) {
						return results[ii];
					}
					break;
				case "B":
				case "S":
					if (!isField) {
						return results[ii];
					}
					break;
			}
		}
		return results[0];
	}
	return oldId;
}

function _replaceTitle(source, mapList) {
	if (source && typeof(source) == 'object') {
		var properties = Object.keys(source);
		for (var ii = 0, jj = properties.length; ii < jj; ii++) {
			var property = properties[ii];
			var sourceValue = source[property];
			if (typeof(sourceValue) == 'object') {
				if (sourceValue != null) {
					if (Array.isArray(sourceValue)) {
						for (var mm = 0, kk = sourceValue.length; mm < kk; mm++) {
							_replaceTitle(sourceValue[mm], mapList);
						}
					} else {
						_replaceTitle(sourceValue, mapList);
					}
				}
			} else {
				if (sourceValue && sourceValue.indexOf && property == "$title") {
					if (sourceValue.indexOf("{@") === 0) {
						// particular case : delete title like {@100016**}
						if (sourceValue.match(/\{@.*100016\d\d\}/)) delete source.$title;
						else {
							var key = sourceValue.substr(1, sourceValue.length - 2);
							var newId = findNewId(key, mapList, source.$bind);
							if (newId) {
								source.$title = "{" + newId + "}";
							}
						}
					}
				}
			}
		}
	}
}

exports.convertLocalization = function($prototype, $article, options) {
	var opt = options || {};
	if ($prototype.$localization && $prototype.$hackLocalization) {
		_replaceTitle($article, $prototype.$hackLocalization);
		if (opt.$diagnoses) {
			var nf = _warnNotFound($article, $prototype.$localization);
			if (nf && nf.length) {
				opt.$diagnoses.push({
					$severity: "warning",
					$message: locale.format(module, "locCodeNotFound", (opt.prototypeId || ""), nf.join(","))
				});
			}
		}
	}
};

exports.getLocalizationNotFoundArray = function($article, $protoLocalization) {
	return _warnNotFound($article, $protoLocalization);
};