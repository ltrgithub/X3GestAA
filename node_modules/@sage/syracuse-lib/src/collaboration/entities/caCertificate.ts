"use strict";
const locale = require('streamline-locale');
import * as util from 'util';
import * as cert from './certificate';
import * as certTools from '../../load-balancer/certTools';
import * as config from 'config';
import { globals } from 'streamline-runtime';

export const entity = {
	$properties: {
		name: {
			$title: "Name",
			$isMandatory: true,
			$isUnique: true,
			$isReadOnly(_, instance) {
				return !instance.$created;
			},
			$linksToDetails: true,
			$pattern: "^[a-z][-a-z0-9_.]*$"
		},
		description: {
			$title: "Description",
			$isReadOnly(_, instance) {
				return instance.internal(_);
			}
		},
		internal: {
			$title: "internal",
			$isReadOnly: true,
			$type: "boolean"
		},
		// this is an input field only. The the output is the function getPEMCertificate
		certificate: {
			$title: "CA Certificate",
			$type: "binary",
			$storage: "db_file",
			$isMandatory(_, instance) {
				return instance.$created;
			}
		},
		subject: {
			$title: "Distinguished name JSON",
			$type: "json",
			$isHidden: true
		},
		subjectDn: {
			$title: "Distinguished name",
			$compute(_, instance) {
				return cert.getDn(instance.subject(_));
			}
		},
		issuer: {
			$title: "Issuer name JSON",
			$type: "json",
			$isHidden: true
		},
		issuerDn: {
			$title: "Issuer distinguished name",
			$isReadOnly: true,
			$compute(_, instance) {
				return cert.getDn(instance.issuer(_));
			}
		},
		notBefore: {
			$title: "Valid from",
			$isReadOnly: true,
			$type: "datetime"
		},
		notAfter: {
			$title: "Valid until",
			$isReadOnly: true,
			$type: "datetime"
		},
		certificateHash: {
			$title: "Hash of certificate",
			$isReadOnly: true,
			$isHidden: true
		}
	},
	$relations: {
		ldaps: {
			$title: "LDAP servers",
			$type: "ldaps",
			$inv: "cacerts"
		},
		notificationServers: {
			$title: "notification servers",
			$type: "notificationServers",
			$inv: "cacerts"
		},
		restWebService: {
			$title: "CA certificates for Rest web service",
			$type: "restWebServices",
			$inv: "cacerts",
			$isComputed: true
		}


	},
	$titleTemplate: "Certificates of Certification Authorities",
	$valueTemplate: "{name}",
	$helpPage: "Administration-reference_CA-Certificates",
	$events: {
		$beforeSave: [

			function(_, instance) {
				cert.fillInstance(instance, true, _);
			}
		],
		$afterSave: [

			function(_, instance) { // update nanny processes unless special marker property has been set
				if (config.mockServer) {
					var options = {
						path: "/nannyCommand/notifyNannies/update",
						method: "PUT",
						hostname: "",
						port: 0
					};
					try {
						console.log(config.mockServer.mockClient.simpleRequest(options, null, _));
					} catch (e) {
						console.log("Error " + e);
					}
				}
			}
		]
	},
	$actions: {
		$save(_, instance) {
			var r = {};
			if (!config.hosting.multiTenant && config.mockServer && instance.$snapshot && !instance.$created) {
				r.$confirm = locale.format(module, "maybeRestart");
			}
			return r;
		}
	},
	$searchIndex: {
		$fields: ["name"]
	},
	$functions: {
		$onDelete(_) {
			// delete contents in file system
			cert.deleteData(this, true, _);
		},
		/// function getPEMCertificate
		/// retrieves the complete certificate text in PEM format as a string.
		/// Only returns locally available certificates (not server certificates of other servers)
		getPEMCertificate(_) {
			return certTools.getPEMCertificate(_, (this.internal(_) ? "" : this.name(_)), true, globals.context.tenantId);
		}
	},
	$defaultOrder: [
		["name", true]
	],
	$services: {}
};