"use strict";
var locale = require('streamline-locale');
var util = require('util');
var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;
var helpers = require('@sage/syracuse-core').helpers;
var fs = require('streamline-fs');
var fsp = require('path');
var globals = require('streamline-runtime').globals;
var serializer = require("@sage/syracuse-lib/src/orm/serializer");
var entities = require("@sage/syracuse-lib/src/orm/entities");
var secProfile;
var entitiesToLog;


function _hasModifiedProperties(obj) {
	return JSON.stringify(obj, null, 1).match(/\$value|\$prev|\$added|\$deleted/g);
}

function _isProperty(obj) {
	  if (obj && obj.hasOwnProperty("$prev") && (typeof(obj.$prev) == "object") && !(obj.$prev.hasOwnProperty("default")))
	    return false;		
	  if (obj && obj.hasOwnProperty("$value") && (typeof(obj.$value) == "object") && !(obj.$value.hasOwnProperty("default")))
	    return false;		
      return true;    
}

function _isCollection(obj) {
	return (obj && Array.isArray(obj) && _hasModifiedProperties(obj));
}

function _isReference(obj) {
	return (obj && obj.hasOwnProperty("$prev") &&
		((typeof(obj.$prev) == "object") || (typeof(obj.$value) == "object")));
}

// Format the json delta in to intermediate json ready to stringify into human readable string
function _propertyToText(_, instance, obj, path, type) {
	var result = {};
	if (type == undefined ) type = null;
	var realName;
	if (_isCollection(obj)) {
		for (var item in obj) {	
			var prop = _getProperty(_, instance.getLoggedEntity(_,type),type? path.split(".").slice(-1)[0]: path);
			if (!prop) return result;			
			realName = prop.getTitle();
			result[realName] = result[realName] || [];
			if (_hasModifiedProperties(obj[item])) {				
				var aitem = _propertyToText(_, instance, obj[item], path, obj[item].$type);
				var value = _getValueFromTemplate(_, instance, path, obj[item]);
				
				if ((value) && (obj[item].$added)) value = locale.format(module, "added", value);
				if ((value) && (obj[item].$deleted)) value = locale.format(module, "deleted", value);				
				var tmpObj = {};
				if (value)
					tmpObj[value] = aitem;
				else
					tmpObj = aitem;
			
				result[realName].push(tmpObj);
			}
		}
	} else {
		for (var key in obj) {
			var v, p;			
			var prop = _getProperty(_, instance.getLoggedEntity(_,obj.$type), obj.$type ? key : path + '.' + key,);
			if (prop && (prop instanceof entities.Property) && obj[key] && (obj[key].$value || obj[key].$prev)) {
				realName = prop.getTitle();
				v =  _getValueByType(_,prop,obj[key].$value);
				p =  _getValueByType(_,prop,obj[key].$prev);
				result[realName] = locale.format(module, "prevValue", v, p);

			} else if (prop && _isReference(obj[key])) {
				realName = prop.getTitle();
				v = _getValueFromTemplate(_, instance, path + '.' + key, obj[key].$value);
				p = _getValueFromTemplate(_, instance, path + '.' + key, obj[key].$prev);
				result[realName] = locale.format(module, "prevValue", v, p);

			} else if (_isCollection(obj[key])) {				
				result = Object.assign(result,_propertyToText(_, instance, obj[key], path + '.' + key,type));
			}
		}

	}
	return result;
}

// Get property/relation according with the model description
function _getProperty(_, entity, propName) {	
	var oProp = propName;
	var nProp;    
	if (!entity) return;
	if (propName.includes('.')) {
		var a = propName.split(".");
		oProp = a.shift();
		nProp = a.join(".");
	}
	
	var rel = entity.$relations[oProp] || entity.$properties[oProp];	
	if (nProp && rel) {
		var singular = entity.getModel().singularize(rel.type) || rel.type;		
		return _getProperty(_, entity.getModel().getEntity(_, singular), nProp);
	}
	return rel;
}

// Get localized value
function _getLocalizeValue(_,data) {
	var locCode = (globals.context.sessionLocale || locale.current).toLowerCase();
	if (locCode && data && data.hasOwnProperty(locCode) && data[locCode]) return data[locCode];
	if (data && data.hasOwnProperty("default")) return data["default"];
}


// Get property value function of type  
function _getValueByType(_,prop,data) {
	if (prop) {	
      if ((prop.$type == "binary") || (prop.$type == "image")) return "binary";
	  if (prop.$type == "json") return JSON.stringify(data, null, 1);
      if (prop.$enum) {
		  var enumVal;
		  if (typeof prop.$enum === "function")	
		    enumVal = prop.$enum(_, null)
		  else 
		    enumVal = prop.$enum; 	
		  var e = enumVal.find(function(e){return e.$value == data}); 
		  if (e) return (!e.$title)?e.$value:e.$title;
	  }
	  if (prop.$isArray) {
	    return Array.isArray(data) ? data.join() : data;
  	  } 
	
      if (prop.$isLocalized) {
	     return _getLocalizeValue(_,data);
	  }
	}
	else if (data.hasOwnProperty("default")) {
	   return _getLocalizeValue(_,data);
	}
	
	return data
	
}

// Get object description according to the template defined at the entity level
function _getValueFromTemplate(_, instance, propName, obj) {
	if ((!obj) || (Object.keys(obj).length === 0)) return;
	var template;
	var targetEntity;
    if (obj.$type) {
		targetEntity = instance.getLoggedEntity(_,obj.$type);
	}
	else {
		var prop = _getProperty(_, instance.getLoggedEntity(_), propName);
		targetEntity = prop && prop.targetEntity;
	}

	if (!targetEntity) { 
		var d = JSON.stringify(obj, null, 5);
		d = d.replace(/[\[\]\{\}\"]+/g, '').replace(/,\n|,$/g, '\n').replace(/^\s*\n/gm, '');
	    return d
	}
	 
	template = targetEntity.$valueTemplate;

	if (!template) return "undefined";
	var res = template.expression;
	if (!template.matches) return res;
	template.matches.forEach_(_, function(_, match) {
		var pName = match.substring(1, match.length - 1);
        var val = obj;
		var segs = pName.split(".");
		var seg;
		for(var i=0; i < segs.length ; i++){
		  seg = segs[i];		  	 			  
          val = val && val[seg];		 		  			     
        }
        // if have type information start from last segment
		propName = obj.$type? propName.split(".").slice(-1)[0]: propName;
	    var prop; 
	    if (obj.$type) {	
		  prop = _getProperty(_, instance.getLoggedEntity(_,obj.$type),pName);
		}
		else { 
		  prop = _getProperty(_, instance.getLoggedEntity(_,null), propName + '.' + pName);
		}		
		if (val && val.$value) 
		  val = _getValueByType(_,prop,val.$value)		
		else if (val && val.$prev) 
		  val = _getValueByType(_,prop,val.$prev)
        else 
		  val = _getValueByType(_,prop,val); 
		res = res.replace(match, val);
		
	});
	return res;

}

// Get the list of history log items (property,new value, previous value) for a fistory log instance
function _getHistoryLogItems(_, instance) {
	var result = [];
	var delta = instance.delta(_);
	var d;
	for (var key in delta) {					
		var prop = _getProperty(_, instance.getLoggedEntity(_), key);
		
		if (key.substring(0,1) == '$') continue;
		if (prop && prop instanceof entities.Property && (delta[key].$value || delta[key].$prev)) {							
			result.push({
				property:  prop.getTitle(),
				oldValue:  _getValueByType(_,prop,delta[key].$prev),
				newValue:  _getValueByType(_,prop,delta[key].$value),						
			});
		} else if (_isCollection(delta[key])) {						
			d = JSON.stringify(_propertyToText(_, instance, delta[key], key), null, 5);
			d = d.replace(/[\[\]\{\}\"]+/g, '').replace(/,\n|,$/g, '\n').replace(/^\s*\n/gm, '');

			result.push({
				property: prop.getTitle(),
				newValue: locale.format(module, "itemChanges",
					delta[key].filter(item => item.$added).length,
					delta[key].filter(item => item.$deleted).length,
					delta[key].filter(item => !item.$deleted && !item.$added && _hasModifiedProperties(item)).length),
				description: d

			});

		} else if (_isReference(delta[key])) {			
			result.push({
				property: prop.getTitle(),
				oldValue: _getValueFromTemplate(_, instance, key, delta[key].$prev),
				newValue: _getValueFromTemplate(_, instance, key, delta[key].$value),				
			});
		}
	}
	return result;
}

// History log entity
exports.entity = {
	$canCreate: false,
	$canDelete: false,
	$canEdit: false,
	$titleTemplate: "History log",
	$valueTemplate: "{type}",
	$descriptionTemplate: "{type}",
	$showMeta: "$creUser,$creDate",
	$properties: {
		name: {
			$title: "Entity name",
			$type: "string",
			$linksToDetails: true
		},
		value: {
			$title: "Value",
			$type: "string",
		},
		op: {
			$title: "Operation",
			$type: "string",
			$isMandatory: true,
			$isReadOnly: true,
			$enum: [{
				$value: "del",
				$title: "Deleted"
			}, {
				$value: "add",
				$title: "Created"
			}, {
				$value: "mod",
				$title: "Modified"
			}],
		},
		type: {
			$title: "Type",
			$type: "string"
		},
		delta: {
			$title: "Delta",
			$type: "object"
		},
		changes: {
			$title: "Changes",
			$type: "string",
			$format: "html",
			$compute: function(_, instance) {}
		},
		jsonDelta: {
			$title: "JSON Delta",
			$type: "string",
			$compute: function(_, instance) {
				return JSON.stringify(instance.delta(_), null, 3);
			}			

		}
	},
    $defaultOrder: [
		["$creDate", false]
	],
	$relations: {
		items: {
			$title: "Changes",
			$type: "historyLogItems",
			$isChild: true,
			$compute: true
		}
	},

	$functions: {
		getLoggedEntity: function(_,type) {
			var self = this;
			if (type)
			  return self._db.model.getEntity(_, type)
			else  
			  return self._db.model.getEntity(_, self.name(_));
		},
		$serialize: function(_) {
			let res = this._internalSerialize(_);
			res.items = _getHistoryLogItems(_, this);
			return res;
		}
	},

	$expire: function(_, instance) {
		var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
		var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {});
		if (setting && setting.historyMaxDays(_))
			return setting.historyMaxDays(_) * 24 * 3600 * 1000;
	}
};

// Check if the instance are allowed to be traced according to the traceability settings
function _allowLogHistory(_, instance) {
	if (instance._meta.name == "historyLog") return false;
	if (instance._meta.name == "setting") return true;
	if (instance._relation && instance._relation.getIsChild()) return false;
	if (!entitiesToLog) {
		secProfile = secProfile || JSON.parse(fs.readFile(fsp.join(__dirname, "../security/historySetting.json"), _));
		entitiesToLog = [];
		var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
		var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {});
		setting.historyLogSettings(_).toArray(_)
			.filter_(_, function(_, hls) {
				return hls.enable(_);
			})
			.forEach_(_, function(_, hls) {
				for (var key in secProfile[hls.code(_)].entities)
					if (entitiesToLog.indexOf(key) === -1) {
						entitiesToLog.push(key);
					}
			});
	}
	return (entitiesToLog.indexOf(instance._meta.name) !== -1);
}

// Log update and create objects in database
function _logHistory(_, instance, param) {
	if (!_allowLogHistory(_, instance)) return;
	var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
	var op = "mod";
	if (instance.$created) op = "add";
   	var deltaSerializer = new serializer.DeltaSerializer();
	var delta = deltaSerializer.serialize(_, instance, null, true);
	if (!_hasModifiedProperties(delta))  return;
	
	var hl = db.getEntity(_, "historyLog").createInstance(_, db);
	hl.name(_, instance._meta.name);
	hl.op(_, op);
	hl.value(_, instance.getValue(_));
	hl.delta(_, delta);
	hl.save(_);
}

// Log delete objects in database
function _logDeleteHistory(_, instance) {
	if (!_allowLogHistory(_, instance)) return;
 	var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
 
	var deltaSerializer = new serializer.DeltaSerializer();
	var delta = deltaSerializer.serialize(_, instance, null, true);

	var hl = db.getEntity(_, "historyLog").createInstance(_, db);	
	hl.name(_, instance._meta.name);
	hl.op(_, "del");
	hl.value(_, instance.getValue(_));
	hl.delta(_, delta);
	hl.save(_);
}

exports.reloadHistoryRights = function(_) {
	entitiesToLog = null;
}

// Register model events afterSave and afterDelete
exports.registerModelEvents = function(_, config) {
	try {
		var model = adminHelper.getCollaborationEndpoint(_).getModel(_, false);
		model && model.registerEvent(_, "$afterSave", "logHistory", _logHistory);
		model && model.registerEvent(_, "$afterDelete", "logDeleteHistory", _logDeleteHistory);
	} catch (e) {
		console.log("Cannot register history model events " + e);
		return;
	}


};