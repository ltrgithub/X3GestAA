"use strict";

import * as sys from 'util';
const locale = require('streamline-locale');
var fs = require('streamline-fs');
var fsp = require('path');
var globals = require('streamline-runtime').globals;
var adminHelper = require("../helpers").AdminHelper;
var config;
var config;

export const entity = {
	$canCreate: false,
	$canDelete: false,
	$helpPage: "Administration-reference_Global-Settings",
	$properties: {
		code: {
			$title: "Code"
		},
		authentication: {
			$title: "Authentication",
			$enum: require('../../../src/auth/helpers').authEnum(true),
			defaultValue(_, instance) {
				var config = require("config");
				var method = (config && config.session && config.session.auth) || "basic";
				if (Array.isArray(method)) method = method[0];
				return method;
			},
			$isMandatory: true
		},
		patchLock: {
			$title: "Patch system locked",
			$type: "boolean",
			$isNullable: true,
			$default: false
		},
		proxy: {
			$title: "Proxy server",
			$type: "boolean",
			$default: false,
			$isNullable: true
		},
		traceMaxFiles: {
			$title: "Maximum number of files",
			$description: "Changes on traces maximum size will not be applied on existing records.",
			$type: "integer",
			$minimum: 3,
			$minimumCanEqual: true,
			$default: 5
		},
		traceMaxSize: {
			$title: "Maximum size (not compressed) of files",
			$description: "Changes on traces maximum files number will not be applied on existing records.",
			$pattern: "^(\\d+)([mMkKgG]?)$",
			$patternMessage: "Maximum size can be set with (k), (m) or (g) characters",
			$default: "10M",
			$isReadOnly: true
		},
		traceMaxDays: {
			$title: "Maximum days",
			$description: "Maximum number of days to keep automatic records.",
			$type: "integer",
			$default: 5,
			$propagate(_, instance, value) {
				instance.traceMaxDaysChanged(_, true);
			}
		},
		traceMaxDaysChanged: {
			$type: "boolean",
			$default: false
		},
		webServiceWarnThreshold: {
			$title: "Web service warning threshold",
			$description: "When this percentage of the licensed limit is exceeded, a notification will be sent",
			$type: "integer",
			$default: 75,
		},
		endpoint: {
			$title: "Synchronization endpoint"
		},
		conflictPriority: {
			$title: "Conflict priority",
			$type: "integer",
			$maximum: 9,
			$minimum: 1,
			$default: 5
		},
		twoDigitYearMin: {
			$title: "Lower bound of two-digit year expansion interval",
			$type: "integer",
			$compute(_, instance) {
				return instance.twoDigitYearMax(_) - 99;
			}
		},
		twoDigitYearMax: {
			$title: "Upper bound of two-digit year expansion interval",
			$isMandatory: true,
			$type: "integer",
			$minimum: 1930,
			$maximum: 9000,
			$default: 2029
		},
		historyMaxDays: {
			$title: "History maximum days",
			$description: "Maximum number of days to keep history records.",
			$type: "integer",
			$minimum: -1,
			$default: 365
		}
	},
	$titleTemplate: "Global settings",
	$valueTemplate: "Global settings",
	$descriptionTemplate: "Global settings",
	$relations: {
		ldap: {
			$title: "Default LDAP server",
			$type: "ldap",
			$isMandatory(_, instance) {
				return instance.authentication(_) === "ldap";
			},
			$isHidden(_, instance) {
				return instance.authentication(_) !== "ldap";
			}
		},
		oauth2: {
			$title: "Default OAuth2 server",
			$type: "oauth2",
			$isMandatory(_, instance) {
				return instance.authentication(_) === "oauth2";
			},
			$isHidden(_, instance) {
				return instance.authentication(_) !== "oauth2";
			}
		},
		saml2: {
			$title: "Default SAML2 server",
			$type: "saml2",
			$isMandatory(_, instance) {
				return instance.authentication(_) === "saml2";
			},
			$isHidden(_, instance) {
				return instance.authentication(_) !== "saml2";
			}
		},
		proxyConf: {
			$title: "Default proxy configuration",
			$type: "proxyConfiguration",
			$isMandatory(_, instance) {
				return instance.proxy(_);
			},
			$isHidden(_, instance) {
				return !instance.proxy(_);
			}
		},
		mailer: {
			$title: "Default mailer",
			$type: "notificationServer",
			$isMandatory: false,
		},
		localePref: {
			$title: "Global default locale",
			$type: "localePreference",
			$isMandatory: false
		},
		historyLogSettings: {
			$capabilities: "",
			$title: "History log",
			$type: "historyLogSettings",
			$isChild: true
		}
	},
	$init: function(_, instance) {
		instance.loadHistorySettingFromFile(_);
	},
	$functions: {
		loadHistorySettingFromFile: function(_) {
			var self = this;
			var profile = JSON.parse(fs.readFile(fsp.join(__dirname, "../security/historySetting.json"), _));
			Object.keys(profile).forEach_(_, function(_, pName) {
				var item = self.historyLogSettings(_).add(_);
				var p = profile[pName];
				item.code(_, pName);
				item.description(_, p.title);
			});
		}
	},
	$events: {
		$beforeSave: [
			function(_, instance) {
				// Remark: Code about changes of tracing settings has been moved to entities/setting-extension.ts within syracuse-trace.
				// has authentication method changed?
				config = config || require('config');
				if (!config.session || !config.session.authAlwaysLogin) {
					var auth = instance.authentication(_);
					var settingsOld = instance._db.fetchInstance(_, instance.getEntity(_), {});
					if (!settingsOld) return;
					var oldAuth = settingsOld.authentication(_);
					if (oldAuth != auth) {
						var duplicates = {};
						if (auth === "basic") auth = "db";
						var condition = 'active eq true and (authentication eq "" or authentication eq "' + auth + '")';
						var cursor = instance._db.createCursor(_, instance._db.getEntity(_, "user"), {
							sdataWhere: condition
						});
						var inst;
						instance.$diagnoses = instance.$diagnoses || [];
						if (auth === "sage-id" || auth === "oauth2" || auth === "saml2") { // find duplicates

							while (inst = cursor.next(_)) {
								var login = inst.login(_);

								var key = inst.email(_) || login;
								// 	do not change authentication of admin user
								if (login === "admin" && inst.authentication(_) === "") {
									if (!_setAdminAuthentication(_, instance, inst, settingsOld)) return false;
								}
								if (key.indexOf('@') > 0) {
									if (key in duplicates) {
										instance.$addError(locale.format(module, "sameEmail", login, duplicates[key], key));
										return false;
									} else
										duplicates[key] = login;

								}
				// has authentication method changed?
				config = config || require('config');
				if (!config.session || !config.session.authAlwaysLogin) {
					var auth = instance.authentication(_);
					var settingsOld = instance._db.fetchInstance(_, instance.getEntity(_), {});
					if (!settingsOld) return;
					var oldAuth = settingsOld.authentication(_);
					if (oldAuth != auth) {
						var duplicates = {};
						if (auth === "basic") auth = "db";
						var condition = 'authentication eq "" or authentication eq "' + auth + '"';
						var cursor = instance._db.createCursor(_, instance._db.getEntity(_, "user"), {
							sdataWhere: condition
						});
						var inst;
						instance.$diagnoses = instance.$diagnoses || [];
						if (auth === "sage-id" || auth === "oauth2" || auth === "saml2") { // find duplicates

							while (inst = cursor.next(_)) {
								var login = inst.login(_);

								var key = inst.email(_) || login;
								// 	do not change authentication of admin user
								if (login === "admin" && inst.authentication(_) === "") {
									if (!_setAdminAuthentication(_, instance, inst, settingsOld)) return false;
								}
								if (key.indexOf('@') > 0) {
									if (key in duplicates) {
										instance.$addError(locale.format(module, "sameEmail", login, duplicates[key], key));
										return false;
									} else
										duplicates[key] = login;

								}
							}
						} else {
							while (inst = cursor.next(_)) {
								var login = inst.login(_);
								var key = inst.email(_) || login;
								// 	do not change authentication of admin user
								if (login === "admin" && inst.authentication(_) === "") {
									if (!_setAdminAuthentication(_, instance, inst, settingsOld)) return false;
								}
								// here, duplicates[x] is a string which can contain the following characters: L: one user has login 'x',
								// 1: at least one user has email 'x', 2: at least 2 users have email 'x'
								// login is blocked when 'x' appears as login name and also as email for >=2 users
								if (login.indexOf('@') > 0) {
									if (login in duplicates) {
										if (duplicates[login].indexOf("2") >= 0) { // already 2 users with this email: login blocked
											instance.$addError(locale.format(module, "userEmail", login, login));
											return false;
										} else
											duplicates[login] += "L";
									} else
										duplicates[login] = "L";
								}
								if (key.indexOf('@') > 0) {
									var d = duplicates[key];
									if (d) {
										if (d.indexOf("1") >= 0) { // already one user with this email, so this will be second user
											if (d.indexOf("L") >= 0) { // even one user with this login: double email: login blocked
												instance.$addError(locale.format(module, "userEmail", key, key));
												return false;
											} else if (d.indexOf("2") < 0) // otherwise mark second user for this email address
												duplicates[key] += "2";
										} else duplicates[key] += "1"; // append email value
									} else
										duplicates[key] = "1"; // set email value
								}
							}
						}
					}
				}
			}
		]
	}
};
};

// set authentication method for admin user to ensure that admin user can login even after change of global settings
// parameters: settings: new global settings instance (to be stored)
//             user: instance of admin user
//             oldSettings: old global settings intance (from database)
// result: true: changes applied, false: error
function _setAdminAuthentication(_, settings, user, oldSettings) {
	var oldAuth = oldSettings.authentication(_);
	user.authentication(_, oldAuth === 'basic' ? 'db' : oldAuth);
	switch (oldAuth) {
		case "ldap":
			user.ldap(_, oldSettings.ldap(_));
			break;
		case "oauth2":
			user.oauth2(_, oldSettings.oauth2(_));
			break;
		case "saml2":
			user.saml2(_, oldSettings.saml2(_));
			break;
	}
	user.save(_);
	var diags = [];
	user.getAllDiagnoses(_, diags, {
		addEntityName: true,
		addPropName: true
	});
	if (diags.some(function(diag) {
			return diag.$severity === "error";
		})) {
		diags.forEach(function(diag) {
			settings.$diagnoses.push(diag);
		});
		return false;
	} else {
		settings.$diagnoses.push({
			$severity: "info",
			$message: locale.format(module, "adminAuthSet", user.authentication(_))
		});
	}
	return true;
}

export function getInstance(_, db) {	var entity = db.model.getEntity(_, 'setting');
	return entity.fetchInstance(_, db, {});
};

exports.updateHistoryLogSetting = function(_) {
	try {
		var db = adminHelper.getCollaborationEndpoint(_).getOrm(_);
		var entity = db.model.getEntity(_, 'setting');
		var setting = entity.fetchInstances(_, db, {})[0];
		if (setting && setting.historyLogSettings(_).toArray(_).length == 0) {
			if (!setting.historyMaxDays(_)) setting.historyMaxDays(_,365);
			setting.loadHistorySettingFromFile(_);
			setting.save(_);						
		}
	} catch (e) {
		console.log("Error on update history log settings", e);
	}
};

// set authentication method for admin user to ensure that admin user can login even after change of global settings
// parameters: settings: new global settings instance (to be stored)
//             user: instance of admin user
//             oldSettings: old global settings intance (from database)
// result: true: changes applied, false: error
function _setAdminAuthentication(_, settings, user, oldSettings) {
	var oldAuth = oldSettings.authentication(_);
	user.authentication(_, oldAuth === 'basic' ? 'db' : oldAuth);
	switch (oldAuth) {
		case "ldap":
			user.ldap(_, oldSettings.ldap(_));
			break;
		case "oauth2":
			user.oauth2(_, oldSettings.oauth2(_));
			break;
		case "saml2":
			user.saml2(_, oldSettings.saml2(_));
			break;
	}
	user.save(_);
	var diags = [];
	user.getAllDiagnoses(_, diags, {
		addEntityName: true,
		addPropName: true
	});
	if (diags.some(function(diag) {
			return diag.$severity === "error";
		})) {
		diags.forEach(function(diag) {
			settings.$diagnoses.push(diag);
		});
		return false;
	} else {
		settings.$diagnoses.push({
			$severity: "info",
			$message: locale.format(module, "adminAuthSet", user.authentication(_))
		});
	}
	return true;
}
