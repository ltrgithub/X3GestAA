"use strict";

import { helpers } from '@sage/syracuse-core';
import { _, flows } from 'streamline-runtime';
import { adminHelper } from '../collaboration/helpers';
import { globals } from 'streamline-runtime';

const locale = require('streamline-locale');
var tracer = require('@sage/syracuse-core').getTracer("pubsub");
var os = require("os");

// Generic classes to implement publish/subscriber mechanism
class Broker {
  public name;
  public tenantId;
  public channels = {};
  public clients = {};
  constructor(name, tenantId) {
    this.name = name;
    this.tenantId = tenantId || "";
    tracer.debug && tracer.debug("New broker: " + this.fullName);
  }
  public get fullName(): string {
    return this.name + " [" + this.tenantId + "]";
  }
  public connect(_, namespace) { }
  public subscribe(_, topic, callback): Client { return null; }
  public unSubscribe(_, topic) { }
  public publish(_, topic, message) {
    tracer.debug && tracer.debug("Broker publish on " + topic + ", broker=" + this.fullName + ", tenant=" + globals.context.tenantId + ", message=" + JSON.stringify(message));
  }
  public removeChannel(channel) {
    tracer.debug && tracer.debug("Remove channel " + channel.name + ", broker=" + this.fullName + ", tenant=" + globals.context.tenantId);
    delete this.channels[channel.name];
  }

  public publishAndWaitOn(_, pubTopic, message, subTopic) {
    var _subCallback;
    var broker = this;

    function _publish(cb, topic, pmessage) {
      _subCallback = cb;
      broker.publish(function (err) {
        if (err) {
          console.log("Publish got error " + err);
        }
      }, topic, pmessage);

    }
    var client = this.subscribe(_, subTopic || pubTopic, function (_, smessage) {
      _subCallback && _subCallback(null, smessage);
    });

    var data = _publish(_, pubTopic, message);
    client.unSubscribe();
    return data;
  }
}

class Channel {
  public name: string;
  public clients;
  private broker: Broker
  constructor(broker, topic) {
    tracer.debug && tracer.debug("Create channel : " + topic + ", broker=" + broker.fullName + ", tenant=" + globals.context.tenantId);
    this.clients = [];
    this.broker = broker;
    this.name = topic;
  }
  protected addClient(client: Client) {
    this.clients.push(client);
    client.setChannel(this);
    tracer.debug && tracer.debug("Client " + client.id.toString() + " subscribe to channel " + this.name + ", broker=" + this.broker.fullName + ", tenant=" + globals.context.tenantId);
  }
  public removeClient(client: Client) {
    var removeIndex = this.clients.map(function (obj) { return obj.id.toString(); })
      .indexOf(client.id.toString());
    ~removeIndex && this.clients.splice(removeIndex, 1);
    tracer.debug && tracer.debug("Remove client " + client.id + " from channel " + this.name + ", broker=" + this.broker.fullName + ", tenant=" + globals.context.tenantId)
    if (this.clients.length == 0) this.broker.removeChannel(this);
  }

}

class Client {
  public hostname: String;
  public id;
  protected channel: Channel;
  protected callback;
  protected broker;
  public unSubscribe() {
    this.channel.removeClient(this);
  };
  public setChannel(channel: Channel) {
    this.channel = channel;
  }
}

// Factory method to deliver a brocker singleton instance 
const _brokers = {};
export function getBroker(_) {
  const tenantId = globals.context.tenantId || "";
  let broker = _brokers[tenantId];
  if (broker) return broker;
  tracer.debug && tracer.debug("Creating broker for tenant '" + tenantId + "'");
  broker = _brokers[tenantId] = new BrokerDB(tenantId);
  let db = adminHelper.getCollaborationOrm(_);
  broker.initDatabase(_, db);
  return broker;
}


// DB broker implementation using MongoDB capped collection
// The comunication pass trough a mongo collection (dbMessage) and every new insert
// will be trigger an event used to call specific client functions

class ClientDB extends Client {
  constructor(broker, callback) {
    super();
    this.callback = callback;
    this.broker = broker;
  }

  public start(_): Client {
    var res = this.broker.getCollection().insertOne({ "channel": "$sys", "message": { "type": "subscribe", "data": { host: os.hostname(), "pid": process.pid } }, "time": new Date().toISOString() }, _);
    this.id = res.insertedId;
    tracer.debug && tracer.debug("Start client " + this.id.toString() + ", broker=" + this.broker.fullName + ", tenant=" + globals.context.tenantId);
    return this;
  }
}


class ChannelDB extends Channel {
  protected stream;
  constructor(broker, topic, startId) {
    super(broker, topic);
    this.clients = [];
    var condition = {
      channel: topic,
      _id: { $gt: startId}
    };
    this.stream = broker.getCollection().find(condition, { tailable: true, numberOfRetries: Number.MAX_VALUE, tailableRetryInterval: 200, noCursorTimeout: true, awaitData: true }).stream();
  }

  public start(_): Channel {
    var channel = this;
    tracer.debug && tracer.debug("Start channel " + this.name + "(" + this.clients.length + "), broker=" + this.broker.fullName + ", tenant=" + globals.context.tenantId);
    this.stream.on('data', function (data) {
      tracer.debug && tracer.debug("Received on " + channel.name + JSON.stringify(data.message) + ", broker=" + channel.broker.fullName + ", tenant=" + globals.context.tenantId);
      (_ => {

        for (var i = 0; i < channel.clients.length; i++) {
          var client = channel.clients[i];
          client.callback(_, JSON.parse(data.message));
          tracer.debug && tracer.debug("Client " + client.id.toString() + " received " + JSON.stringify(data.message) + ", broker=" + channel.broker.fullName + ", tenant=" + globals.context.tenantId);
        }
      })(flows.check);
    });
    this.stream.on('close', function () { tracer.debug && tracer.debug("Close cursor on " + channel.name + ", broker=" + channel.broker.fullName + ", tenant=" + globals.context.tenantId) });
    this.stream.on('error', function (err) { console.log("Error on", channel.name, err) });
    return this;
  }
}

export class BrokerDB extends Broker {
  protected db;
  protected stream;
  protected collection;
  constructor(tenantId) {
    super("Mongo DB broker", tenantId);
  }

  public initDatabase(_, db) {
    //console.log("Using database",db.db);
    this.db = db.db;
    this.collection = this.collection || this.db.createCollection("dbMessage", { "capped": true, "size": 100000, "max": 1000 }, _);
  }

  public getCollection() {
    return this.collection;
  }

  public subscribe(_, topic, callback): Client {
    tracer.debug && tracer.debug("Broker subscribe " + topic + ", broker=" + this.fullName + ", tenant=" + globals.context.tenantId);
    var wrapper = function () {
      tracer.debug && tracer.debug("Calling subscribe callback: tenantId='" + globals.context.tenantId + "', message=" + JSON.stringify(arguments[1]));
      return callback.apply(this, arguments);
    };

    var client = new ClientDB(this, globals.withContext(wrapper, {
      tenantId: this.tenantId
    }));

    client.start(_);
    var channel = this.channels[topic];
    if (!channel) {
      channel = new ChannelDB(this, topic, client.id);
      this.channels[topic] = channel.start(_);
    }
    channel.addClient(client);
    return client;
  }

  public publish(_, topic, message) {
    this.collection.insertOne({ "channel": topic, "message": JSON.stringify(message), "time": new Date().toISOString() }, _);
    super.publish(_, topic, message);
  }

  public removeChannel(channel) {    
    channel.stream.close();
    super.removeChannel(channel);
  }

}

