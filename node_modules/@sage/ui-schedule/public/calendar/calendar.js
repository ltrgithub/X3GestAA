"use strict";
var Calendar = require("@sage/ui-schedule/public/calendar/baseCalendar").Calendar;
var _ext = require('@sage/syracuse-ui/lib/extend/extendGateway');
var _moment = require("@sage/ui-schedule/public/deps/calendar/moment");
var _globals = require('streamline-runtime').globals;

require("@sage/ui-schedule/public/deps/calendar/calendar");
require("@sage/ui-schedule/public/deps/calendar/planning");

exports.stylesheets = ["/ui-schedule/public/calendar/calendar.css", "/ui-schedule/public/calendar/patternbolt.css"];
exports.create = function (context) {
    var cal = new Calendar();
    cal.applyChange = function (dataRecordSet, parentDataRecord, append, isOverlapping) {
        function validColorIndex(index) {
            return (index % 1 === 0) && index > 0 && index < 21;
        }
        if (parentDataRecord && parentDataRecord.agenda) {
            if (append && this._events.length) {
                for (var ii = 0; ii < this._events.length; ii++) {
                    var ev = this._events[ii];
                    if (ev.isOverlapping) {
                        ev.splice(ii, 1);
                    }
                }
            }
            var $events = parentDataRecord.agenda.$events;
            for (var ii = 0, jj = $events.length; ii < jj; ii++) {
                var event = $events[ii];
                var hasStart = false, hasEnd = false;
                if (event.start.datetime && event.start.datetime.length) {
                    event.start.datetime = _ext.culture.datetime.parse(event.start.datetime).toString();
                    hasStart = true;
                }
                if (event.end.datetime && event.end.datetime.length) {
                    event.end.datetime = _ext.culture.datetime.parse(event.end.datetime).toString();
                    hasEnd = true;
                }
                if (hasStart || hasEnd) {
                    var fcEvent = {
                        title: event.summary,
                        subtitle: event.subtitle,
                        description: event.description,
                        id: event.id,
                        isOverlapping: isOverlapping,
                        category: validColorIndex(event.category) ? event.category : 0,
                        color: validColorIndex(event.color) ? event.color : 0
                    };
                    if (!hasStart) {
                        // We don't have a start datetime, so make the start datetime the same as the end datetime, then increment the endtime by 1 minute.                
                        fcEvent.start = event.end.datetime;
                        fcEvent.actualEnd = _moment(fcEvent.start);
                        fcEvent.end = _ext.culture.datetime.parse(fcEvent.start).addMinutes(30).toString();
                    }
                    else {
                        if (!hasEnd) {
                            //  We don't have an end datetime, so make the end datetime 1 minute after the start datetime
                            fcEvent.start = event.start.datetime;
                            fcEvent.actualEnd = _moment(fcEvent.start);
                            fcEvent.endFormat = "application/x-date";
                            fcEvent.end = _ext.culture.datetime.parse(fcEvent.start).addMinutes(30).toString();
                        }
                        else {
                            var startDate = _ext.culture.datetime.parse(event.start.datetime);
                            var endDate = _ext.culture.datetime.parse(event.end.datetime);
                            if (startDate > endDate) {
                                //  With some X3 requests, we get the event endtime starting before the starttime!
                                //  In this case, make the end date the same as the start date.
                                fcEvent.start = event.start.datetime;
                                fcEvent.actualEnd = _moment(fcEvent.start);
                                fcEvent.endFormat = "application/x-date";
                                fcEvent.end = _ext.culture.datetime.parse(fcEvent.start).addMinutes(30).toString();
                            }
                            else {

                                var startHour = new Date(event.start.datetime).getUTCHours();
                                var startMinutes = new Date(event.start.datetime).getMinutes();
                                var endHour = new Date(event.end.datetime).getUTCHours();
                                var endMinutes = new Date(event.end.datetime).getMinutes();

                                if (startHour === 0 && startMinutes === 0 && endHour === 0 && endMinutes === 0) {
                                    fcEvent.start = event.start.datetime;
                                    // A one-day all-day event from the server is from 00:00 to 00:00 on the SAME day.
                                    //  So, we need to add 24 hours to the end date that we get from the server.
                                    fcEvent.end = _ext.culture.datetime.parse(event.end.datetime).addDays(1).toString();
                                    fcEvent.actualEnd = _moment(fcEvent.end);
                                    fcEvent.allDay = true;
                                }
                                else {
                                    fcEvent.start = event.start.datetime;
                                    fcEvent.actualEnd = _moment(event.end.datetime);
                                    var duration = Math.round(_ext.culture.datetime.parse(event.end.datetime).millisDiff(_ext.culture.datetime.parse(event.start.datetime)) / 60000);
                                    fcEvent.end = (duration < 30) ? _ext.culture.datetime.parse(fcEvent.start).addMinutes(30).toString() : event.end.datetime;
                                }
                            }
                        }
                    }
                    this._events.push(fcEvent);
                }
            }
        }
        if (this.rerender) {
            this._widget.fullCalendar('render');
            this.rerender = false;
        }
        this._widget.fullCalendar('refetchEvents');
    };

    cal._addLegend = function (data) {
        if (data && $(this._widget[0].parentElement).children(".s-fc-header").length === 0){
            var keys = Object.keys(data);
            if (keys.length) {
                var header = _ext.dom.div("s-fc-header");
                for (var ii = 0, jj = keys.length; ii < jj; ii++) {
                    var icon = document.createElement("span");
                    icon.className = "s-fc-header-day-type-" + (ii + 1) + " s-legendwhiteborder";

                    var desc = document.createElement("span");
                    desc.className = "s-fc-header-day-type";
                    desc.textContent = data[keys[ii]];

                    var legend = document.createElement("span");
                    legend.className = "s-fc-legend";
                    legend.appendChild(icon);
                    legend.appendChild(desc);
                    header.appendChild(legend);
                }
                this.context.div.insertBefore(header, this._widget[0]);
            }
        }
    };
    cal._addPreviousNextArrows = function (event, element, view) {
        var self = this;
        if (view.dateToDayOffset(event.start) < 0) {
            view.segEach(function (seg) {
                if ((seg.row == 0) && seg.el == element) {
                    var startEvent = event.start ? event.start : event.actualStart;
                    var text = _ext.culture.datetime.parse(startEvent._i, startEvent.f).toString(_ext.culture.format.getDate());
                    text = self.locale.plcal_start + " " + text;
                    element[0].firstChild.insertBefore(_ext.item.addIndicator(self.context, {
                        text: text,
                        css: "fc-previous-arrow",
                        fontIcon: "left_arrow",
                        title: self.$categoryLegend && self.$categoryLegend.legend[event.category]
                    }).link, null);
                }
            }, event);
        }
        //next
        if (view.dateToDayOffset(event.end) >= (view.rowCnt * view.colCnt)) {
            view.segEach(function (seg) {
                if ((seg.row == view.rowCnt - 1) && seg.el == element) {
                    var endEvent = event.end ? event.end : event.actualEnd;
                    var text = _ext.culture.datetime.parse(endEvent._i, endEvent.f).toString(_ext.culture.format.getDate());
                    text = self.locale.plcal_end + " " + text;
                    _ext.item.addIndicator(self.context, {
                        slot: element[0].firstChild,
                        text: text,
                        css: "fc-next-arrow",
                        fontIcon: "right_arrow",
                        title: self.$categoryLegend && self.$categoryLegend.legend[event.category]
                    });
                }
            }, event);
        }
    };
    cal.setValue = function (dataRecordSet, metaData, parentDataRecord) {
        this._events = [];
        var agenda = parentDataRecord && parentDataRecord.agenda;
        if (agenda) {
            var $calendar = agenda.$calendars[0];
            if ($calendar) {
                $calendar.$colorLegend && this._addLegend($calendar.$colorLegend.legend);
                this.$categoryLegend = $calendar.$categoryLegend;
                this.applyChange(dataRecordSet, parentDataRecord, metaData);
            }
        }
        this._createWidget();
    };
    cal._createWidget = function () {
        var self = this;
        self.calendar = self._widget.fullCalendar({
            lang: _ext.culture.format.currentLangCode,
            aspectRatio: self._ASPECT_RATIO,
            defaultView: self.context.design.$calendarView,
            header: {
                left: 'prev,next,today',
                center: 'title',
                right: 'month,agendaWeek,basicWeek,agendaDay,basicDay'
            },
            monthNames: self.monthNames,
            monthNamesShort: self.monthNamesShort,
            dayNames: self.dayNames,
            dayNamesShort: self.dayNamesShort,
            allDayHtml: self.locale.plcal_allday,
            eventLimitText: self.locale.plcal_more,
            firstDay: _globals.context.localePreferences.firstDayOfWeek === undefined ? 1 : _globals.context.localePreferences.firstDayOfWeek,
            axisFormat: 'H(:mm)',
            timeFormat: 'H:mm',
            //timezone: 'local',
            slotEventOverlap: false,
            buttonText: {
                month: self.locale.plcal_month,
                week: self.locale.plcal_week,
                day: self.locale.plcal_day,
                today: self.locale.plcal_today
            },
            eventClick: function (calEvent, jsEvent, view) {
                self._toggleEventOver(calEvent, jsEvent);
                return false;
            },
            eventAfterAllRender: function () {
                $('.fc-more').each(function (index, elem) {
                    elem.text = elem.text.slice(1);
                });
            },
            eventMouseover: function (event, jsEvent, view) {
            },
            eventAfterRender: function (event, element, view) {
                element.addClass("s-fc-color-type-" + event.color);
                var childNode = element[0].firstChild; // childNode == fc-content
                var infoDiv = _ext.dom.div("s-fc-info");
                var nodes = childNode.childNodes;
                if (event.allDay) {
                    for (var i = 0; i < nodes.length;) {
                        infoDiv.appendChild(nodes[i]);
                    }
                } else {
                    for (var i = 0; i < nodes.length; i++) {
                        infoDiv.appendChild(nodes[i]);
                    }
                }
                childNode.appendChild(infoDiv);

                if (event.category > 0) {
                    childNode.insertBefore(_ext.dom.div("ted pb-pattern o-lines-bold s-fc-status s-fc-status-color-" + event.category), childNode.firstChild); // add status div as a first child of fc-content.
                }
                self._addPreviousNextArrows(event, element, view);
            },
            viewRender: function (view) {
                if (self.calendar) {
                    var selected = self.calendar.fullCalendar("getView").name;
                    self.$pagePreferences = {
                        $calendarView: self.context.design.$calendarView = selected
                    };
                    _ext.preference.save(self.context, self.$pagePreferences);
                }
                var $$right = $('.fc-right');
                var $$btn = $('.fc-button.fc-agendaWeek-button.fc-state-default', $$right);
                $$btn.text(self.locale.plcal_week);
                $$btn.prepend('<span class="fc-tab-icon s-fonticon-btn">' + _ext.icon.font.time + '</span>');

                $$btn = $('.fc-button.fc-agendaDay-button.fc-state-default', $$right);
                $$btn.text(self.locale.plcal_day);
                $$btn.prepend('<span class="fc-tab-icon s-fonticon-btn">' + _ext.icon.font.time + '</span>');

            },
            selectable: true,
            selectHelper: false,
            defaultDate: new Date(),
            eventLimit: true,
            events: function (start, end, timezone, callback) {
                /*
                 * We're disabling paging for the moment, as requests do not currently support the "or" operator.
                 * This is required in order to include events that do not start and/or end within the page,
                 * but traverse the page.
                 */
                // if (planning.$field.$filter && planning._isFetchNeeded()) {
                // 	planning._fetchCalendarEvents();
                // }
                callback(self._events || []);
            }
        });
        if (!self._widget.is(':visible')) {
            /*
             * If the parent slot is not visible, fullCalendar will not initialise propertly.
             * This can result in exceptions being thrown if an attempt is then made to refresh events.
             */
            self.rerender = true;
        }
    };
    cal.load(context);
    return cal;
};