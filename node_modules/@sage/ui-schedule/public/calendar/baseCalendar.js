"use strict";
var _ext = require('syracuse-ui/lib/extend/extendGateway');
var _locale = require('streamline-locale');

var _ASPECT_RATIO = 2.5;

var _eventPopup;

function Calendar(){

}

Calendar.prototype._isFetchNeeded = function(){
    var view = this._widget.fullCalendar('getView');
    if (this.startDateFetchedEvents && this.endDateFetchedEvents) {
        var range = this._fetchDataRange(view);
        return range.start.isBefore(this.startDateFetchedEvents) || range.end.isAfter(this.endDateFetchedEvents);
    }
    return true;
};
Calendar.prototype._fetchCalendarEvents = function(){
    var view = this._widget.fullCalendar('getView');
    var where = "";
    var filterStartProp = this.context.prototype.$filter.start[0];
    var filterEndProp = this.context.prototype.$filter.end[0];
    var range = this._fetchDataRange(view);
    
    function dateFilterRightValue(date){
        return '@' + date.format('YYYY-MM-DD') + '@';
    }
    
    /*
     * TODO -  Deal with events with end dates within the range, but start dates out of the range!
     */
    if (this.startDateFetchedEvents && this.endDateFetchedEvents) {
    
        if (range.start.isBefore(this.startDateFetchedEvents)) {
            where = "&where=((" + filterStartProp + " GE " + dateFilterRightValue(range.start) + ") and " +
            "(" +
            filterStartProp +
            " LT " +
            dateFilterRightValue(this.startDateFetchedEvents) +
            "))";
            
            this.startDateFetchedEvents = range.start;
            this._fetch(where, true);
        }
        
        if (range.end.isAfter(this.endDateFetchedEvents)) {
        
            where = "&where=((" + filterStartProp + " GT " + dateFilterRightValue(this.endDateFetchedEvents) + ") and " +
            "(" +
            filterStartProp +
            " LE " +
            dateFilterRightValue(range.end) +
            "))";
            
            this.endDateFetchedEvents = range.end;
            this._fetch(where, true);
        }
        
    }
    else {
        where = "&where=((" + filterStartProp + " GE " + dateFilterRightValue(range.start) + ") and " +
        "(" +
        filterStartProp +
        " LE " +
        dateFilterRightValue(range.end) +
        "))";
        
        this.startDateFetchedEvents = range.start;
        this.endDateFetchedEvents = range.end;
        this._fetch(where, false);
    }
    
    /*
     * We also need to look for long events that start before and end after the fetched range.
     * These will be regenerated each time we send a request to prevent any potential event duplications.
     */
    where = "&where=((" + filterStartProp + " LT " + dateFilterRightValue(range.start) + ") and " +
    "(" +
    filterStartProp +
    " GT " +
    dateFilterRightValue(range.end) +
    "))";
    
    this._fetch(where, true, true);
};

Calendar.prototype._fetchDataRange = function(view){
    var range = {};
    /*
     * The month view is a special case - the intervalStart date is not always the first cell in the view.
     * Additionaly, the intervalEnd is not always the last cell in the view.
     * We have to show events in the previous and next month cells, so we have to compute the date of the
     * first cell in month - 1 and the date of the last cell in month + 1
     */
    if (view.name === 'month') {
        var cellsPerView = view.rowCnt * view.colCnt;
        var firstDateInLastView = view.incrementDate(view.intervalStart, -1);
        range.start = firstDateInLastView.subtract(firstDateInLastView.weekday(), 'days');
        var firstDateInNextView = view.incrementDate(view.intervalStart, 1);
        range.end = firstDateInNextView.add(cellsPerView - firstDateInNextView.weekday() - 1, 'days');
    }
    else {
        range.start = view.intervalStart;
        range.end = view.intervalEnd;
    }
    return range;
};

Calendar.prototype._fetch = function(where, append, isOverlapping){
    var self = this;
    _ext.ajax.get({
        url: self.context.field.page.$field.$representationUrl + where,
        success: function(data, response){
            if (data.agenda.$events.length > 0) {
                self.applyChange(data, data, null, append, isOverlapping);
            }
        }
    });
};
Calendar.prototype._draw = function(){
    this._widget = $(this.context.div.appendChild(document.createElement("div")));
};
Calendar.prototype.isFiltersActive = function(parentDataRecord){
    var filterProp = (parentDataRecord.agenda.$calendars[0]).$pageFilter;
    var startFilterProp = filterProp.start[0];
    var endFilterProp = filterProp.end[0];
    var $criteria = this.context.field.page.$prototype.$properties.$criteria;
    return startFilterProp &&
    $criteria &&
    $criteria.$item.$properties[startFilterProp] &&
    endFilterProp &&
    $criteria.$item.$properties[endFilterProp];
};
Calendar.prototype.load = function(context){
    this._ASPECT_RATIO = _ASPECT_RATIO;
    this.monthNames = [];
    this.monthNamesShort = [];
    for (var ii = 1; ii <= 12; ii++) {
        this.monthNames.push(_ext.culture.date.monthName(ii));
        this.monthNamesShort.push(_ext.culture.date.monthName(ii, true));
    }
    this.dayNames = [];
    this.dayNamesShort = [];
    for (var ii = 0; ii <= 6; ii++) {
        this.dayNames.push(_ext.culture.date.dayName(ii));
        this.dayNamesShort.push(_ext.culture.date.dayName(ii, true));
    }
    
    this.locale = _locale.resources(module)();
    context.field.page.defaultItemsPerPage = 500;
    if (context.field.page.vignetteField) {
        context.field.page.vignetteField.isDesignModeEnabled = false;
        context.field.page.vignetteField.toggleMenuButton(false);
    }
    this.context = context;
    this._draw();
};
Calendar.prototype.resize = function(){
    var self = this;
    self.resizeTimer = setTimeout(function(){
        if (self.calendar && self._widget) {
            // width minus 1 because of scrollbar issue on firefox
            var width = self.calendar.width();
            width = Math.max(width ? width : 0, self.context.div.clientWidth) - 1;
            self._widget.attr('style', 'width: ' + width + 'px; margin: 0 auto;');
            if (self.usingPlanningCalendar) {
                self._widget.planningFullCalendar('option', 'aspectRatio', self._ASPECT_RATIO);
            }
            else {
                if (self.rerender) {
                    self._widget.fullCalendar('render');
                    self.rerender = false;
                }
                self._widget.fullCalendar('option', 'aspectRatio', self._ASPECT_RATIO);
                
                $('.fc-more').each(function(index, elem){
                    elem.text = elem.text.slice(1);
                });
            }
        }
    }, 200);
};
Calendar.prototype._toggleEventOver = function(calEvent, jsEvent){
    if (!calEvent) {
        _eventPopup && _eventPopup.popup.close();
        _eventPopup = null;
    }
    else {
        if (_eventPopup) {
            var target = _eventPopup.target;
            this._toggleEventOver();
            if (target == jsEvent.target || target == jsEvent.target.parentNode) 
                return;
        }
        _eventPopup = {
            slot: _ext.dom.div("s-agenda-tip"),
            target: jsEvent.target
        };
        var css = _eventPopup.target.parentNode.className;
        if (css.indexOf("fc-time") >= 0 || css.indexOf("fc-title") >= 0) {
            _eventPopup.target = _eventPopup.target.parentNode;
        }
        
        _ext.dom.text("s-agenda-tip-title", calEvent.title, _eventPopup.slot);
        _ext.dom.text("s-agenda-tip-subtitle", calEvent.subtitle, _eventPopup.slot);
        
        var period = _ext.dom.div("s-agenda-tip-period", _eventPopup.slot);
        if (calEvent.category > 0) {
            _ext.dom.div("ted pb-pattern o-lines-bold s-fc-tip-status s-fc-status-color-" + calEvent.category, period);
        }
        else {
            period.className += " s-fc-status-color-0";
        }
        var dt = _ext.dom.div("s-agenda-tip-period-dt", period);
        _ext.dom.text("s-agenda-tip-period-dt-lb", this.locale.plcal_start, dt);
        var text = _ext.culture.datetime.parse(calEvent.start._i, calEvent.start.f).toString(_ext.culture.format.getDatetime() + "Z").slice(0, -1);
        _ext.dom.text("s-agenda-tip-period-dt-val", text, dt);
        
        dt = _ext.dom.div("s-agenda-tip-period-dt", period);
        _ext.dom.text("s-agenda-tip-period-dt-lb", this.locale.plcal_end, dt);
        var text = _ext.culture.datetime.parse(calEvent.actualEnd._i, calEvent.actualEnd.f);
        if (calEvent.endFormat) {
            text = text.toString(_ext.culture.format.get(calEvent.endFormat));
        }
        else {
            text = text.toString(_ext.culture.format.getDatetime() + "Z").slice(0, -1);
        }
        _ext.dom.text("s-agenda-tip-period-dt-val", text, dt);
        
        
        if (calEvent.description) {
            var description = _ext.dom.div("s-agenda-tip-description", _eventPopup.slot);
            _eventPopup.record = _ext.item.addRecord({
                $prototype: this.context.prototype.$item,
                page: this.context.field.page,
                articleParent: this.context.field.articleParent
            });
            var $fields = _eventPopup.record.$prototype.$properties;
            var $binds = Object.keys(calEvent.description);
            var slot = _ext.dom.div("s-agenda-description-inner", description);
            for (var ii = 0, jj = $binds.length; ii < jj; ii++) {
                var $bind = $binds[ii];
                var $details = $fields[$bind].$links && $fields[$bind].$links.$details;
                if ($details) {
                    $details.$target = "blank";
                }
                _ext.item.add(this.context, _ext.dom.div("s-agenda-description-item", slot), {
                    $bind: $bind,
                    $inplace: true
                }, _eventPopup.record);
            }
            _eventPopup.record.applyChange(calEvent.description);
        }
        
        if (calEvent.summary) {
            _ext.dom.text("s-agenda-tip-summary", calEvent.summary, _eventPopup.slot);
        }
        
        _eventPopup.popup = _ext.popup.open({
            slot: _eventPopup.slot,
            position: {
                my: "left top",
                at: "right top",
                of: _eventPopup.target
            },
            close: function(){
                _eventPopup.record && _eventPopup.record.dispose();
                _eventPopup.record = null;
            }
        });
    }
};
Calendar.prototype.dispose = function(){
    this.resizeTimer && clearTimeout(this.resizeTimer);
    this._toggleEventOver();
};

exports.Calendar = Calendar;
