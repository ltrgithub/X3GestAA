import { _ } from 'streamline-runtime';
import * as fs from 'fs';
import * as path from 'path';
import { types } from '@sage/syracuse-core';
const { date } = types;
import * as sync from '../../../etna-etl/lib/sync';
import * as conflictHelper from '../conflictHelper';
import * as supervisor from '@sage/etna/lib/supervisor/supervisor';
import * as ez from 'ez-streams';
import { Tracker, FileStruct } from '../../../etna-etl/lib/exporter';
import { TableDefinition } from '@sage/etna/lib/engine/drivers/types';
type Supervisor = supervisor.Supervisor;

var jsonHelper = require('scm-lib/jsonHelper'),
	productsHelper = require('scm-lib/productsHelper'),
	globalConfig = exports.config = require('../../../../nodelocal').config,
	update = require('syracuse-x3/lib/entities/update');

interface Context {
	db: any;
	request: ez.devices.http.HttpServerRequest;
	tracker: Tracker;
}

interface Instance {
}

interface Endpoint extends Instance {
	dataset(_: _): string;
	getEtnaConfig(_: _): supervisor.Config;
	gitFolder(_: _): string;
}


function _getEndpoint(_: _, context: Context, endPointName: string): Endpoint {
	var db = context.db;
	var endPoints = db.fetchInstances(_, db.getEntity(_, "endPoint"), {}).filter_(_, function (_: _, ep: Endpoint) {
		return ep.dataset(_) === endPointName;
	});

	if (endPoints.length != 1)
		throw new Error("Invalid endPoint name " + endPointName);

	return endPoints[0];
}

function _saveJSonFile(_: _, endPoint: Endpoint, metadataObject: any, filename: string) {
	var entityType = jsonHelper.parseMetaFilename(filename).type;
	var sortedMetadataObject = jsonHelper.sortJsonObject(_, metadataObject, entityType);
	fs.writeFile(filename, JSON.stringify(sortedMetadataObject, null, '\t'), "utf8", _);
}

function _getProductId(_: _, superv: Supervisor) {
	var productId: any;
	try {
		superv.sqlDriver.withConnection(cnx => {
			var row: any = superv.sqlDriver.reader(cnx, "SELECT VALEUR_0 FROM ADOVAL WHERE PARAM_0=" + superv.sqlDriver.param(0), ['TYPDOS']).toArray()[0];
			if (!row)
				throw new Error("Could not detect the productId");
			// REVIEW: shouldn't this be row.VALEUR???
			productId = productsHelper.getProductFromFolderType(parseInt(row.VALEUR_0)).id;
		});
	} catch (err) {
		console.log(err.stack);
		throw new Error("Could not retrieve the productId, reason = " + err.message);
	}
	return productId;
}

export const scmConfig = {
	$titleTemplate: "SCM configuration {name}",
	$valueTemplate: "{name}",
	$summaryTemplate: "SCM configuration {name}",
	$descriptionTemplate: "SCM configuration",
	$className: "scmConfig",
	$isPersistent: false,
	$services: {
		syracuseIsReady: {
			$method: "POST",
			$isMethod: false,
			$title: "Checks whether the Syracuse server is up and ready",
			$execute(_: _, context: Context, instance: Instance): any {
				try {
					var data = JSON.parse(context.request.readAll(_));
					var endPointName = data.endPoint;
					var endPoint = _getEndpoint(_, context, endPointName);

					var etnaConfig = endPoint.getEtnaConfig(_);
					var superv = supervisor.create(etnaConfig);
					var result = true;
					try {
						superv.sqlDriver.withConnection(cnx => {
							superv.sqlDriver.reader(cnx, "select CONTROLFILE_TYPE from v$database").toArray()[0];
						});
					} catch (err) {
						result = false;
					}
					superv.release();
					return {
						isUp: result,
					};
				} catch (err) {
					return {
						error: {
							message: err.message,
							stack: err.stack,
						},
					}
				}
			}
		},
		getColumnsLocalizedLabelCodes: {
			$method: "POST",
			$isMethod: false,
			$title: "Get codes of localized labels of columns",
			$execute(_: _, context: Context, instance: Instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);

				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(etnaConfig);

				var result: any = {
					ids: {},
				};
				try {
					superv.sqlDriver.withConnection(cnx => {
						const rows = superv.sqlDriver.reader(
							cnx,
							"select CODZONE_0, NOLONG_0 from ATABZON where CODFIC_0 = " + superv.sqlDriver.param(0), [data.tablename]).toArray();
						if (!rows)
							throw new Error("Could not read structure of table " + data.tablename);
						result.ids = rows.reduce(function (obj: any, row: any) {
							obj[row.CODZONE_0] = row.NOLONG_0;
							return obj;
						}, {} as any);
					});
				} catch (err) {
					console.log("ERROR", err);
					result = false;
				}
				superv.release();
				return result;
			}
		},

		getProductId: {
			$method: "POST",
			$isMethod: false,
			$title: "Returns the productID of a given endpoint",
			$execute(_: _, context: Context, instance: Instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);

				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(etnaConfig);

				const result = {
					productId: _getProductId(_, superv),
				};
				superv.release();
				return result;
			}
		},

		getSyncInfos: {
			$method: "POST",
			$isMethod: false,
			$title: "Get synchronization infos",
			$execute(_: _, context: Context, instance: Instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);

				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(etnaConfig);

				var createTable = false;
				try {
					// Make sure the settings table exists
					var tableDef = superv.sqlDriver.getTableDef(etnaConfig.folderName, "ASCMSETTINGS");
					createTable = Object.keys(tableDef.columns).length == 0;
				} catch (err) {
					createTable = true;
				}

				if (createTable) {
					var tableDef: TableDefinition = {
						schemaName: etnaConfig.folderName,
						tableName: "ASCMSETTINGS",
						columns: [{
							name: "KEY",
							isNullable: false,
							type: "nvarchar",
							maxLength: 100
						}, {
							name: "VALUE",
							isNullable: true,
							//type: "clob",
							type: "nvarchar",
							maxLength: 4000,
						}],
						indexes: [],
					};
					superv.sqlDriver.createTableFromTableDefinition(tableDef);
				}

				var result = {
					folderName: etnaConfig.folderName,
					lastSyncdSha1: undefined as any,
					productId: undefined as any,
				};


				try {
					superv.sqlDriver.withConnection(cnx => {
						var row: any = superv.sqlDriver.reader(cnx, "SELECT VALUE FROM ASCMSETTINGS WHERE KEY=" + superv.sqlDriver.param(0), ['PATCH.SYNC.LAST.GIT.HEAD']).toArray()[0];
						if (row)
							result.lastSyncdSha1 = JSON.parse(row.VALUE).sha1;
					});
				} catch (err) {
					console.log(err.stack);
					throw new Error("Could not retrieve last sync'd git sha1, reason = " + err.message);
				}

				result.productId = _getProductId(_, superv);

				superv.release();

				return result;
			}
		},

		importToMongo: {
			$method: "POST",
			$isMethod: false,
			$title: "importToMongo",
			$invocationMode: 'async',
			$capabilities: 'abort',
			$execute(_: _, context: Context, instance: Instance) {

				context.tracker.phaseDetail = "Importing to mongoDb";
				context.tracker.$diagnoses = context.tracker.$diagnoses || [];

				var data: {
					fileStructs: FileStruct[];
					fullSync: boolean;
					endPoint: string;
				} = JSON.parse(context.request.readAll(_));
				var endPoint = _getEndpoint(_, context, data.endPoint);
				var rootFolder = endPoint.gitFolder(_);
				console.log("MONGO rootFolder = " + rootFolder);
				// fileStructs is a list of {status:xxx, relativeFilename : xxx}
				var absFileStructs = data.fileStructs.map(function (fileStruct) {
					return {
						status: fileStruct.status,
						absoluteFilename: path.join(rootFolder, fileStruct.relativeFilename),
					};
				});

				var fullSync = data.fullSync;

				// First, only keep the metadata files
				absFileStructs = absFileStructs.filter(function (fileStruct) {
					return jsonHelper.isMetadataFile(fileStruct.absoluteFilename);
				});
				var syncInstance = sync.newSync(_, endPoint, context.tracker);
				syncInstance.importMetadataToMongo(_, absFileStructs, undefined, fullSync);
				return true;
			},
		},

		importPatches: {
			$method: "POST",
			$isMethod: false,
			$title: "importPatches",
			$invocationMode: 'async',
			$capabilities: 'abort',
			$execute(_: _, context: Context, instance: Instance) {
				var body = context.request.readAll(_);
				var data = JSON.parse(body);
				var endPoint = _getEndpoint(_, context, data.endPoint);
				var etnaConfig = endPoint.getEtnaConfig(_);
				var patchFolder = path.join(etnaConfig.solutionPath, etnaConfig.folderName, "SCMPATCH");
				// There is only one patch
				var absoluteFilename = path.join(patchFolder, data.relativePatchNames[0]);

				var description = data.description || (data.fromSha1 + " -> " + data.toSha1);

				var applyResult = update.applyPatches(_,
					context,
					"SCM update " + date.today(true),
					"SCM Patch, imported @" + new Date().toISOString() + " (" + description + ")",
					data.endPoint, [{
						name: absoluteFilename,
						type: "SCM",
						description: description,
						path: absoluteFilename,
					}]);
				return {
					update: {
						uuid: applyResult.update.uuid,
					},
					errorMessage: applyResult.errorMessage,
				};
			},
		},

		getImportTrace: {
			$method: "POST",
			$isMethod: false,
			$title: "return import traces",
			$execute(_: _, context: Context, instance: Instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				var updateUuid = data.updateUuid;
				var db = context.db;
				var updates = db.fetchInstances(_, db.getEntity(_, "update"), {}).filter_(_, function (_: _, update: any) {
					return update.$uuid === updateUuid;
				});

				if (updates.length != 1)
					throw new Error("Invalid update uuid : " + updateUuid);
				var update = updates[0];
				var endPoints = update.endpoints(_).toArray(_, true);
				var folders = endPoints[0].folders(_).toArray(_, true);
				var folder = folders[0];
				var stream = folder.trace(_).createReadableStream(_);
				return {
					html: new Buffer(stream.readAll(_)).toString('utf8'),
				};
			},
		},
		saveResolvedFile: {
			$method: "POST",
			$isMethod: false,
			$title: "save resolved file",
			$execute(_: _, context: Context, instance: Instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				_saveJSonFile(_, endPoint, data.metadataObject, data.filename);
				return {
					result: "OK"
				};
			},
		},
		parseForConflicts: {
			$method: "POST",
			$isMethod: false,
			$title: "parse a file for conflicts",
			$execute(_: _, context: Context, instance: Instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var filename = data.filename;
				var entityType = jsonHelper.parseMetaFilename(filename).type;
				var endPoint = _getEndpoint(_, context, endPointName);
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(etnaConfig);

				// console.log("Parsing file " + filename);
				var result = conflictHelper.parseForConflicts(_, superv, entityType, filename);
				// console.log("Parsing result = " + JSON.stringify(result));

				superv.release();

				// Note : result has the following format : 
				// {
				// 	result: the parsed json
				// 	hasConflicts: whether a conflict was detected,
				// 	atLeastOneConflictFixed: whether at least one conflict was automatically resolved
				// };
				result.entityType = entityType;

				if (result.atLeastOneConflictFixed && !result.hasConflicts) {
					// console.log("Conflicts have been automatically resolved");
					// This file was in conflict but all the conflicts have been resolved automatically.
					if (data.autoSaveFixedFile) {
						// console.log("Save the file");
						// Save the file
						var conflictObject = result.result;
						// conflictObject is a structure that was built to retrieve (and resolve) all the conflicts.
						// We have to transform it back to a metadataObject to be able to save it
						var metadataObject = conflictHelper.rebuildMetadataFile(_, conflictObject);
						_saveJSonFile(_, endPoint, metadataObject, filename);
					}
				}
				return result;
			},
		},
		setLastSyncdGitHead: {
			$method: "POST",
			$isMethod: false,
			$title: "Set last sync'd git head",
			$execute(_: _, context: Context, instance: Instance) {
				var data = JSON.parse(context.request.readAll(_));
				var sha1 = data.sha1;
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(etnaConfig);

				try {
					superv.sqlDriver.withConnection(cnx => {
						superv.sqlDriver.execute(cnx, "delete from ASCMSETTINGS where KEY = " + superv.sqlDriver.param(0), ["PATCH.SYNC.LAST.GIT.HEAD"]);
						var valueToWrite = JSON.stringify({
							sha1: sha1,
							date: new Date().toISOString()
						});
						var sql = "insert into ASCMSETTINGS (KEY, VALUE) values (" + superv.sqlDriver.param(0) + "," + superv.sqlDriver.param(1) + ")";
						var params = ["PATCH.SYNC.LAST.GIT.HEAD", valueToWrite];
						superv.sqlDriver.execute(cnx, sql, params);
					});
				} catch (err) {
					throw new Error("Could not write last sync'd git sha1, reason = " + err.message);
				} finally {
					superv.release();
				}
			},
		},
	},
};