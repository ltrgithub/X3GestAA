"use strict";
var supervisor = require("etna/lib/supervisor/supervisor"),
	path = require("path"),
	fs = require('streamline-fs'),
	jsonHelper = require('scm-helper/lib/jsonHelper'),
	productsHelper = require('scm-helper/lib/productsHelper'),
	date = require("syracuse-core").types.date,
	sync = require("etna-etl/lib/sync"),
	conflictHelper = require('../conflictHelper'),
	globalConfig = exports.config = require('../../../../nodelocal').config,
	update = require('syracuse-collaboration/lib/entities/update');


function _getEndpoint(_, context, endPointName) {
	var db = context.db;
	var endPoints = db.fetchInstances(_, db.getEntity(_, "endPoint"), {}).filter_(_, function(_, ep) {
		return ep.dataset(_) === endPointName;
	});

	if (endPoints.length != 1)
		throw new Error("Invalid endPoint name " + endPointName);

	return endPoints[0];
}

function _saveJSonFile(_, endPoint, metadataObject, filename) {
	var entityType = jsonHelper.parseMetaFilename(filename).type;
	var sortedMetadataObject = jsonHelper.sortJsonObject(_, metadataObject, entityType);
	fs.writeFile(filename, JSON.stringify(sortedMetadataObject, null, '\t'), "utf8", _);
}

function _getProductId(_, superv) {
	var productId;
	try {
		superv.sqlDriver.withConnection(_, function(_, cnx) {
			var row = superv.sqlDriver.reader(_, cnx, "SELECT VALEUR_0 FROM ADOVAL WHERE PARAM_0=" + superv.sqlDriver.param(0), ['TYPDOS']).toArray(_)[0];
			if (!row)
				throw new Error("Could not detect the productId");
			productId = productsHelper.getProductFromFolderType(parseInt(row.VALEUR_0)).id;
		});
	} catch (err) {
		console.log(err.stack);
		throw new Error("Could not retrieve the productId, reason = " + err.message);
	}
	return productId;
}

module.exports = {
	$titleTemplate: "SCM configuration {name}",
	$valueTemplate: "{name}",
	$summaryTemplate: "SCM configuration {name}",
	$descriptionTemplate: "SCM configuration",
	$className: "scmConfig",
	$isPersistent: false,
	$services: {
		syracuseIsReady: {
			$method: "POST",
			$isMethod: false,
			$title: "Checks whether the Syracuse server is up and ready",
			$execute: function(_, context, instance) {
				try {
					var data = JSON.parse(context.request.readAll(_));
					var endPointName = data.endPoint;
					var endPoint = _getEndpoint(_, context, endPointName);

					var etnaConfig = endPoint.getEtnaConfig(_);
					var superv = supervisor.create(_, etnaConfig);
					var result = true;
					try {
						superv.sqlDriver.withConnection(_, function(_, cnx) {
							superv.sqlDriver.reader(_, cnx, "select CONTROLFILE_TYPE from v$database").toArray(_)[0];
						});
					} catch (err) {
						result = false;
					}
					superv.release(_);
					return {
						isUp: result,
					};
				} catch (err) {
					return {
						error: err
					}
				}
			}
		},
		getColumnsLocalizedLabelCodes: {
			$method: "POST",
			$isMethod: false,
			$title: "Get codes of localized labels of columns",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);

				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				var result = {
					ids: {},
				};
				try {
					superv.sqlDriver.withConnection(_, function(_, cnx) {
						const rows = superv.sqlDriver.reader(_,
							cnx,
							"select CODZONE_0, NOLONG_0 from ATABZON where CODFIC_0 = " + superv.sqlDriver.param(0), [data.tablename]).toArray(_);
						if (!rows)
							throw new Error("Could not read structure of table " + data.tablename);
						result.ids = rows.reduce(function(obj, row) {
							obj[row.CODZONE_0] = row.NOLONG_0;
							return obj;
						}, {});
					});
				} catch (err) {
					console.log("ERROR", err);
					result = false;
				}
				superv.release(_);
				return result;
			}
		},

		getProductId: {
			$method: "POST",
			$isMethod: false,
			$title: "Returns the productID of a given endpoint",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);

				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				return {
					productId: _getProductId(_, superv),
				};
				superv.release(_);
				return result;
			}
		},

		getSyncInfos: {
			$method: "POST",
			$isMethod: false,
			$title: "Get synchronization infos",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);

				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				var createTable = false;
				try {
					// Make sure the settings table exists
					var tableDef = superv.sqlDriver.getTableDef(_, etnaConfig.folderName, "ASCMSETTINGS");
					createTable = Object.keys(tableDef.columns).length == 0;
				} catch (err) {
					createTable = true;
				}

				if (createTable) {
					var tableDef = {
						schemaName: etnaConfig.folderName,
						tableName: "ASCMSETTINGS",
						columns: [{
							name: "KEY",
							isNullable: false,
							type: "nvarchar",
							maxLength: 100
						}, {
							name: "VALUE",
							isNullable: true,
							//type: "clob",
							type: "nvarchar",
							maxLength: 4000,
						}],
						indexes: [],
					};
					superv.sqlDriver.createTableFromTableDefinition(_, tableDef);
				}

				var result = {
					folderName: etnaConfig.folderName,
					lastSyncdSha1: undefined,
					productId: undefined,
				};


				try {
					superv.sqlDriver.withConnection(_, function(_, cnx) {
						var row = superv.sqlDriver.reader(_, cnx, "SELECT VALUE FROM ASCMSETTINGS WHERE KEY=" + superv.sqlDriver.param(0), ['PATCH.SYNC.LAST.GIT.HEAD']).toArray(_)[0];
						if (row)
							result.lastSyncdSha1 = JSON.parse(row.VALUE).sha1;
					});
				} catch (err) {
					console.log(err.stack);
					throw new Error("Could not retrieve last sync'd git sha1, reason = " + err.message);
				}

				result.productId = _getProductId(_, superv);

				superv.release(_);

				return result;
			}
		},

		importToMongo: {
			$method: "POST",
			$isMethod: false,
			$title: "importToMongo",
			$invocationMode: 'async',
			$capabilities: 'abort',
			$execute: function(_, context, instance) {

				context.tracker.phaseDetail = "Importing to mongoDb";
				context.tracker.$diagnoses = context.tracker.$diagnoses || [];

				var data = JSON.parse(context.request.readAll(_));
				var endPoint = _getEndpoint(_, context, data.endPoint);
				var rootFolder = endPoint.gitFolder(_);
				console.log("MONGO rootFolder = " + rootFolder);
				var absoluteFilenames = data.relativeFilenames.map(function(relPath) {
					return path.join(rootFolder, relPath);
				});

				var fullSync = data.fullSync;

				// First, only keep the metadata files
				absoluteFilenames = absoluteFilenames.filter(function(absoluteFilename) {
					return jsonHelper.isMetadataFile(absoluteFilename);
				});
				var syncInstance = sync.newSync(_, endPoint, context.tracker);
				syncInstance.importMetadataToMongo(_, absoluteFilenames, undefined, fullSync);
				return true;
			},
		},

		importPatches: {
			$method: "POST",
			$isMethod: false,
			$title: "importPatches",
			$invocationMode: 'async',
			$capabilities: 'abort',
			$execute: function(_, context, instance) {
				var body = context.request.readAll(_);
				var data = JSON.parse(body);
				var endPoint = _getEndpoint(_, context, data.endPoint);
				var etnaConfig = endPoint.getEtnaConfig(_);
				var patchFolder = path.join(etnaConfig.solutionPath, etnaConfig.folderName, "SCMPATCH");
				// There is only one patch
				var absoluteFilename = path.join(patchFolder, data.relativePatchNames[0]);

				var description = data.description || (data.fromSha1 + " -> " + data.toSha1);

				var applyResult = update.applyPatches(_,
					context,
					"SCM update " + date.today(true),
					"SCM Patch, imported @" + new Date().toISOString() + " (" + description + ")",
					data.endPoint, [{
						name: absoluteFilename,
						type: "SCM",
						description: description,
						path: absoluteFilename,
					}]);
				return {
					update: {
						uuid: applyResult.update.uuid,
					},
					errorMessage: applyResult.errorMessage,
				};
			},
		},

		getImportTrace: {
			$method: "POST",
			$isMethod: false,
			$title: "return import traces",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				var updateUuid = data.updateUuid;
				var db = context.db;
				var updates = db.fetchInstances(_, db.getEntity(_, "update"), {}).filter_(_, function(_, update) {
					return update.$uuid === updateUuid;
				});

				if (updates.length != 1)
					throw new Error("Invalid update uuid : " + updateUuid);
				var update = updates[0];
				var endPoints = update.endpoints(_).toArray(_, true);
				var folders = endPoints[0].folders(_).toArray(_, true);
				var folder = folders[0];
				var stream = folder.trace(_).createReadableStream(_);
				return {
					html: new Buffer(stream.readAll(_)).toString('utf8'),
				};
			},
		},
		saveResolvedFile: {
			$method: "POST",
			$isMethod: false,
			$title: "save resolved file",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				_saveJSonFile(_, endPoint, data.metadataObject, data.filename);
				return {
					result: "OK"
				};
			},
		},
		parseForConflicts: {
			$method: "POST",
			$isMethod: false,
			$title: "parse a file for conflicts",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var filename = data.filename;
				var entityType = jsonHelper.parseMetaFilename(filename).type;
				var endPoint = _getEndpoint(_, context, endPointName);
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				// console.log("Parsing file " + filename);
				var result = conflictHelper.parseForConflicts(_, superv, entityType, filename);
				// console.log("Parsing result = " + JSON.stringify(result));

				// Note : result has the following format : 
				// {
				// 	result: the parsed json
				// 	hasConflicts: whether a conflict was detected,
				// 	atLeastOneConflictFixed: whether at least one conflict was automatically resolved
				// };
				result.entityType = entityType;

				if (result.atLeastOneConflictFixed && !result.hasConflicts) {
					// console.log("Conflicts have been automatically resolved");
					// This file was in conflict but all the conflicts have been resolved automatically.
					if (data.autoSaveFixedFile) {
						// console.log("Save the file");
						// Save the file
						var conflictObject = result.result;
						// conflictObject is a structure that was built to retrieve (and resolve) all the conflicts.
						// We have to transform it back to a metadataObject to be able to save it
						var metadataObject = conflictHelper.rebuildMetadataFile(_, conflictObject);
						_saveJSonFile(_, endPoint, metadataObject, filename);
					}
				}
				return result;
			},
		},
		setLastSyncdGitHead: {
			$method: "POST",
			$isMethod: false,
			$title: "Set last sync'd git head",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var sha1 = data.sha1;
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				try {
					superv.sqlDriver.withConnection(_, function(_, cnx) {
						superv.sqlDriver.execute(_, cnx, "delete from ASCMSETTINGS where KEY = " + superv.sqlDriver.param(0), ["PATCH.SYNC.LAST.GIT.HEAD"]);
						var valueToWrite = JSON.stringify({
							sha1: sha1,
							date: new Date().toISOString()
						});
						var sql = "insert into ASCMSETTINGS (KEY, VALUE) values (" + superv.sqlDriver.param(0) + "," + superv.sqlDriver.param(1) + ")";
						var params = ["PATCH.SYNC.LAST.GIT.HEAD", valueToWrite];
						superv.sqlDriver.execute(_, cnx, sql, params);
					});
				} catch (err) {
					throw new Error("Could not write last sync'd git sha1, reason = " + err.message);
				}
				superv.release(_);

			},
		},
	},
};