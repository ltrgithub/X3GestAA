"use strict";
var supervisor = require("etna-supervisor/lib/supervisor"),
	path = require("path"),
	fs = require('streamline-fs'),
	jsonHelper = require('bundles/scm-helper/lib/jsonHelper');

function _getEndpoint(_, context, endPointName) {
	var db = context.db;
	var endPoints = db.fetchInstances(_, db.getEntity(_, "endPoint"), {}).filter_(_, function(_, ep) {
		return ep.dataset(_) === endPointName;
	});

	if (endPoints.length != 1)
		throw new Error("Invalid endPoint name " + endPointName);

	return endPoints[0];
}

function _saveJSonFile(_, endPoint, jsonObject, filename) {
	var entityType = jsonHelper.parseMetaFilename(filename).type;
	var json = jsonHelper.sortJsonObject(_, jsonObject, entityType);
	console.log("SAVING FILE");
	fs.writeFile(filename, JSON.stringify(jsonObject, null, '\t'), "utf8", _);
}

module.exports = {
	$titleTemplate: "SCM configuration {name}",
	$valueTemplate: "{name}",
	$summaryTemplate: "SCM configuration {name}",
	$descriptionTemplate: "SCM configuration",
	$className: "scmConfig",
	$isPersistent: false,

	$services: {
		getSyncInfos: {
			$method: "POST",
			$isMethod: false,
			$title: "Get synchronization infos",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);

				var settingsTableName = "_SETTINGS";
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				try {
					// Make sure the settings table exists
					superv.sqlDriver.getTableDef(_, etnaConfig.folderName, settingsTableName);
				} catch (err) {
					var tableDef = {
						schemaName: etnaConfig.folderName,
						tableName: settingsTableName,
						columns: [{
							name: "ID",
							isNullable: false,
							type: "nvarchar",
							maxLength: 100
						}, {
							name: "VALUE",
							isNullable: true,
							type: "clob",
						}],
						indexes: [],
					};
					superv.sqlDriver.createTableFromTableDefinition(_, tableDef);
				}

				var sha1;
				try {
					superv.sqlDriver.withConnection(_, function(_, cnx) {
						var row = superv.sqlDriver.reader(_, cnx, "select VALUE from " + settingsTableName + " where ID = " + superv.sqlDriver.param(0), ["PATCH.SYNC.LAST.GIT.HEAD"]).toArray(_)[0];
						if (row)
							sha1 = JSON.parse(row.VALUE).sha1;
						else
							sha1 = null;;
					});
				} catch (err) {
					throw new Error("Could not retrieve last sync'd git sha1, reason = " + err.message);
				}

				return {
					solutionFolder: etnaConfig.solutionPath,
					lastSyncdSha1: sha1,
					syracuseFolder: __dirname.split(path.sep).slice(0, -5).join(path.sep), // Return the path to the root of syracuse
					x3ServiceName: "MSSQLSERVER" /*"RTMSTDEN"*/ , // Windows service name
				};
			}
		},
		importPatch: {
			$method: "POST",
			$isMethod: false,
			$title: "import patch",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var patchFileName = data.patchFile;
				console.log("Patch filename to import = " + patchFileName);
			},
		},
		saveResolvedFile: {
			$method: "POST",
			$isMethod: false,
			$title: "save resolved file",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				_saveJSonFile(_, endPoint, data.json, data.filename);
				return {
					result: "OK"
				};
			},
		},
		parseForConflicts: {
			$method: "POST",
			$isMethod: false,
			$title: "parse a file for conflicts",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var filename = data.filename;
				var entityType = jsonHelper.parseMetaFilename(filename).type;
				var endPoint = _getEndpoint(_, context, endPointName);
				var settingsTableName = "_SETTINGS";
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				var conflictHelper = require('../conflictHelper');
				var result = conflictHelper.parseForConflicts(_, superv, entityType, filename);
				// Note : result has the following format : 
				// {
				// 	result: the parsed json
				// 	hasConflicts: whether a conflict was detected,
				// 	atLeastOneConflictFixed: whether at least one conflict was automatically resolved
				// };
				result.entityType = entityType;

				if (result.atLeastOneConflictFixed && !result.hasConflicts) {
					// This file was in conflict but all the conflicts have been resolved automatically.
					if (data.autoSaveFixedFile) {
						// Save the file

						_saveJSonFile(_, endPoint, result.result, filename);
					}
				}
				return result;
			},
		},
		setLastSyncdGitHead: {
			$method: "POST",
			$isMethod: false,
			$title: "Set last sync'd git head",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var sha1 = data.sha1;
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				var settingsTableName = "_SETTINGS";
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				try {
					superv.sqlDriver.withConnection(_, function(_, cnx) {
						superv.sqlDriver.execute(_, cnx, "delete from " + settingsTableName + " where ID = " + superv.sqlDriver.param(0), ["PATCH.SYNC.LAST.GIT.HEAD"]);
						var valueToWrite = JSON.stringify({
							sha1: sha1,
							date: new Date().toISOString()
						});
						superv.sqlDriver.execute(_, cnx, "insert into " + settingsTableName + " (ID, VALUE) values (" + superv.sqlDriver.param(0) + "," + superv.sqlDriver.param(1) + ")", ["PATCH.SYNC.LAST.GIT.HEAD", valueToWrite]);
					});
				} catch (err) {
					throw new Error("Could not write last sync'd git sha1, reason = " + err.message);
				}
			},
		},
	},
};