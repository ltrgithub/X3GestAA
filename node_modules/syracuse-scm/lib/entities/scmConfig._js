"use strict";
var supervisor = require("etna/lib/supervisor/supervisor"),
	path = require("path"),
	fs = require('streamline-fs'),
	jsonHelper = require('scm-helper/lib/jsonHelper'),
	date = require("syracuse-core").types.date,
	sync = require("etna-etl/lib/sync"),
	conflictHelper = require('../conflictHelper');


function _getEndpoint(_, context, endPointName) {
	var db = context.db;
	var endPoints = db.fetchInstances(_, db.getEntity(_, "endPoint"), {}).filter_(_, function(_, ep) {
		return ep.dataset(_) === endPointName;
	});

	if (endPoints.length != 1)
		throw new Error("Invalid endPoint name " + endPointName);

	return endPoints[0];
}

function _saveJSonFile(_, endPoint, metadataObject, filename) {
	var entityType = jsonHelper.parseMetaFilename(filename).type;
	var sortedMetadataObject = jsonHelper.sortJsonObject(_, metadataObject, entityType);
	fs.writeFile(filename, JSON.stringify(sortedMetadataObject, null, '\t'), "utf8", _);
}

module.exports = {
	$titleTemplate: "SCM configuration {name}",
	$valueTemplate: "{name}",
	$summaryTemplate: "SCM configuration {name}",
	$descriptionTemplate: "SCM configuration",
	$className: "scmConfig",
	$isPersistent: false,

	$services: {
		getSyncInfos: {
			$method: "POST",
			$isMethod: false,
			$title: "Get synchronization infos",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);

				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				var createTable = false;
				try {
					// Make sure the settings table exists
					var tableDef = superv.sqlDriver.getTableDef(_, etnaConfig.folderName, "SCMSETTINGS");
					createTable = Object.keys(tableDef.columns).length == 0;
				} catch (err) {
					createTable = true;
				}

				if (createTable) {
					var tableDef = {
						schemaName: etnaConfig.folderName,
						tableName: "SCMSETTINGS",
						columns: [{
							name: "KEY",
							isNullable: false,
							type: "nvarchar",
							maxLength: 100
						}, {
							name: "VALUE",
							isNullable: true,
							//type: "clob",
							type: "nvarchar",
							maxLength: 4000,
						}],
						indexes: [],
					};
					superv.sqlDriver.createTableFromTableDefinition(_, tableDef);
				}

				var sha1;
				try {
					superv.sqlDriver.withConnection(_, function(_, cnx) {
						var row = superv.sqlDriver.reader(_, cnx, "SELECT VALUE FROM SCMSETTINGS WHERE KEY=" + superv.sqlDriver.param(0), ['PATCH.SYNC.LAST.GIT.HEAD']).toArray(_)[0];
						if (row)
							sha1 = JSON.parse(row.VALUE).sha1;
						else
							sha1 = null;;
					});
				} catch (err) {
					console.log(err.stack);
					throw new Error("Could not retrieve last sync'd git sha1, reason = " + err.message);
				}

				return {
					solutionFolder: etnaConfig.solutionPath,
					folderName: etnaConfig.folderName,
					lastSyncdSha1: sha1,
					syracuseFolder: __dirname.split(path.sep).slice(0, -4).join(path.sep), // Return the path to the root of syracuse
					x3ServiceName: "MSSQLSERVER" /*"RTMSTDEN"*/ , // Windows service name
				};
			}
		},

		importToMongo: {
			$method: "POST",
			$isMethod: false,
			$title: "importToMongo",
			$invocationMode: 'async',
			$capabilities: 'abort',
			$execute: function(_, context, instance) {

				context.tracker.phaseDetail = "Importing to mongoDb";
				context.tracker.$diagnoses = context.tracker.$diagnoses || [];

				var data = JSON.parse(context.request.readAll(_));
				var rootFolder = data.rootFolder;
				console.log("MONGO rootFolder = " + rootFolder);
				var absoluteFilenames = data.relativeFilenames.map(function(relPath) {
					return path.join(rootFolder, relPath);
				});

				var fullSync = data.fullSync;

				var endPoint = _getEndpoint(_, context, data.endPoint);

				// First, only keep the metadata files
				absoluteFilenames = absoluteFilenames.filter(function(absoluteFilename) {
					return jsonHelper.isMetadataFile(absoluteFilename);
				});
				var syncInstance = sync.newSync(_, endPoint, context.tracker);
				syncInstance.importMetadataToMongo(_, absoluteFilenames, undefined, fullSync);
				return true;
			},
		},

		importPatches: {
			$method: "POST",
			$isMethod: false,
			$title: "importPatches",
			$invocationMode: 'async',
			$capabilities: 'abort',
			$execute: function(_, context, instance) {
				console.log("Import patch.1");
				var data = JSON.parse(context.request.readAll(_));
				console.log("Import patch.2");
				// Create an update
				var db = context.db;
				var updateEntity = db.getEntity(_, "update");
				var update = updateEntity.createInstance(_, db, null);
				update.name(_, "SCM update " + date.today(true));
				update.description(_, "update for SCM, imported @" + new Date().toISOString());

				var endPoint = _getEndpoint(_, context, data.endPoint);

				// Add a patch to the update
				update.patches(_).reset(_);

				data.patchNames.forEach_(_, function(_, patchFilename) {

					var patch = update.patches(_).add(_);
					patch.name(_, "SCM patch");
					patch.type(_, "X3");
					patch.description(_, "Patch for SCM (" + patchFilename + ")");
					patch.path(_, patchFilename);
					patch.mandatory(_, true);
					patch.firstMaintenance(_, 0);
					patch.lastMaintenance(_, 0);
					patch.apply(_, true);
				});

				var ep = update.endpoints(_).add(_);
				ep.endpoint(_, endPoint);
				ep.folders(_).reset(_);
				var folder = ep.folders(_).add(_);
				folder.name(_, endPoint.x3ServerFolder(_));
				folder.parent(_, "");
				folder.updated(_, date.today(true));
				update.save(_);

				var options = {
					localFolder: data.patchFolder,
					forceUpdate: true,
					skipStartBatchServer: data.skipStartBatchServer,
				};

				var errorMessage = undefined;
				try {
					update.applyUpdate(true)(_, context, update, options);
				} catch (err) {
					errorMessage = err.message;
				}

				return {
					update: {
						uuid: update.$uuid,
					},
					errorMessage: errorMessage,
				};
			},
		},

		getImportTrace: {
			$method: "POST",
			$isMethod: false,
			$title: "return import traces",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				var updateUuid = data.updateUuid;
				var db = context.db;
				var updates = db.fetchInstances(_, db.getEntity(_, "update"), {}).filter_(_, function(_, update) {
					return update.$uuid === updateUuid;
				});

				if (updates.length != 1)
					throw new Error("Invalid update uuid : " + updateUuid);
				var update = updates[0];
				var endPoints = update.endpoints(_).toArray(_, true);
				var folders = endPoints[0].folders(_).toArray(_, true);
				var folder = folders[0];
				var stream = folder.trace(_).createReadableStream(_);
				return {
					html: new Buffer(stream.readAll(_)).toString('utf8'),
				};
			},
		},
		saveResolvedFile: {
			$method: "POST",
			$isMethod: false,
			$title: "save resolved file",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				_saveJSonFile(_, endPoint, data.metadataObject, data.filename);
				return {
					result: "OK"
				};
			},
		},
		parseForConflicts: {
			$method: "POST",
			$isMethod: false,
			$title: "parse a file for conflicts",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var endPointName = data.endPoint;
				var filename = data.filename;
				var entityType = jsonHelper.parseMetaFilename(filename).type;
				var endPoint = _getEndpoint(_, context, endPointName);
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				// console.log("Parsing file " + filename);
				var result = conflictHelper.parseForConflicts(_, superv, entityType, filename);
				// console.log("Parsing result = " + JSON.stringify(result));

				// Note : result has the following format : 
				// {
				// 	result: the parsed json
				// 	hasConflicts: whether a conflict was detected,
				// 	atLeastOneConflictFixed: whether at least one conflict was automatically resolved
				// };
				result.entityType = entityType;

				if (result.atLeastOneConflictFixed && !result.hasConflicts) {
					// console.log("Conflicts have been automatically resolved");
					// This file was in conflict but all the conflicts have been resolved automatically.
					if (data.autoSaveFixedFile) {
						// console.log("Save the file");
						// Save the file
						var conflictObject = result.result;
						// conflictObject is a structure that was built to retrieve (and resolve) all the conflicts.
						// We have to transform it back to a metadataObject to be able to save it
						var metadataObject = conflictHelper.rebuildMetadataFile(_, conflictObject);
						_saveJSonFile(_, endPoint, metadataObject, filename);
					}
				}
				return result;
			},
		},
		setLastSyncdGitHead: {
			$method: "POST",
			$isMethod: false,
			$title: "Set last sync'd git head",
			$execute: function(_, context, instance) {
				var data = JSON.parse(context.request.readAll(_));
				var sha1 = data.sha1;
				var endPointName = data.endPoint;
				var endPoint = _getEndpoint(_, context, endPointName);
				var etnaConfig = endPoint.getEtnaConfig(_);
				var superv = supervisor.create(_, etnaConfig);

				try {
					superv.sqlDriver.withConnection(_, function(_, cnx) {
						superv.sqlDriver.execute(_, cnx, "delete from SCMSETTINGS where KEY = " + superv.sqlDriver.param(0), ["PATCH.SYNC.LAST.GIT.HEAD"]);
						var valueToWrite = JSON.stringify({
							sha1: sha1,
							date: new Date().toISOString()
						});
						var sql = "insert into SCMSETTINGS (KEY, VALUE) values (" + superv.sqlDriver.param(0) + "," + superv.sqlDriver.param(1) + ")";
						var params = ["PATCH.SYNC.LAST.GIT.HEAD", valueToWrite];
						superv.sqlDriver.execute(_, cnx, sql, params);
					});
				} catch (err) {
					throw new Error("Could not write last sync'd git sha1, reason = " + err.message);
				}
			},
		},
	},
};