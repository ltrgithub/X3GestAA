"use strict";
var supervisor = require("etna-supervisor/lib/supervisor"),
	path = require("path"),
	ez = require("ez-streams"),
	file = ez.devices.file,
	fs = require("streamline-fs"),
	resourceManager = require('bundles/scm-helper/lib/resourceManager'),
	jsonHelper = require('bundles/scm-helper/lib/jsonHelper');



exports.parseForConflicts = function(_, superv, entityType, jsonFile, options) {
	options = options || {};
	var entity = resourceManager.getEntityDescriptor(_, entityType).entity;
	var inConflict = false;
	var inPreviousVersion = false;
	var currentVersion = "";
	var previousVersion = "";
	file.text.reader(jsonFile, "utf8").transform(ez.transforms.lines.parser()).forEach(_, function(_, line) {
		if (line[0] == '<') {
			inConflict = true;
			inPreviousVersion = true;
		} else if (line[0] === '=') {
			inPreviousVersion = false;
		} else if (line[0] == '>') {
			inConflict = false;
		} else {
			if (inConflict) {
				if (inPreviousVersion)
					previousVersion += line;
				else
					currentVersion += line;
			} else {
				previousVersion += line;
				currentVersion += line;
			}
		}
	});
	var prevObj = JSON.parse(previousVersion);
	var currentObj = JSON.parse(currentVersion);
	var result = findDifferences(_, superv, entity, "", "", prevObj, currentObj, options);

	_setProblemCount(result);
	var writer = file.text.writer("c:\\out.xml", "utf8");
	writer.write(_, require('util').inspect(result, false, null));
	writer.write(_);
	console.log(">>>>>>> " + jsonFile + " parsed");
	return result;
};


function _setProblemCount(obj) {
	var problemCount = false;

	if (obj.$type === "value") {
		obj.$problemCount = (obj.$status === "match" ? 0 : 1);
		return obj.$problemCount;
	}

	if ((obj.$type === "array") || (obj.$type === "sub-objects")) {
		obj.$problemCount = 0;
		obj.$values.forEach(function(item) {
			obj.$problemCount += _setProblemCount(item);
		});
		return obj.$problemCount;
	}

	// Here, this an object or a list of sub-objects
	try {
		var childPbm = 0;
		Object.keys(obj.$values).forEach(function(key) {
			try {
				childPbm += _setProblemCount(obj.$values[key]);
			} catch (e) {
				console.log("KKKKKKKKKKKKKKKKKKK = " + key + " > " + obj.$path + " > " + obj.$values[key]);
			}
		});
	} catch (err) {
		console.log("--------------------------------------------------------");
		console.log(obj.$values);
		throw err;
	}
	obj.$problemCount = childPbm;

	return childPbm;
}




function findDifferences(_, superv, entity, propName, path, valLocal, valRemote, options) {

	var localizedLabels = {};

	if (options.skipSpecials && ("##" === propName.slice(0, 2))) {
		// Skip special tags (##texts##, ##comments##, ...)
		return undefined;
	}

	function getLocalizedLabel(_, tableName, columnName) {
		if (!localizedLabels[tableName]) {
			// Load all the localized labels for this table
			var sql = "SELECT z.CODZONE_0 ZONE, t.TEXTE_0 TEXT FROM ATABZON z";
			sql += " LEFT JOIN ATEXTE t ON t.NUMERO_0 = z.NOLONG_0";
			sql += " WHERE z.CODFIC_0=" + superv.sqlDriver.param(0) + " AND t.LAN_0 = " + superv.sqlDriver.param(1);
			superv.sqlDriver.withConnection(_, function(_, cnx) {
				superv.sqlDriver.execute(_, cnx, sql, [tableName, options.langage || "FRA"]).forEach(function(row) {
					localizedLabels[tableName + "." + row.ZONE] = row.TEXT;
				});
			});
			localizedLabels[tableName] = tableName;
		}
		var key = tableName + '.' + columnName;
		var label = localizedLabels[key];
		if (!label)
			label = key;
		return label;
	}

	function getDistance(a, b) {
		if (a.length == 0) return b.length;
		if (b.length == 0) return a.length;

		var matrix = [];

		// increment along the first column of each row
		var i;
		for (i = 0; i <= b.length; i++) {
			matrix[i] = [i];
		}

		// increment each column in the first row
		var j;
		for (j = 0; j <= a.length; j++) {
			matrix[0][j] = j;
		}

		// Fill in the rest of the matrix
		for (i = 1; i <= b.length; i++) {
			for (j = 1; j <= a.length; j++) {
				if (b.charAt(i - 1) == a.charAt(j - 1)) {
					matrix[i][j] = matrix[i - 1][j - 1];
				} else {
					matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
						Math.min(matrix[i][j - 1] + 1, // insertion
							matrix[i - 1][j] + 1)); // deletion
				}
			}
		}

		return matrix[b.length][a.length];
	};

	function decodeRawValue(rawValue) {
		if (path.indexOf("/##") !== -1) {
			// Values of special texts are not formatted (##comments##, ##texts##, ...)
			return rawValue;
		}
		return jsonHelper.decodeValueFromJsonString("", rawValue).value;
	}

	function indexArray(entity, array) {
		var indexedArray = {};
		array.forEach(function(instance) {
			indexedArray[decodeRawValue(instance[getPK(entity)])] = instance;
		});
		return indexedArray;
	}

	function getPK(entity) {
		return entity.primaryKey || entity.patchPK || entity.orderBy;
	}


	var result = undefined;
	if (valLocal === valRemote) {
		if (options.skipMatching)
			return undefined;
		result = {
			$type: "value",
			$label: getLocalizedLabel(_, entity.tableName, propName),
			$path: path,
			$status: "match",
			$rawValue: valLocal,
			$value: decodeRawValue(valLocal),
		};
		return result;
	}
	if (Array.isArray(valLocal)) {
		// Assume that valRemote is also an array
		var subEntity;
		if (entity.children && entity.children.hasOwnProperty(propName)) {

			// This is a subObject
			subEntity = entity.children[propName];
			// We have to index all the items by their PK to be sure to compare the good pairs.
			// for instance, in a table, there will be a subObject named "COLUMNS" that will describe all the columns.
			// We can't be sure that the columns were serialized in the same order in the local and in the remote object.
			var arrLocal = indexArray(subEntity, valLocal);
			var arrRemote = indexArray(subEntity, valRemote);
			options.isArrayItem = true;

			result = {
				$type: "sub-objects",
				$pk: getPK(subEntity),
				$path: path,
				$values: findDifferences(_, superv, subEntity, propName, path, arrLocal, arrRemote, options),
			};
		} else {
			// TODO !!!
			// Here, the items of the array can't be indexed, so we have no other choice than
			// assuming (or hoping...) that all the items are sorted the same way in the 2 arrays.
			// Might be improved later (maybe by using levenshtein distance based algo to identify the best pairs)
			result = {
				$type: "array",
				$values: [],
			};
			for (var i = 0; i < Math.min(valLocal.length, valRemote.length); i++) {
				var subResult = findDifferences(_, superv, entity, propName, path + "[" + i + "]", valLocal[i], valRemote[i], options);
				if (subResult) {
					result.$values.push(subResult);
				}
			}
			for (var i = Math.min(valLocal.length, valRemote.length); i < valLocal.length; i++) {
				result.$values.push({
					$type: "value",
					$path: path + "[" + i + "]",
					$status: "missing",
					$rawLocal: valLocal[i],
					$local: decodeRawValue(valLocal[i]),
				});
			}
			for (var i = Math.min(valLocal.length, valRemote.length); i < valRemote.length; i++) {
				result.$values.push({
					$type: "value",
					$path: path + "[" + i + "]",
					$status: "missing",
					$rawRemote: valRemote[i],
					$remote: decodeRawValue(valRemote[i]),
				});
			}
		}

	} else if ("object" === typeof(valLocal)) {
		// Assume that valRemote is also an object
		result = {};
		var isArrayItem = options.isArrayItem;
		delete options.isArrayItem;
		Object.keys(valLocal).filter(function(key) {
			// Filter any special texts ##texts##, ##comments##, ...
			return key.slice(0, 2) != "##";
		}).forEach_(_, function(_, childPropName) {
			if (!valRemote.hasOwnProperty(childPropName)) {
				result[childPropName] = {
					$type: "value",
					$label: getLocalizedLabel(_, entity.tableName, childPropName),
					$path: path + "/" + childPropName,
					$status: "missing",
					$rawLocal: valLocal[childPropName],
					$local: jsonHelper.cleanData(valLocal[childPropName]),
				};
				return;
			}
			var propLocal = valLocal[childPropName];
			var propRemote = valRemote[childPropName];
			var subResult = findDifferences(_, superv, entity, childPropName, path + "/" + childPropName, propLocal, propRemote, options);
			if (subResult) {
				if (subResult.$type === "value") {
					// Check if this value stands for the id of a text
					if (valLocal["##texts##"] && valLocal["##texts##"][childPropName]) {
						if (subResult.$status === "match") {
							subResult.$texts = valLocal["##texts##"][childPropName];
							subResult.$comments = valLocal["##comments##"][childPropName];
						} else {
							subResult.$localTexts = valLocal["##texts##"][childPropName];
							subResult.$localComments = valLocal["##comments##"][childPropName];
							subResult.$remoteTexts = valRemote["##texts##"][childPropName];
							subResult.$remoteComments = valRemote["##comments##"][childPropName];
						}
					}
				}
				result[childPropName] = subResult;

			}
			delete valRemote[childPropName];
		});
		// Here, valRemote only contains the properties that are not declared in valLocal
		Object.keys(valRemote).filter(function(key) {
			return key.slice(0, 2) != "##";
		}).forEach_(_, function(_, childPropName) {
			result[childPropName] = {
				$type: "value",
				$label: getLocalizedLabel(_, entity.tableName, childPropName),
				$path: path + "/" + childPropName,
				$status: "missing",
				$remote: decodeRawValue(valRemote[childPropName]),
				$rawRemote: valRemote[childPropName],
			};
		});
		if (isArrayItem) {
			var subObjects = [];
			Object.keys(result).forEach(function(key) {
				var subObject = result[key];
				subObject.$type = "object";
				subObject.$key = key;
				subObjects.push(subObject);
			});
			result = subObjects;
		} else
			result = {
				$type: "object",
				$path: path,
				$status: "match",
				$values: result
			};
	} else {
		result = {
			$label: getLocalizedLabel(_, entity.tableName, propName),
			$type: "value",
			$path: path,
			$status: "mismatch",
			$rawLocal: valLocal,
			$local: decodeRawValue(valLocal),
			$rawRemote: valRemote,
			$remote: decodeRawValue(valRemote),
		};
	}

	return result;
}