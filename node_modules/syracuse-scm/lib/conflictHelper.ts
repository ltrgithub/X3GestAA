import { _ } from 'streamline-runtime';
import * as fs from 'fs';
import * as path from 'path';
import * as ez from 'ez-streams';
import { Supervisor } from '@sage/etna/lib/supervisor/supervisor';
import { Descriptor } from '../../etna-etl/lib/exporter';

var file = ez.devices.file,
	resourceManager = require('scm-lib/resourceManager'),
	jsonHelper = require('scm-lib/jsonHelper');

export type Dict<T> = { [key: string]: T }

export interface Options {
	skipSpecials?: boolean;
	skipMatching?: boolean;
	isArrayItem?: boolean;
	langage?: string; // TODO: rename to language
	autoFixProperties?: string[];
}

type Result = any;

/// !doc
/// --------------------------
/// ### rebuildMetadataFile(_, conflictObject, fixedValues)
/// Rebuild a metadata JSON object from a structure(conflictObject). This structure was previously built 
///	by parseForConflicts() method.
/// fixedValues are all the values that have been fixed, when resolving the conflict.
export function rebuildMetadataFile(_: _, conflictObject: any) {

	function transformObject(obj: any, key?: string, textsHolder?: Dict<Dict<string>>) {
		if (obj.$type == 'object') {
			var result = {} as any;
			Object.keys(obj.$values).forEach(function (key) {
				result[key] = transformObject(obj.$values[key], key, result);
			});
			return result;
		}
		if (obj.$type == 'sub-objects') {
			var result = [] as any;
			obj.$values.forEach(function (item: any) {
				result.push(transformObject(item, undefined, textsHolder));
			});
			return result;
		}
		if (obj.$type == 'value') {
			if (!obj.hasOwnProperty('$rawValue'))
				throw new Error("All the conflicts were not resolved, can't save (key of remaining conflict is " + obj.$path + ")");
			if (obj.hasOwnProperty('$comments')) {
				textsHolder["##comments##"] = textsHolder["##comments##"] || {};
				textsHolder["##comments##"][key] = obj.$comments;

			}
			if (obj.hasOwnProperty('$texts')) {
				textsHolder["##texts##"] = textsHolder["##texts##"] || {};
				textsHolder["##texts##"][key] = obj.$texts;

			}
			return obj.$rawValue;
		}
		throw new Error("Invalid object type : " + obj.$type);
	}

	return transformObject(conflictObject);
};

export function parseForConflicts(_: _, superv: Supervisor, entityType: string, jsonFile: string, options?: Options) {

	var atLeastOneConflictFixed = false;

	var localizedLabels = {} as Dict<string>;

	function _findDifferences(_: _, superv: Supervisor, entityDescriptor: Descriptor, propName: string, path: string, valLocal: any, valRemote: any, options?: Options) {

		if (options.skipSpecials && ("##" === propName.slice(0, 2))) {
			// Skip special tags (##texts##, ##comments##, ...)
			return undefined;
		}

		function getLocalizedLabel(_: _, tableName: string, columnName: string) {
			if (!localizedLabels[tableName]) {
				// Load all the localized labels for this table
				var sql = "SELECT z.CODZONE_0 ZONE, t.TEXTE_0 TEXT FROM ATABZON z";
				sql += " LEFT JOIN ATEXTE t ON t.NUMERO_0 = z.NOLONG_0";
				sql += " WHERE z.CODFIC_0=" + superv.sqlDriver.param(0) + " AND t.LAN_0 = " + superv.sqlDriver.param(1);
				type Row = {
					ZONE: string;
					TEXT: string;
				}
				superv.sqlDriver.withConnection(cnx => {
					superv.sqlDriver.execute(cnx, sql, [tableName, options.langage || "FRA"]).forEach((row: Row) => {
						localizedLabels[tableName + "." + row.ZONE] = row.TEXT;
					});
				});
				localizedLabels[tableName] = tableName;
			}
			var key = tableName + '.' + columnName;
			var label = localizedLabels[key];
			if (!label)
				label = key;
			return label;
		}

		function decodeRawValue(rawValue: any) {
			if (path.indexOf("/##") !== -1) {
				// Values of special texts are not formatted (##comments##, ##texts##, ...)
				return rawValue;
			}
			return jsonHelper.decodeValueFromJsonString("", rawValue).value;;
		}

		function indexArray(entityDescriptor: Descriptor, array: any) {

			var indexedArray = {} as Dict<any>;
			array.forEach(function (instance: any) {
				var values = getOrderBy(entityDescriptor).map(function (propName) {
					propName = propName.trim();
					return decodeRawValue(instance[propName]);
				});
				var key = values.join('+');
				if (indexedArray.hasOwnProperty(key)) {
					console.log(array);
					console.log(require("util").inspect(entityDescriptor, false, null));
					throw new Error("Duplicate key " + key);
				}
				indexedArray[key] = instance;
			});
			return indexedArray;
		}

		function getOrderBy(entityDescriptor: Descriptor) {
			var orderBy = entityDescriptor.orderBy || entityDescriptor.primaryKey || entityDescriptor.patchPK;
			if (!Array.isArray(orderBy))
				orderBy = orderBy.split(',');
			return orderBy;
		}

		var result: Result = undefined;
		if (valLocal === valRemote) {
			if (options.skipMatching) {
				// We are only interested in differences
				return undefined;
			}
			result = {
				$type: "value",
				$label: getLocalizedLabel(_, entityDescriptor.tableName, propName),
				$path: path,
				$status: "match",
				$rawValue: valLocal,
				$value: decodeRawValue(valLocal),
			};
			return result;
		}
		if (Array.isArray(valLocal)) {
			// Assume that valRemote is also an array
			var subEntityDescriptor: Descriptor;
			if (entityDescriptor.children && entityDescriptor.children.hasOwnProperty(propName)) {

				// This is a subObject
				subEntityDescriptor = entityDescriptor.children[propName];
				// We have to index all the items by their PK to be sure to compare the good pairs.
				// for instance, in a table, there will be a subObject named "COLUMNS" that will describe all the columns.
				// We can't be sure that the columns were serialized in the same order in the local and in the remote object.
				var arrLocal = indexArray(subEntityDescriptor, valLocal);
				var arrRemote = indexArray(subEntityDescriptor, valRemote);
				options.isArrayItem = true;

				result = {
					$type: "sub-objects",
					$pk: getOrderBy(subEntityDescriptor),
					$path: path,
					$values: _findDifferences(_, superv, subEntityDescriptor, propName, path, arrLocal, arrRemote, options),
				};
			} else {
				// TODO !!!
				// Here, the items of the array can't be indexed, so we have no other choice than
				// assuming (or hoping...) that all the items are sorted the same way in the 2 arrays.
				// Might be improved later (maybe by using levenshtein distance based algo to identify the best pairs)
				result = {
					$type: "array",
					$values: [],
				};
				for (var i = 0; i < Math.min(valLocal.length, valRemote.length); i++) {
					var subResult = _findDifferences(_, superv, entityDescriptor, propName, path + "[" + i + "]", valLocal[i], valRemote[i], options);
					if (subResult) {
						result.$values.push(subResult);
					}
				}
				for (var i = Math.min(valLocal.length, valRemote.length); i < valLocal.length; i++) {
					result.$values.push({
						$type: "value",
						$path: path + "[" + i + "]",
						$status: "missing",
						$rawLocal: valLocal[i],
						$local: decodeRawValue(valLocal[i]),
					});
				}
				for (var i = Math.min(valLocal.length, valRemote.length); i < valRemote.length; i++) {
					result.$values.push({
						$type: "value",
						$path: path + "[" + i + "]",
						$status: "missing",
						$rawRemote: valRemote[i],
						$remote: decodeRawValue(valRemote[i]),
					});
				}
			}

		} else if ("object" === typeof (valLocal)) {
			// Assume that valRemote is also an object
			result = {};
			var isArrayItem = options.isArrayItem;
			delete options.isArrayItem;
			Object.keys(valLocal).filter(function (key) {
				// Filter any special texts ##texts##, ##comments##, ...
				return key.slice(0, 2) != "##";
			}).forEach_(_, function (_, childPropName) {
				if (!valRemote.hasOwnProperty(childPropName)) {
					result[childPropName] = {
						$type: "value",
						$label: getLocalizedLabel(_, entityDescriptor.tableName, childPropName),
						$path: path + "/" + childPropName,
						$status: "missing",
						$rawLocal: valLocal[childPropName],
						$local: jsonHelper.cleanData(valLocal[childPropName]),
					};
					return;
				}
				var propLocal = valLocal[childPropName];
				var propRemote = valRemote[childPropName];
				var subResult = _findDifferences(_, superv, entityDescriptor, childPropName, path + "/" + childPropName, propLocal, propRemote, options);
				if (subResult) {
					if (subResult.$type === "value") {
						// Check if this value stands for the id of a text
						if (valLocal["##texts##"] && valLocal["##texts##"][childPropName]) {
							if (subResult.$status === "match") {
								// The 2 resources have the same number
								// We now have to ensure that these 2 resources are bound to the same texts
								subResult.$texts = valLocal["##texts##"][childPropName];
								subResult.$comments = valLocal["##comments##"][childPropName];
							} else {
								// The 2 text resources do not have the same id. We have to let the user
								// choose wich resource he wants to keep
								subResult.$localTexts = valLocal["##texts##"][childPropName];
								subResult.$localComments = valLocal["##comments##"][childPropName];
								subResult.$remoteTexts = valRemote["##texts##"][childPropName];
								subResult.$remoteComments = valRemote["##comments##"][childPropName];
							}
						}
					}
					result[childPropName] = subResult;

				}
				delete valRemote[childPropName];
			});
			// Here, valRemote only contains the properties that are not declared in valLocal
			Object.keys(valRemote).filter(function (key) {
				return key.slice(0, 2) != "##";
			}).forEach_(_, function (_, childPropName) {
				result[childPropName] = {
					$type: "value",
					$label: getLocalizedLabel(_, entityDescriptor.tableName, childPropName),
					$path: path + "/" + childPropName,
					$status: "missing",
					$remote: decodeRawValue(valRemote[childPropName]),
					$rawRemote: valRemote[childPropName],
				};
			});
			if (isArrayItem) {
				var subObjects: any[] = [];
				Object.keys(result).forEach(function (key) {
					var subObject = result[key];
					subObject.$type = "object";
					subObject.$key = key;
					subObjects.push(subObject);
				});
				result = subObjects;
			} else
				result = {
					$type: "object",
					$path: path,
					$status: "match",
					$values: result
				};
		} else {
			if (options.autoFixProperties.indexOf(propName) !== -1) {
				// This property must be resolved automatically.
				// By convention, we will use the local value as a reference
				result = {
					$label: getLocalizedLabel(_, entityDescriptor.tableName, propName),
					$type: "value",
					$path: path,
					$status: "match",
					$rawValue: valLocal,
					$value: decodeRawValue(valLocal),
				};
				atLeastOneConflictFixed = true;
			} else
				result = {
					$label: getLocalizedLabel(_, entityDescriptor.tableName, propName),
					$type: "value",
					$path: path,
					$status: "mismatch",
					$rawLocal: valLocal,
					$local: decodeRawValue(valLocal),
					$rawRemote: valRemote,
					$remote: decodeRawValue(valRemote),
				};
		}

		return result;
	}

	function _scanProblems(obj: any) {
		if (obj.$type === "value") {
			obj.$problems = {
				count: (obj.$status === "match" ? 0 : 1),
				mismatches: obj.$status === "mismatch",
			};
			return obj.$problems;
		}

		if ((obj.$type === "array") || (obj.$type === "sub-objects")) {
			obj.$problems = {
				count: 0,
				mismatches: 0,
			};
			obj.$values.forEach(function (item: any) {
				var subPbms = _scanProblems(item);
				obj.$problems.count += subPbms.count;
				obj.$problems.mismatches += subPbms.mismatches;
			});
			return obj.$problems;
		}

		// Here, this an object or a list of sub-objects
		var childPbm: {
			count: number;
			mismatches: number;
		}
		if (obj.$status === "match") {
			childPbm = {
				count: (obj.$status === "missing" ? 1 : 0),
				mismatches: 0,
			};

			Object.keys(obj.$values).forEach(function (key) {
				var subPbms = _scanProblems(obj.$values[key]);
				childPbm.count += subPbms.count;
				childPbm.mismatches += subPbms.mismatches;
			});
		} else {
			childPbm = {
				count: 1,
				mismatches: (obj.$status === "mismatch" ? 1 : 0),
			};
		}
		obj.$problems = childPbm;

		return childPbm;
	}

	options = options || {};
	options.autoFixProperties = options.autoFixProperties || ['CREUSR'];

	var entityDescriptor = resourceManager.getEntityDescriptor(_, entityType);
	var inConflict = false;
	var inRemoteVersion = false;
	var localVersion = "";
	var remoteVersion = "";
	file.text.reader(jsonFile, "utf8").transform(ez.transforms.lines.parser()).forEach(_, function (_, line) {
		if (line[0] == '<') {
			inConflict = true;
			inRemoteVersion = true;
		} else if (line[0] === '=') {
			inRemoteVersion = false;
		} else if (line[0] == '>') {
			inConflict = false;
		} else {
			if (inConflict) {
				if (inRemoteVersion)
					remoteVersion += line;
				else
					localVersion += line;
			} else {
				remoteVersion += line;
				localVersion += line;
			}
		}
	});
	var remoteObject = JSON.parse(remoteVersion);
	var localObject = JSON.parse(localVersion);
	var result = _findDifferences(_, superv, entityDescriptor, "", "", localObject, remoteObject, options);
	_scanProblems(result);
	var writer = file.text.writer("c:\\out.xml", "utf8");
	writer.write(_, require('util').inspect(result, false, null));
	writer.write(_);
	return {
		result: result,
		hasConflicts: (result.$problems.count > 0),
		atLeastOneConflictFixed: atLeastOneConflictFixed,
		entityType: undefined as any,
	};
};