"use strict";
var supervisor = require("etna-supervisor/lib/supervisor"),
	gitWrapper = require('etna-etl/lib/gitWrapper'),
	path = require("path"),
	ez = require("ez-streams"),
	file = ez.devices.file,
	fs = require("streamline-fs"),
	patchGenerator = require("./patchGenerator");
gitWrapperInstance;

/// !doc
/// # Patch generator
/// Tools to generate patch files from versionned (git) JSON files that contain metadata
/// Usage : 
/// ```
/// require("syracuse-scm/lib/patchGenerator").newGenerator(_, config).synchonize(_);
/// ```
exports.newSync = function(_, config) {

	config.git = config.git || {};
	config.settingsTable = config.settingsTable || "_SETTINGS";

	// Normalize the meta folder
	config.metaSubFolder = path.join(config.metaSubFolder + "/").toLowerCase();
	var superv = supervisor.create(_, config);

	try {
		// Make sure the settings table exists
		superv.sqlDriver.getTableDef(_, superv.folderName, config.settingsTable);
	} catch (err) {
		var tableDef = {
			schemaName: superv.folderName,
			tableName: config.settingsTable,
			columns: [{
				name: "ID",
				isNullable: false,
				type: "nvarchar",
				maxLength: 100
			}, {
				name: "VALUE",
				isNullable: true,
				type: "clob",
			}],
			indexes: [],
		};
		superv.sqlDriver.createTableFromTableDefinition(_, tableDef);
		config.trace && config.trace("Settings table '" + tableDef.tableName + "' was created.");
	}

	function _getGitWrapper() {
		if (!gitWrapperInstance) {
			var options = {
				folder: config.gitFolder || config.solutionPath,
				trace: config.git.trace
			};
			gitWrapperInstance = new gitWrapper.git(options);
		}
		return gitWrapperInstance;
	}

	function _applyPatches(_, patchFilenames) {
		if (!patchFilenames.length)
			return;
		console.log("******* TODO ***********");
		console.log("apply the following patches : ");
		patchFilenames.forEach(function(patchFilename) {
			console.log("\t-" + patchFilename);
		});
	}

	return {

		/// !doc
		/// ### getLastSyncdSha1(_)
		/// Returns the sha1 that was last synchronized
		getLastSyncdSha1: function(_) {
			var sha1;
			try {
				superv.sqlDriver.withConnection(_, function(_, cnx) {
					var row = superv.sqlDriver.reader(_, cnx, "select VALUE from " + config.settingsTable + " where ID = " + superv.sqlDriver.param(0), ["PATCH.SYNC.LAST.GIT.HEAD"]).toArray(_)[0];
					if (!row) {
						return null;
					}
					sha1 = JSON.parse(row.VALUE).sha1;
				});
			} catch (err) {
				console.log("ERROR : " + err.message);
			}
			return sha1;
		},

		/// !doc
		/// ### setLastSyncdSha1(_, sha1)
		/// Stores the sha1 that was last synchronized
		setLastSyncdSha1: function(_, sha1) {
			try {
				superv.sqlDriver.withConnection(_, function(_, cnx) {
					superv.sqlDriver.execute(_, cnx, "delete from " + config.settingsTable + " where ID = " + superv.sqlDriver.param(0), ["PATCH.SYNC.LAST.GIT.HEAD"]);
					var valueToWrite = JSON.stringify({
						sha1: sha1,
						date: new Date().toISOString()
					});
					superv.sqlDriver.execute(_, cnx, "insert into " + config.settingsTable + " (ID, VALUE) values (" + superv.sqlDriver.param(0) + "," + superv.sqlDriver.param(1) + ")", ["PATCH.SYNC.LAST.GIT.HEAD", valueToWrite]);
				});
			} catch (err) {
				console.log("ERROR : " + err.message);
			}
			config.trace && config.trace("'" + sha1 + "' written as the last sync'd head.");
		},


		/// !doc
		/// --------------------------
		/// ### synchronize(_, options)
		/// Updates the metadata from a git repository.
		/// The local git repo will first be sync'd (git pull) and, if no errors occured,
		/// a patch file will be generated from all the updated/created JSON files.
		/// This patch file will then be sent to the server so that it can update its metadata.
		synchronize: function(_, options) {
			options = options || {};

			if (config.trace) {
				var currentBranchResult = _getGitWrapper().getBranch(_);
				if (0 === currentBranchResult.exitCode)
					config.trace("Current branch is [" + currentBranchResult.out + "]");
				else
					config.trace("Could not get the current branch, reason = " + currentBranchResult.err);
				config.trace("Local git folder : " + _getGitWrapper().getFolder());
				config.trace("Git pull...");
			}
			// Run a git pull command to retreive all the new/updated json files
			var result = _getGitWrapper().pull(_);
			if (result.exitCode) {
				// Something went wrong ... maybe a conflict
				// For now, we can't do anything
				var msg = "The git-pull failed, reason = " + result.err;
				config.trace && config.trace(msg);
				throw new Error(msg);
			}

			var lastSyncdSha1;
			if (!options.full)
				lastSyncdSha1 = this.getLastSyncdSha1(_);
			if (config.trace) {
				if (lastSyncdSha1)
					config.trace("Last sync'd head = " + lastSyncdSha1);
				else
					config.trace("Last sync'd head = not set => full sync");
			}

			var gitHead = this.getGitHead(_);
			config.trace && config.trace("Git head = " + gitHead.sha1);

			// First : retrieve the files that have been updated (or created) between the two revisions			
			var updatedFilesList = _getGitWrapper().ListModifiedFiles(_, lastSyncdSha1, gitHead.sha1);

			if (updatedFilesList.length) {
				var pg = patchGenerator.newGenerator(_, options);
				var patchFilenames = pg.generatePatches(_, updatedFilesList, options);
				_applyPatches(_, patchFilenames);

				// Store the current head in db so that next sync will be incremental
				this.setLastSyncdSha1(_, gitHead.sha1);
			} else {
				config.trace && config.trace("Already up-to-date, no patch needed.");
			}
		},

		resolveConflitcs: function(_, entity, jsonFile, options) {
			var inConflict = false;
			var inPreviousVersion = false;
			var currentVersion = "";
			var previousVersion = "";
			file.text.reader(jsonFile, "utf8").transform(ez.transforms.lines.parser()).forEach(_, function(_, line) {
				if (line[0] == '<') {
					inConflict = true;
					inPreviousVersion = true;
				} else if (line[0] === '=') {
					inPreviousVersion = false;
				} else if (line[0] == '>') {
					inConflict = false;
				} else {
					if (inConflict) {
						if (inPreviousVersion)
							previousVersion += line;
						else
							currentVersion += line;
					} else {
						previousVersion += line;
						currentVersion += line;
					}
				}
			});
			var writer = file.text.writer("c:\\out.xml", "utf8");
			writer.write(_, previousVersion);
			writer.write(_);
			var prevObj = JSON.parse(previousVersion);
			var currentObj = JSON.parse(currentVersion);
			var result = findDifferences(_, entity, "", "", prevObj, currentObj, options);
			console.log(JSON.stringify(result, undefined, "    "));
		}
	};


	function findDifferences(_, entity, propName, path, valLeft, valRight, options) {

		var localizedLabels = {};
		options = options || {};

		if (options.skipSpecials && ("##" === propName.slice(0, 2))) {
			// Skip special tags (##texts##, ##comments##, ...)
			return undefined;
		}



		function getLocalizedLabel(_, tableName, columnName) {
			if (!localizedLabels[tableName]) {
				// Load all the localized labels for this table
				var sql = "SELECT z.CODZONE_0 ZONE, t.TEXTE_0 TEXT FROM ATABZON z";
				sql += " LEFT JOIN ATEXTE t ON t.NUMERO_0 = z.NOLONG_0";
				sql += " WHERE z.CODFIC_0=" + superv.sqlDriver.param(0) + " AND t.LAN_0 = " + superv.sqlDriver.param(1);
				superv.sqlDriver.withConnection(_, function(_, cnx) {
					superv.sqlDriver.execute(_, cnx, sql, [tableName, options.langage || "FRA"]).forEach(function(row) {
						localizedLabels[tableName + "." + row.ZONE] = row.TEXT;
					});
				});
				localizedLabels[tableName] = tableName;
			}
			var key = tableName + '.' + columnName;
			var label = localizedLabels[key];
			if (!label)
				label = key;
			return label;
		}

		function getDistance(a, b) {
			if (a.length == 0) return b.length;
			if (b.length == 0) return a.length;

			var matrix = [];

			// increment along the first column of each row
			var i;
			for (i = 0; i <= b.length; i++) {
				matrix[i] = [i];
			}

			// increment each column in the first row
			var j;
			for (j = 0; j <= a.length; j++) {
				matrix[0][j] = j;
			}

			// Fill in the rest of the matrix
			for (i = 1; i <= b.length; i++) {
				for (j = 1; j <= a.length; j++) {
					if (b.charAt(i - 1) == a.charAt(j - 1)) {
						matrix[i][j] = matrix[i - 1][j - 1];
					} else {
						matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
							Math.min(matrix[i][j - 1] + 1, // insertion
								matrix[i - 1][j] + 1)); // deletion
					}
				}
			}

			return matrix[b.length][a.length];
		};

		function indexArray(entity, array) {
			var indexedArray = {};
			array.forEach(function(instance) {
				indexedArray[instance[getPK(entity)]] = instance;
			});
			return indexedArray;
		}

		function getPK(entity) {
			return entity.primaryKey || entity.patchPK || entity.orderBy;
		}


		var result = undefined;
		//console.log(path + " : compare " + valLeft + " / " + valRight);
		if (valLeft == valRight) {
			if (options.skipMatching)
				return undefined;
			return {
				label: getLocalizedLabel(_, entity.tableName, propName),
				path: path,
				status: "match",
				value: valLeft
			};
		}
		if (Array.isArray(valLeft)) {
			// Assume that valRight is also an array
			var subEntity;
			if (entity.children && entity.children.hasOwnProperty(propName)) {

				// This is a subObject
				subEntity = entity.children[propName];
				// We have to index all the items by their PK to be sure to compare the good pairs.
				// for instance, in a table, there will be a subObject named "COLUMNS" that will describe all the columns.
				// We can't be sure that the columns were serialized in the same order in the left and in the right object.
				var arrLeft = indexArray(subEntity, valLeft);
				var arrRight = indexArray(subEntity, valRight);
				result = findDifferences(_, subEntity, propName, path, arrLeft, arrRight, options);

			} else {
				// TODO !!!
				// Here, the items of the array can't be indexed, so we have no other choice than
				// assuming (or hoping...) that all the items are sorted the same way on the 2 arrays.
				// Might be improved later (maybe by using levenshtein distance based algo to identify the bast pairs)
				for (var i = 0; i < Math.min(valLeft.length, valRight.length); i++) {
					var subResult = findDifferences(_, entity, propName, path + "[" + i + "]", valLeft[i], valRight[i], options);
					if (subResult) {
						result = result || [];
						result.push(subResult);
					}
				}
				for (var i = Math.min(valLeft.length, valRight.length); i < valLeft.length; i++) {
					result.push({
						path: path + "[" + i + "]",
						status: "missing",
						left: valLeft[i],
					});
				}
				for (var i = Math.min(valLeft.length, valRight.length); i < valRight.length; i++) {
					result.push({
						path: path + "[" + i + "]",
						status: "missing",
						right: valRight[i],
					});
				}
			}

		} else if ("object" === typeof(valLeft)) {
			// Assume that valRight is also an object
			Object.keys(valLeft).forEach_(_, function(_, childPropName) {
				if (!valRight.hasOwnProperty(childPropName)) {
					result = result || {};
					result[childPropName] = {
						label: getLocalizedLabel(_, entity.tableName, childPropName),
						path: path + "/" + childPropName,
						status: "missing",
						left: valLeft[childPropName],
					};
					return;
				}
				var propVal1 = valLeft[childPropName];
				var propVal2 = valRight[childPropName];
				var subResult = findDifferences(_, entity, childPropName, path + "/" + childPropName, propVal1, propVal2, options);
				if (subResult) {
					result = result || {};
					result[childPropName] = subResult;
				}
				delete valRight[childPropName];
			});
			// Here, valRight only contains the properties that are not declared in valLeft
			Object.keys(valRight).forEach_(_, function(_, childPropName) {
				result = result || {};
				result[childPropName] = {
					label: getLocalizedLabel(_, entity.tableName, childPropName),
					path: path + "/" + childPropName,
					status: "missing",
					right: valRight[childPropName],
				};
			});
		} else {
			result = {
				label: getLocalizedLabel(_, entity.tableName, propName),
				path: path,
				status: "mismatch",
				left: valLeft,
				right: valRight,
			};
		}
		return result;
	}
};