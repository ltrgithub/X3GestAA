"use strict";

var express = require('express'),
	exphbs = require('express-handlebars'),

	app = express(),
	ez = require('ez-streams'),
	os = require('os'),

	http = require('http'),
	bodyParser = require('body-parser'),

	config = require('./config').config,

	gitWrapper = require('etna-etl/lib/gitWrapper'),
	patchGenerator = require('syracuse-scm/lib/patchGenerator'),
	child_process = require('child_process'),
	path = require("path"),
	fs = require("streamline-fs"),
	file = ez.devices.file,
	log = console.log,
	debug = console.log;

var trackers = [];


function sendSDataRequest(_, scmConfig, path, options) {
	options = options || {};
	var request = ez.devices.http.client({
		method: options.method || "get",
		user: scmConfig.x3.user,
		password: scmConfig.x3.password,
		url: 'http://localhost:' + scmConfig.syracuse.port + '/sdata/syracuse/collaboration/syracuse/' + path,
		headers: {
			//			Authorization: 'Basic YWRtaW46YWRtaW4=',
			'content-type': 'application/json',
		},
	});
	var response = request.end(options.data ? JSON.stringify(options.data) : undefined).response(_);

	return {
		statusCode: response.statusCode,
		body: (200 === response.statusCode) ? JSON.parse(response.readAll(_)) : undefined
	};
}

function callSDataService(_, scmConfig, serviceName, options) {
	var result = sendSDataRequest(_, scmConfig, "scmConfigs/$service/" + serviceName, options);
	//	var result = sendSDataRequest(_, "syracuse/collaboration/syracuse/scmConfigs('" + uuid + "')/$service/" + serviceName, options);
	if (result.statusCode !== 200) {
		throw buildStatusCodeError("Failed :(", result);
	}
	return result.body;
}

function buildStatusCodeError(err, requestResult) {
	var error = new Error(err);
	error.statusCode = requestResult.statusCode || 500;
	return error;
}

function getScmConfig(configId) {
	var cfg = config.configurations.filter(function(cfg) {
		return cfg.id === configId;
	})[0];
	cfg.patch = cfg.patch || {};
	cfg.syracuse = cfg.syracuse || {};
	cfg.syracuse.port = cfg.syracuse.port || 8124;
	cfg.gitFolder = path.join(cfg.gitFolder); // Normalize folder
	return cfg;
}

function getScmConfigs() {
	return config.configurations;
	// var result = sendSDataRequest(_, 'syracuse/collaboration/syracuse/scmConfigs?representation=scmConfig.$query');
	// if (200 === result.statusCode) {
	// 	return result.body.$resources.map(function(item) {
	// 		return {
	// 			$uuid: item.$uuid,
	// 			$shortUrl: item.$shortUrl,
	// 			name: item.name,
	// 			gitFolder: item.gitFolder,
	// 			gitBranch: item.gitBranch,
	// 			user: item.gitUser,
	// 		};
	// 	});
	// }
	// throw new Error("Could not get configuration");
}

function contactSyracuse(_, scmConfig) {
	debug && debug("contactSyracuse(" + scmConfig.id + ")");

	// The sdata service will return a response that looks like : 
	//  { 
	//		solutionFolder : xxxx,  // The x3 solution folder
	//		lastSyncdSha1 : xxxx 	// the last sync'd git sha1
	// 	}

	try {
		var result = callSDataService(_, scmConfig, "getSyncInfos", {
			method: "post",
			data: {
				endPoint: scmConfig.x3.endPoint
			}
		});
		if (scmConfig.fullSync) {
			// Force full resync
			result.lastSyncdSha1 = null;
		}
		return result;
	} catch (err) {
		throw new Error("Could not connect to Syracuse (port " + scmConfig.syracuse.port + "). Please check that Syracuse is started (reason = " + err.message + ")");
	}
}

function writeLastSyncdSha1(_, scmConfig, sha1) {
	debug && debug("writeLastSyncdSha1(" + scmConfig.id + ", " + sha1 + ")");

	return callSDataService(_, scmConfig, "setLastSyncdGitHead", {
		method: "post",
		data: {
			endPoint: scmConfig.x3.endPoint,
			sha1: sha1
		}
	});
}


function gitUpdate(_, scmConfig, lastSyncdSha1) {


	debug && debug("gitUpdate(" + scmConfig.id + ")");
	var gw = new gitWrapper.git({
		folder: scmConfig.gitFolder
	});

	// Retrieve from X3 the last syncd git head
	debug && debug("last sha1 = " + lastSyncdSha1);
	if (lastSyncdSha1)
		log && log("Last sync'd sha1 : " + lastSyncdSha1);
	else
		log && log("No last sync'd sha1 provided : full synchronization");

	var result = gw.pull(_);
	debug && debug("git pull : exitCode = " + result.exitCode + ", err = " + result.err);
	if (result.exitCode)
		throw new Error("Git pulled failed (" + result.exitCode + "), reason = " + result.err);

	var currentSha1 = gw.getHead(_).sha1;
	debug && debug("new sha1 = " + currentSha1);

	// Retrieve the modified files between the 2 sha1
	var files = gw.listModifiedFiles(_, lastSyncdSha1, currentSha1);
	debug && debug(files.length + " files to process");
	return {
		files: files,
		sha1: currentSha1,
		hasConflicts: false,
		needToStartStopServers: true,
	};
}

function generatePatch(_, scmConfig, files) {
	debug && debug("generatePatch(" + scmConfig.id + ", " + files.length + " files)");

	var options = scmConfig;
	options.folder = path.join(scmConfig.solutionFolder, scmConfig.patchSubFolder);
	var pg = patchGenerator.newGenerator(_, options);

	// First, we are going to filter json files
	var jsonFiles = files.filter(function(filename) {
		return filename.slice(-5) === '.json';
	});

	if (jsonFiles.length == 0) {
		// Nothing to do
		return null;
	}

	var patchFilename = pg.generatePatches(_, jsonFiles, {})[0];
	debug && debug("generated patch = " + patchFilename);
	return patchFilename;
}


function createFolderIfNeeded(_, folder) {
	if (fs.exists(folder, _))
		return;
	// Check (or create) parent folder
	createFolderIfNeeded(_, path.dirname(folder));
	try {
		fs.mkdir(folder, _);
	} catch (err) {
		throw new Error("Could not create patch folder, reason = " + err.message);
	}
}

function copyFiles(_, scmConfig, solutionFolder, files) {
	files.forEach_(_, function(_, fileName) {
		var relativePath = path.join(fileName).substring(scmConfig.gitFolder.length);
		var destAbsolutePath = path.join(solutionFolder, relativePath);
		createFolderIfNeeded(_, path.dirname(destAbsolutePath));
		var reader = file.text.reader(fileName);
		var writer = file.text.writer(destAbsolutePath);
		reader.pipe(_, writer);
	});
}


function importPatch(_, scmConfig, patchFile) {
	debug && debug("importPatch(" + scmConfig.id + ", " + patchFile + ")");

	// Invoke a SData service to make X3 import the patch
	callSDataService(_, scmConfig, "importPatch", {
		method: "post",
		data: {
			patchFile: patchFile
		}
	});
}


function getGitBranch(req, res) {
	streamLine(req, res, function(_) {
			setTimeout(~_, 1000);
			var scmConfig = getScmConfig(req.body.configId);
			var result = callSDataService(_, scmConfig, "getGitBranch");
			res.send({
				result: "branch = " + result.branch,
			});
		},
		function(err) {
			res.status(err.statusCode || 500).send("git update failed, reason = " + err.message);
		});
}

function executeCommand(_, cmd, args, options) {
	var result = {};
	(function(cb) {
		var child = child_process.spawn(cmd, args, options);
		child.stdout.on('data', function(data) {
			//console.log('stdout: ' + data);
			result.stdout = (result.stdout || "") + data;
		});
		child.stderr.on('data', function(data) {
			//console.log('stderr: ' + data);
			result.stderr = (result.stderr || "") + data;
		});

		child.on('error', function(data) {
			//console.log('error: ' + data);
			result.error = data;
		});

		child.on('close', function(code) {
			result.exitCode = code;
			//console.log('child process exited with code ' + code);
			cb();
		});
	})(~_);

	return result;
}

function executeLocalScript(_, folder, scripts) {
	var validScript;
	if (!scripts.some_(_, function(_, script) {
		validScript = path.join(folder, script);
		return (fs.exists(validScript, _));
	})) {
		throw new Error("Could not find any valid script in folder " + folder + ", looked for " + scripts);
	}

	executeCommand(_, validScript, [], {
		cw: folder
	});
}

function isServiceRunning(_, serviceName) {
	// This function uses sc query xxxx . The output of the command looks like
	// SERVICE_NAME: MSSQLSERVER
	//         TYPE               : 10  WIN32_OWN_PROCESS
	//         STATE              : 4  RUNNING
	//                                 (STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN)
	//         WIN32_EXIT_CODE    : 0  (0x0)
	//         SERVICE_EXIT_CODE  : 0  (0x0)
	//         CHECKPOINT         : 0x0
	//         WAIT_HINT          : 0x0
	var result = executeCommand(_, 'sc', ['query', serviceName]);
	if (result.exitCode != 0)
		throw new Error("Could not get information on service : " + serviceName);
	return result.stdout.split(os.EOL).some(function(line) {
		line = line.trim();
		if (line.slice(0, 5) === "STATE")
			return line.indexOf("RUNNING") != -1;
		return false;
	});
}

function stopServers(_, scmConfig) {
	// Stop syracuse server
	executeLocalScript(_, scmConfig.syracuseFolder, ["servicestop.cmd", "servicestop.sh"]);
	// First check if the service is running

	if (!isServiceRunning(_, scmConfig.x3ServiceName)) {
		log && log("Service " + scmConfig.x3ServiceName + " not stopped (was not running)");
		return false;
	}
	// Stop X3 server
	var result = executeCommand(_, 'net', ['stop', scmConfig.x3ServiceName]);
	log && log("Service " + scmConfig.x3ServiceName + " stopped, exitCode = " + result.exitCode);
	if (result.exitCode != 0)
		throw new Error("Could not stop service " + scmConfig.x3ServiceName);
	return true;
}


function startServers(_, scmConfig) {
	// Start syracuse server
	executeLocalScript(_, scmConfig.syracuseFolder, ["servicestart.cmd", "servicestart.sh"]);
	var result = executeCommand(_, 'net', ['start', scmConfig.x3ServiceName]);
	log && log("Service " + scmConfig.x3ServiceName + " started, exitCode = " + result.exitCode);
	if (result.exitCode != 0)
		throw new Error("Could not start service " + scmConfig.x3ServiceName);
}

function renderErrorPage(res, err, fullMessage) {
	res.render('error', {
		error: err,
		fullMessage: fullMessage
	});
}

function streamLine(req, res, fn, errorHandler) {
	(function(_) {
		fn(_);
	})(_ >> function(err) {
		if (err) {
			if (log) {
				log(err);
				log(err.stack);
			}
			if (errorHandler)
				errorHandler(err);
			else
				renderErrorPage(res, err);
		}
	});
}

app.use(express.static(__dirname + '/public'));
app.use(bodyParser.json());
app.engine('handlebars', exphbs({
	defaultLayout: 'main',
	layoutsDir: __dirname + '/views/layouts'
}));
app.set('view engine', 'handlebars');
app.set('views', __dirname + '/views');

app.get('/', function(req, res) {
	streamLine(req, res, function(_) {
		res.render('home', {
			scmConfigs: getScmConfigs(),
		});
	});
});

app.get('/tracker/:trackerId/getStatus', function(req, res) {
	var trackerId = req.params.trackerId;
	if (trackerId >= trackers.length) {
		renderErrorPage(res, null, "Invalid tracker Id");
		return;
	}
	var tracker = trackers[trackerId];
	res.send(tracker);
});

app.post('/actions/update', function(req, res) {


	var configId = req.body.configId;
	var scmConfig = getScmConfig(configId);
	if (!scmConfig) {
		renderErrorPage(res, undefined, "Invalid config id : " + configId);
	}
	var trackerId = trackers.length;
	var tracker = {
		status: "running",
		phases: [],
	};
	trackers.push(tracker);
	var currentPhase;

	var result;
	streamLine(req, res, function(_) {

			// scmConfig.syracuseFolder = "D:/sources/Syracuse";
			// scmConfig.x3ServiceName = "MSSQLSERVER";
			// stopServers(_, scmConfig);
			// startServers(_, scmConfig);
			// res.send({
			// 	trackerId: trackerId,
			// });
			// return;

			currentPhase = {
				label: "Contact Syracuse",
				status: "running"
			};
			tracker.phases.push(currentPhase);
			var contactResult = contactSyracuse(_, scmConfig);
			scmConfig.solutionFolder = contactResult.solutionFolder;
			scmConfig.syracuseFolder = contactResult.syracuseFolder;
			scmConfig.x3ServiceName = contactResult.x3ServiceName;
			currentPhase.status = "done";
			currentPhase.result = "OK, folder = " + contactResult.solutionFolder;

			currentPhase = {
				label: "Update from git",
				status: "running"
			};
			tracker.phases.push(currentPhase);
			var updateResult = gitUpdate(_, scmConfig, contactResult.lastSyncdSha1);
			currentPhase.status = "done";
			if (updateResult.files.length == 0) {
				currentPhase.result = "already up-to-date";
			} else {
				currentPhase.result = "OK (" + updateResult.files.length + " files updated)";
				log && log(updateResult.files.length + " files updated, sha1 = " + updateResult.sha1);

				currentPhase = {
					label: "Generate patch file",
					status: "running"
				};
				tracker.phases.push(currentPhase);
				var patchFile = generatePatch(_, scmConfig, updateResult.files);
				currentPhase.status = "done";
				if (patchFile)
					currentPhase.result = "OK (" + patchFile + " was generated)";
				else
					currentPhase.result = "OK (no patch needed)";

				if (updateResult.needToStartStopServers) {
					currentPhase = {
						label: "Stop servers",
						status: "running"
					};
					tracker.phases.push(currentPhase);
					currentPhase.status = "done";
					if (!stopServers(_, scmConfig))
						currentPhase.result = "(was not running)";
				}

				currentPhase = {
					label: "Copy pulled files",
					status: "running"
				};
				tracker.phases.push(currentPhase);
				copyFiles(_, scmConfig, contactResult.solutionFolder, updateResult.files);
				currentPhase.status = "done";

				if (updateResult.needToStartStopServers) {
					currentPhase = {
						label: "Start servers",
						status: "running"
					};
					tracker.phases.push(currentPhase);
					startServers(_, scmConfig);
					currentPhase.status = "done";
				}

				if (patchFile) {
					currentPhase = {
						label: "Import patch",
						status: "running"
					};
					tracker.phases.push(currentPhase);
					importPatch(_, scmConfig, patchFile);
					currentPhase.status = "done";
				}

				currentPhase = {
					label: "Write last synchronized git head",
					status: "running"
				};
				tracker.phases.push(currentPhase);
				writeLastSyncdSha1(_, scmConfig, updateResult.sha1);
				currentPhase.status = "done";
			}
			tracker.status = "done";
		},
		function(err) {
			if (currentPhase && currentPhase.status === "running") {
				currentPhase.status = "error";
				currentPhase.result = err.message;
			}
			tracker.status = "error";
			tracker.error = err.message;
		});
	res.send({
		trackerId: trackerId,
	});
});

config.port = config.port || 3000;

var server = app.listen(config.port, function() {
	console.log("SCM server running at http://127.0.0.1:" + server.address().port);
});