"use strict";
var helpers = require('syracuse-core/lib/helpers');

exports.fieldsInsert = function(designLevel, isFusion, garbageObj) {
	var level = "level" + designLevel.charAt(0).toUpperCase() + designLevel.slice(1);
	var insertLibrary = (isFusion && _insertFusion[level]) || _insertStandard[level];
	var context = {
		"library": insertLibrary,
		"page": garbageObj.page,
		"isFusion": isFusion
	};
	var result = {"field": {}, "block": {}, "section": {}};
	result.field = _insertFields.call(garbageObj, level, insertLibrary, context);
	return result;
}
function _insertBlocks (level, insertLibrary, ctx) {
	var result = _helpers.initResult(), severity, message, detail;
}

function _insertFields (level, insertLibrary, ctx) {
	var i, len = this._$freeFieldBinds.length, targets = {}, $bind, ret, _getFieldSrclayout, _getFreeBlock, srcLayout, jocker;
	var oldLibrary, targetsKeys, target, localize = ctx.page.localize;
	var result = _helpers.initResult(), severity, message, detail;

	function _getMethod(name) {
		return (ctx.isFusion && _insertFusion[level] && _insertFusion[level].field && _insertFusion[level].field[name]) || _insertStandard[level][name].field;
	}
	try {
		// For each free binds, we look for the best block target
		for (i = 0; i < len; i++) {
			ctx.$bind = this._$freeFieldBinds[i];
			ret = _processEntity.call(this, ctx, "field");
			if (!ret && ctx.isFusion && insertLibrary != _insertStandard[level]) {
				oldLibrary = insertLibrary;
				ctx.library = _insertStandard[level];
				ret = _processEntity.call(this, ctx, "field");
				ctx.library = oldLibrary;
			}
			targets[ctx.$bind] = ret;
			if(!ret && ctx.diagnosis) {
				targets[ctx.$bind] = {"diagnosis": ctx.diagnosis};
			}
			else if(ret){
				targets[ctx.$bind].diagnosis = ctx.diagnosis;
			}
		}
		// For each free binds, we try to insert field in target block layout
		targetsKeys = Object.keys(targets);
		for (i = 0, len = targetsKeys.length; i < len; i++) {
			// Misc init
			target = targets[targetsKeys[i]];
			_getFieldSrclayout = _getMethod("getFieldSrclayout");
			_getFreeBlock = _getMethod("getLastFreeBlock");
			srcLayout = _getFieldSrclayout.call(this, targetsKeys[i], ctx);
			message = "autoInsertFailed";
			severity = "error";
			// Check if we have found a section/bloc, otherwise we look for a default one...
			if (!target || !target.block) {
				jocker = target ? target.section : null;
				if (!(target = _getFreeBlock.call(this, jocker, ctx))) {
					message = "autoInsertNoFreeBlock";
				} else {
					message = jocker ? "autoInsertInLastBlock" : "autoInsertInLastSecBlock";
					jocker = true;
					severity = "warning";
				}
			}
			if (target && target.block) {
				ret = _insertLayout.call(this, srcLayout, target);
				if (ret.success && !jocker) {
					severity = "info";
					message = "autoInsertSuccess";
				}
			}
			// Set diagnosis
			result.diagnoses[targetsKeys[i]] = target.diagnosis || this.makeDiagnosis(null, null, targetsKeys[i] + " : " + localize[message], severity, ret ? ret.details : null);
			result[target.diagnosis && target.diagnosis.$severity || severity]++;
		}
	} catch (e) {
		var ii, lenii;
		if (this._$freeFieldBinds) {
			for (ii = 0, lenii = this._$freeFieldBinds.length; ii < lenii; ii++) {
				if (!result.diagnoses[this._$freeFieldBinds[ii]]) {
					result.diagnoses[this._$freeFieldBinds[ii]] = this.makeDiagnosis(null, null, this._$freeFieldBinds[ii] + " : " + localize.autoInsertUnexpected, "fatal", e.message, e.stack);
					result.fatal++;
				}
			}
		}
	} finally {
		return result;
	}
};
function _processEntity (context, type) {
	var i, len, ret = false, lib = context.library[type];
	for (i = 0, len = lib.rules.length; i < len; i++) {
		if ((ret = lib[lib.rules[i]].call(this, context))) {
			break;
		}
	}
	return ret;
}

function _searchNewContainers(sectionRef, sectionAuth) {
	var i, j, leni = sectionRef.block.length, lenj = sectionAuth.block.length;
	var blockR, blockA, titBlockR, newMap = [], idxOf;
	if(leni == lenj) {
		// Just ensure all is ok (same title matching) : TODO 
	}
	else if (leni > lenj){
		j = leni;
		// Audit
		for(i = 0; i < lenj; i++) {
			blockA = sectionAuth.block[i];
			blockR = sectionRef.block[i];
			titBlockR = blockR.$title || "-";
			if(blockA.$title == titBlockR) {
				// Keep... but ensure is really same block!
				newMap[i] = {"from": i, "to": i};
			}
			else {
				idxOf = sectionAuth.boundBlocks.indexOf(blockR.$title);
				if(idxOf >= 0) {
					// Move
					newMap[idxOf] = {"from": i, "to": idxOf};
				}
				else {
					// Delete
					newMap[++j] = {"from": i, "to" : -1};
				}
			}
		}
		for(i = lenj; i < leni; i++) {
			// To add
			newMap[i] = {"from": -1, "to": i};
		}
		// Delete/move/add
		for(i = lenj; i < j; i++) {
			this._$layoutMap.section[newMap[i].from].parent.splice(this._$layoutMap.section[newMap[i].from].parentSlot, 1);
		}
		for(i = 0; i < leni; i++) {
			if(newMap[i].from != newMap[i].to) {
				this._$layoutMap.section[newMap[i].to].parent.splice(newMap[i].to, 0, this._$layoutMap.section[newMap[i].from].parent.splice(this._$layoutMap.section[newMap[i].from].parentSlot, 1));
			}
		}
		// TODO : Suppress field from new sec/block from freebinds map
	}
}

function _insertLayout(layoutToInsert, itemTarget) {
	var ret = {
		"success": true,
		"details": ""
	};
	if(itemTarget.layout.parent && itemTarget.layout.parent.$widths) {
		delete itemTarget.layout.parent.$widths;
	}
	itemTarget.layout.slot.splice(itemTarget.layout.rank, 0, layoutToInsert);
	// Warning for Convergence : have to deal with reference field, grid, dimensioned field...
	return ret;
}

var _helpers = {
	initResult: function() {
		return  {
			"diagnoses": {},
			"warning": 0,
			"success": 0,
			"error": 0,
			"fatal": 0
		}
	},
	_walkLayout: function($item, stop, callback, data) {
		if ($item.$items) {
			callback($item.$items, data);
		}
		if (!stop && $item.$layout && ($item = $item.$layout.$items)) {
			callback($item, data);
		}
	},
	_findSectionByTitle: function(map, sTitle) {
		var i, len = map.section.length;
		if (sTitle == undefined) {
			sTitle = "-";
		}
		for (i = 0; i < len; i++) {
			if (map.section[i].$title == sTitle) {
				break;
			}
		}
		return i < len ? map.section[i] : null;
	},
	_findBlockByTitle: function (map, bTitle, sTitle) {
		var found = null, sec, i, len;
		if (bTitle && (sec = _helpers._findSectionByTitle(map, sTitle))) {
			for (i = 0, len = sec.block.length; i < len; i++) {
				if (sec.block[i].$title == bTitle) {
					found = sec.block[i];
					break;
				}
			}
		}
		return found;
	},
	_searchBlock: function (map, $bind, data) {
		var found = null,
			sec, i, j, leni = map.section.length,
			lenj;
		for (i = 0; i < leni && !found; i++) {
			sec = map.section[i];
			for (j = 0, lenj = sec.block.length; j < lenj; j++) {
				if (sec.block[j].boundFields.indexOf($bind) >= 0) {
					found = sec.block[j];
					if (data) {
						data.section = sec;
					}
					break;
				}
			}
		}
		return found;
	}
};
var _insertFusion = {
	"levelField": {
		"field": {
			"rules": []
		}
	},
	"levelArticle": {
		"_isArticleLevel": true,
		"field": {
			"rules": ["$ruleById", "$ruleByTitleFromId", "$ruleByTitle", "$ruleLast"],
			"_oddFieldTypes": {
				"application/x-array": true,
				"text/rtf": true,
				"text/html": true,
				"image": true,
				"application/wid": true,
				"application/x-shockwave-flash": true
			},
			$ruleById: function(context) {
				var ret = null,
					block;
				context.fieldScope = context.page.getFieldScope(context.$bind, false);
				if ((block = context.library._findBlockById(this._$layoutMap, null, context.fieldScope))) {
					ret = context.library._checkInBlock.call(this, block, context);
				}
				return ret;
			},
			$ruleByTitleFromId: function(context) {
				var block, ret = null,
					found, data = {};
				if ((block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data))) {
					if ((found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
						ret = context.library._checkInBlock.call(this, found, context);
					}
				}
				return ret;
			},
			$ruleByTitle: function(context) {
				var ret = null,
					block, found, data = {};
				block = _helpers._searchBlock(this._$protoLayoutMap, context.$bind, data);
				if (block && (found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
					ret = context.library._checkInBlock.call(this, found, context);
				}
				return ret;
			},
			$ruleLast: function(context) {
				// Just try to resolve section
				var sec = null, data = {"justSection": true};
				context.library._findBlockById(this._$layoutMap, null, context.fieldScope, data);
				if(!data.section) {
					context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data);
					if(!data.section || !data.section.$title) {
						_helpers._searchBlock(this._$protoLayoutMap, context.$bind, data);
					}
					if(data.section && data.section.$title){
						sec = _helpers._findSectionByTitle(this._$layoutMap, data.section.$title);
					}
				}
				else {
					sec = data.section;
				}
				return sec ? {"section": sec} : null;
			},
			getFieldSrclayout: function($bind, context) {
				var block, layout = null;

				function _walk(items) {
					var i, len = items.length, $item;
					for (i = 0; i < len && !layout; i++) {
						$item = items[i];
						if ($item.$bind && $item.$bind == $bind) {
							layout = $item;
							break;
						} else {
							_helpers._walkLayout($item, !!(layout), _walk);
						}
					}
				}
				if (!(block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.page.getFieldScope($bind, false)))) {
					block = _helpers._searchBlock(this._$protoLayoutMap, context.$bind);
				}
				if (block && block.boundFields.indexOf($bind) >= 0) {
					_walk(block.items);
				}
				return layout || {
					"$bind": $bind
				};
			},
			getLastFreeBlock: function(section, context) {
				var i, block = null,
					self = this;

				function _getBlock(sec) {
					var j, blck = null;
					for (j = sec.block.length - 1; j >= 0; j--) {
						if (sec.block[j].boundFields.length > 1 || !context.library.field._oddFieldTypes[self._$properties[sec.block[j].boundFields[0]].$type]) {
							blck = sec.block[j];
							break;
						}
					}
					return blck;
				}
				if (!section) {
					for (i = this._$layoutMap.section.length - 1; i >= 0; i--) {
						if ((block = _getBlock(this._$layoutMap.section[i]))) {
							break;
						}
					}
				} else {
					block = _getBlock(section);
				}
				return block ? {"block": block, "layout": context.library._getBlockLayout.call(this, block, context.$bind, block.boundFields.length, context)} : null;
			}
		},
		_checkInBlock: function(block, context) {
			var i, len, scope, score = 0,
				fieldRank = -1;
			if ((len = block.boundFields.length) > 0) {
				for (i = 0; i < len; i++) {
					scope = context.page.getFieldScope(block.boundFields[i], false);
					if (context.fieldScope.blockRank == scope.blockRank && context.fieldScope.sectionId == scope.sectionId) {
						score++;
					}
				}
				if (score == len) {
					fieldRank = context.fieldScope.rank - 1;
				} else if (score / len * 100 > 50) {
					// TODO : resolve fieldRank!
					fieldRank = -1;
				}
			} else {
				fieldRank = 0;
			}
			return fieldRank >= 0 ? {
				"block": block,
				"layout": context.library._getBlockLayout.call(this, block, context.$bind, fieldRank, context)
			} : null;
		},
		_getBlockLayout: function(block, $bind, rank, context) {
			var i, len, parentLayout = null, slot = null, ctx = {"count": 0, "rankInSlot": 0, "lMap": []};
			var scope, mess = "autoInsertInNearestSlot", sev = "info";
			function _walk(items, data) {
				var i, len, currItem, $item;
				for (i = 0, len = items.length; i < len && !slot; i++) {
					$item = items[i];
					if ($item.$bind) {
						if (rank == 0 || ++data.count == rank) {
							slot = items;
							data.rankInSlot = rank == 0 ? 0 : i + 1;
							break;
						}
						ctx.lMap.push({"$bind": $item.$bind, "slot": items, "rank": i, "layoutP": parentLayout});
					}
					else {
						if($item.$layoutType) {
							parentLayout = $item;
						}
						_helpers._walkLayout($item, !!(slot), _walk, data);
					}
				}
			}
			_walk(block.items, ctx);
			if(!slot) {
				for (i = ctx.lMap.length - 1; i >= 0; i--) {
					scope = context.page.getFieldScope(ctx.lMap[i].$bind, false);
					if(rank >= scope.rank) {
						break;
					}
				}
				if(i < 0) {
					i = ctx.lMap.length - 1;
					mess = "autoInsertInLastSlot";
					sev = "warning";
				}
				slot = ctx.lMap[i].slot;
				parentLayout = ctx.lMap[i].layoutP;
				ctx.rankInSlot = ctx.lMap[i].rank + 1;
				context.diagnosis = this.makeDiagnosis(null, null, $bind + " : " + context.page.localize[mess], sev);
				// TODO : test empty bloc.. without slots
			}
			return {"slot": slot, "parent": parentLayout, "rank": ctx.rankInSlot};
		},
		_findBlockById: function(map, $bind, scope, data) {
			var found = null,
				sec;
			if (map.section.length >= scope.sectionRank) {
				sec = map.section[scope.sectionRank - 1];
				if (sec.$XID == scope.sectionId && sec.block.length >= scope.blockRank) {
					found = !$bind || sec.block[scope.blockRank - 1].boundFields.indexOf($bind) >= 0 ? sec.block[scope.blockRank - 1] : null;
					if (data && found) {
						data.section = sec;
					}
				}
				else if(data && data.justSection && sec.$XID == scope.sectionId && sec.block.length > 0) {
					data.section = sec;
				}
			}
			return found;
		}
	}
};

var _insertStandard = {
	"levelField": {
		"field": {
			"rules": []
		}
	},
	"levelArticle": {
		"_isArticleLevel": true,
		"block": {
			"rules": ["$ruleDummy", "$ruleLast"],
			$ruleDummy: function(context) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(context) {
				// Just try to resole section
				var sec = null;
				return sec ? {"section": sec} : null;
			}
		},
		"field": {
			"rules": ["$ruleDummy", "$ruleLast"],
			"_oddFieldTypes": {
			},
			$ruleDummy: function(context) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(context) {
				// Just try to resole section
				var sec = null;
				return sec ? {"section": sec} : null;
			}
		}
	}
};