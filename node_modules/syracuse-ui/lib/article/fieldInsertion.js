"use strict";
var helpers = require('syracuse-core/lib/helpers');
var syraUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Syra;

exports.fieldsInsert = function(designLevel, isFusion, garbageObj) {
	var level = "level" + designLevel.charAt(0).toUpperCase() + designLevel.slice(1);
	var insertLibrary = (isFusion && _insertFusion[level]) || _insertStandard[level];
	var context = {
		"library": insertLibrary,
		"level": level,
		"page": garbageObj.page,
		"isFusion": isFusion
	};
	var categories = [{
		"id": "section",
		"fct": _insertSections
	}, {
		"id": "block",
		"fct": _insertBlocks
	}, {
		"id": "field",
		"fct": _insertFields
	}];
	var i, len = _helpers._gridModes.length;
	var result = {}, category;
	if (!_helpers._gridModesMap) {
		_helpers._gridModesMap = {};
		for (i = 0; i < len; i++) {
			_helpers._gridModesMap[_helpers._gridModes[i].id] = _helpers._gridModes[i];
		}
	}
	len = categories.length;
	for (i = 0; i < len; i++) {
		category = categories[i];
		if (insertLibrary[category.id]) {
			result[category.id] = category.fct.call(garbageObj, level, insertLibrary, context);
		}
	}
	return result;
};

function _insertSections(level, insertLibrary, ctx) {
	var result = _helpers.initResult(),
		severity, message, localize = ctx.page.localize,
		target, ret,
		freeSections, i, j, title, len, lenj,
		$definedBinds = {};
	try {
		// New sections detection...
		ctx._discardSections = [];
		freeSections = ctx.library.section.getFreeSections.call(this, ctx);
		// New sections Insertion
		for (i = freeSections.length - 1; i >= 0; i--) {
			message = "autoInsertSectionFailed";
			severity = "error";
			target = _processEntity.call(this, ctx, "section", [freeSections[i]]);
			if (target) {
				ret = _insertLayout(target.layoutToInsert, target);
				if (ret.success) {
					severity = "info";
					message = "autoInsertSectionSuccess";
					// Have to suppress field from free binds map and add section in authored map
					for (j = 0, lenj = target.section.block.length; j < lenj; j++) {
						_helpers._deleteFreeBinds(target.section.block[j], this._$freeFieldBinds);
					}
					// Have to remap authored layout according section insertion
					if (ctx.library.section.afterInsertion) {
						ctx.library.section.afterInsertion.call(this, target);
					}
					this._getDefinedFieldsObject(this.article.$item, $definedBinds, this._$layoutMap);
				}
			}
			// Set diagnosis
			title = "'" + _helpers.getTitle(this.article, target && target.section.$title || freeSections[i].section.$title, "Section " + (target ? target.rankOrigin : (i + 1))) + "'";
			result.diagnoses[(i + "_inserted_")] = (target && target.diagnosis) || this.makeDiagnosis(null, null, title + " : " + localize[message], severity, ret ? ret.details : null);
			result[(target && target.diagnosis && target.diagnosis.$severity) || severity]++;
			ctx._discardSections.push(freeSections[i].mapIdx);
			freeSections.splice(i, 1);
		}
	} catch (e) {
		if (freeSections) {
			for (i = 0, len = freeSections.length; i < len; i++) {
				title = "'" + _helpers.getTitle(this.article, freeSections[i].section.$title, "Section " + freeSections[i].mapIdx) + "'";
				result.diagnoses[(i + "_inserted")] = this.makeDiagnosis(null, null, title + " : " + localize.autoInsertSectionUnexpected, "fatal", e.message, e.stack);
				result.fatal++;
			}
		} else {
			result.diagnoses["_catch"] = this.makeDiagnosis("autoInsertSectionUnexpected", null, null, "fatal", e.message, e.stack);
			result.fatal++;
		}
	} finally {
		return result;
	}
}

function _insertBlocks(level, insertLibrary, ctx) {
	var target, result = _helpers.initResult(),
		severity, message;
	var i, j, leni, lenj, title, ret, localize = ctx.page.localize,
		freeBlocks = [],
		$definedBinds = {};
	try {
		// New blocks detection...
		if (ctx._freeBlocksBySec) {
			freeBlocks = ctx._freeBlocksBySec;
		} else {
			for (i = 0, leni = this.page._$protoLayoutMap.section.length; i < leni; i++) {
				freeBlocks[i] = ctx.library.block.getFreeBlocks.call(this, i, ctx);
			}
		}
		// New blocks Insertion
		for (j = 0, lenj = freeBlocks.length; j < lenj; j++) {
			if (ctx._discardSections && ctx._discardSections.indexOf(j) >= 0) {
				continue;
			}
			for (i = freeBlocks[j].length - 1; i >= 0; i--) {
				message = "autoInsertBlockFailed";
				severity = "error";
				target = _processEntity.call(this, ctx, "block", [freeBlocks[j][i], this.page._$protoLayoutMap.section[j], j]);
				if (target) {
					ret = _insertLayout(target.layoutToInsert, target);
					if (ret.success) {
						severity = "info";
						message = "autoInsertBlockSuccess";
						// Have to delete free binds and remap authored layout according blocks insertion
						_helpers._deleteFreeBinds(target.block, this._$freeFieldBinds);
						this._getDefinedFieldsObject(this.article.$item, $definedBinds, this._$layoutMap);
					}
				}
				// Set diagnosis
				title = "'" + _helpers.getTitle(this.article, target && target.block.$title || (freeBlocks[j][i].block && freeBlocks[j][i].block.$title), "Block '" + (target ? target.rankOrigin : (i + 1)) + "'") + "' (Section '" + _helpers.getTitle(this.article, this.page._$protoLayoutMap.section[j].$title, j + 1) + "')";
				result.diagnoses[(j + "_inserted_" + i)] = (target && target.diagnosis) || this.makeDiagnosis(null, null, title + " : " + localize[message], severity, ret ? ret.details : null);
				result[(target && target.diagnosis && target.diagnosis.$severity) || severity]++;
				freeBlocks[j].splice(i, 1);
			}
		}
	} catch (e) {
		if (freeBlocks) {
			for (j = 0, lenj = freeBlocks.length; j < lenj; j++) {
				for (i = freeBlocks[j].length - 1; i >= 0; i--) {
					title = "'" + _helpers.getTitle(this.article, freeBlocks[j][i].block && freeBlocks[j][i].block.$title, "Block '?'") + " (Section '" + _helpers.getTitle(this.article, this.page._$protoLayoutMap.section && this.page._$protoLayoutMap.section[j] && this.page._$protoLayoutMap.section[j].$title, j + 1) + "')";
					result.diagnoses[(j + "_inserted_" + i)] = this.makeDiagnosis(null, null, title + " : " + localize.autoInsertBlockUnexpected, "fatal", e.message, e.stack);
					result.fatal++;
				}
			}
		} else {
			result.diagnoses["_catch"] = this.makeDiagnosis("autoInsertBlockUnexpected", null, null, "fatal", e.message, e.stack);
			result.fatal++;
		}
	} finally {
		return result;
	}
}

function _insertFields(level, insertLibrary, ctx) {
	var i, j, lenj, len = this._$freeFieldBinds.length,
		_getFieldSrclayout, _getAvailableBlock = null,
		_initialize;
	var oldLibrary, localize = ctx.page.localize,
		fldTargets;
	var result = _helpers.initResult(),
		fieldName, self = this;

	function _getFusionFldName(code) {
		var prop;
		return self._$properties && (prop = self._$properties[code]) && prop.$X3Name;
	}

	function _insert(bind, target, mode) {
		var srcLayout, message = "autoInsertFailed",
			severity = "error",
			jocker, ret, diag;
		// Check if we have found a section/bloc, otherwise we look for a default one...
		if (target && target.layoutLess) {
			message = "autoInsertLytLess";
			severity = "info";
		} else if (target && target.notBound) {
			message = "autoInsertNotBound";
			severity = "info";
		} else {
			srcLayout = _getFieldSrclayout.call(self, bind, ctx, null, mode);
			if (!target || !target.block) {
				jocker = target ? target.section : null;
				if (!_getAvailableBlock || !(target = _getAvailableBlock.call(self, jocker, ctx, mode))) {
					message = "autoInsertNoFreeBlock";
				} else {
					message = jocker ? "autoInsertInLastBlock" : "autoInsertInLastSecBlock";
					jocker = true;
					severity = "warning";
				}
			}
			if (target && target.block) {
				ret = _insertLayout.call(self, srcLayout, target, bind);
				if (ret.success && !jocker) {
					severity = "info";
					message = "autoInsertSuccess";
				}
			}
		}
		// Set diagnosis
		fieldName = ctx.isFusion && _getFusionFldName(bind);
		diag = (target && target.diagnosis) || self.makeDiagnosis(null, null, (fieldName || bind) + " : " + localize[message] + (mode ? " in mode '" + _helpers._gridModesMap[mode].label + "'" : ""), severity, ret ? ret.details : null);
		if (!result.diagnoses[bind]) {
			result.diagnoses[bind] = diag;
		} else {
			if (!result.diagnoses[bind].$diagnoses) {
				result.diagnoses[bind].$diagnoses = [];
			}
			result.diagnoses[bind].$diagnoses.push(diag);
		}
		result[target && target.diagnosis && target.diagnosis.$severity || severity]++;
	}
	try {
		// Init
		_getFieldSrclayout = _helpers._getMethod("getFieldSrclayout", ctx.isFusion, "field", level, true);
		_getAvailableBlock = _helpers._getMethod("getLastAvailableBlock", ctx.isFusion, "field", level, true);
		if ((_initialize = _helpers._getMethod("initialize", ctx.isFusion, "field", level))) {
			_initialize.call(this, ctx);
		}
		// Go
		if (ctx.isFusion) {
			this._$freeFieldBinds = _helpers._sortCvgFields(this._$freeFieldBinds, ctx.page);
		}
		for (i = 0; i < len; i++) {
			ctx.$bind = this._$freeFieldBinds[i];
			ctx._alreadyProcessedModes = {};
			fldTargets = _processEntity.call(this, ctx, "field");
			if (Array.isArray(fldTargets)) {
				for (j = 0, lenj = fldTargets.length; j < lenj; j++) {
					_insert(ctx.$bind, fldTargets[j].target, fldTargets[j].mode);
				}
			} else {
				_insert(ctx.$bind, fldTargets);
			}
		}
	} catch (e) {
		var ii, lenii;
		if (this._$freeFieldBinds) {
			for (ii = 0, lenii = this._$freeFieldBinds.length; ii < lenii; ii++) {
				if (!result.diagnoses[this._$freeFieldBinds[ii]]) {
					fieldName = ctx.isFusion && _getFusionFldName(this._$freeFieldBinds[ii]);
					result.diagnoses[this._$freeFieldBinds[ii]] = this.makeDiagnosis(null, null, (fieldName || this._$freeFieldBinds[ii]) + " : " + localize.autoInsertUnexpected, "fatal", e.message, e.stack);
					result.fatal++;
				}
			}
		}
	} finally {
		return result;
	}
}

function _processEntity(context, type, args) {
	var oldLibrary, i, len, ret = null,
		lib = context.library[type];
	var j, lenj, ok = false;
	for (i = 0, len = lib.rules.length; i < len; i++) {
		if ((ret = lib[lib.rules[i]].apply(this, [context].concat(args || [])))) {
			ok = true;
			if (Array.isArray(ret)) {
				for (j = 0, lenj = ret.length; j < lenj; j++) {
					if (!ret[j]) {
						ok = false;
						break;
					} else if (!context._alreadyProcessedModes[ret[j].mode]) {
						context._alreadyProcessedModes[ret[j].mode] = ret[j];
					}
				}
			}
		}
		if (ok) {
			break;
		}
	}
	if (!ok && context.isFusion && context.library != _insertStandard[context.level]) {
		oldLibrary = context.library;
		context.library = _insertStandard[context.level];
		ret = _processEntity.call(this, context, type, args);
		context.library = oldLibrary;
	}
	return ret;
}

function _insertLayout(layoutToInsert, itemTarget, fldBind) {
	var ret = {
		"success": true,
		"details": ""
	};
	if (itemTarget.layout.parent && itemTarget.layout.parent.$widths) {
		delete itemTarget.layout.parent.$widths;
	}
	itemTarget.layout.slot.splice(itemTarget.layout.rank, 0, layoutToInsert);
	if (fldBind) {
		// A little bit more for fields
		if (fldBind && itemTarget.block && itemTarget.block.boundFields && itemTarget.rank !== null) {
			itemTarget.block.boundFields.splice(itemTarget.rank, 0, fldBind);
		}
	}
	return ret;
}

var _helpers = {
	_gridModes: [{
		"id": "$fldMDGrid",
		"label": "grid"
	}, {
		"id": "$fldMDPopup",
		"label": "popup"
	}],
	_getMethod: function(name, isFusion, category, level, deft) {
		return (isFusion && _insertFusion[level] && _insertFusion[level][category] && _insertFusion[level][category][name]) || ((!isFusion || deft) ? (_insertStandard[level][category][name] || _helpers["cmn" + level][name]) : null);
	},
	getTitle: function(api, code, id) {
		var title;
		if (!code || code == "-") {
			title = id;
		} else if (api && api.getLocalizeText) {
			title = api.getLocalizeText(code);
		} else {
			title = code;
		}
		return title;
	},
	initResult: function() {
		return {
			"diagnoses": {},
			"warning": 0,
			"success": 0,
			"error": 0,
			"fatal": 0,
			"info": 0
		};
	},
	_walkLayout: function($item, stop, callback, data) {
		if ($item.$items) {
			callback($item.$items, data);
		}
		if (!stop && $item.$layout && ($item = $item.$layout.$items)) {
			callback($item, data);
		}
	},
	_findSectionByTitle: function(map, sTitle) {
		var i, len = map.section.length;
		if (sTitle == undefined) {
			sTitle = "-";
		}
		for (i = 0; i < len; i++) {
			if (map.section[i].$title == sTitle) {
				break;
			}
		}
		return i < len ? map.section[i] : null;
	},
	_findBlockByTitle: function(map, bTitle, sTitle) {
		var found = null,
			sec, i, len;
		if (bTitle && (sec = _helpers._findSectionByTitle(map, sTitle))) {
			for (i = 0, len = sec.block.length; i < len; i++) {
				if (sec.block[i].$title == bTitle) {
					found = sec.block[i];
					break;
				}
			}
		}
		return found;
	},
	_searchBlockHoldBind: function(map, $bind, data) {
		var found = null,
			sec, i, j, leni = map.section.length,
			lenj;
		for (i = 0; i < leni && !found; i++) {
			sec = map.section[i];
			for (j = 0, lenj = sec.block.length; j < lenj; j++) {
				if (sec.block[j].boundFields.indexOf($bind) >= 0) {
					found = sec.block[j];
					if (data) {
						data.section = sec;
					}
					break;
				}
			}
		}
		return found;
	},
	_deleteFreeBinds: function(block, freeBindsMap) {
		var i, len, idxOf;
		for (i = 0, len = block.boundFields.length; i < len; i++) {
			if ((idxOf = freeBindsMap.indexOf(block.boundFields[i])) >= 0) {
				freeBindsMap.splice(idxOf, 1);
			}
		}
	},
	_findBlockById: function(map, $bind, scope, data, page) {
		var found = null,
			sec, secScope;
		if (map.section.length >= scope.sectionRank) {
			sec = map.section[scope.sectionRank - 1];
			secScope = page.getFieldScope(sec.$XID, false, true);
			if (secScope.sectionId == scope.sectionId && sec.block.length >= scope.blockRank) {
				found = !$bind || sec.block[scope.blockRank - 1].boundFields.indexOf($bind) >= 0 ? sec.block[scope.blockRank - 1] : null;
				if (data && found) {
					data.section = sec;
				}
			} else if (data && data.justSection && secScope.sectionId == scope.sectionId && sec.block.length > 0) {
				data.section = sec;
			}
		}
		return found;
	},
	_getFieldlayoutFromMap: function(layoupMap, $bind, context, byPassById) {
		var block, layout = null;
		if (byPassById || !(block = _helpers._findBlockById(layoupMap, $bind, context.page.getFieldScope($bind, false), null, context.page))) {
			block = _helpers._searchBlockHoldBind(layoupMap, $bind);
		}
		if (block && block.boundFields.indexOf($bind) >= 0) {
			_helpers._walkOnBlockLayoutItems(block.items, function(bd, itm) {
				var ret = false;
				if (bd == $bind) {
					ret = true;
					layout = itm;
				}
				return ret;
			});
		}
		return layout;
	},
	_sortCvgFields: function(fldAIn, page) {
		return fldAIn.sort(function(left, right) {
			var lId, ltScope = page.getFieldScope(left);
			var rId, rScope = page.getFieldScope(right);
			lId = (ltScope.sectionRank << 24) + (ltScope.blockRank << 16) + (ltScope.rank << 8);
			rId = (rScope.sectionRank << 24) + (rScope.blockRank << 16) + (rScope.rank << 8);
			return lId - rId;
		});
	},
	_walkOnBlockLayoutItems: function(items, callback, data) {
		function _walk(items) {
			var i, len = items.length,
				$item, stop = false;
			if (items) {
				for (i = 0; i < len; i++) {
					$item = items[i];
					if ($item.$bind) {
						if (callback($item.$bind, $item, data)) {
							stop = true;
							break;
						}
					} else {
						_helpers._walkLayout($item, stop, _walk, data);
					}
				}
			}
		}
		_walk(items);
	},
	_getGridFieldModes: function(gridArticle, fldBind, context) {
		var _getFieldSrclayout, modes = [],
			proto = syraUtil.getFieldProtoFromCollObj(gridArticle, fldBind);
		var i, len = _helpers._gridModes.length;
		if (proto && false) {
			// TODO when when the time comes...
			//modes = ["$fldMDGrid", "$fldMDPopup", "$fldMDVcard", "...];
		} else if (context._layoutFldR) {
			_getFieldSrclayout = _helpers._getMethod("getFieldSrclayout", context.isFusion, "field", context.level, true);
			for (i = 0; i < len; i++) {
				if (_getFieldSrclayout(fldBind, context, {
					"strict": true,
					"$gridBind": gridArticle.$item.$bind
				}, _helpers._gridModes[i].id)) {
					modes.push(_helpers._gridModes[i].id);
				}
			}
		}
		return modes;
	},
	_getLayoutAGridModes: function(gridArticle) {
		var ret = null,
			articleLyt = gridArticle.$item;
		if (articleLyt) {
			ret = {};
			ret.$fldMDGrid = articleLyt.$layout ? articleLyt.$layout.$items : null;
			if (articleLyt.$popupCard) {
				ret.$fldMDPopup = articleLyt.$popupCard.$layout ? articleLyt.$popupCard.$layout.$items : null;
			}
		}
		return ret;
	},
	_processRuleMulitModes: function(mode, context, callback) {
		var ret = {
			"mode": mode
		};
		var alreadyP = context._alreadyProcessedModes && context._alreadyProcessedModes[mode];
		if (alreadyP) {
			return alreadyP;
		} else {
			ret.target = callback();
			return ret.target ? ret : null;
		}
	},
	"cmnlevelField": {
		getFieldSrclayout: function($bind, context, data, mode) {
			var layoutP, layout = null,
				cards;
			layoutP = context._layoutFldR || _helpers._getFieldlayoutFromMap(context.page._$protoLayoutMap, (this && this.article ? this.article.$item.$bind : data.$gridBind), context, true);
			if (layoutP) {
				switch (mode) {
					case "$fldMDGrid":
						break;
					case "$fldMDPopup":
						layoutP = (cards = layoutP.$cards) && cards.$position == "popup" ? cards : null;
						break;
					default:
						layoutP = null;
				}
				if (layoutP) {
					_helpers._walkOnBlockLayoutItems(layoutP.$layout.$items, function(bd, itm) {
						var ret = false;
						if (bd == $bind) {
							ret = true;
							layout = itm;
						}
						return ret;
					});
				}
			}
			return layout || (!data || !data.strict ? {
				"$bind": $bind
			} : null);
		}
	},
	"cmnlevelArticle": {
		getFieldSrclayout: function($bind, context, data) {
			return _helpers._getFieldlayoutFromMap(this.page._$protoLayoutMap, $bind, context, !context.isFusion);
		}
	}
};
var _insertFusion = {
	"levelField": {
		"field": {
			"rules": ["$ruleLast"],
			$ruleLast: function(context) {
				var i, len;
				var grdFldModes, grdLytdModes, ret = null,
					block = {
						"boundFields": []
					};
				// Retrieve an process different modes for this new field
				grdFldModes = _helpers._getGridFieldModes(this.article, context.$bind, context);
				grdLytdModes = _helpers._getLayoutAGridModes(this.article);
				if (!grdLytdModes) {
					ret = {
						"layoutLess": true
					};
				} else if (grdFldModes && (len = grdFldModes.length)) {
					context.fieldScope = context.page.getFieldScope(context.$bind, false);
					ret = [];
					for (i = 0; i < len; i++) {
						ret[i] = _helpers._processRuleMulitModes(grdFldModes[i], context, function() {
							var target, block = {
									"boundFields": []
								};
							block.items = grdLytdModes[grdFldModes[i]] || [];
							if (block.items && block.items.length) {
								_helpers._walkOnBlockLayoutItems(block.items, function($bind) {
									block.boundFields.push($bind);
									return false;
								});
								target = _insertFusion._checkInBlock.call(this, block, context);
							} else {
								target = {
									"layoutLess": true
								};
							}
							return target;
						});
					}
				} else {
					ret = {
						"notBound": true
					};
				}
				return ret;
			},
			initialize: function(context, data) {
				context._layoutFldR = _helpers._getFieldlayoutFromMap(this.page._$protoLayoutMap, this.article.$item.$bind, context, true);
			}
		}
	},
	"levelArticle": {
		"_isArticleLevel": true,
		"field": {
			"rules": ["$ruleDimField", "$ruleById", "$ruleByTitleFromId", "$ruleByTitle", "$ruleLast"],
			"_oddFieldTypes": {
				"application/x-array": true,
				"text/rtf": true,
				"text/html": true,
				"image": true,
				"application/wid": true,
				"application/x-shockwave-flash": true
			},
			$ruleDimField: function(context) {
				var ret = null,
					block, name, i, len, persisteP, score = 0,
					bindDim, targetLayout, dimFldName;

				function _getDimName(fldName) {
					var dimIdx, dimMap = {
							"n": null,
							"id": null
						}, ret = false;
					if ((dimIdx = fldName.lastIndexOf("_")) > 0 && (dimMap.id = name.substring(dimIdx + 1))) {
						dimMap.id = parseInt(dimMap.id, 10);
						if (!isNaN(dimMap.id) && (dimMap.n = name.substring(0, dimIdx))) {
							ret = true;
						}
					}
					return ret ? dimMap : null;
				}
				if ((name = this._$properties[context.$bind].$X3Name) && (persisteP = this.article.$persistPrototype && this.article.$persistPrototype.$properties)) {
					if ((dimFldName = _getDimName(name))) {
						for (i = 1; i < dimFldName.id; i++) {
							score = persisteP[dimFldName.n + "_" + (i + 1)] ? score + 1 : score;
						}
						if (score && score == dimFldName.id - 1 && (bindDim = persisteP[dimFldName.n + "_" + (dimFldName.id - 1)].$xid)) {
							// So new occurrences of sized field
							block = _helpers._searchBlockHoldBind(this._$layoutMap, bindDim);
							if (block && (targetLayout = _insertFusion._getBlockLayout.call(this, block, context.$bind, {
								"bind": bindDim,
								"after": true
							}, context, {
								"strictRow": true
							}))) {
								ret = {
									"rank": block.boundFields.indexOf(bindDim) + 1,
									"block": block,
									"layout": targetLayout.layout,
									"diagnosis": targetLayout.diagnosis
								};
							}
						} else if (!score) {
							// Perhaps new sized field!
							for (i = 0, len = this._$freeFieldBinds.length; i < len; i++) {
								if (this._$freeFieldBinds[i] != context.$bind && (name = this._$properties[this._$freeFieldBinds[i]].$X3Name) && (dimFldName = _getDimName(name))) {
									// TODO : improve detection relevance, and process...
								}
							}
						}
					}
				}
				return ret;
			},
			$ruleById: function(context) {
				var ret = null,
					block, data = {
						"justSection": true
					}, relevance = false;
				// Check rule relevance
				context.fieldScope = context.page.getFieldScope(context.$bind, false);
				_helpers._findBlockById(this._$layoutMap, null, context.fieldScope, data, context.page);
				relevance = !data.section || (data.section.block.length != this.page._$protoLayoutMap.section[context.fieldScope.sectionRank - 1].block.length) ? false : true;
				// If OK...
				if (relevance && (block = _helpers._findBlockById(this._$layoutMap, null, context.fieldScope, null, context.page))) {
					ret = _insertFusion._checkInBlock.call(this, block, context);
				}
				return ret;
			},
			$ruleByTitleFromId: function(context) {
				var block, ret = null,
					found, data = {};
				if ((block = _helpers._findBlockById(this.page._$protoLayoutMap, context.$bind, context.fieldScope, data, context.page))) {
					if ((found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
						ret = _insertFusion._checkInBlock.call(this, found, context);
					}
				}
				return ret;
			},
			$ruleByTitle: function(context) {
				var ret = null,
					block, found, data = {};
				block = _helpers._searchBlockHoldBind(this.page._$protoLayoutMap, context.$bind, data);
				if (block && (found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
					ret = _insertFusion._checkInBlock.call(this, found, context);
				}
				return ret;
			},
			$ruleLast: function(context) {
				// Just try to resolve section
				var sec = null,
					data = {
						"justSection": true
					};
				_helpers._findBlockById(this._$layoutMap, null, context.fieldScope, data, context.page);
				if (!data.section) {
					_helpers._findBlockById(this.page._$protoLayoutMap, context.$bind, context.fieldScope, data, context.page);
					if (!data.section || !data.section.$title) {
						_helpers._searchBlockHoldBind(this.page._$protoLayoutMap, context.$bind, data);
					}
					if (data.section && data.section.$title) {
						sec = _helpers._findSectionByTitle(this._$layoutMap, data.section.$title);
					}
				} else {
					sec = data.section;
				}
				return sec ? {
					"section": sec
				} : null;
			},
			getLastAvailableBlock: function(section, context) {
				var i, block = null,
					self = this,
					targetLayout;

				function _getBlock(sec) {
					var j, blck = null;
					for (j = sec.block.length - 1; j >= 0; j--) {
						if (sec.block[j].boundFields.length > 1 || !context.library.field._oddFieldTypes[self._$properties[sec.block[j].boundFields[0]].$type]) {
							blck = sec.block[j];
							break;
						}
					}
					return blck;
				}
				if (!section) {
					for (i = this._$layoutMap.section.length - 1; i >= 0; i--) {
						if ((block = _getBlock(this._$layoutMap.section[i]))) {
							break;
						}
					}
				} else {
					block = _getBlock(section);
				}
				targetLayout = _insertFusion._getBlockLayout.call(this, block, context.$bind, {
					"last": true
				}, context);
				return block && targetLayout ? {
					"rank": block.boundFields.length,
					"block": block,
					"layout": targetLayout.layout,
					"diagnosis": targetLayout.diagnosis
				} : null;
			}
		},
		"block": {
			"rules": ["$ruleByRank", "$ruleLast"],
			$ruleByRank: function(context, freeBlock, srcSection, srcSectionRank) {
				var ret = null,
					i, j, k, len, secA, last = false;
				var blockA, lenA, rank, scope, score = 0,
					diagnosis;
				var authoBlocks = {}, temp;
				// Resolve authored section according source section description
				secA = context.library._getAuthoredSectionForBind.call(this, freeBlock.block.boundFields.length ? freeBlock.block.boundFields[0] : null, srcSection.$title, context);
				if (secA) {
					lenA = secA.block.length;
					// New blocks insertion rank resoluteness
					for (i = 0; i < lenA; i++) {
						blockA = secA.block[i];
						temp = [];
						for (j = 0, len = blockA.boundFields.length; j < len; j++) {
							scope = context.page.getFieldScope(blockA.boundFields[j]);
							temp[scope.blockRank] = !temp[scope.blockRank] ? 1 : temp[scope.blockRank] + 1;
						}
						rank = -1;
						k = 0;
						for (j = 0, len = temp.length; j < len; j++) {
							if (temp[j] && temp[j] > k) {
								k = temp[j];
								rank = j;
							}
						}
						if (rank >= 0 && !authoBlocks[rank.toString()]) {
							authoBlocks[rank.toString()] = i;
						}
					}
					// Process...
					temp = Object.keys(authoBlocks).sort(function(left, right) {
						var l = parseInt(left, 10),
							r = parseInt(right, 10);
						return left - right;
					});
					for (i = 0, lenA = temp.length; i < lenA; i++) {
						if (freeBlock.rank <= parseInt(temp[i], 10)) {
							break;
						}
					}
					// TODO : test section without block!
					if (i < lenA || (last = freeBlock.rank == (parseInt(temp[lenA - 1], 10) + 1))) {
						blockA = secA.block[!last ? authoBlocks[temp[i]] : lenA - 1];
						ret = context.library._processNewBlock.call(this, freeBlock.rank, freeBlock.block, freeBlock.excludeBinds, blockA.parent, !last ? blockA.parentSlot : blockA.parent.length, blockA.parentLayout);
					} else {
						// By default, insertion in the nearest or last slot of section
						if (lenA >= freeBlock.rank) {
							blockA = secA.block[freeBlock.rank - 1];
							rank = blockA.parentSlot;
						} else {
							blockA = secA.block[lenA - 1];
							rank = blockA.parent.length;
						}
						diagnosis = this.makeDiagnosis(null, null, "'" + _helpers.getTitle(this.article, freeBlock.block.$title, "Block '" + freeBlock.rank + "'") + "' : " + context.page.localize.autoInsertBlockInNearestSlot, "warning");
						ret = context.library._processNewBlock.call(this, freeBlock.rank, freeBlock.block, freeBlock.excludeBinds, blockA.parent, rank, blockA.parentLayout, diagnosis);
					}
				}
				return ret;
			},
			$ruleLast: function(context, freeBlock) {
				var i, len, blockA, diagnosis, ret = null,
					sections;
				sections = this._$layoutMap.section.sort(function(left, right) {
					var scopeR = context.page.getFieldScope(right.$XID, false, true);
					var scopeL = context.page.getFieldScope(left.$XID, false, true);
					return scopeR.sectionRank - scopeL.sectionRank;
				});
				for (i = 0, len = sections.length; i < len; i++) {
					if (sections[i].block.length) {
						blockA = sections[i].block[sections[i].block.length - 1];
						diagnosis = this.makeDiagnosis(null, null, "'" + _helpers.getTitle(this.article, freeBlock.block.$title, "Block '" + freeBlock.rank + "'") + "' : " + context.page.localize.autoInsertBlockInLastSec, "warning");
						ret = context.library._processNewBlock.call(this, freeBlock.rank, freeBlock.block, freeBlock.excludeBinds, blockA.parent, blockA.parent.length, blockA.parentLayout, diagnosis);
						break;
					}
				}
				return ret;
			},
			getFreeBlocks: function(sectionRank, context, data) {
				var secR = this.page._$protoLayoutMap.section[sectionRank],
					free = [],
					freeFieldsBind, fieldsBind,
					i, j, k, block, leni = secR.block.length,
					nbFields, jocker,
					lenj, lenk, scope, score = 0,
					secA, blockA, exlcudeBinds,
					byPassRank = !context.isFusion;
				for (i = 0; i < leni; i++) {
					// Simple detection...
					block = secR.block[i];
					freeFieldsBind = [];
					fieldsBind = [];
					exlcudeBinds = {};
					for (j = 0, nbFields = block.boundFields.length; j < nbFields; j++) {
						if (this._$freeFieldBinds.indexOf(block.boundFields[j]) >= 0) {
							freeFieldsBind.push(block.boundFields[j]);
						} else {
							fieldsBind.push(block.boundFields[j]);
						}
					}
					score = freeFieldsBind.length;
					// If we not reach 100% matching score, we check if remaining fields would no be bound to another block in same section...
					if (score != nbFields && nbFields && score && (lenj = fieldsBind.length) && (secA = context.library._getAuthoredSectionForBind.call(this, freeFieldsBind[0], secR.$title, context, data))) {
						for (j = 0; j < lenj; j++) {
							if ((blockA = _helpers._searchBlockHoldBind(this._$layoutMap, fieldsBind[j])) && blockA.$title != block.$title) {
								jocker = 0;
								for (k = 0, lenk = fieldsBind.length; k < lenk; k++) {
									if (fieldsBind[j] != fieldsBind[k] && blockA.boundFields.indexOf(fieldsBind[k]) >= 0) {
										jocker++;
									}
								}
								if (!jocker || (lenj - 1 > jocker)) {
									// Very  likely this field is already bound to another block of the authored representation (i.e moved server side)
									score++;
									exlcudeBinds[fieldsBind[j]] = true;
								}
							}
						}
					}
					// So, new or not new?
					if (score == nbFields && nbFields) {
						scope = !byPassRank ? context.page.getFieldScope(freeFieldsBind[0]) : null;
						free.push({
							"block": block,
							"rank": scope && scope.blockRank,
							"excludeBinds": helpers.object.clone(exlcudeBinds)
						});
					} else if (!nbFields) {
						// Empty block... never mind, we can discard it, even if it's a new one!
					}
				}
				return byPassRank ? free : free.sort(function(left, right) {
					return right.rank - left.rank;
				});
			}
		},
		"section": {
			"rules": ["$ruleByRank", "$ruleLast"],
			$ruleByRank: function(context, freeSection) {
				var ret = null,
					diagnosis = null,
					lenA = this._$layoutMap.section.length,
					secA, scope, authoSecRank = [],
					last, i, insertRank;
				// New section insertion rank resoluteness
				for (i = 0; i < lenA; i++) {
					scope = context.page.getFieldScope(this._$layoutMap.section[i].$XID, false, true);
					authoSecRank.push({
						"rank": scope.sectionRank,
						"idx": i
					});
				}
				authoSecRank = authoSecRank.sort(function(left, right) {
					return left.rank - right.rank;
				});
				// Process...
				for (i = 0; i < lenA; i++) {
					if (freeSection.rank <= authoSecRank[i].rank) {
						break;
					}
				}
				if (i < lenA || (last = freeSection.rank == (authoSecRank[lenA - 1].rank + 1))) {
					insertRank = !last ? authoSecRank[i].idx : authoSecRank[lenA - 1].idx + 1;
					secA = this._$layoutMap.section[!last ? insertRank : lenA - 1];
					ret = context.library._processNewSection.call(this, insertRank, freeSection.rank, freeSection.section, secA.parent, !last ? secA.parentSlot : secA.parent.length, secA.parentLayout);
				} else {
					// By default, insertion in the nearest slot
					insertRank = Math.min(freeSection.rank, lenA);
					secA = this._$layoutMap.section[Math.min(insertRank, lenA - 1)];
					diagnosis = this.makeDiagnosis(null, null, "'" + _helpers.getTitle(this.article, freeSection.$title, "Section '" + freeSection.rank + "'") + "' : " + context.page.localize.autoInsertSectionInNearestSlot, "warning");
					ret = context.library._processNewSection.call(this, insertRank, freeSection.rank, freeSection.section, secA.parent, secA.parentSlot, secA.parentLayout, diagnosis);
				}
				return ret;
			},
			$ruleLast: function(context, freeSection) {
				var ret = null;
				// Normally we should never reach this rule...
				return ret;
			},
			getFreeSections: function(context, data) {
				var free = [],
					i, leni = this.page._$protoLayoutMap.section.length,
					scope, score = 0;
				var byPassRank = !context.isFusion,
					section, fillBlocks, j, lenj;
				context._freeBlocksBySec = [];
				for (i = 0; i < leni; i++) {
					section = this.page._$protoLayoutMap.section[i];
					lenj = fillBlocks = section.block.length;
					for (j = 0; j < lenj; j++) {
						if (!section.block[j].boundFields.length) {
							fillBlocks--;
						}
					}
					context._freeBlocksBySec[i] = context.library.block.getFreeBlocks.call(this, i, context, data);
					if (context._freeBlocksBySec[i].length == fillBlocks && fillBlocks) {
						scope = !byPassRank ? context.page.getFieldScope(section.$XID, false, true) : null;
						free.push({
							"section": section,
							"rank": scope && scope.sectionRank,
							"mapIdx": i
						});
						context._freeBlocksBySec[i] = [];
					} else if (!fillBlocks) {
						// Empty section... never mind, we ca discard it, even if it's a new one!						
					}
				}
				return byPassRank ? free : free.sort(function(left, right) {
					return right.rank - left.rank;
				});
			},
			afterInsertion: function(target) {
				// Update id for inserted section
				target.layout.slot[target.layout.rank].$XID = target.$XID;
			}
		},
		_processNewSection: function(rankInMapLayoutA, rank, sectionRef, slot, slotRank, slotParentLayout, diag) {
			var i, len, ret, lyTypeA = slotParentLayout.$layoutType,
				secA,
				lyTypeR = sectionRef.parentLayout.$layoutType;
			var parentLayout = slotParentLayout,
				mess = null,
				tabsLyt,
				detail, isTab = (lyTypeR == "tabs");

			function _appendTabsLyt(parentLyt) {
				parentLyt.$items.push({
					"$layoutType": "tabs",
					"$widths": "100",
					"$items": []
				});
				return parentLyt.$items[parentLyt.$items.length - 1];
			}

			function _getTabsLyt() {
				var lyt = null;
				for (i = 0, len = this._$layoutMap.section.length; i < len; i++) {
					if ((lyt = this._$layoutMap.section[i].parentLayout.$layoutType) == "tabs") {
						break;
					}
				}
				return lyt;
			}
			ret = {
				"diagnosis": diag,
				"section": sectionRef,
				"rankOrigin": rank,
				"layoutToInsert": sectionRef.parent[sectionRef.parentSlot]
			};
			ret.layout = {
				"slot": slot,
				"rank": slotRank
			};
			if (lyTypeA != lyTypeR) {
				if (isTab) {
					if (this._$layoutMap.section.length == 1) {
						// Have to create a tab layout... 
						parentLayout = _appendTabsLyt(slotParentLayout);
						slotParentLayout.$layoutType = "stack";
						slotParentLayout.$widths = "100";
						ret.layout = {
							"slot": parentLayout.$items,
							"rank": 0
						};
					} else {
						// Normally it should not occur... so we just add a detail in diagnosis and let the default behavior
						mess = "autoInsertSectionWarnLayout";
						detail = " tab --> stack";
					}
				} else {
					// To check, but normally it should not occur... so we just add a detail in diagnosis and let the default behavior
					mess = "autoInsertSectionWarnLayout";
					detail = "statck --> tab";
				}
			} else {
				if (!isTab) {
					// Oups, we have to insert an header section, and move authored section in new tabs layout
					secA = (slotParentLayout.$items.splice(0, 1))[0];
					if (this._$layoutMap.section.length == 1) {
						tabsLyt = _appendTabsLyt(slotParentLayout);
						tabsLyt.$items.push(secA);
					} else {
						// We have to insert an header section, and move authored section in currently tabs layout 
						if (!(tabsLyt = _getTabsLyt())) {
							mess = "autoInsertSectionWarnLayout";
							detail = "can't retrieve tabs layout";
						} else {
							tabsLyt.$items.splice(0, 0, secA);
						}
					}
					if (tabsLyt) {
						secA = this._$layoutMap.section[0];
						secA.parent = tabsLyt.$items;
						secA.parentSlot = 0;
						secA.parentLayout = tabsLyt;
					}
				}
			}
			// Check messages
			if (mess) {
				mess = _helpers.getTitle(this.article, mess);
				if (!ret.diagnosis) {
					mess = "'" + _helpers.getTitle(this.article, sectionRef.section.$title, "Section " + sectionRef.mapIdx) + "' : " + mess;
					ret.diagnosis = this.makeDiagnosis(null, null, labelString, "warning", detail);
				} else {
					ret.diagnosis.$details = mess + " (" + detail + ")";
				}
			}
			// Have to re-index section $XID
			ret.$XID = this.page.getScreenInstFromRank(rankInMapLayoutA, isTab);
			for (i = rankInMapLayoutA, len = this._$layoutMap.section.length; i < len; i++) {
				secA = this._$layoutMap.section[i];
				secA.parent[secA.parentSlot].$XID = this.page.getScreenInstFromRank(i + 1, (secA.parentLayout.$layoutType == "tabs"));
			}
			return ret;
		},
		_processNewBlock: function(rank, blockRef, excludeLyt, slot, slotRank, slotParentLayout, diag) {
			var ret, clonedLyt, i, len, lytKeys, lytToInsert = blockRef.parent[blockRef.parentSlot];
			var excludeMap = [],
				excludeLytKeys = excludeLyt ? Object.keys(excludeLyt) : null;

			function _walk(items, data) {
				var i, len = items.length,
					$item;
				if (items) {
					for (i = 0; i < len; i++) {
						$item = items[i];
						if ($item.$bind && excludeLytKeys.indexOf($item.$bind) >= 0) {
							excludeMap.push({
								"rank": i,
								"item": items
							});
						} else {
							_helpers._walkLayout($item, false, _walk, data);
						}
					}
				}
			}
			// First, deal with excluded fields in new block...
			if (excludeLytKeys && excludeLytKeys.length) {
				lytToInsert = helpers.object.clone(lytToInsert, true);
				_walk(lytToInsert.$items || (lytToInsert.$layout ? lytToInsert.$layout.$items : []));
				if ((len = excludeMap.length)) {
					for (i = len - 1; i >= 0; i--) {
						excludeMap[i].item.splice(excludeMap[i].rank, 1);
					}
				}
			}
			// Init our internal structure
			ret = {
				"diagnosis": diag,
				"block": blockRef,
				"rankOrigin": rank,
				"layoutToInsert": lytToInsert,
				"layout": {
					"slot": slot,
					"rank": slotRank
				}
			};
			// As possible, we try to insert new block in stack
			if (slotParentLayout && slotParentLayout.$layoutType == "row") {
				if (slotParentLayout.$items.length == 1) {
					slotParentLayout.$layoutType = "stack";
					delete slotParentLayout.$widths;
				} else if (slotParentLayout.$items.length == slotRank || slotRank == 0) {
					// Clone cleanup and rebuild parentlayout
					clonedLyt = helpers.object.clone(slotParentLayout, true);
					lytKeys = Object.keys(slotParentLayout);
					for (i = 0, len = lytKeys.length; i < len; i++) {
						delete slotParentLayout[lytKeys[i]];
					}
					slotParentLayout.$layoutType = "stack";
					slotParentLayout.$items = [clonedLyt];
					slotParentLayout.$items.splice(slotRank == 0 ? 0 : 1, 0, {
						"$layoutType": "stack",
						"$items": []
					});
					ret.layout = {
						"slot": slotParentLayout.$items[slotRank == 0 ? 0 : 1].$items,
						"rank": 0
					};
				}
			}
			return ret;
		},
		_getAuthoredSectionForBind: function(bind, sectionRefTitle, context, data) {
			var sec = null,
				dataEx = data || {};
			dataEx.justSection = true;
			if (!bind || !context.isFusion || (!(_helpers._findBlockById(this._$layoutMap, null, context.page.getFieldScope(bind), dataEx, context.page)) && !dataEx.section)) {
				sec = _helpers._findSectionByTitle(this._$layoutMap, sectionRefTitle);
			} else {
				sec = dataEx.section;
			}
			delete dataEx.justSection;
			return sec;
		}
	},
	_checkInBlock: function(block, context) {
		var targetLayout, i, len, scope, score = 0,
			fieldRank = -1,
			tabfldRank = [],
			nearest = 9999,
			compute, where = {};
		if ((len = block.boundFields.length) > 0) {
			for (i = 0; i < len; i++) {
				scope = context.page.getFieldScope(block.boundFields[i], false);
				if (context.fieldScope.blockRank == scope.blockRank && context.fieldScope.sectionId == scope.sectionId) {
					score++;
					tabfldRank.push({
						"from": i,
						"rank": scope.rank,
						"bind": block.boundFields[i]
					});
				}
			}
			if (score == len || score / len * 100 > 50) {
				for (i = 0, len = tabfldRank.length; i < len; i++) {
					compute = tabfldRank[i].rank - context.fieldScope.rank;
					if (compute >= 0 && compute < nearest || (compute < 0 && -1 * compute < nearest)) {
						nearest = Math.abs(compute);
						where.after = compute >= 0 ? false : true;
						fieldRank = tabfldRank[i].from;
						where.bind = tabfldRank[i].bind;
					}
				}
				if (nearest < 9999) {
					fieldRank = !where.after ? fieldRank : fieldRank + 1;
				}
			}
		} else {
			where.first = true;
			fieldRank = 0;
		}
		if (fieldRank >= 0 && block.items) {
			targetLayout = _insertFusion._getBlockLayout.call(this, block, context.$bind, where, context);
			return targetLayout ? {
				"rank": fieldRank,
				"block": block,
				"layout": targetLayout.layout,
				"diagnosis": targetLayout.diagnosis
			} : null;
		} else {
			return null;
		}
	},
	_getBlockLayout: function(block, $bind, where, context, dataEx) {
		var i, len, parentLayout = null,
			slot = null,
			ctx = {
				"count": 0,
				"rankInSlot": 0,
				"lMap": []
			};
		var parentItem = block.items,
			parentItemSlot = 0,
			deep = 0,
			dummy;
		var scope, mess = "autoInsertInNearestSlot",
			sev = "info",
			diagnosis = null;

		function _ensureRowLayout(data, rank) {
			var newLayout, i;
			if (parentItemSlot < parentItem.length - 1) {
				if (parentItem[parentItemSlot + 1].$items.length <= rank || ((dummy = parentItem[parentItemSlot + 1].$items[rank]) && dummy.$category && dummy.$category == "space")) {
					slot = parentItem[parentItemSlot + 1].$items;
					data.rankInSlot = rank;
					if (dummy) {
						slot.splice(rank, 1);
					}
				}
			} else {
				newLayout = helpers.object.clone(parentLayout, true);
				for (i = newLayout.$items.length - 1; i >= 0; i--) {
					if (newLayout.$items[i].$bind) {
						newLayout.$items.splice(i, 1);
					}
				}
				parentItem.push(newLayout);
				slot = parentItem[parentItem.length - 1].$items;
				data.rankInSlot = rank;
				if (rank > 0) {
					for (i = 0; i < rank; i++) {
						slot[i] = {
							"$category": "space"
						};
					}
				}
			}
		}

		function _walk(items, data) {
			var i, len, currItem, $item;
			deep++;
			for (i = 0; i < items.length && !slot; i++) {
				if (parentItem == items) {
					parentItemSlot = i;
				}
				$item = items[i];
				if ($item.$bind) {
					if ((where.first != null && where.first) || (where.bind != null && where.bind == $item.$bind)) {
						slot = items;
						data.rankInSlot = where.first != null && where.first ? 0 : (where.after ? i + 1 : i);
						if (dataEx && dataEx.strictRow && parentLayout && parentLayout.$layoutType == "row") {
							// Caution : "_ensureRowLayout" works only is "where.after" is true... meaning just for sized fields!
							_ensureRowLayout(data, i);
						}
						break;
					}
					ctx.lMap.push({
						"$bind": $item.$bind,
						"slot": items,
						"rank": i,
						"layoutP": parentLayout
					});
				} else {
					if ($item.$layoutType) {
						parentLayout = $item;
						parentItem = items;
					} else if ($item.$items) {
						parentItem = $item;
					}
					_helpers._walkLayout($item, !! (slot), _walk, data);
				}
			}
			deep--;
		}
		if (!block.boundFields.length) {
			// Oups, block without fields
			parentLayout = block.parent[block.parentSlot];
			if (!parentLayout.$layout) {
				parentLayout.$layout = {
					"$items": []
				};
			}
			if (!parentLayout.$layout.$items) {
				parentLayout.$layout.$items = [];
			}
			slot = parentLayout.$layout.$items;
			ctx.rankInSlot = slot.length;
			parentLayout = parentLayout.$layout;
		} else {
			_walk(block.items, ctx);
		}
		if (!slot && where.last != null && where.last) {
			i = ctx.lMap[ctx.lMap.length - 1];
			slot = i.slot;
			parentLayout = i.layoutP;
			ctx.rankInSlot = i.rank + 1;
		} else if (!slot) {
			for (i = ctx.lMap.length - 1; i >= 0; i--) {
				scope = context.page.getFieldScope(ctx.lMap[i].$bind, false);
				if (rank >= scope.rank) {
					break;
				}
			}
			if (i < 0) {
				i = ctx.lMap.length - 1;
				mess = "autoInsertInLastSlot";
				sev = "warning";
			}
			slot = ctx.lMap[i].slot;
			parentLayout = ctx.lMap[i].layoutP;
			ctx.rankInSlot = ctx.lMap[i].rank + 1;
			diagnosis = this.makeDiagnosis(null, null, $bind + " : " + context.page.localize[mess], sev);
		}
		return {
			"layout": {
				"slot": slot,
				"parent": parentLayout,
				"rank": ctx.rankInSlot
			},
			"diagnosis": diagnosis
		};
	}
};

var _insertStandard = {
	"levelField": {
		"field": {
			"rules": ["$ruleLast"],
			$ruleLast: function(context) {
				var ret = null;
				return ret;
			},
			getLastAvailableBlock: function(section, context, mode) {
				// TODO : close cvg => factorize!
			},
			initialize: function(context, data) {
				_insertFusion[context.level].field.initialize.apply(this, arguments);
			}
		}
	},
	"levelArticle": {
		"_isArticleLevel": true,
		"section": {
			"rules": ["$ruleDummy", "$ruleLast"],
			$ruleDummy: function(context, freeSection) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(context, freeSection) {
				var ret = null;
				return ret;
			},
			getFreeSections: function(sectionRank, context) {
				return _insertFusion[context.level].section.getFreeBlocks.call(this, context);
			}
		},
		"block": {
			"rules": ["$ruleDummy", "$ruleLast"],
			$ruleDummy: function(context, freeBlock, srcSection, srcSectionRank) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(context, freeBlock, srcSection, srcSectionRank) {
				var ret = null;
				return ret;
			},
			getFreeBlocks: function(sectionRank, context) {
				return _insertFusion[context.level].block.getFreeBlocks.call(this, sectionRank, context);
			}
		},
		"field": {
			"rules": ["$ruleDummy", "$ruleLast"],
			"_oddFieldTypes": {},
			$ruleDummy: function(context) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(context) {
				var ret = null;
				return ret;
			},
			getLastAvailableBlock: function(section, context) {
				// TODO : close cvg => factorize!
			}
		}
	}
};