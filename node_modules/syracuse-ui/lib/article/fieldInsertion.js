"use strict";


exports.fieldsInsert = function(designLevel, isFusion, garbageObj) {
	var level = "level" + designLevel.charAt(0).toUpperCase() + designLevel.slice(1);
	var insertLibrary = (isFusion && _insertFusion[level]) || _insertStandard[level],
		oldLibrary;
	var i, len = garbageObj._$freeFieldBinds.length,
		targets = {}, $bind, ret, _getSrclayout, _getFreeBlock, srcLayout, jocker;
	var ctx = {
		"library": insertLibrary,
		"page": garbageObj.page
	}, targetsKeys, target, localize = ctx.page.localize;
	var result = {
		"diagnoses": {},
		"warning": 0,
		"success": 0,
		"error": 0,
		"fatal": 0
	}, severity, message, detail;

	function _getMethod(name) {
		return (isFusion && _insertFusion[level] && _insertFusion[level][name]) || _insertStandard[level][name];
	}

	function _searchTarget(context) {
		var i, len, ret = false;
		for (i = 0, len = context.library.rules.length; i < len; i++) {
			if ((ret = context.library[context.library.rules[i]].call(garbageObj, context))) {
				break;
			}
		}
		return ret;
	}
	try {
		// For each free binds, we look for the best target
		for (i = 0; i < len; i++) {
			ctx.$bind = garbageObj._$freeFieldBinds[i];
			ret = _searchTarget(ctx);
			if (!ret && isFusion && insertLibrary != _insertStandard[level]) {
				oldLibrary = insertLibrary;
				ctx.library = _insertStandard[level];
				ret = _searchTarget(ctx);
				ctx.library = oldLibrary;
			}
			targets[ctx.$bind] = ret;
			targets[ctx.$bind].diagnosis = ctx.diagnosis;
		}
		// For each free binds, we try to insert field in target layout
		targetsKeys = Object.keys(targets);
		for (i = 0, len = targetsKeys.length; i < len; i++) {
			// Misc init
			target = targets[targetsKeys[i]];
			_getSrclayout = _getMethod("getSrcLayout");
			_getFreeBlock = _getMethod("getLastFreeBlock");
			srcLayout = _getSrclayout.call(garbageObj, targetsKeys[i], ctx);
			message = "autoInsertFailed";
			severity = "error";
			// Check if we have found a section/bloc, otherwise we look for a default one...
			if (!target || !target.block) {
				jocker = target ? target.section : null;
				if (!(target = _getFreeBlock.call(garbageObj, jocker, ctx))) {
					message = "autoInsertNoFreeBlock";
				} else {
					message = jocker ? "autoInsertInLastBlock" : "autoInsertInLastSecBlock";
					jocker = true;
					severity = "warning";
				}
			}
			if (target && target.block) {
				ret = _insertLayout.call(garbageObj, srcLayout, target);
				if (ret.success && !jocker) {
					severity = "info";
					message = "autoInsertSuccess";
				}
			}
			// Set diagnosis
			result.diagnoses[targetsKeys[i]] = target.diagnosis || garbageObj.makeDiagnosis(null, null, targetsKeys[i] + " : " + localize[message], severity, ret ? ret.details : null);
			result[target.diagnosis && target.diagnosis.$severity || severity]++;
		}
	} catch (e) {
		var ii, lenii;
		if (garbageObj && garbageObj._$freeFieldBinds) {
			for (ii = 0, lenii = garbageObj._$freeFieldBinds.length; ii < lenii; ii++) {
				if (!result.diagnoses[garbageObj._$freeFieldBinds[ii]]) {
					result.diagnoses[garbageObj._$freeFieldBinds[ii]] = garbageObj.makeDiagnosis(null, null, garbageObj._$freeFieldBinds[ii] + " : " + localize.autoInsertUnexpected, "fatal", e.message, e.stack);
					result.fatal++;
				}
			}
		}
	} finally {
		return result;
	}
};

function _insertLayout(layoutToInsert, blockTarget) {
	var ret = {
		"success": true,
		"details": ""
	};
	if(blockTarget.layout.parent && blockTarget.layout.parent.$widths) {
		delete blockTarget.layout.parent.$widths;
	}
	blockTarget.layout.slot.splice(blockTarget.layout.rank, 0, layoutToInsert);
	// Warning for Convergence : have to deal with reference field, grid, dimensioned field...
	return ret;
}

var _helpers = {
	_walkLayout: function($item, stop, callback, data) {
		if ($item.$items) {
			callback($item.$items, data);
		}
		if (!stop && $item.$layout && ($item = $item.$layout.$items)) {
			callback($item, data);
		}
	},
	_findSectionByTitle: function(map, sTitle) {
		var i, len = map.section.length;
		if (sTitle == undefined) {
			sTitle = "-";
		}
		for (i = 0; i < len; i++) {
			if (map.section[i].$title == sTitle) {
				break;
			}
		}
		return i < len ? map.section[i] : null;
	},
	_findBlockByTitle: function (map, bTitle, sTitle) {
		var found = null, sec, i, len;
		if (bTitle && (sec = _helpers._findSectionByTitle(map, sTitle))) {
			for (i = 0, len = sec.block.length; i < len; i++) {
				if (sec.block[i].$title == bTitle) {
					found = sec.block[i];
					break;
				}
			}
		}
		return found;
	},
	_searchBlock: function (map, $bind, data) {
		var found = null,
			sec, i, j, leni = map.section.length,
			lenj;
		for (i = 0; i < leni && !found; i++) {
			sec = map.section[i];
			for (j = 0, lenj = sec.block.length; j < lenj; j++) {
				if (sec.block[j].field.indexOf($bind) >= 0) {
					found = sec.block[j];
					if (data) {
						data.section = sec;
					}
					break;
				}
			}
		}
		return found;
	}
};
var _insertFusion = {
	"levelField": {
		"rules": []
	},
	"levelArticle": {
		"rules": ["$ruleById", "$ruleByTitleFromId", "$ruleByTitle", "$ruleLast"],
		"_oddFieldTypes": {
			"application/x-array": true,
			"text/rtf": true,
			"text/html": true,
			"image": true,
			"application/wid": true,
			"application/x-shockwave-flash": true
		},
		$ruleById: function(context) {
			var ret = null,
				block;
			context.fieldScope = context.page.getFieldScope(context.$bind, false);
			if ((block = context.library._findBlockById(this._$layoutMap, null, context.fieldScope))) {
				ret = context.library._checkInBlock.call(this, block, context);
			}
			return ret;
		},
		$ruleByTitleFromId: function(context) {
			var block, ret = null,
				found, data = {};
			if ((block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data))) {
				if ((found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
					ret = context.library._checkInBlock.call(this, found, context);
				}
			}
			return ret;
		},
		$ruleByTitle: function(context) {
			var ret = null,
				block, found, data = {};
			block = _helpers._searchBlock(this._$protoLayoutMap, context.$bind, data);
			if (block && (found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
				ret = context.library._checkInBlock.call(this, found, context);
			}
			return ret;
		},
		$ruleLast: function(context) {
			// Just try to resolve section
			var sec = null, data = {"justSection": true};
			context.library._findBlockById(this._$layoutMap, null, context.fieldScope, data);
			if(!data.section) {
				context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data);
				if(!data.section || !data.section.$title) {
					_helpers._searchBlock(this._$protoLayoutMap, context.$bind, data);
				}
				if(data.section && data.section.$title){
					sec = _helpers._findSectionByTitle(this._$layoutMap, data.section.$title);
				}
			}
			else {
				sec = data.section;
			}
			return sec ? {"section": sec} : null;
		},
		getSrcLayout: function($bind, context) {
			var block, slot = null,
				layout = null;

			function _walk(items) {
				var i, len = items.length, $item;
				for (i = 0; i < len && !layout; i++) {
					$item = items[i];
					if ($item.$bind && $item.$bind == $bind) {
						layout = $item;
						break;
					} else {
						_helpers._walkLayout($item, !!(layout), _walk);
					}
				}
			}
			if (!(block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.page.getFieldScope($bind, false)))) {
				block = _helpers._searchBlock(this._$protoLayoutMap, context.$bind);
			}
			if (block && (slot = block.field.indexOf($bind)) >= 0) {
				_walk(block.items);
			}
			return layout || {
				"$bind": $bind
			};
		},
		getLastFreeBlock: function(section, context) {
			var i, block = null,
				self = this;

			function _getBlock(sec) {
				var j, blck = null;
				for (j = sec.block.length - 1; j >= 0; j--) {
					if (sec.block[j].field.length > 1 || !context.library._oddFieldTypes[self._$properties[sec.block[j].field[0]].$type]) {
						blck = sec.block[j];
						break;
					}
				}
				return blck;
			}
			if (!section) {
				for (i = this._$layoutMap.section.length - 1; i >= 0; i--) {
					if ((block = _getBlock(this._$layoutMap.section[i]))) {
						break;
					}
				}
			} else {
				block = _getBlock(section);
			}
			return block ? {"block": block, "layout": context.library._getBlockLayout.call(this, block, context.$bind, block.field.length, context)} : null;
		},
		_checkInBlock: function(block, context) {
			var i, len, scope, score = 0,
				fieldRank = -1;
			if ((len = block.field.length) > 0) {
				for (i = 0; i < len; i++) {
					scope = context.page.getFieldScope(block.field[i], false);
					if (context.fieldScope.blockRank == scope.blockRank && context.fieldScope.sectionId == scope.sectionId) {
						score++;
					}
				}
				if (score == len) {
					fieldRank = context.fieldScope.rank - 1;
				} else if (score / len * 100 > 50) {
					// TODO : resolve fieldRank!
					fieldRank = -1;
				}
			} else {
				fieldRank = 0;
			}
			return fieldRank >= 0 ? {
				"block": block,
				"layout": context.library._getBlockLayout.call(this, block, context.$bind, fieldRank, context)
			} : null;
		},
		_getBlockLayout: function(block, $bind, rank, context) {
			var i, len, parentSlot = null, slot = null, ctx = {"count": 0, "rankInSlot": 0, "lMap": []};
			var scope, mess = "autoInsertInNearestSlot", sev = "info";
			function _walk(items, data) {
				var i, len, currItem, $item;
				for (i = 0, len = items.length; i < len && !slot; i++) {
					$item = items[i];
					if ($item.$bind) {
						if (rank == 0 || ++data.count == rank) {
							slot = items;
							data.rankInSlot = rank == 0 ? 0 : i + 1;
							break;
						}
						ctx.lMap.push({"$bind": $item.$bind, "slot": items, "rank": i, "slotP": parentSlot});
					}
					else {
						if($item.$layoutType) {
							parentSlot = $item;
						}
						_helpers._walkLayout($item, !!(slot), _walk, data);
					}
				}
			}
			_walk(block.items, ctx);
			if(!slot) {
				for (i = ctx.lMap.length - 1; i >= 0; i--) {
					scope = context.page.getFieldScope(ctx.lMap[i].$bind, false);
					if(rank >= scope.rank) {
						break;
					}
				}
				if(i < 0) {
					i = ctx.lMap.length - 1;
					mess = "autoInsertInLastSlot";
					sev = "warning";
				}
				slot = ctx.lMap[i].slot;
				parent = ctx.lMap[i].slotP;
				ctx.rankInSlot = ctx.lMap[i].rank + 1;
				context.diagnosis = this.makeDiagnosis(null, null, $bind + " : " + context.page.localize[mess], sev);
				// TODO : test empty bloc.. without slots
			}
			return {"slot": slot, "parent": parentSlot, "rank": ctx.rankInSlot};
		},
		_findBlockById: function(map, $bind, scope, data) {
			var found = null,
				sec;
			if (map.section.length >= scope.sectionRank) {
				sec = map.section[scope.sectionRank - 1];
				if (sec.$XID == scope.sectionId && sec.block.length >= scope.blockRank) {
					found = !$bind || sec.block[scope.blockRank - 1].field.indexOf($bind) >= 0 ? sec.block[scope.blockRank - 1] : null;
					if (data && found) {
						data.section = sec;
					}
				}
				else if(data && data.justSection && sec.$XID == scope.sectionId && sec.block.length > 0) {
					data.section = sec;
				}
			}
			return found;
		}
	}
};

var _insertStandard = {
	"levelField": {
		"rules": []
	},
	"levelArticle": {
		"rules": ["$ruleDummy", "$ruleLast"],
		"_oddFieldTypes": {
		},
		$ruleDummy: function(context) {
			var ret = null;
			return ret;
		},
		$ruleLast: function(context) {
			// Just try to resole section
			var sec = null;
			return sec ? {"section": sec} : null;
		}
	}
};