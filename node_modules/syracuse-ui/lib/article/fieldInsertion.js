"use strict";
var helpers = require('syracuse-core/lib/helpers');

exports.fieldsInsert = function(designLevel, isFusion, garbageObj) {
	var level = "level" + designLevel.charAt(0).toUpperCase() + designLevel.slice(1);
	var insertLibrary = (isFusion && _insertFusion[level]) || _insertStandard[level];
	var context = {
		"library": insertLibrary,
		"level": level,
		"page": garbageObj.page,
		"isFusion": isFusion
	};
	var result = {};
	result.section = _insertSections.call(garbageObj, level, insertLibrary, context);
	result.block = _insertBlocks.call(garbageObj, level, insertLibrary, context);
	result.field = _insertFields.call(garbageObj, level, insertLibrary, context);
	return result;
};

function _insertSections(level, insertLibrary, ctx) {
	var result = _helpers.initResult(),
		severity, message, localize = ctx.page.localize;
	try {} catch (e) {} finally {
		return result;
	}
}

function _insertBlocks(level, insertLibrary, ctx) {
	var target, result = _helpers.initResult(),
		severity, message;
	var i, j, leni, lenj, title, ret, localize = ctx.page.localize,
		freeBlocks = [],
		$definedBinds = {};
	try {
		// New block detection...
		for (i = 0, leni = this._$protoLayoutMap.section.length; i < leni; i++) {
			freeBlocks[i] = ctx.library.block.getFreeBlocks.call(this, i, ctx);
			if (ctx.isFusion) {
				freeBlocks[i] = freeBlocks[i].sort(function(left, right) {
					return right.rank - left.rank;
				});
			}
		}
		// New blocks Insertion
		for (j = 0, lenj = freeBlocks.length; j < lenj; j++) {
			for (i = freeBlocks[j].length - 1; i >= 0; i--) {
				message = "autoInsertBlockFailed";
				severity = "error";
				target = _processEntity.call(this, ctx, "block", [freeBlocks[j][i], this._$protoLayoutMap.section[j], j]);
				if (target) {
					ret = _insertLayout(target.layoutToInsert, target);
					if (ret.success) {
						severity = "info";
						message = "autoInsertBlockSuccess";
						// Have to remap authored layoud according blocks insertion
						this._getDefinedFieldsObject(this.article.$item, $definedBinds, this._$layoutMap);
					}
				}
				// Set diagnosis
				title = "'" + _helpers.getTitle(this.article, target && target.block.$title || (freeBlocks[j][i].block && freeBlocks[j][i].block.$title), "Block '" + (target ? target.rankOrigin : (i + 1)) + "'") + "' (Section '" + _helpers.getTitle(this.article, this._$protoLayoutMap.section[j].$title, j + 1) + "')";
				result.diagnoses[(j + "_inserted_" + i)] = (target && target.diagnosis) || this.makeDiagnosis(null, null, title + " : " + localize[message], severity, ret ? ret.details : null);
				result[(target && target.diagnosis && target.diagnosis.$severity) || severity]++;
				freeBlocks[j].splice(i, 1);
			}
		}
	} catch (e) {
		if (freeBlocks) {
			for (j = 0, lenj = freeBlocks.length; j < lenj; j++) {
				for (i = freeBlocks[j].length - 1; i >= 0; i--) {
					title = "'" + _helpers.getTitle(this.article, freeBlocks[j][i].block && freeBlocks[j][i].block.$title, "Block '?'") + " (Section '" + _helpers.getTitle(this.article, this._$protoLayoutMap.section && this._$protoLayoutMap.section[j] && this._$protoLayoutMap.section[j].$title, j + 1) + "')";
					result.diagnoses[(j + "_inserted_" + i)] = this.makeDiagnosis(null, null, title + " : " + localize.autoInsertBlockUnexpected, "fatal", e.message, e.stack);
					result.fatal++;
				}
			}
		} else {
			result.diagnoses["_catch"] = this.makeDiagnosis("autoInsertBlockUnexpected", null, null, "fatal", e.message, e.stack);
			result.fatal++;
		}
	} finally {
		return result;
	}
}

function _insertFields(level, insertLibrary, ctx) {
	var i, len = this._$freeFieldBinds.length,
		_getFieldSrclayout, _getAvailableBlock;
	var oldLibrary, localize = ctx.page.localize;
	var result = _helpers.initResult(),
		fieldName, self = this;

	function _getMethod(name) {
		return (ctx.isFusion && _insertFusion[level] && _insertFusion[level].field && _insertFusion[level].field[name]) || _insertStandard[level][name].field;
	}

	function _getFusionFldName(code) {
		var prop;
		return self._$properties && (prop = self._$properties[code]) && prop.$X3Name;
	}

	function _insert(bind, target) {
		var srcLayout, message = "autoInsertFailed",
			severity = "error",
			jocker, ret;
		// Misc init
		srcLayout = _getFieldSrclayout.call(self, bind, ctx);
		// Check if we have found a section/bloc, otherwise we look for a default one...
		if (!target || !target.block) {
			jocker = target ? target.section : null;
			if (!(target = _getAvailableBlock.call(self, jocker, ctx))) {
				message = "autoInsertNoFreeBlock";
			} else {
				message = jocker ? "autoInsertInLastBlock" : "autoInsertInLastSecBlock";
				jocker = true;
				severity = "warning";
			}
		}
		if (target && target.block) {
			ret = _insertLayout.call(self, srcLayout, target, bind);
			if (ret.success && !jocker) {
				severity = "info";
				message = "autoInsertSuccess";
			}
		}
		// Set diagnosis
		fieldName = ctx.isFusion && _getFusionFldName(bind);
		result.diagnoses[bind] = target.diagnosis || self.makeDiagnosis(null, null, (fieldName || bind) + " : " + localize[message], severity, ret ? ret.details : null);
		result[target.diagnosis && target.diagnosis.$severity || severity]++;
	}
	try {
		// Init
		_getFieldSrclayout = _getMethod("getFieldSrclayout");
		_getAvailableBlock = _getMethod("getLastAvailableBlock");
		// For each free binds, we look for the best block target
		if (ctx.isFusion) {
			this._$freeFieldBinds = ctx.library._sortFields(this._$freeFieldBinds, ctx.page);
		}
		for (i = 0; i < len; i++) {
			ctx.$bind = this._$freeFieldBinds[i];
			_insert(ctx.$bind, _processEntity.call(this, ctx, "field"));
		}
	} catch (e) {
		var ii, lenii;
		if (this._$freeFieldBinds) {
			for (ii = 0, lenii = this._$freeFieldBinds.length; ii < lenii; ii++) {
				if (!result.diagnoses[this._$freeFieldBinds[ii]]) {
					fieldName = ctx.isFusion && _getFusionFldName(this._$freeFieldBinds[ii]);
					result.diagnoses[this._$freeFieldBinds[ii]] = this.makeDiagnosis(null, null, (fieldName || this._$freeFieldBinds[ii]) + " : " + localize.autoInsertUnexpected, "fatal", e.message, e.stack);
					result.fatal++;
				}
			}
		}
	} finally {
		return result;
	}
}

function _processEntity(context, type, args) {
	var oldLibrary, i, len, ret = null,
		lib = context.library[type];
	for (i = 0, len = lib.rules.length; i < len; i++) {
		if ((ret = lib[lib.rules[i]].apply(this, [context].concat(args || [])))) {
			break;
		}
	}
	if (!ret && context.isFusion && context.library != _insertStandard[context.level]) {
		oldLibrary = context.library;
		context.library = _insertStandard[context.level];
		ret = _processEntity.call(this, context, type, args);
		context.library = oldLibrary;
	}
	return ret;
}

function _insertLayout(layoutToInsert, itemTarget, fldBind) {
	var ret = {
		"success": true,
		"details": ""
	};
	if (itemTarget.layout.parent && itemTarget.layout.parent.$widths) {
		delete itemTarget.layout.parent.$widths;
	}
	itemTarget.layout.slot.splice(itemTarget.layout.rank, 0, layoutToInsert);
	if (fldBind) {
		// A little bit more for fields
		if (fldBind && itemTarget.block && itemTarget.block.boundFields && itemTarget.rank !== null) {
			itemTarget.block.boundFields.splice(itemTarget.rank, 0, fldBind);
		}
	}
	return ret;
}

var _helpers = {
	getTitle: function(api, code, id) {
		var title;
		if (!code || code == "-") {
			title = id;
		} else if (api && api.getLocalizeText) {
			title = api.getLocalizeText(code);
		} else {
			title = code;
		}
		return title;
	},
	initResult: function() {
		return {
			"diagnoses": {},
			"warning": 0,
			"success": 0,
			"error": 0,
			"fatal": 0,
			"info": 0
		};
	},
	_walkLayout: function($item, stop, callback, data) {
		if ($item.$items) {
			callback($item.$items, data);
		}
		if (!stop && $item.$layout && ($item = $item.$layout.$items)) {
			callback($item, data);
		}
	},
	_findSectionByTitle: function(map, sTitle) {
		var i, len = map.section.length;
		if (sTitle == undefined) {
			sTitle = "-";
		}
		for (i = 0; i < len; i++) {
			if (map.section[i].$title == sTitle) {
				break;
			}
		}
		return i < len ? map.section[i] : null;
	},
	_findBlockByTitle: function(map, bTitle, sTitle) {
		var found = null,
			sec, i, len;
		if (bTitle && (sec = _helpers._findSectionByTitle(map, sTitle))) {
			for (i = 0, len = sec.block.length; i < len; i++) {
				if (sec.block[i].$title == bTitle) {
					found = sec.block[i];
					break;
				}
			}
		}
		return found;
	},
	_searchBlockHoldBind: function(map, $bind, data) {
		var found = null,
			sec, i, j, leni = map.section.length,
			lenj;
		for (i = 0; i < leni && !found; i++) {
			sec = map.section[i];
			for (j = 0, lenj = sec.block.length; j < lenj; j++) {
				if (sec.block[j].boundFields.indexOf($bind) >= 0) {
					found = sec.block[j];
					if (data) {
						data.section = sec;
					}
					break;
				}
			}
		}
		return found;
	}
};
var _insertFusion = {
	"levelField": {
		"field": {
			"rules": []
		}
	},
	"levelArticle": {
		"_isArticleLevel": true,
		"field": {
			"rules": ["$ruleDimField", "$ruleById", "$ruleByTitleFromId", "$ruleByTitle", "$ruleLast"],
			"_oddFieldTypes": {
				"application/x-array": true,
				"text/rtf": true,
				"text/html": true,
				"image": true,
				"application/wid": true,
				"application/x-shockwave-flash": true
			},
			$ruleDimField: function(context) {
				var ret = null,
					block, name, i, len, persisteP, score = 0,
					bindDim, targetLayout, dimFldName;

				function _getDimName(fldName) {
					var dimIdx, dimMap = {
							"n": null,
							"id": null
						}, ret = false;
					if ((dimIdx = fldName.lastIndexOf("_")) > 0 && (dimMap.id = name.substring(dimIdx + 1))) {
						dimMap.id = parseInt(dimMap.id, 10);
						if (!isNaN(dimMap.id) && (dimMap.n = name.substring(0, dimIdx))) {
							ret = true;
						}
					}
					return ret ? dimMap : null;
				}
				if ((name = this._$properties[context.$bind].$X3Name) && (persisteP = this.article.$persistPrototype && this.article.$persistPrototype.$properties)) {
					if ((dimFldName = _getDimName(name))) {
						for (i = 1; i < dimFldName.id; i++) {
							score = persisteP[dimFldName.n + "_" + (i + 1)] ? score + 1 : score;
						}
						if (score && score == dimFldName.id - 1 && (bindDim = persisteP[dimFldName.n + "_" + (dimFldName.id - 1)].$xid)) {
							// So new occurrences of sized field
							block = _helpers._searchBlockHoldBind(this._$layoutMap, bindDim);
							if (block && (targetLayout = context.library._getBlockLayout.call(this, block, context.$bind, {
								"bind": bindDim,
								"after": true
							}, context, {
								"strictRow": true
							}))) {
								ret = {
									"rank": block.boundFields.indexOf(bindDim) + 1,
									"block": block,
									"layout": targetLayout.layout,
									"diagnosis": targetLayout.diagnosis
								};
							}
						} else if (!score) {
							// Perhaps new sized field!
							for (i = 0, len = this._$freeFieldBinds.length; i < len; i++) {
								if (this._$freeFieldBinds[i] != context.$bind && (name = this._$properties[this._$freeFieldBinds[i]].$X3Name) && (dimFldName = _getDimName(name))) {
									// TODO : improve detection relevance, and process...
								}
							}
						}
					}
				}
				return ret;
			},
			$ruleById: function(context) {
				var ret = null,
					block, data = {
						"justSection": true
					}, relevance = false;
				// Check rule relevance
				context.fieldScope = context.page.getFieldScope(context.$bind, false);
				context.library._findBlockById(this._$layoutMap, null, context.fieldScope, data, context.page);
				relevance = !data.section || (data.section.block.length != this._$protoLayoutMap.section[context.fieldScope.sectionRank - 1].block.length) ? false : true;
				// If OK...
				if (relevance && (block = context.library._findBlockById(this._$layoutMap, null, context.fieldScope, null, context.page))) {
					ret = context.library._checkInBlock.call(this, block, context);
				}
				return ret;
			},
			$ruleByTitleFromId: function(context) {
				var block, ret = null,
					found, data = {};
				if ((block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data, context.page))) {
					if ((found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
						ret = context.library._checkInBlock.call(this, found, context);
					}
				}
				return ret;
			},
			$ruleByTitle: function(context) {
				var ret = null,
					block, found, data = {};
				block = _helpers._searchBlockHoldBind(this._$protoLayoutMap, context.$bind, data);
				if (block && (found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
					ret = context.library._checkInBlock.call(this, found, context);
				}
				return ret;
			},
			$ruleLast: function(context) {
				// Just try to resolve section
				var sec = null,
					data = {
						"justSection": true
					};
				context.library._findBlockById(this._$layoutMap, null, context.fieldScope, data, context.page);
				if (!data.section) {
					context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data, context.page);
					if (!data.section || !data.section.$title) {
						_helpers._searchBlockHoldBind(this._$protoLayoutMap, context.$bind, data);
					}
					if (data.section && data.section.$title) {
						sec = _helpers._findSectionByTitle(this._$layoutMap, data.section.$title);
					}
				} else {
					sec = data.section;
				}
				return sec ? {
					"section": sec
				} : null;
			},
			getFieldSrclayout: function($bind, context, data) {
				var block, layout = null,
					byPassFindById = !! (data && data.byPassById);

				function _walk(items) {
					var i, len = items.length,
						$item;
					for (i = 0; i < len && !layout; i++) {
						$item = items[i];
						if ($item.$bind && $item.$bind == $bind) {
							layout = $item;
							break;
						} else {
							_helpers._walkLayout($item, !! (layout), _walk);
						}
					}
				}
				if (byPassFindById || !(block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.page.getFieldScope($bind, false), null, context.page))) {
					block = _helpers._searchBlockHoldBind(this._$protoLayoutMap, context.$bind);
				}
				if (block && block.boundFields.indexOf($bind) >= 0) {
					_walk(block.items);
				}
				return layout || {
					"$bind": $bind
				};
			},
			getLastAvailableBlock: function(section, context) {
				var i, block = null,
					self = this,
					targetLayout;

				function _getBlock(sec) {
					var j, blck = null;
					for (j = sec.block.length - 1; j >= 0; j--) {
						if (sec.block[j].boundFields.length > 1 || !context.library.field._oddFieldTypes[self._$properties[sec.block[j].boundFields[0]].$type]) {
							blck = sec.block[j];
							break;
						}
					}
					return blck;
				}
				if (!section) {
					for (i = this._$layoutMap.section.length - 1; i >= 0; i--) {
						if ((block = _getBlock(this._$layoutMap.section[i]))) {
							break;
						}
					}
				} else {
					block = _getBlock(section);
				}
				targetLayout = context.library._getBlockLayout.call(this, block, context.$bind, {
					"last": true
				}, context);
				return block && targetLayout ? {
					"rank": block.boundFields.length,
					"block": block,
					"layout": targetLayout.layout,
					"diagnosis": targetLayout.diagnosis
				} : null;
			}
		},
		"block": {
			"rules": ["$ruleByRank", "$ruleLast"],
			$ruleByRank: function(context, freeBlock, srcSection, srcSectionRank) {
				var ret = null,
					i, j, k, len, secA, data = {
						"justSection": true
					}, last = false;
				var blockA, lenA, rank, scope, score = 0,
					diagnosis;
				var authoBlocks = {}, temp;
				// Resolve authored section according source section description
				if (!(context.library._findBlockById(this._$layoutMap, null, context.page.getFieldScope(freeBlock.block.boundFields[0]), data, context.page)) || !data.section) {
					secA = _helpers._findSectionByTitle(this._$layoutMap, srcSection.$title);
				} else {
					secA = data.section;
				}
				if (secA) {
					lenA = secA.block.length;
					// New blocks insertion rank resoluteness
					for (i = 0; i < lenA; i++) {
						blockA = secA.block[i];
						temp = [];
						for (j = 0, len = blockA.boundFields.length; j < len; j++) {
							scope = context.page.getFieldScope(blockA.boundFields[j]);
							temp[scope.blockRank] = !temp[scope.blockRank] ? 1 : temp[scope.blockRank] + 1;
						}
						rank = -1;
						k = 0;
						for (j = 0, len = temp.length; j < len; j++) {
							if (temp[j] && temp[j] > k) {
								k = temp[j];
								rank = j;
							}
						}
						if (rank >= 0 && !authoBlocks[rank.toString()]) {
							authoBlocks[rank.toString()] = i;
						}
					}
					// Process...
					temp = Object.keys(authoBlocks).sort();
					for (i = 0, lenA = temp.length; i < lenA; i++) {
						if (freeBlock.rank <= parseInt(temp[i], 10)) {
							break;
						}
					}
					// TODO : test section without block!
					if (i < lenA || (last = freeBlock.rank == (parseInt(temp[lenA - 1], 10) + 1))) {
						blockA = secA.block[!last ? authoBlocks[temp[i]] : lenA - 1];
						ret = context.library._processNewBlock.call(this, freeBlock.rank, freeBlock.block, blockA.parent, !last ? blockA.parentSlot : blockA.parent.length);
					} else {
						// By default, insertion in the nearest or last slot of section
						if (lenA >= freeBlock.rank) {
							blockA = secA.block[freeBlock.rank - 1];
							rank = blockA.parentSlot;
						} else {
							blockA = secA.block[lenA - 1];
							rank = blockA.parent.length;
						}
						diagnosis = this.makeDiagnosis(null, null, "'" + _helpers.getTitle(this.article, freeBlock.block.$title, "Block '" + freeBlock.rank + "'") + "' : " + context.page.localize.autoInsertBlockInNearestSlot, "warning");
						ret = context.library._processNewBlock.call(this, freeBlock.rank, freeBlock.block, blockA.parent, rank, diagnosis);
					}
				}
				return ret;
			},
			$ruleLast: function(context, freeBlock) {
				var i, len, blockA, diagnosis, ret = null,
					sections;
				sections = this._$layoutMap.section.sort(function(left, right) {
					var scopeR = context.page.getFieldScope(right.$XID, false, true);
					var scopeL = context.page.getFieldScope(left.$XID, false, true);
					return scopeR.sectionRank - scopeL.sectionRank;
				});
				for (i = 0, len = sections.length; i < len; i++) {
					if (sections[i].block.length) {
						blockA = sections[i].block[sections[i].block.length - 1];
						diagnosis = this.makeDiagnosis(null, null, "'" + _helpers.getTitle(this.article, freeBlock.block.$title, "Block '" + freeBlock.rank + "'") + "' : " + context.page.localize.autoInsertInLastSection, "warning");
						ret = context.library._processNewBlock.call(this, freeBlock.rank, freeBlock.block, blockA.parent, blockA.parent.length, diagnosis);
						break;
					}
				}
				return ret;
			},
			getFreeBlocks: function(sectionRank, context, data) {
				var secR = this._$protoLayoutMap.section[sectionRank],
					free = [],
					i, j, block, leni = secR.block.length,
					lenj, scope, score = 0,
					byPassRank = !! (data && sectionRank.byPassRank);
				for (i = 0; i < leni; i++) {
					block = secR.block[i];
					score = 0;
					for (j = 0, lenj = block.boundFields.length; j < lenj; j++) {
						if (this._$freeFieldBinds.indexOf(block.boundFields[j]) >= 0) {
							score++;
						}
					}
					scope = !byPassRank ? context.page.getFieldScope(block.boundFields[0]) : null;
					if (score == lenj) {
						free.push({
							"block": block,
							"rank": scope && scope.blockRank
						});
					}
				}
				return free;
			}
		},
		_processNewBlock: function(rank, blockRef, slot, slotRank, diag) {
			var i, idxOf, len, ret;
			ret = {
				"diagnosis": diag,
				"block": blockRef,
				"rankOrigin": rank,
				"layoutToInsert": blockRef.parent[blockRef.parentSlot],
				"layout": {
					"slot": slot,
					"rank": slotRank
				}
			};
			// Have to suppress field from free binds map
			for (i = 0, len = blockRef.boundFields.length; i < len; i++) {
				if ((idxOf = this._$freeFieldBinds.indexOf(blockRef.boundFields[i])) >= 0) {
					this._$freeFieldBinds.splice(idxOf, 1);
				}
			}
			return ret;
		},
		_checkInBlock: function(block, context) {
			var targetLayout, i, len, scope, score = 0,
				fieldRank = -1,
				tabfldRank = [],
				nearest = 9999,
				compute, where = {};
			if ((len = block.boundFields.length) > 0) {
				for (i = 0; i < len; i++) {
					scope = context.page.getFieldScope(block.boundFields[i], false);
					if (context.fieldScope.blockRank == scope.blockRank && context.fieldScope.sectionId == scope.sectionId) {
						score++;
						tabfldRank.push({
							"from": i,
							"rank": scope.rank,
							"bind": block.boundFields[i]
						});
					}
				}
				if (score == len || score / len * 100 > 50) {
					for (i = 0, len = tabfldRank.length; i < len; i++) {
						compute = tabfldRank[i].rank - context.fieldScope.rank;
						if (compute >= 0 && compute < nearest || (compute < 0 && -1 * compute < nearest)) {
							nearest = Math.abs(compute);
							where.after = compute >= 0 ? false : true;
							fieldRank = tabfldRank[i].from;
							where.bind = tabfldRank[i].bind;
						}
					}
					if (nearest < 9999) {
						fieldRank = !where.after ? fieldRank : fieldRank + 1;
					}
				}
			} else {
				where.first = true;
				fieldRank = 0;
			}
			if (fieldRank >= 0 && block.items) {
				targetLayout = context.library._getBlockLayout.call(this, block, context.$bind, where, context);
				return targetLayout ? {
					"rank": fieldRank,
					"block": block,
					"layout": targetLayout.layout,
					"diagnosis": targetLayout.diagnosis
				} : null;
			} else {
				return null;
			}
		},
		_getBlockLayout: function(block, $bind, where, context, dataEx) {
			var i, len, parentLayout = null,
				slot = null,
				ctx = {
					"count": 0,
					"rankInSlot": 0,
					"lMap": []
				};
			var parentItem = block.items,
				parentItemSlot = 0,
				deep = 0,
				dummy;
			var scope, mess = "autoInsertInNearestSlot",
				sev = "info",
				diagnosis = null;

			function _ensureRowLayout(data, rank) {
				var newLayout, i;
				if (parentItemSlot < parentItem.length - 1) {
					if (parentItem[parentItemSlot + 1].$items.length <= rank || ((dummy = parentItem[parentItemSlot + 1].$items[rank]) && dummy.$category && dummy.$category == "space")) {
						slot = parentItem[parentItemSlot + 1].$items;
						data.rankInSlot = rank;
						if (dummy) {
							slot.splice(rank, 1);
						}
					}
				} else {
					newLayout = helpers.object.clone(parentLayout, true);
					for (i = newLayout.$items.length - 1; i >= 0; i--) {
						if (newLayout.$items[i].$bind) {
							newLayout.$items.splice(i, 1);
						}
					}
					parentItem.push(newLayout);
					slot = parentItem[parentItem.length - 1].$items;
					data.rankInSlot = rank;
					if (rank > 0) {
						for (i = 0; i < rank; i++) {
							slot[i] = {
								"$category": "space"
							};
						}
					}
				}
			}

			function _walk(items, data) {
				var i, len, currItem, $item;
				deep++;
				for (i = 0; i < items.length && !slot; i++) {
					if (parentItem == items) {
						parentItemSlot = i;
					}
					$item = items[i];
					if ($item.$bind) {
						if ((where.first != null && where.first) || (where.bind != null && where.bind == $item.$bind)) {
							slot = items;
							data.rankInSlot = where.first != null && where.first ? 0 : (where.after ? i + 1 : i);
							if (dataEx && dataEx.strictRow && parentLayout && parentLayout.$layoutType == "row") {
								// Caution : "_ensureRowLayout" works only is "where.after" is true... meaning just for sized fields!
								_ensureRowLayout(data, i);
							}
							break;
						}
						ctx.lMap.push({
							"$bind": $item.$bind,
							"slot": items,
							"rank": i,
							"layoutP": parentLayout
						});
					} else {
						if ($item.$layoutType) {
							parentLayout = $item;
							parentItem = items;
						} else if ($item.$items) {
							parentItem = $item;
						}
						_helpers._walkLayout($item, !! (slot), _walk, data);
					}
				}
				deep--;
			}
			_walk(block.items, ctx);
			if (!slot && where.last != null && where.last) {
				i = ctx.lMap[ctx.lMap.length - 1];
				slot = i.slot;
				parentLayout = i.layoutP;
				ctx.rankInSlot = i.rank + 1;
			} else if (!slot) {
				for (i = ctx.lMap.length - 1; i >= 0; i--) {
					scope = context.page.getFieldScope(ctx.lMap[i].$bind, false);
					if (rank >= scope.rank) {
						break;
					}
				}
				if (i < 0) {
					i = ctx.lMap.length - 1;
					mess = "autoInsertInLastSlot";
					sev = "warning";
				}
				slot = ctx.lMap[i].slot;
				parentLayout = ctx.lMap[i].layoutP;
				ctx.rankInSlot = ctx.lMap[i].rank + 1;
				diagnosis = this.makeDiagnosis(null, null, $bind + " : " + context.page.localize[mess], sev);
				// TODO : test empty bloc.. without slots
			}
			return {
				"layout": {
					"slot": slot,
					"parent": parentLayout,
					"rank": ctx.rankInSlot
				},
				"diagnosis": diagnosis
			};
		},
		_findBlockById: function(map, $bind, scope, data, page) {
			var found = null,
				sec, secScope;
			if (map.section.length >= scope.sectionRank) {
				sec = map.section[scope.sectionRank - 1];
				secScope = page.getFieldScope(sec.$XID, false, true);
				if (secScope.sectionId == scope.sectionId && sec.block.length >= scope.blockRank) {
					found = !$bind || sec.block[scope.blockRank - 1].boundFields.indexOf($bind) >= 0 ? sec.block[scope.blockRank - 1] : null;
					if (data && found) {
						data.section = sec;
					}
				} else if (data && data.justSection && secScope.sectionId == scope.sectionId && sec.block.length > 0) {
					data.section = sec;
				}
			}
			return found;
		},
		_sortFields: function(fldAIn, page) {
			return fldAIn.sort(function(left, right) {
				var lId, ltScope = page.getFieldScope(left);
				var rId, rScope = page.getFieldScope(right);
				lId = (ltScope.sectionRank << 24) + (ltScope.blockRank << 16) + (ltScope.rank << 8);
				rId = (rScope.sectionRank << 24) + (rScope.blockRank << 16) + (rScope.rank << 8);
				return lId - rId;
			});
		}
	}
};

var _insertStandard = {
	"levelField": {
		"field": {
			"rules": []
		}
	},
	"levelArticle": {
		"_isArticleLevel": true,
		"block": {
			"rules": ["$ruleDummy", "$ruleLast"],
			$ruleDummy: function(context, freeBlock, section) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(ontext, freeBlock, srcSection, srcSectionRank) {
				var ret = null;
				return ret;
			},
			getFreeBlocks: function(sectionRank, context) {
				return _insertFusion[context.level].block.getFreeBlocks.call(this, sectionRank, context, {
					"byPassRank": true
				});
			}
		},
		"field": {
			"rules": ["$ruleDummy", "$ruleLast"],
			"_oddFieldTypes": {},
			$ruleDummy: function(context) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(context) {
				var ret = null;
				return ret;
			},
			getFieldSrclayout: function($bind, context) {
				return _insertFusion[context.level].field.getFieldSrclayout.call(this, $bind, context, {
					"byPassById": true
				});
			},
			getLastAvailableBlock: function(section, context) {
				// TODO : close cvg => factorize!
			}
		}
	}
};