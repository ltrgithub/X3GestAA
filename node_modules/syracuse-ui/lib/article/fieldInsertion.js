"use strict";


exports.fieldsInsert = function(designLevel, isFusion, garbageObj) {
	var level = "level" + designLevel.charAt(0).toUpperCase() + designLevel.slice(1);
	var insertLibrary = (isFusion && _insertFusion[level]) || _insertStandard[level],
		oldLibrary;
	var i, len = garbageObj._$freeFieldBinds.length,
		targets = {}, $bind, ret, _getSrclayout, _getFreeBlock, srcLayout, jocker;
	var ctx = {
		"library": insertLibrary,
		"page": garbageObj.article.page
	}, targetsKeys, target, localize = ctx.page.localize;
	var result = {
		"diagnoses": {},
		"warning": 0,
		"success": 0,
		"error": 0,
		"fatal": 0
	}, severity, message, detail;

	function _getMethod(name) {
		return (isFusion && _insertFusion[level] && _insertFusion[level][name]) || _insertStandard[level][name];
	}

	function _searchTarget(context) {
		var i, len, ret = false;
		for (i = 0, len = context.library.rules.length; i < len; i++) {
			if ((ret = context.library[context.library.rules[i]].call(garbageObj, context))) {
				break;
			}
		}
		return ret;
	}
	try {
		// For each free binds, we look for the best target
		for (i = 0; i < len; i++) {
			ctx.$bind = garbageObj._$freeFieldBinds[i];
			ret = _searchTarget(ctx);
			if (!ret && isFusion && insertLibrary != _insertStandard[level]) {
				oldLibrary = insertLibrary;
				ctx.library = _insertStandard[level];
				ret = _searchTarget(ctx);
				ctx.library = oldLibrary;
			}
			targets[ctx.$bind] = ret;
		}
		// For each free binds, we  try to insert field in target layout
		targetsKeys = Object.keys(targets);
		for (i = 0, len = targetsKeys.length; i < len; i++) {
			// Misc init
			target = targets[targetsKeys[i]];
			_getSrclayout = _getMethod("getSrcLayout");
			_getFreeBlock = _getMethod("getlastFreeBlock");
			srcLayout = _getSrclayout.call(garbageObj, targetsKeys[i], ctx);
			message = "failed to insert - todo"; //localize.autoInsertFailed
			severity = "error";
			// Check if we have found a section/bloc, otherwise we look for a default one...
			if (!target.block) {
				jocker = target ? target.section : null;
				target = {};
				if (!(target.block = _getFreeBlock.call(garbageObj, jocker, ctx))) {
					message = "can't find free block slot - todo"; //localize.autoInsertNoFreeBlock
				} else {
					target.slot = target.block.field.length;
					message = jocker ? "insert in last block - todo" : "insert in last section/last block - todo"; //target.section ? localize.autoInsertInLastBlock : localize.autoInsertInLastSecBlock
					jocker = true;
					severity = "warning";
				}
			}
			if (target.block) {
				ret = _insertLayout.call(garbageObj, srcLayout, target.block, target.slot);
				if (ret.success && !jocker) {
					severity = "success";
					message = "inserted successfully - todo"; //localize.autoInsertSuccess
				}
			}
			// Set diagnosis
			result.diagnoses[targetsKeys[i]] = [{
				"$severity": severity,
				"$message": message,
				"$details": ret ? ret.details : null
			}];
			result[severity]++;
		}
	} catch (e) {
		var ii, lenii;
		if (garbageObj && garbageObj._$freeFieldBinds) {
			for (ii = 0, lenii = garbageObj._$freeFieldBinds.length; ii < lenii; ii++) {
				if (!result.diagnoses[garbageObj._$freeFieldBinds[ii]]) {
					result.diagnoses[garbageObj._$freeFieldBinds[ii]] = [{
						"$severity": "fatal",
						"$message": "todo - localize.autoInsertUnexpected",
						"$detail": e.message,
						"$stack": e.stack
					}];
					result.fatal++;
				}
			}
		}
	} finally {
		return result;
	}
};

function _insertLayout(layoutToInsert, blockTarget, slot) {
	var ret = {
		"success": true,
		"details": ""
	};
	//blockTarget.items.splice(slot, 0, layoutToInsert);
	// Warning for Convergence : have to deal with reference field, grid, dimensioned field...
	return ret;
}

var _insertFusion = {
	"levelField": {
		"rules": []
	},
	"levelArticle": {
		"rules": ["ruleById", "ruleByTitleFromId", "ruleByTitle"],
		"_oddFieldTypes": {
			"application/x-array": true,
			"text/rtf": true,
			"text/html": true,
			"image": true,
			"application/wid": true,
			"application/x-shockwave-flash": true
		},
		ruleById: function(context) {
			var ret = null,
				block;
			context.fieldScope = context.page.getFieldScope(context.$bind, false);
			if ((block = context.library._findBlockById(this._$layoutMap, null, context.fieldScope))) {
				ret = context.library._checkInBlock(block, context);
			}
			return ret;
		},
		ruleByTitleFromId: function(context) {
			var block, ret = null,
				found, data = {};
			if ((block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data))) {
				if ((found = context.library._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
					ret = context.library._checkInBlock(found, context);
				}
			}
			return ret;
		},
		ruleByTitle: function(context) {
			var ret = null,
				block, found, data = {};
			block = context.library._searchBlock(this._$protoLayoutMap, context.$bind, data);
			if (block && (found = context.library._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
				ret = context.library._checkInBlock(found, context);
			}
			return ret || {
				"section": data.section
			};
		},
		getSrcLayout: function($bind, context) {
			var block, slot = null,
				layout = null;

			function _walk(items) {
				var ii, $item, jj = items.length;
				for (ii = 0; ii < jj && !layout; ii++) {
					$item = items[ii];
					if ($item.$bind && $item.$bind == $bind) {
						layout = $item;
						break;
					} else {
						if ($item.$items) {
							_walk($item.$items);
						}
						if (!layout && $item.$layout && ($item = $item.$layout.$items)) {
							_walk($item);
						}
					}
				}
			}
			if (!(block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.page.getFieldScope($bind, false)))) {
				block = context.library._searchBlock(this._$protoLayoutMap, context.$bind);
			}
			if (block && (slot = block.field.indexOf($bind)) >= 0) {
				_walk(block.items);
			}
			return layout || {
				"$bind": $bind
			};
		},
		getlastFreeBlock: function(section, context) {
			var i, block = null,
				self = this;

			function _getBlock(sec) {
				var j, blck = null;
				for (j = sec.block.length - 1; j >= 0; j--) {
					if (sec.block[j].field.length > 1 || !context.library._oddFieldTypes[self._$properties[sec.block[j].field[0]].$type]) {
						blck = sec.block[j];
						break;
					}
				}
				return blck;
			}
			if (!section) {
				for (i = this._$layoutMap.section.length - 1; i >= 0; i--) {
					if ((block = _getBlock(this._$layoutMap.section[i]))) {
						break;
					}
				}
			} else {
				block = _getBlock(section);
			}
			return block;
		},
		_checkInBlock: function(block, context) {
			var i, len, scope, score = 0,
				fieldSlot = null;
			if ((len = block.field.length) > 0) {
				for (i = 0; i < len; i++) {
					scope = context.page.getFieldScope(block.field[i], false);
					if (context.fieldScope.blockRank == scope.blockRank && context.fieldScope.sectionId == scope.sectionId) {
						score++;
					}
				}
				if (score == len) {
					fieldSlot = context.fieldScope.rank - 1;
				} else if (score / len * 100 > 50) {
					// TODO : resolve fieldSlot!
					fieldSlot = null;
				}
			} else {
				fieldSlot = 0;
			}
			return fieldSlot !== null ? {
				"block": block,
				"slot": fieldSlot
			} : null;
		},
		_findBlockById: function(map, $bind, scope, data) {
			var found = null,
				sec;
			if (map.section.length >= scope.sectionRank) {
				sec = map.section[scope.sectionRank - 1];
				if (sec.$XID == scope.sectionId && sec.block.length >= scope.blockRank) {
					found = !$bind || sec.block[scope.blockRank - 1].field.indexOf($bind) >= 0 ? sec.block[scope.blockRank - 1] : null;
					if (data && found) {
						data.section = sec;
					}
				}
			}
			return found;
		},
		_searchBlock: function(map, $bind, data) {
			var found = null,
				sec, i, j, leni = map.section.length,
				lenj;
			for (i = 0; i < leni && !found; i++) {
				sec = map.section[i];
				for (j = 0, lenj = sec.block.length; j < lenj; j++) {
					if (sec.block[j].field.indexOf($bind) >= 0) {
						found = sec.block[j];
						if (data) {
							data.section = sec;
						}
						break;
					}
				}
			}
			return found;
		},
		_findBlockByTitle: function(map, bTitle, sTitle, context) {
			var found = null,
				sec, i, j, leni = map.section.length,
				lenj;
			if (sTitle == undefined) {
				sTitle = "-";
			}
			if (bTitle && sTitle) {
				for (i = 0; i < leni && !found; i++) {
					sec = map.section[i];
					if (sec.$title == sTitle) {
						for (j = 0, lenj = sec.block.length; j < lenj; j++) {
							if (sec.block[j].$title == bTitle) {
								found = sec.block[j];
								break;
							}
						}
					}
				}
			}
			return found;
		}
	}
};

var _insertStandard = {
	"levelField": {
		"rules": []
	},
	"levelArticle": {
		"rules": []
	}
};