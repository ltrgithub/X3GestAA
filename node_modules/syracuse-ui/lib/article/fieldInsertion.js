"use strict";
var helpers = require('syracuse-core/lib/helpers');

exports.fieldsInsert = function(designLevel, isFusion, garbageObj) {
	var level = "level" + designLevel.charAt(0).toUpperCase() + designLevel.slice(1);
	var insertLibrary = (isFusion && _insertFusion[level]) || _insertStandard[level];
	var context = {
		"library": insertLibrary,
		"level": level,
		"page": garbageObj.page,
		"isFusion": isFusion
	};
	var result = {"field": {}, "block": {}, "section": {}}, $definedBinds = {}, stats;
	result.block = _insertBlocks.call(garbageObj, level, insertLibrary, context);
	stats = result.block && garbageObj.insertStats (result.block);
	if(stats && stats.ok) {
		// Have to remap authored layoud according blocks insertion
    	garbageObj._getDefinedFieldsObject(garbageObj.article.$item, $definedBinds, garbageObj._$layoutMap);
    }
	result.field = _insertFields.call(garbageObj, level, insertLibrary, context);
	return result;
};

function _insertBlocks (level, insertLibrary, ctx) {
	var targetsKeys, target, result = _helpers.initResult(), severity, message;
	var i, j, leni, lenj, title, ret, targets = {}, localize = ctx.page.localize;
	try {
		// New block detection...
		for (i = 0, leni = this._$protoLayoutMap.section.length; i < leni; i++) {
			targets[i.toString()] = _processEntity.call(this, ctx, "block", [i]);
		}
		// For each new block detected, we try to insert it in target layout
		targetsKeys = Object.keys(targets);
		for (i = 0, leni = targetsKeys.length; i < leni; i++) {
			if((lenj = targets[targetsKeys[i]].inserted.length)) {
				for (j = 0; j < lenj; j++) {
					target = targets[targetsKeys[i]].inserted[j];
					message = "autoInsertBlockFailed";
					severity = "error";
					ret = _insertLayout(target.layoutToInsert, target);
					if (ret.success) {
						severity = "info";
						message = "autoInsertBlockSuccess";
					}
					// Set diagnosis
					title = "'" + _helpers.getTitle(this.article, target.block.$title, "Block '" + target.rankOrigin + "'") + "' (Section '" + _helpers.getTitle(this.article, targetsKeys[i], targetsKeys[i]) + "')";
					result.diagnoses[(i + "_inserted_" + j)] = target.diagnosis || this.makeDiagnosis(null, null, title + " : " + localize[message], severity, ret ? ret.details : null);
					result[target.diagnosis && target.diagnosis.$severity || severity]++;
				}
			}
			if((lenj = targets[targetsKeys[i]].defects.length)) {
				// Defects...
				for (j = 0; j < lenj; j++) {
					target = targets[targetsKeys[i]].defects[j];
					result.diagnoses[(i + "_defects_" + j)] = target.diagnosis;
					result[target.diagnosis && target.diagnosis.$severity || "error"]++;
				}
			}
		}
	}
	catch (e) {
		result.diagnoses["_catch"] = this.makeDiagnosis("autoInsertBlockUnexpected", null, null, "fatal", e.message, e.stack);
		result.fatal++;
	}
	finally {
		return result;
	}
}

function _insertFields (level, insertLibrary, ctx) {
	var i, len = this._$freeFieldBinds.length, _getFieldSrclayout, _getFreeBlock;
	var oldLibrary, localize = ctx.page.localize;
	var result = _helpers.initResult(), fieldName, self = this;

	function _getMethod(name) {
		return (ctx.isFusion && _insertFusion[level] && _insertFusion[level].field && _insertFusion[level].field[name]) || _insertStandard[level][name].field;
	}
	function _getFusionFldName(code) {
		var prop;
		return self._$properties && (prop = self._$properties[code]) && prop.$X3Name;
	}
	function _insert(bind, target) {
		var srcLayout, message = "autoInsertFailed", severity = "error", jocker, ret;
		// Misc init
		srcLayout = _getFieldSrclayout.call(self, bind, ctx);
		// Check if we have found a section/bloc, otherwise we look for a default one...
		if (!target || !target.block) {
			jocker = target ? target.section : null;
			if (!(target = _getFreeBlock.call(self, jocker, ctx))) {
				message = "autoInsertNoFreeBlock";
			} else {
				message = jocker ? "autoInsertInLastBlock" : "autoInsertInLastSecBlock";
				jocker = true;
				severity = "warning";
			}
		}
		if (target && target.block) {
			ret = _insertLayout.call(self, srcLayout, target, bind);
			if (ret.success && !jocker) {
				severity = "info";
				message = "autoInsertSuccess";
			}
		}
		// Set diagnosis
		fieldName = ctx.isFusion && _getFusionFldName(bind);
		result.diagnoses[bind] = target.diagnosis || self.makeDiagnosis(null, null, (fieldName || bind) + " : " + localize[message], severity, ret ? ret.details : null);
		result[target.diagnosis && target.diagnosis.$severity || severity]++;
	}
	try {
		// Init
		_getFieldSrclayout = _getMethod("getFieldSrclayout");
		_getFreeBlock = _getMethod("getLastFreeBlock");
		// For each free binds, we look for the best block target
		if(ctx.isFusion) {
			this._$freeFieldBinds = this._$freeFieldBinds.sort();
		}
		for (i = 0; i < len; i++) {
			ctx.$bind = this._$freeFieldBinds[i];
			_insert(ctx.$bind, _processEntity.call(this, ctx, "field"));
		}
	} catch (e) {
		var ii, lenii;
		if (this._$freeFieldBinds) {
			for (ii = 0, lenii = this._$freeFieldBinds.length; ii < lenii; ii++) {
				if (!result.diagnoses[this._$freeFieldBinds[ii]]) {
					fieldName = ctx.isFusion && _getFusionFldName(this._$freeFieldBinds[ii]);
					result.diagnoses[this._$freeFieldBinds[ii]] = this.makeDiagnosis(null, null, (fieldName || this._$freeFieldBinds[ii]) + " : " + localize.autoInsertUnexpected, "fatal", e.message, e.stack);
					result.fatal++;
				}
			}
		}
	} finally {
		return result;
	}
}

function _processEntity (context, type, args) {
	var oldLibrary, i, len, ret = null, lib = context.library[type];
	for (i = 0, len = lib.rules.length; i < len; i++) {
		if ((ret = lib[lib.rules[i]].apply(this, [context].concat(args || [])))) {
			break;
		}
	}
	if (!ret && context.isFusion && context.library != _insertStandard[context.level]) {
		oldLibrary = context.library;
		context.library = _insertStandard[context.level];
		ret = _processEntity.call(this, context, type, args);
		context.library = oldLibrary;
	}
	return ret;
}

function _insertLayout(layoutToInsert, itemTarget, fldBind) {
	var ret = {
		"success": true,
		"details": ""
	};
	if(itemTarget.layout.parent && itemTarget.layout.parent.$widths) {
		delete itemTarget.layout.parent.$widths;
	}
	itemTarget.layout.slot.splice(itemTarget.layout.rank, 0, layoutToInsert);
	if(fldBind) {
		// A little bit more for fields
		if(fldBind && itemTarget.block && itemTarget.block.boundFields && itemTarget.rank !== null ) {
			itemTarget.block.boundFields.splice(itemTarget.rank, 0, fldBind);
		}
	}
	return ret;
}

var _helpers = {
	getTitle: function(api, code, id) {
		var title;
		if(!code || code == "-") {
			title = id;
		}
		else if(api && api.getLocalizeText) {
			title = api.getLocalizeText(code);
		}
		else {
			title = code;
		}
		return title;
	},
	initResult: function() {
		return  {
			"diagnoses": {},
			"warning": 0,
			"success": 0,
			"error": 0,
			"fatal": 0,
			"info": 0
		}
	},
	_walkLayout: function($item, stop, callback, data) {
		if ($item.$items) {
			callback($item.$items, data);
		}
		if (!stop && $item.$layout && ($item = $item.$layout.$items)) {
			callback($item, data);
		}
	},
	_findSectionByTitle: function(map, sTitle) {
		var i, len = map.section.length;
		if (sTitle == undefined) {
			sTitle = "-";
		}
		for (i = 0; i < len; i++) {
			if (map.section[i].$title == sTitle) {
				break;
			}
		}
		return i < len ? map.section[i] : null;
	},
	_findBlockByTitle: function (map, bTitle, sTitle) {
		var found = null, sec, i, len;
		if (bTitle && (sec = _helpers._findSectionByTitle(map, sTitle))) {
			for (i = 0, len = sec.block.length; i < len; i++) {
				if (sec.block[i].$title == bTitle) {
					found = sec.block[i];
					break;
				}
			}
		}
		return found;
	},
	_searchBlockHoldBind: function (map, $bind, data) {
		var found = null,
			sec, i, j, leni = map.section.length,
			lenj;
		for (i = 0; i < leni && !found; i++) {
			sec = map.section[i];
			for (j = 0, lenj = sec.block.length; j < lenj; j++) {
				if (sec.block[j].boundFields.indexOf($bind) >= 0) {
					found = sec.block[j];
					if (data) {
						data.section = sec;
					}
					break;
				}
			}
		}
		return found;
	}
};
var _insertFusion = {
	"levelField": {
		"field": {
			"rules": []
		}
	},
	"levelArticle": {
		"_isArticleLevel": true,
		"field": {
			"rules": ["$ruleDimField", "$ruleById", "$ruleByTitleFromId", "$ruleByTitle", "$ruleLast"],
			"_oddFieldTypes": {
				"application/x-array": true,
				"text/rtf": true,
				"text/html": true,
				"image": true,
				"application/wid": true,
				"application/x-shockwave-flash": true
			},
			$ruleDimField: function(context) {
				var ret = null, block, name, dimIdx, dimId, dimName, i, persisteP, score = 0, bindDim, targetLayout;
				if((name = this._$properties[context.$bind].$X3Name) && (persisteP = this.article.$persistPrototype && this.article.$persistPrototype.$properties)) {
					if ((dimIdx = name.lastIndexOf("_")) > 0) {
						dimId = name.substring(dimIdx + 1);
						if(dimId.length && !isNaN(parseInt(dimId, 10))) {
							dimName = name.substring(0, dimIdx);
							for(i = 1; i < dimId; i++) {
								if(persisteP[dimName + "_" + (i + 1)]) {
									score++;
								}
							}
							if (score == dimId - 1 && (bindDim = persisteP[dimName + "_" + (dimId - 1)].$xid)) {
								block = _helpers._searchBlockHoldBind(this._$layoutMap, bindDim);
								if(block && (targetLayout = context.library._getBlockLayout.call(this, block, context.$bind, {"bind": bindDim, "after": true}, context))) {
									ret = {"rank": block.boundFields.indexOf(bindDim), "block": block, "layout": targetLayout.layout, "diagnosis": targetLayout.diagnosis};
								}
							}
						}
					}
				}
				return ret;
			},
			$ruleById: function(context) {
				var ret = null, block, data = {"justSection": true}, relevance = false;
				// Check rule relevance
				context.fieldScope = context.page.getFieldScope(context.$bind, false);
				context.library._findBlockById(this._$layoutMap, null, context.fieldScope, data, context.page);
				relevance = !data.section || (data.section.block.length != this._$protoLayoutMap.section[context.fieldScope.sectionRank - 1].block.length) ? false : true;
				// If OK...
				if (relevance && (block = context.library._findBlockById(this._$layoutMap, null, context.fieldScope, null, context.page))) {
					ret = context.library._checkInBlock.call(this, block, context);
				}
				return ret;
			},
			$ruleByTitleFromId: function(context) {
				var block, ret = null,
					found, data = {};
				if ((block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data, context.page))) {
					if ((found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
						ret = context.library._checkInBlock.call(this, found, context);
					}
				}
				return ret;
			},
			$ruleByTitle: function(context) {
				var ret = null,
					block, found, data = {};
				block = _helpers._searchBlockHoldBind(this._$protoLayoutMap, context.$bind, data);
				if (block && (found = _helpers._findBlockByTitle(this._$layoutMap, block.$title, data.section.$title, context))) {
					ret = context.library._checkInBlock.call(this, found, context);
				}
				return ret;
			},
			$ruleLast: function(context) {
				// Just try to resolve section
				var sec = null, data = {"justSection": true};
				context.library._findBlockById(this._$layoutMap, null, context.fieldScope, data, context.page);
				if(!data.section) {
					context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.fieldScope, data, context.page);
					if(!data.section || !data.section.$title) {
						_helpers._searchBlockHoldBind(this._$protoLayoutMap, context.$bind, data);
					}
					if(data.section && data.section.$title){
						sec = _helpers._findSectionByTitle(this._$layoutMap, data.section.$title);
					}
				}
				else {
					sec = data.section;
				}
				return sec ? {"section": sec} : null;
			},
			getFieldSrclayout: function($bind, context) {
				var block, layout = null;

				function _walk(items) {
					var i, len = items.length, $item;
					for (i = 0; i < len && !layout; i++) {
						$item = items[i];
						if ($item.$bind && $item.$bind == $bind) {
							layout = $item;
							break;
						} else {
							_helpers._walkLayout($item, !!(layout), _walk);
						}
					}
				}
				if (!(block = context.library._findBlockById(this._$protoLayoutMap, context.$bind, context.page.getFieldScope($bind, false), null, context.page))) {
					block = _helpers._searchBlockHoldBind(this._$protoLayoutMap, context.$bind);
				}
				if (block && block.boundFields.indexOf($bind) >= 0) {
					_walk(block.items);
				}
				return layout || {
					"$bind": $bind
				};
			},
			getLastFreeBlock: function(section, context) {
				var i, block = null,
					self = this, targetLayout;

				function _getBlock(sec) {
					var j, blck = null;
					for (j = sec.block.length - 1; j >= 0; j--) {
						if (sec.block[j].boundFields.length > 1 || !context.library.field._oddFieldTypes[self._$properties[sec.block[j].boundFields[0]].$type]) {
							blck = sec.block[j];
							break;
						}
					}
					return blck;
				}
				if (!section) {
					for (i = this._$layoutMap.section.length - 1; i >= 0; i--) {
						if ((block = _getBlock(this._$layoutMap.section[i]))) {
							break;
						}
					}
				} else {
					block = _getBlock(section);
				}
				targetLayout = context.library._getBlockLayout.call(this, block, context.$bind, {"last": true}, context);
				return block && targetLayout ? {"rank": block.boundFields.length, "block": block, "layout": targetLayout.layout, "diagnosis": targetLayout.diagnosis} : null;
			}
		},
		"block": {
			"rules": ["$ruleLast"],
			$ruleLast: function(context, secRank) {
				var ret = {"inserted": [], "defects": []}, i, j, k, len, secA = this._$layoutMap.section[secRank], secR = this._$protoLayoutMap.section[secRank];
				var blockR, blockA, lenR = secR.block.length, lenA = secA.block.length, rank, scope, score = 0, diagnosis;
				var newBlocks = [], authoBlocks = {}, temp, self = this;
				function _processNewBlock(idx, blockRef, slot, slotRank, diag) {
					var i, idxOf, len;
					ret.inserted.push ({"diagnosis": diag, "block": blockRef, "rankOrigin": newBlocks[idx].rank, "layoutToInsert": blockRef.parent[blockR.parentSlot], "layout": {"slot": slot, "rank": slotRank}});
					newBlocks.splice(idx, 1);
					// Have to suppress field from freebinds map
					for(i = 0, len = blockRef.boundFields.length; i < len; i++) {
						if((idxOf = self._$freeFieldBinds.indexOf(blockRef.boundFields[i])) >= 0) {
							self._$freeFieldBinds.splice(idxOf, 1);
						}
					}
				}
				// New blocks detection
				for(i = 0; i < lenR; i++) {
					blockR = secR.block[i];
					score = 0;
					for(j = 0, len = blockR.boundFields.length; j < len; j++) {
						if(this._$freeFieldBinds[blockR.boundFields[j]]) {
							score++;
						}
					}
					scope = context.page.getFieldScope(blockR.boundFields[0]);
					if(((score / len) * 100 > 50) || (blockR.$title && blockR.$title != "-" && secA.boundBlocks.indexOf(blockR.$title) < 0)) {
						newBlocks.push({"from": i, "rank": scope.blockRank});
					}
				}
				if(newBlocks.length) {
					// New blocks insertion rank resoluteness
					for(i = 0; i < lenA; i++) {
						blockA = secA.block[i];
						temp = [];
						for(j = 0, len = blockA.boundFields.length; j < len; j++) {
							scope = context.page.getFieldScope(blockA.boundFields[j]);
							temp[scope.blockRank] = !temp[scope.blockRank] ? 1 : temp[scope.blockRank] + 1;
						}
						rank = -1;
						k = 0;
						for(j = 0, len = temp.length; j < len; j++) {
							if(temp[j] && temp[j] > k) {
								k =  temp[j];
								rank = j;
							}
						}
						if(rank >= 0 && !authoBlocks[rank.toString()]) {
							authoBlocks[rank.toString()] = i;
						}
					}
					// Process...
					for(j = newBlocks.length - 1; j >= 0; j--) {
						blockR = secR.block[newBlocks[j].from];
						temp = Object.keys(authoBlocks).sort();
						for(i = 0, lenA = temp.length; i < lenA; i++) {
							if(newBlocks[j].rank <= parseInt(temp[i], 10)) {
								break;
							}
						}
						if(i < lenA) {
							blockA = secA.block[authoBlocks[temp[i]]];
							_processNewBlock(j, blockR, blockA.parent, blockA.parentSlot);
						}
					}
					if ((len = newBlocks.length)) {
						// By default, insertion in last slot of section
						for(j = len - 1; j >= 0; j--) {
							blockR = secR.block[newBlocks[j].from];
							if(secA.block.length >= newBlocks[j].rank) {
								blockA = secA.block[newBlocks[j].rank - 1];
								rank = blockA.parentSlot;
							}
							else {
								blockA = secA.block[secA.block.length - 1];
								rank = blockA.parent.length;
							}
							diagnosis = this.makeDiagnosis(null, null, "'" + _helpers.getTitle(this.article, blockR.$title, "Block '" + newBlocks[j].rank + "'")  + "' : " + context.page.localize.autoInsertBlockInNearestSlot, "warning");
							_processNewBlock(j, blockR, blockA.parent, rank, diagnosis);
						}
					}
				}
				return ret;
			}
		},
		_checkInBlock: function(block, context) {
			var targetLayout, i, len, scope, score = 0,
				fieldRank = -1, tabfldRank = [], nearest = 9999, compute, where = {};
			if ((len = block.boundFields.length) > 0) {
				for (i = 0; i < len; i++) {
					scope = context.page.getFieldScope(block.boundFields[i], false);
					if (context.fieldScope.blockRank == scope.blockRank && context.fieldScope.sectionId == scope.sectionId) {
						score++;
						tabfldRank.push({"from": i, "rank": scope.rank, "bind": block.boundFields[i]});
					}
				}
				if (score == len || score / len * 100 > 50) {
					for (i = 0, len = tabfldRank.length; i < len; i++) {
						compute = tabfldRank[i].rank - context.fieldScope.rank; 
						if(compute >= 0 && compute < nearest || (compute < 0 && -1*compute < nearest)){
							nearest = Math.abs(compute);
							where.after = compute >= 0 ? false : true;
							fieldRank = tabfldRank[i].from;
							where.bind = tabfldRank[i].bind
						}
					}
					if(nearest < 9999) {
						fieldRank = !where.after ? fieldRank : fieldRank + 1;
					}
				}
			} else {
				where.first = true;
				fieldRank = 0;
			}
			if(fieldRank >= 0 && block.items) {
				targetLayout = context.library._getBlockLayout.call(this, block, context.$bind, where, context);
				return targetLayout ? {"rank": fieldRank, "block": block, "layout": targetLayout.layout, "diagnosis": targetLayout.diagnosis} : null;
			}
			else {
				return null;
			}
		},
		_getBlockLayout: function(block, $bind, where, context) {
			var i, len, parentLayout = null, slot = null, ctx = {"count": 0, "rankInSlot": 0, "lMap": []};
			var scope, mess = "autoInsertInNearestSlot", sev = "info", diagnosis = null;
			function _walk(items, data) {
				var i, len, currItem, $item;
				for (i = 0, len = items.length; i < len && !slot; i++) {
					$item = items[i];
					if ($item.$bind) {
						if ((where.first != null && where.first) || (where.bind != null && where.bind == $item.$bind)) {
							slot = items;
							data.rankInSlot = where.first != null && where.first ? 0 : (where.after ? i + 1 : i);
							break;
						}
						ctx.lMap.push({"$bind": $item.$bind, "slot": items, "rank": i, "layoutP": parentLayout});
					}
					else {
						if($item.$layoutType) {
							parentLayout = $item;
						}
						_helpers._walkLayout($item, !!(slot), _walk, data);
					}
				}
			}
			_walk(block.items, ctx);
			if(!slot && where.last != null && where.last) {
				i =  ctx.lMap[ctx.lMap.length - 1];
				slot = i.slot;
				parentLayout = i.layoutP;
				ctx.rankInSlot = i.rank + 1;
			}
			else if(!slot) {
				for (i = ctx.lMap.length - 1; i >= 0; i--) {
					scope = context.page.getFieldScope(ctx.lMap[i].$bind, false);
					if(rank >= scope.rank) {
						break;
					}
				}
				if(i < 0) {
					i = ctx.lMap.length - 1;
					mess = "autoInsertInLastSlot";
					sev = "warning";
				}
				slot = ctx.lMap[i].slot;
				parentLayout = ctx.lMap[i].layoutP;
				ctx.rankInSlot = ctx.lMap[i].rank + 1;
				diagnosis = this.makeDiagnosis(null, null, $bind + " : " + context.page.localize[mess], sev);
				// TODO : test empty bloc.. without slots
			}
			return {"layout": {"slot": slot, "parent": parentLayout, "rank": ctx.rankInSlot}, "diagnosis": diagnosis};
		},
		_findBlockById: function(map, $bind, scope, data, page) {
			var found = null,
				sec, secScope;
			if (map.section.length >= scope.sectionRank) {
				sec = map.section[scope.sectionRank - 1];
				secScope = page.getFieldScope(sec.$XID, false, true);
				if (secScope.sectionId == scope.sectionId && sec.block.length >= scope.blockRank) {
					found = !$bind || sec.block[scope.blockRank - 1].boundFields.indexOf($bind) >= 0 ? sec.block[scope.blockRank - 1] : null;
					if (data && found) {
						data.section = sec;
					}
				}
				else if(data && data.justSection && secScope.sectionId == scope.sectionId && sec.block.length > 0) {
					data.section = sec;
				}
			}
			return found;
		}
	}
};

var _insertStandard = {
	"levelField": {
		"field": {
			"rules": []
		}
	},
	"levelArticle": {
		"_isArticleLevel": true,
		"block": {
			"rules": ["$ruleDummy", "$ruleLast"],
			$ruleDummy: function(context) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(context) {
				var ret = null;
				return ret;
			}
		},
		"field": {
			"rules": ["$ruleDummy", "$ruleLast"],
			"_oddFieldTypes": {
			},
			$ruleDummy: function(context) {
				var ret = null;
				return ret;
			},
			$ruleLast: function(context) {
				var ret = null;
				return ret;
			}
		}
	}
};