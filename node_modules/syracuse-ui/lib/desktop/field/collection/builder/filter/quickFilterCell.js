"use strict";
var helpers = require('syracuse-core/lib/helpers');

var _localizeOperators = {
    "none": "All",
    "gt": "Greater than",
    "ge": "Greater than or equals",
    "lt": "Less than",
    "le": "Less than or equals",
    "eq": "Equals",
    "ne": "Not equals",
    "between": "Between",
    "like": "Contains",
    "like_s": "Starts with"
}

function QuickFilterCell(){
}

exports.QuickFilterCell = helpers.defineClass(QuickFilterCell, null, {
    render: function(record, $$container, $field, $bind){
        var self = this;
        self.$field = $field;
        self.record = record;
        self.$bind = $bind;
        self.operator = "none";
        var $$filter = self.$$container = $$container;
        self.$$list = $("<div class='s-q-filter-list'/>").appendTo(self.$$container).hide();
        self.hookListClick();
        self.$$operator = $("<a class='s-q-filter s-q-filter-op-none'/>").appendTo(self.$$container).bind("click", function(){
            if (!self.listPopup) {
                self.$$list.empty();
                var operators;
                switch (self.$field.$type) {
                    case "application/x-date":
                    case "application/x-time":
                    case "application/x-datetime":
                        operators = ["none", "gt", "ge", "lt", "le", "eq", "ne", "between"];
                        break;
                    case "application/x-string":
                        operators = ["none", "gt", "ge", "lt", "le", "eq", "ne", "like_s", "like", "between"];
                        break;
                    default:
                        operators = ["none", "eq", "ne"];
                        break;
                }
                operators.forEach(function(op){
                    self.$$list.append($("<a class='s-q-filter-item s-q-filter-op-" + op + "'/>").attr("data-s-op", op).text(_localizeOperators[op]));
                });
                self.listPopup = self.record.boxParent.openDialog({
                    $dialogMode: "popup",
                    content: self.record,
                    $$dialog: self.$$list,
                    position: {
                        my: "left top",
                        at: "left bottom",
                        of: self.$$container
                    },
                    onClose: function(){
                        self.listPopup = null;
                    }
                });
            }
            else {
                self.listPopup.close();
            }
            return false;
        });
        self.loadField();
    },
    setOperator: function(operator){
        this.$$operator[0].className = "s-q-filter s-q-filter-op-" + (this.operator = operator);
    },
    hookListClick: function(){
        var self = this;
        self.$$list.delegate("a.s-q-filter-item", "click", function(){
            self.setOperator($(this).attr("data-s-op"));
            self.listPopup.close()
            // between, create the "high" field
            var highField = self.record.boundFields[self.$bind + "$High"];
            if (self.operator === "between") {
                if (highField) {
                    highField[0].$$dataValue.toggle(true);
                }
                else {
                    self.loadField(self.$field, self.$bind + "$High");
                }
            }
            else {
                if (highField) {
                    highField[0].$$dataValue.toggle(false);
                }
                var value = self.record.dataset[self.$bind];
                if (self.operator != "none") {
                    if (value != null && value != "") {
                        self.record._buildFilter();
                    }
                }
                else {
                    if (value != null && value != "") {
                        var field = self.record.boundFields[self.$bind][0];
                        field.setDataValue(null);
                        document.fieldController.notifyChange(field, null);
                    }
                    else {
                        self.record._buildFilter();
                    }
                }
            }
        });
    },
    _format: function(field, $type, value){
        switch ($type) {
            case "application/x-reference":
                return "'" + (field.currentValue.$key || field.currentValue.$value) + "'";
            case "application/x-choice":
                var fieldType = (field.$field && field.$field.$value && field.$field.$value.$type) || "application/x-string";
                return this._format(field, fieldType, value);
            case "application/x-boolean":
            case "application/x-integer":
            case "application/x-decimal":
                return value;
            case "application/x-date":
                return "@" + value + "@";
        }
        return "'" + value + "'";
    },
    getValue: function(){
        var field = this.record.boundFields[this.$bind][0];
        var value = this.record.dataset[this.$bind];
        if (this.operator != "none" && value != null) {
            var op = this.operator;
            var right;
            switch (op) {
                case "like":
                    // like is for strings only so direct access to store
                    right = "'%" + value + "%'";
                    break;
                case "like_s":
                    // like is for strings only so direct access to store
                    right = "'" + value + "%'";
                    op = "like";
                    break;
                case "between":
                    var highValue = this.record.dataset[this.$bind + "$High"];
                    if (value && !highValue) {
                        right = this._format(field, this.$field.$type, value);
                        op = "ge";
                    }
                    else {
                        if (!value && highValue) {
                            right = this._format(field, this.$field.$type, highValue);
                            op = "le";
                        }
                        else {
                            if (value && highValue) {
                                right = this._format(field, this.$field.$type, value) + " and " + this._format(field, this.$field.$type, highValue);
                            }
                            else {
                                return "";
                            }
                        }
                    }
                    break;
                default:
                    right = this._format(field, this.$field.$type, value);
                    break;
            }
            return "(" + this.$bind + " " + op + " " + right + ")";
        }
    },
    loadField: function($field, $bind){
        document.itemFactory.load(this.$$container, {
            $bind: $bind || this.$bind,
            $isTopLabelAlignment: false,
            $isCellChild: true,
            $isFilterMode: true,
            $inplace: true,
            $field: $field
        }, this.record);
    },
    ensureEqual: function(){
        // force operator to equals
        if (this.operator === "none" && this.$field) {
            var defaultFilter;
            switch (this.$field.$type) {
                case "application/x-date":
                case "application/x-time":
                case "application/x-datetime":
                    defaultFilter = "ge";
                    break;
                case "application/x-string":
                    defaultFilter = "like";
                    break;
                default:
                    defaultFilter = "eq";
                    break;
            }
            this.setOperator(defaultFilter);
        }
    },
    dispose: function(){
        if (this.$$operator) {
            this.$$operator.unbind();
        }
        if (this.$$list) {
            this.$$list.undelegate();
        }
        delete this.record;
    },
    // FDB 
    fusionGetInputValue: function(){
        var field = this.record.boundFields[this.$bind][0];
        return field.getDataValue();
    }
});
