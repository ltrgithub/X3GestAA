"use strict";

var d3 = require("syracuse-ui/deps/d3");

var helpers = require('syracuse-core/lib/helpers'),
	uiHelper = require('syracuse-ui/lib/desktop/field/process/helpers');
require('syracuse-ui/lib/desktop/field/process/jquery.contextMenu');
require('syracuse-ui/deps/jqModal/jqModal');


var imagesRoot = "/syracuse-ui/themes/desktop/sage/process/images",
	libInfoRoot = "/syracuse-ui/lib/desktop/field/process"  ;


function ProcessPlayer() {};

exports.ProcessPlayer = helpers.defineClass(ProcessPlayer, null, {
	init: function($$div, options) {
		var self = this;
		this.$$div = $$div;
		this.options = options;
		this.uuid = $$div.attr("id");

		/*******************************************************
		 *	Contextual Menu
		 *******************************************************/
		// TODO: review this by using syracuse popup and without using right click
		/*		$("body").contextMenu({
			menu: 'myMenu'
		}, function(action, el, pos) {
			if (action == "echangeDonnee") {
				//affichage du cadre EchangeDeDonnées et mise à jour du champ
				$("#divCadreEchangesDeDonnees").show();
				$('#textAreaContenuEchangesDeDonnees').val(traceEchData);
			} else if (action == "messageEtTrace") {
				$("#msgEtTraces").show();
				$('#textAreaMsgEtTraces').val(txtMsg);
			} else if (action == "fenetreTechnique") {
				$("#fenetreTechnique").toggle();
				if ($(".montrer").length > 0) {
					if ($(".montrer:visible").length) {
						$('.montrer').jqmHide();
					} else {
						$('.montrer').jqmShow();
					}
				}
			}
		});
*/
		var pageInfoJson = options.process && options.process.getPageInfo();

		// var $$mainMenuSlot = $('<div class="s-process-menu-actions" style="visibility: hidden;">').appendTo($$div);
		// $('<a>').addClass("s-process-main-menu").click(function(event) {
		// 	console.log("menu click s-process-menu-actions");
		// }).appendTo($$mainMenuSlot);

		var $$page = $('<div>').attr("id", "page").appendTo($$div);
		// $$page.bind("mouseenter.buttons mouseleave.buttons", function(event) {
		// 	// $$page.bind("mouseenter mouseleave", function(event){
		// 	$$mainMenuSlot[0].style.visibility = event.type == "mouseenter" ? "visible" : "hidden";
		// });

		this.$$container = $$page;

		// $('<div>').attr("id", "fenetreTechnique").addClass("s-process-hidden s-process-fenetreImportExport") //
		// .appendTo($$div).append('<div id="entetedivflottantFT">') //
		// .append($('<div id="DivDockToolBar"').addClass("s-process-DivDockToolBar")) //
		// .append('<div id="divSousMenu">');
		var technicPart = '<div id="fenetreTechnique" class="s-process-hidden s-process-fenetreImportExport">   \
            <div id="entetedivflottantFT"></div>    \
            <div id="DivDockToolBar" class="s-process-DivDockToolBar">    \
                <div id="menuprincipal" class="s-process-menuprincipal">    \
                    <a id="titreMenuPrincipal" class="s-process-titreMenuPrincipal">Fichier</a>  \
                </div>  \
            </div>  \
            <div id="divSousMenu class="s-process-divSousMenu">  \
                <a class="sousMenuItem" id="importLink">Importer...</a> \
                <a class="sousMenuItem" id="exportLink">Exporter en texte...</a>    \
            </div>  \
        </div>';
		$(technicPart).appendTo($$div);

		// <!--pop-up "fenêtre Importer"-->
		var importPopup = '<div id="import" class="s-process-fenetreImportExport s-process-hidden"> \
        <div id="enteteImport" class="s-process-enteteFenetreImportExport"></div>         \
            <p>Collez vos donn&eacute;es ici :</p>  \
            <div>   \
                <textarea id="textAreaImport" class="s-process-textAreaImportExport"></textarea>  \
            </div>  \
            <div>   \
                <button id="btnValiderImport" class="s-process-btnFT">OK</button> \
                <button id="btnAnnulerImport" class="s-process-btnFT">Annuler</button>    \
            </div>  \
        </div>';
		$(importPopup).appendTo($$div);

		// <!--pop-up "fenêtre Exporter"-->
		var exportPopup = '<div id="export" class="s-process-fenetreImportExport s-process-hidden"> \
            <div id="enteteExport" class="s-process-enteteFenetreImportExport"></div> \
            <p>Vos donn&eacute;es :</p> \
            <div>   \
                <textarea id="textAreaExport" class="s-process-textAreaImportExport"></textarea>  \
            </div>  \
            <div>   \
                <button id="btnValiderExport" class="s-process-btnFT">OK</button> \
            </div>  \
        </div>';
		$(exportPopup).appendTo($$div);

		// <!-- pop up message et traces -->
		var messagePopup = '<div id="msgEtTraces" class="s-process-hidden">   \
            <div id="enteteMsgEtTraces" class="s-process-enteteMsgEtTraces">    \
                <div id="titreMsgEtTraces" class="s-process-left"> Vos messages </div>    \
                <div id="divFermer" class="s-process-left"><img id="imageFermerMessageTrace" src="' + imagesRoot + '/fermer.png" width="20" height="20" alt="fermer"> </div> \
                <div style="clear:both"></div>  \
            </div>  \
            <div>   \
                <div id="divTextAreaMsgEtTraces" class="s-process-left">  \
                    <textarea  id="textAreaMsgEtTraces" class="s-process-textAreaMsgEtTraces" readonly="readonly"></textarea> \
                </div>  \
                <div id="actions" class="s-process-left"> \
                    <div class="s-process-divAction" id="btnMsg"> Messages </div> \
                    <div class="s-process-divAction" id="btnDetail"> Détail </div>    \
                    <div class="s-process-divAction" id="btnTrace"> Trace </div>  \
                    <div class="s-process-divAction" id="btnCopier"> Copier </div>    \
                </div>  \
                <div style="clear:both"></div>  \
            </div>  \
        </div>';
		$(messagePopup).appendTo($$div);

		// <!-- pop up echange de donnees -->
		var exchangePopup = '<div id="divCadreEchangesDeDonnees" class="s-process-hidden s-process-divCadreEchangesDeDonnees">    \
            <div id="divContenuEchangesDeDonnees" class="s-process-divContenuEchangesDeDonnees">  \
                <textarea  id="textAreaContenuEchangesDeDonnees" class="s-process-textAreaContenuEchangesDeDonnees" readonly="readonly"></textarea>    \
            </div>  \
        </div>';
		$(exchangePopup).appendTo($$div);

		var contextMenu = '<ul id="myMenu" class="s-process-contextMenu"> \
            <li ><a href="#echangeDonnee">Echanges de donnees</a></li>  \
            <li class="cut"><a href="#messageEtTrace">Messages et trace</a></li>    \
            <li class="copy separator"><a href="#fenetreTechnique">Montrer/cacher fenetre technique</a></li>    \
        </ul>';
		$(contextMenu).appendTo($$div);


		/*******************************************************
		 *	Chargement du contenu de la page en JSon dans le pop up "exporter"
		 *******************************************************/
		$("#exportLink").click(function(event) {
			showPopUp('export');
			$('#textAreaExport').text(options.process && options.process.getJson());
			$('#textAreaExport').select();
		});

		/*******************************************************
		 *	Affichage du popup "import"
		 *******************************************************/
		$('#importLink').click(function(event)  {
			showPopUp('import');
		});

		/*******************************************************
		 *	Fermeture de la fenêtre message et trace avec un click sur l'image de fermeture
		 *******************************************************/
		$("#imageFermerMessageTrace").hover(function() {
			$(this).attr('src', imagesRoot + '/fermerHover.png');
		}, function() {
			$(this).attr('src', imagesRoot + '/fermer.png');
		}).click(function() {
			$("#msgEtTraces").toggle();
		});

		/*******************************************************
		 *	Gestion du menu de la fenetre technique
		 *******************************************************/
		$("#menuprincipal").click(function(event) {

			if ($("#menuprincipal").hasClass('orangebackground')) {
				$("#menuprincipal").removeClass('orangebackground');
			} else {
				$("#menuprincipal").addClass('orangebackground');
				$("#divSousMenu").toggle();

				//empeche le declenchement du listener qui suit
				event.stopPropagation();

				//Ajout d'un listener de click sur toute la page qui ferme le menu						
				$('#body').bind('click', function() {
					$("#menuprincipal").removeClass('orangebackground');
					$("#divSousMenu").toggle();
					//suppression du listener une fois celui ci utilisé
					$('#body').unbind('click');
				});
			}
		});

		/*******************************************************
		 *	Gestion des boutons de importer/exporter
		 *******************************************************/
		$("#btnValiderExport").click(function() {
			$('#export').jqmHide();
			$('#export').removeClass('montrer');
		});
		$("#btnAnnulerImport").click(function() {
			$('#import').jqmHide();
			$('#import').removeClass('montrer');
		});
		$('textarea').disableContextMenu();

		/*******************************************************
		 *	Gestion de l'import quand on entre le json à la main
		 *******************************************************/
		$('#btnValiderImport').click(function() {
			// on recupere le json … 
			var jsonTxt = $('#textAreaImport').val();
			if (jsonTxt != "") {
				// … et on le charge
				self.options.process && self.options.process.loadJson(jsonTxt);
				// on verifie ensuite que le json est importé, pour vérifier qu'il n'avait pas d'erreur.
				// donc getJson() doit renvoyé le même contenu que l'import
				self.options.process && self.options.process.loadJson(jsonTxt);
				if (self.options.process && (self.options.process.getJson() == jsonTxt))  {

					// et on affiche tous les nouveaux
					self.clear().show();
					// sageInitPage($.sageJSON.getPageInfo()).sageDisplayPlayer($.sageJSON.getFormes());
					// on vide le textarea 
					$('#textAreaImport').val('');

					// et on ferme la fenêtre					
					$('#import').jqmHide();
					$('#import').removeClass('montrer');

				} else {

					// si ça ne correspond pas, on affiche un petit popup
					alert("Le JSON importé n'est pas valide");
				}
			}
		});

		/*******************************************************
		 *	Fenetre echange de données
		 *******************************************************/
		//Cacher la fenetre echange de donnée avec un clic sur la bordure
		$("#divContenuEchangesDeDonnees").click(function(event) {
			event.stopPropagation();
		});
		$("#divCadreEchangesDeDonnees").click(function() {
			$("#divCadreEchangesDeDonnees").hide();
		});

		/*******************************************************
		 *	Definition des draggable pour les popups
		 *******************************************************/
		$("#msgEtTraces").draggable({
			containment: "body",
			scroll: false,
			handle: "#titreMsgEtTraces"
		});
		$("#fenetreTechnique").draggable({
			containment: "body",
			scroll: false
		});
		$("#import").draggable({
			containment: "body",
			scroll: false,
			handle: "#enteteImport"
		});
		$("#export").draggable({
			containment: "body",
			scroll: false,
			handle: "#enteteExport"
		});

		/***************************************************
		 *        Affichage des traces
		 *******************************************************/
		$('#btnTrace').click(function(event) {
			$('#textAreaMsgEtTraces').val(txtTrace);
		});

		/***************************************************
		 *        Affichage des messages
		 *******************************************************/
		$('#btnMsg').click(function(event) {
			$('#textAreaMsgEtTraces').val(txtMsg);
		});

		$$page.css('height', pageInfoJson.contentSize.xheight + 'px').css('width', pageInfoJson.contentSize.xwidth + 'px').css('top', pageInfoJson.docDims.xtop).css('left', pageInfoJson.docDims.xtop);

		return this;
	},
	show: function() {
        var w = 480,
         h = 600 ;
        var t=1 ; //var t = .5 ;
        var delta = .01 ;
       var padding = 0 ;
       var  bezier = {} ;
        var line = d3.svg.line().x(x).y(y) ;
        var stroke = d3.scale.category20b() ;
        var points =[] ;
         

        
        
         function update(ggg, forme) {
                  var interpolation = ggg.selectAll("g").data(function(d) { return getLevels(d, t); });
                  interpolation.enter().append("g"); 

                  var path = interpolation.selectAll("path") 
                      .data(function(d) { return [d]; });
                  path.enter().append("path") ;

                  var curve = ggg.selectAll("path.curve").data(getCurve);
                  curve.enter().append("path") ;
                  curve.attr("d", line);
                  curve.attr('stroke',  function(){
                                            if  (forme.xstrokeProps.xtype==='none' //
                                                || forme.xstrokeProps.xtype==='nostroke') //
                                                return 'none' ;
                                            else
                                                return getHexadecimalColor(forme.xstrokeProps.xcolor) ;
                                    }) ; 
                                curve.attr('stroke-opacity', function(){return forme.xstrokeProps.xalpha/100 ;}) //
                                .attr('stroke-width',function(){return forme.xstrokeProps.xthickness} ) ;
                                curve.attr('stroke-dasharray', function(){
                                if (forme.xstrokeProps.xtype==='dottedstroke')
                                    return 2*forme.xstrokeProps.xthickness+','+ 2*forme.xstrokeProps.xthickness ;
                                else if (forme.xstrokeProps.xtype==='dashedstroke')
                                    return 5*forme.xstrokeProps.xthickness+','+5*forme.xstrokeProps.xthickness; 
                                else return ''; });
                                curve.attr('fill',function(){
                                if (forme.xfillProps.xtype==='nofill')
                                    return 'none';
                                else if (forme.xfillProps.xtype==='solidfill')
                                    return getHexadecimalColor(forme.xfillProps.xcolor) ;
                                else if (forme.xfillProps.xtype==='gradientfill')
                                    return  'url(#grad'+forme.uniqueID+')' ;
                            });
            }
            

            function interpolate(d, p) {
              if (arguments.length < 2) p = t;
              var r = [];
              for (var i=1; i<d.length; i++) {
                var d0 = d[i-1], d1 = d[i];
                r.push({x: d0.x + (d1.x - d0.x) * p, y: d0.y + (d1.y - d0.y) * p});
              }
              return r;
            }

            function getLevels(d, t_) {
              if (arguments.length < 2) t_ = t;
              var x
              if (d[1]>0)
                x = [points.slice(d[0], d[1])];
            else
                x = [points.slice(d[0])];
              for (var i=1; i<4; i++) {
                x.push(interpolate(x[x.length-1], t_));
              }
              return x;
            }

            function getCurve(d) {
              var curve = bezier[d];
              if (!curve) {
                curve = bezier[d] = [];
                for (var t_=0; t_<=1; t_+=delta) {
                  var x = getLevels(d, t_);
                  curve.push(x[x.length-1][0]);
                }
              }
              return [curve.slice(0, t / delta + 1)];
            }

            function x(d) { return d.x; }
            function y(d) { return d.y; }
            function colour(d, i) {
              stroke(-i);
              return d.length > 1 ? stroke(i) : "red";
            }

        function appendGradient(forme,svgel) {
            var defs=d3.select(svgel).append('defs') ;
            switch (forme.xfillProps.xgtype) {
                case 'linear' :
                    var grad=defs.append('linearGradient') ;
                    var tabCoord=calculDegrade(forme.xfillProps.xgrotation) ;
                    grad.attr("id",'grad'+forme.uniqueID).attr('x1',tabCoord.x1+'%')//
                    .attr('y1',tabCoord.y1+'%').attr('x2',tabCoord.x2+'%') //
                    .attr('y2',tabCoord.y2+'%');
                    var stops=grad.selectAll('stop').data(forme.xfillProps.xgcolors).enter().append('stop') ;
                    stops.attr('offset',function(d,i){return forme.xfillProps.xgratios[i]/245.82*100+'%'}) //
                    .attr('style',function(d,i){return 'stop-color:'+getHexadecimalColor(d) + ';stop-opacity:'+forme.xfillProps.xgalphas[i]/100+';';})//
                    break ;
                case 'radial': 
                    var grad=defs.append('radialGradient') ;
                    grad.attr("id",'grad'+forme.uniqueID).attr('cx','50%')//
                    .attr('cy','50%').attr('r','50%') //
                    .attr('fx','50%').attr('fy','50%');
                    var stops=grad.selectAll('stop').data(forme.xfillProps.xgcolors).enter().append('stop') ;
                    stops.attr('offset',function(d,i){return forme.xfillProps.xgratios[i]/245.82*100+'%'}) //
                    .attr('style',function(d,i){return 'stop-color:'+getHexadecimalColor(d) + ';stop-opacity:'+forme.xfillProps.xgalphas[i]/100+';';})//
                break ;
            }
                
        }
        function appendText(forme,el) {
            var divtext=d3.select(el).append('div').attr('id',forme.uniqueID+'p');
            divtext.html(forme.xtext) ;
            var text="";
            
            var textformat=divtext.selectAll('textformat') ;
            var font=textformat.selectAll('p>font') ;

            var a=font.selectAll('a').each(function (){
                el.attr('href',parseLien($(a).attr("href")))
            }) ;
            text += font.html()+'<br />';

            divtext.html(text) ;
            divtext.style('position','absolute') //
            .style('text-align',forme.xtextFormat.align) //
            .style('word-spacing',forme.xtextFormat.kerning) //
            .style('display',forme.xtextFormat.display) //
            .style('letter-spacing',forme.xtextFormat.letterSpacing+'px') //
            .style('tab-stops',forme.xtextFormat.tabStops)//
            .style('text-indent',forme.xtextFormat.blockIndent+'px') //
            .style('padding-left',forme.xtextFormat.indent+'px') //
            .style('margin-right',forme.xtextFormat.rightMargin+'px') //
            .style('margin-left',forme.xtextFormat.leftMargin+'px') //
            .style('text-decoration',forme.xtextFormat.underline) //
            .style('italic',forme.xtextFormat.italic) //
            .style('font-weight',forme.xtextFormat.bold) //
            .style('target',forme.xtextFormat.target) //
            .style('color',getHexadecimalColor(forme.xtextFormat.color)) //
            .style('font-size',forme.xtextFormat.size+'px') //
            .style('font-family',forme.xtextFormat.font) //
            .style ('z-index',forme.xlevel)//
            .style ('vertical-align',forme.xcaptionProps.xvertAlignMode) ;
            divtext.style('left',forme.xcaptionPos.xleft+'px') //
            .style('top',forme.xcaptionPos.xtop+'px')//
            .style('width',forme.xcaptionSize.xwidth-forme.xtextFormat.rightMargin-forme.xtextFormat.leftMargin+'px') //
            .style('height',forme.xcaptionSize.xheight+'px') ;
        }

        function appendShape(forme,svgel){
            var orders = [] ;
            //var forme=arguments[i] ;
            switch (forme.xshapeType){
                    case 'apishape' :
                    
                        switch (forme.xdrawBehaviorCode){
                            case "K_API_LINE" :
                                var line=d3.select(svgel).append("line") //
                                .attr('x1',forme.xanchors[0].x).attr('y1',forme.xanchors[0].y) //
                                .attr('x2',forme.xanchors[1].x).attr('y2',forme.xanchors[1].y) //
                            break ;
                            case "K_API_RECT" :
                                var rect = d3.select(svgel).append("rect") //
                                .attr("x", forme.xanchors[0].x).attr("y",forme.xanchors[0].y);
                  rect.attr("width", Math.abs(forme.xanchors[1].x-forme.xanchors[0].x))//
                  .attr("height", Math.abs(forme.xanchors[3].y-forme.xanchors[0].y));
                            break ;
                            case "K_API_ELLIPSE" :
                                var ellipse=d3.select(svgel).append("ellipse")//
                                .attr("cx",forme.xanchors[0].x+Math.abs(forme.xanchors[1].x-forme.xanchors[0].x));
                                ellipse.attr("cy",forme.xanchors[0].y)//
                                .attr("rx",Math.abs(forme.xanchors[2].x-forme.xanchors[0].x)/2)//
                                .attr("ry", Math.abs(forme.xanchors[1].y-forme.xanchors[3].y)/2) ;
                            break ;
                            }
                     break ;
                    case 'beziershape' :
                        points =[] ;
                        bezier={} ;
                        var n=forme.xanchors.length ;
                        var end= forme.xclosed ? n : n-1 ;
                        for (var i=1 ; i<=end; i++){
                            var j=i%n ;
                            points.push({'x' :forme.xanchors[i-1].x , 'y' : forme.xanchors[i-1].y   });
                            points.push({'x' :forme.xanchors[i-1].c2x , 'y' : forme.xanchors[i-1].c2y   });
                            points.push({'x' :forme.xanchors[j].c1x , 'y' : forme.xanchors[j].c1y   });
                            points.push({'x' :forme.xanchors[j].x , 'y' : forme.xanchors[j].y   });
                            orders.push([(i-1)*4, j*4 ]) ;
                        }
                    
                    d3.select(svgel).data(orders).attr("width", w ).attr("height", h ) //
                    var gg=d3.select(svgel).selectAll("g").data(orders).enter().append("g") 
                    update(gg,forme,points);
                    d3.select(svgel).datum(forme) ;                    
        break ;
        }  
    }    
    
		var self = this,
			$$container = this.$$container,
			formesListe = self.options && self.options.process && self.options.process.getFormes();
		
		// on parcours les groupes
		for (var gn = 0, sizeG = formesListe.length; gn < sizeG; gn++) {
			var group = formesListe[gn];


		var divs=d3.select($$container[0]).selectAll("div.apishape").data( formesListe[gn].xpropsArr,function(d){if (d.xshapeType==='apishape' || d.xshapeType==='beziershape') return d ;}) //
        .enter().append('div').attr('class','apishape').attr("style",function(d){return 'position:absolute;width:100%;height:100%;z-index:'+d.xlevel+';';}); //.classed('apishape') ;
        var svg=divs.append('svg') ;
        
        svg.attr("width", 900).attr("height", 900).attr('id',function(d){return d.uniqueID}) ;
        svg.each(function(d,idx){
            appendShape(d,svg[0][idx])
        }) ; 

    
    
      

        var gradientsvg = d3.select($$container[0]).selectAll('svg').filter(function(d, i) { 
            if (d.xfillProps!=null && d.xfillProps.xtype==='gradientfill') 
                return 1 ;  });
        gradientsvg.each(function(d,idx){
            appendGradient(d,gradientsvg[0][idx]) ;
        });

        var edge=d3.select($$container[0]).selectAll("svg line, svg rect, svg ellipse, svg line"); 
                            edge.attr('stroke', 
                                    function(d){
                                            if  (d.xstrokeProps.xtype==='none' || d.xstrokeProps.xtype==='nostroke')
                                                return 'none' ;
                                            else
                                                return getHexadecimalColor(d.xstrokeProps.xcolor) ;
                                    }) ; 
                                edge.attr('stroke-opacity', function(d){return d.xstrokeProps.xalpha/100 ;}) //
                                .attr('stroke-width',function(d){return d.xstrokeProps.xthickness} ) ;
                                edge.attr('stroke-dasharray', function(d){
                                    if (d.xstrokeProps.xtype==='dottedstroke')
                                        return 2*d.xstrokeProps.xthickness+','+ 2*d.xstrokeProps.xthickness ;
                                    else if (d.xstrokeProps.xtype==='dashedstroke')
                                        return 5*d.xstrokeProps.xthickness+','+5*d.xstrokeProps.xthickness; //+5*d.xstrokeProps.xthickness+','+ 5*d.xtrokeProps.xthickness ;
                                    else return ''; });
                                edge.attr('fill',function(d){
                                    if (d.xfillProps.xtype==='nofill')
                                        return 'none';
                                    else if (d.xfillProps.xtype==='solidfill')
                                        return getHexadecimalColor(d.xfillProps.xcolor) ;
                                    else if (d.xfillProps.xtype==='gradientfill'){
                                        return  'url(#grad'+d.uniqueID+')' ;
                                    }
                                });
        var textparent = divs.filter(function(d, i) { 
            if (d.xtext!='') 
                return 1 ;  });
        textparent.each(function(d,idx){
            appendText(d, $$container[0]) ;
        });
                                
                                
        //case 'clipshape' :
         var link=d3.select($$container[0]).selectAll("a") //
         .data(formesListe[gn].xpropsArr.filter(function(forme){return (forme.xshapeType==='clipshape' && forme.xlinkProps.xtype!='none')})) //
         .enter().append('a').attr('id',function(d){return d.uniqueID+'ai';})//
         .attr('href',function(d){return d.xlinkProps.xcode;}) ;
         link.append('img').attr('id',function(d){return d.uniqueID}) //
         .attr("src",function(d){return '/syracuse-ui/themes/desktop/sage/process/images'+getBibName(d.bibid)+'/'+d.eltid+'.png';}) ;
        

         var img=d3.select($$container[0]).selectAll("img")//
         .data( formesListe[gn].xpropsArr.filter(function(forme){
         return (forme.xshapeType==='clipshape' && forme.xlinkProps.xtype==='none');})) //
         .enter().append('img') ;
        img.attr('id',function(d){return d.uniqueID;}) ;
        img.style('position','absolute') ;
        img.style('width',function(d){return d.xsize.xwidth;}) ;
        img.style('height',function(d){return d.xsize.xheight;}) ;
        img.style('top',function(d){return d.xcenter.y-d.xsize.xheight/2 +'px' ;}) ;
        img.style('left',function(d){return d.xcenter.x-d.xsize.xwidth/2 +'px' ;}) ;
        img.style('z-index',function(d){return d.xlevel ;}) ;
        img.style('filter',function(d){return "alpha(opacity="+d.alpha+")" ;}) ;
        img.style('-moz-opacity',function(d){ return d.alpha+"/100" ;}) ;
        img.style('-khtml-opacity',function(d){return d.alpha+"/100" ;}) ;
        img.style('opacity',function(d){return d.alpha+"/100" ;}) ;

        img.attr("src",function(d){
        return '/syracuse-ui/themes/desktop/sage/process/images/'+getBibName(d.bibid)+'/'+d.eltid+'.png';}) ;
		}

		return this;
	},
	clear: function() {
		this.$$container.empty();
		return this;
	}
});

/**
 *	Variables globales
 */
//variable stockant la ou les traces
var txtTrace = "a";
//variable stockant les messages
var txtMsg = "b";
//variable stockant le ou les échange de données
var traceEchData = "c";
// variable qui conserve l'ensemble des correspondances bibid 
var bibCorrespondance;


/**
 *	fonctions
 */
/*Permet de remplir la variable txtTrace*/

function laisseTrace(newTrace) {
	txtTrace += "\n\r" + newTrace;
} /*Permet de remplir la variable txtMsg*/

function laisseMsg(newMsg) {
	txtMsg = newMsg;
}

/*Permet de remplir la variable traceEchData*/

function traceAlert(amsg) {
	//cette fonction ne comprend pas le test relatif à xtraceType la variable n'étant pas implémenter dans notre prototype
	//amsg est aussi tracé
	laisseTrace(amsg)
	//test portant sur la longueur de la variable traceEchData 
	if (traceEchData.length > 159000) {
		if (traceEchData.length < 159400) {
			traceEchData += ". ";
		}
		return;
	}
	//MAJ de la variable traceEchData avec l'ajout du nouveau message amsg
	traceEchData += "\n\r" + amsg;
}

/*
 * Montre / Cache pop up modal
 */

function showPopUp(divID) {
	// $("#" + divID).jqm({
	// 	overlay: 10,
	// 	modal: true
	// });
	// $("#" + divID).jqmShow();
	// $("#" + divID).addClass("montrer");
}

//Permet de construire correctement un élément svg dans la page html

function makeSVG(tag, attrs) {
	var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
	for (var k in attrs) {
		el.setAttribute(k, attrs[k]);
	}
	return el;
}

//Récupère le code hexadecimal de la couleur à partir du code décimal

function getHexadecimalColor(str) {
	if (typeof str == 'undefined') {
		str = 0;
	}
	var hex = Number(str).toString(16);
	hex = "#000000".substr(0, 7 - hex.length) + hex;
	return hex.toUpperCase();
}

function getBibName(bibid) {
	var json = "";
	var response = $.ajax({
		type: 'get',
		url: libInfoRoot + '/sgx_libsinfo.txt',
		dataType: 'json',
		async: false
	});

	// status 200 = OK
	if (response.status == 200) {
		try {
			json = $.parseJSON(response.responseText);
		} catch (e) {
			// si le parse ne fonctionne pas, on renvoie une chaine vide.
			return "";
		}
	}

	// si bibCorrespondance est vide, on le remplit d'abord
	if (bibCorrespondance == null) {
		bibCorrespondance = {};
		// On parcours la liste des librairies
		for (var libNum = 0, sizeL = json.libsinfo.length; libNum < sizeL; libNum++) {
			var bibList = json.libsinfo[libNum].biblist;

			// on parcours la liste 
			for (var bibNum = 0, sizeB = bibList.length; bibNum < sizeB; bibNum++) {
				var bib = bibList[bibNum];

				bibCorrespondance[bib.bibid] = bib;
			}
		}
	}

	return (typeof bibCorrespondance[bibid] !== 'undefined' && bibCorrespondance[bibid].bibfilename !== null) ? bibCorrespondance[bibid].bibfilename.replace(/\.swf/, "") : "";
};

function parseLien(chaine) {
	var chaineParse = ""
	if (chaine.indexOf("erpfunc", 0) > -1) {} // lien vers une fonction erp //non géré
	if (chaine.indexOf("link", 0) > -1) { //lien de type URL
		var temp = chaine.replace(/.*xcode%22.*?%22(.*?)%22.*?%22xtype.*/, "$1"); //la chaine a parser se situe entre xcode et xtype
		//remplace l'encodage
		temp = temp.replace(/%3A/g, ":");
		temp = temp.replace(/%2F/g, "/");
		temp = temp.replace(/%2E/g, ".");
		chaineParse = temp;
	}
	return chaineParse;
}

function calculDegrade(alpha) {
    // l'angle de rotation est calculé par rapport au centre de la forme, on considére donc ce point comme centre de notre graphe
    // le repère est orthonormée de longueur max 50 (la fenetre graphique éMath.tant de longueur et largeur 100)
    
    var x1, x2,y1,y2 ;
    
    //traitement cas spéciaux
    var margeArrondi = Math.PI/100;
    if (alpha == 0)
    {
        x2=50;
        y2=0;
    }
    else if (alpha==Math.PI/2){
        x2=0;
        y2=50;
    }
    else if (alpha==Math.PI){
        x2=-50;
        y2=0;
    }
    else if (alpha==3*Math.PI/2){
        x2=0;
        y2=-50;
    }
    //cas normaux
    else if (alpha<Math.PI/4){
        x2=50;
        y2=50*Math.tan(alpha);
    }
    else if (alpha<Math.PI/2 - margeArrondi){
        x2=50*(Math.tan(alpha-Math.PI/4));
        y2=50;
    }
    else if (alpha<3*Math.PI/4){
        x2=50*(Math.tan(alpha-Math.PI/2))*-1;
        y2=50;
    }
    else if (alpha<Math.PI){
        x2=-50;
        y2=50*(Math.tan(alpha-3*Math.PI/4));
    }
    else if (alpha<5*Math.PI/4){
        x2=-50;
        y2=50*(Math.tan(alpha-Math.PI))*-1;
    }
    else if (alpha<3*Math.PI/2){
        x2=50*(Math.tan(alpha-5*Math.PI/4))*-1;
        y2=-50;
    }
    else if (alpha<7*Math.PI/4){
        x2=50*(Math.tan(alpha-3*Math.PI/2))*-1;
        y2=-50;
    }
    else { //alpha>315
        x2=50;
        y2=(50*Math.tan(alpha-7*Math.PI/4))*-1;
    } 
    //calcul de x1 y1 en fonction de x2, y2. x1 et y1 sont opposé par rapport à l'origine
    x1=-x2;
    y1=-y2;
    // calcul pour basculer en coordonnées grphique (origine en haut a gauche)
    x1+=50;
    y1+=50;
    x2+=50;
    y2+=50;
    return {x1:x1,y1:y1,x2:x2,y2:y2};
}