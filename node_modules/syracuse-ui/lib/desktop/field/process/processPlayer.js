"use strict";

var d3 = require("syracuse-ui/deps/d3");

var helpers = require('syracuse-core/lib/helpers');
require('syracuse-ui/lib/desktop/field/process/jquery.contextMenu');
require('syracuse-ui/deps/jqModal/jqModal');


var imagesRoot = "/syracuse-ui/themes/desktop/sage/process/images",
	libInfoRoot = "/syracuse-ui/lib/desktop/field/process";

function ProcessPlayer() {};

exports.ProcessPlayer = helpers.defineClass(ProcessPlayer, null, {
	init: function($$div, /* options,*/ fld) {
		var self = this;
		this.$$div = $$div;
		//this.options = options;
		this.uuid = $$div.attr("id");
		this.field = fld;

		var $$page = $('<div>').attr("id", "page").appendTo($$div);
		this.$$container = $$page;

		var technicPart = '<div id="fenetreTechnique" class="s-process-hidden s-process-fenetreImportExport">   \
	<div id="entetedivflottantFT"></div>    \
	<div id="DivDockToolBar" class="s-process-DivDockToolBar">    \
	<div id="menuprincipal" class="s-process-menuprincipal">    \
	<a id="titreMenuPrincipal" class="s-process-titreMenuPrincipal">Fichier</a>  \
	</div>  \
	</div>  \
	<div id="divSousMenu class="s-process-divSousMenu">  \
	<a class="sousMenuItem" id="importLink">Importer...</a> \
	<a class="sousMenuItem" id="exportLink">Exporter en texte...</a>    \
	</div>  \
	</div>';
		$(technicPart).appendTo($$div);

		// <!--pop-up "fenêtre Exporter"-->
		var exportPopup = '<div id="export" class="s-process-fenetreImportExport s-process-hidden"> \
	<div id="enteteExport" class="s-process-enteteFenetreImportExport"></div> \
	<p>Vos donn&eacute;es :</p> \
	<div>   \
	<textarea id="textAreaExport" class="s-process-textAreaImportExport"></textarea>  \
	</div>  \
	<div>   \
	<button id="btnValiderExport" class="s-process-btnFT">OK</button> \
	</div>  \
	</div>';
		$(exportPopup).appendTo($$div);

		// <!-- pop up message et traces -->
		var messagePopup = '<div id="msgEtTraces" class="s-process-hidden">   \
	<div id="enteteMsgEtTraces" class="s-process-enteteMsgEtTraces">    \
	<div id="titreMsgEtTraces" class="s-process-left"> Vos messages </div>    \
	<div id="divFermer" class="s-process-left"><img id="imageFermerMessageTrace" src="' + imagesRoot + '/fermer.png" width="20" height="20" alt="fermer"> </div> \
	<div style="clear:both"></div>  \
	</div>  \
	<div>   \
	<div id="divTextAreaMsgEtTraces" class="s-process-left">  \
	<textarea  id="textAreaMsgEtTraces" class="s-process-textAreaMsgEtTraces" readonly="readonly"></textarea> \
	</div>  \
	<div id="actions" class="s-process-left"> \
	<div class="s-process-divAction" id="btnMsg"> Messages </div> \
	<div class="s-process-divAction" id="btnDetail"> Détail </div>    \
	<div class="s-process-divAction" id="btnTrace"> Trace </div>  \
	<div class="s-process-divAction" id="btnCopier"> Copier </div>    \
	</div>  \
	<div style="clear:both"></div>  \
	</div>  \
	</div>';
		$(messagePopup).appendTo($$div);

		// <!-- pop up echange de donnees -->
		var exchangePopup = '<div id="divCadreEchangesDeDonnees" class="s-process-hidden s-process-divCadreEchangesDeDonnees">    \
	<div id="divContenuEchangesDeDonnees" class="s-process-divContenuEchangesDeDonnees">  \
	<textarea  id="textAreaContenuEchangesDeDonnees" class="s-process-textAreaContenuEchangesDeDonnees" readonly="readonly"></textarea>    \
	</div>  \
	</div>';
		$(exchangePopup).appendTo($$div);

		var contextMenu = '<ul id="myMenu" class="s-process-contextMenu"> \
	<li ><a href="#echangeDonnee">Echanges de donnees</a></li>  \
	<li class="cut"><a href="#messageEtTrace">Messages et trace</a></li>    \
	<li class="copy separator"><a href="#fenetreTechnique">Montrer/cacher fenetre technique</a></li>    \
	</ul>';
		$(contextMenu).appendTo($$div);

		/*******************************************************
		 * Chargement du contenu de la page en JSon dans le pop up "exporter"
		 *******************************************************/
		$("#exportLink").click(function(event) {
			showPopUp('export');
			$('#textAreaExport').text(options.process && options.process.getJson());
			$('#textAreaExport').select();
		});

		/*******************************************************
		 * Affichage du popup "import"
		 *******************************************************/
        $('#importLink').click(function (event)  {
			showPopUp('import');
		});

		/*******************************************************
		 * Fermeture de la fenêtre message et trace avec un click sur l'image de fermeture
		 *******************************************************/
		$("#imageFermerMessageTrace").hover(function() {
			$(this).attr('src', imagesRoot + '/fermerHover.png');
		}, function() {
			$(this).attr('src', imagesRoot + '/fermer.png');
		}).click(function() {
			$("#msgEtTraces").toggle();
		});

		/*******************************************************
		 * Gestion du menu de la fenetre technique
		 *******************************************************/
		$("#menuprincipal").click(function(event) {

			if ($("#menuprincipal").hasClass('orangebackground')) {
				$("#menuprincipal").removeClass('orangebackground');
			} else {
				$("#menuprincipal").addClass('orangebackground');
				$("#divSousMenu").toggle();

				//empeche le declenchement du listener qui suit
				event.stopPropagation();

				//Ajout d'un listener de click sur toute la page qui ferme le menu      
				$('#body').bind('click', function() {
					$("#menuprincipal").removeClass('orangebackground');
					$("#divSousMenu").toggle();
					//suppression du listener une fois celui ci utilisé
					$('#body').unbind('click');
				});
			}
		});

		/*******************************************************
		 * Gestion des boutons de importer/exporter
		 *******************************************************/
		$("#btnValiderExport").click(function() {
			$('#export').jqmHide();
			$('#export').removeClass('montrer');
		});
		$("#btnAnnulerImport").click(function() {
			$('#import').jqmHide();
			$('#import').removeClass('montrer');
		});
		$('textarea').disableContextMenu();

		/*******************************************************
		 * Gestion de l'import quand on entre le json à la main
		 *******************************************************/
		$('#btnValiderImport').click(function() {
			// on recupere le json … 
			var jsonTxt = $('#textAreaImport').val();
			if (jsonTxt !== "") {
				// … et on le charge
				self.options.process && self.options.process.loadJson(jsonTxt);
				// on verifie ensuite que le json est importé, pour vérifier qu'il n'avait pas d'erreur.
				// donc getJson() doit renvoyé le même contenu que l'import
				self.options.process && self.options.process.loadJson(jsonTxt);
                if (self.options.process && (self.options.process.getJson() == jsonTxt))  {

					// et on affiche tous les nouveaux
					self.clear().show();
					// sageInitPage($.sageJSON.getPageInfo()).sageDisplayPlayer($.sageJSON.getFormes());
					// on vide le textarea 
					$('#textAreaImport').val('');

					// et on ferme la fenêtre     
					$('#import').jqmHide();
					$('#import').removeClass('montrer');

				} else {

					// si ça ne correspond pas, on affiche un petit popup
					alert("Le JSON importé n'est pas valide");
				}
			}
		});

		/*******************************************************
		 * Fenetre echange de données
		 *******************************************************/
		//Cacher la fenetre echange de donnée avec un clic sur la bordure
		$("#divContenuEchangesDeDonnees").click(function(event) {
			event.stopPropagation();
		});
		$("#divCadreEchangesDeDonnees").click(function() {
			$("#divCadreEchangesDeDonnees").hide();
		});

		/*******************************************************
		 * Definition des draggable pour les popups
		 *******************************************************/
		$("#msgEtTraces").draggable({
			containment: "body",
			scroll: false,
			handle: "#titreMsgEtTraces"
		});
		$("#fenetreTechnique").draggable({
			containment: "body",
			scroll: false
		});
		$("#import").draggable({
			containment: "body",
			scroll: false,
			handle: "#enteteImport"
		});
		$("#export").draggable({
			containment: "body",
			scroll: false,
			handle: "#enteteExport"
		});

		//$$page.css('height', pageInfoJson.contentSize.xheight + 'px').css('width', pageInfoJson.contentSize.xwidth + 'px').css('top', pageInfoJson.docDims.xtop).css('left', pageInfoJson.docDims.xtop);
		return this;
	},

	loadProcess: function(process) {
		this.process = process.$data;
		this.info = process.$info;
		this._loadBibMapping();
		this.$$container.css('height', this.process.contentSize.xheight + 'px').css('width', this.process.contentSize.xwidth + 'px').css('top', this.process.docDims.xtop).css('left', this.process.docDims.xtop);
	},

	_loadBibMapping: function() {
		if (this.bibMapping != null) return;
		var libsinfo = this.info && this.info.libsinfo,
			bibMapping = {};

		libsinfo && libsinfo.forEach(function(lib) {
			lib.biblist && lib.biblist.forEach(function(bib) {
				bibMapping[bib.bibid] = bib;
			});
		});

		this.bibMapping = bibMapping;
	},

	show: function() {
		
		var bibMapping = this.bibMapping;

		function getStroke(xprop) {
			return (xprop.xstrokeProps.xtype === 'none' || xprop.xstrokeProps.xtype === 'nostroke') //
			? 'none' : getHexadecimalColor(xprop.xstrokeProps.xcolor) ;
		}

		function getStrokeDashArray(xprop) {

			if (xprop.xstrokeProps.xtype === 'dottedstroke') {
				return 2 * xprop.xstrokeProps.xthickness + ',' + 2 * xprop.xstrokeProps.xthickness;
			}
			else if (xprop.xstrokeProps.xtype === 'dashedstroke') {
				return 5 * xprop.xstrokeProps.xthickness + ',' + 5 * xprop.xstrokeProps.xthickness;
			}
			else {
				return '';
			}
		}

		function getFill(xprop) {
			if (xprop.xfillProps.xtype === 'nofill') return 'none';
			else if (xprop.xfillProps.xtype === 'solidfill') return getHexadecimalColor(xprop.xfillProps.xcolor);
			else if (xprop.xfillProps.xtype === 'gradientfill') return 'url(#grad' + xprop.uniqueID + ')';

		}


		

		function setStyles(shape, xprop) {
			shape.attr('stroke', getStroke(xprop)) ;
			shape.attr('stroke-opacity', xprop.xstrokeProps.xalpha / 100) ;
			shape.attr('stroke-width', xprop.xstrokeProps.xthickness) ;
			shape.attr('stroke-dasharray', getStrokeDashArray(xprop)) ;
			shape.attr('fill', getFill(xprop));
		}

		function createShape(xprop) {
			function compare_float_func(a, b) {
				 // Elle doit retourner :
				 // -1 si a < b
				 //  0 si a = b
				 //  1 si a > b
				 return parseFloat(a) - parseFloat(b)
				}
		if (xprop.xshapeType==='apishape' || xprop.xshapeType==='beziershape'){
			if (xprop.xfillProps.xtype === 'gradientfill')
				defs+=createGradient(xprop);
		}
			if (xprop.xshadowProps.xtype === 'global')
				defs+=createShadow(xprop);

			var shape;
			var parent ;
			var markers ='';
			
			switch (xprop.xshapeType) {
			case 'apishape':

			
			var centerx, centery ,width, height;
			var xcoords = [];
			var ycoords =[] ;
		      for (var j = 0; j < 4; j++) {
		       xcoords.push(xprop.xanchors[j].x);
		      }
		      xcoords.sort(compare_float_func);
		       
		    
		      for (var i = 0; i < 4; i++) {
		       ycoords.push(xprop.xanchors[i].y);
		      }
		      ycoords.sort(compare_float_func);
                    var apirotation ;

				switch (xprop.xdrawBehaviorCode) {
				case "K_API_LINE":
				shape=$('<line>') ;

                            apirotation = Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, //
                            xprop.xanchors[2].x - xprop.xanchors[0].x);

                            /*var halfthick=xprop.xstrokeProps.xthickness/2 ;
                            if (apirotation){
                            	shape.attr("x1", xprop.xanchors[0].x -Math.cos(apirotation)*halfthick)//
                        		.attr("y1", xprop.xanchors[0].y-Math.sin(apirotation)*halfthick)//
                        		.attr("x2", xprop.xanchors[2].x +Math.cos(apirotation)*halfthick)//
                        		.attr("y2", xprop.xanchors[2].y +Math.sin(apirotation)*halfthick);
                        	}else{
                        		if (xprop.xanchors[0].x<xprop.xanchors[2].x){
                        		shape.attr("x1", xprop.xanchors[0].x-halfthick).attr("y1", xprop.xanchors[0].y)//
                        		.attr("x2", xprop.xanchors[2].x+halfthick).attr("y2", xprop.xanchors[2].y);
                        		} else {
                        			shape.attr("x1", xprop.xanchors[0].x+halfthick).attr("y1", xprop.xanchors[0].y)//
                        		.attr("x2", xprop.xanchors[2].x-halfthick).attr("y2", xprop.xanchors[2].y);
                        		}
                        	}*/
                        	shape.attr("x1", xprop.xanchors[0].x).attr("y1", xprop.xanchors[0].y)//
                        		.attr("x2", xprop.xanchors[2].x).attr("y2", xprop.xanchors[2].y);
                        	shape.attr("stroke-linecap","square") ;
				   	 
				var markertype, filled ;
				if (xprop.xstrokeProps.xstart){
					markertype = xprop.xstrokeProps.xstart.xtype;
					filled = xprop.xstrokeProps.xstart.xfilled;

					if (markertype != 'none' && markertype != 'noarrow') {
						markers+=createLineMarker(xprop,  markertype, filled, 'start',shape);
					}
				}
                         
				if (xprop.xstrokeProps.xend){
					markertype = xprop.xstrokeProps.xend.xtype;
					filled = xprop.xstrokeProps.xend.xfilled;

					if (markertype != 'none' && markertype != 'noarrow') {
					markers+=createLineMarker(xprop,markertype,filled,"end",shape) ;
                               
					}
				}
					break;
				case "K_API_RECT":
				shape=$('<rect>') ;
                            apirotation = (Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, //
				xprop.xanchors[1].x - xprop.xanchors[0].x) != 0) ;
				if (apirotation){

					centerx=xcoords[0]+(xcoords[3] - xcoords[0])/2;
		   	  centery=ycoords[0]+ (ycoords[3] - ycoords[0])/2;

		   	  width=Math.sqrt( //
		   	  	(xprop.xanchors[1].x - xprop.xanchors[0].x)* //
		   	  	(xprop.xanchors[1].x - xprop.xanchors[0].x) +//
		   	  	(xprop.xanchors[1].y - xprop.xanchors[0].y)* //
		   	  	(xprop.xanchors[1].y - xprop.xanchors[0].y)//
		   	   );
		   	  height=Math.sqrt(//
				(xprop.xanchors[3].x - xprop.xanchors[0].x)* //
		   	  	(xprop.xanchors[3].x - xprop.xanchors[0].x) +//
		   	  	(xprop.xanchors[3].y - xprop.xanchors[0].y)* //
		   	  	(xprop.xanchors[3].y - xprop.xanchors[0].y) //
		   	  	) ;
					
				shape.attr("x",centerx-width/2).attr("y",centery-height/2)//
				.attr("width",width).attr("height",height) ;
				   	 
                            } else {

				shape.attr("x",xprop.xanchors[0].x).attr("y",xprop.xanchors[0].y)//
				.attr("width",Math.abs(xprop.xanchors[1].x - xprop.xanchors[0].x))//
				.attr("height",Math.abs(xprop.xanchors[3].y - xprop.xanchors[0].y)) ;
				}
					break;
				case "K_API_ELLIPSE":
                             apirotation = (Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, //
				xprop.xanchors[1].x - xprop.xanchors[3].x) != 0) ;
				shape=$('<ellipse>') ;

				if (apirotation){
					var rx=Math.sqrt((xprop.xanchors[2].x-xprop.xanchors[0].x)*(xprop.xanchors[2].x-xprop.xanchors[0].x)//
                                + (xprop.xanchors[2].y - xprop.xanchors[0].y) * (xprop.xanchors[2].y - xprop.xanchors[0].y)) / 2;

					var ry=Math.sqrt((xprop.xanchors[1].x-xprop.xanchors[3].x)*(xprop.xanchors[1].x-xprop.xanchors[3].x)//
                                +(xprop.xanchors[1].y - xprop.xanchors[3].y) * (xprop.xanchors[1].y - xprop.xanchors[3].y)) / 2;

					var cx= xcoords[0]+(xcoords[3]-xcoords[0])/2 ;
					var cy=ycoords[0]+(ycoords[3]-ycoords[0])/2 ;
				shape.attr('cx',cx).attr('cy',cy).attr('rx',rx).attr('ry',ry) ;
				}else{
				shape.attr('cx',xprop.xanchors[0].x + Math.abs(xprop.xanchors[1].x - xprop.xanchors[0].x))//
				.attr('cy',xprop.xanchors[0].y)//
				.attr('rx',Math.abs(xprop.xanchors[2].x - xprop.xanchors[0].x) / 2)//
				.attr('ry',Math.abs(xprop.xanchors[1].y - xprop.xanchors[3].y) / 2) ;
				}
					break;
				};
				
				
				//shape.datum(xprop) ;
				break;
			case 'beziershape':
				//var path=svgplot.createPath();
				var xanchors = xprop.xanchors;
				var a = xanchors[0];
				if (!a) return; // we get this in fill test
				//path=path.move(a.x,a.y) ;
				var d = 'M ' + a.x + ' ' + a.y;
				var len = xanchors.length + (xprop.xclosed ? 1 : 0);
				// control points are weaker than in flash - so I move them away by a factor of f
				// value is experimental.
				var f = 1.3;
				for (var i = 1; i < len; i++) {
					var pa = a;
					a = xanchors[i % xanchors.length];
					var c2x = pa.x + f * (pa.c2x - pa.x);
					var c2y = pa.y + f * (pa.c2y - pa.y);
					var c1x = a.x + f * (a.c1x - a.x);
					var c1y = a.y + f * (a.c1y - a.y);
					d += ' C ' + c2x + ' ' + c2y + ' ' + c1x + ' ' + c1y + ' ' + a.x + ' ' + a.y;
				//path=path.curveC(c2x, c2y, c1x, c1y, a.x, a.y); 
				}
				if (xprop.xclosed) d+='z' ;

				/*shape=svgplot.path(parent,path,{stroke: getStroke(xprop), strokeWidth: xprop.xstrokeProps.xthickness,//
						style: "stroke-dasharray: "+getStrokeDashArray(xprop) //
						+"; stroke-opacity : "+xprop.xstrokeProps.xalpha / 100, //
						fill: getFill(xprop) }) ;*/
				shape=$('<path>').attr('d',d) ;
				//shape.datum(xprop);
				break;
			case 'clipshape':
			case 'fileshape':
				//var g = d3.select(el);
				//shape = g.append('image'); // d3.select($$container[0]).selectAll("img") ;

				var width=Math.sqrt(//
				(xprop.xanchors[1].x-xprop.xanchors[0].x)*(xprop.xanchors[1].x-xprop.xanchors[0].x) //
					+(xprop.xanchors[1].y-xprop.xanchors[0].y)*(xprop.xanchors[1].y-xprop.xanchors[0].y));
				var height=Math.sqrt(//
					(xprop.xanchors[2].x-xprop.xanchors[1].x)*(xprop.xanchors[2].x-xprop.xanchors[1].x) //
					+(xprop.xanchors[2].y-xprop.xanchors[1].y)*(xprop.xanchors[2].y-xprop.xanchors[1].y)) ;

				shape= $('<image>') ;
				/*shape.attr('x',xprop.xcenter.x - xprop.xsize.xwidth/ 2);
				shape.attr('y',xprop.xcenter.y - xprop.xsize.xheight/ 2);
				shape.attr('width', xprop.xsize.xwidth);
				shape.attr('height',  xprop.xsize.xheight);*/
				
				shape.attr('x',xprop.xcenter.x - width/ 2);
				shape.attr('y',xprop.xcenter.y - height/ 2);
				shape.attr('width', width);
				shape.attr('height',  height);
				
				shape.attr('preserveAspectRatio','none') ;
				shape.attr('id', xprop.uniqueID);
				//shape.style('position', 'absolute');
				shape.attr('z-index', xprop.xlevel);
				/*shape.style('filter', "alpha(opacity=" + xprop.alpha + ")");
				shape.style('-moz-opacity', xprop.alpha + "/100");
				shape.style('-khtml-opacity', xprop.alpha + "/100");
				shape.style('opacity', xprop.alpha + "/100");*/

				shape.attr("xlink:href", getHRef(xprop));

				
				break;
			}
			
			if (xprop.xshapeType==='apishape' || xprop.xshapeType==='beziershape'){
				setStyles(shape, xprop);
			}
			if (xprop.xactionProps.trig)
				xprop.xactionProps.trig.forEach(function(value,index,array){
					shape.addClass('trigger'+value) ;
				});
			if (xprop.xactionProps.targ)
				xprop.xactionProps.targ.forEach(function(value,index,array){
					shape.addClass('target'+value) ;
				});
			if (xprop.xshadowProps.xtype=='global')
				shape.attr('filter',"url(#shadow"+xprop.uniqueID+")");
			return markers+shape[0].outerHTML ;
			}

		function getRotate(xprop) {
			var centerx,centery ;
			if (xprop.xshapeType==='clipshape' || xprop.xshapeType==='fileshape'){
				centerx=xprop.xcenter.x ; 
				centery=xprop.xcenter.y ;
			}else if (xprop.xshapeType==='apishape'){
				var xcoords = [];
					var ycoords =[] ;
				      for (var j = 0; j < 4; j++) {
				       xcoords.push(xprop.xanchors[j].x);
				      }
				      xcoords.sort(compare_float_func);
				       centerx=xcoords[0]+(xcoords[3] - xcoords[0])/2;
				    
				      for (var i = 0; i < 4; i++) {
				       ycoords.push(xprop.xanchors[i].y);
				      }
				      ycoords.sort(compare_float_func);
				      
				   	  centery=ycoords[0]+ (ycoords[3] - ycoords[0])/2;
			}
            
			var anglerad ;
			if (xprop.xshapeType=="apishape" && xprop.xdrawBehaviorCode=="K_API_ELLIPSE")
				anglerad = Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, xprop.xanchors[2].x - xprop.xanchors[0].x);
            else if (xprop.xshapeType == "apishape" && xprop.xdrawBehaviorCode == "K_API_LINE"){
            	/*var centerRotation=Math.atan2(xprop.xanchors[1].y-xprop.xanchors[0].y,//
            		xprop.xanchors[1].x-xprop.xanchors[0].x)  ;
				var originRotation=Math.atan2(xprop.xanchors[2].y-xprop.xanchors[0].y,//
					xprop.xanchors[2].x-xprop.xanchors[0].x)-centerRotation ;
						

				if (centerRotation){
					anglerad =centerRotation ;
				}
				else if (originRotation){
					anglerad =originRotation ;
					centerx= xprop.xanchors[0].x;
					centery= xprop.xanchors[0].y;
				}*/
				return"" ;

            }else 
				anglerad = Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, xprop.xanchors[1].x - xprop.xanchors[0].x);
			var angle = 180 * anglerad / Math.PI;


            var result = 'rotate(' + angle + ',' + centerx + ',' + centery+') ';
			return result;
		}

		function getHRef(xprop) {
			var bib = getBib(xprop.bibid),
				src = '/syracuse-ui/themes/desktop/sage/process/images/' + bib.famSubpath + bib.catSubpath + bib.name + '/' + xprop.eltid;
            if (xprop.xshapeType == 'clipshape') src += '.svg';
			return src;
		}

		function getBib(bibid) {
			var bib = bibMapping[bibid];
			return {
				name: (bib && bib.type == 'swflib' && bib.bibfilename && bib.bibfilename.replace(/\.swf/, "")) || "",
				catSubpath: (bib && bib.catsubpath) || "",
				famSubpath: (bib && bib.familysubpath) || ""
			};
		}

		





function createAction(action, index, array){
	var trigger=svgplot.find('.trigger'+action.id) ;
	trigger.attr('pointer-events','visible') ;
	switch(action.type){
	case 'shotip' :
		svgplot.find('.target'+action.id).hide();
		trigger.mouseover(function(){
			svgplot.find('.target'+action.id).show();
		})//
		.mouseleave(function(){
			svgplot.find('.target'+action.id).hide();
		});
		break ;
	case 'sho' :
		svgplot.find('.target'+action.id).hide();
		trigger.click(function(){
			svgplot.find('.target'+action.id).show();
		});
		break ;
		case 'hide' :
		

		trigger.click(function(){
			svgplot.find('.target'+action.id).hide();
		});
		break ; 
		case 'shohid' :
			trigger.click(function(){
			var target=svgplot.find('.target'+action.id ) ;
			var hidden=(target.attr('display') =='none');
                        if (hidden) target.attr('display', 'block');
                        else target.attr('display', 'none');
			//toggle();
			/*var toshow=svgplot.find('.target'+action.id +':hidden').show()  ;
			var tohide=svgplot.find('.target'+action.id +':visible').hide() ;
			var ishidden=tohide.is(':hidden') ;
			var tt=tohide.attr("display");
			var ttt=6 ;*/
		});
			//svgplot.find('.target'+action.id).hide();
		break ;
	}

}

        function manageLink(index, el) {
        var str = $(el).attr('href');
        //var parsedlink = parseLink(str) ;
        var children=$(el).contents();
        /*var textchildren=children.filter(function(index){
        	if (children[index].nodeType!= 3)
        		return false ;
        });
        
        while (textchildren.length===0){
        	children=children.contents();
        	textchildren=children.filter(function(index){
        	if (children[index].nodeType== 3)
        		return true ;
        	else 
        		return false ;
        }) ;



        }*/

       $(el).parent().append(children) ;
       $(el).remove() ;
       children.bind('click',function(e){
        	alert ("haha") ;
        var obj= {} ;


         
    if (str.indexOf("erpfunc", 0) > -1) {
    	obj.$type = "application/json;vnd.sage=syracuse";
           // obj.$title = xprop.xlinkProps.xlabel;
           // obj.$url = "/trans/x3/erp/SUPERV/$sessions?f=" + xprop.xlinkProps.xcode + "/2//M/" + xprop.xlinkProps.xparam2;
            obj.$method = "POST";

    } // lien vers une fonction erp //non géré
    if (str.indexOf("link", 0) > -1) { //lien de type URL
        var temp = str.replace(/.*xcode%22.*?%22(.*?)%22.*?%22xtype.*/, "$1"); //la chaine a parser se situe entre xcode et xtype
        //remplace l'encodage
        temp = temp.replace(/%3A/g, ":");
        temp = temp.replace(/%2F/g, "/");
        temp = temp.replace(/%2E/g, ".");

        obj.$type = "application/json;vnd.sage=syracuse";
        obj.$url = temp;
    	}
        document.controller.openPage(self.field.boxParent.getArticle(), obj , null);

        });

       //attr('class','link') ; 
        
        
        
    }



		var self = this,
			$$container = this.$$container,
			layers = self.process && self.process.layersArr;
		var actions=(self.process.acts.a)? self.process.acts.a :[] ;
		
		var result="" ;
		var defs='<defs>';
	
    for (var gn = 0, sizeG = layers.length; gn < sizeG; gn++) {
			var group = layers[gn];

		
		for (var i=0 ;i<group.xpropsArr.length; i++ ){
		
		var shapedescr=createShape(group.xpropsArr[i]) ;
		var rotation ;
		if (group.xpropsArr[i].xshapeType=="apishape" && group.xpropsArr[i].xdrawBehaviorCode=="K_API_ELLIPSE")
			rotation=(Math.atan2(group.xpropsArr[i].xanchors[2].y - group.xpropsArr[i].xanchors[0].y, //
				group.xpropsArr[i].xanchors[2].x - group.xpropsArr[i].xanchors[0].x) != 0) ;
                }else if(group.xpropsArr[i].xshapeType == "clipshape"  //
                 || group.xpropsArr[i].xshapeType == "apishape" //
                 && group.xpropsArr[i].xdrawBehaviorCode != "K_API_LINE"){
			rotation=(Math.atan2(group.xpropsArr[i].xanchors[1].y - group.xpropsArr[i].xanchors[0].y, //
				group.xpropsArr[i].xanchors[1].x - group.xpropsArr[i].xanchors[0].x) != 0) ;
	            }
                
 		//rotation=false ;

			var ttext='';
               if (group.xpropsArr[i].xtext != "") {
               	ttext = createText(group.xpropsArr[i], rotation );
               result += ttext;
           		}
               if( rotation ) {
                    result += '<g transform="' + getRotate(group.xpropsArr[i]) + '">';

                } 
               /* if (originRotation){
                    	result += '<g transform="' + getRotate(group.xpropsArr[i]) + '">';
				}
				if (!rotation && !originRotation){
				result+='<g>' ;
                }*/


			result+=shapedescr ;
		result+='</g>';

                /*if (rotation && originRotation){
                    result += '</g>';
                }*/

}

	}
	defs+='</defs>';
	var svgplot=$('<svg width='+this.process.contentSize.xwidth //
        +
        'px height=' + this.process.contentSize.xheight + 'px >' + defs + result + '</svg>');
		$$container.append(svgplot) ;


	actions.forEach(createAction) ;
			
        var links=svgplot.find('a');
        links.each(manageLink ) ;

         


		return this;
	},

	clear: function() {
		this.$$container.empty();
		return this;
	},
	dispose: function() {
		self.field = null;
		// AJouter la method dispose dans ProcessPlayer
	}
});

/*
 * Montre / Cache pop up modal
 */

function showPopUp(divID) {
	// $("#" + divID).jqm({
	//  overlay: 10,
	//  modal: true
	// });
	// $("#" + divID).jqmShow();
	// $("#" + divID).addClass("montrer");
}

//Récupère le code hexadecimal de la couleur à partir du code décimal

function getHexadecimalColor(str) {
	if (typeof str == 'undefined') {
		str = 0;
	}
	var hex = Number(str).toString(16);
	hex = "#000000".substr(0, 7 - hex.length) + hex;
	return hex.toUpperCase();
}

function parseLink(chaine) {

	var chaineParse = ""
	if (chaine.indexOf("erpfunc", 0) > -1) {} // lien vers une fonction erp //non géré
	if (chaine.indexOf("link", 0) > -1) { //lien de type URL
		var temp = chaine.replace(/.*xcode%22.*?%22(.*?)%22.*?%22xtype.*/, "$1"); //la chaine a parser se situe entre xcode et xtype
		//remplace l'encodage
		temp = temp.replace(/%3A/g, ":");
		temp = temp.replace(/%2F/g, "/");
		temp = temp.replace(/%2E/g, ".");
		chaineParse = temp;
	}
	return chaineParse;
}

function calculDegrade(alpha) {
	// l'angle de rotation est calculé par rapport au centre de la xprop, on considére donc ce point comme centre de notre graphe
	// le repère est orthonormée de longueur max 50 (la fenetre graphique éMath.tant de longueur et largeur 100)
	var x1, x2, y1, y2;

	//traitement cas spéciaux
	var margeArrondi = Math.PI / 100;
	if (alpha == 0) {
		x2 = 50;
		y2 = 0;
	} else if (alpha == Math.PI / 2) {
		x2 = 0;
		y2 = 50;
	} else if (alpha == Math.PI) {
		x2 = -50;
		y2 = 0;
	} else if (alpha == 3 * Math.PI / 2) {
		x2 = 0;
		y2 = -50;
	}
	//cas normaux
	else if (alpha < Math.PI / 4) {
		x2 = 50;
		y2 = 50 * Math.tan(alpha);
	} else if (alpha < Math.PI / 2 - margeArrondi) {
		x2 = 50 * (Math.tan(alpha - Math.PI / 4));
		y2 = 50;
	} else if (alpha < 3 * Math.PI / 4) {
		x2 = 50 * (Math.tan(alpha - Math.PI / 2)) * -1;
		y2 = 50;
	} else if (alpha < Math.PI) {
		x2 = -50;
		y2 = 50 * (Math.tan(alpha - 3 * Math.PI / 4));
	} else if (alpha < 5 * Math.PI / 4) {
		x2 = -50;
		y2 = 50 * (Math.tan(alpha - Math.PI)) * -1;
	} else if (alpha < 3 * Math.PI / 2) {
		x2 = 50 * (Math.tan(alpha - 5 * Math.PI / 4)) * -1;
		y2 = -50;
	} else if (alpha < 7 * Math.PI / 4) {
		x2 = 50 * (Math.tan(alpha - 3 * Math.PI / 2)) * -1;
		y2 = -50;
	} else { //alpha>315
		x2 = 50;
		y2 = (50 * Math.tan(alpha - 7 * Math.PI / 4)) * -1;
	}
	//calcul de x1 y1 en fonction de x2, y2. x1 et y1 sont opposé par rapport à l'origine
	x1 = -x2;
	y1 = -y2;
	// calcul pour basculer en coordonnées grphique (origine en haut a gauche)
	x1 += 50;
	y1 += 50;
	x2 += 50;
	y2 += 50;
	return {
		x1: x1,
		y1: y1,
		x2: x2,
		y2: y2
	};
}




function constructURL(xprop) {
	switch (xprop.xlinkProps.xtype) {
	case 'erpfunc':
		var url = "/trans/x3/erp/SUPERV/$sessions?f=" + xprop.xlinkProps.xcode + "/2//M/" + xprop.xlinkProps.xparam2;
		return url;

	case 'url':
		return xprop.xlinkProps.xcode;
	}
}

function createText(xprop ) {
	function replaceFont(el){
	
		var size=$(el).attr('size')? 'font-size:'+$(el).attr('size')+'px;':'';
		var face=$(el).attr('face')? 'font-family:'+$(el).attr('face')+';' : '';
		var color=$(el).attr('color')? 'color:' +$(el).attr('color') +';' : '';
		
		//$(el).removeAttr('size');
		//$(el).wrap($('<span style="font-size:'+size+'px">')) ;
		$(el).replaceWith('<span style="'+size+face+color+'">'+$(el).html()+'</span>') ;
	}
	function replaceParagraph(index,el ){
		var alignement=$(el).attr('align');
		var textformat=$(el).parents().filter('textformat') ;
        if (index == 0 || textformat.length == 0) $(el).replaceWith('<div style="text-align: ' + alignement + ';">' + $(el).html() + '</div>');

    }

   


    
    function getBoundingBox(xprop) {
        var bb = {};
        switch (xprop.xshapeType) {
            case 'apishape':


                var centerx, centery, width, height;
                var xcoords = [];
                var ycoords = [];
                for (var j = 0; j < 4; j++) {
                    xcoords.push(xprop.xanchors[j].x);
                }
                xcoords.sort(compare_float_func);


                for (var i = 0; i < 4; i++) {
                    ycoords.push(xprop.xanchors[i].y);
                }
                ycoords.sort(compare_float_func);

                switch (xprop.xdrawBehaviorCode) {
                    case "K_API_RECT":
                        var centerx, centery, width, height;
                        centerx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;
                        centery = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;

                        width = Math.sqrt( //
                        (xprop.xanchors[1].x - xprop.xanchors[0].x) * //
                        (xprop.xanchors[1].x - xprop.xanchors[0].x) + //
                        (xprop.xanchors[1].y - xprop.xanchors[0].y) * //
                        (xprop.xanchors[1].y - xprop.xanchors[0].y) //
                        );
                        height = Math.sqrt( //
                        (xprop.xanchors[3].x - xprop.xanchors[0].x) * //
                        (xprop.xanchors[3].x - xprop.xanchors[0].x) + //
                        (xprop.xanchors[3].y - xprop.xanchors[0].y) * //
                        (xprop.xanchors[3].y - xprop.xanchors[0].y) //
                        );
                        bb.left = centerx - width / 2;
                        bb.top = centery - height / 2;
                        bb.width = width;
                        break;
                    case "K_API_ELLIPSE":
                        var rx = Math.sqrt((xprop.xanchors[2].x - xprop.xanchors[0].x) * (xprop.xanchors[2].x - xprop.xanchors[0].x) //
                        +
                        (xprop.xanchors[2].y - xprop.xanchors[0].y) * (xprop.xanchors[2].y - xprop.xanchors[0].y)) / 2;

                        var ry = Math.sqrt((xprop.xanchors[1].x - xprop.xanchors[3].x) * (xprop.xanchors[1].x - xprop.xanchors[3].x) //
                        +
                        (xprop.xanchors[1].y - xprop.xanchors[3].y) * (xprop.xanchors[1].y - xprop.xanchors[3].y)) / 2;

                        var cx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;
                        var cy = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;


                        bb.left = cx - rx;
                        bb.top = cy - ry;
                        bb.width = rx;
                        break;
                }


	}
        return bb;
    }


    var foreignobj = $('<foreignObject>');

    //if (!rotated) {

        foreignobj.attr('x', xprop.xcaptionPos.xleft + 'px').attr('y', xprop.xcaptionPos.xtop + 'px') //
	.attr('width',xprop.xcaptionSize.xwidth - xprop.xtextFormat.rightMargin - xprop.xtextFormat.leftMargin + 'px')//
        .attr('height', xprop.xcaptionSize.xheight);
    /*} else {
        var box = getBoundingBox(xprop);
        foreignobj.attr('x', box.left + 'px').attr('y', box.top + 'px') //
        .attr('width', box.width - xprop.xtextFormat.rightMargin - xprop.xtextFormat.leftMargin + 'px') //
        .attr('height', '100%'  );
       
        
	
    }*/
	var body=$('<body>').attr('xmlns',"http://www.w3.org/1999/xhtml") ;
	var shadow='';
    if (xprop.xshadowProps.xtype === 'global') shadow = 'text-shadow: silver 5px 5px 3px;';

	var stdiv="<div style='width:100%;margin-left:"+xprop.xtextFormat.leftMargin //
    +
    "px; margin-right:" + xprop.xtextFormat.rightMargin + "px;" + shadow + "vertical-align:"+xprop.xcaptionProps.xvertAlignMode+";'>";

 //foreignobj.attr('style', 'vertical-align:' + xprop.xcaptionProps.xvertAlignMode);
	
	var textobj=$(stdiv+xprop.xtext+"</div>") ;

     //var links = textobj.find('a');
    //links.each(manageLink );

	var fonts = textobj.find('font'); //find('font[size]');
	var i;
	for (i=fonts.length;i>0;i--)
		replaceFont(fonts[i-1]) ;
	
	var paragraphs = textobj.find('p');
	paragraphs.each(replaceParagraph);

	body.html(textobj[0].outerHTML) ;
	body.appendTo(foreignobj);
	
	return foreignobj[0].outerHTML ;	
}



function compare_float_func(a, b) {
	return parseFloat(a) - parseFloat(b)
}

function constructLinksObj(xprop) {
	//d.$field.$prototype.$links.$default
	var obj = {};
	switch (xprop.xlinkProps.xtype) {

	case 'erpfunc':
/*var url="/trans/x3/erp/SUPERV/$sessions?f="+xprop.xlinkProps.xcode+"/2//M/"+xprop.xlinkProps.xparam2 ;
return  url ;*/
		obj.$type = "application/json;vnd.sage=syracuse";
		obj.$title = xprop.xlinkProps.xlabel;
		obj.$url = "/trans/x3/erp/SUPERV/$sessions?f=" + xprop.xlinkProps.xcode + "/2//M/" + xprop.xlinkProps.xparam2;
		obj.$method = "POST";
		//"$url": "{$baseUrl}/{$pluralType}('{$key}')?representation={$singularType}.$details&role={$role}"
		return obj;
	case 'url':
		obj.$type = "application/json;vnd.sage=syracuse";
		obj.$url = xprop.xlinkProps.xcode;
		return obj;
	}
}



function appendLineMarkers(xprop, parent) {
	var markertype, filled;
	if (xprop.xstrokeProps.xstart) {
		markertype = xprop.xstrokeProps.xstart.xtype;
		filled = xprop.xstrokeProps.xstart.xfilled;

		if (markertype != 'none' && markertype != 'noarrow') {
			appendLineMarker(xprop, parent, markertype, filled, 'start');
		}
	}

	if (xprop.xstrokeProps.xend) {
		markertype = xprop.xstrokeProps.xend.xtype;
		filled = xprop.xstrokeProps.xend.xfilled;

		if (markertype != 'none' && markertype != 'noarrow') {
			appendLineMarker(xprop, parent, markertype, filled, 'end');
		}
	}

}

function updateLine(xprop,line,markertype, startend) {
	if( markertype == 'none' || markertype == 'noarrow')
		return ;
	var spreadfactor = 0.5;
	var sz = 2 * xprop.xstrokeProps.xthickness + 11;
	var point1x, point1y, point3x, point3y ;
	var x1, x2, y1, y2, angle;
	var endx, endy ;
	
	x1 = xprop.xanchors[0].x;
	x2 = xprop.xanchors[2].x;
	y1 = xprop.xanchors[0].y;
	y2 = xprop.xanchors[2].y;
	var angle = Math.atan2(y2 - y1, x2 - x1);
	switch (markertype) {
	case 'arr1':
	case 'arr2':
	case 'diamond1':
		if (startend == 'end') {
			if (markertype == 'arr1' || markertype == 'arr2') {
				point1x = x2 - Math.cos(angle + spreadfactor) * sz;
				point1y = y2 - Math.sin(angle + spreadfactor) * sz;
				point3x = x2 - Math.cos(angle - spreadfactor) * sz;
				point3y = y2 - Math.sin(angle - spreadfactor) * sz;
			}

			if (markertype == 'arr1') {
				endx = (point1x + point3x) / 2;
				endy = (point1y + point3y) / 2;
			} else if (markertype == 'arr2') {
				endx = x2 - Math.cos(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
				endy = y2 - Math.sin(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
			} else if (markertype == 'diamond1') {
				endx = x2 - Math.cos(angle) * sz / 2;
				endy = y2 - Math.sin(angle) * sz / 2;
			}
			line.attr('x2', endx).attr('y2', endy);

		} else if (startend == 'start') {
			if (markertype == 'arr1' || markertype == 'arr2') {
				point1x = x1 + Math.cos(angle + spreadfactor) * sz;
				point1y = y1 + Math.sin(angle + spreadfactor) * sz;
				point3x = x1 + Math.cos(angle - spreadfactor) * sz;
				point3y = y1 + Math.sin(angle - spreadfactor) * sz;
				
				if (markertype == 'arr1') {
					endx = Math.round((point1x + point3x) / 2);
					endy = Math.round((point1y + point3y) / 2);
				} else if (markertype == 'arr2') {
					endx = x1 + (Math.cos(angle) * xprop.xstrokeProps.xthickness / 2);
					endy = y1 + (Math.sin(angle) * xprop.xstrokeProps.xthickness / 2);
				}
			} else if (markertype == 'diamond1') {
				endx = x1 + Math.cos(angle) * sz / 2;
				endy = y1 + Math.sin(angle) * sz / 2;
			}
			line.attr('x1', endx).attr('y1', endy);
		}
		break ;
 	case 'disc1':
		var r = xprop.xstrokeProps.xthickness + 3;
		if (startend == 'end') {
				endx = x2 - Math.cos(angle) * r * 2;
				endy = y2 - Math.sin(angle) * r * 2;
				line.attr('x2', endx).attr('y2', endy);
            } else if (startend == 'start') {
				endx = x1 + Math.cos(angle) * r * 2;
				endy = y1 + Math.sin(angle) * r * 2;
				line.attr('x1', endx).attr('y1', endy);
			}
	}

}


function createLineMarker(xprop, markertype, filled, startend,line) {
	var marker;
	var sz = 2 * xprop.xstrokeProps.xthickness + 11;
	var x1, x2, y1, y2, angle, anglePoint;


	x1 = xprop.xanchors[0].x;
	x2 = xprop.xanchors[2].x;
	y1 = xprop.xanchors[0].y;
	y2 = xprop.xanchors[2].y;

	angle = Math.atan2(y2 - y1, x2 - x1);
	anglePoint = Math.PI / 2 - angle;
	switch (markertype) {
	case 'arr1':
	case 'arr2':
	case 'diamond1':

		var spreadfactor = 0.5;
		var point1x, point1y, point2x, point2y, point3x, point3y, point4x, point4y, endx, endy;
		var centerx, centery;
		var marker ;
            var halfthickness =xprop.xstrokeProps.xthickness / 2 ;
		if (startend == 'end') {
			if (markertype == 'arr1' || markertype == 'arr2') {
				point1x = x2 - Math.cos(angle + spreadfactor) * sz;
				point1y = y2 - Math.sin(angle + spreadfactor) * sz;
				point3x = x2 - Math.cos(angle - spreadfactor) * sz;
				point3y = y2 - Math.sin(angle - spreadfactor) * sz;
				point2x = x2;
				point2y = y2;

				if (markertype == 'arr1') {
                        endx = (point1x + point3x) / 2;
                        endy = (point1y + point3y) / 2;
				} else if (markertype == 'arr2') {
                        endx = x2 - Math.cos(angle ) * halfthickness ;
                        endy = y2 - Math.sin(angle ) * halfthickness ;

				}

			} else if (markertype == 'diamond1') {
				centerx = x2 - Math.cos(angle) * sz / 2;
				centery = y2 - Math.sin(angle) * sz / 2;
				point1x = centerx + Math.cos(anglePoint) * sz / 2;
				point1y = centery - Math.sin(anglePoint) * sz / 2;
				point2x = x2 - Math.cos(angle) * sz;
				point2y = y2 - Math.sin(angle) * sz;
				point3x = centerx - Math.cos(anglePoint) * sz / 2;
				point3y = centery + Math.sin(anglePoint) * sz / 2;
				point4x = x2;
				point4y = y2;
				endx = centerx;
				endy = centery;

			}
               
				line.attr('x2', endx).attr('y2', endy);
               
				
		} else if (startend == 'start') {
			if (markertype == 'arr1' || markertype == 'arr2') {
				point1x = x1 + Math.cos(angle + spreadfactor) * sz;
				point1y = y1 + Math.sin(angle + spreadfactor) * sz;
				point3x = x1 + Math.cos(angle - spreadfactor) * sz;
				point3y = y1 + Math.sin(angle - spreadfactor) * sz;
				point2x = x1;
				point2y = y1;
				if (markertype == 'arr1') {
                        endx = (point1x + point3x) / 2;
                        endy = (point1y + point3y) / 2;
				} else if (markertype == 'arr2') {
                        endx = x1 + (Math.cos(angle) * halfthickness);
                        endy = y1 + (Math.sin(angle) * halfthickness);
				}
			} else if (markertype == 'diamond1') {

				centerx = x1 + Math.cos(angle) * sz / 2;
				centery = y1 + Math.sin(angle) * sz / 2;
				point1x = centerx - Math.cos(anglePoint) * sz / 2;
				point1y = centery + Math.sin(anglePoint) * sz / 2;
				point2x = x1 + Math.cos(angle) * sz;
				point2y = y1 + Math.sin(angle) * sz;
				point3x = centerx + Math.cos(anglePoint) * sz / 2;
				point3y = centery - Math.sin(anglePoint) * sz / 2;
				point4x = x1;
				point4y = y1;
				endx = centerx;
				endy = centery;
			}

			line.attr('x1', endx).attr('y1', endy);

		}


		marker = $('<path>').attr('d', function() {
			var pathdescr = 'M ' + point1x + ' ' + point1y + ' L ' + point2x + ' ' + point2y + ' L ' + point3x + ' ' + point3y;
			if (markertype == 'diamond1') pathdescr += ' L ' + point4x + ' ' + point4y;
			if (markertype == 'arr1' || markertype == 'diamond1') pathdescr += ' z';

			return pathdescr;
		});

		marker.attr('stroke', function() {
			return getHexadecimalColor(xprop.xstrokeProps.xcolor)
		});
		marker.attr('stroke-width', function() {
                if (markertype == 'arr2') 
                	return xprop.xstrokeProps.xthickness;
			else return 1;
		});
            if (markertype == 'arr2') {
            	marker.attr('stroke-linecap', 'round');
            	marker.attr('stroke-linejoin', 'round');
            	
            }

            
            marker.attr('stroke-opacity', xprop.xstrokeProps.xalpha / 100);

            
            

        	
		marker.attr('fill', function() {
            	if (markertype == 'diamond1' || markertype =='arr1'){
                if (filled) 
                	return getHexadecimalColor(xprop.xstrokeProps.xcolor);
                else 
                	return '#FFFFFF';
                }
			else return 'none';
		});

		break;

	case 'disc1':

		var r, cx, cy;


		r = xprop.xstrokeProps.xthickness + 3;
		if (startend == 'end') {
			cx = x2 - Math.cos(angle) * r;
			cy = y2 - Math.sin(angle) * r;
			endx = x2 - Math.cos(angle) * r * 2;
			endy = y2 - Math.sin(angle) * r * 2;
			//d3.select(parent).select('line').attr('x2', endx).attr('y2', endy);
			line.attr('x2', endx).attr('y2', endy);
		} else if (startend == 'start') {
			cx = x1 + Math.cos(angle) * r;
			cy = y1 + Math.sin(angle) * r;
			endx = x1 + Math.cos(angle) * r * 2;
			endy = y1 + Math.sin(angle) * r * 2;
			//d3.select(parent).select('line').attr('x1', endx).attr('y1', endy);
			line.attr('x1', endx).attr('y1', endy);
		}
		marker = $('<circle>').attr('cx', cx).attr('cy', cy).attr('r', r);
		marker.attr('stroke', function() {
			return getHexadecimalColor(xprop.xstrokeProps.xcolor)
		});
		marker.attr('fill', function() {
			if (filled) return getHexadecimalColor(xprop.xstrokeProps.xcolor);
                else return '#FFFFFF';
		});

		break;
	}
	return marker[0].outerHTML ;

}


function createGradient(xprop) {
	function stops(){
		var stopset="";
		
		for (var j=0;j<xprop.xfillProps.xgcolors.length;j++){
			var stop=$('<stop>').attr('offset',xprop.xfillProps.xgratios[j] / 245.82 * 100 + '%');
			stop.attr('style','stop-color:'+getHexadecimalColor(xprop.xfillProps.xgcolors[j]) //
            +
            '; stop-opacity:' + xprop.xfillProps.xgalphas[j] / 100);
			stopset+=stop[0].outerHTML ;
		}
		return stopset ;
	}
	
		var grad ;
		var res ;
				switch (xprop.xfillProps.xgtype) {
				case 'linear':
					var tabCoord = calculDegrade(xprop.xfillProps.xgrotation);
					 grad =  $('<lineargradient>').attr('id','grad' + xprop.uniqueID)//
					.attr('x1',tabCoord.x1 + '%')//
					.attr('y1',tabCoord.y1 + '%')//
					.attr('x2',tabCoord.x2 + '%') //
					.attr('y2',tabCoord.y2 + '%') ;
					res=grad[0].outerHTML;
					var st=stops() ;
					res=res.replace(/<\/lineargradient>/, st+"</lineargradient>");
					//var pos=lastIndexOf("</lineargradient>");
					
					break;
				case 'radial':
				//TODO les 50% c'ets codé en dur
					grad =  $('<radialgradient>').attr('id','grad' + xprop.uniqueID)//
					.attr('cx','50%')//
					.attr('cy','50%')//
					.attr('r','50%') //
					.attr('fx','50%') //
					.attr('fy','50%') ;
					var res =grad[0].outerHTML;
					res=res.replace(/<\/radialgradient>/, stops()+"</radialgradient>");
					break;
				}
				return res ;
}

function createShadow(xprop) {
var res='<filter id="shadow'+xprop.uniqueID+'">' ;
//$('<filter>').attr('id',xprop.uniqueID) ;

var feOffset=$('<feOffset>').attr('in',"SourceAlpha").attr('dx',"5").attr('dy',"5").attr("result","offOut") ;
res+=feOffset[0].outerHTML ;
var feGaussianBlur=$('<feGaussianBlur>').attr('in',"offOut").attr('stdDeviation',"3").attr("result","blurred") ;
res+=feGaussianBlur[0].outerHTML ;
var feBlend=$('<feBlend>').attr('in',"SourceGraphic").attr('in2',"blurred").attr("mode","normal") ;
res+=feBlend[0].outerHTML ;

/*<filter id="shadow"+xprop.uniqueID x="0" y="0" width="200%" height="200%">
<feOffset in="SourceAlpha" dx="5" dy="5" result="offOut"/>
<feGaussianBlur in="offOut" stdDeviation="3" result="blurred"/>
<feBlend in="SourceGraphic" in2="blurred" mode="normal" />

</filter>*/


	return res+='</filter>' ;
}
