"use strict";

var d3 = require("syracuse-ui/deps/d3");

var helpers = require('syracuse-core/lib/helpers'),
	uiHelper = require('syracuse-ui/lib/desktop/field/process/helpers');
require('syracuse-ui/lib/desktop/field/process/jquery.contextMenu');
require('syracuse-ui/deps/jqModal/jqModal');


var imagesRoot = "/syracuse-ui/themes/desktop/sage/process/images",
	libInfoRoot = "/syracuse-ui/lib/desktop/field/process";


function ProcessPlayer() {};

exports.ProcessPlayer = helpers.defineClass(ProcessPlayer, null, {
	init: function($$div, /* options,*/ fld) {
		var self = this;
		this.$$div = $$div;
		//this.options = options;
		this.uuid = $$div.attr("id");
		this.field = fld;

		var $$page = $('<div>').attr("id", "page").appendTo($$div);
		this.$$container = $$page;

		var technicPart = '<div id="fenetreTechnique" class="s-process-hidden s-process-fenetreImportExport">   \
	<div id="entetedivflottantFT"></div>    \
	<div id="DivDockToolBar" class="s-process-DivDockToolBar">    \
	<div id="menuprincipal" class="s-process-menuprincipal">    \
	<a id="titreMenuPrincipal" class="s-process-titreMenuPrincipal">Fichier</a>  \
	</div>  \
	</div>  \
	<div id="divSousMenu class="s-process-divSousMenu">  \
	<a class="sousMenuItem" id="importLink">Importer...</a> \
	<a class="sousMenuItem" id="exportLink">Exporter en texte...</a>    \
	</div>  \
	</div>';
		$(technicPart).appendTo($$div);

		// <!--pop-up "fenêtre Exporter"-->
		var exportPopup = '<div id="export" class="s-process-fenetreImportExport s-process-hidden"> \
	<div id="enteteExport" class="s-process-enteteFenetreImportExport"></div> \
	<p>Vos donn&eacute;es :</p> \
	<div>   \
	<textarea id="textAreaExport" class="s-process-textAreaImportExport"></textarea>  \
	</div>  \
	<div>   \
	<button id="btnValiderExport" class="s-process-btnFT">OK</button> \
	</div>  \
	</div>';
		$(exportPopup).appendTo($$div);

		// <!-- pop up message et traces -->
		var messagePopup = '<div id="msgEtTraces" class="s-process-hidden">   \
	<div id="enteteMsgEtTraces" class="s-process-enteteMsgEtTraces">    \
	<div id="titreMsgEtTraces" class="s-process-left"> Vos messages </div>    \
	<div id="divFermer" class="s-process-left"><img id="imageFermerMessageTrace" src="' + imagesRoot + '/fermer.png" width="20" height="20" alt="fermer"> </div> \
	<div style="clear:both"></div>  \
	</div>  \
	<div>   \
	<div id="divTextAreaMsgEtTraces" class="s-process-left">  \
	<textarea  id="textAreaMsgEtTraces" class="s-process-textAreaMsgEtTraces" readonly="readonly"></textarea> \
	</div>  \
	<div id="actions" class="s-process-left"> \
	<div class="s-process-divAction" id="btnMsg"> Messages </div> \
	<div class="s-process-divAction" id="btnDetail"> Détail </div>    \
	<div class="s-process-divAction" id="btnTrace"> Trace </div>  \
	<div class="s-process-divAction" id="btnCopier"> Copier </div>    \
	</div>  \
	<div style="clear:both"></div>  \
	</div>  \
	</div>';
		$(messagePopup).appendTo($$div);

		// <!-- pop up echange de donnees -->
		var exchangePopup = '<div id="divCadreEchangesDeDonnees" class="s-process-hidden s-process-divCadreEchangesDeDonnees">    \
	<div id="divContenuEchangesDeDonnees" class="s-process-divContenuEchangesDeDonnees">  \
	<textarea  id="textAreaContenuEchangesDeDonnees" class="s-process-textAreaContenuEchangesDeDonnees" readonly="readonly"></textarea>    \
	</div>  \
	</div>';
		$(exchangePopup).appendTo($$div);

		var contextMenu = '<ul id="myMenu" class="s-process-contextMenu"> \
	<li ><a href="#echangeDonnee">Echanges de donnees</a></li>  \
	<li class="cut"><a href="#messageEtTrace">Messages et trace</a></li>    \
	<li class="copy separator"><a href="#fenetreTechnique">Montrer/cacher fenetre technique</a></li>    \
	</ul>';
		$(contextMenu).appendTo($$div);


		/*******************************************************
		 * Chargement du contenu de la page en JSon dans le pop up "exporter"
		 *******************************************************/
		$("#exportLink").click(function(event) {
			showPopUp('export');
			$('#textAreaExport').text(options.process && options.process.getJson());
			$('#textAreaExport').select();
		});

		/*******************************************************
		 * Affichage du popup "import"
		 *******************************************************/
		$('#importLink').click(function(event)  {
			showPopUp('import');
		});

		/*******************************************************
		 * Fermeture de la fenêtre message et trace avec un click sur l'image de fermeture
		 *******************************************************/
		$("#imageFermerMessageTrace").hover(function() {
			$(this).attr('src', imagesRoot + '/fermerHover.png');
		}, function() {
			$(this).attr('src', imagesRoot + '/fermer.png');
		}).click(function() {
			$("#msgEtTraces").toggle();
		});

		/*******************************************************
		 * Gestion du menu de la fenetre technique
		 *******************************************************/
		$("#menuprincipal").click(function(event) {

			if ($("#menuprincipal").hasClass('orangebackground')) {
				$("#menuprincipal").removeClass('orangebackground');
			} else {
				$("#menuprincipal").addClass('orangebackground');
				$("#divSousMenu").toggle();

				//empeche le declenchement du listener qui suit
				event.stopPropagation();

				//Ajout d'un listener de click sur toute la page qui ferme le menu      
				$('#body').bind('click', function() {
					$("#menuprincipal").removeClass('orangebackground');
					$("#divSousMenu").toggle();
					//suppression du listener une fois celui ci utilisé
					$('#body').unbind('click');
				});
			}
		});

		/*******************************************************
		 * Gestion des boutons de importer/exporter
		 *******************************************************/
		$("#btnValiderExport").click(function() {
			$('#export').jqmHide();
			$('#export').removeClass('montrer');
		});
		$("#btnAnnulerImport").click(function() {
			$('#import').jqmHide();
			$('#import').removeClass('montrer');
		});
		$('textarea').disableContextMenu();

		/*******************************************************
		 * Gestion de l'import quand on entre le json à la main
		 *******************************************************/
		$('#btnValiderImport').click(function() {
			// on recupere le json … 
			var jsonTxt = $('#textAreaImport').val();
			if (jsonTxt != "") {
				// … et on le charge
				self.options.process && self.options.process.loadJson(jsonTxt);
				// on verifie ensuite que le json est importé, pour vérifier qu'il n'avait pas d'erreur.
				// donc getJson() doit renvoyé le même contenu que l'import
				self.options.process && self.options.process.loadJson(jsonTxt);
				if (self.options.process && (self.options.process.getJson() == jsonTxt))  {

					// et on affiche tous les nouveaux
					self.clear().show();
					// sageInitPage($.sageJSON.getPageInfo()).sageDisplayPlayer($.sageJSON.getFormes());
					// on vide le textarea 
					$('#textAreaImport').val('');

					// et on ferme la fenêtre     
					$('#import').jqmHide();
					$('#import').removeClass('montrer');

				} else {

					// si ça ne correspond pas, on affiche un petit popup
					alert("Le JSON importé n'est pas valide");
				}
			}
		});

		/*******************************************************
		 * Fenetre echange de données
		 *******************************************************/
		//Cacher la fenetre echange de donnée avec un clic sur la bordure
		$("#divContenuEchangesDeDonnees").click(function(event) {
			event.stopPropagation();
		});
		$("#divCadreEchangesDeDonnees").click(function() {
			$("#divCadreEchangesDeDonnees").hide();
		});

		/*******************************************************
		 * Definition des draggable pour les popups
		 *******************************************************/
		$("#msgEtTraces").draggable({
			containment: "body",
			scroll: false,
			handle: "#titreMsgEtTraces"
		});
		$("#fenetreTechnique").draggable({
			containment: "body",
			scroll: false
		});
		$("#import").draggable({
			containment: "body",
			scroll: false,
			handle: "#enteteImport"
		});
		$("#export").draggable({
			containment: "body",
			scroll: false,
			handle: "#enteteExport"
		});

		/***************************************************
		 *        Affichage des traces
		 *******************************************************/
		$('#btnTrace').click(function(event) {
			$('#textAreaMsgEtTraces').val(txtTrace);
		});

		/***************************************************
		 *        Affichage des messages
		 *******************************************************/
		$('#btnMsg').click(function(event) {
			$('#textAreaMsgEtTraces').val(txtMsg);
		});

		//$$page.css('height', pageInfoJson.contentSize.xheight + 'px').css('width', pageInfoJson.contentSize.xwidth + 'px').css('top', pageInfoJson.docDims.xtop).css('left', pageInfoJson.docDims.xtop);
		return this;
	},

	loadProcess: function(process) {

		this.process = process;
		this.$$container.css('height', process.contentSize.xheight + 'px').css('width', process.contentSize.xwidth + 'px').css('top', process.docDims.xtop).css('left', process.docDims.xtop);
	},

	show: function() {
		var w = 480,
			h = 600;
		var t = 1; //var t = .5 ;
		var delta = .01;
		var padding = 0;
		var bezier = {};
		var line = d3.svg.line().x(x).y(y);
		var stroke = d3.scale.category20b();
		var points = [];
		var svgplot;
		var clickactions;
		var mouseoveractions;

		function getStroke(xprop) {
			return (xprop.xstrokeProps.xtype === 'none' || xprop.xstrokeProps.xtype === 'nostroke') //
			? 'none' : getHexadecimalColor(xprop.xstrokeProps.xcolor)
		}

		function getStrokeDashArray(xprop) {

			if (xprop.xstrokeProps.xtype === 'dottedstroke') return 2 * xprop.xstrokeProps.xthickness + ',' + 2 * xprop.xstrokeProps.xthickness;
			else if (xprop.xstrokeProps.xtype === 'dashedstroke') return 5 * xprop.xstrokeProps.xthickness + ',' + 5 * xprop.xstrokeProps.xthickness;
			else return '';
		}

		function getFill(xprop) {
			if (xprop.xfillProps.xtype === 'nofill') return 'none';
			else if (xprop.xfillProps.xtype === 'solidfill') return getHexadecimalColor(xprop.xfillProps.xcolor);
			else if (xprop.xfillProps.xtype === 'gradientfill') return 'url(#grad' + xprop.uniqueID + ')';

		}

		function setAttrs(shape, xprop) {
			shape.attr('stroke', getStroke(xprop)) //
			.attr('stroke-opacity', xprop.xstrokeProps.xalpha / 100) //
			.attr('stroke-width', xprop.xstrokeProps.xthickness) //
			.attr('stroke-dasharray', getStrokeDashArray(xprop)) //
			.attr('fill', getFill(xprop));
		}

		function appendShape(xprop, el, acts) {
			var svg = d3.select(el).append('svg');
			svg.attr('class', 'shape');
			var shape;
			var actions = acts;
			switch (xprop.xshapeType) {
			case 'apishape':

				switch (xprop.xdrawBehaviorCode) {
				case "K_API_LINE":
					shape = svg.append("line") //
					.attr('x1', xprop.xanchors[0].x).attr('y1', xprop.xanchors[0].y) //
					.attr('x2', xprop.xanchors[2].x).attr('y2', xprop.xanchors[2].y);
					break;
				case "K_API_RECT":
					shape = svg.append("rect") //
					.attr("x", xprop.xanchors[0].x).attr("y", xprop.xanchors[0].y) //
					.attr("width", Math.abs(xprop.xanchors[1].x - xprop.xanchors[0].x)) //
					.attr("height", Math.abs(xprop.xanchors[3].y - xprop.xanchors[0].y));
					break;
				case "K_API_ELLIPSE":
					shape = svg.append("ellipse") //
					.attr("cx", xprop.xanchors[0].x + Math.abs(xprop.xanchors[1].x - xprop.xanchors[0].x)) //
					.attr("cy", xprop.xanchors[0].y) //
					.attr("rx", Math.abs(xprop.xanchors[2].x - xprop.xanchors[0].x) / 2) //
					.attr("ry", Math.abs(xprop.xanchors[1].y - xprop.xanchors[3].y) / 2);
					break;
				};
				setAttrs(shape, xprop);
				break;
			case 'beziershape':
				var xanchors = xprop.xanchors;
				var a = xanchors[0];
				if (!a) return; // we get this in fill test
				var d = 'M ' + a.x + ' ' + a.y;
				var len = xanchors.length + (xprop.xclosed ? 1 : 0);
				// control points are weaker than in flash - so I move them away by a factor of f
				// value is experimental.
				var f = 1.3;
				for (var i = 1; i < len; i++) {
					var pa = a;
					a = xanchors[i % xanchors.length];
					var c2x = pa.x + f * (pa.c2x - pa.x);
					var c2y = pa.y + f * (pa.c2y - pa.y);
					var c1x = a.x + f * (a.c1x - a.x);
					var c1y = a.y + f * (a.c1y - a.y);
					d += ' C ' + c2x + ' ' + c2y + ' ' + c1x + ' ' + c1y + ' ' + a.x + ' ' + a.y;
				}
				shape = svg.append("path").attr('d', d);
				setAttrs(shape, xprop);
				shape.datum(xprop);
				break;
			case 'clipshape':
			case 'fileshape':
				var g = d3.select(el);
				shape = g.append('image'); // d3.select($$container[0]).selectAll("img") ;
				shape.attr('id', function(d) {
					return d.uniqueID;
				});
				shape.style('position', 'absolute');


				if (Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, xprop.xanchors[1].x - xprop.xanchors[0].x) != 0) {
					//there is a rotation
					shape.attr('x', function(d) {
						return d.xcenter.x - Math.max(d.xsize.xwidth, d.xsize.xheight) / 2;
					});
					shape.attr('y', function(d) {
						return d.xcenter.y - Math.max(d.xsize.xwidth, d.xsize.xheight) / 2;
					});
					shape.attr('width', function(d) {
						return (Math.max(d.xsize.xwidth, d.xsize.xheight));
					});
					shape.attr('height', function(d) {
						return (Math.max(d.xsize.xwidth, d.xsize.xheight));
					});
					shape.attr('transform', function(d) {

						var anglerad = Math.atan2(d.xanchors[1].y - d.xanchors[0].y, d.xanchors[1].x - d.xanchors[0].x);
						var angle = 180 * anglerad / Math.PI;
						var result = 'rotate(' + angle + ',' + xprop.xcenter.x + ',' + xprop.xcenter.y //
						+ ') ';
						return result;
					});
				} else {
					//No rotation
					shape.attr('width', function(d) {
						var xcoords = [];
						for (var j = 0; j < 4; j++) {
							xcoords.push(d.xanchors[j].x);
						}
						xcoords.sort(compare_int_func);
						return (xcoords[3] - xcoords[0]);
					});

					shape.attr('height', function(d) {
						var i;
						var ycoords = [];
						for (i = 0; i < 4; i++) {
							ycoords.push(d.xanchors[i].y);
						}
						ycoords.sort(compare_int_func);
						return (ycoords[3] - ycoords[0]);
					});
					shape.attr('y', function(d) {
						var i;
						var ycoords = [];
						for (i = 0; i < 4; i++)
						ycoords.push(d.xanchors[i].y);
						ycoords.sort(compare_int_func);
						return (ycoords[0] + 'px');
					});

					shape.attr('x', function(d) {
						var i;
						var xcoords = [];
						for (i = 0; i < 4; i++)
						xcoords.push(d.xanchors[i].x);
						xcoords.sort(compare_int_func);
						return (xcoords[0] + 'px');
					});


					shape.attr('preserveAspectRatio', 'none');
				}
				shape.attr('z-index', function(d) {
					return d.xlevel;
				});
				shape.style('filter', function(d) {
					return "alpha(opacity=" + d.alpha + ")";
				});
				shape.style('-moz-opacity', function(d) {
					return d.alpha + "/100";
				});
				shape.style('-khtml-opacity', function(d) {
					return d.alpha + "/100";
				});
				shape.style('opacity', function(d) {
					return d.alpha + "/100";
				});

				shape.attr("xlink:href", function(d) {
					var src = '/syracuse-ui/themes/desktop/sage/process/images/' //
					+ getBibFamSubpath(d.bibid) //
					+ getBibCatSubpath(d.bibid) + getBibName(d.bibid) + '/' + d.eltid;
					if (d.xshapeType == 'clipshape') src += '.png';
					return src;
				});
				var links = shape.filter(function(xprop) {
					return (xprop.xlinkProps.xtype != 'none');
				}); //
				links.on("click", function(d) {
					document.controller.openPage(self.field.boxParent.getArticle(), constructLinksObj(d), null);
				});
				break;

			}

			shape.style('display', function(xprop) {
				if (xprop.xactionProps.targ && isHidden(xprop.xactionProps.targ[0], actions)) return 'none';
				else return 'bloc';

			});
		}

		function x(d) {
			return d.x;
		}

		function y(d) {
			return d.y;
		}

		function colour(d, i) {
			stroke(-i);
			return d.length > 1 ? stroke(i) : "red";
		}

		function click(d) {
			var typeact = 'none';
			var targets = svgplot.selectAll('g').selectAll('*').filter(function(xprop) {
				if (xprop.xactionProps && xprop.xactionProps.targ) {
					var clicktrig = d.xactionProps.trig.filter(function(el) {
						for (var i = 0; i < clickactions.length; i++) {
							if (el == clickactions[i].id) {
								typeact = clickactions[i].type;
								return true;
							}
						}
						return false;
					});

					for (var j = 0; j < xprop.xactionProps.targ.length; j++) {
						if (xprop.xactionProps.targ[j] == clicktrig[0]) return true;
					}
				}
				return false;
			});

			switch (typeact) {
			case 'sho':
			case 'shopopmenu':
			case 'shoallpopmenu':
				targets.style('display', 'block');
				break;
			case 'hid':
				targets.style('display', 'none');
				break;
			case 'shohid':
				targets.style('display', function() {
					if (this.style.display == 'none' || this.style.display == "") return 'block';
					else return 'none'
				});
				break;
			default:
				;
			}
		}


		function mouseover(d) {
			var targets = svgplot.selectAll('g').selectAll('*').filter(function(xprop) {
				if (xprop.xactionProps && xprop.xactionProps.targ) {

					var mouseovertrig = d.xactionProps.trig.filter(function(el) {
						for (var i = 0; i < mouseoveractions.length; i++) {
							if (el == mouseoveractions[i].id) return true;
						}
						return false;
					});

					for (var j = 0; j < xprop.xactionProps.targ.length; j++) {
						if (xprop.xactionProps.targ[j] == mouseovertrig[0]) return true;
					}
				}
				return false;
			});
			targets.style('display', 'block');
		}


		var self = this,
			$$container = this.$$container,
			layers = self.process && self.process.layersArr;
		svgplot = d3.select($$container[0]).append('svg');
		svgplot.attr('height', 900).attr('width', 1200);
		for (var gn = 0, sizeG = layers.length; gn < sizeG; gn++) {
			var group = layers[gn];
			var gforme = svgplot.selectAll("g.lvl" + gn) //
			.data(layers[gn].xpropsArr).enter().append('g');
			gforme.attr('class', 'shape');
			gforme.attr('id', function(d) {
				return d.uniqueID
			});
			gforme.attr("style", function(d) {
				return 'position:absolute;width:100%;height:100%;z-index:' + d.xlevel + ';';
			});
			gforme.each(function(d, idx) {
				appendShape(d, gforme[0][idx], self.process.acts.a);
			});


			var links = gforme.filter(function(xprop) {
				return (xprop.xlinkProps.xtype != 'none');
			});


			links.on("click", function(d) {
				document.controller.openPage(self.field.boxParent.getArticle(), constructLinksObj(d), null);
			});

			if (self.process.acts.a) {
				clickactions = self.process.acts.a.filter(function(el) {
					return (el.type == 'shopopmenu' //
					|| el.type == 'sho' || el.type == 'shohid' || el.type == 'hid')
				});

				mouseoveractions = self.process.acts.a.filter(function(el) {
					return (el.type == 'shotip')
				});

				var clickActs = gforme.filter(function(xprop) {
					return (xprop.xactionProps.trig != null &&

					isClickable(xprop.xactionProps.trig, clickactions));
				});
				clickActs.on('click', click);

				var mouseoverActs = gforme.filter(function(xprop) {
					return (xprop.xactionProps.trig != null && isMouseover(xprop.xactionProps.trig, mouseoveractions));
				});
				mouseoverActs.on('mouseover', mouseover);
			}

			var gradientsvg = d3.select($$container[0]).selectAll('svg.shape').filter(function(d, i) {
				return (d.xfillProps && d.xfillProps.xtype === 'gradientfill');
			});
			var defs = gradientsvg.append('defs');
			defs.each(function(d, idx) {
				appendGradient(d, defs[0][idx]);
			});

			var linesWithMarkers = d3.select($$container[0]).selectAll('line' /*'svg.shape'*/ ).filter(function(d, i) {
				return (d.xstrokeProps && (d.xstrokeProps.xstart.xtype != 'none' //
				|| d.xstrokeProps.xend.xtype != 'none'));
			});
			linesWithMarkers.each(

			function(d, idx) {

				appendLineMarkers(d, (linesWithMarkers[0][idx]).parentNode);
			});
			var edge = d3.select($$container[0]).selectAll("svg line, svg rect, svg ellipse svg.path");
			edge.attr('stroke', function(d) {
				if (d.xstrokeProps.xtype === 'none' || d.xstrokeProps.xtype === 'nostroke') return 'none';
				else return getHexadecimalColor(d.xstrokeProps.xcolor);
			});
			edge.attr('stroke-opacity', function(d) {
				return d.xstrokeProps.xalpha / 100;
			});
			edge.attr('stroke-width', function(d) {
				return d.xstrokeProps.xthickness
			});
			edge.attr('stroke-dasharray', function(d) {
				if (d.xstrokeProps.xtype === 'dottedstroke') return 2 * d.xstrokeProps.xthickness + ',' + 2 * d.xstrokeProps.xthickness;
				else if (d.xstrokeProps.xtype === 'dashedstroke') return 5 * d.xstrokeProps.xthickness + ',' + 5 * d.xstrokeProps.xthickness; //+5*d.xstrokeProps.xthickness+','+ 5*d.xtrokeProps.xthickness ;
				else return '';
			});
			edge.attr('fill', function(d) {
				if (d.xfillProps.xtype === 'nofill') return 'none';
				else if (d.xfillProps.xtype === 'solidfill') return getHexadecimalColor(d.xfillProps.xcolor);
				else if (d.xfillProps.xtype === 'gradientfill') {
					return 'url(#grad' + d.uniqueID + ')';
				}
			});
			edge.attr('marker-end', function(d) {
				if (d.xstrokeProps.xend && d.xstrokeProps.xend.xtype != 'none') return 'url(#endMarker' + d.uniqueID + ')';
				else return '';
			});
			edge.attr('marker-start', function(d) {
				if (d.xstrokeProps.xstart && d.xstrokeProps.xstart.xtype != 'none') return 'url(#startMarker' + d.uniqueID + ')';
				else return '';
			});

			var textparent = gforme.filter(function(d, i) {
				return d.xtext != '';
			});
			textparent.each(function(d, idx) {
				appendText(d, $$container[0]);
			});
		}
		return this;
	},
	clear: function() {
		this.$$container.empty();
		return this;
	},
	dispose: function() {
		self.field = null;
		// AJouter la method dispose dans ProcessPlayer
	}
});

/**
 * Variables globales
 */
//variable stockant la ou les traces
var txtTrace = "a";
//variable stockant les messages
var txtMsg = "b";
//variable stockant le ou les échange de données
var traceEchData = "c";
// variable qui conserve l'ensemble des correspondances bibid 
var bibCorrespondance;


/**
 * fonctions
 */
/*Permet de remplir la variable txtTrace*/

function laisseTrace(newTrace) {
	txtTrace += "\n\r" + newTrace;
} /*Permet de remplir la variable txtMsg*/

function laisseMsg(newMsg) {
	txtMsg = newMsg;
}

/*Permet de remplir la variable traceEchData*/

function traceAlert(amsg) {
	//cette fonction ne comprend pas le test relatif à xtraceType la variable n'étant pas implémenter dans notre prototype
	//amsg est aussi tracé
	laisseTrace(amsg)
	//test portant sur la longueur de la variable traceEchData 
	if (traceEchData.length > 159000) {
		if (traceEchData.length < 159400) {
			traceEchData += ". ";
		}
		return;
	}
	//MAJ de la variable traceEchData avec l'ajout du nouveau message amsg
	traceEchData += "\n\r" + amsg;
}

/*
 * Montre / Cache pop up modal
 */

function showPopUp(divID) {
	// $("#" + divID).jqm({
	//  overlay: 10,
	//  modal: true
	// });
	// $("#" + divID).jqmShow();
	// $("#" + divID).addClass("montrer");
}


function makeSVG(tag, attrs) {
	var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
	for (var k in attrs) {
		el.setAttribute(k, attrs[k]);
	}
	return el;
}

//Récupère le code hexadecimal de la couleur à partir du code décimal

function getHexadecimalColor(str) {
	if (typeof str == 'undefined') {
		str = 0;
	}
	var hex = Number(str).toString(16);
	hex = "#000000".substr(0, 7 - hex.length) + hex;
	return hex.toUpperCase();
}

function getBibName(bibid) {
	var json = "";
	var response = $.ajax({
		type: 'get',
		url: libInfoRoot + '/sgx_libsinfo.txt',
		dataType: 'json',
		async: false
	});

	// status 200 = OK
	if (response.status == 200) {
		try {
			json = $.parseJSON(response.responseText);
		} catch (e) {
			// si le parse ne fonctionne pas, on renvoie une chaine vide.
			return "";
		}
	}

	// si bibCorrespondance est vide, on le remplit d'abord
	if (bibCorrespondance == null) {
		bibCorrespondance = {};
		// On parcours la liste des librairies
		for (var libNum = 0, sizeL = json.libsinfo.length; libNum < sizeL; libNum++) {
			var bibList = json.libsinfo[libNum].biblist;

			// on parcours la liste 
			for (var bibNum = 0, sizeB = bibList.length; bibNum < sizeB; bibNum++) {
				var bib = bibList[bibNum];

				bibCorrespondance[bib.bibid] = bib;
			}
		}
	}

	return (typeof bibCorrespondance[bibid] !== 'undefined' && bibCorrespondance[bibid].type == 'swflib' //
	&& bibCorrespondance[bibid].bibfilename != null) ? bibCorrespondance[bibid].bibfilename.replace(/\.swf/, "") : "";
};


function getBibCatSubpath(bibid) {
	var json = "";
	var response = $.ajax({
		type: 'get',
		url: libInfoRoot + '/sgx_libsinfo.txt',
		dataType: 'json',
		async: false
	});

	// status 200 = OK
	if (response.status == 200) {
		try {
			json = $.parseJSON(response.responseText);
		} catch (e) {
			// si le parse ne fonctionne pas, on renvoie une chaine vide.
			return "";
		}
	}

	// si bibCorrespondance est vide, on le remplit d'abord
	if (bibCorrespondance == null) {
		bibCorrespondance = {};
		// On parcours la liste des librairies
		for (var libNum = 0, sizeL = json.libsinfo.length; libNum < sizeL; libNum++) {
			var bibList = json.libsinfo[libNum].biblist;

			// on parcours la liste 
			for (var bibNum = 0, sizeB = bibList.length; bibNum < sizeB; bibNum++) {
				var bib = bibList[bibNum];

				bibCorrespondance[bib.bibid] = bib;
			}
		}
	}
	return (typeof bibCorrespondance[bibid] !== 'undefined' && bibCorrespondance[bibid].catsubpath != null) ? bibCorrespondance[bibid].catsubpath : "";
}

function getBibFamSubpath(bibid) {
	var json = "";
	var response = $.ajax({
		type: 'get',
		url: libInfoRoot + '/sgx_libsinfo.txt',
		dataType: 'json',
		async: false
	});

	// status 200 = OK
	if (response.status == 200) {
		try {
			json = $.parseJSON(response.responseText);
		} catch (e) {
			// si le parse ne fonctionne pas, on renvoie une chaine vide.
			return "";
		}
	}

	// si bibCorrespondance est vide, on le remplit d'abord
	if (bibCorrespondance == null) {
		bibCorrespondance = {};
		// On parcours la liste des librairies
		for (var libNum = 0, sizeL = json.libsinfo.length; libNum < sizeL; libNum++) {
			var bibList = json.libsinfo[libNum].biblist;

			// on parcours la liste 
			for (var bibNum = 0, sizeB = bibList.length; bibNum < sizeB; bibNum++) {
				var bib = bibList[bibNum];

				bibCorrespondance[bib.bibid] = bib;
			}
		}
	}


	return (typeof bibCorrespondance[bibid] !== 'undefined' && bibCorrespondance[bibid].familysubpath != null) ? bibCorrespondance[bibid].familysubpath : "";
};

function parseLien(chaine) {
	var chaineParse = ""
	if (chaine.indexOf("erpfunc", 0) > -1) {} // lien vers une fonction erp //non géré
	if (chaine.indexOf("link", 0) > -1) { //lien de type URL
		var temp = chaine.replace(/.*xcode%22.*?%22(.*?)%22.*?%22xtype.*/, "$1"); //la chaine a parser se situe entre xcode et xtype
		//remplace l'encodage
		temp = temp.replace(/%3A/g, ":");
		temp = temp.replace(/%2F/g, "/");
		temp = temp.replace(/%2E/g, ".");
		chaineParse = temp;
	}
	return chaineParse;
}

function calculDegrade(alpha) {
	// l'angle de rotation est calculé par rapport au centre de la xprop, on considére donc ce point comme centre de notre graphe
	// le repère est orthonormée de longueur max 50 (la fenetre graphique éMath.tant de longueur et largeur 100)
	var x1, x2, y1, y2;

	//traitement cas spéciaux
	var margeArrondi = Math.PI / 100;
	if (alpha == 0) {
		x2 = 50;
		y2 = 0;
	} else if (alpha == Math.PI / 2) {
		x2 = 0;
		y2 = 50;
	} else if (alpha == Math.PI) {
		x2 = -50;
		y2 = 0;
	} else if (alpha == 3 * Math.PI / 2) {
		x2 = 0;
		y2 = -50;
	}
	//cas normaux
	else if (alpha < Math.PI / 4) {
		x2 = 50;
		y2 = 50 * Math.tan(alpha);
	} else if (alpha < Math.PI / 2 - margeArrondi) {
		x2 = 50 * (Math.tan(alpha - Math.PI / 4));
		y2 = 50;
	} else if (alpha < 3 * Math.PI / 4) {
		x2 = 50 * (Math.tan(alpha - Math.PI / 2)) * -1;
		y2 = 50;
	} else if (alpha < Math.PI) {
		x2 = -50;
		y2 = 50 * (Math.tan(alpha - 3 * Math.PI / 4));
	} else if (alpha < 5 * Math.PI / 4) {
		x2 = -50;
		y2 = 50 * (Math.tan(alpha - Math.PI)) * -1;
	} else if (alpha < 3 * Math.PI / 2) {
		x2 = 50 * (Math.tan(alpha - 5 * Math.PI / 4)) * -1;
		y2 = -50;
	} else if (alpha < 7 * Math.PI / 4) {
		x2 = 50 * (Math.tan(alpha - 3 * Math.PI / 2)) * -1;
		y2 = -50;
	} else { //alpha>315
		x2 = 50;
		y2 = (50 * Math.tan(alpha - 7 * Math.PI / 4)) * -1;
	}
	//calcul de x1 y1 en fonction de x2, y2. x1 et y1 sont opposé par rapport à l'origine
	x1 = -x2;
	y1 = -y2;
	// calcul pour basculer en coordonnées grphique (origine en haut a gauche)
	x1 += 50;
	y1 += 50;
	x2 += 50;
	y2 += 50;
	return {
		x1: x1,
		y1: y1,
		x2: x2,
		y2: y2
	};
}

function isHidden(actId, acts) {
	for (var k = 0; k < acts.length; k++) {
		if (acts[k].id == actId && (acts[k].type == 'shopopmenu' //
		|| acts[k].type == 'sho' //
		|| acts[k].type == 'shohid' //
		|| acts[k].type == 'shotip')) return true;
	}
	return false;
}

function isClickAct(actId, acts) {
	for (var k = 0; k < acts.length; k++) {
		if (acts[k].id == actId && (acts[k].type == 'shopopmenu' //
		|| acts[k].type == 'sho' //
		|| acts[k].type == 'shohid' //
		|| acts[k].type == 'hid')) return true;
	}
	return false;
}


function isClickable(actIds, clickacts) {

	var acts = clickacts;
	var result = actIds.filter(function(el) {
		for (var k = 0; k < acts.length; k++) {
			if (el == acts[k].id) return true;
		}
		return false;
	});
	return (result.length > 0);
}

function isMouseover(actIds, mouseoveracts) {
	var acts = mouseoveracts;
	var result = actIds.filter(function(el) {
		for (var k = 0; k < acts.length; k++) {
			if (el == acts[k].id) return true;
		}
		return false;
	});
	return (result.length > 0);
}

function constructURL(xprop) {
	switch (xprop.xlinkProps.xtype) {
	case 'erpfunc':
		var url = "/trans/x3/erp/SUPERV/$sessions?f=" + xprop.xlinkProps.xcode + "/2//M/" + xprop.xlinkProps.xparam2;
		return url;

	case 'url':
		return xprop.xlinkProps.xcode;
	}
}

function appendText(xprop, el) {
	var divtext = d3.select(el).append('div').attr('id', xprop.uniqueID + 'p');
	divtext.html(xprop.xtext);
	var text = "";

	var textformat = divtext.selectAll('textformat');
	var font = textformat.selectAll('p>font');

	var a = font.selectAll('a').each(function() {
		$(this).attr('href', parseLien($(this).attr("href")))
	});
	text += font.html() + '<br />';

	divtext.html(text);
	divtext.style('position', 'absolute');
	divtext.style('text-align', xprop.xtextFormat.align) //
	.style('word-spacing', xprop.xtextFormat.kerning) //
	.style('display', xprop.xtextFormat.display) //
	.style('letter-spacing', xprop.xtextFormat.letterSpacing + 'px') //
	.style('tab-stops', xprop.xtextFormat.tabStops) //
	.style('text-indent', xprop.xtextFormat.blockIndent + 'px') //
	.style('padding-left', xprop.xtextFormat.indent + 'px') //
	.style('margin-right', xprop.xtextFormat.rightMargin + 'px') //
	.style('margin-left', xprop.xtextFormat.leftMargin + 'px') //
	.style('text-decoration', xprop.xtextFormat.underline) //
	.style('italic', xprop.xtextFormat.italic) //
	.style('font-weight', xprop.xtextFormat.bold) //
	.style('target', xprop.xtextFormat.target) //
	.style('color', getHexadecimalColor(xprop.xtextFormat.color)) //
	.style('font-size', xprop.xtextFormat.size + 'px') //
	.style('font-family', xprop.xtextFormat.font) //
	.style('z-index', xprop.xlevel) //
	.style('vertical-align', xprop.xcaptionProps.xvertAlignMode);
	divtext.style('left', xprop.xcaptionPos.xleft + 'px') //
	.style('top', xprop.xcaptionPos.xtop + 'px') //
	.style('width', xprop.xcaptionSize.xwidth - xprop.xtextFormat.rightMargin - xprop.xtextFormat.leftMargin + 'px') //
	.style('height', xprop.xcaptionSize.xheight + 'px');
}

function compare_int_func(a, b) {
	// Elle doit retourner :
	// -1 si a < b
	//  0 si a = b
	//  1 si a > b
	return parseInt(a) - parseInt(b)
}

function constructLinksObj(xprop) {
	//d.$field.$prototype.$links.$default
	var obj = {};
	switch (xprop.xlinkProps.xtype) {

	case 'erpfunc':
/*var url="/trans/x3/erp/SUPERV/$sessions?f="+xprop.xlinkProps.xcode+"/2//M/"+xprop.xlinkProps.xparam2 ;
return  url ;*/
		obj.$type = "application/json;vnd.sage=syracuse";
		obj.$title = xprop.xlinkProps.xlabel;
		obj.$url = "/trans/x3/erp/SUPERV/$sessions?f=" + xprop.xlinkProps.xcode + "/2//M/" + xprop.xlinkProps.xparam2;
		obj.$method = "POST";
		//"$url": "{$baseUrl}/{$pluralType}('{$key}')?representation={$singularType}.$details&role={$role}"
		return obj;
	case 'url':
		obj.$type = "application/json;vnd.sage=syracuse";
		obj.$url = xprop.xlinkProps.xcode;
		return obj;
	}
}


function appendLineMarkers(xprop, parent) {
	var markertype, filled;
	if (xprop.xstrokeProps.xstart) {
		markertype = xprop.xstrokeProps.xstart.xtype;
		filled = xprop.xstrokeProps.xstart.xfilled;

		if (markertype != 'none' && markertype != 'noarrow') {
			appendLineMarker(xprop, parent, markertype, filled, 'start');
		}
	}

	if (xprop.xstrokeProps.xend) {
		markertype = xprop.xstrokeProps.xend.xtype;
		filled = xprop.xstrokeProps.xend.xfilled;

		if (markertype != 'none' && markertype != 'noarrow') {
			appendLineMarker(xprop, parent, markertype, filled, 'end');
		}
	}

}


function appendLineMarker(xprop, parent, markertype, filled, startend) {
	var marker;
	var sz = 2 * xprop.xstrokeProps.xthickness + 11;
	var x1, x2, y1, y2, angle, anglePoint;


	x1 = xprop.xanchors[0].x;
	x2 = xprop.xanchors[2].x;
	y1 = xprop.xanchors[0].y;
	y2 = xprop.xanchors[2].y;

	angle = Math.atan2(y2 - y1, x2 - x1);
	anglePoint = Math.PI / 2 - angle;
	switch (markertype) {
	case 'arr1':
	case 'arr2':
	case 'diamond1':

		var spreadfactor = 0.5;
		var point1x, point1y, point2x, point2y, point3x, point3y, point4x, point4y, endx, endy;
		var centerx, centery;
		if (startend == 'end') {
			if (markertype == 'arr1' || markertype == 'arr2') {
				point1x = x2 - Math.cos(angle + spreadfactor) * sz;
				point1y = y2 - Math.sin(angle + spreadfactor) * sz;
				point3x = x2 - Math.cos(angle - spreadfactor) * sz;
				point3y = y2 - Math.sin(angle - spreadfactor) * sz;
				point2x = x2;
				point2y = y2;

				if (markertype == 'arr1') {
					endx = Math.round((point1x + point3x) / 2);
					endy = Math.round((point1y + point3y) / 2);
				} else if (markertype == 'arr2') {
					endx = x2 - Math.cos(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
					endy = y2 - Math.sin(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
				}

			} else if (markertype == 'diamond1') {
				centerx = x2 - Math.cos(angle) * sz / 2;
				centery = y2 - Math.sin(angle) * sz / 2;
				point1x = centerx + Math.cos(anglePoint) * sz / 2;
				point1y = centery - Math.sin(anglePoint) * sz / 2;
				point2x = x2 - Math.cos(angle) * sz;
				point2y = y2 - Math.sin(angle) * sz;
				point3x = centerx - Math.cos(anglePoint) * sz / 2;
				point3y = centery + Math.sin(anglePoint) * sz / 2;
				point4x = x2;
				point4y = y2;
				endx = centerx;
				endy = centery;

			}
			if (markertype != 'arr2') d3.select(parent).select('line').attr('x2', endx).attr('y2', endy);
		} else if (startend == 'start') {
			if (markertype == 'arr1' || markertype == 'arr2') {
				point1x = x1 + Math.cos(angle + spreadfactor) * sz;
				point1y = y1 + Math.sin(angle + spreadfactor) * sz;
				point3x = x1 + Math.cos(angle - spreadfactor) * sz;
				point3y = y1 + Math.sin(angle - spreadfactor) * sz;
				point2x = x1;
				point2y = y1;
				if (markertype == 'arr1') {
					endx = Math.round((point1x + point3x) / 2);
					endy = Math.round((point1y + point3y) / 2);
				} else if (markertype == 'arr2') {
					endx = x1 + (Math.cos(angle) * xprop.xstrokeProps.xthickness / 2);
					endy = y1 + (Math.sin(angle) * xprop.xstrokeProps.xthickness / 2);
				}
			} else if (markertype == 'diamond1') {

				centerx = x1 + Math.cos(angle) * sz / 2;
				centery = y1 + Math.sin(angle) * sz / 2;
				point1x = centerx - Math.cos(anglePoint) * sz / 2;
				point1y = centery + Math.sin(anglePoint) * sz / 2;
				point2x = x1 + Math.cos(angle) * sz;
				point2y = y1 + Math.sin(angle) * sz;
				point3x = centerx + Math.cos(anglePoint) * sz / 2;
				point3y = centery - Math.sin(anglePoint) * sz / 2;
				point4x = x1;
				point4y = y1;
				endx = centerx;
				endy = centery;
			}

			//if (markertype!='arr2')
			d3.select(parent).select('line').attr('x1', endx).attr('y1', endy);
		}


		marker = d3.select(parent).append('path').attr('d', function() {
			var pathdescr = 'M ' + point1x + ' ' + point1y + ' L ' + point2x + ' ' + point2y + ' L ' + point3x + ' ' + point3y;
			if (markertype == 'diamond1') pathdescr += ' L ' + point4x + ' ' + point4y;
			if (markertype == 'arr1' || markertype == 'diamond1') pathdescr += ' z';

			return pathdescr;
		});

		marker.attr('stroke', function() {
			return getHexadecimalColor(xprop.xstrokeProps.xcolor)
		});
		marker.attr('stroke-width', function() {
			if (markertype == 'arr2') return xprop.xstrokeProps.xthickness;
			else return 1;
		});
		marker.attr('fill', function() {
			if (filled) return getHexadecimalColor(xprop.xstrokeProps.xcolor);
			else return 'none';
		});
		break;

	case 'disc1':

		var r, cx, cy;


		r = xprop.xstrokeProps.xthickness + 3;
		if (startend == 'end') {
			cx = x2 - Math.cos(angle) * r;
			cy = y2 - Math.sin(angle) * r;
			endx = x2 - Math.cos(angle) * r * 2;
			endy = y2 - Math.sin(angle) * r * 2;
			d3.select(parent).select('line').attr('x2', endx).attr('y2', endy);
		} else if (startend == 'start') {
			cx = x1 + Math.cos(angle) * r;
			cy = y1 + Math.sin(angle) * r;
			endx = x1 + Math.cos(angle) * r * 2;
			endy = y1 + Math.sin(angle) * r * 2;
			d3.select(parent).select('line').attr('x1', endx).attr('y1', endy);
		}
		marker = d3.select(parent).append('circle').attr('cx', cx).attr('cy', cy).attr('r', r);
		marker.attr('stroke', function() {
			return getHexadecimalColor(xprop.xstrokeProps.xcolor)
		});
		marker.attr('fill', function() {
			if (filled) return getHexadecimalColor(xprop.xstrokeProps.xcolor);
			else return 'none';
		});

		break;
	}

}


function appendGradient(xprop, defs) {
	if (xprop.xfillProps.xtype === 'gradientfill') {
		switch (xprop.xfillProps.xgtype) {
		case 'linear':
			var grad = d3.select(defs).append('linearGradient');
			var tabCoord = calculDegrade(xprop.xfillProps.xgrotation);
			grad.attr("id", 'grad' + xprop.uniqueID).attr('x1', tabCoord.x1 + '%') //
			.attr('y1', tabCoord.y1 + '%').attr('x2', tabCoord.x2 + '%') //
			.attr('y2', tabCoord.y2 + '%');
			var stops = grad.selectAll('stop').data(xprop.xfillProps.xgcolors).enter().append('stop');
			stops.attr('offset', function(d, i) {
				return xprop.xfillProps.xgratios[i] / 245.82 * 100 + '%'
			}) //
			.attr('style', function(d, i) {
				return 'stop-color:' + getHexadecimalColor(d) //
				+ ';stop-opacity:' + xprop.xfillProps.xgalphas[i] / 100 + ';';
			}) //
			break;
		case 'radial':
			var grad = d3.select(defs).append('radialGradient');
			grad.attr("id", 'grad' + xprop.uniqueID).attr('cx', '50%') //
			.attr('cy', '50%').attr('r', '50%') //
			.attr('fx', '50%').attr('fy', '50%');
			var stops = grad.selectAll('stop').data(xprop.xfillProps.xgcolors).enter().append('stop');
			stops.attr('offset', function(d, i) {
				return xprop.xfillProps.xgratios[i] / 245.82 * 100 + '%'
			});
			stops.attr('style', function(d, i) {
				return 'stop-color:' + getHexadecimalColor(d) + ';stop-opacity:' //
				+ xprop.xfillProps.xgalphas[i] / 100 + ';';
			}) //
			break;
		}
	}
}