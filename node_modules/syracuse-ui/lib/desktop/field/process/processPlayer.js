"use strict";
var helpers = require('syracuse-core/lib/helpers'),
	uiHelper = require('syracuse-ui/lib/desktop/field/process/helpers');
require('syracuse-ui/lib/desktop/field/process/jquery.contextMenu');
require('syracuse-ui/deps/jqModal/jqModal');

var imagesRoot = "/syracuse-ui/themes/desktop/sage/process/images",
	libInfoRoot = "/syracuse-ui/lib/desktop/field/process"

function ProcessPlayer() {};

exports.ProcessPlayer = helpers.defineClass(ProcessPlayer, null, {
	init: function($$div, options) {
		var self = this;
		this.$$div = $$div;
		this.options = options;
		this.uuid = $$div.attr("id");

		/*******************************************************
		 *	Contextual Menu
		 *******************************************************/
		// TODO: review this by using syracuse popup and without using right click
		/*		$("body").contextMenu({
			menu: 'myMenu'
		}, function(action, el, pos) {
			if (action == "echangeDonnee") {
				//affichage du cadre EchangeDeDonnées et mise à jour du champ
				$("#divCadreEchangesDeDonnees").show();
				$('#textAreaContenuEchangesDeDonnees').val(traceEchData);
			} else if (action == "messageEtTrace") {
				$("#msgEtTraces").show();
				$('#textAreaMsgEtTraces').val(txtMsg);
			} else if (action == "fenetreTechnique") {
				$("#fenetreTechnique").toggle();
				if ($(".montrer").length > 0) {
					if ($(".montrer:visible").length) {
						$('.montrer').jqmHide();
					} else {
						$('.montrer').jqmShow();
					}
				}
			}
		});
*/
		var pageInfoJson = options.process && options.process.getPageInfo();

		// var $$mainMenuSlot = $('<div class="s-process-menu-actions" style="visibility: hidden;">').appendTo($$div);
		// $('<a>').addClass("s-process-main-menu").click(function(event) {
		// 	console.log("menu click s-process-menu-actions");
		// }).appendTo($$mainMenuSlot);

		var $$page = $('<div>').attr("id", "page").appendTo($$div);
		// $$page.bind("mouseenter.buttons mouseleave.buttons", function(event) {
		// 	// $$page.bind("mouseenter mouseleave", function(event){
		// 	$$mainMenuSlot[0].style.visibility = event.type == "mouseenter" ? "visible" : "hidden";
		// });

		this.$$container = $$page;

		// $('<div>').attr("id", "fenetreTechnique").addClass("s-process-hidden s-process-fenetreImportExport") //
		// .appendTo($$div).append('<div id="entetedivflottantFT">') //
		// .append($('<div id="DivDockToolBar"').addClass("s-process-DivDockToolBar")) //
		// .append('<div id="divSousMenu">');
		var technicPart = '<div id="fenetreTechnique" class="s-process-hidden s-process-fenetreImportExport">   \
            <div id="entetedivflottantFT"></div>    \
            <div id="DivDockToolBar" class="s-process-DivDockToolBar">    \
                <div id="menuprincipal" class="s-process-menuprincipal">    \
                    <a id="titreMenuPrincipal" class="s-process-titreMenuPrincipal">Fichier</a>  \
                </div>  \
            </div>  \
            <div id="divSousMenu class="s-process-divSousMenu">  \
                <a class="sousMenuItem" id="importLink">Importer...</a> \
                <a class="sousMenuItem" id="exportLink">Exporter en texte...</a>    \
            </div>  \
        </div>';
		$(technicPart).appendTo($$div);

		// <!--pop-up "fenêtre Importer"-->
		var importPopup = '<div id="import" class="s-process-fenetreImportExport s-process-hidden"> \
        <div id="enteteImport" class="s-process-enteteFenetreImportExport"></div>         \
            <p>Collez vos donn&eacute;es ici :</p>  \
            <div>   \
                <textarea id="textAreaImport" class="s-process-textAreaImportExport"></textarea>  \
            </div>  \
            <div>   \
                <button id="btnValiderImport" class="s-process-btnFT">OK</button> \
                <button id="btnAnnulerImport" class="s-process-btnFT">Annuler</button>    \
            </div>  \
        </div>';
		$(importPopup).appendTo($$div);

		// <!--pop-up "fenêtre Exporter"-->
		var exportPopup = '<div id="export" class="s-process-fenetreImportExport s-process-hidden"> \
            <div id="enteteExport" class="s-process-enteteFenetreImportExport"></div> \
            <p>Vos donn&eacute;es :</p> \
            <div>   \
                <textarea id="textAreaExport" class="s-process-textAreaImportExport"></textarea>  \
            </div>  \
            <div>   \
                <button id="btnValiderExport" class="s-process-btnFT">OK</button> \
            </div>  \
        </div>';
		$(exportPopup).appendTo($$div);

		// <!-- pop up message et traces -->
		var messagePopup = '<div id="msgEtTraces" class="s-process-hidden">   \
            <div id="enteteMsgEtTraces" class="s-process-enteteMsgEtTraces">    \
                <div id="titreMsgEtTraces" class="s-process-left"> Vos messages </div>    \
                <div id="divFermer" class="s-process-left"><img id="imageFermerMessageTrace" src="' + imagesRoot + '/fermer.png" width="20" height="20" alt="fermer"> </div> \
                <div style="clear:both"></div>  \
            </div>  \
            <div>   \
                <div id="divTextAreaMsgEtTraces" class="s-process-left">  \
                    <textarea  id="textAreaMsgEtTraces" class="s-process-textAreaMsgEtTraces" readonly="readonly"></textarea> \
                </div>  \
                <div id="actions" class="s-process-left"> \
                    <div class="s-process-divAction" id="btnMsg"> Messages </div> \
                    <div class="s-process-divAction" id="btnDetail"> Détail </div>    \
                    <div class="s-process-divAction" id="btnTrace"> Trace </div>  \
                    <div class="s-process-divAction" id="btnCopier"> Copier </div>    \
                </div>  \
                <div style="clear:both"></div>  \
            </div>  \
        </div>';
		$(messagePopup).appendTo($$div);

		// <!-- pop up echange de donnees -->
		var exchangePopup = '<div id="divCadreEchangesDeDonnees" class="s-process-hidden s-process-divCadreEchangesDeDonnees">    \
            <div id="divContenuEchangesDeDonnees" class="s-process-divContenuEchangesDeDonnees">  \
                <textarea  id="textAreaContenuEchangesDeDonnees" class="s-process-textAreaContenuEchangesDeDonnees" readonly="readonly"></textarea>    \
            </div>  \
        </div>';
		$(exchangePopup).appendTo($$div);

		var contextMenu = '<ul id="myMenu" class="s-process-contextMenu"> \
            <li ><a href="#echangeDonnee">Echanges de donnees</a></li>  \
            <li class="cut"><a href="#messageEtTrace">Messages et trace</a></li>    \
            <li class="copy separator"><a href="#fenetreTechnique">Montrer/cacher fenetre technique</a></li>    \
        </ul>';
		$(contextMenu).appendTo($$div);


		/*******************************************************
		 *	Chargement du contenu de la page en JSon dans le pop up "exporter"
		 *******************************************************/
		$("#exportLink").click(function(event) {
			showPopUp('export');
			$('#textAreaExport').text(options.process && options.process.getJson());
			$('#textAreaExport').select();
		});

		/*******************************************************
		 *	Affichage du popup "import"
		 *******************************************************/
		$('#importLink').click(function(event)  {
			showPopUp('import');
		});

		/*******************************************************
		 *	Fermeture de la fenêtre message et trace avec un click sur l'image de fermeture
		 *******************************************************/
		$("#imageFermerMessageTrace").hover(function() {
			$(this).attr('src', imagesRoot + '/fermerHover.png');
		}, function() {
			$(this).attr('src', imagesRoot + '/fermer.png');
		}).click(function() {
			$("#msgEtTraces").toggle();
		});

		/*******************************************************
		 *	Gestion du menu de la fenetre technique
		 *******************************************************/
		$("#menuprincipal").click(function(event) {

			if ($("#menuprincipal").hasClass('orangebackground')) {
				$("#menuprincipal").removeClass('orangebackground');
			} else {
				$("#menuprincipal").addClass('orangebackground');
				$("#divSousMenu").toggle();

				//empeche le declenchement du listener qui suit
				event.stopPropagation();

				//Ajout d'un listener de click sur toute la page qui ferme le menu						
				$('#body').bind('click', function() {
					$("#menuprincipal").removeClass('orangebackground');
					$("#divSousMenu").toggle();
					//suppression du listener une fois celui ci utilisé
					$('#body').unbind('click');
				});
			}
		});

		/*******************************************************
		 *	Gestion des boutons de importer/exporter
		 *******************************************************/
		$("#btnValiderExport").click(function() {
			$('#export').jqmHide();
			$('#export').removeClass('montrer');
		});
		$("#btnAnnulerImport").click(function() {
			$('#import').jqmHide();
			$('#import').removeClass('montrer');
		});
		$('textarea').disableContextMenu();

		/*******************************************************
		 *	Gestion de l'import quand on entre le json à la main
		 *******************************************************/
		$('#btnValiderImport').click(function() {
			// on recupere le json … 
			var jsonTxt = $('#textAreaImport').val();
			if (jsonTxt != "") {
				// … et on le charge
				self.options.process && self.options.process.loadJson(jsonTxt);
				// on verifie ensuite que le json est importé, pour vérifier qu'il n'avait pas d'erreur.
				// donc getJson() doit renvoyé le même contenu que l'import
				self.options.process && self.options.process.loadJson(jsonTxt);
				if (self.options.process && (self.options.process.getJson() == jsonTxt))  {

					// et on affiche tous les nouveaux
					self.clear().show();
					// sageInitPage($.sageJSON.getPageInfo()).sageDisplayPlayer($.sageJSON.getFormes());
					// on vide le textarea 
					$('#textAreaImport').val('');

					// et on ferme la fenêtre					
					$('#import').jqmHide();
					$('#import').removeClass('montrer');

				} else {

					// si ça ne correspond pas, on affiche un petit popup
					alert("Le JSON importé n'est pas valide");
				}
			}
		});

		/*******************************************************
		 *	Fenetre echange de données
		 *******************************************************/
		//Cacher la fenetre echange de donnée avec un clic sur la bordure
		$("#divContenuEchangesDeDonnees").click(function(event) {
			event.stopPropagation();
		});
		$("#divCadreEchangesDeDonnees").click(function() {
			$("#divCadreEchangesDeDonnees").hide();
		});

		/*******************************************************
		 *	Definition des draggable pour les popups
		 *******************************************************/
		$("#msgEtTraces").draggable({
			containment: "body",
			scroll: false,
			handle: "#titreMsgEtTraces"
		});
		$("#fenetreTechnique").draggable({
			containment: "body",
			scroll: false
		});
		$("#import").draggable({
			containment: "body",
			scroll: false,
			handle: "#enteteImport"
		});
		$("#export").draggable({
			containment: "body",
			scroll: false,
			handle: "#enteteExport"
		});

		/***************************************************
		 *        Affichage des traces
		 *******************************************************/
		$('#btnTrace').click(function(event) {
			$('#textAreaMsgEtTraces').val(txtTrace);
		});

		/***************************************************
		 *        Affichage des messages
		 *******************************************************/
		$('#btnMsg').click(function(event) {
			$('#textAreaMsgEtTraces').val(txtMsg);
		});

		$$page.css('height', pageInfoJson.contentSize.xheight + 'px').css('width', pageInfoJson.contentSize.xwidth + 'px').css('top', pageInfoJson.docDims.xtop).css('left', pageInfoJson.docDims.xtop);

		return this;
	},
	show: function() {
		var self = this,
			$$container = this.$$container,
			formesListe = self.options && self.options.process && self.options.process.getFormes();
		/**
		 *	Fait la transition entre le "bibid" disponible dans le json, et le nom de la bibliotheque présent dans le fichier sgx_libsinfo.txt
		 *	@return	string	le nom du fichier de la bibliotheque sans l'extension
		 */
		// on parcours les groupes
		for (var groupNum = 0, sizeG = formesListe.length; groupNum < sizeG; groupNum++) {
			var group = formesListe[groupNum];

			// on parcours les formes 
			for (var formNum = 0, sizeF = group.xpropsArr.length; formNum < sizeF; formNum++) {
				var forme = group.xpropsArr[formNum];

				// si c'est une image 
				if (forme.xshapeType == 'clipshape') {

					if (forme.xlinkProps.xcode != '') {
						$$container.append('<a id="' + forme.uniqueID + 'ai"><img id="' + forme.uniqueID + '" />');
					} else {
						$$container.append('<img id="' + forme.uniqueID + '" />');
					}

					//mettre un lien sur l'image qui en contient un
					$('#' + forme.uniqueID + 'ai')
					//.addclass(elementJSON)
					.attr('href', forme.xlinkProps.xcode);
					// pour selectionner l'image (ou peu importe la balise) il suffit de selectionner l'id uniqueId
					$('#' + forme.uniqueID).attr('src', imagesRoot + '/' + getBibName(forme.bibid) + '/' + forme.eltid + '.png').attr('alt', 'float:left;').css('position', 'absolute').css('width', forme.xsize.xwidth).css('height', forme.xsize.xheight).css('top', forme.xcenter.y - forme.xsize.xheight / 2 + 'px').css('left', forme.xcenter.x - forme.xsize.xwidth / 2 + 'px').css('z-index', forme.xlevel).css('filter', 'alpha(opacity=' + forme.alpha + ')').css('-moz-opacity', forme.alpha + '/100').css('-khtml-opacity', forme.alpha + '/100').css('opacity', forme.alpha + '/100');
					// $('#' + forme.uniqueID).attr('src', imagesRoot + '/' + getBibName(forme.bibid) + '/' + forme.eltid + '.png').attr('alt', 'float:left;').css('position', 'relative').css('width', forme.xsize.xwidth).css('height', forme.xsize.xheight).css('top', forme.xcenter.y - forme.xsize.xheight / 2 + 'px').css('left', forme.xcenter.x - forme.xsize.xwidth / 2 + 'px').css('z-index', forme.xlevel).css('filter', 'alpha(opacity=' + forme.alpha + ')').css('-moz-opacity', forme.alpha + '/100').css('-khtml-opacity', forme.alpha + '/100').css('opacity', forme.alpha + '/100');
					//transparence de l'image pour les principaux navigateurs
				}

				/************** Traitement des formes géométrique et de bezier ***********************/
				else if (forme.xshapeType == 'apishape' || forme.xshapeType == 'beziershape') { // Déclaration de variables
					var type = "path";
					var tAttr = new Array();
					var dDefs;
					var linearGradientDef;
					var radialGradientDef;
					var tabStop = new Array();

					if (forme.xdrawBehaviorCode == "K_API_LINE") {
						type = "line";
						tAttr["x1"] = forme.xanchors[0].x;
						tAttr["y1"] = forme.xanchors[0].y;
						tAttr["x2"] = forme.xanchors[2].x;
						tAttr["y2"] = forme.xanchors[2].y;
						tAttr["stroke-linecap"] = "round";
					} else if (forme.xdrawBehaviorCode == "K_API_RECT") {
						var strAttr = "M" + forme.xanchors[0].x + " " + forme.xanchors[0].y;
						for (var j = 1; j < forme.xanchors.length; j++) {
							strAttr += " L" + forme.xanchors[j].x + " " + forme.xanchors[j].y;
						}
						strAttr += " Z";
						tAttr["d"] = strAttr;
					} else if (forme.xdrawBehaviorCode == "K_API_ELLIPSE" || forme.xdrawBehaviorCode == "K_BZ_ELLIPSE" || (forme.xdrawBehaviorCode == "K_BZ_POLY" && (Math.abs(forme.xanchors[0].x - forme.xanchors[0].c1x) > 0.1 || Math.abs(forme.xanchors[0].y - forme.xanchors[0].c1y) > 0.1))) {
						type = "ellipse";
						var Ax = forme.xanchors[0].x;
						var Ay = forme.xanchors[0].y;
						var Bx = forme.xanchors[1].x;
						var By = forme.xanchors[1].y;
						var Cx = forme.xanchors[2].x;
						var Cy = forme.xanchors[2].y;
						var Dx = forme.xanchors[3].x;
						var Dy = forme.xanchors[3].y;

						tAttr["cx"] = Ax + Math.abs((Ax - Bx) / 2) + Math.abs((Ay - Dy));
						tAttr["cy"] = Ay + Math.abs((Ay - Dy) / 2) - Math.abs((Ax - Bx) / 4);
						tAttr["rx"] = Math.abs((Ax - Bx));
						tAttr["ry"] = Math.abs((Ay - Dy));
					} else if (forme.xanchors.length > 0) { //On dessine les autres formes de Bezier
						var strAttr = "M" + forme.xanchors[0].x + " " + forme.xanchors[0].y;
						var nb = forme.xanchors.length;
						if (forme.xdrawBehaviorCode == null) {
							for (var j = 1; j < nb; j++) {
								strAttr += " C" + forme.xanchors[j - 1].c2x + " " + forme.xanchors[j - 1].c2y + " " + forme.xanchors[j % nb].c1x + " " + forme.xanchors[j % nb].c1y + " " + forme.xanchors[j % nb].x + " " + forme.xanchors[j % nb].y;
							}
						} else {
							for (var j = 1; j <= nb; j++) {
								strAttr += " C" + forme.xanchors[j - 1].c2x + " " + forme.xanchors[j - 1].c2y + " " + forme.xanchors[j % nb].c1x + " " + forme.xanchors[j % nb].c1y + " " + forme.xanchors[j % nb].x + " " + forme.xanchors[j % nb].y;
							}
						}
						if (forme.xclosed == true) {
							strAttr += " Z";
						}
						tAttr["d"] = strAttr;
					}
					if (forme.xshapeType == 'beziershape' && forme.xclosed == true) {
						strAttr += " Z";
					}
					tAttr["d"] = strAttr;

					// Ajout du trait de contour
					var stroketype = forme.xstrokeProps.xtype;
					if (stroketype == "none" || stroketype == "nostroke") {
						tAttr["stroke"] = "none";
					} else {
						tAttr["stroke"] = getHexadecimalColor(forme.xstrokeProps.xcolor);
						tAttr["stroke-opacity"] = forme.xstrokeProps.xalpha / 100;
						tAttr["stroke-width"] = forme.xstrokeProps.xthickness;
						if (stroketype != 'solidstroke') {
							if (stroketype == 'dottedstroke') {
								strAttr = "" + 2 * forme.xstrokeProps.xthickness + "," + 2 * forme.xstrokeProps.xthickness;
							} else if (stroketype == 'dashedstroke') {
								strAttr = "" + 5 * forme.xstrokeProps.xthickness + "," + 5 * forme.xstrokeProps.xthickness;
							}
							tAttr["stroke-dasharray"] = strAttr;
						}
					}
					//Arrondir les bords des formes a l'exception des lingnes bezier
					if (forme.xdrawBehaviorCode != "K_BZ_LINE") {
						tAttr["stroke-linejoin"] = "round";
					}
					if (forme.xlinkProps.xtype != "none") {
						tAttr["style"] = "cursor:pointer";
						tAttr["onclick"] = "window.open('" + forme.xlinkProps.xcode + "')";
					}

					// Remplissage de la forme
					var filltype = forme.xfillProps.xtype;
					if (filltype == "nofill") {
						tAttr["fill"] = "none";
					} else if (filltype == "solidfill") {
						tAttr["fill"] = getHexadecimalColor(forme.xfillProps.xcolor);
						tAttr["fill-opacity"] = forme.xstrokeProps.xalpha / 100;
					}
					//Gestion du dégradé
					else if (filltype == "gradientfill") {
						var gradientType = forme.xfillProps.xgtype;
						//Dégradé linéaire						
						if (gradientType == "linear") {
							dDefs = makeSVG("defs", {});
							var tabCoord = uiHelper.calculDegrade(forme.xfillProps.xgrotation);

							linearGradientDef = makeSVG("linearGradient", {
								id: "grad" + forme.uniqueID,
								x1: tabCoord.x1 + "%",
								y1: tabCoord.y1 + "%",
								x2: tabCoord.x2 + "%",
								y2: tabCoord.y2 + "%"
							});
							for (var i = 0; i < forme.xfillProps.xgcolors.length; i++) {
								tabStop[i] = makeSVG("stop", {
									offset: forme.xfillProps.xgratios[i] / 245.82 * 100 + "%",
									style: "stop-color:" + getHexadecimalColor(forme.xfillProps.xgcolors[i]) + ";stop-opacity:" + forme.xfillProps.xgalphas[i] / 100 + ";"
								});
							}
							tAttr["fill"] = "url(#grad" + forme.uniqueID + ")";
						}
						//Dégradé radial
						else if (gradientType == "radial") {
							dDefs = makeSVG("defs", {});
							radialGradientDef = makeSVG("radialGradient", {
								id: "grad" + forme.uniqueID,
								cx: "50%",
								cy: "50%",
								r: "50%",
								fx: "50%",
								fy: "50%"
							});
							for (var i = 0; i < forme.xfillProps.xgcolors.length; i++) {
								tabStop[i] = makeSVG("stop", {
									offset: forme.xfillProps.xgratios[i] / 245.82 * 100 + "%",
									style: "stop-color:" + getHexadecimalColor(forme.xfillProps.xgcolors[i]) + ";stop-opacity:" + forme.xfillProps.xgalphas[i] / 100 + ";"
								});
							}
							tAttr["fill"] = "url(#grad" + forme.uniqueID + ")";
						}
					} else if (filltype == "patternfill") {
						//TODO
					}
					//Insertion de la forme dans la page
					var baliseSVG = "<svg height='900' width='900' id='" + forme.uniqueID + "' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'>";
					$$container.append(baliseSVG).append("</svg>");
					var svg_shape = makeSVG(type, tAttr);
					if (!$.isEmptyObject(linearGradientDef)) {
						$("#" + forme.uniqueID).append(dDefs);
						$("#" + forme.uniqueID + " defs").append(linearGradientDef);
						for (var i = 0; i < tabStop.length; i++) {
							$("#grad" + forme.uniqueID).append(tabStop[i]);
						}
					} else if (!$.isEmptyObject(radialGradientDef)) {
						$("#" + forme.uniqueID).append(dDefs);
						$("#" + forme.uniqueID + " defs").append(radialGradientDef);
						for (var i = 0; i < tabStop.length; i++) {
							$("#grad" + forme.uniqueID).append(tabStop[i]);
						}
					}
					$("#" + forme.uniqueID).append(svg_shape);
					$("#" + forme.uniqueID).wrap("<div style='position:absolute;width:100%;height:100%;z-index:" + forme.xlevel + ";'></div>");
					// $("#" + forme.uniqueID).wrap("<div style='position:relative;width:100%;height:100%;z-index:" + forme.xlevel + ";'></div>");
					if (forme.xlinkProps.xtype != "none") {
						$("#" + forme.uniqueID).wrap("<a href=" + forme.xlinkProps.xcode + "></a>");
					}
				} // fin traitement formes gométriques et de bezier
				//Gestion affichage du texte
				if (forme.xtext != "") {
					// on affiche la zone texte SEULEMENT si on a du texte 
					$$container.append('<div id="' + forme.uniqueID + 'p">' + forme.xtext + '</div>');

					// on supprime le style défini dans le JSON
					var text = "";
					$('#' + forme.uniqueID + 'p > textformat').each(

					function() {
						$(this).find('p > font').each(

						function() {
							//remplace les données du flash avec l'url du lien dans l'attribut href
							$(this).find('a').each(

							function() {
								$(this).attr("href", parseLien($(this).attr("href")));
							});
							text += $(this).html() + '<br />';
						});

						$(this).find('li > font').each(

						function() {
							//remplace les données du flash avec l'url du lien dans l'attribut href
							$(this).find('a').each(

							function() {
								$(this).attr("href", parseLien($(this).attr("href")));
							});
							text += '&bull; ' + $(this).html() + '<br />';
						});


					});

					//paramétrage du texte
					$('#' + forme.uniqueID + 'p').html(text);

					$('#' + forme.uniqueID + 'p').css('position', 'absolute')
					// $('#' + forme.uniqueID + 'p').css('position', 'relative')
					//
					.css('text-align', forme.xtextFormat.align).css('word-spacing', forme.xtextFormat.kerning) //todo : chercher correspondance de kerning en css
					.css('display', forme.xtextFormat.display).css('letter-spacing', forme.xtextFormat.letterSpacing + 'px')
					//.css('bullet',forme.xtextFormat.bullet)
					.css('tab-stops', forme.xtextFormat.tabStops).css('text-indent', forme.xtextFormat.blockIndent + 'px')
					//.css('line-height',forme.xtextFormat.leading)
					.css('padding-left', forme.xtextFormat.indent + 'px').css('margin-right', forme.xtextFormat.rightMargin + 'px').css('margin-left', forme.xtextFormat.leftMargin + 'px').css('text-decoration', forme.xtextFormat.underline).css('italic', forme.xtextFormat.italic).css('font-weight', forme.xtextFormat.bold).css('target', forme.xtextFormat.target).css('color', getHexadecimalColor(forme.xtextFormat.color)).css('font-size', forme.xtextFormat.size + 'px').css('font-family', forme.xtextFormat.font).css('z-index', forme.xlevel)
					//.css('font-weight',forme.xcaptionProps.xsizingMode)		// font-weight déjà utilisé
					.css('vertical-align', forme.xcaptionProps.xvertAlignMode).css('left', forme.xcaptionPos.xleft).css('top', forme.xcaptionPos.xtop).css('width', forme.xcaptionSize.xwidth - forme.xtextFormat.rightMargin - forme.xtextFormat.leftMargin + 'px').css('height', forme.xcaptionSize.xheight);
				} //fin traitement texte
			} // fin boucle forme
		} // fin boucle groupes
		return this;
	},
	clear: function() {
		this.$$container.empty();
		return this;
	}
});

/**
 *	Variables globales
 */
//variable stockant la ou les traces
var txtTrace = "a";
//variable stockant les messages
var txtMsg = "b";
//variable stockant le ou les échange de données
var traceEchData = "c";
// variable qui conserve l'ensemble des correspondances bibid 
var bibCorrespondance;


/**
 *	fonctions
 */
/*Permet de remplir la variable txtTrace*/

function laisseTrace(newTrace) {
	txtTrace += "\n\r" + newTrace;
} /*Permet de remplir la variable txtMsg*/

function laisseMsg(newMsg) {
	txtMsg = newMsg;
}

/*Permet de remplir la variable traceEchData*/

function traceAlert(amsg) {
	//cette fonction ne comprend pas le test relatif à xtraceType la variable n'étant pas implémenter dans notre prototype
	//amsg est aussi tracé
	laisseTrace(amsg)
	//test portant sur la longueur de la variable traceEchData 
	if (traceEchData.length > 159000) {
		if (traceEchData.length < 159400) {
			traceEchData += ". ";
		}
		return;
	}
	//MAJ de la variable traceEchData avec l'ajout du nouveau message amsg
	traceEchData += "\n\r" + amsg;
}

/*
 * Montre / Cache pop up modal
 */

function showPopUp(divID) {
	// $("#" + divID).jqm({
	// 	overlay: 10,
	// 	modal: true
	// });
	// $("#" + divID).jqmShow();
	// $("#" + divID).addClass("montrer");
}

//Permet de construire correctement un élément svg dans la page html

function makeSVG(tag, attrs) {
	var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
	for (var k in attrs) {
		el.setAttribute(k, attrs[k]);
	}
	return el;
}

//Récupère le code hexadecimal de la couleur à partir du code décimal

function getHexadecimalColor(str) {
	if (typeof str == 'undefined') {
		str = 0;
	}
	var hex = Number(str).toString(16);
	hex = "#000000".substr(0, 7 - hex.length) + hex;
	return hex.toUpperCase();
}

function getBibName(bibid) {
	var json = "";
	var response = $.ajax({
		type: 'get',
		url: libInfoRoot + '/sgx_libsinfo.txt',
		dataType: 'json',
		async: false
	});

	// status 200 = OK
	if (response.status == 200) {
		try {
			json = $.parseJSON(response.responseText);
		} catch (e) {
			// si le parse ne fonctionne pas, on renvoie une chaine vide.
			return "";
		}
	}

	// si bibCorrespondance est vide, on le remplit d'abord
	if (bibCorrespondance == null) {
		bibCorrespondance = {};
		// On parcours la liste des librairies
		for (var libNum = 0, sizeL = json.libsinfo.length; libNum < sizeL; libNum++) {
			var bibList = json.libsinfo[libNum].biblist;

			// on parcours la liste 
			for (var bibNum = 0, sizeB = bibList.length; bibNum < sizeB; bibNum++) {
				var bib = bibList[bibNum];

				bibCorrespondance[bib.bibid] = bib;
			}
		}
	}

	return (typeof bibCorrespondance[bibid] !== 'undefined' && bibCorrespondance[bibid].bibfilename !== null) ? bibCorrespondance[bibid].bibfilename.replace(/\.swf/, "") : "";
};

function parseLien(chaine) {
	var chaineParse = ""
	if (chaine.indexOf("erpfunc", 0) > -1) {} // lien vers une fonction erp //non géré
	if (chaine.indexOf("link", 0) > -1) { //lien de type URL
		var temp = chaine.replace(/.*xcode%22.*?%22(.*?)%22.*?%22xtype.*/, "$1"); //la chaine a parser se situe entre xcode et xtype
		//remplace l'encodage
		temp = temp.replace(/%3A/g, ":");
		temp = temp.replace(/%2F/g, "/");
		temp = temp.replace(/%2E/g, ".");
		chaineParse = temp;
	}
	return chaineParse;
}