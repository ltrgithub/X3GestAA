"use strict";
var helpers = require('syracuse-core/lib/helpers');
var cubeHelper = require('syracuse-ui/lib/desktop/field/cube/cubeHelper');
var Article = require("syracuse-ui/lib/desktop/article/article").Article;
var TabularChartAuthoring = require("./authoring/tabularChartAuthoring").TabularChartAuthoring;
require('syracuse-ui/deps/highcharts/highcharts');
require('syracuse-ui/deps/highcharts/modules/exporting');
require('syracuse-ui/themes/desktop/sage/highcharts/theme');
var forEachKey = helpers.object.forEachKey;
var objectCopy = helpers.object.copy;
var objectClone = helpers.object.clone;

var _localize = {
    area: "area",
    areaspline: "area spline",
    bar: "bar",
    column: "column",
    line: "line",
    pie: "pie",
    scatter: "scatter",
    spline: "spline",
    seriesType: "Serie Name",
    chartType: "Chart Type",
    drillUp: "Drill Up",
    clickToDrill: "Click to drill down"
};

var _chartStyles = [_localize.area, _localize.areaspline, _localize.bar, _localize.column, _localize.line, /*_localize.pie,*/ _localize.scatter, _localize.spline];
var _styleMap = {
    point: "scatter",
    stick: "column"
};

var _merge = function() {
        var args = arguments;
        return $.extend(true, null, args[0], args[1], args[2], args[3]);
    };

var _formatApi = require('syracuse-ui/lib/desktop/field/formatApi');

function _createChoices(title, items) {
    return {
        $type: "application/x-choice",
        $title: title,
        $value: {
            $type: "application/x-string",
                $enum: items.map(function(item) {
                    return typeof(item) === "string" ? {
                        $value: item,
                        $title: _localize[item] || item
                    } : {
                        $value: item.$value,
                        $title: item.$title || _localize[item.$value] || item.$value
                    }
                })
        }
    };
};

// TODO: 
// - event management
// - dynamic loading of series

function ToolBox() {};

exports.ToolBox = helpers.defineClass(ToolBox, Article, {
    onNotifyRecordChange: function(value, binding) {
        if (binding === "$choices$series") {
            console.log("select " + value);
        } else if (binding === "$choices$chartType") {
            this.handlers && this.handlers.serieStyleChange && this.handlers.serieStyleChange.call(null, value);
        }
        return null; //cancel notify
    },
    bind: function(handlers) {
        this.handlers = handlers;
    },
    load: function(chart, $boxItem) {
        var self = this;
        self.$prototype = {
            "$properties": {
/*              $choices$series: _createChoices(_localize.seriesType, [{
                 $value: "number1",
                 $title: "Number 1"
                 }, {
                 $value: "number2",
                 $title: "Number 2"
                 }, {
                 $value: "number3",
                 $title: "Number 3"
                 }, {
                 $value: "number4",
                 $title: "Number 4"
                 }]),*/
                $choices$chartType: _createChoices(_localize.chartType, ["area", "areaspline", "bar", "column", "line", "pie", "scatter", "spline"])
            },
            $links: {
                $drillUp: {
                    $title: _localize.drillUp
                }
            },
            // $isTitleHidden: false,
            // $choices$series: "number1",
            $choices$chartType: "column"
        };

        document.itemFactory.initializeItem(self, {
            $category: "section",
            $bind: "$box",
            $isBorderVisible: true,
            $skin: "s-chart-toolbar-item",
            $layout: {
                $layoutType: "side",
                $layoutCss: "s-chart-toolbar-item-side",
                $items: [{
                    $category: "block",
                    // $title: "Size",
                    $layout: {
                        $layoutType: "side",
                        $items: [
/*{
                         $bind: "$choices$series",
                         $isEditMode: true,
                         // $isTitleHidden: true,
                         $labelWidth: "auto",
                         $css: "s-chart-toolbar-field",
                         $format: "$combo"
                         }, */
                        {
                            $bind: "$choices$chartType",
                            $isEditMode: true,
                            $isTitleHidden: true,
                            $labelWidth: "auto",
                            $css: "s-chart-toolbar-field",
                            $format: "$combo"
                        }, {
                            $bind: "$drillUp",
                            // $skin: "s-chart-toolbar-link",
                            $css: "s-chart-toolbar-field-link",
                            $category: "link"
                        }]
                    }
                }]
            }
        }, chart);
        self.$$container = chart.$$container;
        self.loadBox($boxItem);
        self.menuItems.$drillUp[0].onMenuClick = function() {
            self.handlers && self.handlers.drillUp && self.handlers.drillUp.call(null, null);
            return false;
        };
        self.menuItems.$drillUp[0].hide(true);
    },
    show: function(opt) {
        var self = this;
        // this.$$bar && this.$$bar.show();
        if (opt) {
            opt = _merge(self.state, opt);
/*          opt.series && self.$$series && self.$$series.show();
             opt.chartTypes && self.$$chartTypes && self.$$chartTypes.show();*/
        }
    },
    hide: function(opt) {
        var self = this;
        if (opt) {
            opt = _merge(self.state, opt);
/*          opt.series && self.$$series && self.$$series.hide();
             opt.chartTypes && self.$$chartTypes && self.$$chartTypes.hide();*/
        } else {
            // this.$$bar && this.$$bar.hide();
        }
    },
    addSeries: function(choices) {
/*      var self = this;
         choices = Array.isArray(choices) ? choices : ( !! choices ? [choices] : []);
         choices.map(function(choice) {
         $("<option />").attr("value", choice.id).text(choice.title).appendTo(self.$$series);
         });*/
    },
    removeAllSeries: function() {
        // this.$$series && this.$$series.empty();
    },
    selectSerie: function(val) {
        // this._selectChoice(this.$$series, val);
    },
    selectChartType: function(val) {
        // this._selectChoice(this.$$chartTypes, val);
    },
    _selectChoice: function($$obj, val) {
        // $$obj && $$obj.children('option[value="' + val + '"]').attr("selected", "selected");
    },
    showDrillUp: function(show) {
        this.menuItems.$drillUp[0].hide(!show);
    },
});

function RecordArticle() {};

exports.RecordArticle = helpers.defineClass(RecordArticle, Article, {
    drawBox: function() {
        document.itemFactory.load($("<div style='display:none'/>").appendTo(this.boxParent.$$container), {
            $category: "links"
        }, this);
    },
});

function TabularChart() {}

exports.TabularChart = helpers.defineClass(TabularChart, Article, {
    applyDesignMetaData: function(metadata, onAuthoring) {
        var self = this;
        if (metadata.$chartType !== undefined) {
            self.$item.$chartType = metadata.$chartType;
            forEachKey(self._meta.series, function(key, s) {
                var series = self._chart.get(s.options.id);
                self._setType(series, self.$item.$chartType);
            });
            self._chart.redraw();
        }
    },
    _createChoices: function() {
        return _createChoices(_localize.chartType, ["area", "areaspline", "bar", "column", "line", "pie", "scatter", "spline"]);
    },
    getAuthoringWidget: function() {
        return new TabularChartAuthoring();
    },
    drawBox: function() {
        var self = this;
        var id = 'highcharts_' + self.id;
        (self._toolBox = new ToolBox()).load(self, self.boxParent);
        self._toolBox.bind({
            serieChange: function(id) {
                self._chart.series.map(function(s) {
                    s.hide();
                });
                self._chart.get(id).show();
            },
            serieStyleChange: function(type) {
                forEachKey(self._meta.series, function(key, s) {
                    var series = self._chart.get(s.options.id);
                    self._setType(series, type);
                });
                self._chart.redraw();
            },
            drillUp: function() {
                self._drill(null, true);
            },
        });

        $('<div />').attr('id', id).appendTo(self.$$container);

        var proto = self.$prototype;
        // create an alias
        proto.$properties = proto.$item.$properties;

        var options = _merge(self._getPref(), self._getOptions(id, proto));
        // cubeHelper._initializeMeta(self);
        self._initializeMeta();
        self._initializeToobar();
        self._chart = new Highcharts.Chart(options);
        self.getArticleParent().bind(self, self.$item.$bind);
    },
    setDataBind: function(value, record, metaData) {
        //this.value = value;
        if (metaData) {
            this._processMeta(metaData);
        }
        if (value) {
            var self = this;
            var settings = value.reduce(function(res, current) {
                var categoryName = self._getMeasureLabel(current, self._meta.xAxis[0].code);
                categoryName && res.categories.push(categoryName);
                forEachKey(self._meta.series, function(key, s) {
                    var serie = res.series[key];
                    if (serie == null) {
                        serie = objectClone(s.options);
                        serie.data = [];
                        res.series[key] = serie;
                    }
                    serie.data.push(parseFloat(current[key]));
                });
                return res;
            }, {
                categories: [],
                series: {}
            });

            self._chart.xAxis[0].setCategories(settings.categories, false);

            // todo use series.setData
            // remove all current series
            var series = self._chart.series;
            for (var i = series.length; i > 0; i--) {
                // for (var i = 0; i < series.length; i++) {
                series[0].remove(false);
                // series[i].setData(settings.series[series[i].options.id.slice(3)].data);
            }
            self._toolBox.removeAllSeries();

            //add series
            forEachKey(self._meta.series, function(key, s) {
                self._chart.addSeries(settings.series[key], false);
                self._toolBox.addSeries({
                    id: s.options.id,
                    title: s.options.name
                });
            });
/*          
             var size = self.$$container.innerWidth();
             self._chart.setSize(size);
             */
            setTimeout(function() {
                var size = self.$$container.innerWidth();
                self._chart.setSize(size);
                // self._chart.redraw();
            }, 100);
        }
    },
    _getOptions: function(id, proto) {
        var self = this;
        var cube = this.$prototype.$cube;

        var options = {
            chart: {
                renderTo: id,
                marginRight: 150
            },
            legend: {
                align: 'right',
                verticalAlign: 'top',
                x: 0,
                y: 130,
/*              align: 'center',
                 verticalAlign: 'bottom',
                 x: 0,
                 y: 0,*/
                // floating: true
            },
            title: (cube && cube.$title) || '',
            xAxis: [{
                categories: [],
                title: {
                    text: proto.$axes && proto.$axes.length > 0 && proto.$axes[0].$title
                }
            }],
            yAxis: [{
                min: 0,
                title: {
                    text: ''
                }
            }],
            plotOptions: {
                series: {
                    cursor: 'pointer',
                    point: {
                        events: {
                            click: function(event) {
                                // no longer drill up if shiftKey is pressed
                                if (!event.shiftKey) self._drill(this, event.shiftKey);
                            }
                        }
                    }
                }
            },

            tooltip: {
                formatter: function() {
                    var measure = self._meta.series[this.series.options.id.slice(3)].measure;
                    var label = '' + this.x + ': <b> ' + (measure ? measure.formatApi.format(this.y, measure.localeFormat) : this.y) + '</b>';
                    var data = this.series.processedYData;
                    if (measure && (measure.$isNormalized) && data.length > 0) {
                        var sum = data.reduce(function(a, b) {
                            return a + b;
                        });
                        label += ' (' + measure.formatApi.format(this.y / sum * 100, measure.localeFormat) + '%)';
                    }
                    label += '<br/><span style="font-size: 10px; font-style:italic;">' + _localize.clickToDrill + '</span>'
                    // label += '<br/><span style="font-size: 10px; font-style:italic;">' + _localize.clickToDrill + '</span><br/><span style="font-size: 10px; font-style:italic;">Shift+Click to drill up</span>'
                    return label;
/*  var items = this.points || splat(this),
                     series = items[0].series,
                     s;
                     // build the header
                     s = [series.tooltipHeaderFormatter(items[0].key)];
                     // build the values
                     items.map(function(item) {
                     series = item.series;
                     s.push((series.tooltipFormatter && series.tooltipFormatter(item)) || item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
                     });
                     // footer
                     s.push(options.footerFormat || '');
                     return s.join('');*/
                }
            },
            series: []
        };

        if (options.xAxis[0].title.text != options.title) {
            options.xAxis[0].title.text = options.title + ' / ' + options.xAxis[0].title.text;
        }

        return options;

    },
    _initializeMeta: function() {
        var proto = this.$prototype;
        var cube = proto.$cube;
        this._meta = {
            xAxis: [{}],
            series: {},
            displaysOneMeasure: cube && cube.$displaysOneMeasure,
            hasMeasureSelector: cube && cube.$hasMeasureSelector,
            hasStyleSelector: cube && cube.$hasStyleSelector,
            defaultStyle: _styleMap[cube.$style] || cube.$style || 'column',
            drill: {
                minLevel: 1,
                maxLevel: 0,
                currLevel: 1,
                currAxisHier: 0,
                levelsProperties: [],
                members: [],
                stack: [{
                    $axes: proto.$axes,
                    $item: proto.$item,
                    $slicer: proto.$slicer
                }]
/*              code: proto.$codeStat || "UNKNOWN",
                 axis0FieldCode: self._meta.xAxis[0].code || ""*/
            }
        };
        this._processMeta(proto);
    },
    _initializeToobar: function() {
        var self = this;
        self._toolBox && self._toolBox.show({
            series: (self._meta.hasMeasureSelector && self._meta.displaysOneMeasure),
            chartTypes: self._meta.hasStyleSelector
        });

        self._toolBox && self._toolBox.selectChartType(self._meta.defaultStyle);
    },
    _processMeta: function(proto) {
        this._processMeasures(proto);
        this._processLinks(proto);
        this._processAxes(proto);
    },
    _processMeasures: function(proto) {
        var self = this;
        var cube = this.$prototype.$cube;
        var items = this.$prototype.$properties;

        // Get measures definition. If measures are not defined in the second axis members (Cf. specs),
        // we used all the measures defined in the cube
        var measures = cube && cube.$measures;
        if (measures) {
            var restraintMeasures = measures;
            if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
                restraintMeasures = {};
                _.each(proto.$axes[1].$members[0][0], function(measureCode) {
                    restraintMeasures[measureCode] = measures[measureCode];
                });
            }
            _.each(restraintMeasures, function(m, key) {
                // Because duplicate properties is possible for cube definition... we keep the last defined
                var code = (m.$property || key);
                //options.xAxis[0].categories.push(measure.$title || proto.$properties[code].$title || "???");
                var measure = _merge(items[code], m);
                measure.formatApi = _formatApi.getApi(measure.$type);
                measure.numFormatObj = _formatApi.getLocale().getNumberFormatObj(measure.$type);
                measure.localeFormat = measure.$format || measure.numFormatObj.numFormat;

                self._meta.series[code] = {
                    options: {
                        id: '#s-' + code,
                        // legendIndex: "",
                        name: measure.$title || '???',
                        stack: measure.$isStacked,
                        type: measure.$style && (_styleMap[measure.$style] || measure.$style),
                        visible: !! (!self._meta.displaysOneMeasure || measure.$isDefault)
                    },
                    measure: measure
                };
                // self._chart && self._chart.addSeries(self._meta.series[code].options);
            });
        }
    },
    _processLinks: function(proto) {
        var self = this;
        self._meta.links = [];
        if (proto.$links) {
            _.each(proto.$links, function(link, id) {
                self._meta.links.push(self._getLinkDef("$links", id, link));
            }, self);
        }
        // need to validate the spec about these points
/*
         if(proto.$actions) {
         _.each(proto.$actions, function(link, id) {
         self._meta.links.push(self._getLinkDef("$actions", id, link));
         }, self);
         }
         if(self._meta.xAxis[0].code && proto.$properties && proto.$properties[self._meta.xAxis[0].code].$thumb && proto.$properties[self._meta.xAxis[0].code].$thumb.$links) {
         _.each(proto.$properties[self._meta.xAxis[0].code].$thumb.$links, function(link, id) {
         self._meta.links.push(self._getLinkDef("$links", id, link));
         }, self);
         }
         */
    },
    _processAxes: function(proto) {
        var cube = this.$prototype.$cube;
        if (!_isCubeValid(cube, proto)) return false;

        var self = this;
        var currAxisHier = 0;
        // TODO: review this
        // Get axis analysis
        var mainHLevelsTab = null;
        _.each(proto.$axes[0].$hierarchies, function(hierarchy, idx) {
            if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
                mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
                if (mainHLevelsTab) {
                    self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
                    currAxisHier = idx;
                }
            }
        });
        if (!mainHLevelsTab && proto.$axes[0].$hierarchies[0].length > 0) {
            mainHLevelsTab = cube.$hierarchies[proto.$axes[0].$hierarchies[0][0]].$properties;
            if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
        }

        // Get drill definition
        var properties;
        self._meta.drill.code = proto.$codeStat || "UNKNOWN";
        self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";

        _.each(proto.$axes[0].$hierarchies, function(hierarchie) {
            properties = cube.$hierarchies[hierarchie[0]].$properties;
            _.each(properties, function(property) {
                this.levelsProperties[this.maxLevel++] = property;
            }, self._meta.drill);
        });
        self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
        if (proto.$axes[0].$members) {
            _.each(proto.$axes[0].$members, function(tuple) {
                _.each(tuple, function(value) {
                    if (value.length > 0) {
                        this.members[this.currLevel++-1] = value[0];
                    }
                }, this);
            }, self._meta.drill);
        }
    },
    // set graph style
    _setGraphStyle: function(cube, measures) {
        // Init
        var graphStyle = {},
            mDefault = null;
        var msCode = [],
            i = 0;
        var self = this;

        if (cube.$style == "pie") {
            _.each(measures, function(measure) {
/*              msCode.push(measure.property);
                 if(measure.definition.$isDefault)
                 mDefault = measure.property;
                 */
            });
        } else {
            _.each(measures, function(measure) {
/*
                 // So, "xy" style
                 switch (measure.definition.$style) {
                 case "stick":
                 break;
                 }
                 if(measure.definition.$isStacked) {
                 } else if(measure.definition.$isNormalized) {
                 }
                 if(measure.definition.$isDefault)
                 mDefault = measure.property;
                 msCode.push(measure.property);
                 */
            });
        }

        // Misc properties
        graphStyle.defaultMeasures = (!cube.$displaysOneMeasure ? msCode.join(";") : (mDefault ? mDefault : msCode[0]));
        graphStyle.hasMeasureSelector = !! cube.$hasMeasureSelector;
        graphStyle.hasStyleSelector = !! cube.$hasStyleSelector;

        return graphStyle;
    },
    _getLinkDef: function(type, id, link) {
        return {
            "type": type,
            "id": id,
            "link": link,
            "title": link.$title
        };
    },
    _getPref: function() {
        // TODO: change default preference by using authoring mode
        var options = Highcharts.getOptions();
        return _merge(options, {
            chart: {
                defaultSeriesType: 'column' // 'line', 'spline', 'area', 'areaspline', 'column', 'bar', 'pie', 'scatter',
            },
            credits: {
                enabled: false
            },
            legend: {
                layout: 'vertical',
                align: 'left',
                verticalAlign: 'top',
                x: 100,
                y: 70,
                floating: true
            },
            plotOptions: {
                column: {
                    pointPadding: 0.2,
                    borderWidth: 0,
                    //stacking : 'normal',
                }
            },
        });
    },
    _getMeasureLabel: function(measure, code) {
        var label = measure.$title;
        if (label) return label;
        var self = this;
        var item = self.$prototype.$properties[code];
        if (!item) return null;
        switch (item.$type) {
        case "application/x-string":
            label = measure[code];
            break;
        case "application/x-choice":
            item.$value.$enum.some(function(element, i, array) {
                if (element.$value === measure[code]) {
                    label = element.$title;
                    return true;
                }
                return false;
            });
            label = measure[code];
            break;
        }
        return label;
    },

    // --------------------------------------------------------------------------------
    // Chart action management
    // --------------------------------------------------------------------------------
    _executeRecordMenu: function(context) {
        if (!this.recordArticle) {
            this.recordArticle = new RecordArticle();
            this.recordArticle.$prototype = this.$prototype.$item;
            document.itemFactory.initializeItem(this.recordArticle, {}, this);
            this.recordArticle.loadBox(context.$item);
        } else {
            this.recordArticle.applyChange(context.$item);
        }
        this.recordArticle.menuItems[Object.keys(context["$links" || "$actions"])[0]][0].click();
    },
    _execLink: function(context) {
        this._executeRecordMenu(context);
    },
    _drill: function(serie, up) {
        var self = this;
        var cube = this.$prototype.$cube;
        var meta = self._meta;
        var i = meta.drill.currAxisHier;
        var stack = self._meta.drill.stack;

        if (up) {
            // already on top ?
            if (stack.length < 2) return;
            stack.shift();
            meta.drill.currAxisHier--;
            this._toolBox.showDrillUp(meta.drill.currAxisHier > 0);
            this._fetch(stack[0]);
            return;
        }

        var proto = stack[0];
        var members = proto.$axes[0].$members;
        if (!members) {
            members = proto.$axes[0].$members = [];
        }
        stack.unshift(objectClone(proto, true));
        proto = stack[0];
        members = proto.$axes[0].$members;
        var hierarchies = proto.$axes[0].$hierarchies;

        var cubeHier = cube.$hierarchies[hierarchies[i][0]];
        if (hierarchies[i][2] == (cubeHier.$properties ? cubeHier.$properties.length - 1 : -1)) {
            hierarchies[i].splice(1, 2, 0, 0);
            hierarchies[i + 1].splice(1, 2, 1, 0);
            meta.drill.currAxisHier++;
        } else {
            hierarchies[i][2]++;
        }
        if (members.length < i + 1) {
            members[i] = [];
        }
        members[i].push([serie ? "" + serie.x : "???"]);

        this._toolBox.showDrillUp(meta.drill.currAxisHier > 0);
        this._fetch(proto);
    },
    _fetch: function(proto) {
        this.getPage().fetch({
            jsonParams: {
                $axes: proto.$axes,
                $slicer: proto.$slicer
            }
        });
    },
    // --------------------------------------------------------------------------------
    // Chart management
    // --------------------------------------------------------------------------------
    _setChart: function(categories, series, data) {
        var self = this;
        alert('_setChart NIY');
/*
         self._chart.xAxis[0].setCategories(categories);
         self._chart.series[0].remove();
         self._chart.addSeries({
         name : name,
         proto : proto,
         //color : color || 'red'
         });
         */
    },
    _setType: function(series, newType) {
        var chart = series.chart;
        var newSeries = {
            id: series.options.id,
            type: newType,
            name: series.name,
            data: series.options.data,
            visible: series.visible,
            stack: series.stack,
            color: series.color
        };
        series.remove();
        chart.addSeries(newSeries, false);
    }
});

function _isCubeValid(cube, proto) {
    return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 //
    && proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
}

function _formatValue(v, format) {

}