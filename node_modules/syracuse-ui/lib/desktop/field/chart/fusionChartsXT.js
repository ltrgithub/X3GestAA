"use strict";
var helpers = require('syracuse-core/lib/helpers');
var cubeHelper = require('syracuse-ui/lib/common/field/cube/cubeHelper');
var Article = require("syracuse-ui/lib/common/article/article").Article;
require('syracuse-ui/deps/fusionCharts/charts/FusionCharts');
require('syracuse-ui/deps/fusionCharts/charts/FusionCharts.jqueryplugin');
require('syracuse-ui/deps/fusionCharts/charts/FusionCharts.HC');
require('syracuse-ui/deps/fusionCharts/charts/FusionCharts.HC.Charts');

var forEachKey = helpers.object.forEachKey;
var objectCopy = helpers.object.copy;
var objectClone = helpers.object.clone;

var chartStyles = {
    classic: ["Column2D", "Column3D", "Line", "Area2D", "Bar2D", "Pie2D", "Pie3D", "Doughnut2D", "Doughnut3D", "Pareto2D", "Pareto3D"],
    multiSeries: ["MSColumn2D", "MSColumn3D", "MSLine", "MSBar2D", "MSBar3D", "MSArea", "Marimekko", "ZoomLine"],
    stacked: ["StackedColumn2D", "StackedColumn3D", "StackedBar2D", "StackedBar3D", "StackedArea2D", "MSStackedColumn2D"],
    combination: ["MSCombi2D", "MSCombi3D", "MSColumnLine3D", "StackedColumn2DLine", "StackedColumn3DLine", "MSCombiDY2D", "MSColumn3DLineDY", "MSStackedColumn2DLineDY", "StackedColumn3DLineDY"],
    xyPlot: ["Scatter", "Bubble"],
    scroll: ["ScrollColumn2D", "ScrollLine2D", "ScrollArea2D", "ScrollStackedColumn2D", "ScrollCombi2D", "ScrollCombiDY2D"],
    grid: ["SSGrid"]
};

var styleMap = {
    $default: "MSCombi3D",
    stick: "MSCombi3D",
    pie: "Pie3D"
};

function _getChartStyle(type){
    return "FusionCharts/" + styleMap[type] + ".swf";
};

var _merge = function(){
    var args = arguments;
    return $.extend(true, null, args[0], args[1], args[2], args[3]);
};

var _formatApi = require('syracuse-ui/lib/common/field/formatApi');

function ToolBar(){
}

helpers.defineClass(ToolBar, null, {
    create: function(container, id, handlers){
        var self = this;
        self.id = id;
        self.state = {
            series: false,
            chartTypes: true
        };
        // TODO: be compliant with syracuse theme
        self.$$bar = $("<div />").attr("style", "display:none").appendTo(container);
        self.$$series = $("<select />").attr("id", "select_series_" + id) //
.appendTo(self.$$bar) //
.change(function(){
            $(this).children("option:selected").each(function(){
                handlers && handlers.serieChange.call(null, $(this).attr("value"));
            });
        });
        self.$$chartTypes = $("<select />").attr("id", "select_chart_type_" + id) //
.appendTo(self.$$bar) //
.change(function(){
            $(this).children("option:selected").each(function(){
                handlers && handlers.serieStyleChange.call(null, $(this).attr("value"));
            });
        });
        /*		chartStyles.forEach(function(style) {
         $("<option />").attr("value", style).text(style).appendTo(self.$$chartTypes);
         });*/
        return this;
    },
    show: function(opt){
        var self = this;
        this.$$bar && this.$$bar.show();
        if (opt) {
            opt = _merge(self.state, opt);
            opt.series && self.$$series && self.$$series.show();
            opt.chartTypes && self.$$chartTypes && self.$$chartTypes.show();
        }
    },
    hide: function(opt){
        var self = this;
        if (opt) {
            opt = _merge(self.state, opt);
            opt.series && self.$$series && self.$$series.hide();
            opt.chartTypes && self.$$chartTypes && self.$$chartTypes.hide();
        }
        else {
            this.$$bar && this.$$bar.hide();
        }
    },
    addSeries: function(choices){
        var self = this;
        choices = Array.isArray(choices) ? choices : (!!choices ? [choices] : []);
        choices.map(function(choice){
            $("<option />").attr("value", choice.id).text(choice.title).appendTo(self.$$series);
        });
    },
    removeAllSeries: function(){
        this.$$series.empty();
    },
    selectSerie: function(val){
        this._selectChoice(this.$$series, val);
    },
    selectChartType: function(val){
        this._selectChoice(this.$$chartTypes, val);
    },
    _selectChoice: function($$obj, val){
        $$obj.children('option[value="' + val + '"]').attr("selected", "selected");
    }
});

function RecordArticle(){
}

exports.RecordArticle = helpers.defineClass(RecordArticle, Article, {
    drawBox: function(){
        document.itemFactory.load($("<div style='display:none'/>").appendTo(this.boxParent.$$container), {
            $category: "links"
        }, this);
    },
});

function TabularChart(){
}

exports.TabularChart = helpers.defineClass(TabularChart, Article, {
    drawBox: function(){
        FusionCharts.setCurrentRenderer('javascript');
        /*		FusionCharts.debugMode.enabled(true);
         FusionCharts.debugMode.outputTo(function() {
         console.log(arguments);
         });*/
        var self = this;
        var id = 'chart_' + self.id;
        self._toolbar = new ToolBar().create(self.$$container, self.id, {
            serieChange: function(id){
                /*				self._chart.series.map(function(s) {
                 s.hide();
                 });
                 self._chart.get(id).show();*/
            },
            serieStyleChange: function(type){
                /*				forEachKey(self._meta.series, function(key, s) {
                 var series = self._chart.get(s.options.id);
                 self._setType(series, type);
                 });
                 self._chart.redraw();*/
            }
        });
        $('<div />').attr('id', id).appendTo(self.$$container);
        
        var proto = self.$prototype;
        // create an alias of item's definition
        proto.$ = proto.$item.$;
        
        
        self.$$chart = $('#' + id);
        self.$$chart.insertFusionCharts({
            swfUrl: _getChartStyle("$default"),
            width: "900",
            height: "500",
            id: "my" + id
        });
        
        /*		self.$$chart.bind("fusionchartsdrawcomplete", function(e, args) {
         console.log("Chart named " + e.sender.id + " drawcomplete.");
         });
         self.$$chart.bind("fusionchartslinkeditemopened", function(e, args) {
         console.log("Chart named " + e.sender.id + " LinkedItemOpened.");
         });
         */
        cubeHelper.initializeMeta(this, styleMap);
        /*
         self._initializeMeta();
         self._initializeToobar();
         */
        self.getArticleParent().bind(self, self.$item.$bind);
    },
    setDataBind: function(value, record, metaData){
        //this.value = value;
        if (metaData) {
            this._processMeta(metaData);
        }
        if (value) {
            var self = this;
            
            var source = self._getSource(value, metaData);
            self.$$chart.updateFusionCharts({
                swfUrl: _getChartStyle("stick"),
                dataSource: source,
                dataFormat: "json"
            });
            /*			
             self._chart.xAxis[0].setCategories(settings.categories, false);
             // todo use series.setData
             // remove all current series
             var series = self._chart.series;
             for (var i = series.length; i > 0; i--) {
             // for (var i = 0; i < series.length; i++) {
             series[0].remove(false);
             // series[i].setData(settings.series[series[i].options.id.slice(3)].data);
             }
             self._toolbar.removeAllSeries();
             //add series
             forEachKey(self._meta.series, function(key, s) {
             self._chart.addSeries(settings.series[key], false);
             self._toolbar.addSeries({
             id: s.options.id,
             title: s.options.name
             });
             });
             self._chart.redraw();*/
        }
    },
    onMenuClick: function(){
        console.log('' + this.y);
    },
    _getSource: function(value, metaData){
        var self = this, proto = this.$prototype, cube = proto.$cube, items = proto.$item.$, xAxisCode = self._meta.xAxis[0].code;
        
        var settings = value.reduce(function(res, current){
            var categoryName = cubeHelper.getMeasureLabel(current, xAxisCode, items);
            categoryName &&
            res.categories.push({
                label: categoryName
            });
            forEachKey(self._meta.series, function(key, s){
                var serie = res.series[key];
                if (serie == null) {
                    serie = {
                        seriesname: s.options && s.options.name,
                        data: []
                    };
                    res.series[key] = serie;
                    res.dataset.push(serie);
                }
                var value = parseFloat(current[key]);
                serie.data.push({
                    value: value,
                    // link: "JavaScript: function inspect(o){var s = ''; for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) s +=o[k]; return s;}; console.log(inspect(this)); console.log('" + value + "');"
                    // link: "JavaScript: function inspect(o){var s = ''; for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) s += k + '=' + o[k] + ', '; return s;}; console.log(inspect(this);"
                    link: "JavaScript: console.log(typeof(this.series));"
                });
            });
            return res;
        }, {
            categories: [],
            series: {},
            dataset: []
        });
        
        return {
            chart: {
                caption: cube.$title || '',
                // subcaption: "Six Months",
                xaxisname: proto.$axes && proto.$axes.length > 0 && proto.$axes[0].$title,
                yaxisname: '',
                // bgcolor: "E9E9E9",
                canvasbgcolor: "D9E5F1",
                canvasbasecolor: "D9E5F1",
                outcnvbasefontcolor: "666666",
                showlabels: "1",
                showvalues: "0",
                plotfillalpha: "70",
                numvdivlines: "10",
                showalternatevgridcolor: "1",
                alternatevgridcolor: "e1f5ff",
                divlinecolor: "e1f5ff",
                vdivlinecolor: "e1f5ff",
                basefontcolor: "666666",
                canvasborderthickness: "1",
                showplotborder: "0",
                plotborderthickness: "0",
                startangx: "7",
                endangx: "7",
                startangy: "-18",
                endangy: "-18",
                zgapplot: "20",
                zdepth: "60",
                exetime: "2",
                chartorder: "area,column"
            },
            styles: {
                definition: [{
                    name: "myToolTipFont",
                    type: "font",
                    font: "Arial",
                    size: "12",
                    color: "FF5904"
                }],
                application: [{
                    toobject: "ToolTip",
                    styles: "myToolTipFont"
                }]
            },
            
            categories: [{
                category: [settings.categories]
            }],
            dataset: settings.dataset
        };
        
        /*		var source = {
         legend: {
         align: 'left',
         verticalAlign: 'top',
         x: 30,
         y: 30,
         // floating: true
         },
         xAxis: [{
         categories: [],
         title: {
         text: proto.$axes && proto.$axes.length > 0 && proto.$axes[0].$title
         }
         }],
         yAxis: [{
         min: 0,
         title: {
         text: ''
         }
         }],
         plotOptions: {
         series: {
         cursor: 'pointer',
         point: {
         events: {
         click: function(event) {
         // drill up if shiftKey is pressed
         self._drill(this, event.shiftKey);
         }
         }
         }
         }
         },
         tooltip: {
         formatter: function() {
         var measure = self._meta.series[this.series.options.id.slice(3)].measure;
         var label = '' + this.x + ': <b> ' + (measure ? measure.formatApi.format(this.y, measure.localeFormat) : this.y) + '</b>';
         var data = this.series.processedYData;
         if (measure && (measure.$isNormalized) && data.length > 0) {
         var sum = data.reduce(function(a, b) {
         return a + b;
         });
         label += ' (' + measure.formatApi.format(this.y / sum * 100, measure.localeFormat) + '%)';
         }
         label += '<br/><span style="font-size: 10px; font-style:italic;">Click to drill down</span><br/><span style="font-size: 10px; font-style:italic;">Shift+Click to drill up</span>'
         return label;
         }
         },
         series: []
         };
         if (options.xAxis[0].title.text != options.title) {
         options.xAxis[0].title.text = options.title + ' / ' + options.xAxis[0].title.text;
         }
         return source;
         */
    },
    _initializeToobar: function(){
        var self = this;
        self._toolbar &&
        self._toolbar.show({
            series: (self._meta.hasMeasureSelector && self._meta.displaysOneMeasure),
            chartTypes: self._meta.hasStyleSelector
        });
        
        self._toolbar && self._toolbar.selectChartType(self._meta.defaultStyle);
    },
    _processMeta: function(proto){
        // this._processMeasures(proto);
        // this._processLinks(proto);
        // this._processAxes(proto);
    },
    _processMeasures: function(proto){
        var self = this;
        var cube = this.$prototype.$cube;
        var items = this.$prototype.$;
        
        // Get measures definition. If measures are not defined in the second axis members (Cf. specs),
        // we used all the measures defined in the cube
        var measures = cube.$measures;
        if (measures) {
            var restraintMeasures = measures;
            if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
                restraintMeasures = {};
                _.each(proto.$axes[1].$members[0][0], function(measureCode){
                    restraintMeasures[measureCode] = measures[measureCode];
                });
            }
            _.each(restraintMeasures, function(m, key){
                // Because duplicate properties is possible for cube definition... we keep the last defined
                var code = (m.$property || key);
                //options.xAxis[0].categories.push(measure.$title || proto.$[code].$title || "???");
                var measure = _merge(items[code], m);
                measure.formatApi = _formatApi.getApi(measure.$type);
                measure.numFormatObj = _formatApi.getLocale().getNumberFormatObj(measure.$type);
                measure.localeFormat = measure.$format || measure.numFormatObj.numFormat;
                
                self._meta.series[code] = {
                    options: {
                        id: '#s-' + code,
                        // legendIndex: "",
                        name: measure.$title || '???',
                        stack: measure.$isStacked,
                        type: measure.$style && (styleMap[measure.$style] || measure.$style),
                        visible: !!(!self._meta.displaysOneMeasure || measure.$isDefault)
                    },
                    measure: measure
                };
                // self._chart && self._chart.addSeries(self._meta.series[code].options);
            });
        }
    },
    _processLinks: function(proto){
        var self = this;
        self._meta.links = [];
        if (proto.$links) {
            _.each(proto.$links, function(link, id){
                self._meta.links.push(self._getLinkDef("$links", id, link));
            }, self);
        }
        // need to validate the spec about these points
        /*
         if(proto.$actions) {
         _.each(proto.$actions, function(link, id) {
         self._meta.links.push(self._getLinkDef("$actions", id, link));
         }, self);
         }
         if(self._meta.xAxis[0].code && proto.$ && proto.$[self._meta.xAxis[0].code].$thumb && proto.$[self._meta.xAxis[0].code].$thumb.$links) {
         _.each(proto.$[self._meta.xAxis[0].code].$thumb.$links, function(link, id) {
         self._meta.links.push(self._getLinkDef("$links", id, link));
         }, self);
         }
         */
    },
    _processAxes: function(proto){
        var cube = this.$prototype.$cube;
        if (!cubeHelper.isValid(cube, proto)) 
            return false;
        
        var self = this;
        var currAxisHier = 0;
        // TODO: review this
        // Get axis analysis
        var mainHLevelsTab = null;
        _.each(proto.$axes[0].$hierarchies, function(hierarchy, idx){
            if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
                mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
                if (mainHLevelsTab) {
                    self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
                    currAxisHier = idx;
                }
            }
        });
        if (!mainHLevelsTab && proto.$axes[0].$hierarchies[0].length > 0) {
            mainHLevelsTab = cube.$hierarchies[proto.$axes[0].$hierarchies[0][0]].$properties;
            if (mainHLevelsTab && mainHLevelsTab.length > 0) 
                self._meta.xAxis[0].code = mainHLevelsTab[0];
        }
        
        // Get drill definition
        var properties;
        self._meta.drill.code = proto.$codeStat || "UNKNOWN";
        self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";
        
        _.each(proto.$axes[0].$hierarchies, function(hierarchie){
            properties = cube.$hierarchies[hierarchie[0]].$properties;
            _.each(properties, function(property){
                this.levelsProperties[this.maxLevel++] = property;
            }, self._meta.drill);
        });
        self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
        if (proto.$axes[0].$members) {
            _.each(proto.$axes[0].$members, function(tuple){
                _.each(tuple, function(value){
                    if (value.length > 0) {
                        this.members[this.currLevel++ - 1] = value[0];
                    }
                }, this);
            }, self._meta.drill);
        }
    },
    _getLinkDef: function(type, id, link){
        return {
            "type": type,
            "id": id,
            "link": link,
            "title": link.$title
        };
    },
    
    // --------------------------------------------------------------------------------
    // Chart action management
    // --------------------------------------------------------------------------------
    _executeRecordMenu: function(context){
        if (!this.recordArticle) {
            this.recordArticle = new RecordArticle();
            this.recordArticle.$prototype = this.$prototype.$item;
            document.itemFactory.initializeItem(this.recordArticle, {}, this);
            this.recordArticle.loadBox(context.$item);
        }
        else {
            this.recordArticle.applyChange(context.$item);
        }
        this.recordArticle.menuItems[Object.keys(context["$links" || "$actions"])[0]][0].click();
    },
    _execLink: function(context){
        this._executeRecordMenu(context);
    },
    _drill: function(serie, up){
        //alert('Category: ' + serie.category + ', value: ' + serie.y);
        var self = this;
        var cube = this.$prototype.$cube;
        var meta = self._meta;
        var i = meta.drill.currAxisHier;
        var stack = self._meta.drill.stack;
        
        if (up) {
            // already on top ?
            if (stack.length < 2) 
                return;
            stack.shift();
            meta.drill.currAxisHier--;
            this._fetch(stack[0]);
            return;
        }
        var proto = stack[0];
        var members = proto.$axes[0].$members;
        if (!members) {
            members = proto.$axes[0].$members = [];
        }
        stack.unshift(objectClone(proto, true));
        proto = stack[0];
        members = proto.$axes[0].$members;
        var hierarchies = proto.$axes[0].$hierarchies;
        
        var cubeHier = cube.$hierarchies[hierarchies[i][0]];
        if (hierarchies[i][2] == (cubeHier.$properties ? cubeHier.$properties.length - 1 : -1)) {
            hierarchies[i].splice(1, 2, 0, 0);
            hierarchies[i + 1].splice(1, 2, 1, 0);
            meta.drill.currAxisHier++;
        }
        else {
            hierarchies[i][2]++;
        }
        if (members.length < i + 1) {
            members[i] = [];
        }
        members[i].push([serie ? "" + serie.x : "???"]);
        
        this._fetch(proto);
    },
    _fetch: function(proto){
        this.getPage().fetch({
            jsonParams: {
                $axes: proto.$axes,
                $slicer: proto.$slicer
            }
        });
    },
});
