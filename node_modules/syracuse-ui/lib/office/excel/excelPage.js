"use strict";

var helpers = require('syracuse-core/lib/helpers');
var RawPage = require('syracuse-ui/lib/page/rawPage').RawPage;
var article = require('syracuse-ui/lib/article/article');
var excelLoaded = external && external.Application;

// create a grid article and a grid record article. Fro now, they only serves for parseExpression

function ExcelGrid(page, prototype) {
	this.$page = page;
	this.articleParent = page;
	this.$prototype = prototype;
	this.dataset = {};
}

var ExcelGrid = helpers.defineClass(ExcelGrid, article.Article, {
	drawBox: function() {

	}
});

function ExcelRecord(excelGrid, prototype) {
	this.$grid = excelGrid;
	this.$prototype = prototype;
	this.dataset = {};
	this.articleParent = excelGrid;
}

var ExcelRecord = helpers.defineClass(ExcelRecord, article.Article, {
	drawBox: function() {

	}
});

function ExcelPage() {

}

exports.ExcelPage = helpers.defineClass(ExcelPage, RawPage, {
	drawBox: function() {
		var $properties = this.$prototype.$properties;
		this.$excelTablePrototype = this._makeExcelTablePrototype($properties.$resources.$item.$properties, this.$item);
		this.$grid = new ExcelGrid(this, $properties.$resources);
		this.$grid.loadBox();
		this.$grid.$record = new ExcelRecord(this.$grid, $properties.$resources.$item);
		this.$grid.$record.loadBox();
	},
	onDialogResize: function() {},
	_makeExcelTablePrototype: function($prototype, $item) {
		var self = this;
		var proto = $prototype;
		var _item = $item;
		var items;
		if (self.$prototype.fields) {
			items = self.$prototype.fields.map(function(f) {
				return {
					$bind: f
				};
			});
		} else {
			// get to "$resources" layout
			while (_item && _item.$layout && (_item.$bind !== "$resources"))
				_item = _item.$layout.$items && _item.$layout.$items[0];
			if (!_item)
				return;
			// get column list as string array 
			// TODO : properly manage $resource node
			items = (_item.$layout && _item.$layout.$items) || _item.$items ||
				Object.keys(proto).filter(function(prop) {
					return proto[prop].$isHidden !== true;
				}).map(function(prop) {
					return {
						$bind: prop
					};
				});
		}
		// simplified proto
		return items.map(function(item) {
			//return item.$bind;
			var protoItem = proto[item.$bind];
			// use undescore instead of $ as cannot have properties with $ in VSTO
			var sp = {
				_name: item.$bind.replace("$", "_"), // escape $ properties
				_orgName: item.$bind, // temporary storage of original name
				_title: self.parseExpression(protoItem.$title),
				_type: protoItem.$type,
				_scale: (protoItem.$scale !== undefined) ? protoItem.$scale : null
			};
			return sp;
		});
	},
	_makeExcelTableData: function(data, $prototype, $excelTablePrototype) {
		var proto = $prototype;
		var items = $excelTablePrototype;
		var self = this;
		//
		return data.$resources.map(function(res) {
			return items.map(function(item) {
				var prop = res[item._orgName];
				var propProto = proto[item._orgName];
				var result = "";
				var record = res;
				// manage limited set of types
				switch (item._type) {
					case "application/x-string":
					case "application/x-integer":
					case "application/x-decimal":
					case "application/x-datetime":
					case "application/x-date":
					case "application/x-time":
					case "application/x-boolean":
					case "application/x-choice":
						result = prop;
						break;
					case "application/x-reference":
						record = prop;
						propProto = propProto.$item || {};
						var valueTemplate = propProto.$value || propProto.$key;
						result = (record && valueTemplate && (self.$grid.$record.parseExpression(valueTemplate, record) || self.$grid.$record.parseExpression(valueTemplate, res))) ||
							"";
						break;
					default:
						result = "";
				}
				//
				if (record && propProto.$links && propProto.$links.$details)
					return [result, document.location.protocol + "//" + document.location.host + document.site.$syracuseMainPageUrl +
						"?url=" +
						encodeURIComponent(self.$grid.$record.parseExpression(propProto.$links.$details.$url, record))];
				else
					return result;
			});
		});
	},
	createExcelTableShell: function(linesCount) {
		return (excelLoaded && external.ResizeTable(this.$prototype.$datasourceName, JSON.stringify(this.$excelTablePrototype), linesCount, this.$prototype.cellAddress || "")) || !excelLoaded;
	},
	applyChange: function(newData) {
		// send to excel
		var self = this;
		var representation = this;
		var res = true;
		// make header
		var proto = representation.$prototype.$properties.$resources.$item.$properties;
		var dsName = representation.$prototype.$datasourceName;
		var items = self.$excelTablePrototype;
		// make data as array
		var data = self._makeExcelTableData(newData, proto, items);
		//
		if (excelLoaded && external.UpdateTable(dsName, JSON.stringify(items), JSON.stringify(data), newData.$startIndex - 1)) {
			// save datasource to document
			document.site.excelDocument.updateDatasourceToDocument(representation.$prototype.$datasource, representation.$prototype.$datasourceName);
		} else
			res = false;
		return res;
	},
	dispose: function() {
		if (document.site.dialogAdapter) {
			document.site.removeDialog();
		}
		RawPage.prototype.dispose.call(this);
	}
});