"use strict"

var helpers = require('syracuse-core/lib/helpers');
var RawPage = require('syracuse-ui/lib/article/rawPage').RawPage;
var article = require('syracuse-ui/lib/article/article');
var base64 = require("msoffice/lib/Base64").Base64;

function WordReportPage() {
}

exports.WordReportPage = helpers.defineClass(WordReportPage, RawPage, {
    drawBox: function() {
    	var self = this;
    },
    createWordTemplate: function(wordInterface, refreshOnly) {
    	var self = this;
    	self.wordLayoutBoxes = new Array();
    	
    	// Ensure a basic layout for entities w/o representation
    	self.$item.$layout = self.$item.$layout || 
    		{
                $items: [{
                    $category: "section",
                    $layout: {
                        $items: Object.keys(self.get$Properties()).map(function($bind){
                        	var $item = {
                        		$bind: $bind
                        	};
                        	if ($item.$bind === "$resources")
                       		{
                        		$item.$layout = {};
                        		$item.$layout.$items = [];
                        		var proto = self.get$Properties();
                        		if (proto && proto.$resources && proto.$resources.$item && proto.$resources.$item.$)
                        		{
                        			Object.keys(proto.$resources.$item.$).map(function(column) {
                        				$item.$layout.$items.push({$bind: column});
                        			});
                        		}
                       		}
                        	return $item;
                        })
                    }
                }]
    		};
    	
    	self.createLayout(self.$item, self.get$Properties(), null, self.wordLayoutBoxes, null, self.$prototype);
    	wordInterface.createWordTemplate(self.wordLayoutBoxes, self.createSimpleData(), refreshOnly);
    },
    populateWordTemplate: function(wordInterface) {
    	var self = this;
    	wordInterface.populateWordTemplate(self.createSimpleData());
    },
    onDialogResize: function() {
    },
    applyChange: function(newData, response, requestUrl) {
    	var self = this;
    	self.pageData = newData;
    },
    dispose: function() {
    },
    createLayout: function(article, prototype, parent, boxes, level, baseProto) {
    	// walk layout and build flat list of boxes which contain properties with type information
    	var self = this;
    	
    	var layoutType;
    	var bind;
    	var layoutSubType;
    	var data;
    	var box;
    	var hidden;
    	var i;

    	function getLocalizedText(val) {
    		if (val === "{$title}")
    			return baseProto.$title || val;
    		return val && val.replace(/\{(@\w+)\}/g, function(match, p1) {
    			return (baseProto.$localization && baseProto.$localization[p1]) || match;
    		});
    	};

    	function getCardviewItems(layout) {
    		var itemsArray = new Array();
    		function recurse(items) {
    	    	items && items.map(function(item) {
    	    		if (item.$bind) {
    	    			itemsArray.push(item);
    	    		}
    	    		if (item.$items) {
    	    			recurse(item.$items);
    	    		}
    	    	});
    		};
    		recurse(layout.$items);
    		if (itemsArray.length === 0)
    			itemsArray = null;
    		return itemsArray;
    	};

    	if (!level)
    		level = 1;

    	var items = article.$items || (article.$layout && article.$layout.$items);
    	var cardview = article.$cards;
    	
    	// If we encounter a cardview, traverse the whole layout tree to extract all $binds
    	if (!items && cardview) {
    		items = getCardviewItems(cardview.$layout);
    	}
    	
    	if (article.$bind && items) {
    		// collection
    		bind = article.$bind; // collection property
    		data = (prototype && bind) ? prototype[bind] : prototype;
    		if (!data || data.$type.indexOf("application/x-array") < 0)
    		{
    			// Not handled yet
    			console.log("unknown type: " + (data && data.$type) + "(" + bind + ")");
    		}
    		else
    		{
	    		box = {
	    			$title:  getLocalizedText(data.$title),
	    			$container: "table",
	    			$bind: bind
	    		};
	    		data = data.$item.$properties;
    		}
    	} else if (article.$bind && !items) {
    		// property
    		bind = article.$bind; // property
    		hidden = article.$isHidden || false
    		data = (prototype && bind) ? prototype[bind] : prototype;
    		if (data) {
    			parent.$items = parent.$items || {};
    			parent.$items[bind] = {
    					$type: data.$type,
    					$title: data.$title || bind,
    					$bind: bind,
    					$hidden: hidden
    			};
    		}
    	} else {
    		// container
    		data = prototype;
    		box = {
    				$title:  getLocalizedText(article.$title),
    				$container: "box"
    		};
    	}
    	
    	if (box && box.$title) { // a box with a title is considered as one level of indentation of headers
    		box.$level = level;
    		level ++;
    	}

    	var childBoxes = new Array();
    	items && items.map(function(item) {
    		self.createLayout(item, data, box, childBoxes, level, baseProto);
    	});
    	if (box) {
    		if (box.$title || box.$items)
    			boxes.push(box);
    	}
    	for (i = 0; i < childBoxes.length; i++) {
    		boxes.push(childBoxes[i]);
    	}
    },
    createSimpleData: function() {
    	var self = this;
    	
    	function format(expression, res) {
    		res = res || {};
    		var value = expression && expression.replace(/\{(.*?)\}/g, function(match, p1) {
    			return res[p1] || self.pageData[p1] || self.$prototype[p1];
    		});

    		return value;
    	}
    	
    	function addProperties(proto, dataOut, dataIn) {
    		for (var property in proto)
    		{
    			var p	 = proto[property];
    			var prop = {};
    			dataOut[property] = prop;

    			prop.$type = p.$type;
    			if (prop.$type === "application/x-array") {
    				var dataArray = dataIn[property];
    				if (dataArray) {
	    				prop.$items = new Array();
	    				for (var i = 0; i < dataArray.length; i++) {
	    					var item = {};
	    					prop.$items.push(item);	
	    					addProperties(p.$item.$properties, item, dataArray[i]);
	    				}
    				}
				}
    			else if (prop.$type === "application/x-reference") {
    				addProperties(p.$properties, prop, p);
    			}
    			else
   				{
    				var result = {};
    				var value = dataIn[property];
    				if (value && value.$url) {
    					result.$url = format(value.$url, dataIn);
    					prop.$link  = result.$url;	// E.g. for images - add url als link
    				}
   					result.$value = value;
    				prop.$value = result;
    				prop.$format = p.$format;

    				if (p.$links && p.$links.$details && p.$links.$details.$url) {
    					prop.$link = format(p.$links.$details.$url, dataIn);
    				}
    				// Handle special formatted properties here to eventually overide detail link
    				switch (prop.$format) {
    				case "$email":
    					prop.$link = "mailto:" + value;
    					break;
    				case "$phone":
    					prop.$link = "phoneto:" + value;
    					break;
    				}
   				}
    		}
    	};

    	var dataOut = {};
    	addProperties(self.$prototype.$properties, dataOut, self.pageData);
    	return dataOut;
    },
    setLineCount: function(lineCount) {
    }
});

// Called from word when additional data has to be fetched (eg. images)
// ONLY WORKS IN IE. no problem here, since this is only called from IE within word!
window.readBinaryURLContentIE = function(url) {

	var xhr = new XMLHttpRequest();
	var data = {};
	xhr.open('GET', url, false);

	xhr.setRequestHeader("X-Content-Type-Override", "text/plain; charset=x-user-defined");
	xhr.onreadystatechange = function(e) {
	  if (this.readyState == 4 && this.status == 200) {
		  // this.responseText is broken in IE with binary data!
		  data.responseBody = this.responseBody;
	  }
	};
	xhr.send();
	
	// This is a c# byte array!
	return data.responseBody;
};