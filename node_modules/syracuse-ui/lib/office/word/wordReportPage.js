"use strict";

var helpers = require('syracuse-core/lib/helpers');
var RawPage = require('syracuse-ui/lib/page/rawPage').RawPage;
var article = require('syracuse-ui/lib/article/article');
var base64 = require("msoffice/lib/Base64").Base64;

function WordReportPage() {}

exports.WordReportPage = helpers.defineClass(WordReportPage, RawPage, {
	drawBox: function() {
		var self = this;
		self.pageData = null;
	},
	createWordTemplate: function(wordInterface, refreshOnly) {
		var self = this;
		self.createBasicLayout();
		self.createLayout(self.$item, self.$prototype.$properties, null, self.wordLayoutBoxes, null, self.$prototype);
		wordInterface.createWordTemplate(self.wordLayoutBoxes, self.createSimpleData(), refreshOnly);
	},
	createBasicLayout: function() {
		var self = this;
		self.wordLayoutBoxes = new Array();
		// Ensure a basic layout for entities w/o representation
		self.$item.$layout = self.$item.$layout || {
			$items: [{
				$category: "section",
				$layout: {
					$items: Object.keys(self.$prototype.$properties).map(function($bind) {
						var $item = {
							$bind: $bind
						};
						if ($item.$bind === "$resources") {
							$item.$layout = {};
							$item.$layout.$items = [];
							var proto = self.$prototype.$properties;
							if (proto && proto.$resources && proto.$resources.$item && proto.$resources.$item.$properties) {
								Object.keys(proto.$resources.$item.$properties).map(function(column) {
									$item.$layout.$items.push({
										$bind: column
									});
								});
							}
						}
						return $item;
					})
				}
			}]
		};
	},
	populateWordTemplate: function(wordInterface) {
		var self = this;
		self.createBasicLayout();
		self.createLayout(self.$item, self.$prototype.$properties, null, self.wordLayoutBoxes, null, self.$prototype);
		wordInterface.populateWordTemplate(self.wordLayoutBoxes, self.createSimpleData());
	},
	refreshWordDocument: function(wordInterface) {
		var self = this;
		self.createBasicLayout();
		self.createLayout(self.$item, self.$prototype.$properties, null, self.wordLayoutBoxes, null, self.$prototype);
		wordInterface.refreshWordDocument(self.wordLayoutBoxes, self.createSimpleData());
	},
	onDialogResize: function() {},
	applyChange: function(newData, response, requestUrl) {
		var self = this;
		if (!self.pageData) {
			self.pageData = newData;
		} else {
			if (self.pageData.$resources && newData.$resources) self.pageData.$resources.push.apply(self.pageData.$resources, newData.$resources);
		}
	},
	dispose: function() {},
	createLayout: function(article, prototype, parent, boxes, level, baseProto) {
		// walk layout and build flat list of boxes which contain properties with type information
		var self = this;

		var layoutType;
		var bind;
		var layoutSubType;
		var data;
		var box;
		var hidden;
		var i;

		function getLocalizedText(val) {
			return val && val.replace(/\{(@[\w-]+)\}/g, function(match, p1) {
				return (baseProto.$localization && baseProto.$localization[p1]) || match;
			});
		}

		function getChildItems(layout) {
			var itemsArray = [];

			function recurse(items) {
				items && items.map(function(item) {
					if (item.$bind) {
						itemsArray.push(item);
					}
					if (item.$items) {
						recurse(item.$items);
					}
				});
			}

			recurse(layout.$items);
			if (itemsArray.length === 0) {
				itemsArray = null;
			}
			return itemsArray;
		}

		if (!level) {
			level = 1;
		}

		var items = article.$items || (article.$layout && article.$layout.$items);

		// If we encounter a cardview, traverse the whole layout tree to extract all $binds
		if (!items) {
			bind = article.$bind;
			if (article.$cards) {
				items = getChildItems(article.$cards.$layout);
			} else if (prototype && bind && prototype[bind] && prototype[bind].$type.indexOf("application/x-array") > -1) {
				items = [];
				var props = prototype[bind].$item && prototype[bind].$item.$properties;
				if (!props) {
					props = prototype[bind].$item && prototype[bind].$item.$item && prototype[bind].$item.$item.$properties;
				}
				if (props) {
					items = Object.keys(props).map(function(i) {
						return {
							$bind: i
						};
					});
				}
			}
		}

		if (article.$bind && items) {
			// collection
			bind = article.$bind; // collection property
			data = (prototype && bind) ? prototype[bind] : prototype;
			if (!data || data.$type.indexOf("application/x-array") < 0) {
				// Not handled yet
				console.log("unknown type: " + (data && data.$type) + "(" + bind + ")");
			} else {
				box = {
					$title: getLocalizedText(data.$title),
					$container: "table",
					$bind: bind
				};
				data = data.$item.$properties || (data.$item.$item && data.$item.$item.$properties);
			}
		} else if (article.$bind && !items) {
			// property
			bind = article.$bind; // property
			hidden = (article.$isHidden !== undefined) ? article.$isHidden : false;
			data = (prototype && bind) ? prototype[bind] : prototype;
			if (data) {
				parent.$items = parent.$items || {};
				parent.$items[bind] = {
					$type: data.$type,
					$title: getLocalizedText(data.$title) || bind,
					$bind: bind,
					$hidden: hidden,
					$scale: (data.$scale !== undefined) ? data.$scale : null
				};
			}
		} else {
			// container
			data = prototype;
			box = {
				$title: getLocalizedText(article.$title),
				$container: "box"
			};
		}

		if (box && box.$title) { // a box with a title is considered as one level of indentation of headers
			box.$level = level;
			level++;
		}

		var childBoxes = [];
		items && items.map(function(item) {
			self.createLayout(item, data, box, childBoxes, level, baseProto);
		});
		if (box) {
			if (box.$title || box.$items) {
				boxes.push(box);
			}
		}
		for (i = 0; i < childBoxes.length; i++) {
			boxes.push(childBoxes[i]);
		}
	},
	createSimpleData: function() {
		var self = this;

		function format(expression, res, keepPlaceholder) {
			res = res || {};
			var value = expression && expression.replace(/\{(.*?)\}/g, function(match, p1) {
				return ((res[p1] || self.pageData[p1] || self.$prototype[p1]) || (self.$prototype.$localization && self.$prototype.$localization[p1]) || (keepPlaceholder && match)) || "";
			});

			return value;
		}

		function addProperties(proto, dataOut, dataIn) {
			var property;
			for (property in proto) {
				var p = proto[property];
				var prop = {};
				dataOut[property] = prop;

				prop.$type = p.$type;
				if (prop.$type === "application/x-array") {
					var dataArray = dataIn[property];
					if (dataArray) {
						prop.$items = [];
						var i;
						for (i = 0; i < dataArray.length; i++) {
							var item = {};
							prop.$items.push(item);
							addProperties(p.$item.$properties || (p.$item.$item && p.$item.$item.$properties), item, dataArray[i]);
						}
					}
				} else if (prop.$type === "application/x-reference") {
					//addProperties(p.$properties, prop, p);
					if (p.$item && p.$item.$value) {
						var value = p.$item.$value;
						if (value && typeof value === "string") {
							value = format(value, p.$item, true);
							value = format(value, dataIn);
						}
						var result = {};
						result.$value = value;
						result.$title = (dataIn[property] && dataIn[property].$title) || "";
						result.$description = (dataIn[property] && dataIn[property].$description) || "";
						result.$symbol = (dataIn[property] && dataIn[property].$symbol) || "";
						prop.$value = result;
					}
				} else if (prop.$type === "application/x-document" || prop.$type === "text/rtf" || prop.$type === "text/html" || prop.$type === "text/plain") {
					var lazyUrl = proto[property] && proto[property].$url;
					var contentType = dataIn[property] && dataIn[property].$contentType;
					if (lazyUrl && contentType) {
						lazyUrl = format(lazyUrl, dataIn);
						// Workaround for IE7
						lazyUrl = lazyUrl.replace(/Â¨/g, "%C2%A8");
						document.controller.sendRequest(null, {
							$location: {
								$url: lazyUrl
							},
							syncRqst: true,
							$acceptType: "html" // Set html since it may be HTML, plain text or rtf ("html" forces jQuery not to parse the response)
						}, function(data, response) {
							var result = {};
							result.$value = data;
							prop.$value = result;
						}, function(error, httpquery) { /* alert(JSON.stringify(error)); */
						});
					}
				} else {
					var result = {};
					var value = dataIn[property];
					if (value && value.$url) {
						result.$url = format(value.$url, dataIn);
						prop.$link = result.$url; // E.g. for images - add url als link
					}
					if (p.$type === "application/x-choice") {
						p.$value.$enum.some(function(element) {
							if (element.$value === value) {
								value = element.$title;
								return true;
							}
							return false;
						});
					} else if (p.$type === "application/x-quantity") {
						if (p.$unit && dataIn[p.$unit]) {
							var unitProp = dataIn[p.$unit];
							result.$title = unitProp.$title || "";
							result.$description = unitProp.$description || "";
							result.$symbol = unitProp.$symbol || "";
						}
					}
					if (value && typeof value === "string") {
						value = format(value, dataIn);
					}
					result.$value = value;
					prop.$value = result;
					prop.$format = p.$format;

					if (p.$links && p.$links.$details && p.$links.$details.$url) {
						prop.$link = format(p.$links.$details.$url, dataIn);
						var parts = prop.$link.split("/");
						prop.$link = parts.slice(0, 3).join("/") + "/syracuse-main/html/main.html?url=" + escape(prop.$link);
					}
					// Handle special formatted properties here to eventually overide detail link
					switch (prop.$format) {
						case "$email":
							if (value) {
								prop.$link = "mailto:" + value;
							}
							break;

						case "$phone":
							if (value) {
								prop.$link = "phoneto:" + value;
							}
							break;
					}
				}
			}
		}

		var dataOut = {};
		addProperties(self.$prototype.$properties, dataOut, self.pageData);
		return dataOut;
	},
	setLineCount: function(lineCount) {}
});