"use strict";
var parametersDialogs = require('./parametersDialogs');

function _getHost($url) {
	var reg = new RegExp('^(?:f|ht)tp(?:s)?\://([^/]+)', 'im');
	var parts = $url.match(reg);
	return parts ? parts[1].toString() : null;
};

exports.addHost = function($url) {
	var host = _getHost($url);
	if (!host) {
		var href = window.location.href;
		$url = href.slice(0, href.indexOf(window.location.host) + window.location.host.length) + $url;
	}
	return $url;
};

exports.replaceEndpoint = function($url, newEndpoint, check) {
	if (newEndpoint) {
		var segments = this.parse($url);
		if (segments.endpoint) {
			if (!check || (segments.endpoint.application === newEndpoint.application && segments.endpoint.contract === newEndpoint.contract)) {
				segments.endpoint = newEndpoint;
				$url = exports.build(segments);
			}
		}
	}
	return $url;
};

exports.build = function(segments) {
	var $url = segments.uri;
	if (segments) {
		if (segments.endpoint) {
			var parts = $url.split("/");
			for (var ii = 0, jj = parts.length; ii < jj; ii++) {
				switch (parts[ii].toLowerCase()) {
					case "sdata":
					case "trans":
						parts[ii + 1] = segments.endpoint.application || "";
						parts[ii + 2] = segments.endpoint.contract || "";
						parts[ii + 3] = segments.endpoint.dataset || "";
						$url = parts.join("/");
						ii = jj; //end loop
						break;
				}
			}
		}
		if (segments.params) {
			var paramString = "";
			var keys = Object.keys(segments.params);
			for (var ii = 0, jj = keys.length; ii < jj; ii++) {
				paramString += "&" + keys[ii] + "=" + encodeURIComponent(segments.params[keys[ii]]);
			}
			$url += "?" + paramString.slice(1);
		}
	}
	return $url;
};

exports.parse = function($url, isSyracuse) {
	var limit = $url.indexOf('?');
	var segments = {
		$url: $url,
		uri: $url.slice(0, limit),
		params: {},
		target: "$page"
	};
	var params = $url.slice(limit + 1).split('&');
	for (var ii = 0, jj = params.length; ii < jj; ii++) {
		var hash = params[ii].split("=");
		segments.params[hash[0]] = decodeURIComponent(hash[1]);
	}
	if (!(segments.endpoint = segments.params.endpoint)) {
		var sdataIndex = $url.search(/\/sdata\//i);
		if (sdataIndex >= 0) {
			segments.endpoint = $url.slice(sdataIndex + ("/sdata/").length).split("/").slice(0, 3).join(".");
		} else {
			var x3Index = $url.search(/\/trans\//i);
			if (x3Index >= 0) {
				segments.endpoint = $url.slice(x3Index + ("/trans/").length).split("/").slice(0, 3).join(".");
				segments.target = "trans";
				segments.isFusion = true;
				if (segments.params && segments.params.f) {
					segments.fusionParams = {};
					var parts = segments.params.f.split("/")[0].split("~");
					segments.fusionParams.functionCode = parts[0];
					if (parts.length > 1) {
						segments.fusionParams.transaction = parts[1];
					}
				}
			} else {
				segments.endpoint = document.site.userProfile ? document.site.userProfile.getSelectedEndpointString() : null;
			}
		}
	}
	// crnit: don't put a default endpoint name, this will allow to detect if no endpoint was selected in user profile
	// but keep endpoint segments with default values (for now ?)
	// parts.endpoint = segments.endpoint || "syracuse.collaboration.syracuse";
	segments.endpoint = segments.endpoint;
	//var endpointParts = segments.endpoint.split(".");
	var endpointSeg = (segments.endpoint || "syracuse.collaboration.syracuse").split(".");

	if (endpointSeg.length == 3) {
		segments.endpointSeg = {
			application: endpointSeg[0],
			contract: endpointSeg[1],
			dataset: endpointSeg[2]
		};
	}

	if (segments.params.representation) {
		var result = segments.params.representation.split(".");
		segments.representationRoot = result[0];
		segments.$facet = result[1];
	}
	if (isSyracuse) {
		var host = _getHost($url);
		segments.isSyracuse = host ? host == window.location.host : true; //no host == relative
	}
	return segments;
};

exports.applyParameters = function($url, params) {
	var paramObj = {};
	var paramString, key, ii, jj;
	var paramsStart = $url.lastIndexOf("?");
	if (paramsStart >= 0) {
		var parts = $url.slice(paramsStart + 1).split("&");
		for (ii = 0, jj = parts.length; ii < jj; ii++) {
			var part = parts[ii];
			var valueStart = part.indexOf("=");
			paramObj[part.substring(0, valueStart)] = part.substring(valueStart + 1);
		}
		$url = $url.substring(0, paramsStart);
	}
	var $keys = Object.keys(params);
	for (ii = 0, jj = $keys.length; ii < jj; ii++) {
		key = $keys[ii];
		if (params[key] === null) {
			delete paramObj[key];
		} else {
			if (params[key] !== undefined) {
				paramObj[key] = encodeURIComponent(params[key]);
			}
		}
	}
	paramString = "";
	$keys = Object.keys(paramObj);
	for (ii = 0, jj = $keys.length; ii < jj; ii++) {
		key = $keys[ii];
		paramString += "&" + key + "=" + paramObj[key];
	}
	$url += "?" + paramString.slice(1);
	return $url;
};
/**************************  FORMAT   **********************************************/
function _formatParameters(article, $parameters, record, callback) {
	var values = {};
	var props = Object.keys($parameters);
	for (var ii = 0, jj = props.length; ii < jj; ii++) {
		var prop = props[ii];
		switch (prop) {
			case "$properties":
			case "$":
			case "$links":
			case "$actions":
				break;
			default:
				var expression = $parameters[prop];
				if (expression && typeof(expression) == "string") {
					expression = article.parseExpression(expression, record);
				}
				values[prop] = expression;
				break;
		}
	}
	if (callback) {
		if ($parameters.$actions) {
			parametersDialogs.openSelectDialog(article, values, $parameters, record, callback);
			return;
		}
		if ($parameters.$properties) {
			parametersDialogs.openDialog(article, values, $parameters, record, callback);
			return;
		}
		callback(values);
	}
	return values;
};


function _formatMenuUrlWithCallback(article, $menu, record, callback) {
	if ($menu.$parameters) {
		$menu.$parameters.$title = $menu.getTitle ? $menu.getTitle() : null;
		_formatParameters(article, $menu.$parameters, record, function(values, isCanceled) {
			if (isCanceled) {
				callback(null, isCanceled);
			} else {
				if ($menu.$sourceType && $menu.$sourceType.indexOf("{") == 0) {
					$menu.$type = article.parseExpression($menu.$sourceType, record, values);
					var $sourceMenu = article.$menus[$menu.$bind];
					if (($menu.$type.indexOf("{") != 0) && $sourceMenu && !$sourceMenu.$target) {
						$menu.$target = (($menu.$type.indexOf('json') == -1) && ($menu.$type != "html")) ? "blank" : "";
					}
				}
				callback(article.parseExpression($menu.$sourceUrl || $menu.$url, record, values));
			}
		});
	} else {
		callback(article.parseExpression($menu.$sourceUrl || $menu.$url, record, undefined, $menu.$subRecordKey, undefined, true));
	}
}

exports.formatMenuUrl = function(article, $menu, record, callback) {
	if (callback) {
		_formatMenuUrlWithCallback(article, $menu, record, callback);
	} else {
		var properties;
		if ($menu.$parameters) {
			properties = _formatParameters(article, $menu.$parameters, record);
		}
		return article.parseExpression($menu.$sourceUrl || $menu.$url, record, properties, $menu.$subRecordKey, undefined, true);
	}
};


exports.notifyParametersActionChange = function(article, menu, record, target, request) {
	menu.$parameters.$title = menu.getTitle ? menu.getTitle() : null;
	_formatParameters(article, menu.$parameters, record, function(values, isCanceled) {
		if (!isCanceled) {
			var $bindAction = request[Object.keys(request)[0]];
			$bindAction.$parameters = {};
			delete values.$title;
			var props = Object.keys(values);
			for (var ii = 0, jj = props.length; ii < jj; ii++) {
				$bindAction.$parameters[props[ii]] = values[props[ii]];
			}
			article.page.notifyActionChange(menu, target, request);
		}
	});
};