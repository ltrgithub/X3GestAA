"use strict";
var _log;

var _emptyLog = {
	enable: function(isEnabled) {
		if (isEnabled) {
			window.syra_log = (_log = _log || new Log());
		}
	},
	object: function(key, object, stringify) {},
	startChange: function(item) {},
	applyChange: function(item, newData) {},
	endChange: function() {},
	setValue: function(field, value, meta) {},
	add: function(item, $item) {},
	startLoad: function(item) {},
	endLoad: function() {}
};

function Log() {
	this.hideChange = this.isDisabled = false;
	this.binds = "";
	this.enable = function(isEnabled) {
		if (!isEnabled) {
			window.syra_log = _emptyLog;
		}
	};
	this.object = function(key, object, stringify) {
		if (!this.isDisabled) {
			try {
				if (object !== undefined) {
					if (typeof(object) == 'object') {
						console.groupCollapsed(key);
						if (stringify === false) {
							console.dir(object);
						} else {
							console.log("%c" + JSON.stringify(object, null, 2), "color:blue;");
						}
						console.groupEnd();
					} else {
						console.log("%c" + key + ": " + object, "color:blue;");
					}
				}
			} catch (error) {

			}
		}
	};
	this.startChange = function(item) {
		if (this.hideChange) {
			return;
		}
		console.groupCollapsed(item.constructor.name + " startChange");
	};
	this.applyChange = function(item, newData) {
		if (this.hideChange) {
			return;
		}
		if (newData) {
			var info = item.constructor.name + " applyChange ";
			if (item.$uuid) {
				info += item.$uuid;
			}
			if (newData && newData.$isPartialDelta) {
				info += " Classic";
			}
			console.groupCollapsed(info);
			this.object("newData", newData);
		} else {
			console.groupEnd();
		}
	};

	this.endChange = function() {
		if (this.hideChange) {
			return;
		}
		console.groupEnd();
	};

	this.setValue = function(field, value, meta) {
		if (this.binds) {
			if (!field.$item || !(this.binds.indexOf(field.$item.$bind) >= 0)) {
				return;
			}
		}
		var key = field.constructor.name;
		if (field.$item && field.$item.$bind) {
			key += " $bind: " + field.$item.$bind;
		}
		console.groupCollapsed(key + " setValue");
		this.object("value", value);
		this.object("meta", meta);
		console.groupEnd();
	};

	this.add = function(item, $item) {
		if (this.binds) {
			if (!item.$item || !(this.binds.indexOf(item.$item.$bind) >= 0)) {
				return;
			}
		}
		var key = "";
		if (item) {
			if (item.constructor.name == "MenuBlockField") {
				return;
			}
			key = item.constructor.name;
		}
		if ($item.$bind) {
			key += " $bind: " + $item.$bind;
		}
		this.object(key + " add", $item);
	};

	this.startLoad = function(item) {
		if (this.hideLoad) {
			return;
		}
		var info = item.constructor.name + " load";
		switch (item.constructor.name) {
			case "Layout":
				info = " $layoutType:" + item.$item.$layoutType;
				break;
			case "RecordArticle":
				if (item.isFilterArticle) {
					info = " isFilterArticle";
				}
				if (item.list) {
					info = "List " + item.list.$item.$bind + " " + info;
				}
				break;

		}
		console.groupCollapsed(info);
		if (item.isDesktopPage) {
			var keys = ["$authorUrl", "$facet", "$isEditMode", "$pageCategory", "$pageCollaborationUrl", "$authorUrl"];
			for (var ii = 0, jj = keys.length; ii < jj; ii++) {
				var key = keys[ii];
				if (item[key] !== undefined) {
					if (typeof item[key] === "object") {
						console.log("%c" + key + ": \t" + JSON.stringify(item[key], null, 2), "color:blue;");
					} else {
						console.log("%c" + key + ": \t" + item[key], "color:blue;");
					}
				}
			}
			this.object("urlSeg", item.urlSeg, false);
			this.object("$item", item.$item, false);
			this.object("$prototype", item.$prototype, false);
			this.object("$preferences", item.$preferences);
		}
	};
	this.endLoad = function() {
		if (this.hideLoad) {
			return;
		}
		console.groupEnd();
	};
}




exports.enable = function(isEnabled) {
	if (!_log) {
		_log = new Log();
	}
	if (isEnabled) {
		return _log;
	}
	if (!_emptyLog) {
		_emptyLog = {};
		for (var prop in _log) {
			_emptyLog[prop] = function() {};
		}
	}
	return _emptyLog;
};



exports.load = function() {
	window.syra_log = _emptyLog;
};