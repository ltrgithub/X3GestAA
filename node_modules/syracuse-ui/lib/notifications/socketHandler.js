"use strict";
var helpers = require('syracuse-core/lib/helpers');
var io = require('syracuse-ui/deps/socket.io-client/socket.io');

/// !doc
///
/// # socketHandle API
/// This module allow the client framework to register any kind of event in order
//  to receive push server message and emit in return message to server
/// ``` javascript
/// var SocketHandler = require('syracuse-x3/lib/notifications/SocketHandler').create();
///
///
var SocketHandler = helpers.defineClass(function() {
	this.listSocketEvent = {};
	this.host = "http://" + window.location.host;
	this.listSocket = {};
	// on message receive

}, null, {
	///
	/// # register socketio event
	/// register for a specific path and socket io callback depending of event and return the socket instanciate by socket io
	/// var socketio = register(id, path [, messageEvent])
	///
	/// id : identifier of the registered events (session id or other...)
	/// namespace : namespace used by socket io. must be the same in the server.
	/// messageEvent : list of message event with id and callback function that the client can receive.
	/// socketio : object that allow the client to emit request and send the close socket event to the server.
	/// 	socketio.close(); // for send a close event to the server
	///
	/// 	socketio.emit(...) // follow the specs of socket.io
	/// 		message : string that identify the message that the server can received as a event
	///			data : data to send to the server that can be a JSON object or primitive type
	///
	///
	/// var messageEvent = {
	/// 	"event1" : function(socket){
	///      	//some code
	///     },
	/// 	"event2" : function(socket){
	///			// some code
	///     },...
	/// }
	///

	///
	///
	register: function(id, namespace, messageEvent) {
		this.listSocketEvent[id] = {
			namespace: namespace,
			messageEvent: messageEvent
		};
		this._initEvents(); // reinitialize event to manage
		// return a object that allow the client to emit request and close the client
		return {
			socket: this.listSocket[id],
			emit: function() {
				this.listSocket[id].emit.apply(this, arguments);
			},
			close: function() {
				this.listSocket[id].emit("disconnect", "");
			}
		};
	},

	///
	/// # unregister socketio event
	/// unregister socket io event identified by an id
	/// unregister: function(id)
	///
	/// id : identifier of the registered events
	///
	unregister: function(id) {
		delete this.listSocketEvent[id];
		this._initEvents(); // reinitialize event to manage
	},

	_initEvents: function() {
		var self = this;
		Object.keys(this.listSocketEvent).forEach(function(key) {
			var event = self.listSocketEvent[key];
			if (event) {
				// check if we are already connected
				if (!self.listSocket[key])
					self.listSocket[key] = io.connect(self.host + event.namespace);

				// register all message
				event.messageEvent && Object.keys(event.messageEvent).forEach(function(k) {
					var message = event.messageEvent[k];
					self.listSocket[key].on(k, message);
				});

			}
		});
	},
});

///
/// # create an instance of socket Io handler
///
exports.create = function() {
	return new SocketHandler();
};