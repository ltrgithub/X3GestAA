"use strict";
var helpers = require('syracuse-core/lib/helpers');
var io = require('syracuse-ui/deps/socket.io-client/socket.io');


/// !doc
///
/// # SocketIo Object
/// This Class provide an abstract of all method provide by socket io to emit, broadcast and join a room.
/// ``` javascript
/// var SocketHandler = require('syracuse-x3/lib/notifications/SocketHandler').create();
///
///
var SocketIo = helpers.defineClass(function(socket) {
	this.socket = socket;
	this.listRoom = [];
}, null, {
	/// # emit socketio method
	///	emit(eventName, arg2, arg3..)
	emit: function() {
		this.socket.emit.apply(this, arguments);
	},
	/// # broadcast to all in the default room
	///	broadcast(eventName, arg2, arg3..)
	broadcast: function() { // to everyone or a specify rooms
		this.socket.broadcast.emit.apply(this, arguments);
	},
	/// # broadcast to specified room
	///	broadcast(eventName, arg2, arg3..)
	broadcastRoom: function(room) {
		this.socket.broadcast.to(room).emit.apply(this, arguments.slice(1));
	},
	/// # join a specified room
	///	join(roomName)
	joinRoom: function(room) {
		this.socket.join(room);
		this.listRoom.push(room);
	},
	/// # leave all joined rooms
	///	leaveRooms()
	leaveRooms: function() {
		this.listRoom.forEach(function(room) {
			this.socket.leave(room);
		});
	},
	/// # leave a specify room
	///	leaveRoom(room)
	leaveRoom: function(room) {
		delete this.listRom[this.listRoom.indeOf(room)];
		this.socket.leave(room);
	},
	/// # close send a disconnect event
	///	close()
	close: function() {
		this.socket.emit("disconnect");
	}
});

///
/// # socketHandle API
/// This module allow the client framework to register any kind of event in order
//  to receive push server message and emit in return message to server
/// ``` javascript
/// var SocketHandler = require('syracuse-x3/lib/notifications/SocketHandler').create();
///
///
var SocketHandler = helpers.defineClass(function() {
	this.listSocketEvent = {};
	this.host = "http://" + window.location.host;
	this.listSocket = {};
	// on message receive

}, null, {
	///
	/// # register socketio event
	/// register for a specific path and socket io callback depending of event and return the socket instanciate by socket io
	/// var socketio = register(id, path [, messageEvent])
	///
	/// id : identifier of the registered events (session id or other...)
	/// namespace : namespace used by socket io. must be the same in the server.
	/// messageEvent : list of message event with id and callback function that the client can receive.
	/// socketio : return a socketIo Object that allow the client to emit request and send the close socket event to the server.
	/// 	socketio.close(); // for send a close event to the server
	///
	/// 	socketio.emit(...) // follow the specs of socket.io
	/// 		message : string that identify the message that the server can received as a event
	///			data : data to send to the server that can be a JSON object or primitive type
	///
	///
	/// var messageEvent = {
	/// 	"event1" : function(socket){
	///      	//some code
	///     },
	/// 	"event2" : function(socket){
	///			// some code
	///     },...
	/// }
	///

	///
	///
	register: function(id, namespace, messageEvent) {
		this.listSocketEvent[id] = {
			namespace: namespace,
			messageEvent: messageEvent
		};
		this._initEvents(); // reinitialize event to manage
		// return a object that allow the client to emit request and close the client
		return new SocketIo(this.listSocket[id]);

	},

	///
	/// # unregister socketio event
	/// unregister socket io event identified by an id
	/// unregister: function(id)
	///
	/// id : identifier of the registered events
	///
	unregister: function(id) {
		delete this.listSocketEvent[id];
		this._initEvents(); // reinitialize event to manage
	},

	_initEvents: function() {
		var self = this;
		Object.keys(this.listSocketEvent).forEach(function(key) {
			var event = self.listSocketEvent[key];
			if (event) {
				// check if we are already connected
				if (!self.listSocket[key])
					self.listSocket[key] = io.connect(self.host + event.namespace);

				// register all message
				event.messageEvent && Object.keys(event.messageEvent).forEach(function(k) {
					var message = event.messageEvent[k];
					self.listSocket[key].on(k, message);
				});

			}
		});
	},
});

///
/// # create an instance of socket Io handler
///
exports.create = function() {
	return new SocketHandler();
};