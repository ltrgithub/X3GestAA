"use strict";
var _subModuleMenuBlock = require('./subModuleMenuBlock');
var _menuItem = require('./menuItem');
var _megaDetailPanel = require('./megaDetailPanel');

var LAST_COL_INDEX = 3;

function SubModule() {

}

SubModule.prototype.onItemInOut = function(onEnter) {
	if (onEnter) {
		this.activate(true);
		var list = this.submoduleList;
		if (list && !list.adjusted) {
			list.adjusted = true;
			var overflowContent = [];
			var maxX = this.page.popup.clientHeight;
			var firtstCol = list.cols[0].slot;
			while (this.page.popup.scrollHeight > maxX && firtstCol.childNodes.length) {
				var child = firtstCol.lastChild;
				syra_dom.remove(child);
				overflowContent.push(child);
			}
			if (overflowContent.length) {
				//  Start adding the array elements to the new column slot in reverse order.
				var col = list._addColumn();
				this.page.popup.appendChild(col.slot); //popupBody
				for (var ii = overflowContent.length - 1; ii > -1 /*&& newColumn < LAST_COL_INDEX*/ ; ii--) {
					col.slot.appendChild(overflowContent[ii]);
					if (maxX < this.page.popup.scrollHeight) {
						this.page.popup.removeChild(this.page.popup.lastChild); //popupBody
						if (list.cols.length === LAST_COL_INDEX)
							break;
						col = list._addColumn();
						this.page.popup.appendChild(col.slot); //popupBody
						ii++;
					}
				}
			}
		}
	}
};

SubModule.prototype.onActivated = function() {
	if (this.mode == "large") {
		this.page.popup.appendChild(this.body); //popupBody
	} else {
		this.megaDetailPanel.activate();
	}
};
SubModule.prototype.activate = function(on) {
	this.page.activateItem(this, on);
};
SubModule.prototype.setVolumeSize = function(dataset) {
	/*
     * We always show the left-side vertical menu (#1).
     * We show an adjacent 2nd vertical menu (#2) if either:
     1) there are 7 or more entries at the level of menu #2
     2) excluding menu #1, there are 3 or more sublevels,
     *
     * Otherwise, don't display menu #2, but rather just an options area.
     */
	var items = dataset && dataset.items;
	if (items) {
		if (this.hasLargeVolumeDepth(items)) {
			this.mode = "large";
		} else {
			this.mode = "small";
		}
	}
};
SubModule.prototype.hasLargeVolumeDepth = function(items, isLastLevel) {
	var blockCount = 0;
	for (var ii = 0, jj = items.length; ii < jj; ii++) {
		if (items[ii].menuBlock) {
			blockCount++;
			if (isLastLevel) {
				return true;
			} else {
				return this.hasLargeVolumeDepth(items[ii].menuBlock.items, true);
			}
		}
	}
	return blockCount > 6;
};
SubModule.prototype.dispose = function() {
	syra_item.unregister(this);
	syra_site.disposeObject(this);
};



exports.add = function(module, parentNode, dataset) {
	var sub = syra_item.initialize(module.page, new SubModule());
	sub.navParent = module;

	sub.setVolumeSize(dataset);

	sub.maxColumns = (sub.page.isHighRes && sub.mode === "large") ? 5 : 4;

	//article compatiblity
	sub.dataset = dataset;
	sub.$prototype = module.$prototype.$properties.submodules.$item;
	sub.articleParent = sub.boxParent = module;

	sub.slot = syra_dom.li('s-mega-submodule');
	sub.slot.syrainout = sub.id;
	sub.title = syra_dom.div("s-mega-submodule-title", sub.slot);
	sub.title.textContent = dataset.title;

	sub.body = syra_dom.ul("s-mega-submodules-level-2");

	if (sub.mode == "small") {
		sub.megaDetailPanel = _megaDetailPanel.add(sub);
		sub.body.className += " s-mega-block-detail";
	}
	sub.children = [];
	for (var ii = 0, jj = dataset.items.length; ii < jj; ii++) {
		var item = dataset.items[ii];
		var dataItem = item.menuItem || item.menuBlock;
		if (dataItem) {
			var slot;
			if (sub.mode == "large") {
				slot = syra_dom.li("s-mega-sub-menu-block-slot", sub.body);
			} else {
				slot = syra_dom.li("s-nav-mega-link-parent", sub.megaDetailPanel.firstColumnSlot());
			}

			var child;
			if (item.menuItem) {
				child = _menuItem.add(sub);
				child.$skin = sub.page.$skin + ((sub.mode == "large") ? "-submodule-link" : "-link");
			} else { //item.menuBlock
				child = _subModuleMenuBlock.add(sub);
				child.isHLayout = sub.mode == "large";
			}
			sub.children.push(child);
			child.slot = slot;
			child.load(dataItem);
			if (slot != child.domItem) {
				slot.appendChild(child.domItem);
			}
		}
	}
	parentNode.appendChild(sub.slot);
	return sub;
};