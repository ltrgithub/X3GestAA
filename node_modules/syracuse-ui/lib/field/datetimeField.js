"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var _choiceType = {
	time: require('syracuse-ui/lib/field/datetime/timeChoice').TimeChoice,
	date: require('syracuse-ui/lib/field/datetime/dateChoice').DateChoice
};
var formatApi = require('syracuse-ui/lib/field/formatApi');
var datetime = require('syracuse-core/lib/types/datetime');


var _formatter = {
	"application/x-date": function(field, val) {
		var directives = ["dirOne", "dirTwo", "dirThree"];
		var fObj = field.formatObj;
		var s = fObj.separator;
		var splitted = val.split(/[^\d]+/); // split into numeric groups
		var twoDigitYearMax = formatApi.getLocale().getTwoDigitYearMax().toString();
		switch (splitted.length) {
			case 1:
				// assuming 2 digits min per directive (ex: ddMMyy)
				var date = splitted[0];
				var dateLen = date.length;
				switch (dateLen) {
					case 6:
						for (var ii = 0, jj = directives.length; ii < jj; ii++) {
							var dir = directives[ii];
							var f = fObj[dir];
							var max = f.max;
							// if 'y' dir is encountered before the end, year.length is 2
							var yBeforeEnd = dir != directives[directives.length - 1] && f.dir == 'y';
							f.date = yBeforeEnd ? date.substring(0, 2) : date.substring(0, max);
							//f.date = date.substring(0, max);
							// dealing with y case
							if (f.dir == "y") {
								var len = f.date.length;
								switch (len) {
									case 2:
										// yy < yyyy ?
										f.date = len < max ? (f.date > twoDigitYearMax.substring(2) ? "19" + f.date : "20" + f.date) : f.date;
										break;
									default:
										throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
								}
							}
							date = date.substring(yBeforeEnd ? 2 : max);
						}
						break;
					case 8:
						for (var ii = 0, jj = directives.length; ii < jj; ii++) {
							var dir = directives[ii];
							var f = fObj[dir];
							var max = f.max;
							// If it is the last directive, the remaining of date value is considered --> substring(0)
							f.date = dir == directives[directives.length - 1] ? date.substring(0) : date.substring(0, max);
							// dealing with y case
							if (f.dir == "y") {
								var len = f.date.length;
								switch (len) {
									case 4:
										// yyyy > yy ?
										f.date = f.date.length > f.max ? f.date.substring(2) : f.date;
										break;
									default:
										throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
										//return err;
								}
							}
							date = date.substring(max);
						}
						break;
					default:
						throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
				}
				break;
			case 3:
				// day, month and year
				var i = 0;
				for (var mm = 0, jj = splitted.length; mm < jj; mm++) {
					var spl = splitted[mm];
					var f = fObj[directives[i]];
					var max = f.max;
					if (/[dM]/.test(f.dir) && spl.length > max) { // splitted number length cannot exceed directive maxLength for "d" and "M" directives
						throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
					} else {
						f.date = spl;
						// dealing with y case
						if (f.dir == "y") {
							var len = f.date.length;
							switch (len) {
								case 2:
									// yy < yyyy ?
									f.date = f.date.length < max ? (f.date > twoDigitYearMax.substring(2) ? "19" + f.date : "20" + f.date) : f.date;
									break;
								case 4:
									// yyyy > yy ?
									f.date = f.date.length > max ? f.date.substring(2) : f.date;
									break;
								default:
									throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
							}
						}
					}
					++i;
				}
				break;
			default:
				throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
		}
		return field.formatApi.parse(fObj[directives[0]].date + s + fObj[directives[1]].date + s + fObj[directives[2]].date, field.localFormat);
	},
	"application/x-time": function(field, val) {
		var times = val.split(/[^\d]+/);
		if (times.length == 1) {
			var str = times[0] + "";
			times = null;
			switch (str.length) {
				case 4:
					times = [str.substring(0, 2), str.substring(2)]; // hhmm
					break;
				case 6:
					times = [str.substring(0, 2), str.substring(2, 4), str.substring(4)]; // hhmmss
					break;
			}
		}
		if (!times || (times.length > 3)) {
			throw new Error(syra_local.dfInvalidTime + " : " + val);
		}
		var am = field.formatApi.amDesignator().toUpperCase();
		var pm = field.formatApi.pmDesignator().toUpperCase();
		var upper = val.toUpperCase();
		var hasAM = upper.indexOf(am) >= 0;
		var hasPM = upper.indexOf(pm) >= 0;
		if (hasAM || hasPM) {
			var hour = parseInt(times[0], 10);
			if (hour > 12)
				throw new Error(syra_local.dfInvalidTime + " : " + val);
			if (hasAM) {
				hour = hour == 12 ? 0 : hour;
			} else {
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
			}
			times[0] = hour;
		}
		for (var ii = 0; ii < 3; ii++) {
			times[ii] = (times[ii] || "0") + "";
			times[ii] = "00".slice(times[ii].length) + times[ii];
		}
		return field.formatApi.parse(times.join(":"));
	},
	"application/x-datetime": function(field, val) {
		return val;
	}
};


function _onPickerClick(options) {
	var field = this.parent;
	field.focus();
	if (!field.popupPicker) {
		field.domItem.id = field.id;
		field.selector = new _choiceType[this.pickerId]();
		field.selector.create(field, options);
		field.popupPicker = syra_over.openPopup(field.boxParent, {
			content: field,
			slot: field.selector.domItem,
			picker: field.layoutSlot,
			position: {
				my: "right top",
				at: "right bottom",
				of: field._dataValue
			},
			close: function() {
				setTimeout(function() {
					if (field.selector) {
						field.selector.remove();
						field.selector = null;
					}
					field.popupPicker = null;
				}, 100);
			}
		});
	} else {
		field.popupPicker.close();
	}
}

function DateTimeField() {}

exports.DateTimeField = helpers.defineClass(DateTimeField, Field, {
	applyEscape: function() {
		return this.popupPicker && this.popupPicker.close();
	},
	applyShortCut: function(shortcuts, event) {
		event.altKey || shortcuts.up;
		if (event.altKey) {
			if (shortcuts.down && !this.popupPicker) {
				(this.picker_date || this.picker_time).link.click();
				return true;
			}
		}
		return this.selector && this.selector.applyShortCut(shortcuts, event);
	},

	setButtonValue: function(formatedValue, internalValue) {
		var self = this;
		this.popupPicker.close();
		if (!this.$isReadOnly) {
			this.page.externalAdapter.setButtonValue({
				target: this,
				value: formatedValue,
				internalValue: internalValue,
				doStatements: function(options) {
					self.setInputValue(options.value);
					self.input.focus();
					$(self.input).change();
				}
			});
		}
	},
	render: function() {
		if (this.$isEditMode) {
			if (this.$field.$type != "application/x-datetime") {
				this.input = syra_dom.addInput(this.$skinInput, this._dataValue);
				if (this.$item.$css) {
					this.input.className += " " + this.$item.$css;
				}
				syra_button.addFieldPicker({
					parent: this,
					pickerId: this.isTimeField ? "time" : "date",
					fontIcon: this.isTimeField ? "time" : "date",
					text: this.isTimeField ? syra_local.dfSelectTime : syra_local.dfSelectDate,
					shortCutTip: syra_shortCuts.tip.openDatePick,
					click: _onPickerClick
				});

			} else {
				this.input = syra_dom.addInput(this.$skinInput, this._dataValue);
			}
		} else {
			Field.prototype.render.call(this);
		}
	},
	initialize: function() {
		this.pickerCount = 1;
		this.$cssFieldType = "s-date";
		//if (!this.formatApi) {
		this.formatApi = formatApi.getApi(this.$field.$type);
		this.localFormat = formatApi.getLocalFormat(this.$field.$type);
		this._formatInput = _formatter[this.$field.$type];
		//}
		this.localFormatDisplay = formatApi.getLocalFormat(this.$field.$type, this.$field.$format);
		this.$field.$maxLength = this.localFormatDisplay.length;
		switch (this.$field.$type) {
			case "application/x-time":
				this.isTimeField = true;
				break;
			case "application/x-date":
				//temp waiting format updating
				var max = 0;
				this.formatObj = formatApi.processFormat(this.localFormat);
				max += ((this.formatObj.dirOne && this.formatObj.dirOne.max) || 0);
				max += ((this.formatObj.dirTwo && this.formatObj.dirTwo.max) || 0);
				max += ((this.formatObj.dirThree && this.formatObj.dirThree.max) || 0);
				max += (this.formatObj.separator ? 2 : 0);
				this.$field.$maxLength = Math.max(this.$field.$maxLength, max);
				break;
		}
		//temp come from convergence to clean
		if (this.formatEx) {
			this.formatApi = this.formatEx.formatApi;
			this.localFormat = this.formatEx.localFormat;
			this.localFormatDisplay = this.formatEx.localFormatDisplay;
			this.formatObj = this.formatEx.formatObj;
			this._formatInput = this.formatEx._formatInput;
			delete this.formatEx;
		}
	},
	setValue: function(value, metaData) {
		this.displayText = "";
		this.currentValue = value;
		try {
			if (this.currentValue !== undefined && this.currentValue !== null) {
				var dateObj = this.formatApi.parse(this.currentValue);
				if (this.isTimeField || !dateObj.isNull()) {
					this.displayText = dateObj.toString(this.$isEditMode ? this.localFormat : this.localFormatDisplay);
				} else {
					this.currentValue = null;
				}

			}
			if (this.$isEditMode) {
				this.setInputValue(this.displayText);
			} else {
				if (this.displayText && !this.$isDetailLinkDisabled && this.$menus && this.$menus.$details) {
					syra_fields.addDetailLink(this, this.displayText, this.$menus.$details);
				} else {
					this._dataValue.textContent = this.displayText;
				}
			}
		} catch (error) {
			syra_fields.invalidate(this, error.message);
		}
		syra_menus.pickers.menus.show(this);
		this.applyMetaData(metaData);
	},
	getDisplayText: function() {
		return this.displayText || "";
	},

	parseMask: function(val) {
		var dayOffset = null,
			dateObj, newVal = null;
		if (val === "0") {
			dayOffset = 0;
		} else
		if (val.length > 1 && (val[0] == "+" || val[0] == "-")) {
			dayOffset = parseInt(val, 10);
			if (isNaN(dayOffset)) {
				dayOffset = null;
			}
		}
		if (dayOffset != null) {
			dateObj = datetime.now().addDays(dayOffset);
			if (!this.page.externalAdapter.getFormatedValFromHelperVal) {
				newVal = dateObj.toString(this.localFormat || formatApi.getLocalFormat(this.$field.$type));
			} else {
				newVal = this.page.externalAdapter.getFormatedValFromHelperVal(this, dateObj);
			}
		}
		return newVal;
	},
	validate: function(errors, value) {
		if (this.$field.$type == "application/x-date") {
			if (value) {
				var dateObj = this._formatInput(this, this.input.value);
				this.formatApi.validate(dateObj, {
					$isMandatory: this.$isMandatory,
					$isNullable: this.$isNullable
				}, errors);
			}
		}
	},
	getValue: function(entity, index, event) {
		if (this.input) {
			var val = this.getInputValue();
			if (!event) {
				var inputHelper = this.parseMask(val);
				if (inputHelper) {
					val = this.input.value = inputHelper;
				} else {
					if (val) {
						var dateObj = this._formatInput(this, this.input.value);
						val = this.input.value = dateObj.toString(this.localFormat);
						val = val ? this.formatApi.parse(val, this.localFormat).toString() : null;
					}
				}
			}
			return val || null;
		}
		return this.currentValue;
	}
});