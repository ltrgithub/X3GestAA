"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var selectorType = {
	time: require('syracuse-ui/lib/field/datetimeSelectors/timeSelector').TimeSelector,
	date: require('syracuse-ui/lib/field/datetimeSelectors/dateSelector').DateSelector
};
var formatApi = require('syracuse-ui/lib/field/formatApi');

function _clean(arr) {
	return $.grep(arr, function(n) {
		return (n);
	});
}

var _formatter = {
	"application/x-date": function(field, val) {
		var directives = ["dirOne", "dirTwo", "dirThree"];
		var fObj = field.formatObj;
		var s = fObj.separator;
		var splitted = val.split(/[^\d]+/); // split into numeric groups
		splitted = _clean(splitted);
		var splittedLen = splitted.length;
		var twoDigitYearMax = formatApi.getLocale().getTwoDigitYearMax().toString();
		switch (splittedLen) {
			case 1:
				// assuming 2 digits min per directive (ex: ddMMyy)
				var date = splitted[0];
				var dateLen = date.length;
				switch (dateLen) {
					case 6:
						for (var ii = 0, jj = directives.length; ii < jj; ii++) {
							var dir = directives[ii];
							var f = fObj[dir];
							var max = f.max;
							// if 'y' dir is encountered before the end, year.length is 2
							var yBeforeEnd = dir != directives[directives.length - 1] && f.dir == 'y';
							f.date = yBeforeEnd ? date.substring(0, 2) : date.substring(0, max);
							//f.date = date.substring(0, max);
							// dealing with y case
							if (f.dir == "y") {
								var len = f.date.length;
								switch (len) {
									case 2:
										// yy < yyyy ?
										f.date = len < max ? (f.date > twoDigitYearMax.substring(2) ? "19" + f.date : "20" + f.date) : f.date;
										break;
									default:
										throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
								}
							}
							date = date.substring(yBeforeEnd ? 2 : max);
						}
						break;
					case 8:
						for (var ii = 0, jj = directives.length; ii < jj; ii++) {
							var dir = directives[ii];
							var f = fObj[dir];
							var max = f.max;
							// If it is the last directive, the remaining of date value is considered --> substring(0)
							f.date = dir == directives[directives.length - 1] ? date.substring(0) : date.substring(0, max);
							// dealing with y case
							if (f.dir == "y") {
								var len = f.date.length;
								switch (len) {
									case 4:
										// yyyy > yy ?
										f.date = f.date.length > f.max ? f.date.substring(2) : f.date;
										break;
									default:
										throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
										//return err;
								}
							}
							date = date.substring(max);
						}
						break;
					default:
						throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
				}
				break;
			case 3:
				// day, month and year
				var i = 0;
				for (var mm = 0, jj = splitted.length; mm < jj; mm++) {
					var spl = splitted[mm];
					var f = fObj[directives[i]];
					var max = f.max;
					if (/[dM]/.test(f.dir) && spl.length > max) { // splitted number length cannot exceed directive maxLength for "d" and "M" directives
						throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
					} else {
						f.date = spl;
						// dealing with y case
						if (f.dir == "y") {
							var len = f.date.length;
							switch (len) {
								case 2:
									// yy < yyyy ?
									f.date = f.date.length < max ? (f.date > twoDigitYearMax.substring(2) ? "19" + f.date : "20" + f.date) : f.date;
									break;
								case 4:
									// yyyy > yy ?
									f.date = f.date.length > max ? f.date.substring(2) : f.date;
									break;
								default:
									throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
							}
						}
					}
					++i;
				}
				break;
			default:
				throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
		}
		// setting formatted input value
		var dateObj = field.formatApi.parse(fObj[directives[0]].date + s + fObj[directives[1]].date + s + fObj[directives[2]].date, field.localFormat);
		return dateObj;
		//return dateObj.toString(field.localFormat);
	},
	"application/x-time": function(field, val) {
		var splitted = val.split(/[^\d]+/); // split into numeric groups
		splitted = _clean(splitted);
		var splittedLen = splitted.length;
		var hour = '00',
			minute = '00',
			second = '00';
		field.isTimeField = true;
		switch (splittedLen) {
			case 1:
				// assuming 2 digits min per directive (ex: hhmmss)
				var time = splitted[0];
				switch (time.length) {
					case 4:
						// hhmm
						hour = time.substring(0, 2);
						minute = time.substring(2);
						break;
					case 6:
						// hhmmss
						hour = time.substring(0, 2);
						minute = time.substring(2, 4);
						second = time.substring(4);
						break;
					default:
						throw new Error(syra_local.dfInvalidTime + " : " + val);
				}
				break;
			case 2:
				// hour and minute
				var hour = splitted[0];
				var minute = splitted[1];
				break;
			case 3:
				// hour, minute and second
				var hour = splitted[0];
				var minute = splitted[1];
				var second = splitted[2];
				break;
			default:
				throw new Error(syra_local.dfInvalidTime + " : " + val);
		}
		var am = field.formatApi.amDesignator();
		var pm = field.formatApi.pmDesignator();
		var hasAM = val.indexOf(am.toUpperCase()) > -1 || val.indexOf(am.toLowerCase()) > -1;
		var hasPM = val.indexOf(pm.toUpperCase()) > -1 || val.indexOf(pm.toLowerCase()) > -1;
		if (hasAM || hasPM) {
			hour = parseInt(hour, 10);
			if (hour > 12)
				return "invalid time. With AM/PM designator, hour value cannot be greater than 12";
			if (hasAM)
				hour = hour == 12 ? 0 : hour;
			else {
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
			}
		}
		hour = hour.toString().length < 2 ? '0' + hour : hour.toString();
		minute = minute.toString().length < 2 ? '0' + minute : minute.toString();
		second = second.toString().length < 2 ? '0' + second : second.toString();

		// formatting
		var timeObj = field.formatApi.parse(hour + ":" + minute + ":" + second);
		return timeObj;
	},
	"application/x-datetime": function(field, val) {
		return val;
	}
};

function DateTimeField() {}

exports.DateTimeField = helpers.defineClass(DateTimeField, Field, {
	applyEscape: function(shortcuts, event) {
		if (this.popupPicker) {
			this.popupPicker.close();
			return true;
		} else {
			return Field.prototype.applyEscape.call(this, shortcuts, event);
		}
		return false;
	},
	applyShortCuts: function(shortcurts, event) {
		if (shortcurts.down) {
			this.mnPickers.date && this.mnPickers.date.click();
			this.mnPickers.time && this.mnPickers.time.click();
			return true;
		}
		return Field.prototype.applyShortCuts.call(this, shortcurts, event);
	},
	onDateTimePickerClick: function(picker, options) {
		var self = this;
		self.focus();
		if (!self.popupPicker) {
			self.domItem.id = self.id;
			self.selector = new selectorType[picker.syraPickerType]();
			self.selector.create(self, options);
			self.popupPicker = syra_site.dialogManager.openPopup(self.boxParent, {
				content: self,
				slot: self.selector.domItem,
				position: {
					my: "right top",
					at: "right bottom",
					of: $(self.domValueSlot)
				},
				onClose: function() {
					setTimeout(function() {
						if (self.selector) {
							self.selector.remove();
							self.selector = null;
						}
						self.popupPicker = null;
					}, 200);
				}
			});
		} else {
			self.popupPicker.close();
		}

	},
	setButtonValue: function(formatedValue, internalValue) {
		var self = this;
		this.popupPicker.close();
		if (!this.$isReadOnly) {
			this.page.externalAdapter.setButtonValue({
				target: this,
				value: formatedValue,
				internalValue: internalValue,
				doStatements: function(options) {
					self.setInputValue(options.value);
					self.input.focus();
					$(self.input).change();
				}
			});
		}
	},
	render: function() {
		if (this.$isEditMode) {
			if (this.$field.$type != "application/x-datetime") {
				this.input = document.createElement("input");
				this.input.setAttribute("type", "text");
				syra_site.setSpecificAttributes(this.input);
				this.input.className = this.$skinInput;
				if (this.$item.$css) {
					this.input.className += " " + this.$item.$css;
				}
				this.fieldValue.appendChild(this.input);
				syra_menus.addPicker(this, this.isTimeField ? "time" : "date", this.isTimeField ? syra_local.dfSelectTime : syra_local.dfSelectDate);
			} else {
				this.input = document.createElement("input");
				this.input.setAttribute("type", "text");
				syra_site.setSpecificAttributes(this.input);
				this.input.className = this.$skinInput;
				this.fieldValue.appendChild(this.input).className = this.$skinInput;
			}
		} else {
			Field.prototype.render.call(this);
		}
	},
	initialize: function() {
		this.pickerCount = 1;
		this.$cssFieldType = "s-date";
		this.formatApi = formatApi.getApi(this.$field.$type);
		this.localFormat = formatApi.getLocalFormat(this.$field.$type);
		this.localFormatDisplay = formatApi.getLocalFormat(this.$field.$type, this.$field.$format);
		this._formatInput = _formatter[this.$field.$type];
		// for application/x-date type only for now
		if (this.$field.$type == "application/x-date")
			this.formatObj = formatApi.processFormat(this.localFormat);
		if (this.formatEx) {
			// Overwrite format APIs  "formatApi", "localFormat", "localFormatDisplay", "formatObj", etc...
			helpers.object.extendEx(this, this.formatEx);
		}
	},
	setDataValue: function(value) {
		if (value !== undefined && value !== null) {
			try {
				var dateObj = this.formatApi.parse(value);
				if (this.$field.$type == "application/x-time") {
					this._setNotNullDataValue(value, dateObj);
				} else {
					if (!dateObj.isNull()) {
						this._setNotNullDataValue(value, dateObj);
					} else {
						this._setNullDataValue();
					}
				}
			} catch (error) {
				this.showErrors([error.message]);
			}
		} else {
			if (value === null) {
				this._setNullDataValue();
			}
		}
		syra_menus.ensureMenuPicker(this);
	},
	_setNotNullDataValue: function(value, dateObj) {
		var formated;
		this.currentValue = value;
		if (this.$isEditMode) {
			this.setInputValue(formated = dateObj.toString(this.localFormat));
			this.input.setAttribute("placeholder", this.localFormat);
		} else {
			formated = dateObj.toString(this.localFormatDisplay);
			if (formated && !this.$isDetailLinkDisabled && this.$menus && this.$menus.$details) {
				this.appendDetailLink(formated, this.$menus.$details);
			} else {
				this.fieldValue.textContent = formated;
			}
		}
		this.fieldHelper.setValueLength(this, formated);

	},
	_setNullDataValue: function() {
		if (this.$isEditMode) {
			this.setInputValue("");
			this.input.setAttribute("placeholder", "");
		} else {
			syra_site.dom.empty(this.fieldValue);
			this.fieldValue.textContent = "";
		}
	},
	getDataValue: function() {
		var val = this.getInputValue();
		return val ? this.formatApi.parse(val, this.localFormat).toString() : null;
	},
	onInputValidate: function(event) {
		try {
			var newValue = this.getDataValue();
			if (newValue != this.currentValue) {
				this.notifyFieldChange(newValue);
			}
		} catch (error) {
			this.showErrors([error.message]);
		}
	},
	onInputChange: function(input, event) {
		try {
			var self = this,
				errors = []; //, val = input.value, valFormatted = val;
			// for application/x-date and application/x-time types only for now
			if (input.value != '') {
				// applying api validation rules
				var rawVal = self._formatInput(self, input.value);
				var constraints = {
					$isMandatory: self.$isMandatory,
					$isNullable: self.$isNullable
				};
				self.formatApi.validate(rawVal, constraints, errors);

				// formatted value to send to server
				input.value = rawVal.toString(self.localFormat);
				//input.value = valFormatted = this._formatInput(self, val);
			}

			if (self.validate(input.value, errors)) {
				self.onInputValidate(event);
			}
		} catch (error) {
			this.showErrors([error.message]);
		}
	},
	dispose: function() {
		this.formatApi = this.localFormatDisplay = this.localFormat = this._formatInput = this.formatObj = null;
		if (this.formatEx) {
			var keys = Object.keys(this.formatEx);
			for (var ii = 0, jj = keys.length; ii < jj; ii++) {
				delete this.formatEx[keys[ii]];
			}
		}
		Field.prototype.dispose.call(this);
	}
});