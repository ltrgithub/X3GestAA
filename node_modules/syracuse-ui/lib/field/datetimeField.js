"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var _choiceType = {
	time: require('syracuse-ui/lib/field/datetime/timeChoice').TimeChoice,
	date: require('syracuse-ui/lib/field/datetime/dateChoice').DateChoice
};
var formatApi = require('syracuse-ui/lib/field/formatApi');
var datetime = require('syracuse-core/lib/types/datetime');

var _formatter = {
	"application/x-date": function(field, val) {
		var directives = ["dirOne", "dirTwo", "dirThree"];
		var fObj = field.formatObj;
		var s = fObj.separator;
		var splitted = val.split(/[^\d]+/); // split into numeric groups
		var twoDigitYearMax = formatApi.getLocale().getTwoDigitYearMax().toString();
		switch (splitted.length) {
			case 1:
				// assuming 2 digits min per directive (ex: ddMMyy)
				var date = splitted[0];
				var dateLen = date.length;
				switch (dateLen) {
					case 6:
						for (var ii = 0, jj = directives.length; ii < jj; ii++) {
							var dir = directives[ii];
							var f = fObj[dir];
							var max = f.max;
							// if 'y' dir is encountered before the end, year.length is 2
							var yBeforeEnd = dir != directives[directives.length - 1] && f.dir == 'y';
							f.date = yBeforeEnd ? date.substring(0, 2) : date.substring(0, max);
							//f.date = date.substring(0, max);
							// dealing with y case
							if (f.dir == "y") {
								var len = f.date.length;
								switch (len) {
									case 2:
										// yy < yyyy ?
										f.date = len < max ? (f.date > twoDigitYearMax.substring(2) ? "19" + f.date : "20" + f.date) : f.date;
										break;
									default:
										throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
								}
							}
							date = date.substring(yBeforeEnd ? 2 : max);
						}
						break;
					case 8:
						for (var ii = 0, jj = directives.length; ii < jj; ii++) {
							var dir = directives[ii];
							var f = fObj[dir];
							var max = f.max;
							// If it is the last directive, the remaining of date value is considered --> substring(0)
							f.date = dir == directives[directives.length - 1] ? date.substring(0) : date.substring(0, max);
							// dealing with y case
							if (f.dir == "y") {
								var len = f.date.length;
								switch (len) {
									case 4:
										// yyyy > yy ?
										f.date = f.date.length > f.max ? f.date.substring(2) : f.date;
										break;
									default:
										throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
										//return err;
								}
							}
							date = date.substring(max);
						}
						break;
					default:
						throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
				}
				break;
			case 3:
				// day, month and year
				var i = 0;
				for (var mm = 0, jj = splitted.length; mm < jj; mm++) {
					var spl = splitted[mm];
					var f = fObj[directives[i]];
					var max = f.max;
					if (/[dM]/.test(f.dir) && spl.length > max) { // splitted number length cannot exceed directive maxLength for "d" and "M" directives
						throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
					} else {
						f.date = spl;
						// dealing with y case
						if (f.dir == "y") {
							var len = f.date.length;
							switch (len) {
								case 2:
									// yy < yyyy ?
									f.date = f.date.length < max ? (f.date > twoDigitYearMax.substring(2) ? "19" + f.date : "20" + f.date) : f.date;
									break;
								case 4:
									// yyyy > yy ?
									f.date = f.date.length > max ? f.date.substring(2) : f.date;
									break;
								default:
									throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
							}
						}
					}
					++i;
				}
				break;
			default:
				throw new Error(syra_local.dfInvalidDate + " : " + val + ". " + syra_local.dfFormat + " : " + field.localFormat);
		}
		// setting formatted input value
		var dateObj = field.formatApi.parse(fObj[directives[0]].date + s + fObj[directives[1]].date + s + fObj[directives[2]].date, field.localFormat);
		return dateObj;
		//return dateObj.toString(field.localFormat);
	},
	"application/x-time": function(field, val) {
		var times = val.split(/[^\d]+/);
		if (times.length == 1) {
			var str = times[0] + "";
			times = null;
			switch (str.length) {
				case 4:
					times = [str.substring(0, 2), str.substring(2)]; // hhmm
					break;
				case 6:
					times = [str.substring(0, 2), str.substring(2, 4), str.substring(4)]; // hhmmss
					break;
			}
		}
		if (!times || (times.length > 3)) {
			throw new Error(syra_local.dfInvalidTime + " : " + val);
		}
		var am = field.formatApi.amDesignator().toUpperCase();
		var pm = field.formatApi.pmDesignator().toUpperCase();
		var upper = val.toUpperCase();
		var hasAM = upper.indexOf(am) >= 0;
		var hasPM = upper.indexOf(pm) >= 0;
		if (hasAM || hasPM) {
			var hour = parseInt(times[0], 10);
			if (hour > 12)
				throw new Error(syra_local.dfInvalidTime + " : " + val);
			if (hasAM) {
				hour = hour == 12 ? 0 : hour;
			} else {
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
			}
			times[0] = hour;
		}
		for (var ii = 0; ii < 3; ii++) {
			times[ii] = (times[ii] || "0") + "";
			times[ii] = "00".slice(times[ii].length) + times[ii];
		}
		return field.formatApi.parse(times.join(":"));
	},
	"application/x-datetime": function(field, val) {
		return val;
	}
};


function _onPickerClick(options) {
	var field = this.parent;
	field.focus();
	if (!field.popupPicker) {
		field.domItem.id = field.id;
		field.selector = new _choiceType[this.pickerId]();
		field.selector.create(field, options);
		field.popupPicker = syra_site.dialogManager.openPopup(field.boxParent, {
			content: field,
			slot: field.selector.domItem,
			picker: field.layoutSlot,
			position: {
				my: "right top",
				at: "right bottom",
				of: $(field._dataValue)
			},
			onClose: function() {
				setTimeout(function() {
					if (field.selector) {
						field.selector.remove();
						field.selector = null;
					}
					field.popupPicker = null;
				}, 100);
			}
		});
	} else {
		field.popupPicker.close();
	}
}

function DateTimeField() {}

exports.DateTimeField = helpers.defineClass(DateTimeField, Field, {
	applyEscape: function() {
		return this.popupPicker && this.popupPicker.close();
	},
	applyShortCut: function(shortcuts, event) {
		event.shiftKey || shortcuts.up;
		if (event.shiftKey) {
			if (shortcuts.down && !this.popupPicker) {
				(this.picker_date || this.picker_time).link.click();
				return true;
			}
		}
		return this.selector && this.selector.applyShortCut(shortcuts, event);
	},

	setButtonValue: function(formatedValue, internalValue) {
		var self = this;
		this.popupPicker.close();
		if (!this.$isReadOnly) {
			this.page.externalAdapter.setButtonValue({
				target: this,
				value: formatedValue,
				internalValue: internalValue,
				doStatements: function(options) {
					self.setInputValue(options.value);
					self.input.focus();
					$(self.input).change();
				}
			});
		}
	},
	render: function() {
		if (this.$isEditMode) {
			if (this.$field.$type != "application/x-datetime") {
				this.input = document.createElement("input");
				this.input.setAttribute("type", "text");
				syra_site.setSpecificAttributes(this.input);
				this.input.className = this.$skinInput;
				if (this.$item.$css) {
					this.input.className += " " + this.$item.$css;
				}
				this._dataValue.appendChild(this.input);
				syra_menus.button.addFieldPicker({
					parent: this,
					pickerId: this.isTimeField ? "time" : "date",
					fontIcon: this.isTimeField ? "time" : "date",
					text: this.isTimeField ? syra_local.dfSelectTime : syra_local.dfSelectDate,
					shortCutTip: "ESC F12",
					btnclick: _onPickerClick
				});
			} else {
				this.input = document.createElement("input");
				this.input.setAttribute("type", "text");
				syra_site.setSpecificAttributes(this.input);
				this.input.className = this.$skinInput;
				this._dataValue.appendChild(this.input).className = this.$skinInput;
			}
		} else {
			Field.prototype.render.call(this);
		}
	},
	initialize: function() {
		this.pickerCount = 1;
		this.$cssFieldType = "s-date";
		this.formatApi = formatApi.getApi(this.$field.$type);
		this.localFormat = formatApi.getLocalFormat(this.$field.$type);
		this.localFormatDisplay = formatApi.getLocalFormat(this.$field.$type, this.$field.$format);
		this._formatInput = _formatter[this.$field.$type];
		this.isTimeField = this.$field.$type == "application/x-time";
		// for application/x-date type only for now
		if (this.$field.$type == "application/x-date") {
			this.formatObj = formatApi.processFormat(this.localFormat);
		}
		if (this.formatEx) {
			// Overwrite format APIs  "formatApi", "localFormat", "localFormatDisplay", "formatObj", etc...
			helpers.object.extendEx(this, this.formatEx);
		}
	},
	setDataValue: function(value) {
		if (value !== undefined && value !== null) {
			try {
				var dateObj = this.formatApi.parse(value);
				if (this.$field.$type == "application/x-time") {
					this._setNotNullDataValue(value, dateObj);
				} else {
					if (!dateObj.isNull()) {
						this._setNotNullDataValue(value, dateObj);
					} else {
						this._setNullDataValue();
					}
				}
			} catch (error) {
				this.showErrors([error.message]);
			}
		} else {
			if (value === null) {
				this._setNullDataValue();
			}
		}
		syra_menus.showMenuPicker(this);
	},
	getDisplayText: function() {
		return this.displayText || "";
	},
	_setNotNullDataValue: function(value, dateObj) {
		this.displayText = "";
		this.currentValue = value;
		if (this.$isEditMode) {
			this.setInputValue(this.displayText = dateObj.toString(this.localFormat));
			this.input.setAttribute("placeholder", this.localFormat);
		} else {
			this.displayText = dateObj.toString(this.localFormatDisplay);
			if (this.displayText && !this.$isDetailLinkDisabled && this.$menus && this.$menus.$details) {
				this.appendDetailLink(this.displayText, this.$menus.$details);
			} else {
				this._dataValue.textContent = this.displayText;
			}
		}
	},
	_setNullDataValue: function() {
		this.currentValue = null;
		this.displayText = "";
		if (this.$isEditMode) {
			this.setInputValue(this.displayText);
			this.input.setAttribute("placeholder", this.displayText);
		} else {
			syra_site.dom.empty(this._dataValue);
			this._dataValue.textContent = this.displayText;
		}
	},
	processInputHelper: function(val) {
		var dayOffset = null,
			dateObj, newVal = null;
		if (val === "0") {
			dayOffset = 0;
		} else
		if (val.length > 1 && (val.startsWith("+") || val.startsWith("-"))) {
			dayOffset = parseInt(val, 10);
			if (isNaN(dayOffset)) {
				dayOffset = null;
			}
		}
		if (dayOffset != null) {
			dateObj = datetime.now().addDays(dayOffset);
			if (!this.page.externalAdapter.getFormatedValFromHelperVal) {
				newVal = dateObj.toString(this.localFormat || formatApi.getLocalFormat(this.$field.$type));
			} else {
				newVal = this.page.externalAdapter.getFormatedValFromHelperVal(this, dateObj);
			}
		}
		return newVal;
	},
	getDataValue: function() {
		if (this.input) {
			var val = this.getInputValue();
			var helperVal = this.processInputHelper(val);
			return helperVal || (val ? this.formatApi.parse(val, this.localFormat).toString() : null);
		}
		return this.currentValue;
	},
	onInputValueChanged: function(event) {
		var inputHelper = this.processInputHelper(this.input.value);
		if (inputHelper) {
			this.input.value = inputHelper;
		}
		var errors = [];
		// for application/x-date and application/x-time types only for now
		if (this.input.value != '') {
			// applying api validation rules
			var rawVal = this._formatInput(this, this.input.value);
			this.formatApi.validate(rawVal, {
				$isMandatory: this.$isMandatory,
				$isNullable: this.$isNullable
			}, errors);
			this.input.value = rawVal.toString(this.localFormat);
		}
		if (syra_workingCopy.validateInput(this, this.input.value, errors)) {
			var newValue = this.getDataValue(event);
			if (newValue != this.currentValue) {
				syra_workingCopy.notifyFieldChange(this, newValue);
			}
		}
	},
	dispose: function() {
		this.formatApi = this.localFormatDisplay = this.localFormat = this._formatInput = this.formatObj = null;
		if (this.formatEx) {
			var keys = Object.keys(this.formatEx);
			for (var ii = 0, jj = keys.length; ii < jj; ii++) {
				delete this.formatEx[keys[ii]];
			}
		}
		Field.prototype.dispose.call(this);
	}
});