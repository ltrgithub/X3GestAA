"use strict";
var helpers = require('syracuse-core/lib/helpers');
var fieldHelper = require('syracuse-ui/lib/field/helpers/fieldHelper');


function _ensureRow(list) {
	if (!list.colFitterRow) {
		var table = document.createElement("table");
		table.className = list.$skin + "-size-body";
		table.setAttribute("cellspacing", "0");
		table.setAttribute("cellpadding", "0");
		table.style.position = "absolute";
		table.style.zIndex = 1;
		table.appendChild(list.colFitterRow = document.createElement("tr"));
		list.tableSlot.appendChild(table);
	}
}

exports.setFieldWidth = function(list, col, $field) {
	var width = col.$item.$width || $field.$width;
	if (width == "NaNpx") {
		width = null;
	}
	col.widthAdded = 0;
	if (width) {
		col.colWidth = parseInt((width + "").replace("px", ""), 10);
	} else {
		col.colWidth = fieldHelper.getColumnFieldWidth($field, col.titleText.length, col.isSortable);
		col.colWidth += 8; //for padding
		var hasFilter;
		if ($field.$capabilities && ($field.$capabilities.indexOf("filter") >= 0)) {
			col.widthAdded += syra_menus.btnWidth;
			hasFilter = true;
		}
		if (list.$isEditMode || hasFilter) {
			var width = syra_menus.fieldBtnWidth[$field.$type];
			if (width) {
				col.widthAdded += width;
			}

		}
		if (list.$isEditMode) {
			if ($field.$item ? ($field.$item.$links || $field.$item.$actions) : ($field.$links || $field.$actions)) {
				col.widthAdded += syra_menus.btnWidth;
				if ($field.$links && ($field.$links.$lookup || $field.$links.$select)) {
					col.widthAdded += syra_menus.btnWidth;
				}
			}
		}
		if (col.widthAdded) {
			col.colWidth += col.widthAdded;
		}
	}
	col.origWidth = col.colWidth = Math.max(40, col.colWidth);

};

exports.calculateMaxFieldLength = function(record, fitter) {
	var list = record.list;
	if (fitter || !list.$isEditMode) {
		fitter = fitter || list.colFitter;
		for (var ii = 0, jj = list.orderCols.length; ii < jj; ii++) {
			var col = list.orderCols[ii];
			if (col.$bind) {
				var field = record.boundFields[col.$bind];
				field = field && field[0];
				if (field && field.valueLength) {
					var fitted = fitter.fields[col.$bind];
					if (!fitted) {
						fitted = fitter.fields[col.$bind] = {
							valueLength: 0
						};
					}
					if (fitted.valueLength < field.valueLength) {
						fitted.valueLength = field.valueLength;
						fitted.field = field;
					}
				}
			}
		}
	}
};

exports.applyResizeShortcut = function(item) {
	var hasFit, lists = [];
	if (item.page == item) {
		lists = syra_store.getLists(item);
	}
	item.isList && lists.push(item);
	if (lists.length) {
		for (var ii = 0, jj = lists.length; ii < jj; ii++) {
			var list = lists[ii];
			if (list.isGridList) {
				hasFit = true;
				if (list.$isEditMode) {
					list.adjusted = {
						fields: {}
					};
					for (var mm = 0, kk = list.records.length; mm < kk; mm++) {
						exports.calculateMaxFieldLength(list.records[mm], list.adjusted);
					}
					for (var mm = 0, kk = list.orderCols.length; mm < kk; mm++) {
						var col = list.orderCols[mm];
						if (col.$bind) {
							var field = list.adjusted.fields[col.$bind];
							if (col.titleText) {
								var minLength = Math.min(col.titleText.length, 6);
								var length = field ? field.valueLength : minLength;
								if (!field) {
									field = list.adjusted.fields[col.$bind] = {};
								}
								field.valueLength = Math.max(minLength, length);
							}
						}
					}
				} else {
					exports.reset(list);
					for (var mm = 0, kk = list.records.length; mm < kk; mm++) {
						exports.calculateMaxFieldLength(list.records[mm]);
					}
				}
				list.resizeArticle(true);
			}
		}
	}
	return hasFit;
};

function _clearColWidths(list, sizer) {
	if (sizer) {
		var $binds = Object.keys(sizer);
		for (var ii = 0, jj = $binds.length; ii < jj; ii++) {
			var $bind = $binds[ii];
			var col = list.cols[$bind];
			if (col) {
				col.scrollWidthValue = col.colWidth = col.origWidth;
			}
		}
	}
}

exports.fit = function(list) {
	if (true || !list.colFitter.isFitted) {
		if (!list.$isEditMode) {
			_ensureRow(list);
			syra_site.dom.empty(list.colFitterRow);
		}
		list.colsWidth = 0;
		list.fixedCols = [];
		list.fixedWidth = 0;
		list.scrolledCols = [];
		list.scrolledWidth = 0;

		var $columnWidths = (list.$userPreferences && list.$userPreferences.$columnWidths) || {};
		if (list.page.onClearPreferences) {
			list.adjusted && _clearColWidths(list, list.adjusted.fields);
			delete list.adjusted;
			_clearColWidths(list, $columnWidths);
			$columnWidths = {};
			delete list.$userPreferences;
		}

		for (var ii = 0, jj = list.orderCols.length; ii < jj; ii++) {
			var col = list.orderCols[ii];
			var width;
			if (col.$isHidden) {
				width = 0;
			} else {
				if (col.$bind) {
					if ($columnWidths[col.$item.$bind]) {
						col.colWidth = parseInt(($columnWidths[col.$item.$bind] + "").replace("px", ""), 10);
					} else {
						if (list.$isEditMode) {
							if (list.adjusted) {
								var field = list.adjusted.fields[col.$bind];
								if (field) {
									col.colWidth = (field.valueLength * 8) + 20; //for padding ;
									if (field.field && field.field.mnPickers && field.field.mnPickers.menus) {
										col.colWidth += syra_menus.btnWidth; //width menu
									}
									if (col.widthAdded) {
										col.colWidth += col.widthAdded;
									}
									col.scrollWidthValue = col.colWidth;
								}
							}
						} else {
							var field = list.colFitter.fields[col.$bind];
							if (field && field.field.domItem) {
								var cell = list.colFitterRow.appendChild(field.field.domItem.cloneNode(true));
								col.colWidth = cell.scrollWidth;
								if (field.field && field.field.mnPickers && field.field.mnPickers.menus) {
									col.colWidth += syra_menus.btnWidth; //width menu
								}
								if (col.widthAdded) {
									col.colWidth += col.widthAdded;
								}
								col.scrollWidthValue = col.colWidth;
							}
						}
					}
				}
				col.isTreeviewCol && list.treeDecorator.calculateColWidth();

				if (col.$isFixed) {
					list.fixedCols.push(col);
					list.fixedWidth += col.colWidth;
				} else {
					list.scrolledCols.push(col);
					list.scrolledWidth += col.colWidth;
				}
				list.colsWidth += col.colWidth;
				width = col.colWidth;
			}
			if (col.scrollWidthValue != undefined) {
				width = col.scrollWidthValue;
			}
			list.setColWidth(col, width + "px");
		}
		list.colFitterRow && syra_site.dom.empty(list.colFitterRow);
		if (list.fixedCols.length && (list.tableSlotWidth < list.colsWidth)) {
			//fixed column but space for scrolled columns is too short
			while (list.fixedCols.length) {
				var space = list.tableSlotWidth - list.fixedWidth;
				if (space < 100 && list.scrolledWidth > (space + 100)) {
					var col = list.fixedCols.pop();
					list.scrolledCols = list.scrolledCols.splice(0, 0, col);
					list.scrolledWidth += col.colWidth;
					list.fixedWidth -= col.colWidth;
				} else {
					break;
				}
			}
		}
		var width = 0;
		for (var ii = 0, jj = list.scrolledCols.length; ii < jj; ii++) {
			var col = list.scrolledCols[ii];
			col.minX = width;
			width += col.colWidth;
			col.maxX = width;
		}
		list.colFitter.isFitted = true;
		return true;
	}
	return false;
};


exports.reset = function(list) {
	list.colFitter = {
		fields: {},
		isFitted: false
	};
};

exports.dispose = function(list) {
	if (list) {
		list.colFitterRow = list.colFitter = list.fixedCols = list.scrolledCols = null;
	}
};