"use strict";
var helpers = require('syracuse-core/lib/helpers');
var fieldHelper = require('syracuse-ui/lib/field/helpers/fieldHelper');


function _ensureRow(list) {
	if (!list.colFitterRow) {
		var table = document.createElement("table");
		table.className = list.$skin + "-size-body";
		table.setAttribute("cellspacing", "0");
		table.setAttribute("cellpadding", "0");
		table.style.position = "absolute";
		table.style.zIndex = 1;
		table.appendChild(list.colFitterRow = document.createElement("tr"));
		list.tableSlot.appendChild(table);
	}
}

exports.setFieldWidth = function(list, col, $field) {
	var width = col.$item.$width || $field.$width;
	if (width == "NaNpx") {
		width = null;
	}
	col.widthAdded = 0;
	if (width) {
		col.colWidth = parseInt((width + "").replace("px", ""), 10);
	} else {
		col.colWidth = fieldHelper.getColumnFieldWidth($field, col.titleText.length, col.isSortable);
		col.colWidth += 16; //for padding
		var hasFilter;
		if ($field.$capabilities && ($field.$capabilities.indexOf("filter") >= 0)) {
			col.widthAdded += syra_menus.btnWidth;
			hasFilter = true;
		}
		if (list.$isEditMode || hasFilter) {
			var width = syra_menus.fieldBtnWidth[$field.$type];
			if (width) {
				col.widthAdded += width;
			}

		}
		if (list.$isEditMode) {
			if ($field.$item ? ($field.$item.$links || $field.$item.$actions) : ($field.$links || $field.$actions)) {
				col.widthAdded += syra_menus.btnWidth;
				if ($field.$links && ($field.$links.$lookup || $field.$links.$select)) {
					col.widthAdded += syra_menus.btnWidth;
				}
			}
		}
		if (col.widthAdded) {
			col.colWidth += col.widthAdded;
		}
	}
	col.origWidth = col.colWidth = Math.max(40, col.colWidth);

};


exports.calculateMaxFieldLength = function(record) {
	var list = record.list;
	if (!list.$isEditMode) {
		for (var ii = 0, jj = list.orderCols.length; ii < jj; ii++) {
			var col = list.orderCols[ii];
			if (col.$bind) {
				var field = record.boundFields[col.$bind];
				field = field && field[0];
				if (field && field.valueLength) {
					var fitted = list.colFitter.fields[col.$bind];
					if (!fitted) {
						fitted = list.colFitter.fields[col.$bind] = {
							valueLength: 0
						};
					}
					if (fitted.valueLength < field.valueLength) {
						fitted.valueLength = field.valueLength;
						fitted.field = field;
					}
				}
			}
		}
	}
};

exports.fit = function(list) {
	if (!list.colFitter.isFitted) {
		if (!list.$isEditMode) {
			_ensureRow(list);
			syra_site.dom.empty(list.colFitterRow);
		}
		list.colsWidth = 0;
		list.fixedCols = [];
		list.fixedWidth = 0;
		list.scrolledCols = [];
		list.scrolledWidth = 0;
		var $columnWidths = {}; // clear preferences (list.$userPreferences && list.$userPreferences.$columnWidths) || {};
		for (var ii = 0, jj = list.orderCols.length; ii < jj; ii++) {
			var col = list.orderCols[ii];
			var width;
			if (col.$isHidden) {
				width = 0;
			} else {
				if (col.$bind) {
					if ($columnWidths[col.$item.$bind]) {
						col.colWidth = parseInt(($columnWidths[col.$item.$bind] + "").replace("px", ""), 10);
					} else {
						if (list.$isEditMode) {} else {
							var field = list.colFitter.fields[col.$bind];
							if (field && field.field.domItem) {
								var cell = list.colFitterRow.appendChild(field.field.domItem.cloneNode(true));
								col.colWidth = cell.scrollWidth + syra_menus.btnWidth; //width menu
								if (col.widthAdded) {
									col.colWidth += col.widthAdded;
								}
							}
						}
					}
				}
				if (col.$isFixed) {
					list.fixedCols.push(col);
					list.fixedWidth += col.colWidth;
				} else {
					list.scrolledCols.push(col);
					list.scrolledWidth += col.colWidth;
				}
				list.colsWidth += col.colWidth;
				width = col.colWidth;
			}
			if (col.scrollWidthValue != undefined) {
				width = col.scrollWidthValue;
			}
			list.setColWidth(col, width + "px");
		}
		list.colFitterRow && syra_site.dom.empty(list.colFitterRow);
		if (list.fixedCols.length && (list.tableSlotWidth < list.colsWidth)) {
			//fixed column but space for scrolled columns is too short
			while (list.fixedCols.length) {
				var space = list.tableSlotWidth - list.fixedWidth;
				if (space < 100 && list.scrolledWidth > (space + 100)) {
					var col = list.fixedCols.pop();
					list.scrolledCols = list.scrolledCols.splice(0, 0, col);
					list.scrolledWidth += col.colWidth;
					list.fixedWidth -= col.colWidth;
				} else {
					break;
				}
			}
		}
		var width = 0;
		for (var ii = 0, jj = list.scrolledCols.length; ii < jj; ii++) {
			var col = list.scrolledCols[ii];
			col.minX = width;
			width += col.colWidth;
			col.maxX = width;
		}
		list.colFitter.isFitted = true;
		return true;
	}
	return false;
};

function _getLists(page) {
	var lists = [];
	var $binds = page.boundFields ? Object.keys(page.boundFields) : [];
	for (var ii = 0, jj = $binds.length; ii < jj; ii++) {
		var fields = page.boundFields[$binds[ii]];
		if (fields) {
			for (var mm = 0, kk = fields.length; mm < kk; mm++) {
				if (fields[mm] && fields[mm].isList) {
					lists.push(fields[mm]);
				}
			}
		}
	}
	return lists;
}


exports.applyResizeShortcut = function(item) {
	var lists = [];
	if (item.page == item) {
		lists = _getLists();
	}
	item.isList && lists.push(item);
	if (lists.length) {
		var hasFit;
		for (var ii = 0, jj = lists.length; ii < jj; ii++) {
			var list = lists[ii];
			if (list.isGridList) {
				hasFit = true;
				if (list.$userPreferences) {
					delete list.$userPreferences.$columnWidths;
				}
				list.colFitter.isFitted = false;
				for (var ii = 0, jj = list.orderCols.length; ii < jj; ii++) {
					var col = list.orderCols[ii];
					if (col.origWidth) {
						col.colWidth = col.origWidth;
					}
				}
				list.savePreferences(false, "$columnWidths");
				list.resizeArticle(true);
			}
		}
		return hasFit;
	}
};


exports.reset = function(list) {
	list.colFitter = {
		fields: {},
		isFitted: false
	};
};

exports.dispose = function(list) {
	if (list) {
		list.colFitterRow = list.colFitter = list.fixedCols = list.scrolledCols = null;
	}
};