"use strict";
var helpers = require('syracuse-core/lib/helpers');

function Scroller() {}

exports.Scroller = helpers.defineClass(Scroller, null, {
	load: function(list) {
		this.list = list;
		this.id = list.id + "scroller";
		syra_store.add(this);
		this.setFixedBodyHeight(this.list.$item.$fixedBodyHeight);
		this._bindEvents(true);
	},
	setFixedBodyHeight: function($fixedBodyHeight) {
		this.$fixedBodyHeight = parseInt($fixedBodyHeight || 0, 10);
	},
	scrollToTitleItem: function(domItem) {
		this.list.page.scrollToItem(domItem, this.list.headTableSlot, true);
	},
	scrollToItem: function(domItem) {
		this.list.page.scrollToItem(domItem, this.list.bodyTableSlot, true);
	},
	ensureColumnsHScoll: function(newScroll) {
		if (!(this.list.maxWidthCol && this.list.maxWidthCol.proportionalWidth)) {
			var scrollViewWidth = this.list.tableSlotWidth - this.list.fixedWidth;
			var hScrollLeft = (newScroll != undefined) ? newScroll : this.list.hscroller.scrollLeft;
			for (var ii = 0, jj = this.list.scrolledCols.length; ii < jj; ii++) {
				var col = this.list.scrolledCols[ii];
				var prevScrollWidth = col.scrollWidthValue;
				if (prevScrollWidth === undefined) {
					prevScrollWidth = col.colWidth;
				}
				if (hScrollLeft > col.maxX) {
					col.scrollWidthValue = 0;
				} else {
					if (hScrollLeft <= col.minX) {
						col.scrollWidthValue = col.colWidth;
					} else {
						if (hScrollLeft >= col.minX && hScrollLeft <= col.maxX) {
							var diff = hScrollLeft - col.minX;
							col.scrollWidthValue = col.colWidth - diff;
						}
					}
				}
				if (prevScrollWidth != col.scrollWidthValue) {
					col.scrollWidthValue = Math.min(col.scrollWidthValue, scrollViewWidth);
					this.list.setColWidth(col, col.scrollWidthValue + "px");
				}
			}
		}
	},
	ensureFieldVisibility: function(field) {
		if (this.list.scrolledWidth && this.scrollAreaWidth) {
			var visibleWidth = 0;
			var scrollViewWidth = this.list.tableSlotWidth - this.list.fixedWidth;
			for (var ii = 0, jj = this.list.scrolledCols.length; ii < jj; ii++) {
				var col = this.list.scrolledCols[ii];
				if (field.$item.$bind == col.$bind) {
					var newScroll;
					var maxColWidth = Math.min(col.colWidth, scrollViewWidth);
					if (this.list.bodyTableSlot.scrollLeft) {
						this.list.bodyTableSlot.scrollLeft = 0;
					}
					if (this.list.headTableSlot.scrollLeft) {
						this.list.headTableSlot.scrollLeft = 0;
					}
					if (col.scrollWidthValue < maxColWidth) {
						newScroll = col.minX;
					} else {
						if ((visibleWidth + maxColWidth) >= scrollViewWidth) {
							newScroll = col.minX;
						}
					}
					if (newScroll != undefined) {
						newScroll = Math.min(this.scrollAreaWidth, newScroll);
						if (col.scrollWidthValue != maxColWidth) {
							col.scrollWidthValue = maxColWidth;
							this.list.setColWidth(col, col.scrollWidthValue + "px");
						}
						this.ensureColumnsHScoll(newScroll);
						this.list.hscroller.scrollLeft = newScroll;
					}
					break;
				}
				visibleWidth += col.scrollWidthValue === undefined ? col.colWidth : col.scrollWidthValue;
			}
		}
	},
	_bindEvents: function(bind) {
		var self = this;
		if (bind) {
			self.hscrollHandler = self.list.hscroller.addEventListener("scroll", function(event) {
				event.stopPropagation();
				if (!syra_site.isInoutDisabled && self.list.page.isPageLoaded && !self.list.page._isDataChanging) {
					syra_site.dialogManager.closePopups(self.list.page);
					self.ensureColumnsHScoll();
				}
			});
			self.bodyScrollHandler = self.list.bodyTableSlot.addEventListener("scroll", function(event) {
				self.list.bodyTableSlot.scrollLeft = 0;
				event.preventDefault();
				event.stopPropagation();
				event.returnValue = false;
			}, false);
			self.headScrollHandler = self.list.headTableSlot.addEventListener("scroll", function(event) {
				self.list.headTableSlot.scrollLeft = 0;
				event.preventDefault();
				event.stopPropagation();
				event.returnValue = false;
			}, false);

		} else {
			self.list.hscroller && self.list.hscroller.removeEventListener("scroll", self.hscrollHandler);
			self.list.bodyTableSlot && self.list.bodyTableSlot.removeEventListener("scroll", self.bodyScrollHandler);
			self.list.headTableSlot && self.list.headTableSlot.removeEventListener("scroll", self.headScrollHandler);

		}
	},
	_scrollCols: function(left) {
		// in order to scroll column per column
		var self = this;
		clearTimeout(self._scrollColsTimeout);
		self._scrollColsTimeout = setTimeout(function() {
			var col;
			for (var ii = 0, jj = self.list.scrolledCols.length; ii < jj; ii++) {
				if (self.list.scrolledCols[ii].scrollWidthValue == undefined || self.list.scrolledCols[ii].scrollWidthValue != 0) {
					col = self.list.scrolledCols[ii];
					break;
				}
			}
			// calculating scroll offset
			// if scrollWidthValue is undefined, col is the first scrollable column. Offset corresponds to the column width.
			// if scrollWidthValue is defined, offset depends whether scroll is going left or right.
			// if scroll goes to left, then offset value depends on whether column is halfed scrolled (col.scrollWidthValue != col.colWidth) or not scrolled at all (col.scrollWidthValue == col.colWidth).
			// if scroll goes to right, offset corresponds to column scrollWidthValue
			var offset;
			if (col.scrollWidthValue == undefined) {
				offset = col.colWidth;
			} else {
				if (left) {
					offset = (col.scrollWidthValue == col.colWidth ? (ii > 0 ? self.list.scrolledCols[ii - 1].colWidth : col.scrollWidthValue) : col.colWidth - col.scrollWidthValue);
				} else {
					offset = col.scrollWidthValue;
				}
			}
			self.list.hscroller.scrollLeft = left ? self.list.hscroller.scrollLeft - offset : self.list.hscroller.scrollLeft + offset;
		}, 20);
	},
	onButonClick: function(event, btn) {
		this._clearButtonTimer();
		this._scrollCols(btn == this.leftBtn);
	},
	onItemInOut: function(onEnter, event, target) {
		var self = this;
		if (onEnter) {
			self._btnStartTimer = setTimeout(function() {
				self._btnInterval = setInterval(function() {
					if (self.list.hscroller) {
						self._scrollCols(target == self.leftBtn);
					}
				}, 1000);
			}, 1000);
		} else {
			self._clearButtonTimer();
		}
	},
	_clearButtonTimer: function() {
		this._btnStartTimer && clearTimeout(this._btnStartTimer);
		this._btnInterval && clearInterval(this._btnInterval);
		this._btnInterval = this._btnStartTimer = null;
	},
	_appendButtons: function() {
		var show;
		if (!(this.list.maxWidthCol && this.list.maxWidthCol.proportionalWidth) && this.list.page.scrollview && this.list.isScrollButtonEnabled !== false && !this.list.treeDecorator) {
			if (this.list.records.length > 20) {
				if (!this.leftBtn) {
					this.leftBtn = syra_menus.addIconButton("", "s-list-btn-scroll-left", "onButonClick");
					this.leftBtn.syraIsDisplay = true;
					this.rightBtn = syra_menus.addIconButton("", "s-list-btn-scroll-right", "onButonClick");
					this.leftBtn.syraTool = this.rightBtn.syraTool = this.id;
					this.leftBtn.syrainout = this.rightBtn.syrainout = this.id;
					this.leftBtnStyle = this.leftBtn.style;
					this.rightBtnStyle = this.rightBtn.style;
					this.list._core.appendChild(this.leftBtn);
					this.list._core.appendChild(this.rightBtn);
					if (this.list.page && this.list.page.addScrollViewListener) {
						this.list.page.addScrollViewListener(this);
					}
				}
				this.onPageScrollViewChange();
				show = true;
			}
		}
		this.leftBtn && this._showButtons(show);
	},
	_showButtons: function(show) {
		if (show != this.leftBtn.syraIsDisplay) {
			var display = (this.leftBtn.syraIsDisplay = show) ? "" : "none";
			this.leftBtnStyle.display = display;
			this.rightBtnStyle.display = display;
		}
	},
	onPageScrollViewChange: function() {
		if (this.leftBtn) {
			var buttonsRect = syra_site.dom.getBoundingClientRect(this.list._dataValue);
			var scrollRect = this.list.page.getScrollviewSize();
			var show;
			if (!(buttonsRect.top > scrollRect.top && buttonsRect.bottom < scrollRect.bottom)) {
				var bottom = (buttonsRect.bottom < scrollRect.bottom) ? buttonsRect.bottom : scrollRect.bottom;
				var top;
				if (buttonsRect.top > scrollRect.top) {
					top = (bottom - buttonsRect.top) / 2;
				} else {
					top = Math.abs(buttonsRect.top) + ((bottom - scrollRect.top) / 2);
				}
				this.leftBtnStyle.top = top + "px";
				this.rightBtnStyle.top = top + "px";
				show = true;
			}
			this._showButtons(show);
		}
	},
	dispose: function() {
		this._clearButtonTimer();
		this._bindEvents(false);
		syra_store.remove(this);
		if (this.leftBtn) {
			if (this.list.page && this.list.page.removeScrollViewListener) {
				this.list.page.removeScrollViewListener(this.list);
			}
			this.leftBtnStyle = this.rightBtnStyle = this.leftBtn = this.rightBtn = null;
		}
		this.list = this._scrollColsTimeout = null;
		this.hscrollHandler = this.bodyScrollHandler = this.headScrollHandler = null;
	}
});