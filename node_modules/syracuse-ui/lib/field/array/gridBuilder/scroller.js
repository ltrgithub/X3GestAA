"use strict";
var helpers = require('syracuse-core/lib/helpers');

function Scroller() {}

exports.Scroller = helpers.defineClass(Scroller, null, {
	load: function(list) {
		this.list = list;
		repository[this.id = (list.id + "scroller")] = this;
		this.setFixedBodyHeight(this.list.$item.$fixedBodyHeight);
	},
	getInvisibleSize: function() {
		var bodyRect = this.getVisibleSize();
		return {
			height: this.bodySlot.scrollHeight - bodyRect.height,
			width: this.bodySlot.scrollWidth - bodyRect.width
		};
	},
	getVisibleSize: function() {
		return this.bodySlot.getBoundingClientRect();
	},
	setFixedBodyHeight: function($fixedBodyHeight) {
		this.$fixedBodyHeight = parseInt($fixedBodyHeight || 0, 10);
	},
	validateFixedColumns: function() {
		var isFixed = true;
		for (var ii = 0, jj = this.list.orderCols.length; ii < jj; ii++) {
			var col = this.list.orderCols[ii];
			if (col.$bind) {
				isFixed = col.$isFixed = isFixed && col.$item.$isFixed;
				if (!isFixed) {
					delete col.$item.$isFixed;
				} else {
					col.$item.$isFixed = true;
				}
			} else {
				col.$isFixed = true;
			}
		}
	},
	scrollToTitleItem: function(domItem) {
		this.list.page.scrollToItem(domItem, this._headSlot, true);
	},
	scrollToItem: function(domItem) {
		this.list.page.scrollToItem(domItem, this.bodySlot, true);
	},
	getScrollBoundary: function() {
		var boundary = document.site.dom.getBoundingClientRect(this.bodySlot);
		boundary.bodySlot = this.bodySlot;
		boundary.hscroller = this._hscroller;
		boundary.scrollWidth = this._hscroller.scrollWidth;
		boundary.scrollHeight = this.bodySlot.scrollHeight;
		return boundary;
	},
	drawSlots: function(core, header, body) {
		this._headSlot = document.createElement("div");
		this._headSlot.className = this.list.$skin + "-slot-head";
		this._headSlot.appendChild(header);

		this._hscroller = document.createElement("div");
		this._hscroller.className = this.list.$skin + "-h-scroll";
		this._hscroller.syraNoDDSpot = true;
		this._hscroller.appendChild(this._hscrollBody = document.createElement("div"));
		this._hscrollBody.className = this.list.$skin + "-h-scroll-body";

		this.bodySlot = document.createElement("div");
		this.bodySlot.className = this.list.$skin + "-slot-body";
		this.bodySlot.appendChild(body);

		core.appendChild(this._headSlot);
		core.appendChild(this.bodySlot);
		core.appendChild(this._hscroller);

		this._bindEvents(true);
	},
	_calculateScrollableView: function(clientWidth, firstScrollableColIndex) {
		var cols = this.list.orderCols;
		this._widthTotal = 0;
		this.scrollWidthTotal = 0;
		this.fixWidth = 0;
		this.lastColIndex = cols.length - 1;

		if (firstScrollableColIndex == undefined) {
			this.firstScrollableColIndex = 0;
			for (var ii = 0, jj = cols.length; ii < jj; ii++) {
				var col = cols[ii];
				if (!col.$isHidden && !col.$isFixed) {
					this.firstScrollableColIndex = ii;
					break;
				}
			}
		} else {
			this.firstScrollableColIndex = firstScrollableColIndex;
		}
		for (var ii = 0, jj = cols.length; ii < jj; ii++) {
			var col = cols[ii];
			if (!col.$isHidden) {
				if (this.firstScrollableColIndex) {
					if ((ii >= this.firstScrollableColIndex) || (this.fixWidth > clientWidth)) {
						col.minX = this.scrollWidthTotal;
						col.scrollWidth = col.widthValue;
						this.scrollWidthTotal += col.widthValue;
						col.maxX = this.scrollWidthTotal;
					} else {
						this.fixWidth += col.widthValue;
					}
				}
				this._widthTotal += col.widthValue;
			}
		}
		if (firstScrollableColIndex === undefined) {
			if (this.firstScrollableColIndex && (clientWidth < this._widthTotal)) {
				var space = clientWidth - this.fixWidth;
				if (space < 100 && this.scrollWidthTotal > (space + 100)) {
					for (var ii = this.firstScrollableColIndex - 1; ii > 0; ii--) {
						var col = cols[ii];
						if (!col.$isHidden) {
							this.fixWidth -= col.widthValue;
							space = clientWidth - this.fixWidth;
							if (space < 100 && this.scrollWidthTotal > (space + 100)) {
								break;
							}
						}
					}
					this._calculateScrollableView(clientWidth, ii > 0 ? ii : 0);
				}
			}
		}
	},
	onListResize: function() {
		var clientWidth = this.bodySlot && this.bodySlot.clientWidth;
		if (clientWidth) {
			if (this.list.fitToWidFields && !this.list.isFittedToWidth) {
				if (!this.list.sizeBody) {
					this.list.sizeBody = document.createElement("table");
					this.list.sizeBody.className = this.list.$skin + "-size-body";
					this.list.sizeBody.setAttribute("cellspacing", "0");
					this.list.sizeBody.setAttribute("cellpadding", "0");
					this.list.sizeBody.style.position = "absolute";
					this.list.sizeBody.style.zIndex = 1;
					this.list.sizerow = document.createElement("tr");
					this.list.sizeBody.appendChild(this.list.sizerow);
					this.list.tableSlot.appendChild(this.list.sizeBody);
				}
				document.site.dom.empty(this.list.sizerow);
				this.list.maxCol = null;
				for (var ii = 0, jj = this.list.orderCols.length; ii < jj; ii++) {
					var col = this.list.orderCols[ii];
					if (col.$bind) {
						var field = this.list.fitToWidFields[col.$bind];
						if (field && field.field.domItem) {
							var cell = this.list.sizerow.appendChild(field.field.domItem.cloneNode(true));
							if (!col.isUserPreferenceWidth) {
								col.widthValue = cell.scrollWidth + 16;
								if (col.widthAdded) {
									col.widthValue += col.widthAdded;
								}
							}
							if (!this.list.maxCol || col.widthValue > this.list.maxCol.widthValue) {
								this.list.maxCol = col;
							}
							col.groupHead.style.width = col.widthValue + "px";
							col.groupBody.style.width = col.widthValue + "px";
						}
					}
				}
				clientWidth = this.bodySlot && this.bodySlot.clientWidth;
				this.list.isFittedToWidth = true;
				this.scrollFixedColumns();
			}
			this._calculateScrollableView(clientWidth);
			if (this._widthTotal < clientWidth) {
				this.isProportionalWidth = true;
				this.list.maxCol.realWidth = this.list.maxCol.widthValue + (clientWidth - this._widthTotal);
				this.list.maxCol.groupHead.style.width = this.list.maxCol.groupBody.style.width = this.list.maxCol.realWidth + "px";
			} else {
				if (this.isProportionalWidth) {
					this.list.maxCol.groupHead.style.width = this.list.maxCol.groupBody.style.width = (this.list.maxCol.realWidth = this.list.maxCol.widthValue) + "px";
					delete this.isProportionalWidth;
				}
			}

			this.scrollAreaWidth = this._widthTotal - clientWidth;
			this._hscrollBody.style.width = this._widthTotal + "px";

			if (this.bodySlot.scrollHeight > (this.bodySlot.clientHeight + 1)) {
				this._headSlot.style.marginRight = "17px";
				if (!this._headerCorner) {
					this._headerCorner = document.createElement("div");
					this._headerCorner.className = this.list.$skin + "-head-corner";
					this._headSlot.parentNode.appendChild(this._headerCorner);
				}
				this._headerCorner.style.display = "";
				this._headerCorner.style.height = this._headSlot.clientHeight + "px";
			} else {
				this._headSlot.style.marginRight = "";
				if (this._headerCorner) {
					this._headerCorner.style.display = "none";
				}
			}
			this._hscroller.style.display = this.scrollAreaWidth > 0 ? "" : "none";
			if (this.$fixedBodyHeight || this.list.$item.$fitContainer || this.list.$isDockedHeight) {
				if (this.bodySlot.style.overflowY != "auto") {
					this.bodySlot.style.overflowY = "auto";
				}
				if (this.list.$isDockedHeight) {
					var scrollTop = this.list.page.getScrollviewSize().top;
					var bodyRect = this.bodySlot.getBoundingClientRect();
					var fieldRect = this.list.fieldValue.getBoundingClientRect();
					var headerH = Math.ceil(bodyRect.top - fieldRect.top);
					var bottomH = Math.ceil(Math.max(0, (fieldRect.height - headerH) - bodyRect.height));
					bodyHeight = this.list.page.scrollview.clientHeight - ((bodyRect.top - scrollTop) + bottomH);
				} else {
					if (this.$fixedBodyHeight || this.list.$item.$fitContainer) {
						if (this.list.$item.$fitContainer) {
							var savScrollTop = this.bodySlot.scrollTop;
							this.bodySlot.style.height = "";
							var bodyRect = document.site.dom.getBoundingClientRect(this.bodySlot);
							var diff = this.list.layoutSlot.scrollHeight - this.list.layoutSlot.clientHeight;
							var bodyHeight = bodyRect.height - diff;
							this.bodySlot.style.height = bodyHeight + "px";
							this.bodySlot.scrollTop = savScrollTop;
						} else {
							var bodyRect = document.site.dom.getBoundingClientRect(this.bodySlot);
							this.bodySlot.style.height = ((Math.abs(this.$fixedBodyHeight - bodyRect.height) < 2) ? bodyRect.height : this.$fixedBodyHeight) + "px";
						}
					}
				}
			} else {
				if (this.bodySlot.style.overflowY == "auto") {
					this.bodySlot.style.overflowY = "";
					this.bodySlot.style.height = "";
				}
			}
			this._appendButtons();
			return true;
		}
	},
	scrollFixedColumns: function() {
		if (!this.isProportionalWidth && this.firstScrollableColIndex) {
			for (var ii = this.firstScrollableColIndex; ii <= this.lastColIndex; ii++) {
				var col = this.list.orderCols[ii];
				var hScrollLeft = this._hscroller.scrollLeft;
				if (!col.$isHidden) {
					if (hScrollLeft > col.maxX) {
						if (this.focusedCol === col) {
							hScrollLeft = col.minX;
							return;
						}
						col.groupHead.style.width = col.groupBody.style.width = (col.scrollWidthValue = 0) + "px";
					} else {
						if (hScrollLeft <= col.minX) {
							col.groupHead.style.width = col.groupBody.style.width = (col.scrollWidthValue = col.widthValue) + "px";
						} else {
							if (hScrollLeft >= col.minX && hScrollLeft <= col.maxX) {
								if (this.focusedCol === col) {
									continue;
								}
								var diff = hScrollLeft - col.minX;
								col.groupHead.style.width = col.groupBody.style.width = (col.scrollWidthValue = (col.widthValue - diff)) + "px";
							}
						}
					}
				}
			}
		}
	},
	ensureFieldVisibility: function(field) {
		if (this.firstScrollableColIndex) {
			var index = (field.$item.$isFilterMode ? field.layoutSlot.parentNode : field.layoutSlot).cellIndex;
			if (index !== undefined) {
				var fieldRect = field.domItem.getBoundingClientRect();
				var bodyRect = this.bodySlot.getBoundingClientRect();
				var col = this.list.orderCols[index];
				if (col) {
					this._calculateScrollableView(this.bodySlot.clientWidth);
					var firstX = bodyRect.left + this.fixWidth;
					var lastX = bodyRect.right - 10; //margin
					var visibleWidth = lastX - firstX;
					var newScrollLeft;
					var hScrollLeft = this._hscroller.scrollLeft;
					if (col.scrollWidthValue != col.scrollWidth || fieldRect.right > bodyRect.right) {
						if (hScrollLeft > col.minX || visibleWidth < col.widthValue) {
							newScrollLeft = col.minX;
						} else {
							var space = (fieldRect.left - lastX) + Math.min(visibleWidth, col.widthValue);
							newScrollLeft = hScrollLeft + space;
						}
						if (newScrollLeft !== undefined) {
							this.focusedCol = col;
							this._hscroller.scrollLeft = newScrollLeft;
						}
					}
				}
			}
		}
	},
	_bindEvents: function(bind) {
		var self = this;
		if (bind) {
			self.hscrollHandler = self._hscroller.addEventListener("scroll", function(event) {
				event.stopPropagation();
				var hScrollLeft = self._hscroller.scrollLeft;
				if (!self.firstScrollableColIndex) {
					if (self.bodySlot.scrollLeft != hScrollLeft) {
						self.bodySlot.scrollLeft = hScrollLeft;
					}
					if (self._headSlot.scrollLeft != hScrollLeft) {
						self._headSlot.scrollLeft = hScrollLeft;
					}
				} else {
					self.bodySlot.scrollLeft = self._headSlot.scrollLeft = 0;
					self.scrollFixedColumns();
					delete self.focusedCol;
				}

			});
			self.bodyScrollHandler = self.bodySlot.addEventListener("scroll", function(event) {
				if (!self.firstScrollableColIndex) {
					if (self._hscroller.scrollLeft != self.bodySlot.scrollLeft) {
						self._hscroller.scrollLeft = self.bodySlot.scrollLeft;
					}
					if (self._headSlot.scrollLeft != self.bodySlot.scrollLeft) {
						self._headSlot.scrollLeft = self.bodySlot.scrollLeft;
					}
				} else {
					if (self.bodySlot && self.bodySlot.scrollLeft) {
						self._hscroller.scrollLeft += self.bodySlot.scrollLeft;
						self.bodySlot.scrollLeft = 0;
					}
					return false;
				}
			});
			self.headScrollHandler = self._headSlot.addEventListener("scroll", function(event) {
				if (!self.firstScrollableColIndex) {
					if (self._hscroller.scrollLeft != self._headSlot.scrollLeft) {
						self._hscroller.scrollLeft = self._headSlot.scrollLeft;
					}
					if (self.bodySlot.scrollLeft != self._headSlot.scrollLeft) {
						self.bodySlot.scrollLeft = self._headSlot.scrollLeft;
					}
				} else {
					if (self._headSlot.scrollLeft) {
						self._hscroller.scrollLeft += self._headSlot.scrollLeft;
						self._headSlot.scrollLeft = 0;
					}
					return false;
				}
			});
		} else {
			if (self._hscroller) {
				self._hscroller.removeEventListener("scroll", self.hscrollHandler);
			}
			if (self.bodySlot) {
				self.bodySlot.removeEventListener("scroll", self.bodyScrollHandler);
			}
			if (self._headSlot) {
				self._headSlot.removeEventListener("scroll", self.headScrollHandler);
			}
		}
	},
	_scrollCols: function(left) {
		// in order to scroll column per column
		var self = this;
		clearTimeout(self._scrollColsTimeout);
		self._scrollColsTimeout = setTimeout(function() {
			var cols = self.list.orderCols;
			var colToScroll;
			for (var ii = self.firstScrollableColIndex; ii <= self.lastColIndex; ii++) {
				// if scrollWidthValue is not set, no scrolling has been done yet (cols[ii] will thus be the 1st column from which to scroll) 
				if (cols[ii].scrollWidthValue == undefined) {
					colToScroll = cols[ii];
					break;
				} else {
					// once scrolling has already been done, scrollWidthValue is either == 0 or > 0
					// scrollWidthValue == 0 for scrolled columns. First column with scrollWidthValue > 0 is to consider for scrolling 
					if (cols[ii].scrollWidthValue != 0) {
						colToScroll = cols[ii];
						break;
					}
				}
			}
			// calculating scroll offset
			// if scrollWidthValue is undefined, colToScroll is the first scrollable column. Offset corresponds to the column width.
			// if scrollWidthValue is defined, offset depends whether scroll is going left or right.
			// if scroll goes to left, then offset value depends on whether column is halfed scrolled (colToScroll.scrollWidthValue != colToScroll.realWidth) or not scrolled at all (colToScroll.scrollWidthValue == colToScroll.realWidth).
			// if scroll goes to right, offset corresponds to column scrollWidthValue  
			var offset = colToScroll.scrollWidthValue == undefined ? colToScroll.realWidth : (left ? (colToScroll.scrollWidthValue == colToScroll.realWidth ? (ii - 1 >= self.firstScrollableColIndex ? cols[ii - 1].realWidth : colToScroll.scrollWidthValue) : colToScroll.realWidth - colToScroll.scrollWidthValue) : colToScroll.scrollWidthValue);
			self._hscroller.scrollLeft = left ? self._hscroller.scrollLeft - offset : self._hscroller.scrollLeft + offset;
		}, 20);
	},
	onButonClick: function(picker) {
		this._scrollCols(picker == this.leftBtn);
	},
	onItemInOut: function(onEnter, event, target) {
		var self = this;
		if (onEnter) {
			self._btnTimeout = setInterval(function() {
				if (self._hscroller) {
					self._scrollCols(target == self.leftBtn);
				}
			}, 100);
		} else {
			clearInterval(self._btnTimeout);
		}
	},
	_appendButtons: function() {
		var show;
		if (!this.isProportionalWidth && this.list.page.scrollview && this.list.isScrollButtonEnabled !== false && !this.list.treeDecorator) {
			if (this.list.records.length > 20) {
				if (!this.leftBtn) {
					this.leftBtn = document.createElement("a");
					this.leftBtn.className = "s-list-btn-scroll-left";
					this.list._core.appendChild(this.leftBtn);
					this.rightBtn = document.createElement("a");
					this.rightBtn.className = "s-list-btn-scroll-right";

					this.leftBtn.syraTool = this.rightBtn.syraTool = this.id;
					this.leftBtn.syrainout = this.rightBtn.syrainout = this.id;
					this.leftBtn.syraOnClick = this.rightBtn.syraOnClick = "onButonClick";
					this.list._core.appendChild(this.rightBtn);
					if (this.list.page && this.list.page.addScrollViewListener) {
						this.list.page.addScrollViewListener(this);
					}
				}
				this.onPageScrollViewChange();
				show = true;
			}
		}
		if (this.leftBtn) {
			this.leftBtn.style.display = this.rightBtn.style.display = show ? "" : "none";
		}
	},
	onPageScrollViewChange: function() {
		if (this.leftBtn) {
			var listRect = this.list.domValueSlot.getBoundingClientRect();
			var scrollRect = this.list.page.getScrollviewSize();
			var display = "none";
			if (!(listRect.top > scrollRect.top && listRect.bottom < scrollRect.bottom)) {
				var bottom = (listRect.bottom < scrollRect.bottom) ? listRect.bottom : scrollRect.bottom;
				var top;
				if (listRect.top > scrollRect.top) {
					top = (bottom - listRect.top) / 2;
				} else {
					top = Math.abs(listRect.top) + ((bottom - scrollRect.top) / 2);
				}
				this.leftBtn.style.top = this.rightBtn.style.top = top + "px";
				display = "";
			}
			this.leftBtn.style.display = this.rightBtn.style.display = display;
		}
	},
	dispose: function() {
		this._bindEvents(false);
		delete repository[this.id];
		if (this.leftBtn) {
			if (this.list.page && this.list.page.removeScrollViewListener) {
				this.list.page.removeScrollViewListener(this.list);
			}
			this.leftBtn = this.rightBtn = null;
		}
		this._headerCorner = this.list = this._headSlot = this.bodySlot = this._hscroller = this._hscrollBody = this._scrollColsTimeout = null;
		this.hscrollHandler = this.bodyScrollHandler = this.headScrollHandler = null;
	}
});