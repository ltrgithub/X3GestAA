"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Search = require("./search").Search;

function SearchCapability(list) {
	this.list = list;
	this.start = {};
}

exports.SearchCapability = helpers.defineClass(SearchCapability, null, {
	applyMetadata: function(metaData, designing) {

	},
	onSearchClick: function(event, $bind) {
		var self = this;
		switch ($bind) {
			case "$searchCollapse":
				self.search.toggleSearch(event.currentTarget);
				break;
			case "$searchNext":
			case "$searchPrevious":
				var found, value = self.search._itemSearchField.getInputValue();
				if (value === "") return false;
				self.ensureOrderCols();
				if (found = self._search(value, ($bind == "$searchNext"))) {
					var options = {
						field: self.list,
						found: found,
						event: event,
						doEvent: function() {
							self._setFocus(found, ($bind == "$searchNext"));
						}
					};
					self.list.page.externalAdapter.onSearchClickEvent(options);
				}
				break;
		}
	},
	_search: function(value, next, notFound) {
		var startIndexes = this._startIndexes(next),
			toRow = (next ? this.list.clientDataset.length : -1),
			toCol = (next ? this.orderCols.length : -1),
			found;
		for (var ii = startIndexes.row;
			(next && ii < toRow) || (!next && ii > toRow);
			(next ? ii++ : ii--)) {
			for (var jj = startIndexes.col;
				(next && jj < toCol) || (!next && jj > toCol);
				(next ? jj++ : jj--)) {
				if (this.list.clientDataset[ii][this.orderCols[jj].$bind] && this._compare(value, this.list.clientDataset[ii][this.orderCols[jj].$bind], this.orderCols[jj])) {
					this.start = {
						"$uuid": this.list.clientDataset[ii].$uuid,
						"$bind": this.orderCols[jj].$bind,
						"$serverIndex": this.list.clientDataset[ii].$serverIndex
					};
					return this.start;
				}
			}
			startIndexes.col = next ? 0 : this.orderCols.length - 1;
			toCol = next ? this.orderCols.length : -1;
		}
		if (!notFound && (found = this._search(value, !next, true))) {
			return found;
		};
		this.start = {};
		return null;
	},
	_compare: function(value, datasetValue, colProperties) {
		switch (colProperties.$type) {
			case "application/x-date":
			case "application/x-time":
			case "application/x-datetime":
			case "application/x-integer":
			case "application/x-decimal":
			case "application/x-real":
			case "application/x-quantity":
				if (!datasetValue.toLowerCase) datasetValue = new String(datasetValue);
			case "application/x-string":
				return datasetValue.toLowerCase().contains(value.toLowerCase());
				break;
			case "application/x-choice":
				return this._titleChoice(datasetValue, colProperties).toLowerCase().contains(value.toLowerCase());
				break;
			case "application/x-icon":
				return false;
				break;
			case "application/x-boolean":
				return false;
				break;
		}
		return false;
	},
	_titleChoice: function(datasetValue, colProperties) {
		var result = "";
		if (colProperties.$enum) {
			for (var ii = 0; ii < colProperties.$enum.length; ii++) {
				var $item = colProperties.$enum[ii];
				if ($item.$value == datasetValue) {
					result = $item.$title;
					break;
				}
			}
		}
		return result;
	},
	draw: function() {
		this._disposeSearch(true);
		if (this.list.isSearchDisabled !== true && this.list.$item.$isSearchHidden !== true) {
			this.search = new Search();
			this.search.load(this.list, this.list.topbar);
			if (this.list.$item.$graphPosition == "front") {
				this.search.toggle(false);
			}
		}
	},
	ensureOrderCols: function() {
		var builder = this.list.builder,
			colProperties = {};
		this.orderCols = [];
		for (var ii = 0; ii < builder.orderCols.length; ii++) {
			if (!builder.orderCols[ii].$isHidden && builder.orderCols[ii].$bind) {
				colProperties = {};
				colProperties.$bind = builder.orderCols[ii].$bind;
				colProperties.$type = this.list.$fields[builder.orderCols[ii].$bind].$type;
				if (this.list.$fields[builder.orderCols[ii].$bind].$value && this.list.$fields[builder.orderCols[ii].$bind].$value.$enum) {
					colProperties.$enum = this.list.$fields[builder.orderCols[ii].$bind].$value.$enum;
				}
				this.orderCols.push(colProperties);
			}
		}
	},
	_setFocus: function(found, next) {
		this.list.setFocus(false, found.$bind, found.$serverIndex);
	},
	_startIndexes: function(next) {
		var startIndex = {
			row: 0,
			col: 0
		}, changeLine = false;
		if (this.start && this.start.$bind) {
			for (var ii = 0; ii < this.orderCols.length; ii++) {
				if (this.orderCols[ii].$bind == this.start.$bind) {
					if (next) {
						startIndex.col = (ii < this.orderCols.length - 1 ? ii + 1 : 0);
						changeLine = !startIndex.col;
					} else {
						startIndex.col = (ii == 0 ? this.orderCols.length - 1 : ii - 1);
						changeLine = !(startIndex.col == ii - 1);
					}
					this.start.$bind = this.orderCols[startIndex.col].$bind;
					break;
				}
			}
		};
		if (this.start && this.start.$uuid) {
			for (var ii = 0; ii < this.list.dataset.length; ii++) {
				if (this.list.dataset[ii].$uuid == this.start.$uuid) {
					if (changeLine && next) {
						startIndex.row = (ii < this.list.dataset.length - 1 ? ii + 1 : ii);
					} else if (changeLine && !next) {
						startIndex.row = (ii > 0 ? ii - 1 : ii);
					} else {
						startIndex.row = ii;
					}
					this.start.$uuid = this.list.dataset[startIndex.row].$uuid;
					break;
				}
			}
		};

		return startIndex;
	},
	_disposeSearch: function(clear) {
		if (this.search) {
			if (clear) {
				this.search.clear();
			}
			this.search.dispose();
			this.search = null;
		}
	},
	dispose: function() {
		this._disposeSearch();
		this.list = this._item = this.orderCols = this.start = null;
	}
});