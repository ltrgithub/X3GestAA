"use strict";
var helpers = require('syracuse-core/lib/helpers');

function SortCapability(list) {
	this.list = list;
}

exports.SortCapability = helpers.defineClass(SortCapability, null, {
	load: function() {},
	stringify: function() {
		return this._$orderBy ? helpers.url.formatOrderBy(this._$orderBy) : null;
	},
	parse: function(param) {
		return helpers.url.parseOrderBy(param);
	},
	appendSortLink: function(col, $item) {
		var title = col.sortLink = document.createElement("div");
		title.className = this.list.$skin + "-title-link";
		title.setAttribute("data-s-btn", "list-sort");
		title.syraBind = $item.$bind;
		return title;
	},
	setOrderBy: function($orderBy, $startLetter) {
		if ($orderBy !== undefined) {
			this._$orderBy = $orderBy;
		}
		if ($startLetter !== undefined) {
			this._$startLetter = $startLetter;
			this._selectAlphaTab();
		}
	},
	setUnsortable: function(unsortable) {
		if (unsortable) {
			this._unSortable = unsortable;
		}
	},
	onSortClick: function(event, $bind) {
		var self = this;
		var options = {
			field: self.list,
			event: event,
			$$selector: $(event.target),
			doEvent: function(unsortable) {
				var $field = self.list.$fieldProperties[$bind];
				if ($field.$type == "application/x-reference") {
					if ($field.$item.$value) {
						var refBind = self.list.extractExpressionCode($field.$item.$value);
						if (refBind && $field.$item[refBind]) {
							refBind = self.list.extractExpressionCode($field.$item[refBind]);
							if (self.list.$fieldProperties[refBind]) {
								$bind = refBind;
							}
						} else {
							//todo
						}
					}
				}
				var $newOrderBy = [],
					found;
				if (self._$orderBy) {
					for (var ii = 0, jj = self._$orderBy.length; ii < jj; ii++) {
						var $orderItem = self._$orderBy[ii];
						if ($orderItem.binding == $bind) {
							found = true;
							$orderItem.descending = !$orderItem.descending;
							$newOrderBy.push($orderItem);
						} else {
							if (event.shiftKey) {
								$newOrderBy.push($orderItem);
							}
						}
					}
				}
				if (!found) {
					$newOrderBy.push({
						binding: $bind,
						descending: false
					});
				}
				if (unsortable) {
					self.setUnsortable(unsortable);
				}
				self.list.fetch($newOrderBy ? {
					orderBy: $newOrderBy
				} : null);
			}
		};
		self.list.page.externalAdapter.onSortClickEvent(options);
	},
	resetSort: function() {
		if (this._sortedCols) {
			for (var ii = 0, jj = this._sortedCols.length; ii < jj; ii++) {
				var col = this.list.builder.cols[this._sortedCols[ii]];
				if (col && col.sortLink) {
					document.site.toggleClass(col.sortLink, " s-grid-sort-desc", false);
					document.site.toggleClass(col.sortLink, " s-grid-sort-asc", false);
				}
			}
			delete this._sortedCols;
		}
	},
	findSortableReference: function($bind) {
		var $fields = Object.keys(this.list.$fieldProperties);
		for (var ii = 0, jj = $fields.length; ii < jj; ii++) {
			var $field = this.list.$fieldProperties[$fields[ii]];
			if ($field.$type == "application/x-reference" && $field.$item && $field.$item.$value) {
				var refBind = this.list.extractExpressionCode($field.$item.$value);
				if (refBind && $field.$item[refBind]) {
					refBind = this.list.extractExpressionCode($field.$item[refBind]);
					if (this.list.$fieldProperties[refBind] && $bind == refBind) {
						return $fields[ii];
					}
				}
			}
		}
		return null;
	},
	renderOrderBy: function($bind) {
		delete this._alphaTabBinding;
		this.resetSort();
		if (this._$orderBy) {
			this._sortedCols = [];
			for (var ii = 0, jj = this._$orderBy.length; ii < jj; ii++) {
				var criterion = this._$orderBy[ii];
				if (ii == 0) {
					var $field = this.list.$fieldProperties[criterion.binding];
					if ($field.$isHidden) {
						var refBind = this.findSortableReference(criterion.binding);
						if (refBind) {
							$field = this.list.$fieldProperties[refBind];
						}
					}
					if ($field.$capabilities && ($field.$capabilities.indexOf("alphaTab") >= 0)) {
						this._alphaTabBinding = criterion.binding;
					}
				}
				if (this.list.builder.cols) {
					var col = this.list.builder.cols[criterion.binding];
					if (!col) {
						var refBind = this.findSortableReference(criterion.binding);
						if (refBind) {
							col = this.list.builder.cols[refBind];
						}
					}
					if (col && col.sortLink) {
						document.site.toggleClass(col.sortLink, criterion.descending ? " s-grid-sort-desc" : " s-grid-sort-asc", true);
						this._sortedCols.push(criterion.binding);
					}
				}
			}
		}
		this._toggleAlphaTab(self._alphaTabBinding);
	},
	onSortAlphaTab: function(link) {
		var letter = link.textContent;
		if (this._$startLetter == letter) {
			delete self._$startLetter;
			this.list.fetch({});
			this._selectAlphaTab();
		} else {
			this.list.fetch({
				startLetter: letter
			});
			this._selectAlphaTab(link);
		}
	},
	_toggleAlphaTab: function(show) {
		var self = this;
		if (show) {
			if (!self._alphaTab) {
				self._alphaTab = document.createElement("div");
				self._alphaTab.className = "s-alphatab";
				self.list.topbar.appendChild(self._alphaTab);
				for (var ii = "A".charCodeAt(0), end = "Z".charCodeAt(0); ii <= end; ii++) {
					var btn = document.createElement("a");
					btn.setAttribute("data-s-btn", "list-alphatab");
					btn.className = "s-alphatab-link";
					var letter = String.fromCharCode(ii);
					if (self._$startLetter == letter) {
						self._selectAlphaTab(btn);
					}
					btn.textContent = letter;
					self._alphaTab.appendChild(btn);
				}
			}
		}
		if (self._alphaTab) {
			self._alphaTab.style.display = show ? "" : "none";
		}
	},
	_selectAlphaTab: function(btn) {
		if (this._alphaTab) {
			if (!btn && this._$startLetter) {
				if (this._alphaTab.hasChildNodes()) {
					var children = this._alphaTab.childNodes;
					for (var ii = 0; ii < children.length; ii++) {
						var node = children[ii];
						if (node.innerHTML == this._$startLetter) {
							btn = node;
							break;
						}
					}
				}
			}
			if (this._alphaTabSelected) {
				this._alphaTabSelected.className = "s-alphatab-link";
				delete this._alphaTabSelected;
			}
			if (btn) {
				(this._alphaTabSelected = btn).className += " s-alphatab-link-selected";
			}
		}
	},
	filterByStartLetter: function(resource, criterion) {
		resource.$startLetter = criterion.startLetter;
		resource.dataRecordSet = resource.dataRecordSet.filter(function(item) {
			if (criterion.binding) {
				item = item[criterion.binding];
			}
			return item.search(new RegExp(criterion.startLetter, "i")) == 0;
		});

		return resource;
	},
	syracuseSort: function(resource, $orderBy, property) {
		resource.$orderBy = ($orderBy || [{
			binding: "$serverIndex",
			descending: false,
			$type: "application/x-integer"
		}]).map(function(criterion) {
			return {
				binding: criterion.binding,
				asc: criterion.descending !== true
			};
		});
		if (this.list.page.externalAdapter.sortArray(this.list, resource)) {
			this.sort(resource, resource.$orderBy, property);
		}
	},
	sort: function(resource, criteria, property) {
		if (resource && resource.dataRecordSet) {
			var self = this;
			resource.dataRecordSet.sort(function(itemA, itemB) {
				var wr = 0;
				if (property) {
					itemA = itemA[property];
					itemB = itemB[property];
				}
				if (self._unSortable) {
					if (self._unSortable(self.list, {
						dataRecord: itemA
					}) || self._unSortable(self.list, {
						dataRecord: itemB
					})) return 0;
				}
				for (var ii = 0; ii < criteria.length; ii++) {
					wr = self._compare(criteria[ii], itemA, itemB);
					if (wr != 0) break;
				}
				return wr;
			});
		}
		return resource;
	},
	_compare: function(criterion, a, b) {
		var wr = (criterion.asc) ? 1 : -1;
		var valueA = a[criterion.binding];
		var valueB = b[criterion.binding];
		switch (criterion.$type) {
			case "application/x-string":
			case "application/x-datetime":
				break;
			case "application/x-time":
			case "application/x-choice":
			case "application/x-boolean":
			case "application/x-integer":
				valueA = parseInt(valueA, 10);
				valueB = parseInt(valueB, 10);
				break;
			case "application/x-decimal":
			case "application/x-real":
				valueA = parseFloat(valueA, 10);
				valueB = parseFloat(valueB, 10);
				break;
			default:

				break;
		}
		if (valueA > valueB) return wr;
		if (valueA < valueB) return -wr;
		return 0;
	},
	dispose: function() {
		delete this.list;
	}
});