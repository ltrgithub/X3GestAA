"use strict";
var helpers = require('syracuse-core/lib/helpers');

function SortCapability(list) {
	this.list = list;
}

exports.SortCapability = helpers.defineClass(SortCapability, null, {
	load: function() {},
	stringify: function() {
		return this._$orderBy ? helpers.url.formatOrderBy(this._$orderBy) : null;
	},
	cancelSort: function() {
		this._$orderBy = null;
		this.list.triggerFetch({
			orderBy: null
		});
	},
	parse: function(param) {
		return helpers.url.parseOrderBy(param);
	},
	appendSortLink: function(col, $item) {
		var title = col.sortLink = document.createElement("div");
		title.className = this.list.$skin + "-title-link";
		title.syraOnClick = "onSortClick";
		title.syraValue = $item.$bind;
		return title;
	},
	setOrderBy: function($orderBy, $startLetter) {
		if ($orderBy !== undefined) {
			this._$orderBy = $orderBy;
		}
		if ($startLetter !== undefined) {
			this._$startLetter = $startLetter;
			this._selectAlphaTab();
		}
	},
	onSortClick: function($bind, event) {
		var self = this;
		var options = {
			field: self.list,
			event: event,
			selectorTarget: event.target,
			doEvent: function() {
				var $field = self.list.$fields[$bind];
				if ($field.$type == "application/x-reference") {
					if ($field.$item.$value) {
						var refBind = syra_site.expressionMaker.extractCode($field.$item.$value);
						if (refBind && $field.$item[refBind]) {
							refBind = syra_site.expressionMaker.extractCode($field.$item[refBind]);
							if (self.list.$fields[refBind]) {
								$bind = refBind;
							}
						} else {
							//todo
						}
					}
				}
				var $newOrderBy = [],
					found;
				if (self._$orderBy) {
					for (var ii = 0, jj = self._$orderBy.length; ii < jj; ii++) {
						var $orderItem = self._$orderBy[ii];
						if ($orderItem.binding == $bind) {
							if (!event.ctrlKey) {
								found = true;
								$orderItem.descending = !$orderItem.descending;
								$newOrderBy.push($orderItem);
							}
						} else {
							if (event.shiftKey) {
								$newOrderBy.push($orderItem);
							}
						}
					}
				}
				if (!found && !event.ctrlKey) {
					$newOrderBy.push({
						binding: $bind,
						descending: false
					});
				}
				self.list.triggerFetch($newOrderBy ? {
					orderBy: $newOrderBy
				} : null);

			}
		};
		self.list.page.externalAdapter.onSortClickEvent(options);
	},
	resetSort: function() {
		if (this._sortedCols) {
			for (var ii = 0, jj = this._sortedCols.length; ii < jj; ii++) {
				var col = this.list.cols[this._sortedCols[ii]];
				if (col && col.sortLink) {
					syra_site.dom.toggleClass(col.sortLink, " s-grid-sort-desc", false);
					syra_site.dom.toggleClass(col.sortLink, " s-grid-sort-asc", false);
				}
			}
			delete this._sortedCols;
		}
	},
	findSortableReference: function($bind) {
		var $fields = Object.keys(this.list.$fields);
		var expressionMaker = syra_site.expressionMaker;
		for (var ii = 0, jj = $fields.length; ii < jj; ii++) {
			var $field = this.list.$fields[$fields[ii]];
			if ($field.$type == "application/x-reference" && $field.$item && $field.$item.$value) {
				var refBind = expressionMaker.extractCode($field.$item.$value);
				if (refBind && $field.$item[refBind]) {
					refBind = expressionMaker.extractCode($field.$item[refBind]);
					if (this.list.$fields[refBind] && $bind == refBind) {
						return $fields[ii];
					}
				}
			}
		}
		return null;
	},
	renderOrderBy: function($bind) {
		delete this._alphaTabBinding;
		this.resetSort();
		if (this._$orderBy) {
			this._sortedCols = [];
			for (var ii = 0, jj = this._$orderBy.length; ii < jj; ii++) {
				var criterion = this._$orderBy[ii];
				if (ii == 0) {
					var $field = this.list.$fields[criterion.binding];
					if ($field.$isHidden) {
						var refBind = this.findSortableReference(criterion.binding);
						if (refBind) {
							$field = this.list.$fields[refBind];
						}
					}
					if ($field.$capabilities && ($field.$capabilities.indexOf("alphaTab") >= 0)) {
						this._alphaTabBinding = criterion.binding;
					}
				}
				if (this.list.cols) {
					var col = this.list.cols[criterion.binding];
					if (!col) {
						var refBind = this.findSortableReference(criterion.binding);
						if (refBind) {
							col = this.list.cols[refBind];
						}
					}
					if (col && col.sortLink) {
						syra_site.dom.toggleClass(col.sortLink, criterion.descending ? " s-grid-sort-desc" : " s-grid-sort-asc", true);
						this._sortedCols.push(criterion.binding);
					}
				}
			}
		}
		var isSortedCols = this._sortedCols && (this._sortedCols.length > 0);
		if (isSortedCols || (this.list.$menus && this.list.$menus.$cancelSort)) {
			this.list.applyActionLinkChange({
				$links: {
					$cancelSort: {
						$title: this.list.localize.flUnsort,
						$isHidden: !isSortedCols
					}
				}
			});
		}
		//this._toggleAlphaTab(this._alphaTabBinding);
	},
	onSortAlphaTab: function(link) {
		var letter = link.textContent;
		if (this._$startLetter == letter) {
			delete self._$startLetter;
			this.list.fetch({});
			this._selectAlphaTab();
		} else {
			this.list.fetch({
				startLetter: letter
			});
			this._selectAlphaTab(link);
		}
	},
	_toggleAlphaTab: function(show) {
		var self = this;
		if (show) {
			if (!self._alphaTab) {
				self._alphaTab = document.createElement("div");
				self._alphaTab.className = "s-alphatab";
				self.list.topbar.appendChild(self._alphaTab);
				for (var ii = "A".charCodeAt(0), end = "Z".charCodeAt(0); ii <= end; ii++) {
					var btn = document.createElement("a");
					btn.syraOnClick = "onSortAlphaTab";
					btn.className = "s-alphatab-link";
					var letter = String.fromCharCode(ii);
					if (self._$startLetter == letter) {
						self._selectAlphaTab(btn);
					}
					btn.textContent = letter;
					self._alphaTab.appendChild(btn);
				}
			}
		}
		if (self._alphaTab) {
			self._alphaTab.style.display = show ? "" : "none";
		}
	},
	_selectAlphaTab: function(btn) {
		if (this._alphaTab) {
			if (!btn && this._$startLetter) {
				if (this._alphaTab.hasChildNodes()) {
					var children = this._alphaTab.childNodes;
					for (var ii = 0; ii < children.length; ii++) {
						var node = children[ii];
						if (node.innerHTML == this._$startLetter) {
							btn = node;
							break;
						}
					}
				}
			}
			if (this._alphaTabSelected) {
				this._alphaTabSelected.className = "s-alphatab-link";
				delete this._alphaTabSelected;
			}
			if (btn) {
				(this._alphaTabSelected = btn).className += " s-alphatab-link-selected";
			}
		}
	},
	filterByStartLetter: function(criterion) {
		var filterDataset = [];
		for (var ii = 0, jj = this.list.clientDataset.length; ii < jj; ii++) {
			var dataRecord = this.list.clientDataset[ii];
			if (criterion.binding) {
				var dataField = dataRecord[criterion.binding];
				if (dataField.search(new RegExp(criterion.startLetter, "i")) == 0) {
					filterDataset.push(dataRecord);
				}
			}
		}
		this.list.clientDataset = filterDataset;
	},
	sort: function($orderBy, property) {
		var self = this;
		var $externalOrderBy = [];
		$orderBy = $orderBy || [{
			binding: "$serverIndex",
			descending: false,
			$type: "application/x-integer"
		}];
		//map for convergence
		for (var ii = 0, jj = $orderBy.length; ii < jj; ii++) {
			$externalOrderBy.push({
				binding: $orderBy[ii].binding,
				asc: $orderBy[ii].descending !== true
			});
		}
		if (self.list.page.externalAdapter.sortArray(self.list, $externalOrderBy)) {
			self.list.clientDataset.sort(function(itemA, itemB) {
				var wr = 0;
				if (property) {
					itemA = itemA[property];
					itemB = itemB[property];
				}
				for (var mm = 0, kk = $externalOrderBy.length; mm < kk; mm++) {
					var criterion = $externalOrderBy[mm];
					var valueA = itemA[criterion.binding];
					var valueB = itemB[criterion.binding];
					switch (criterion.$type) {
						case "application/x-string":
						case "application/x-datetime":
							break;
						case "application/x-time":
						case "application/x-choice":
						case "application/x-boolean":
						case "application/x-integer":
							valueA = parseInt(valueA, 10);
							valueB = parseInt(valueB, 10);
							break;
						case "application/x-decimal":
						case "application/x-real":
							valueA = parseFloat(valueA, 10);
							valueB = parseFloat(valueB, 10);
							break;
						default:
							break;
					}
					if (valueA != valueB) {
						if (valueA > valueB) {
							wr = (criterion.asc) ? 1 : -1;
						} else {
							//valueA < valueB
							wr = (criterion.asc) ? -1 : 1;
						}
						break;
					}
				}
				return wr;
			});
		}
	},
	dispose: function() {
		this.list = this._sortedCols = this._$orderBy = this._alphaTab = this._alphaTabSelected = null;
	}
});