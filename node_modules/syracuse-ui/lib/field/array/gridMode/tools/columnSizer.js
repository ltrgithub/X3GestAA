"use strict";

var _widths = {
	titleCell: {
		sort: 20,
		noSort: 8
	},
	border: 2,
	input: {
		padding: 12
	}
};


function _findTreeColWidth(records, col) {
	var width = 0;
	for (var ii = 0, jj = records.length; ii < jj; ii++) {
		var record = records[ii];
		var slot = record.treeNode && record.treeNode.slot;
		width = Math.max(slot.scrollWidth, width);
	}
	return width;
}

function _findMaxField(records, col) {
	var width = 0,
		maxField;
	for (var ii = 0, jj = records.length; ii < jj; ii++) {
		var record = records[ii];
		var field = record.fieldCellsMap[col.$bind];
		var length = field.getDisplayText().length;
		if (length > width) {
			maxField = field;
			width = length;
		}
	}
	return maxField;
}

function _findMaxWidth(maxField) {
	var width = 0;
	if (maxField) {
		if (maxField.input) {
			width = maxField.input.scrollWidth + _widths.input.padding;
		} else {
			width = maxField._dataValue.scrollWidth;
		}
	}
	return width;
}

function _findFieldNoEditColWidth(records, col, firstCell) {
	var width = 0;
	switch (col.$field.$type) {
		case "application/x-choice":
		case "application/x-date":
		case "application/x-time":
		case "application/x-datetime":
		case "application/x-reference":
		case "application/x-integer":
		case "application/x-decimal":
		case "application/x-real":
		case "application/x-string":
			width = _findMaxWidth(_findMaxField(records, col));
			break;
		case "application/x-quantity":
			var maxField = _findMaxField(records, col);
			width = _findMaxWidth(maxField);
			if (maxField && maxField.unitField) {
				width += _findMaxWidth(maxField.unitField);
			}
			break;
		case "application/x-boolean":
			if (firstCell) {
				width = firstCell.scrollWidth;
			}
			break;
		case "application/x-icon":
			width = 50;
			width += 32; //cell padding
			break;
		default:
			var firstField = records[0] && records[0].fieldCellsMap[col.$bind];
			if (firstField && firstField.isDocumentField) {
				if (firstField.isImage) {
					width = parseInt(firstField.$item.$imageWidth.replace("px", ""), 10);
					width += 32; //cell padding
				} else {
					width = _findMaxWidth(_findMaxField(records, col));
				}
			}
			break;
	}
	if (col.$field.$hasFilterCapability) {
		width += 36;
	} else {
		width += 16;
	}
	return width;
}

function _findFieldEditColWidth(records, col, firstCell) {
	var firstField = records[0] && records[0].fieldCellsMap[col.$bind];
	var pickerWidth = 0;
	if (firstField && firstField.mnPickers) {
		var count = firstField.mnPickers.length;
		pickerWidth = count && (count * firstField.mnPickers[0].link.clientWidth);
	}
	var width = col.$field.$displayLength || col.$field.$maxLength || 0;
	if (width) {
		width = (width * 8) + _widths.input.padding;
	}
	if (!width) {
		switch (col.$field.$type) {
			case "application/x-choice":
				var $enum = col.$field.$value && col.$field.$value.$enum;
				if ($enum) {
					for (var ii = 0, jj = $enum.length; ii < jj; ii++) {
						width = Math.max(width, ($enum[ii].$title && $enum[ii].$title.length) || 0);
					}
					width = (width * 8) + _widths.input.padding;
				}
				break;
			case "application/x-date":
			case "application/x-time":
			case "application/x-datetime":
				if (firstField && firstField.localFormat) {
					width = (firstField.localFormat.length * 8) + _widths.input.padding;
				}
				break;
			case "application/x-quantity":
			case "application/x-reference":
				width = _findMaxWidth(_findMaxField(records, col));
				break;
			case "application/x-integer":
			case "application/x-decimal":
			case "application/x-real":
				if (col.$field.$precision) {
					width = col.$field.$precision + 2 * (col.$field.$precision / 3); //separator
				}
				if (col.$field.$scale) {
					width += col.$field.$scale + 1; //for separator
				}
				width = (width * 8) + _widths.input.padding;
				break;
			case "application/x-string":
				width = _findMaxWidth(_findMaxField(records, col));
				break;
			case "application/x-boolean":
				if (firstCell) {
					width = firstCell.scrollWidth;
				}
				break;
			case "application/x-icon":
				width = 50;
				width += 32; //cell padding
				break;
			default:
				if (firstField && firstField.isDocumentField) {
					width = firstCell.scrollWidth;
				}
				break;
		}
	}

	return (width || 0) + pickerWidth;
}



exports.setColumnWidth = function(col, records, $prefWidths, firstCell) {
	var builder = col.table.builder;
	col.colWidth = $prefWidths[col.$bind] || (col.$item && col.$item.$width) || (col.$field && col.$field.$width);
	if (col.colWidth == "NaNpx") {
		col.colWidth = null;
	}
	if (col.colWidth) {
		col.colWidth = parseInt((col.colWidth + "").replace("px", ""), 10);
	} else {
		if (firstCell) {
			firstCell.style.width = "";
		}
		col.titleCell.style.width = "";
		if (col == builder.columnsMap.$treeview) {
			col.colWidth = _findTreeColWidth(records, col);
		} else {
			if (col.useContentWidth && firstCell) {
				if (col == builder.columnsMap.$rowIndex && builder.list.greatestServerIndexRecord) {
					col.colWidth = builder.list.greatestServerIndexRecord[col.table.$rowKey].cells[firstCell.cellIndex].scrollWidth;
				} else {
					col.colWidth = firstCell.scrollWidth;
				}
			} else {
				if (col.$field) {
					if (builder.list.$isEditMode) {
						col.colWidth = _findFieldEditColWidth(records, col, firstCell);
					} else {
						col.colWidth = _findFieldNoEditColWidth(records, col, firstCell);
					}
				}
			}
		}
		if (col.colWidth > 1) {
			//>1 cause scrollwidth error
			col.colWidth += 2; //firstCell border 	
		} else {
			col.colWidth = 0;
		}
		if (!col.titleWidth) {
			if (col.titleLabel) {
				col.titleWidth = col.titleLabel.link.scrollWidth + (col.sortBtn ? _widths.titleCell.sort : _widths.titleCell.noSort);
			} else {
				col.titleWidth = col.titleCell.scrollWidth;
			}
			if (col.titleWidth > 1) {
				col.titleWidth += _widths.border;
			} else {
				col.titleWidth = 0;
			}

		}
		col.colWidth = Math.max(col.colWidth, col.titleWidth);
	}
	if (col.$field) {
		col.colWidth = Math.max(40, col.colWidth);
	}
	return col.colWidth;
};