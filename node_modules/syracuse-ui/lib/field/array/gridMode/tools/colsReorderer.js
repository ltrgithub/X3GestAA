"use strict";
var helpers = require('syracuse-core/lib/helpers');

function _fillItemsList(list) {
	var allColumns = list.builder.allColumns;
	list.$item.$layout.$items = [];
	for (var ii = 0, jj = allColumns.length; ii < jj; ii++) {
		var col = allColumns[ii];
		if (col.$bind) {
			if (!col.table.isFixedCols) {
				delete col.$item.$isFixed;
			}
			list.$item.$layout.$items.push(col.$item);
		}
	}
}

function _moveCols(colSource, colTarget, dropAtEnd) {
	var list = colSource.list;
	var allColumns = list.builder.allColumns;
	var tblSource = colSource.table;
	allColumns.splice(allColumns.indexOf(colSource), 1);
	tblSource.columns.splice(tblSource.columns.indexOf(colSource), 1);
	colTarget.titleCell.parentNode.insertBefore(colSource.titleCell, dropAtEnd ? colTarget.titleCell.nextSibling : colTarget.titleCell);
	colSource.slot = colTarget.slot;
	var record = list.builder.filterRecord;
	if (record) {
		var targetCell = record.cellsMap[colTarget.key];
		targetCell.parentNode.insertBefore(record.cellsMap[colSource.key], dropAtEnd ? targetCell.nextSibling : targetCell);
	}
	for (var ii = 0, jj = list.records.length; ii < jj; ii++) {
		var record = list.records[ii];
		var targetCell = record.cellsMap[colTarget.key];
		targetCell.parentNode.insertBefore(record.cellsMap[colSource.key], dropAtEnd ? targetCell.nextSibling : targetCell);
	}
	allColumns.splice(allColumns.indexOf(colTarget) + (dropAtEnd ? 1 : 0), 0, colSource);
	colTarget.table.columns.splice(colTarget.table.columns.indexOf(colTarget) + (dropAtEnd ? 1 : 0), 0, colSource);
	colSource.table = colTarget.table;
	syra_dom.toggleClass(colSource.titleCell, "s-grid-fixed", colSource.table.isFixedCols);
	_fillItemsList(list);
	var $columns = [];
	for (var ii = 0, jj = list.$item.$layout.$items.length; ii < jj; ii++) {
		$columns.push(list.$item.$layout.$items[ii].$bind);
	}
	list.$pagePreferences.$columns = $columns;
	list.saveListDesign();
	syra_preference.page.saveField(list, list.$pagePreferences);
	list.resizeItem();
}

exports.moveToSrollTable = function(col) {
	var list = col.list;
	var scrollTable = list.builder.scrollTable;
	scrollTable.columns.unshift(col);
	scrollTable.titleRow.insertBefore(col.titleCell, scrollTable.titleRow.firstChild);
	col.slot = col.titleCell.parentNode;
	syra_dom.toggleClass(col.titleCell, "s-grid-fixed", false);
	var record = list.builder.filterRecord;
	if (record) {
		record.dataRow.insertBefore(record.cellsMap[col.key], record.dataRow.firstChild);
	}
	for (var ii = 0, jj = list.records.length; ii < jj; ii++) {
		var record = list.records[ii];
		record.dataRow.insertBefore(record.cellsMap[col.key], record.dataRow.firstChild);
	}
	col.table = scrollTable;
};

function _clearFieldColumns(columns) {
	if (columns) {
		for (var ii = 0, jj = columns.length; ii < jj; ii++) {
			if (columns[ii].$bind) {
				columns.splice(ii, columns.length - ii);
				break;
			}
		}
	}
}

exports.resetReorder = function(list) {
	var $binds = list.$origColumns;
	if ($binds) {
		_clearFieldColumns(list.builder.allColumns);
		var fixedTable = list.builder.fixedTable;
		var scrollTable = list.builder.scrollTable;
		fixedTable && _clearFieldColumns(fixedTable.columns);
		scrollTable && _clearFieldColumns(scrollTable.columns);
		var filterRecord = list.builder.filterRecord;
		for (var ii = 0, jj = $binds.length; ii < jj; ii++) {
			var col = list.builder.columnsMap[$binds[ii]];
			list.builder.allColumns.push(col);
			var newTable = col.$field.$isFixed ? fixedTable : scrollTable;
			if (col.titleCell) {
				newTable.titleRow.appendChild(col.titleCell);
				col.slot = col.titleCell.parentNode;
			}
			filterRecord && filterRecord[newTable.$rowKey].appendChild(filterRecord.cellsMap[col.key]);
			for (var mm = 0, kk = list.records.length; mm < kk; mm++) {
				var record = list.records[mm];
				record[newTable.$rowKey].appendChild(record.cellsMap[col.key]);
			}
			newTable.columns.push(col);
			col.table = newTable;
			syra_dom.toggleClass(col.titleCell, "s-grid-fixed", col.table.isFixedCols);
		}
		_fillItemsList(list);
	}
};


exports.isDraggable = function(list, col, event) {
	syra_dd.dropableItem = {
		list: list,
		reordeCol: col
	};
	syra_dd.start(list, ColsReorderDDAgent, list.builder.scrollTable.titleRow);
	event.syraRetValue = false;
};

function ColsReorderDDAgent() {}

helpers.defineClass(ColsReorderDDAgent, null, {
	start: function(dropItem) {
		syra_dd.ddAgent = this;
		this.reordeCol = dropItem.reordeCol;
		this.list = dropItem.list;
		var offset = this.reordeCol.titleCell.getBoundingClientRect();
		this.top = offset.top;
		this.left = offset.left;
		this.boundary = this.list.builder.scrollTable.titleRow.getBoundingClientRect();
		this.info = syra_dom.addDiv("s-grid-drag-image", syra_site.layoutSlot);
		this.cueTop = document.createElement("div");
		this.cueBottom = document.createElement("div");
		this.scrollArea = (this.list.records && this.list.records.length) ? this.list.builder.scrollTable.bodySlot : this.list.builder.scrollTable.headSlot;
		this.scrollBoundary = syra_dom.getBoundingClientRect(this.scrollArea);
		this.scrollBoundary.scrollWidth = this.scrollArea.scrollWidth;
		this.scrollBoundary.scrollHeight = this.scrollArea.scrollHeight;

		syra_dom.hide(this.cueTop, true);
		syra_dom.hide(this.cueBottom, true);
		this.cueTop.className = "s-grid-drop-cue-top";
		this.cueTop.style.top = (this.boundary.top - 9) + "px";
		this.cueBottom.style.top = this.boundary.bottom + "px";
		syra_site.layoutSlot.appendChild(this.cueTop);
		this.cueBottom.className = "s-grid-drop-cue-bottom";
		syra_site.layoutSlot.appendChild(this.cueBottom);
		this.info.textContent = this.reordeCol.titleText;
		this.list.isColReordering = true;
		this.isDragging = false;
	},
	onColumnHeaderEnterLeave: function(col, onEnter) {
		if (onEnter) {
			this.colTarget = col;
			this.targetX = this.colTarget.titleCell.getBoundingClientRect().left - 4; //4 cue width /2
			if (this.list.builder.allColumns[this.list.builder.allColumns.length - 1] == this.colTarget) {
				this.lastColBoundaryX = this.targetX + this.colTarget.colWidth / 2;
			}
			this.cueTop.style.left = this.cueBottom.style.left = this.targetX + "px";
			syra_dom.hide(this.cueTop, false);
			syra_dom.hide(this.cueBottom, false);
			syra_dom.toggleClass(this.info, "s-drag-ok", this.colTarget != null);
		} else {
			if (this.colTarget && this.colTarget == col) {
				this.colTarget = null;
				delete this.lastColBoundaryX;
				syra_dom.hide(this.cueTop, true);
				syra_dom.hide(this.cueBottom, true);
			}
			syra_dom.toggleClass(this.info, "s-drag-ok", this.colTarget != null);
		}
	},
	onDragMouseMove: function(target, event) {
		if (!this.isDragging) {
			if (!this.startX) {
				this.startX = event.pageX;
			} else {
				if (Math.abs(this.startX - event.pageX) > 4) {
					this.isDragging = true;
				}
			}
		}
		if (this.isDragging) {
			var step = 40,
				margin = 80;
			if (this.scrollBoundary) {
				if (event.pageY > (this.scrollBoundary.bottom - margin)) {
					var scrollTop = this.list.builder.scrollTable.bodySlot.scrollTop;
					if (scrollTop < (this.scrollBoundary.scrollHeight - this.scrollBoundary.height)) {
						this.list.builder.scrollTable.bodySlot.scrollTop = Math.min(scrollTop + step, this.scrollBoundary.scrollHeight - this.scrollBoundary.height);
					}
				} else {
					if (event.pageY < (this.scrollBoundary.top + margin)) {
						var scrollTop = this.list.builder.scrollTable.bodySlot.scrollTop;
						this.list.builder.scrollTable.bodySlot.scrollTop = Math.max(scrollTop - step, 0);
					}
				}
				if (event.pageX > (this.scrollBoundary.right - margin)) {
					var scrollLeft = this.scrollArea.scrollLeft;
					if (scrollLeft < (this.scrollBoundary.scrollWidth - this.scrollBoundary.width)) {
						this.scrollArea.scrollLeft = Math.min(scrollLeft + step, this.scrollBoundary.scrollWidth - this.scrollBoundary.width);
					}
				} else {
					if (event.pageX < (this.scrollBoundary.left + margin)) {
						this.scrollArea.scrollLeft = Math.max(this.scrollArea.scrollLeft - step, 0);
					}
				}
			}

			var top = Math.max(event.pageY, this.boundary.top);
			var left = Math.max(event.pageX, this.boundary.left);
			var inBoundary = (event.pageX == left && event.pageY == top);
			this.info.style.top = top + 15 + "px";
			this.info.style.left = left + 15 + "px";

			if (this.lastColBoundaryX) {
				if (event.pageX > this.lastColBoundaryX) {
					if (!this.dropAtEnd) {
						this.cueBottom.style.left = this.cueTop.style.left = (this.targetX + this.colTarget.colWidth) + "px";
						this.dropAtEnd = true;
					}
				} else {
					if (this.dropAtEnd) {
						this.cueBottom.style.left = this.cueTop.style.left = this.targetX + "px";
						this.dropAtEnd = false;
					}
				}
			}
		}
	},
	onDragMouseUp: function(target, event) {
		syra_dom.removeChild(this.info);
		syra_dom.removeChild(this.cueTop);
		syra_dom.removeChild(this.cueBottom);
		this.isDragging && this.colTarget && _moveCols(this.reordeCol, this.colTarget, this.dropAtEnd);
		syra_site.layoutSlot.style.cursor = "default";
	},
	dispose: function() {
		if (this.list) {
			delete this.list.isColReordering;
		}
		this.scrollArea = this.colTarget = this.boundary = this.reordeCol = this.list = this.info = this.cueTop = this.cueBottom = this.scrollBoundary = null;
	}
});