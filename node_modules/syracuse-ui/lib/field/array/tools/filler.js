"use strict";

function _applyFullDelta(list, dataRecordSet, dataIndex, updatedMap) {
	var oldMap = list.recordsMap;
	list.recordsMap = {};
	var oldRecords = list.records;
	list.records = [];
	var lastRecord, recordIndex = 0;
	for (var ii = dataIndex.start; ii <= dataIndex.last; ii++) {
		var dataRecord = dataRecordSet[ii - 1];
		var $index = dataRecord.$serverIndex;
		if ($index === undefined) {
			$index = dataRecord.$index;
		}
		if ($index === undefined) {
			$index = (ii - 1);
		}
		var sourceDataset = list.dataset[$index];
		if (sourceDataset) {
			var record = oldMap[dataRecord.$uuid];
			if (record) {
				record.ensureDataSet(dataRecord.$uuid);
				var updatedRecord = updatedMap && updatedMap[dataRecord.$uuid];
				list.recordsMap[dataRecord.$uuid] = record;
				record.applyChange(updatedRecord || dataRecord);
				record.$serverIndex = sourceDataset.$serverIndex;
				if (oldRecords.indexOf(record) != recordIndex) {
					if (lastRecord) {
						record.reorderItem(lastRecord, true);
					} else {
						record.reorderItem(null, false);
					}
				}
				list.records.push(record);
			} else {
				record = list._appendRecord({
					dataRecord: sourceDataset,
					$recordIndex: recordIndex
				});
			}
			lastRecord = record;
			recordIndex++;
		}
		delete oldMap[dataRecord.$uuid];
	}
	var uiids = Object.keys(oldMap);
	for (var ii = 0, jj = uiids.length; ii < jj; ii++) {
		list.removeRecord(oldMap[uiids[ii]], true);
		delete oldMap[uiids[ii]];
	}
};

function _applyPartialDelta(list, deltaSet, dataIndex) {
	for (var $serverIndex = 0, jj = deltaSet.length; $serverIndex < jj; $serverIndex++) {
		var deltaRecord = deltaSet[$serverIndex];
		var record = list.recordsMap[deltaRecord.$uuid];
		if (record) {
			var index = parseInt(deltaRecord.$index, 10) + 1;
			if (deltaRecord.$isDeleted || !(dataIndex.start <= index && index <= dataIndex.last)) {
				list.removeRecord(record, true, true);
			} else {
				var recordIndex = null,
					prevIndex = null;
				if (deltaRecord.$index !== undefined && record.$serverIndex != deltaRecord.$index) {
					prevIndex = list.records.indexOf(record);
					recordIndex = deltaRecord.$index - dataIndex.start;
				}
				record.ensureDataSet(record.$uuid);
				record.applyChange(deltaRecord);
				if (prevIndex) { //not process if list.clientFetchOptions
					list.records.splice(prevIndex, 1);
					list.records.splice(recordIndex, 0, record);
					var nextRecord;
					if ((recordIndex + 1) < list.records.length) {
						nextRecord = list.records[recordIndex + 1];
					}
					record.reorderItem(nextRecord, nextRecord ? false : true);
				}
			}
		} else {
			if (!deltaRecord.$isDeleted) {
				var index = parseInt(deltaRecord.$index, 10) + 1;
				if (dataIndex.start <= index && index <= dataIndex.last) {
					list._appendRecord({
						dataRecord: list.dataset[deltaRecord.$index],
						$recordIndex: deltaRecord.$index
					});
				}
			}
		}
	}
};


exports.fill = function(list, dataRecordSet, parentDataRecord, isDelta) {
	if (isDelta) {
		var updatedMap = {};
		if (!list.isSingList && dataRecordSet) {
			for (var ii = dataRecordSet.length - 1; ii >= 0; ii--) {
				updatedMap[dataRecordSet[ii].$uuid] = dataRecordSet[ii];
			}
		}
		var partialDelta = list.page.$isPartialDelta || (dataRecordSet.length == 1 && dataRecordSet[0].$index !== undefined);
		if (list.clientFetchOptions) {
			list.fetcher.applyFetchOptions(list, list.clientFetchOptions);
			if (list.pagging.$startIndex !== undefined && list.clientDataset.length < list.pagging.$startIndex) {
				list.pagging.ensureClientRange();
				list.clientFetchOptions.params.startIndex = list.pagging.$startIndex;
			}
			syra_grid.columnFitter.reset(list);
			if (list.treeDecorator) {
				list.treeDecorator.buildTreeMap(list.clientDataset);
			}
			var dataIndex = list.pagging.getParseIndexes();
			_applyFullDelta(list, list.clientDataset, dataIndex, updatedMap);
		} else {
			list.clientDataset = list.ensureDataSet();
			var dataIndex = list.pagging.getParseIndexes();
			if (partialDelta) {
				if (list.treeDecorator) {
					list.treeDecorator.buildTreeMap(dataRecordSet, true);
				}
				_applyPartialDelta(list, dataRecordSet, dataIndex);
			} else {
				syra_grid.columnFitter.reset(list);
				if (list.treeDecorator) {
					list.treeDecorator.buildTreeMap(dataRecordSet);
				}
				_applyFullDelta(list, dataRecordSet, dataIndex);
			}
		}
	} else {
		list.setMustBeResized();
		syra_grid.columnFitter.reset(list);
		list.clientDataset = list.isSingList ? list.ensureDataSet() : dataRecordSet;
		if (list.treeDecorator) {
			list.treeDecorator.buildTreeMap(list.clientDataset);
		}
		list.body.style.display = "none";
		list.removeRecords(!(list.clientDataset && list.clientDataset.length > 0));
		if (list.clientDataset) {
			var start, last;
			//warn: list.onClientFetch =true and list.isClientFetch=false for convergence left list
			if (list.isClientFetch) {
				if (list.pagging.$startIndex !== undefined && list.clientDataset.length < list.pagging.$startIndex) {
					list.pagging.ensureClientRange();
				}
				var dataIndex = list.pagging.getParseIndexes();
				start = dataIndex.start;
				last = dataIndex.last;
			} else {
				start = 1;
				last = list.clientDataset.length;
			}
			for (var ii = start; ii <= last; ii++) {
				var dataRecord = list.clientDataset[ii - 1];
				if (!dataRecord.$isDeleted) {
					list._appendRecord({
						dataRecord: dataRecord
					});
				}
			}
		}
	}
	list.validateDisplay();
};