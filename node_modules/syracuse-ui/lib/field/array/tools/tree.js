"use strict";

function _openNode(tree, record, open) {
	//for commit after merge
	var $bindings = tree.list.$prototype.$treeview.$bindings;
	var node = tree._nodes[record.dataset[$bindings.$id || $bindings.$clientId] || "s-empty"];
	if (open !== undefined && open === node.isOpened) {
		return;
	} else {
		node.isOpened = !node.isOpened;
		if ($bindings.$open) {
			if (tree.list.page.isFusionPage) {
				record.dataset[$bindings.$open] = node.isOpened ? 2 : 1;
			} else {
				record.dataset[$bindings.$open] = node.isOpened;
			}
		}
	}
	syra_button.setText(record.treeNode.expandBtn, "", node.isOpened ? "node_expanded" : "node_collapsed");
	_displayChildren(tree.list, node, node.isOpened, node.children);
}


function _displayChildren(list, parentNode, isParentOpened, uuids) {
	if (parentNode.childRoot) {
		syra_dom.hide(parentNode.childRoot, !isParentOpened);
	}
	for (var ii = 0, jj = uuids.length; ii < jj; ii++) {
		var record = list.recordsMap[uuids[ii]];
		syra_dom.hide(record.dataRow, !(record.treeNode.isVisible = isParentOpened));
		if (record.treeNode.children.length) {
			_displayChildren(list, record.treeNode, record.treeNode.isOpened && isParentOpened, record.treeNode.children);
		}
	}
}

function _addIcon(tree, record, $iconBind) {
	var name = record.dataset[$iconBind];
	var node = record.treeNode;
	if (name) {
		if (!node.icon) {
			node.icon = document.createElement("div");
			node.icon.className = tree.cssNodeIcon;
			node.item.insertBefore(node.icon, node.desc);
		}
		if (node.iconName != name) {
			node.iconName = name;
			node.icon.style.backgroundImage = "url('" + syra_site.$iconPath + "tree/" + name + "')";
		}
	} else {
		if (node.icon) {
			syra_dom.remove(node.icon);
			delete node.icon;
			delete node.iconName;
		}
	}
}

function _drawRecord(tree, parentNode, record, level) {
	var node = record.treeNode;
	var hasChildren = node.children.length > 0;
	var skinLevel = tree.list.$item.$addTreeLevel ? (" " + tree.list.$skin + "-level-" + level) : null;
	tree._orderedNodes.push(record);
	if (tree.isCardFormat) {
		if (hasChildren) {
			if (!node.childRoot) {
				node.childRoot = document.createElement("div");
				node.childRoot.className = tree.list.$skin + "-children";
				if (skinLevel) {
					node.childRoot.className += skinLevel;
				}
				record.domItem.appendChild(node.childRoot);
				syra_dom.hide(node.childRoot, true);
			}
		}
		if (parentNode && parentNode.childRoot) {
			parentNode.childRoot.appendChild(record.dataRow);
		} else {
			tree.list.body.appendChild(record.dataRow);
		}
	} else {
		record.fixedRow && tree.list.builder.fixedTable.bodyTable.appendChild(record.fixedRow);
		tree.list.builder.scrollTable.bodyTable.appendChild(record.dataRow);
	}
	record.treeNode.level = level;
	if (tree.list.selector.appendToRecord) {
		if (tree.list.selector.isMulti) {
			if (!record.checkBox) {
				tree.list.selector.appendToRecord(record, record.treeNode.selectorSlot);
				syra_dom.hide(record.treeNode.selectorSlot, false);
			}
		} else {
			if (hasChildren) {
				if (record.checkBox) {
					syra_dom.remove(record.checkBox.slot);
					delete record.checkBox;
					syra_dom.hide(record.treeNode.selectorSlot, true);
				}
			} else {
				if (!record.checkBox) {
					tree.list.selector.appendToRecord(record, record.treeNode.selectorSlot);
					syra_dom.hide(record.treeNode.selectorSlot, false);
				}
			}
		}
	}
	if (hasChildren) {
		syra_button.setText(record.treeNode.expandBtn, "", node.isOpened ? "node_expanded" : "node_collapsed");
		if (node.childRoot) {
			syra_dom.hide(node.childRoot, !node.isOpened);
		}
	}
	syra_button.hide(record.treeNode.expandBtn, !hasChildren);

	var padding = 0;
	var $bindings = tree.list.$prototype.$treeview.$bindings;
	$bindings.$icon && _addIcon(tree, record, $bindings.$icon);
	if (parentNode) {
		node.isVisible = parentNode.isVisible && parentNode.isOpened;
		//record.dataRow.style.display = node.isVisible ? "" : "none";
		if (!tree.list.$item.$isNodeLazyLoad && !hasChildren && record.treeNode.icon) {
			padding = 22;
		}
	} else {
		node.isVisible = (node.parentId == null) || (node.parentId == "");
	}
	syra_dom.hide(record.dataRow, !node.isVisible);
	record.treeNode.slot.style[syra_site.isRTL ? "paddingRight" : "paddingLeft"] = (record.treeNode.level * 22) + padding + "px";
	if (skinLevel) {
		record.dataRow.className += skinLevel;
		record.treeNode.slot.className += skinLevel;
		record.treeNode.item.className += skinLevel;
	}
	if (hasChildren) {
		for (var ii = 0, jj = node.children.length; ii < jj; ii++) {
			var child = tree.list.recordsMap[node.children[ii]];
			child && _drawRecord(tree, node, child, level + 1);
		}
	}
}


function _onNodeClick() {
	var record = this.parent;
	var list = record.list;
	list.page.externalAdapter.onFieldClickPicker({
		field: record,
		pickerType: "openTreeNode",
		doEvent: function() {
			if (record && record.treeNode) {
				_openNode(list.treeDecorator, record);
				list.resizeItem(true);
			}
		}
	});
}

function Tree(list) {
	this.list = list;
	this.list.$item.$alternateStyle = false;
	var $skin = this.list.$item.$treeSkin || "s-list-tree";
	this.cssNodeSelector = $skin + "-selector";
	this.cssNodeCell = $skin + "-cell";
	this.cssNode = $skin + "-node";
	this.cssNodePicker = this.cssNode + "-picker";
	this.cssNodeIcon = this.cssNode + "-icon";
	if (syra_site.isRTL) {
		this.cssNodeIcon += " s-rtl-img";
		this.cssNodePicker += " s-rtl-img";
	}
	this.cssNodeDesc = this.cssNode + "-desc";
	this.cssNodeDescValue = this.cssNode + "-desc-value";
	this.list.$isEditMode = false; // set false editMode for that that contains tree
	var $bindings = this.list.$prototype.$treeview.$bindings;
	var $data = $bindings.$data || [];
	var $keys = Object.keys(list.$fields);
	for (var ii = 0, jj = $keys.length; ii < jj; ii++) {
		var $field = list.$fields[$keys[ii]];
		$field.$isExcluded = $data.indexOf($keys[ii]) < 0;
	}

	//issue #7036
	if ($bindings.$data && this.list.$item.$selectMode == undefined) {
		this.list.$item.$selectMode = "row";
	}
}

Tree.prototype.buildTreeMap = function() {
	var $bindings = this.list.$prototype.$treeview.$bindings;
	this._nodes = {};
	this.tree = [];
	var max = this.list.records.length;
	if (max) {
		if (this.list.page.isFusionPage && syra_fusion.sapUtil.isEmptyGridDataRecordEx(this.list.$prototype.$item.$properties, this.list.records[max - 1].dataset)) {
			// Unfortunately, in Convergence last line could be inconsistent.
			max--;
		}
	}
	for (var ii = 0; ii < max; ii++) {
		var record = this.list.records[ii];
		var node = record.treeNode;
		if ($bindings.$open && record.dataset[$bindings.$open] !== undefined) {
			node.isOpened = record.dataset[$bindings.$open];
			node.isOpened = (node.isOpened === true || node.isOpened == 2);
		} else {
			node.isOpened = true;
		}
		node.$uuid = record.$uuid;
		node.parentId = record.dataset[$bindings.$parent];
		node.id = record.dataset[$bindings.$id || $bindings.$clientId] || "s-empty";
		node.children = [];
		this._nodes[node.id] = node;
	}
	for (var ii = 0; ii < max; ii++) {
		var node = this.list.records[ii].treeNode;
		var parentNode = this._nodes[node.parentId];
		if (parentNode) {
			node.parentUiid = parentNode.$uuid;
			parentNode.children.push(node.$uuid);
		} else {
			this.tree.push(node);
		}
	}
};
Tree.prototype.onNodeSelected = function(record, selected) {
	if (record && record.treeNode) {
		var parendId = record.treeNode.parentId;
		if (parendId && parendId !== "") {
			var parentRecord = this.list.recordsMap[record.treeNode.parentUiid];
			if (parentRecord && this.list.$item && this.list.$item.$selectMode === "multi") {
				var selectParent = selected;
				if (!selectParent) {
					var children = parentRecord && parentRecord.treeNode && parentRecord.treeNode.children;
					if (children) {
						for (var ii = 0, jj = children.length; ii < jj; ii++) {
							var $uuid = children[ii];
							var record = this.list.recordsMap[children[ii]];
							if (record && record.dataset.$isSelected) {
								selectParent = true;
								break;
							}
						}
					}
				}
				this.list.selector.selectRecord(parentRecord, selectParent);
			}
		}
	}
};
Tree.prototype.onEndFillList = function() {
	this._orderedNodes = [];
	this.buildTreeMap();
	this.isCardFormat = this.list.$item.$format == "cards";
	for (var ii = 0, jj = this.tree.length; ii < jj; ii++) {
		var child = this.list.recordsMap[this.tree[ii].$uuid];
		child && _drawRecord(this, null, child, 0);
	}
};
Tree.prototype.addCardNode = function(record, slot) {
	var node = record.treeNode = {
		slot: slot,
		item: document.createElement("div")
	};
	var $bindings = this.list.$prototype.$treeview.$bindings;
	node.item.className = this.cssNode;
	node.expandBtn = syra_button.add({
		parent: record,
		slot: node.item,
		isHidden: !this.list.$item.$isNodeLazyLoad,
		text: "",
		css: this.cssNodePicker,
		iconOnly: true,
		fontIcon: this.list.$item.$isNodeLazyLoad ? "node_expanded" : "node_collapsed",
		click: _onNodeClick
	});
	if (this.list.selector.appendToRecord) {
		node.selectorSlot = document.createElement("div");
		syra_dom.hide(node.selectorSlot, true);
		node.selectorSlot.className = this.cssNodeSelector;
		node.item.appendChild(node.selectorSlot);
	}
	node.desc = document.createElement("div");
	node.desc.className = this.cssNodeDesc;
	node.descriptionField = record.page.addItem(node.item.appendChild(node.desc), {
		$bind: $bindings.$description,
		$isGridCell: true,
		$inplace: true
	}, record);
	node.descriptionField.setState({
		$isHidden: false
	});
	node.descriptionField._dataValue.className += " " + this.cssNodeDescValue;
	node.slot.appendChild(node.item);
};
Tree.prototype.openAll = function(open) {
	for (var ii = 0, jj = this.list.records.length; ii < jj; ii++) {
		_openNode(this, this.list.records[ii], open);
	}
	this.list.resizeItem(true);
};
Tree.prototype.getPrevNextRecord = function(record, next) {
	var index = this._orderedNodes.indexOf(record);
	for (var ii = (next ? Math.min(index + 1, this._orderedNodes.length - 1) : Math.max(index - 1, 0)), jj = (next ? this._orderedNodes.length : -1);
		(next && ii < jj) || (!next && ii > jj);
		(next ? ii++ : ii--)) {
		var record = this._orderedNodes[ii];
		if (record && record.treeNode && record.treeNode.isVisible) {
			return parseInt(record.$serverIndex, 10);
		}
	}
	return index;
};

exports.add = function(list) {
	list.treeDecorator = new Tree(list);
};