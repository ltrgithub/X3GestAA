"use strict";
var helpers = require('syracuse-core/lib/helpers');

function _openNode(tree, record, open) {
	var node = tree._nodes[record.dataset[tree.list.$prototype.$treeview.$bindings.$clientId] || "s-empty"];
	if (open !== undefined && open === node.isOpened) {
		return;
	} else {
		node.isOpened = !node.isOpened;
	}
	record.treeNode.picker.className = tree.cssNodePicker + (node.isOpened ? " s-open" : " s-close");
	_displayChildren(tree.list, node, node.isOpened, node.children);
}

function _openAll(tree, open) {
	for (var ii = 0, jj = tree.list.records.length; ii < jj; ii++) {
		_openNode(tree, tree.list.records[ii], open);
	}
	tree.list.resizeArticle(true);
}

function _displayChildren(list, parentNode, isParentOpened, children) {
	if (parentNode.childRoot) {
		parentNode.childRoot.style.display = isParentOpened ? "" : "none";
	}
	for (var ii = 0, jj = children.length; ii < jj; ii++) {
		var node = children[ii];
		list.recordsMap[node.$uuid].dataRow.style.display = (node.isVisible = isParentOpened) ? "" : "none";
		if (node.children.length) {
			_displayChildren(list, node, node.isOpened && isParentOpened, node.children);
		}
	}
}

function _drawNodesOrder(tree, parentNode, nodes, level) {
	var isCard = tree.list.$item.$format == "cards";
	var skinLevel = tree.list.$item.$addTreeLevel ? (" " + tree.list.$skin + "-level-" + level) : null;
	var parentRecords = {};
	if (nodes) {
		for (var ii = 0, jj = nodes.length; ii < jj; ii++) {
			var node = nodes[ii];
			var hasChildren = node.children.length > 0;
			var record = (node.$uuid != undefined) ? tree.list.recordsMap[node.$uuid] : null;
			if (record) {
				tree._orderedNodes.push({
					$uuid: record.$uuid,
					$serverIndex: record.$serverIndex,
					$recordIndex: record.$recordIndex
				});
				if (isCard) {
					if (hasChildren) {
						parentRecords[node.$uuid] = record;
						if (!node.childRoot) {
							node.childRoot = document.createElement("div");
							node.childRoot.className = tree.list.$skin + "-children";
							if (skinLevel) {
								node.childRoot.className += skinLevel;
							}
							record.domItem.appendChild(node.childRoot);
							node.childRoot.style.display = "none";
						}
					}
					if (parentNode && parentNode.childRoot) {
						parentNode.childRoot.appendChild(record.dataRow);
					} else {
						tree.list.body.appendChild(record.dataRow);
					}
				} else {
					tree.list.body.appendChild(record.dataRow);
				}
				record.treeNode.level = level;
				if (tree.list.selector.appendToRecord) {
					if (tree.list.selector.isMulti) {
						if (!record._selectorCheck) {
							record._selectorCheck = tree.list.selector.appendToRecord(record.treeNode.selectorSlot);
							record.treeNode.selectorSlot.style.display = "";
						}
					} else {
						if (hasChildren) {
							if (record._selectorCheck) {
								syra_site.dom.removeChild(record._selectorCheck);
								delete record._selectorCheck;
								record.treeNode.selectorSlot.style.display = "none";
							}
						} else {
							if (!record._selectorCheck) {
								record._selectorCheck = tree.list.selector.appendToRecord(record.treeNode.selectorSlot);
								record.treeNode.selectorSlot.style.display = "";
							}
						}
					}
				}
				if (hasChildren) {
					record.treeNode.picker.syraOnClick = "onTreeNodeClick";
					record.treeNode.picker.className = tree.cssNodePicker + (node.isOpened ? " s-open" : " s-close");
					if (node.childRoot) {
						node.childRoot.style.display = node.isOpened ? "" : "none";
					}
					record.treeNode.picker.style.display = "";
				} else {
					if (record.treeNode.picker) {
						record.treeNode.picker.style.display = "none";
					}
				}
				var padding = 0;
				if (parentNode) {
					node.isVisible = parentNode.isVisible && parentNode.isOpened;
					record.dataRow.style.display = node.isVisible ? "" : "none";
					record.dataRow.syraParentNode = parentNode.$uuid;
					if (!tree.list.$item.$isNodeLazyLoad && !hasChildren && record.treeNode.icon) {
						padding = 18;
					}
				} else {
					node.isVisible = true;
				}
				record.treeNode.slot.style.paddingLeft = (record.treeNode.level * 18) + padding + "px";
				if (skinLevel) {
					record.dataRow.className += skinLevel;
					record.treeNode.slot.className += skinLevel;
					record.treeNode.item.className += skinLevel;
				}
			}
			hasChildren && _drawNodesOrder(tree, node, node.children, level + 1);
		}
	}
}

function TreeDecorator() {}

exports.TreeDecorator = helpers.defineClass(TreeDecorator, null, {
	buildTreeMap: function(dataset, partialDelta) {
		var $bindings = this.list.$prototype.$treeview.$bindings;
		var jj = dataset.length,
			extAdapter = this.list.page && this.list.page.externalAdapter,
			listItems = this.list.$prototype && this.list.$prototype.$item;
		if (!partialDelta) {
			this._uuidNodes = {};
			this._nodes = {};
			this.tree = [];
		}
		if (jj && listItems && extAdapter && extAdapter.isListRecordEmpty(listItems.$properties, dataset[jj - 1])) {
			// Unfortunately, in Convergence last line could be inconsistent.
			jj--;
		}
		for (var ii = 0; ii < jj; ii++) {
			var dataRecord = dataset[ii];
			var parentId = dataRecord[$bindings.$parent];
			var id = dataRecord[$bindings.$clientId] || "s-empty";
			var node;
			var isOpened;
			if (partialDelta) {
				node = this._uuidNodes[dataRecord.$uuid] || this._nodes[id];
				if (parentId === undefined && node) {
					parentId = node.parentId;
				}
				if ($bindings.$open && dataRecord[$bindings.$open] !== undefined) {
					isOpened = $bindings.$open ? (dataRecord[$bindings.$open] === true || dataRecord[$bindings.$open] == 2) : true;
				} else {
					isOpened = node ? node.isOpened : false;
				}
			} else {
				node = this._nodes[id];
				isOpened = $bindings.$open ? (dataRecord[$bindings.$open] === true || dataRecord[$bindings.$open] == 2) : true;
			}
			var appendToParent = false;
			if (node) {
				if (node.parentId == undefined) {
					var found = this.tree.indexOf(node);
					if (found >= 0) {
						this.tree.splice(found, 1);
						appendToParent = true;
					}
				} else {
					if (node.parentId != parentId) {
						var prevParent = this._nodes[node.parentId];
						if (prevParent) {
							prevParent.children.splice(prevParent.children.indexOf(node), 1);
						}
						appendToParent = true;
					}
				}
			} else {
				appendToParent = true;
				this._nodes[id] = node = {
					id: id,
					desc: dataRecord[$bindings.$description] || "",
					children: []
				};
			}
			if (appendToParent) {
				var parentNode = this._nodes[parentId];
				if (!parentNode) {
					this.tree.push(parentNode = this._nodes[parentId] = {
						id: parentId,
						children: []
					});
				}
				parentNode.children.push(node);
			}
			node.$uuid = dataRecord.$uuid;
			this._uuidNodes[node.$uuid] = node;
			node.parentId = parentId;
			node.isOpened = isOpened;
		}
	},
	onNodeSelected: function(uuid, selected) {
		var parendId = (this._uuidNodes[uuid] ? this._uuidNodes[uuid].parentId : null),
			parent = (parendId && parendId !== "") ? this._nodes[this._uuidNodes[uuid].parentId] : null,
			selectParent = selected,
			childCount;

		if (parent && this.list.$item && this.list.$item.$selectMode === "multi") {
			if (!selectParent) {
				if (parent.children && (childCount = parent.children.length)) {
					for (var ii = 0; ii < childCount; ii++) {
						if (this.list.dataset[parent.children[ii].$uuid] && this.list.dataset[parent.children[ii].$uuid].$isSelected) {
							selectParent = true;
							break;
						}
					}
				}
			}
			if (parent.$uuid !== undefined)
				this.list.selector.select(parent.$uuid, selectParent);
		}
	},
	load: function(list) {
		this.list = list;
		this.list.$item.$alternateStyle = false;
		var $skin = this.list.$item.$treeSkin || "s-list-tree";
		this.cssNodeSelector = $skin + "-selector";
		this.cssNodeCell = $skin + "-cell";
		this.cssNode = $skin + "-node";
		this.cssNodePicker = this.cssNode + "-picker";
		this.cssNodeIcon = this.cssNode + "-icon";
		this.cssNodeDesc = this.cssNode + "-desc";
		this.cssNodeDescValue = this.cssNode + "-desc-value";
		this.cssNodeTitleCell = this.cssNode + "-title-cell";
		this.list.$isEditMode = false; // set false editMode for that that contains tree
		var $bindings = this.list.$prototype.$treeview.$bindings;
		var $datas = $bindings.$data || [];
		/*if (!$datas) {
         var $keys = Object.keys($bindings);
         for (var ii = 0, jj = $keys.length; ii < jj; ii++) {
         var $field = list.$fields[$bindings[$keys[ii]]];
         if ($field) {
         $field.$isHidden = true;
         }
         }
         }*/
		var $keys = Object.keys(list.$fields);
		this.$visibleFields = [];
		for (var ii = 0, jj = $keys.length; ii < jj; ii++) {
			var $field = list.$fields[$keys[ii]];
			$field.$isExcluded = $datas.indexOf($keys[ii]) < 0;
			if (!$field.$isHidden && !$field.$isExcluded) {
				this.$visibleFields.push($field);
			}
		}
	},
	onNodeEvent: function(record, picker, event) {
		var self = this;
		self.list.page.externalAdapter.onFieldClickPicker({
			field: record,
			pickerType: "openTreeNode",
			doEvent: function() {
				if (record && record.treeNode) {
					_openNode(self, record);
					self.list.resizeArticle(true);
				}
			}
		});
	},

	onEndFillList: function() {
		this._orderedNodes = [];
		for (var ii = 0, jj = this.tree.length; ii < jj; ii++) {
			var rootNode = this.tree[ii];
			rootNode.isOpened = true;
			_drawNodesOrder(this, null, rootNode.children, 0);
		}
	},
	appendTreeviewCol: function(slot) {
		var col = this.list.cols.$treeview = this.list.appendCol();
		col.slot = slot;
		col.isTreeviewCol = true;
		col.titleCell.className = this.cssNodeTitleCell;
		slot.appendChild(col.titleCell);
		var width;
		if (this.$visibleFields.length == 0) {
			this.hasFixWith = false;
			width = col.colWidth = "100%";
		} else {
			this.hasFixWith = true;
			width = (col.colWidth = 100) + "px";
		}
		this.list.setColWidth(col, width);
		return col;
	},
	onRecordResize: function(record) {
		if (this.hasFixWith) {
			var slot = record.treeNode && record.treeNode.item;
			if (slot) {
				var index = record.getRecordIndex();
				if (index == 0) {
					this.onResizeMaxDiff = 0;
				}
				var diff = slot.scrollWidth - slot.clientWidth;
				if (diff > this.onResizeMaxDiff) {
					this.onResizeMaxDiff = diff;
				}
				if (this.onResizeMaxDiff && index == (this.list.records.length - 1)) {
					var col = this.list.cols.$treeview;
					this.list.setColWidth(col, (col.colWidth += this.onResizeMaxDiff) + "px");
					this.onResizeMaxDiff = 0;
				}
			}
		}
	},
	appendNode: function(record, slot) {
		var treeNode = record.treeNode = {
			slot: slot,
			item: document.createElement("div")
		};
		treeNode.item.className = this.cssNode;
		treeNode.picker = syra_menus.addIconButton("", this.cssNodePicker + (this.list.$item.$isNodeLazyLoad ? " s-close" : ""), "onTreeNodeClick");
		treeNode.picker.style.display = this.list.$item.$isNodeLazyLoad ? "" : "none";
		treeNode.item.appendChild(treeNode.picker);
		if (this.list.selector.appendToRecord) {
			treeNode.selectorSlot = document.createElement("div");
			treeNode.selectorSlot.style.display = "none";
			treeNode.selectorSlot.className = this.cssNodeSelector;
			treeNode.item.appendChild(treeNode.selectorSlot);
		}
		var $bindings = this.list.$prototype.$treeview.$bindings;
		if ($bindings.$icon) {
			var name = record.dataset[$bindings.$icon];
			treeNode.icon = document.createElement("div");
			treeNode.icon.className = this.cssNodeIcon;
			treeNode.icon.style.backgroundImage = "url('" + syra_site.$item.$iconPath + "tree/" + name + "')";
			treeNode.item.appendChild(treeNode.icon);
		}
		treeNode.desc = document.createElement("div");
		treeNode.desc.className = this.cssNodeDesc;
		treeNode.descriptionField = record.page.loadNewItem(treeNode.item.appendChild(treeNode.desc), {
			$bind: $bindings.$description,
			$isCellChild: true,
			$inplace: true
		}, record);
		treeNode.descriptionField.setState({
			$isHidden: false
		});
		treeNode.descriptionField.fieldValue.className += " " + this.cssNodeDescValue;
		treeNode.slot.appendChild(treeNode.item);
	},
	appendCellNode: function(record, slot) {
		var cell = document.createElement("td");
		cell.className = this.list.gridCss.cell + " " + this.cssNodeCell;
		if (this.list.$capability && this.list.$capability.reorder) {
			cell.className += " s-tree-record-reorder";
			cell.syraDragSpot = this.list.id;
		}
		slot.appendChild(cell);
		this.appendNode(record, cell);
		return cell;
	},
	appendCardNode: function(record, slot) {
		this.appendNode(record, slot);
		return slot;
	},
	onRemoveRecord: function(record) {
		var node = this._uuidNodes[record.$uuid];
		if (node) {
			var parentNode = node.parentId && this._nodes[node.parentId];
			if (parentNode && parentNode.children) {
				var found = parentNode.children.indexOf(node);
				if (found >= 0) {
					parentNode.children.splice(found, 1);
				}
			}
			delete this._nodes[node.id];
			delete this._uuidNodes[record.$uuid];
			record.treeNode = null;
		}
	},
	applyShortCut: function(shortcuts, event) {
		if (shortcuts.pagedown || shortcuts.pageup) {
			_openAll(this, shortcuts.pagedown);
			return true;
		}
		if (shortcuts.left || shortcuts.right) {
			var record = this.list.getFocusedRecord(!this.list.$item.$isNavigationList);
			if (record) {
				var node = this._uuidNodes[record.$uuid];
				if (node.isOpened !== !! shortcuts.right) {
					record.treeNode.picker.click();
				}
				return true;
			}
		}
		if (shortcuts.up || shortcuts.down) {
			var record = this.list.getFocusedRecord(true);
			var recordIndex = 0;
			if (record) {
				this.list.toggleFocusRecord(record, false);
				recordIndex = this.getPrevNextTreeRecordVisible(record.getRecordIndex(), shortcuts.down);
			}
			var newSelect = this.list.records[recordIndex];
			newSelect && this.list.toggleFocusRecord(newSelect, true);
			return true;
		}
	},

	getPrevNextTreeRecordVisible: function(recordIndex, next) {
		var index;
		var orderedNodes = this._orderedNodes;
		for (var ii = 0, jj = orderedNodes.length; ii < jj; ii++) {
			if (orderedNodes[ii].$serverIndex == recordIndex) {
				index = ii;
				break;
			}
		}
		for (var ii = (next ? Math.min(index + 1, orderedNodes.length - 1) : Math.max(index - 1, 0)), jj = (next ? orderedNodes.length : -1);
			(next && ii < jj) || (!next && ii > jj);
			(next ? ii++ : ii--)) {
			if (this._uuidNodes[orderedNodes[ii].$uuid].isVisible) {
				return parseInt(orderedNodes[ii].$serverIndex, 10);
			}
		}
		return index;
	},
	dispose: function() {
		this._uuidNodes = this._nodes = this.tree = this.list = this.$visibleFields = this._orderedNodes = null;
	}
});