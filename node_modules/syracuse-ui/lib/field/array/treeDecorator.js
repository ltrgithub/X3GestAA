"use strict";
var helpers = require('syracuse-core/lib/helpers');

function TreeDecorator() {}

exports.TreeDecorator = helpers.defineClass(TreeDecorator, null, {
	buildTreeMap: function(dataset, partialDelta) {
		var $bindings = this.list.$prototype.$treeview.$bindings;
		if (!partialDelta) {
			this._uuidNodes = {};
			this._nodes = {};
			this.tree = [];
		}
		for (var ii = 0, jj = dataset.length; ii < jj; ii++) {
			var dataRecord = dataset[ii];
			var parentId = dataRecord[$bindings.$parent];
			var id = dataRecord[$bindings.$id] || "s-empty";
			var node;
			var isOpened;
			if (partialDelta) {
				node = this._uuidNodes[dataRecord.$uuid] || this._nodes[id];
				if (parentId === undefined && node) {
					parentId = node.parentId;
				}
				if ($bindings.$open && dataRecord[$bindings.$open] !== undefined) {
					isOpened = $bindings.$open ? (dataRecord[$bindings.$open] === true || dataRecord[$bindings.$open] === 2) : true;
				} else {
					isOpened = node ? node.isOpened : false;
				}
			} else {
				node = this._nodes[id];
				isOpened = $bindings.$open ? (dataRecord[$bindings.$open] === true || dataRecord[$bindings.$open] === 2) : true;
			}
			var appendToParent = false;
			if (node) {
				if (node.parentId == undefined) {
					var found = this.tree.indexOf(node);
					if (found >= 0) {
						this.tree.splice(found, 1);
						appendToParent = true;
					}
				} else {
					if (node.parentId != parentId) {
						var prevParent = this._nodes[node.parentId];
						if (prevParent) {
							prevParent.children.splice(prevParent.children.indexOf(node), 1);
						}
						appendToParent = true;
					}
				}
			} else {
				appendToParent = true;
				this._nodes[id] = node = {
					id: id,
					desc: dataRecord[$bindings.$description] || "",
					children: []
				};
			}
			if (appendToParent) {
				this.isWaitingReorder = true;
				var parentNode = this._nodes[parentId];
				if (!parentNode) {
					this.tree.push(parentNode = this._nodes[parentId] = {
						id: parentId,
						children: []
					});
				}
				parentNode.children.push(node);
			}
			node.$uuid = dataRecord.$uuid;
			this._uuidNodes[node.$uuid] = node;
			node.parentId = parentId;
			node.isOpened = isOpened;
		}
	},
	load: function(list) {
		this.list = list;
		this.list.$isEditMode = false; // set false editMode for that that contains tree
		var $bindings = this.list.$prototype.$treeview.$bindings;
		var $keys = Object.keys($bindings);
		for (var ii = 0, jj = $keys.length; ii < jj; ii++) {
			var $field = list.$fieldProperties[$bindings[$keys[ii]]];
			if ($field) {
				$field.$isHidden = true;
			}
		}
		var $keys = Object.keys(list.$fieldProperties);
		this.$visibleFields = [];
		for (var ii = 0, jj = $keys.length; ii < jj; ii++) {
			var $field = list.$fieldProperties[$keys[ii]];
			if (!$field.$isHidden && !$field.$isExcluded) {
				this.$visibleFields.push($field);
			}
		}
	},
	findNode: function(record) {
		return this._nodes[record.dataset[this.list.$prototype.$treeview.$bindings.$id] || "s-empty"];
	},
	onNodeEvent: function(event) {
		var self = this;
		var record = self.list.findRecord($(event.target));
		self.list.page.externalAdapter.onFieldClickPicker({
			field: record,
			pickerType: "openTreeNode",
			doEvent: function() {
				if (record && record.treeNode) {
					var node = self.findNode(record);
					node.isOpened = !node.isOpened;
					record.treeNode.picker.className = "s-list-tree-node-picker " + (node.isOpened ? "s-open" : "s-close");
					self.displayChildren(node.isOpened, node.children);
				}
			}
		});
	},
	displayChildren: function(isParentOpened, children) {
		for (var ii = 0, jj = children.length; ii < jj; ii++) {
			var node = children[ii];
			this.list.recordsMap[node.$uuid].$$item[0].style.display = (node.isVisible = isParentOpened) ? "" : "none";
			if (node.children.length) {
				this.displayChildren(node.isOpened && isParentOpened, node.children);
			}
		}
	},
	drawNodesOrder: function(parentNode, nodes, level) {
		if (nodes) {
			for (var ii = 0, jj = nodes.length; ii < jj; ii++) {
				var node = nodes[ii];
				var hasChildren = node.children.length > 0;
				var record = (node.$uuid != undefined) ? this.list.recordsMap[node.$uuid] : null;
				if (record) {
					this.list.builder._body.appendChild(record.dataRow);
					record.treeNode.level = level;
					if (this.list.selector.appendToRecord) {
						if (this.list.selector.isMulti) {
							if (!record._selectorCheck) {
								record._selectorCheck = this.list.selector.appendToRecord(record.treeNode.selectorSlot);
								record.treeNode.selectorSlot.style.display = "";
							}
						} else {
							if (hasChildren) {
								if (record._selectorCheck) {
									document.site.removeDomChild(record._selectorCheck);
									delete record._selectorCheck;
									record.treeNode.selectorSlot.style.display = "none";
								}
							} else {
								if (!record._selectorCheck) {
									record._selectorCheck = this.list.selector.appendToRecord(record.treeNode.selectorSlot);
									record.treeNode.selectorSlot.style.display = "";
								}
							}
						}
					}
					if (hasChildren) {
						record.treeNode.picker.className = "s-list-tree-node-picker " + (node.isOpened ? "s-open" : "s-close");
						record.treeNode.picker.style.display = "";
					}
					var padding = 0;
					if (parentNode) {
						node.isVisible = parentNode.isVisible && parentNode.isOpened;
						record.dataRow.style.display = node.isVisible ? "" : "none";
						if (!this.list.$item.$isNodeLazyLoad && !hasChildren && record.treeNode.icon) {
							padding = 18;
						}
					} else {
						node.isVisible = true;
					}
					record.treeNode.slot.style.paddingLeft = (record.treeNode.level * 18) + padding + "px";
				}
				if (hasChildren) {
					this.drawNodesOrder(node, node.children, level + 1);
				}
			}
		}
	},
	onEndFillList: function() {
		if (this.isWaitingReorder) {
			this.isWaitingReorder = false;
			for (var ii = 0, jj = this.tree.length; ii < jj; ii++) {
				var rootNode = this.tree[0];
				rootNode.isOpened = true;
				this.drawNodesOrder(null, rootNode.children, 0);
			}
		}
	},
	appendTreeviewCol: function(slot) {
		var col = this.list.builder.cols.$treeview = this.list.builder._appendCol();
		col.slot = slot;
		col.titleCell.className = "s-list-tree-title-cell";
		slot.appendChild(col.titleCell);
		if (this.$visibleFields.length == 0) {
			col.groupHead.style.width = col.groupBody.style.width = col.widthValue = "100%";
		} else {
			col.groupHead.style.width = col.groupBody.style.width = (col.widthValue = 200) + "px";
		}
		return col;
	},
	appendTreeviewCell: function(record, slot) {
		var cell = document.createElement("td");
		cell.className = record.builder.gridCss.cell + " s-list-tree-cell";
		if (this.list.$capability && this.list.$capability.reorder) {
			cell.className += " s-list-record-reorder";
		}
		slot.appendChild(cell);
		var treeNode = record.treeNode = {
			slot: cell,
			item: document.createElement("div")
		};
		treeNode.item.className = "s-list-tree-node";
		treeNode.picker = document.createElement("a");
		treeNode.picker.setAttribute("href", "#");
		if (this.list.$item.$isNodeLazyLoad) {
			treeNode.picker.className = "s-list-tree-node-picker s-close";
			treeNode.picker.style.display = "";
		} else {
			treeNode.picker.className = "s-list-tree-node-picker";
			treeNode.picker.style.display = "none";
		}
		treeNode.item.appendChild(treeNode.picker);
		if (this.list.selector.appendToRecord) {
			treeNode.selectorSlot = document.createElement("div");
			treeNode.selectorSlot.style.display = "none";
			treeNode.selectorSlot.className = "s-list-tree-selector";
			treeNode.item.appendChild(treeNode.selectorSlot);
		}
		var $bindings = this.list.$prototype.$treeview.$bindings;
		if ($bindings.$icon) {
			var name = record.dataset[$bindings.$icon];
			treeNode.icon = document.createElement("div");
			treeNode.icon.className = "s-list-tree-node-icon";
			treeNode.icon.style.backgroundImage = "url('" + document.site.$item.$iconPath + "tree/" + name + "')";
			treeNode.item.appendChild(treeNode.icon);
		}
		treeNode.desc = document.createElement("div");
		treeNode.desc.className = "s-list-tree-node-desc";
		treeNode.descriptionField = record.page.loadNewItem(treeNode.item.appendChild(treeNode.desc), {
			$bind: $bindings.$description,
			$isCellChild: true,
			$inplace: true
		}, record);
		treeNode.descriptionField.setState({
			$isHidden: false
		});
		treeNode.descriptionField.fieldValue.className += " s-list-tree-node-desc-value";
		treeNode.slot.appendChild(treeNode.item);
		return cell;
	},

	highlightSelection: function(selected) {
		if (this.list.$item.$isTreeSelectionVisible) {

		}
	},
	onRemoveRecord: function() {
		/* previous code implementation
         if (this.parentNode && this.parentNode.children) {
         for (var ii = 0, jj = this.parentNode.children.length; ii < jj; ii++) {
         if (this.parentNode.children[ii] == this) {
         this.parentNode.children.splice(ii, 1);
         break;
         }
         }
         }
         if (this.children) {
         for (var ii = 0, jj = this.children.length; ii < jj; ii++) {
         delete this.children[ii].parentNode;
         }
         }
         if (this.nodes) {
         delete this.nodes[this.id];
         }
         if (this.record) {
         this.record.treeNode = null;
         }
         this.dispose();
         */
	},
	dispose: function() {
		this._uuidNodes = this._nodes = this.tree = this.list = this.$visibleFields = null;
	}
});