"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var parser = require('syracuse-sdata/lib/parser/parser');

var _recordSelectors = {
	multi: require('./selector/multiRecordSelector').MultiRecordSelector,
	single: require('./selector/singleRecordSelector').SingleRecordSelector,
	button: require('./selector/buttonRecordSelector').ButtonRecordSelector,
	row: require('./selector/rowRecordSelector').RowRecordSelector
};

function _disableAdd(list, isAddDisabled) {
	list._isAddDisabled = isAddDisabled;
	if (list.menuItems) {
		if (list.menuItems.$create) {
			list.menuItems.$create[0].disable(list._isAddDisabled);
		}
		if (list.menuItems.$select) {
			list.menuItems.$select[0].disable(list._isAddDisabled);
		}
	}
	if (list.$capability.insert) {
		for (var ii = 0, jj = list.records.length; ii < jj; ii++) {
			var record = list.records[ii];
			if (record.menuItems.$create) {
				record.menuItems.$create[0].disable(list._isAddDisabled);
			}
		}
	}
}

function _validateDisplay(list) {
	//ensureRecordsIndex
	for (var ii = 0, jj = list.records.length; ii < jj; ii++) {
		var record = list.records[ii];
		record.$recordIndex = ii;
		if (record.dataset.$index !== undefined) {
			record.dataset.$index = ii;
		}
		if (record.dataset.$serverIndex == undefined) {
			if (record._singleField) {
				record.dataset.$serverIndex = ii;
			} else {
				for (var mm = 0, kk = list.dataset.length; mm < kk; mm++) {
					if (list.dataset[mm] == record.dataset) {
						record.dataset.$serverIndex = mm;
						break;
					}
				}
			}
		}
		record.$serverIndex = record.dataset.$serverIndex;
		record.renderRowIndex();
	}
	//_checkMaxItems
	if (list.$isEditMode) {
		if (list.$prototype.$minItems) {
			while (list.records.length < list.$prototype.$minItems) {
				_appendRecord(list, {
					$recordIndex: list.records.length,
					dataRecord: {}
				});
			}
		}
		if (list.$prototype.$maxItems) {
			if (list._isAddDisabled !== (list.$prototype.$maxItems <= list.dataset.length)) {
				_disableAdd(list, !list._isAddDisabled);
			}
		}
	}
}

exports.findRecordByServerIndex = function(list, $serverIndex) {
	for (var ii = 0, jj = list.records.length; ii < jj; ii++) {
		if (list.records[ii].$serverIndex == $serverIndex) {
			return list.records[ii];
		}
	}
	return null;
};

exports.findDataRecord = function(list, $uuid) {
	var found;
	if (list.dataset) {
		for (var ii = 0, jj = list.dataset.length; ii < jj; ii++) {
			var dataRecord = list.dataset[ii];
			if (dataRecord && dataRecord.$uuid == $uuid) {
				found = {
					dataRecord: dataRecord,
					dataRecordIndex: ii
				};
				break;
			}
		}
	}
	return found;
};

function _appendRecord(list, options) {
	if (list.emptyDataItem) {
		document.site.emptyDom(list.emptyDataItem);
		list.emptyDataItem = null;
	}
	if (list.builder.isSingleBuilder) {
		options.dataRecord = {
			$singleField: options.dataRecord
		};
		options.$prototype = {
			$properties: {
				$singleField: list.$prototype.$item
			}
		};
	}
	if (options.dataRecord.$uuid === undefined) {
		options.dataRecord.$uuid = options.$recordIndex;
	}
	var record = (list.recordsMap[options.dataRecord.$uuid] = new list.builder.RecordClass());
	record.arrayLevel = "record";
	record.$uuid = options.dataRecord.$uuid;
	if (options.dataRecord) {
		record.dataset = options.dataRecord;
		record.$serverIndex = options.dataRecord.$serverIndex;
	}
	//record.$serverIndex = options.$serverIndex;
	record.$recordIndex = options.$recordIndex;
	record.$facet = list.$recordFacet;
	record.$isEditMode = list.$isEditMode && !list.treeList;
	record.builder = (record.list = list).builder;
	record.$prototype = options.$prototype || list.$prototype.$item;
	record.isInsert = options.isInsert;
	if (record.initializeRecord) {
		record.initializeRecord(options);
	}
	list.page.initializeNewItem(record, options.$item || {}, list);
	record.loadBox();
	if (options.isCreate && record.onCreated) {
		record.onCreated();
	}
	record.applyChange(list.ensureGlobalMetaRecord());
	if (options.dataRecord) {
		record.applyChange(options.dataRecord);
	}
	if (options.isInsert) {
		list.records.splice(options.$recordIndex, 0, record);
	} else {
		list.records.push(record);
	}
	return record;
};

exports.doSelectAction = function(list) {
	if (list.$prototype.$item.$type == "application/x-choice") {
		list.builder.loadChoiceSelector();
	} else {
		list.currentSelectRecords = null;
		list.boxParent.openDialog({
			article: list,
			$url: list.menuItems.$select[0].$sourceUrl,
			onValidate: function() {
				exports.notifySelectRecords(list);
			},
			onSelectRecord: function(selectedRecords) {
				list.currentSelectRecords = selectedRecords;
				return false;
			}
		});
	}
};

exports.loadSelector = function(list) {
	if (list.selector) {
		document.controller.disposeObject(list.selector);
	}
	var selectorClass = _recordSelectors[list.$item.$selectMode];
	if (selectorClass) {
		(list.selector = new selectorClass()).load(list);
	} else {
		list.selector = {};
	}
};

/************************************* Client Fetching **********************************************/
exports.fetchClientRecordSet = function(list, options) {
	if (options && options.params) {
		var $orderBy;
		var resource = {
			dataRecordSet: list.ensureDataSet()
		};
		if (options.params.orderBy !== undefined) {
			if (options.params.orderBy === null) {
				$orderBy = null;
				list.sortCapability.resetSort();
				delete list.sortCapability._$orderBy;
			} else {
				$orderBy = list.sortCapability.parse(options.params.orderBy);
				if (options.params.startLetter) {
					list.sortCapability.filterByStartLetter(resource, {
						binding: $orderBy[0].binding,
						startLetter: options.params.startLetter
					});
				}
			}
			list.sortCapability.syracuseSort(resource, $orderBy);
		}
		if (options.params.where) {
			var exp = parser.Parser.parse(options.params.where);
			var filterDataSet = [];
			for (var ii = 0, jj = resource.dataRecordSet.length; ii < jj; ii++) {
				var record = resource.dataRecordSet[ii];
				var ok = false;
				// quick workaround ($title). to improve for generic cases
				var ff = record[exp.children[0].value];
				if (typeof(ff) == "object") {
					ok = ff.$title.search(new RegExp(exp.children[1].value.replace("%", "", "g"), "i")) >= 0;
				} else {
					if (typeof(exp.children[1].value) == "string") {
						ok = ff.search(new RegExp(exp.children[1].value.replace("%", "", "g"), "i")) >= 0;
					} else {
						// case of integer (application/x-choice)
						ok = typeof(ff) == "number" && typeof(exp.children[1].value) && ff == exp.children[1].value;
					}
				}
				if (ok) {
					filterDataSet.push(record);
				}
			}
			resource.dataRecordSet = filterDataSet;
		}
		if (options.params.count || options.params.startIndex) {
			list.pagging.goToClientPage({
				dataRecordSet: resource.dataRecordSet,
				$itemsPerPage: options.params.count,
				$startIndex: options.params.startIndex
			});
		}
		list.onClientFetch = true;
		exports.fillList(list, resource.dataRecordSet, list.articleParent.dataset);
		list.onClientFetch = false;
	}
};

/************************************* Delta Management **********************************************/
exports.fillList = function(list, dataRecordSet, parentDataRecord, isDelta) {
	if (list.isClientFetch && list.pagging) {
		//reset clientTotal result 
		delete list.pagging.clientTotalRecords;
	}
	list.applyCapabilitiesSettings(parentDataRecord);
	if (isDelta) {
		var firstIndex, lastIndex;
		if (list.pagging) {
			firstIndex = list.pagging.$startIndex;
			if (firstIndex !== undefined) {
				--firstIndex;
				if (list.pagging.$itemsPerPage !== undefined) {
					lastIndex = firstIndex + list.pagging.$itemsPerPage;
				}
			}
		}
		if (list.page.$isPartialDelta || (dataRecordSet.length == 1 && dataRecordSet[0].$index !== undefined)) {
			if (list.treeList) {
				list.treeList.buildTreeMap(dataRecordSet, true);
			}
			list.applyPartialDelta(dataRecordSet, firstIndex, lastIndex);
		} else {
			if (list.treeList) {
				list.treeList.buildTreeMap(dataRecordSet);
			}
			_applyFullDelta(list, dataRecordSet, firstIndex, lastIndex);
		}
		if (lastIndex) {
			if (list.records.length > list.pagging.$itemsPerPage) {
				while (list.records.length > list.pagging.$itemsPerPage) {
					var record = list.records[list.records.length - 1];
					delete list.recordsMap[record.$uuid];
					list.removeRecord(record, true);
					list.records.pop();
				}
			}
			if (list.isClientFetch && (list.dataset.length <= firstIndex || (list.records.length < list.pagging.$itemsPerPage && list.records.length < (list.dataset.length - firstIndex)))) {
				list.pagging.setPage(0);
			}
		}
	} else {
		if (!list.onClientFetch && !list.isClientFetch) {
			list.clientDataset = null;
		}
		if (list.treeList) {
			list.treeList.buildTreeMap(dataRecordSet);
		}
		list.builder._body.style.display = "none";
		list.removeRecords(!(dataRecordSet && dataRecordSet.length > 0));
		var dataSource = list.ensureDataSet();
		if (dataRecordSet) {
			var $startIndex = 1;
			var $itemsPerPage = list.pagging.$itemsPerPage || dataRecordSet.length;
			if (list.onClientFetch) {
				list.clientDataset = dataSource = dataRecordSet;
			}
			//warn: list.onClientFetch =true and list.isClientFetch=false for convergence left list 
			if (list.isClientFetch && list.pagging) {
				list.pagging.ensureItemsPerPage();
				if (list.onClientFetch) {
					list.pagging.clientTotalRecords = dataRecordSet.length;
					$startIndex = list.pagging.$startIndex;
					$itemsPerPage = list.pagging.$itemsPerPage;
				} else {
					if (dataRecordSet.length > list.pagging.$itemsPerPage) {
						var options = list.pagging.goToClientPage();
						$startIndex = options.$startIndex;
						$itemsPerPage = options.$itemsPerPage;
					}
				}

			}
			for (var ii = $startIndex - 1, count = 0, jj = dataRecordSet.length;
			(count < $itemsPerPage) && (ii < jj); count++, ii++) {
				var dataRecord = dataRecordSet[ii];
				if (!dataRecord.$isDeleted) {
					var dataSourceRecord = dataSource[ii];
					_appendRecord(list, {
						dataRecord: dataSourceRecord,
						$recordIndex: count
					});
				}
			}
		}
	}
	_validateDisplay(list);

	if (list.$item.$cards && list.$item.$format != "cards") {
		if (list.$item.$cards.$position != "inline" && list.$item.$cards.$position != "popup") {
			list.selector.select(); //ensure selection
		}
	}

	if (list.treeList) {
		list.treeList.onEndFillList();
	}
	list.pagging.draw();
	list.sortCapability.renderOrderBy();
	/*if (list.builder._bodySlot) {
     list.builder._bodySlot.style.visibility = "hidden";
     }*/
	list.builder._body.style.display = "";
	list.onWindowResize();
	/* if (list.builder._bodySlot) {
     list.builder._bodySlot.style.visibility = "visible";
     }*/
};
exports.applyPartialDelta = function(list, dataRecordSet, firstIndex, lastIndex) {
	var found, foundIndex;
	for (var $serverIndex = 0, jj = dataRecordSet.length; $serverIndex < jj; $serverIndex++) {
		var dataSourceRecord = dataRecordSet[$serverIndex];
		found = null;
		foundIndex = 0;
		for (var mm = list.records.length; foundIndex < mm; foundIndex++) {
			found = list.records[foundIndex];
			if (found.$uuid == dataSourceRecord.$uuid) {
				break;
			} else {
				found = null;
			}
		}
		if (found) {
			if (dataSourceRecord.$isDeleted) {
				list.records.splice(foundIndex, 1);
				delete list.recordsMap[found.$uuid];
				list.removeRecord(found, true);
			} else {
				var recordIndex = foundIndex;
				if (dataSourceRecord.$index !== undefined) {
					recordIndex = dataSourceRecord.$index;
					if (firstIndex !== undefined) {
						recordIndex -= firstIndex;
					}
				}
				if (recordIndex != foundIndex) {
					delete found.dataset;
				}
				found.ensureDataSet(found.$uuid);
				found.applyChange(dataSourceRecord);
				if (dataSourceRecord.$index !== undefined && dataSourceRecord.$index != foundIndex) {
					list.records.splice(foundIndex, 1);
					list.records.splice(recordIndex, 0, found);
					var nextRecord;
					if ((recordIndex + 1) < list.records.length) {
						nextRecord = list.records[recordIndex + 1];
					}
					found.notifyReorder(nextRecord, nextRecord ? "insertBefore" : "append");
				}
			}
		} else {
			if (!dataSourceRecord.$isDeleted) {
				var index = dataSourceRecord.$index !== null && dataSourceRecord.$index !== undefined ? dataSourceRecord.$index : $serverIndex;
				if (firstIndex !== undefined) {
					if ((index < firstIndex) || (lastIndex != undefined && index >= lastIndex)) {
						index = -1;
					} else {
						index -= firstIndex;
					}
				}
				if (index != -1) {
					_appendRecord(list, {
						dataRecord: list.dataset[dataSourceRecord.$index],
						$recordIndex: index, //dataSourceRecord.$index,
						isInsert: true
					});
				}
			}
		}
	}
};

function _applyFullDelta(list, dataRecordSet, firstIndex, lastIndex) {
	var oldMap = list.recordsMap;
	list.recordsMap = {};
	list.records = [];
	var lastRecord;
	for (var $serverIndex = 0, jj = dataRecordSet.length; $serverIndex < jj; $serverIndex++) {
		var dataRecord = dataRecordSet[$serverIndex];
		var record = oldMap[dataRecord.$uuid];
		if (record) { //Aurelien
			record.applyChange(dataRecord);
			if (record.$serverIndex != $serverIndex) {
				if (lastRecord) {
					record.notifyReorder(lastRecord, "insertAfter");
				} else {
					record.notifyReorder(null, "prepend");
				}
				record.$recordIndex = record.$serverIndex = $serverIndex;
				record.ensureDataSet();
			}
			list.records.push(list.recordsMap[dataRecord.$uuid] = lastRecord = record);
		} else {
			//var index = dataRecord.$index || $serverIndex;
			if (!(firstIndex !== undefined && ($serverIndex < firstIndex || (lastIndex != undefined && $serverIndex >= lastIndex)))) {
				record = _appendRecord(list, {
					dataRecord: list.dataset[$serverIndex],
					$recordIndex: $serverIndex,
					isInsert: true
				});
				list.recordsMap[dataRecord.$uuid] = lastRecord = record;
			}
		}
		delete oldMap[dataRecord.$uuid];
	}
	var uiids = Object.keys(oldMap);
	for (var ii = 0, jj = uiids.length; ii < jj; ii++) {
		list.removeRecord(oldMap[uiids[ii]], true);
		delete oldMap[uiids[ii]];
	}
}

//$recordIndex
/************************************* Notify Change **********************************************/
exports.notifyReorderRecords = function(list, sourceRecord, targetRecord, $insert) {
	var dataRecords = list.ensureDataSet();
	var dataRecord = dataRecords[sourceRecord.dataset.$serverIndex];

	dataRecords.splice(sourceRecord.dataset.$serverIndex, 1);
	list.records.splice(sourceRecord.$recordIndex, 1);
	if (targetRecord.$recordIndex > sourceRecord.$recordIndex) {
		sourceRecord.$recordIndex = ($insert == "insertAfter") ? targetRecord.$recordIndex : (targetRecord.$recordIndex - 2);
	} else {
		sourceRecord.$recordIndex = ($insert == "insertAfter") ? targetRecord.$recordIndex + 1 : (targetRecord.$recordIndex);
	}
	if (targetRecord.dataset.$serverIndex > sourceRecord.dataset.$serverIndex) {
		sourceRecord.dataset.$serverIndex = ($insert == "insertAfter") ? targetRecord.dataset.$serverIndex : (targetRecord.dataset.$serverIndex - 2);
	} else {
		sourceRecord.dataset.$serverIndex = ($insert == "insertAfter") ? targetRecord.dataset.$serverIndex + 1 : (targetRecord.dataset.$serverIndex);
	}
	sourceRecord.$recordIndex = Math.max(sourceRecord.$recordIndex, 0);
	sourceRecord.dataset.$serverIndex = Math.max(sourceRecord.dataset.$serverIndex, 0);
	dataRecords.splice(sourceRecord.dataset.$serverIndex, 0, dataRecord);
	list.records.splice(sourceRecord.$recordIndex, 0, sourceRecord);
	sourceRecord.notifyReorder(targetRecord, $insert);
	for (var ii = 0, jj = dataRecords.length; ii < jj; ii++) {
		dataRecords[ii].$serverIndex = ii;
	}
	for (var ii = 0, jj = list.records.length; ii < jj; ii++) {
		list.records[ii].$recordIndex = ii;
	}
	_validateDisplay(list);

	var sendBag = list.page.ensureSendBag(list);
	if (list.builder.isSingleBuilder) {
		sendBag.dataRecords = dataRecords;
	} else {
		sendBag.reorderRecord(sourceRecord, targetRecord);
	}
	list.page.notifyDataChange(list, sendBag.dataRecords);
};

exports.notifyDeleteRecord = function(list, record) {
	var sendBag = list.page.ensureSendBag(list);
	var dataRecords = list.ensureDataSet();
	if (record) {
		list.records.splice(record.$recordIndex, 1);
		if (list.builder.isSingleBuilder) {
			dataRecords.splice(record.$recordIndex, 1);
			sendBag.dataRecords = dataRecords;
		} else {
			var found = exports.findDataRecord(list, record.$uuid);
			if (found) {
				dataRecords.splice(found.dataRecordIndex, 1);
				record.$index = found.dataRecordIndex;
			}
			sendBag.deleteRecord(record);
			delete record.$index;
		}
		delete list.recordsMap[record.$uuid];
		list.removeRecord(record, true);
	} else {
		dataRecords.splice(0, dataRecords.length);
		sendBag.dataRecords = [];
		list.removeRecords();
	}
	_validateDisplay(list);

	if (list.records.length == 0) {
		list.builder.emptyBody(true);
	}
	list.page.notifyDataChange(list, sendBag.dataRecords);
};

exports.notifyCreateRecord = function(list, record) {
	var sendBag = list.page.ensureSendBag(list);
	var dataRecords = list.ensureDataSet();
	var options = {
		isCreate: true
	};
	if (record) {
		options.$serverIndex = record.$serverIndex;
		options.$recordIndex = record.$recordIndex;
		options.isInsert = true;
	} else {
		if (list.records.length > 0) {
			options.$serverIndex = list.records[list.records.length - 1].$serverIndex + 1;
		} else {
			options.$serverIndex = 0;
		}
		options.$recordIndex = list.records.length;
	}
	if (list.builder.isSingleBuilder) {
		(sendBag.dataRecords = dataRecords).splice(options.$recordIndex, 0, null);
		_appendRecord(list, options);
		_validateDisplay(list);
		//_disableAdd(list, true);
	} else {
		options.dataRecord = {
			$uuid: helpers.uuid.generate()
		};
		if (record) {
			var found = exports.findDataRecord(list, record.$uuid);
			dataRecords.splice(found.dataRecordIndex, 0, options.dataRecord);
		} else {
			dataRecords.splice(options.$serverIndex, 0, options.dataRecord);
		}
		var newRecord = _appendRecord(list, options);
		sendBag.createRecord(newRecord, options.$recordIndex);
		_validateDisplay(list);
		list.page.notifyDataChange(list, sendBag.dataRecords);
	}
};

exports.notifySelectRecords = function(list) {
	if (list.currentSelectRecords) {
		var sendBag = list.page.ensureSendBag(list);
		var dataRecords = list.ensureDataSet();
		if (list.builder.isSingleBuilder) {
			sendBag.dataRecords = dataRecords;
			var $uuids = Object.keys(list.currentSelectRecords);
			for (var ii = 0, jj = $uuids.length; ii < jj; ii++) {
				var options = {
					isCreate: true,
					dataRecord: list.currentSelectRecords[$uuids[ii]].dataset,
					$recordIndex: list.records.length
				};
				switch (list.$prototype.$item.$type) {
					case "application/x-choice":
						options.dataRecord = options.dataRecord.$uuid;
						break;
					case "application/x-reference":
						delete options.dataRecord.$serverIndex;
						delete options.dataRecord.$isSelected;
						break;
				}
				dataRecords.push(options.dataRecord);
				_appendRecord(list, options);
			}
		}
		_validateDisplay(list);
		list.page.notifyDataChange(list, sendBag.dataRecords);
	}
};





function _getDisplayValueInput(inputField) {
	var found = "";
	if (inputField.$enum) { // not a string 
		for (var i = 0; i < inputField.$enum.length; i++) {
			if (inputField.$enum[i].$value === inputField.currentValue) {
				found = inputField.$enum[i].$title;
				break;
			}
		}
	} else {
		if (typeof inputField.currentValue === "object") {
			// not a simple string 
			found = inputField.currentValue.$value + " " + inputField.currentValue.$title;
		} else if (typeof inputField.currentValue === "string") {
			found = inputField.currentValue;
		}
	}
	return found;
}

function getWidthOfInput_old(inputEl) {
	var tmp = document.createElement("span");
	tmp.className = "input-element tmp-element";
	var value = _getDisplayValueInput(inputEl);
	tmp.innerHTML = value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	div.appendChild(tmp);
	var width = (tmp.scrollWidth !== 0 ? tmp.scrollWidth : tmp.offsetWidth) + 20;
	width = width < 30 ? 30 : width;
	width += inputEl.boxPickers ? inputEl.boxPickers.clientWidth : 0;
	width += inputEl.menusBox ? inputEl.menusBox.$$item[0].clientWidth : 0;
	return width;
}

function getWidthOfInput(inputEl, div) {
	var value = _getDisplayValueInput(inputEl);
	div.innerHTML = value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	// var width = div.clientWidth  + 20;;
	var width = (div.scrollWidth !== 0 ? div.scrollWidth : div.offsetWidth) + 20;
	width = width < 30 ? 30 : width;
	width += inputEl.boxPickers ? inputEl.boxPickers.clientWidth : 0;
	width += (inputEl.menusBox && !inputEl.boxPickers) ? inputEl.menusBox.$$item[0].clientWidth + 2 : (inputEl.menusBox && inputEl.boxPickers) ? 2 : 0;
	div.innerHTML = "";
	return width;
}

exports.fitToWidth = function(list) {
	var isFusion = document.site.mainPage && document.site.mainPage.$pageCategory === "fusion";
	var div = document.createElement("div");
	div.style.display = "inline-block";
	div.style.width = "auto";
	if (list.records && list.records.length) {
		var first = list.records[0];
		var s = first.menusBags && first.menusBags.length > 0 ? first.menusBags[0].$$item[0].clientWidth : 0;
		var currentSize = s;
		if (first.menuItems) {
			var item = Object.keys(first.menuItems);
			for (var j = 0; j < item.length; j++) {
				s = first.menuItems && first.menuItems.length > 0 ? first.menuItems[item[j]][0].$$item[0].clientWidth : 0;
				currentSize += s;
			}
		}
		var colSize = {};
		if (currentSize) {
			colSize['$menusBox'] = isFusion ? currentSize : currentSize / 2;
		}
		document.body.appendChild(div);
		for (var i = 0; i < list.records.length; i++) {
			// get all field and 

			var record = list.records[i];
			// calcul for menusBags 
			var keys = Object.keys(record.idMap);
			for (var j = 0; j < keys.length; j++) {

				var item = record.idMap[keys[j]];
				if (item instanceof Field) {
					if (colSize[item.$item.$bind]) {
						// get the max
						colSize[item.$item.$bind] = Math.max(getWidthOfInput(item, div), colSize[item.$item.$bind]);
					} else colSize[item.$item.$bind] = getWidthOfInput(item, div);
				} else {
					if (!colSize[item.$item.$bind]) colSize[item.$item.$bind] = -1; // not change size 
				}
			}
		}
		document.body.removeChild(div);
		// check if we need to apply fit to width
		var colKey = Object.keys(list.builder.cols);
		var isSame = true;
		if (Object.keys(list.builder.prevCols).length != 0) {
			for (var i = 0; i < colKey.length && isSame; i++) {
				if (colSize[colKey[i]] && list.builder.cols[colKey[i]]) {
					isSame = colSize[colKey[i]] === list.builder.cols[colKey[i]].widthValue;
				}
			}
		} else {
			isSame = false; // not same 
		}

		//
		// parcours colsgroupe for header and body and resize 
		for (var i = 0; i < colKey.length; i++) {
			var size;
			if (isSame) {
				if (list.builder.prevCols[colKey[i]]) {
					size = list.builder.prevCols[colKey[i]].widthValue; // affect last value 
				}
			} else {
				size = colSize[colKey[i]];
			}
			if (list.builder.cols[colKey[i]] && colSize[colKey[i]] !== -1 && size) {
				list.builder.cols[colKey[i]].groupHead.style.width = size + "px";
				list.builder.cols[colKey[i]].groupBody.style.width = size + "px";
				if (!isSame) { // if we apply redim to width we need to save old value
					list.builder.prevCols[colKey[i]] = {
						widthValue: list.builder.cols[colKey[i]].widthValue, // save prev value before apply fit to Width
					};
				}
				list.builder.cols[colKey[i]].widthValue = size;
				list.builder.cols[colKey[i]].realWidth = size;
			}
		}
		list.builder.onWindowResize();
	}
};


exports.ensureIsQuickFilter = function(list) {
	var isFilterCapability;
	var $binds = Object.keys(list.$fieldProperties);
	for (var ii = 0, jj = $binds.length; ii < jj; ii++) {
		var $field = list.$fieldProperties[$binds[ii]];
		if (!$field.$isExcluded && $field.$capabilities && ($field.$capabilities.indexOf("filter") >= 0)) {
			isFilterCapability = true;
			break;
		}
	}
	if ((!isFilterCapability && list.$item.$isQuickFilter) || (isFilterCapability && list.$item.$isQuickFilter === undefined)) {
		list.$item.$isQuickFilter = isFilterCapability;
	}
};