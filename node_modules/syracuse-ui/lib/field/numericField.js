"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var _formatApi = require('syracuse-ui/lib/field/formatApi');

function decimalParser(decimalSep, groupSep, groupSize) {
	decimalSep = decimalSep || '.';
	groupSep = groupSep || ',';
	groupSize = groupSize || 3;
	if (groupSep !== '.' && groupSep !== ',' && (decimalSep === '.' || decimalSep === ','))
		decimalSep = '[.,]';
	else
		decimalSep = "\\" + decimalSep;
	var re = new RegExp("^\\s*([+-]?\\d*(?:\\" + groupSep + "\\d{" + groupSize + "})*)" + decimalSep + "?(\\d*)\\s*$");
	return function(str) {
		var match = re.exec(str);
		if (!match)
			throw new Error(syra_local.nfInvalidNumber + " : " + str);
		return parseFloat(match[1].replace(/[^\d\-]/g, '') + '.' + match[2]);
	};
}

function formatInput(field, val) {
	var numFormatObj = field.numFormatObj;
	var parser = decimalParser(numFormatObj.decimalSeparator, numFormatObj.groupSeparator, numFormatObj.groupSize);
	// formatting
	return field.formatApi.format(field.formatApi.parse(parser(val, field)), ensureUnitFieldFormat(field));
}

function _ensureUnitField(field) {
	var unitArticle = field.articleParent;
	var $unit = field.$field.$unit;
	var $unitBind;
	if (typeof($unit) == "string") {
		// By default unit descriptor is 'inlined' and set as object, else unit can be at different level and shared by other fields
		while (unitArticle) {
			if (!(unitArticle.$prototype && unitArticle.$prototype.$properties && unitArticle.$prototype.$properties[$unit])) {
				unitArticle = unitArticle.articleParent;
			} else {
				$unit = unitArticle.$prototype.$properties[$unit];
				break;
			}
		}
		$unitBind = field.$field.$unit;
	} else {
		$unitBind = "$unit";
	}
	if ($unit && $unit.$type) {
		field.unitFieldSlot = document.createElement("label");
		field.unitFieldSlot.className = field.$isEditMode ? "s-quantity-unit-edit" : "s-quantity-unit";
		field.unitField = field.page.loadNewItem(field.unitFieldSlot, {
			$bind: $unitBind,
			$field: $unit,
			$inplace: true,
			$isUnitField: true,
			$isQuantityEditable: field.$isEditMode,
			//$inplace: field.$item.$inplace,
			$isDiagnoseInline: true,
			$skinInput: field.$skinInput,
			$isTitleHidden: true,
			$isEditMode: false,
			$format: $unit.$type == 'application/x-choice' ? "$combo" : ""
		}, field.articleParent);
		if (unitArticle != field.articleParent) {
			field.unitField.setDataBind(unitArticle.dataset[field.unitField.$item.$bind], unitArticle.dataset, null, field.unitField.$item.$bind);
		}
		field.inputId && field.unitFieldSlot.setAttribute("for", field.inputId);

	}
}

function ensureUnitFieldFormat(field) {
	if (field.unitField) {
		//check format
		var unitValue = field.unitField.currentValue;
		if (unitValue) {
			if (unitValue.$format) {
				if (unitValue.$format != field.localFormat) {
					field.localFormat = unitValue.$format;
				}
			} else {
				if (unitValue.$scale != undefined && field.$numeric.$scale != unitValue.$scale) {
					var parts = field.localFormat.split(".");
					var decPart = parts[1] || "0";
					if (decPart && decPart.length != unitValue.$scale) {
						if (unitValue.$scale == 0) {
							field.localFormat = parts[0];
						} else {
							if (unitValue.$scale > decPart.length) {
								var chr = decPart[decPart.length - 1];
								for (var ii = decPart.length; ii < unitValue.$scale; ii++) {
									decPart += chr;
								}
							} else {
								decPart = decPart.substr(0, unitValue.$scale);
							}
							parts[1] = decPart;
							field.localFormat = parts.join(".");
						}
					}
				}
			}
		}
	}
	return field.localFormat;
}

function NumericField() {}

exports.NumericField = helpers.defineClass(NumericField, Field, {
	ensureEditMode: function() {
		if (this.$field.$mode == "progress") {
			this.$isEditMode = false;
			this.isProgressMode = true;
		} else {
			Field.prototype.ensureEditMode.call(this);
		}
	},
	format: function(val, format) {
		return this.formatApi.format(val, format);
	},
	initialize: function() {
		this.$numeric = this.$field;
		if (this.$numeric.$type == "application/x-quantity") {
			this.$numeric = this.$numeric.$value;
			this.$isQuantityField = true;
		} else {
			this.isInteger = this.$numeric.$type == "application/x-integer";
		}
		this.$cssFieldType = "s-number";
		if (!this.formatApi) {
			this.formatApi = _formatApi.getApi(this.$numeric.$type);
			this.numFormatObj = _formatApi.getLocale().getNumberFormatObj(this.$numeric.$type);
			this.localFormat = this.$numeric.$format || this.numFormatObj.numFormat;
			this._formatInput = formatInput;
			this._checkSep = true;
		}
	},
	validateKeyPress: function(charCode, event, shortCut) {
		var validated = true;
		if (event.keyCode != 13) { //13=enter
			validated = (charCode >= "0" && charCode <= "9") || (shortCut && shortCut.ctrl && charCode >= "A" && charCode <= "z");
			validated = validated || charCode == "-" || charCode == "+" || charCode == this.numFormatObj.groupSeparator;
			validated = validated || charCode == (this.isInteger ? '' : ".");
			validated = validated || charCode == (this.isInteger ? '' : ",");
			syra_dom.toggleClass(this.input, 's-field-input-error', !validated);
		}
		return validated;
	},
	onInputFocusin: function(input, event) {
		syra_dom.toggleClass(input, 's-field-input-error', false);
		var gs = this.numFormatObj.groupSeparator;
		var gsRegExp = gs == " " ? /\s/g : new RegExp("[" + gs + "]", "g");
		var editVal = (input.value || "").split(gsRegExp).join('');
		var numVal = this.formatApi.parse(editVal, ensureUnitFieldFormat(this));
		if (numVal.numberValue) {
			numVal = numVal.numberValue();
		}
		if (numVal == 0) {
			editVal = 0;
		}
		input.value = editVal;
		Field.prototype.onInputFocusin.call(this, input, event);
	},
	onInputFocusout: function(input, event) {
		if (this._checkSep && !this.valHasChanged) {
			var ds = this.numFormatObj.decimalSeparator;
			var value = input.value || "";
			if (!(value === "" && this.$item.$isFilterMode)) {
				var rawNum = ds != '.' ? value.replace(new RegExp("[" + ds + "]"), '.') : value;
				var numObj = this.formatApi.parse(rawNum);
				// displaying formatted num
				input.value = this.formatApi.format(numObj, ensureUnitFieldFormat(this));
			}
		} else {
			this.valHasChanged = false;
		}
		Field.prototype.onInputFocusout.call(this, input, event);
	},
	render: function() {
		var renderDone;
		if (this.$isEditMode) {
			this.input = syra_dom.addInput((this.isInteger && syra_site.isTabletDevice) ? "number" : undefined);
			this.input.className = this.$skinInput + " " + this.$skinInput + "-num";
			this._dataValue.appendChild(this.input);
			renderDone = true;
		} else {
			if (this.isProgressMode) {
				this._core.className = "s-progress";
				this._dataValue.className = "s-progress-value";
			}
		}
		if (this.$isQuantityField && !this.$item.$isFilterMode && !this.articleParent.isFilterArticle) {
			_ensureUnitField(this);
		}
		return renderDone;
	},
	loadBox: function() {
		Field.prototype.loadBox.call(this);
		//ensure default display value
		if (!this.isProgressMode && !this.$item.$isFilterMode) {
			this._setDefaultDisplayText();
			if (this.displayText == "0") {
				if (this.$isEditMode) {
					this.setInputValue(this.displayText);
				} else {
					this._dataValue.textContent = this.displayText;
				}
			}
		}
	},
	_setDefaultDisplayText: function() {
		// We don't force anything for field using X3 legacy Format in classic/web page (default value is managed by format - static or sent at runtime)
		var isX3FormattedField = this.page && this.page.isFusionPage || this.$field && this.$field.$X3Fmt;
		this.displayText = "";
		if (!isX3FormattedField && !this.$item.$isFilterMode) {
			this.displayText = "0";
		}
	},
	setDataValue: function(value) {
		if (this.isProgressMode) {
			this._dataValue.style.width = ((this._core.clientWidth * value) / 100) + "px";
		} else {
			this._setDefaultDisplayText();
			this.currentValue = value;
			if (value) {
				// building formatted value
				var numObj = this.formatApi.parse(value);
				this.displayText = this.formatApi.format(numObj, ensureUnitFieldFormat(this));
			}
			if (this.$isEditMode) {
				this.setInputValue(this.displayText);
				this.unitFieldSlot && this.input.parentNode.insertBefore(this.unitFieldSlot, this.input.nextSibling);
			} else {
				if (this.displayText && !this.$isDetailLinkDisabled && this.$menus && this.$menus.$details) {
					syra_fields.addDetailLink(this, this.displayText, this.$menus.$details);
				} else {
					this._dataValue.textContent = this.displayText;
				}
				this.unitFieldSlot && this._dataValue.appendChild(this.unitFieldSlot);
				syra_menus.pickers.menus.show(this);
			}
		}
	},
	getDisplayText: function() {
		var text = this.unitField ? this.unitField.getDisplayText() : "";
		return (this.displayText || "") + text;
	},
	getDataValue: function() {
		if (this.input) {
			var value = this.getInputValue();
			if (value === "" && this.$item.$isFilterMode) {
				return value;
			}
			return this.formatApi.parse(value, ensureUnitFieldFormat(this)).toString();
		}
		return this.currentValue;
	},
	setFieldWidth: function() {
		if (this.$isQuantityField) {
			if (this.$isEditMode && !this.hasFreeWidth && !this.getTextRows() && !this.$item.$inplace && this._dataValue && !this.$item.$isAutoSizeDisabled) {
				this.widthValue = syra_fields.getCardFieldWidth(this.$numeric);
				this.unitField._dataValue.style.maxWidth = this._dataValue.style.maxWidth = this.widthValue + "px";
			}
		} else {
			Field.prototype.setFieldWidth.call(this);
		}
	}
});