"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var _formatApi = require('syracuse-ui/lib/field/formatApi');

function decimalParser(decimalSep, groupSep, groupSize) {
	decimalSep = decimalSep || '.';
	groupSep = groupSep || ',';
	groupSize = groupSize || 3;
	if (groupSep !== '.' && groupSep !== ',' && (decimalSep === '.' || decimalSep === ','))
		decimalSep = '[.,]';
	else
		decimalSep = "\\" + decimalSep;
	var re = new RegExp("^\\s*([+-]?\\d*(?:\\" + groupSep + "\\d{" + groupSize + "})*)" + decimalSep + "?(\\d*)\\s*$");
	return function(str) {
		var match = re.exec(str);
		if (!match)
			throw new Error(syra_local.nfInvalidNumber + " : " + str);
		return parseFloat(match[1].replace(/[^\d\-]/g, '') + '.' + match[2]);
	};
}

function formatInput(field, val) {
	var numFormatObj = field.numFormatObj;
	var parser = decimalParser(numFormatObj.decimalSeparator, numFormatObj.groupSeparator, numFormatObj.groupSize);
	// formatting
	return field.formatApi.format(field.formatApi.parse(parser(val, field)), field.localFormat);
}

function _ensureUnitField(field) {
	var unitArticle = field.articleParent;
	var $unit = field.$field.$unit;
	var $unitBind;
	if (typeof($unit) == "string") {
		// By default unit descriptor is 'inlined' and set as object, else unit can be at different level and shared by other fields
		while (unitArticle) {
			if (!(unitArticle.$prototype && unitArticle.$prototype.$properties && unitArticle.$prototype.$properties[$unit])) {
				unitArticle = unitArticle.articleParent;
			} else {
				$unit = unitArticle.$prototype.$properties[$unit];
				break;
			}
		}
		$unitBind = field.$field.$unit;
	} else {
		$unitBind = "$unit";
	}
	if ($unit && $unit.$type) {
		field.unitFieldSlot = document.createElement("div");
		field.unitFieldSlot.className = field.$isEditMode ? "s-quantity-unit-edit" : "s-quantity-unit";
		field.unitField = field.page.loadNewItem(field.unitFieldSlot, {
			$bind: $unitBind,
			$field: $unit,
			$inplace: true,
			$isUnitField: true,
			$isQuantityEditable: field.$isEditMode,
			//$inplace: field.$item.$inplace,
			$isDiagnoseInline: true,
			$skinInput: field.$skinInput,
			$isTitleHidden: true,
			$isEditMode: false,
			$format: $unit.$type == 'application/x-choice' ? "$combo" : ""
		}, field.articleParent);
		if (unitArticle != field.articleParent) {
			field.unitField.setDataBind(unitArticle.dataset[field.unitField.$item.$bind], unitArticle.dataset, null, field.unitField.$item.$bind);
		}
	}
}


function NumericField() {}

exports.NumericField = helpers.defineClass(NumericField, Field, {
	ensureEditMode: function() {
		if (this.$field.$mode == "progress") {
			this.$isEditMode = false;
		} else {
			Field.prototype.ensureEditMode.call(this);
		}
	},
	format: function(val, format) {
		return this.formatApi.format(val, format);
	},
	dispose: function() {
		var formatEx;
		this.formatApi = this.progressValue = this.numFormatObj = this.localFormat = this._formatInput = this._checkSep = null;
		if ((formatEx = this.formatEx)) {
			var keys = Object.keys(formatEx);
			for (var ii = keys.length - 1; ii >= 0; ii--) {
				delete formatEx[keys[ii]];
			}
		}
		this.unitFieldSlot = this.unitField = null;
		Field.prototype.dispose.call(this);
	},
	initialize: function() {
		this.$numeric = this.$field;
		if (this.$numeric.$type == "application/x-quantity") {
			this.$numeric = this.$numeric.$value;
			this.$isQuantityField = true;
		}
		this.formatApi = _formatApi.getApi(this.$numeric.$type);
		this.numFormatObj = _formatApi.getLocale().getNumberFormatObj(this.$numeric.$type);
		this.$cssFieldType = "s-number";
		this.localFormat = this.$numeric.$format || this.numFormatObj.numFormat;
		this._formatInput = formatInput;
		this._checkSep = true;
		if (this.formatEx) {
			// Overwrite format APIs  "formatApi", "localFormat", etc...
			helpers.object.extendEx(this, this.formatEx);
			this.formatApi.regionalOptions = this.numFormatObj;
		}
	},
	validateKeyPress: function(charCode, event, shortCut) {
		var validated = true;
		if (event.keyCode != 13) { //13=enter
			var isInteger = this.$numeric.$type == "application/x-integer";
			validated = (charCode >= "0" && charCode <= "9") || (shortCut && shortCut.ctrl && charCode >= "A" && charCode <= "z");
			validated = validated || charCode == "-" || charCode == "+" || charCode == this.numFormatObj.groupSeparator;
			validated = validated || charCode == (isInteger ? '' : ".");
			validated = validated || charCode == (isInteger ? '' : ",");
			syra_site.dom.toggleClass(this.input, 's-field-input-error', !validated);
		}
		return validated;
	},
	onInputFocusin: function(input, event) {
		syra_site.dom.toggleClass(input, 's-field-input-error', false);
		var gs = this.numFormatObj.groupSeparator;
		var gsRegExp = gs == " " ? new RegExp("\\s", "g") : new RegExp("[" + gs + "]", "g");
		var editVal = (input.value || "").split(gsRegExp).join('');
		input.value = editVal;
		Field.prototype.onInputFocusin.call(this, input, event);
	},
	onInputFocusout: function(input, event) {
		if (this._checkSep && !this.valHasChanged) {
			var ds = this.numFormatObj.decimalSeparator;
			var value = input.value || "";
			if (!(value === "" && this.$item.$isFilterMode)) {
				var rawNum = ds != '.' ? value.replace(new RegExp("[" + ds + "]"), '.') : value;
				var numObj = this.formatApi.parse(rawNum);
				// displaying formatted num
				input.value = this.formatApi.format(numObj, this.localFormat);
			}
		} else {
			this.valHasChanged = false;
		}
		Field.prototype.onInputFocusout.call(this, input, event);
	},
	onInputChange: function(input, event) {
		// handle formatting
		var val = input.value,
			valFormatted = val;
		this.valHasChanged = true;
		if (val != '') {
			input.value = valFormatted = this._formatInput(this, val);
		}
		if (this.validate(valFormatted, [])) {
			this.onInputValidate(event);
		}
	},
	render: function() {
		var renderDone;
		if (this.$isEditMode) {
			this.input = document.createElement("input");
			syra_site.setSpecificAttributes(this.input);
			this.input.setAttribute("type", syra_site.isTabletDevice ? "number" : "text");
			this.input.className = this.$skinInput + " " + this.$skinInput + "-num";
			this._dataValue.appendChild(this.input);
			renderDone = true;
		} else {
			if (this.$field.$mode == "progress") {
				this._dataValue.className += " s-field-progress";
				this.progressValue = document.createElement("div");
				this.progressValue.className = "s-field-progress-value";
				this._dataValue.appendChild(this.progressValue);
			}
		}
		if (this.$isQuantityField && !this.$item.$isFilterMode && !this.articleParent.isFilterArticle) {
			_ensureUnitField(this);
		}
		return renderDone;
	},
	setDataValue: function(value) {
		this.articleParent.setMustBeResized();
		if (this.progressValue) {
			this.progressValue.style.width = ((this._dataValue.clientWidth * value) / 100) + "px";
		} else {
			this.displayText = "";
			this.currentValue = value;
			if (value) {
				// building formatted value
				var numObj = this.formatApi.parse(value);
				this.displayText = this.formatApi.format(numObj, this.localFormat);
			}
			if (this.$isEditMode) {
				this.setInputValue(this.displayText);
				this.unitFieldSlot && this.input.parentNode.insertBefore(this.unitFieldSlot, this.input.nextSibling);
			} else {
				if (this.displayText && !this.$isDetailLinkDisabled && this.$menus && this.$menus.$details) {
					this.appendDetailLink(this.displayText, this.$menus.$details);
				} else {
					this._dataValue.textContent = this.displayText;
				}
				value && this.unitFieldSlot && this._dataValue.appendChild(this.unitFieldSlot);
				syra_menus.ensureMenuPicker(this);
			}
		}
	},
	getDisplayText: function() {
		var text = this.unitField ? this.unitField.getDisplayText() : "";
		return (this.displayText || "") + text;
	},
	getDataValue: function() {
		var value = this.getInputValue();
		if (value === "" && this.$item.$isFilterMode) {
			return value;
		}
		return this.formatApi.parse(value, this.localFormat).toString();
	},
	setFieldWidth: function() {
		if (this.$isQuantityField) {
			if (this.$isEditMode && !this.hasFreeWidth && !this.$item.$rows && !this.$item.$inplace && this._dataValue && !this.$item.$isAutoSizeDisabled) {
				this.widthValue = this.fieldHelper.getCardFieldWidth(this.$numeric);
				this.unitField._dataValue.style.maxWidth = this._dataValue.style.maxWidth = this.widthValue + "px";
			}
		} else {
			Field.prototype.setFieldWidth.call(this);
		}
	}
});