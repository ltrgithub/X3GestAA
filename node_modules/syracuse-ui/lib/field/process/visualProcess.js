"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Process = require('syracuse-ui/lib/field/process/process').Process;
var Field = require('syracuse-ui/lib/field/field').Field;
var tools = require('syracuse-ui/lib/field/process/processTools');
var SymbolManager = require('syracuse-ui/lib/field/process/symbolManager').SymbolManager;

// Fix jquery browser info
var userAgent = navigator.userAgent.toLowerCase();
$.browser.chrome = /chrome/.test(userAgent);

if ($.browser.chrome) {
	userAgent = userAgent.substring(userAgent.indexOf('chrome/') + 7);
	userAgent = userAgent.substring(0, userAgent.indexOf('.'));
	$.browser.version = userAgent;
	// If it is chrome then jQuery thinks it's safari so we have to tell it it isn't
	delete $.browser.safari;
}

function VisualProcess() {}

exports.VisualProcess = helpers.defineClass(VisualProcess, Field, {
	loadBox: function() {
		this.$item.$isAutoSize = true;
		this.$item.$isTopLabelAlignment = true;
		Field.prototype.loadBox.call(this);
	},
	resizeField: function() {
		if (this.playerSlot && !this.isDisplayed && this.playerSlot.clientWidth) {
			this._showPlayer();
		}
	},
	setDataValue: function(value) {
		try {
			if (this.currentValue != value) {
				this.currentValue = value;

				this.$$playerSlot.empty();
				this.process = {};
				this._loadProcess(value);
				this._showPlayer();
			}
		} catch (e) {
			this.showDiagnoses([{
				$message: e.message,
				$severity: "error",
				"$stackTrace": e.stack
			}]);
		}
	},
	_tryParse: function(json) {
		try {
			return JSON.parse(json);
		} catch (e) {
			throw new Error("Failed to parse " + json + "\n[" + e.message + "]");
		}
	},
	_loadProcess: function(process) {
		this.process = _normalizeProcess(process.$data);
		this.info = process.$info;
		this.isDisplayed = false;

		if (!this.bibMapping) {
			var libsinfo = this.info && this.info.libsinfo;
			this.bibMapping = {};
			if (libsinfo) {
				for (var ii = 0, jj = libsinfo.length; ii < jj; ii++) {
					var lib = libsinfo[ii];
					if (lib.biblist) {
						for (var mm = 0, kk = lib.biblist.length; mm < kk; mm++) {
							this.bibMapping[lib.biblist[mm].bibid] = lib.biblist[mm];
						}
					}
				}
			}
		}
	},

	ensureEditMode: function() {
		this.$isEditMode = false;
	},
	render: function() {
		this._dataValue.setAttribute("id", "vp" + this.id);
		this.$linkId = "$processLink" + this.id;
		this.playerSlot = document.createElement("div");
		this.$$playerSlot = $(this._dataValue.appendChild(this.playerSlot));
		var slot = this.workerSlot = document.createElement("div");
		this._hideWorker();

		this._dataValue.appendChild(this.workerSlot);
		this.page.loadNewItem(this._dataValue, {
			$bind: this.$linkId,
			$category: "link"
		}, this.articleParent);
	},

	_hideWorker: function() {
		var slot = this.workerSlot;
		slot.style.display = "block";
		slot.style["line-height"] = 0;
		slot.style.height = 0;
		slot.style.overflow = "hidden";
	},

	_execLink: function(link) {
		var $links = {};
		$links[this.$linkId] = null;
		this.articleParent.applyChange({
			$links: $links
		});
		this.page.loadNewItem(this._dataValue, {
			$bind: this.$linkId,
			$category: "link"
		}, this.articleParent);
		($links[this.$linkId] = link).$isHidden = true;
		this.articleParent.applyChange({
			$links: $links
		});
		this.articleParent.clickMenu(this.$linkId);
	},
	_constructLinksObj: function(params) {
		var obj = {};
		var baseUrl = this.articleParent.$prototype.$baseUrl;
		switch (params.xtype) {
			case 'url':
				obj.$type = "application/json;vnd.sage=syracuse";
				obj.$url = params.xcode;
				break;
			default:
				this.showErrors([(this.localize.flProcessPlayerIncorrectLinkType || "").replace("{0}", params.xtype)], {
					noViewer: true
				});
				break;
		}
		if (params.xtarget != null) {
			obj.$target = params.xtarget;
		}
		return obj;
	},
	_showPlayer: function() {
		if (!this.process || this.isDisplayed || !this.playerSlot) {
			return;
		}
		this.isDisplayed = true;

		var supportForeignObject = !($.browser.msie || $.browser.safari),
			self = this,
			process = self.process,
			layers = process && process.layersArr,
			actions = process.acts.a;
		var csize = {
			x: process.contentSize.xwidth,
			y: process.contentSize.xheight
		};
		var result = "";

		var bibMapping = this.bibMapping;

		this.symbolManager && this.symbolManager.destroy();
		this.symbolManager = new SymbolManager(this.workerSlot);

		function createAction(action, index, array) {
			function clickHdl() {
				var targ = self.$$playerSlot.find('.target' + action.id);
				targ.css('display', 'block');
			}
			var trigger = self.$$playerSlot.find('.trigger' + action.id);
			var targ;
			trigger.attr('pointer-events', 'visible');
			trigger.css('cursor', 'pointer');
			switch (action.type) {
				case 'shotip':
					self.$$playerSlot.find('.target' + action.id).hide();
					trigger.mouseover(function(e) {
						self.$$playerSlot.find('.target' + action.id).css('display', 'block');
					});
					trigger.mouseout(function(e) {
						self.$$playerSlot.find('.target' + action.id).css('display', 'none');
					});
					break;
				case 'sho':
					targ = self.$$playerSlot.find('.target' + action.id);
					var isHideTarget = false;
					array.forEach(function(a, index, array) {
						if (a.type === 'hid' && targ.is('.target' + a.id))
							isHideTarget = true;
					});
					if (!isHideTarget) {
						targ.hide();
					}
					trigger.click(function() {
						self.$$playerSlot.find('.target' + action.id).show();
					});
					break;
				case 'shopopmenu':
					targ = self.$$playerSlot.find('.target' + action.id);
					targ.hide();
					trigger.click(clickHdl);
					self.$$playerSlot.click(function(e) {
						var parenttrigger = $(e.target).parents().filter(function(idx, el) {
							if ($(el).is('.trigger' + action.id))
								return true;
						});
						var parenttarget = $(e.target).parents().filter(function(idx, el) {
							if ($(el).is('.target' + action.id))
								return true;
						});
						if (!($(e.currentTarget).is('.trigger' + action.id)) && parenttrigger.size() === 0 && !($(e.currentTarget).is('.target' + action.id)) && parenttarget.size() === 0) {
							targ.hide();
						}
					});
					break;
				case 'hid':
					trigger.click(function() {
						self.$$playerSlot.find('.target' + action.id).hide();
					});
					break;
				case 'shohid':
					trigger.click(function() {
						var targ = self.$$playerSlot.find('.target' + action.id);
						var hidden = (targ.css('display') == 'none'); //(target.attr('display') == 'none');
						if (hidden)
							targ.css('display', 'block');
						else
							targ.css('display', 'none');
					});
					break;
				case 'shoallpopmenu':
					trigger.click(function(e) {
						array.forEach(function(a, index, array) {
							if (a.type === "shopopmenu") {
								var targets = self.$$playerSlot.find('.target' + a.id); //+':hidden') ;
								var trig = self.$$playerSlot.find('.trigger' + a.id);
								targets.each(function(index, el) {
									var hidden = ($(el).css('display') == 'none');
									if (hidden) {
										trig.unbind('click', clickHdl);
										$(el).css('display', 'block');
									} else {
										trig.bind('click', clickHdl);
										$(el).css('display', 'none');
									}
								});
							}
						});
						e.stopPropagation();
					});
					break;
			}
		}

		var defs = '<defs>',
			ii, jj, group;

		for (var gn = 0, sizeG = layers.length; gn < sizeG; gn++) {
			group = layers[gn];
			for (var i = 0; i < group.xpropsArr.length; i++) {
				var shapeInfo = tools.createShape(group.xpropsArr[i], csize, bibMapping, this.symbolManager);
				defs += (shapeInfo.defs || "");
				var rotation;
				if (group.xpropsArr[i].xshapeType == "apishape" && group.xpropsArr[i].xdrawBehaviorCode == "K_API_ELLIPSE") {
					rotation = (Math.atan2(group.xpropsArr[i].xanchors[2].y - group.xpropsArr[i].xanchors[0].y, group.xpropsArr[i].xanchors[2].x - group.xpropsArr[i].xanchors[0].x) !== 0);
				} else {
					if (group.xpropsArr[i].xshapeType == "clipshape" || (group.xpropsArr[i].xshapeType == "apishape" && group.xpropsArr[i].xdrawBehaviorCode != "K_API_LINE")) {
						rotation = (Math.atan2(group.xpropsArr[i].xanchors[1].y - group.xpropsArr[i].xanchors[0].y, group.xpropsArr[i].xanchors[1].x - group.xpropsArr[i].xanchors[0].x) !== 0);
					}
				}
				var ttext = '';
				if (group.xpropsArr[i].xlinkProps.xtype != 'none') {
					result += '<g id="' + group.xpropsArr[i].uniqueID + '" class="link">';
				}
				var xactionProps = group.xpropsArr[i].xactionProps;
				if (xactionProps.targ || xactionProps.trig) {
					var css = "";
					if (xactionProps.targ) {
						for (ii = 0, jj = xactionProps.targ.length; ii < jj; ii++) {
							css += "target" + xactionProps.targ[ii] + " ";
						}
					}
					if (xactionProps.trig) {
						for (ii = 0, jj = xactionProps.trig.length; ii < jj; ii++) {
							css += "trigger" + xactionProps.trig[ii] + " ";
						}
					}
					result += ("<g " + (css ? ("class='" + css + "'") : "") + ">");
				}
				if (rotation) {
					result += '<g transform="' + tools.getRotate(group.xpropsArr[i]) + '">';

				}
				result += shapeInfo.descr || "";
				if (rotation) {
					result += '</g>';
				}
				if (group.xpropsArr[i].xtext) {
					if (supportForeignObject) {
						ttext = tools.createText(group.xpropsArr[i], rotation);
						result += ttext;
					}
					// result += tools["createText" + (!supportForeignObject && "_ie" || "")](group.xpropsArr[i], rotation);
				}
				if (group.xpropsArr[i].xlinkProps.xtype != 'none') {
					result += '</g>';
				}
				if (xactionProps.targ || xactionProps.trig) {
					result += '</g>';
				}
			}
		}
		defs += '</defs>';
		var svgdescr = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + csize.x + 'px" height="' + csize.y + 'px" version="1.1"> ' + defs + result + '</svg>';
		var svgplot = $(svgdescr);
		this.$$playerSlot.append(svgplot);
		if (!supportForeignObject) {
			var $$textDiv = $('<div class="s-process-text">').appendTo(this.$$playerSlot);
			$$textDiv.css("position", "absolute").css("left", "0px").css("top", "0px");
			//create the texts as div elements
			for (var mm = 0, kk = layers.length; mm < kk; mm++) {
				group = layers[mm];
				for (ii = 0, jj = group.xpropsArr.length; ii < jj; ii++) {
					if (group.xpropsArr[ii].xtext) {
						tools.appendText(group.xpropsArr[ii], $$textDiv[0]);
					}
				}
			}
		}

		actions.forEach(createAction);

		function manageLink(index, link) {
			var $$link = $(link);
			var uri_decoded = decodeURIComponent(link.getAttribute('href'));
			var children = $$link.contents();
			var next = $$link.next();
			var uri = uri_decoded && uri_decoded.replace("asfunction:_global.ShapeLabelURLClicked,", "");
			var linksobj = self._constructLinksObj(self._tryParse(uri));
			if (next.length === 0) {
				$$link.parent().append(children);
			} else {
				next.before(children);
			}
			$$link.remove();
			if (!linksobj) {
				self.showErrors([(self.localize.flProcessPlayerLinkNotSupported || "").replace("{0}", uri)], {
					noViewer: true
				});
			} else {
				children &&
					children.bind('click', function(e) {
						self._execLink(linksobj);
						return false;
					});
				children.css('cursor', 'pointer');
			}
		}
		var textlinks = this.$$playerSlot.find('a');
		textlinks.each(manageLink);

		function addLink(index, link) {
			var params = self._tryParse(decodeURIComponent(link.getAttribute('link')));
			link.removeAttribute('link');
			var linksobj = self._constructLinksObj(params);
			var g = $(link).closest('g.link');
			g.click(function(e) {
				self._execLink(linksobj);
				return false;
			});
			g.css('cursor', 'pointer');
			if (!supportForeignObject && g[0]) {
				var divtext = self.$$playerSlot.find("div#" + (g[0].id || g[0].getAttribute('id')) + 'p');
				divtext.bind('click', function(e) {
					self._execLink(linksobj);
					return false;
				});
				divtext.css('cursor', 'pointer');
			}
			g.attr('pointer-events', 'visible');
		}
		var links = svgplot.find('*[link]');
		links.each(addLink);
		return this;
	},
	dispose: function() {
		this.process = this.playerSlot = this.$$playerSlot = null;
		Field.prototype.dispose.call(this);
	}
});

function _normalizeProcess(process) {
	process.layersArr = process.layersArr || [];
	process.acts = process.acts || {};
	process.acts.a = process.acts.a || [];
	process.contentSize = process.contentSize || {
		xwidth: 0,
		xheight: 0
	};
	var size = process.contentSize,
		xsize, xcenter, h, w, a;
	process.layersArr.forEach(function(g) {
		g.xpropsArr = g.xpropsArr || [];
		g.xpropsArr.forEach(function(xprop) {
			xprop.xshadowProps = xprop.xshadowProps || {};
			xcenter = xprop.xcenter || {};
			xcenter.x = xcenter.x || 0;
			xcenter.y = xcenter.y || 0;
			xsize = xprop.xsize || {};
			a = xprop.xanchors = xprop.xanchors || [];
			w = a[0] && a[1] && Math.sqrt((a[1].x - a[0].x) * (a[1].x - a[0].x) + (a[1].y - a[0].y) * (a[1].y - a[0].y));
			h = a[1] && a[2] && Math.sqrt((a[2].x - a[1].x) * (a[2].x - a[1].x) + (a[2].y - a[1].y) * (a[2].y - a[1].y));
			xsize.xwidth = xsize.xwidth || w || 0;
			xsize.xheight = xsize.xheight || h || 0;
			w = xcenter.x + xsize.xwidth / 2;
			h = xcenter.y + xsize.xheight / 2;
			size.xwidth = w > size.xwidth ? w : size.xwidth;
			size.xheight = h > size.xheight ? h : size.xheight;
		});
	});
	return process;
}

function appendSvg(nom, attributs) {
	var svg = document.createElementNS("http://www.w3.org/2000/svg", nom);
	for (var cle in attributs) {
		var valeur = attributs[cle];
		svg.setAttribute(cle, valeur);
	}
	/*var appendices = this.length;
     for (var i = 0; i < appendices; i++)
     {
     this[i].appendChild(svg);
     }*/
	return svg;
}