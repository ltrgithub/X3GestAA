"use strict";
var helpers = require('syracuse-core/lib/helpers');
var debugBoundedBox = false;

function _isEqual(a, b) {
	var epsilon = 0.000000000001;
	return ((a - b) < epsilon && (b - a) < epsilon);
}

function _getHexadecimalColor(str) {
	if (typeof str == 'undefined') {
		str = 0;
	}
	var hex = Number(str).toString(16);
	hex = "#000000".substr(0, 7 - hex.length) + hex;
	return hex.toUpperCase();
}

function _encodeLink(link) {
	if (link && link.xcode && link.xtype === "url") {
		link.xcode = $("<div/>").html(link.xcode).text();
	}
	return encodeURIComponent(JSON.stringify(link));
}

function _compare_float_func(a, b) {
	// Must return :
	// -1 if a < b
	//  0 if a = b
	//  1 if a > b
	return parseFloat(a) - parseFloat(b);
}

function _getGradientTransVector(alpha) {
	// l'angle de rotation est calculé par rapport au centre de la xprop, on considére donc ce point comme centre de notre graphe
	// le repère est orthonormée de longueur max 50 (la fenetre graphique éMath.tant de longueur et largeur 100)
	var x1, x2, y1, y2;
	//traitement cas spéciaux
	var margeArrondi = Math.PI / 100;
	if (!alpha || _isEqual(alpha, 2 * Math.PI)) {
		x2 = 50;
		y2 = 0;
	} else if (_isEqual(alpha, Math.PI / 2)) {
		x2 = 0;
		y2 = 50;
	} else if (_isEqual(alpha, Math.PI)) {
		x2 = -50;
		y2 = 0;
	} else if (_isEqual(alpha, 3 * Math.PI / 2)) {
		x2 = 0;
		y2 = -50;
	} else {
		x2 = 50 * Math.cos(alpha);
		y2 = 50 * Math.sin(alpha);
	}

	//calcul de x1 y1 en fonction de x2, y2. x1 et y1 sont opposé par rapport à l'origine
	x1 = -x2;
	y1 = -y2;
	// calcul pour basculer en coordonnées grphique (origine en haut a gauche)
	x1 += 50;
	y1 += 50;
	x2 += 50;
	y2 += 50;
	return {
		x1: x1,
		y1: y1,
		x2: x2,
		y2: y2
	};
}

exports.getRotate = function(xprop) {
	var centerx, centery, anglerad;
	if (xprop.xshapeType === 'clipshape' || xprop.xshapeType === 'fileshape') {
		centerx = xprop.xcenter.x;
		centery = xprop.xcenter.y;
	} else if (xprop.xshapeType === 'apishape') {
		var xcoords = [];
		var ycoords = [];
		for (var j = 0; j < 4; j++) {
			xcoords.push(xprop.xanchors[j].x);
		}
		xcoords.sort(_compare_float_func);
		centerx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;

		for (var i = 0; i < 4; i++) {
			ycoords.push(xprop.xanchors[i].y);
		}
		ycoords.sort(_compare_float_func);

		centery = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;

		if (xprop.xdrawBehaviorCode == "K_API_ELLIPSE") {
			anglerad = Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, xprop.xanchors[2].x - xprop.xanchors[0].x);
		} else {
			if (xprop.xdrawBehaviorCode == xprop.xdrawBehaviorCode == "K_API_LINE") {
				return "";
			}
		}
	}
	if (anglerad === undefined) {
		anglerad = Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, xprop.xanchors[1].x - xprop.xanchors[0].x);
	}
	return 'rotate(' + (180 * anglerad / Math.PI) + ',' + centerx + ',' + centery + ') ';
};

function _setShapeStyles(shape, xprop) {
	var stroke = xprop.xstrokeProps;
	shape.setAttribute('stroke', (stroke.xtype === 'none' || stroke.xtype === 'nostroke') ? 'none' : _getHexadecimalColor(stroke.xcolor));
	shape.setAttribute('stroke-opacity', stroke.xalpha / 100);
	shape.setAttribute('stroke-width', stroke.xthickness);
	switch (stroke.xtype) {
		case 'dottedstroke':
			shape.setAttribute('stroke-dasharray', 2 * stroke.xthickness + ',' + 2 * stroke.xthickness);
			break;
		case 'dashedstroke':
			shape.setAttribute('stroke-dasharray', 5 * stroke.xthickness + ',' + 5 * stroke.xthickness);
			break;
		default:
			shape.setAttribute('stroke-dasharray', "");
			break;

	}
	switch (xprop.xfillProps.xtype) {
		case 'nofill':
			shape.setAttribute('fill', 'none');
			break;
		case 'solidfill':
			shape.setAttribute('fill', _getHexadecimalColor(xprop.xfillProps.xcolor));
			break;
		case 'gradientfill':
			shape.setAttribute('fill', 'url(#grad' + xprop.uniqueID + ')');
			break;
		case 'patternfill':
			shape.setAttribute('fill', 'url(#pattern' + xprop.uniqueID + ')');
			break;
	}
	shape.setAttribute('fill-opacity', xprop.xfillProps.xalpha / 100);
}

function _getStopGradient(xfillProps) {
	var stopset = "";
	for (var ii = 0, jj = xfillProps.xgcolors.length; ii < jj; ii++) {
		var stop = "<stop offset='" + (xfillProps.xgratios[ii] * 100 / 255) + "%'";
		stop += " style='stop-color:" + _getHexadecimalColor(xfillProps.xgcolors[ii]) + "; stop-opacity:" + (xfillProps.xgalphas[ii] / 100) + "'></stop>";
		stopset += stop;
	}
	return stopset;
}

function _createGradient(xprop) {
	var res;
	switch (xprop.xfillProps.xgtype) {
		case 'linear':
			var tabCoord = _getGradientTransVector(xprop.xfillProps.xgrotation);
			res = "<lineargradient id='grad" + xprop.uniqueID + "'";
			res += " x1='" + tabCoord.x1 + "%'";
			res += " y1='" + tabCoord.y1 + "%'";
			res += " x2='" + tabCoord.x2 + "%'";
			res += " y2='" + tabCoord.y2 + "%'";
			res += ">" + _getStopGradient(xprop.xfillProps) + "</lineargradient>";
			break;
		case 'radial':
			//TODO les 50% c'ets codé en dur
			res = "<radialgradient id='grad" + xprop.uniqueID + "'";
			res += " cx='50%' cy='50%'  r='50%' fx='50%' fy='50%'";
			res += ">" + _getStopGradient(xprop.xfillProps) + "</radialgradient>";
			break;
	}
	return res;
}

function _createPattern(xprop) {
	var res;
	var tmpmage = new Image();
	tmpmage.src = "/syracuse-ui/themes/desktop/sage/process/images/patterns/" + xprop.xfillProps.xpatLinkId + ".gif";
	tmpmage.name = xprop.xfillProps.xpatLinkId;
	tmpmage.onload = function() {
		$('.' + this.name).attr('width', this.width).attr('height', this.height);
		return true;
	};
	res = '<pattern id="pattern' + xprop.uniqueID + '" class="' + xprop.xfillProps.xpatLinkId + '" patternUnits="userSpaceOnUse" x="0" y="0" width="0" height="0">';
	res += '<image xlink:href="/syracuse-ui/themes/desktop/sage/process/images/patterns/' + xprop.xfillProps.xpatLinkId + '.gif"';
	res += 'class="' + xprop.xfillProps.xpatLinkId + '" x="0" y="0" width="0" height="0"/>';
	res += "</pattern>";
	return res;
}

function _createShadow(xprop) {
	return "<filter id='shadow" + xprop.uniqueID + "'>" + "<feoffset result='offOut' dy='3' dx='3' in='SourceAlpha'></feoffset><fegaussianblur result='blurred' stddeviation='3' in='offOut'></fegaussianblur><feblend mode='normal' in2='blurred' in='SourceGraphic'></feblend>" + "</filter>";
}

function _createLineMarker(xprop, markertype, filled, startend, line) {
	var marker;
	var sz = 2 * xprop.xstrokeProps.xthickness + 11;
	var x1, x2, y1, y2, angle, anglePoint;

	x1 = xprop.xanchors[0].x;
	x2 = xprop.xanchors[2].x;
	y1 = xprop.xanchors[0].y;
	y2 = xprop.xanchors[2].y;

	angle = Math.atan2(y2 - y1, x2 - x1);
	anglePoint = Math.PI / 2 - angle;
	switch (markertype) {
		case 'arr1':
		case 'arr2':
		case 'diamond1':
			var spreadfactor = 0.5;
			var point1x, point1y, point2x, point2y, point3x, point3y, point4x, point4y, endx, endy;
			var centerx, centery;
			var halfthickness = xprop.xstrokeProps.xthickness / 2;
			if (startend == 'end') {
				if (markertype == 'arr1' || markertype == 'arr2') {
					point1x = x2 - Math.cos(angle + spreadfactor) * sz;
					point1y = y2 - Math.sin(angle + spreadfactor) * sz;
					point3x = x2 - Math.cos(angle - spreadfactor) * sz;
					point3y = y2 - Math.sin(angle - spreadfactor) * sz;
					point2x = x2;
					point2y = y2;

					if (markertype == 'arr1') {
						endx = (point1x + point3x) / 2;
						endy = (point1y + point3y) / 2;
					} else if (markertype == 'arr2') {
						endx = x2 - Math.cos(angle) * halfthickness;
						endy = y2 - Math.sin(angle) * halfthickness;
					}
				} else if (markertype == 'diamond1') {
					centerx = x2 - Math.cos(angle) * sz / 2;
					centery = y2 - Math.sin(angle) * sz / 2;
					point1x = centerx + Math.cos(anglePoint) * sz / 2;
					point1y = centery - Math.sin(anglePoint) * sz / 2;
					point2x = x2 - Math.cos(angle) * sz;
					point2y = y2 - Math.sin(angle) * sz;
					point3x = centerx - Math.cos(anglePoint) * sz / 2;
					point3y = centery + Math.sin(anglePoint) * sz / 2;
					point4x = x2;
					point4y = y2;
					endx = centerx;
					endy = centery;
				}
				line.setAttribute('x2', endx);
				line.setAttribute('y2', endy);
			} else if (startend == 'start') {
				if (markertype == 'arr1' || markertype == 'arr2') {
					point1x = x1 + Math.cos(angle + spreadfactor) * sz;
					point1y = y1 + Math.sin(angle + spreadfactor) * sz;
					point3x = x1 + Math.cos(angle - spreadfactor) * sz;
					point3y = y1 + Math.sin(angle - spreadfactor) * sz;
					point2x = x1;
					point2y = y1;
					if (markertype == 'arr1') {
						endx = (point1x + point3x) / 2;
						endy = (point1y + point3y) / 2;
					} else if (markertype == 'arr2') {
						endx = x1 + (Math.cos(angle) * halfthickness);
						endy = y1 + (Math.sin(angle) * halfthickness);
					}
				} else if (markertype == 'diamond1') {

					centerx = x1 + Math.cos(angle) * sz / 2;
					centery = y1 + Math.sin(angle) * sz / 2;
					point1x = centerx - Math.cos(anglePoint) * sz / 2;
					point1y = centery + Math.sin(anglePoint) * sz / 2;
					point2x = x1 + Math.cos(angle) * sz;
					point2y = y1 + Math.sin(angle) * sz;
					point3x = centerx + Math.cos(anglePoint) * sz / 2;
					point3y = centery - Math.sin(anglePoint) * sz / 2;
					point4x = x1;
					point4y = y1;
					endx = centerx;
					endy = centery;
				}
				line.setAttribute('x1', endx);
				line.setAttribute('y1', endy);
			}

			marker = $('<path>').attr('d', function() {
				var pathdescr = 'M ' + point1x + ' ' + point1y + ' L ' + point2x + ' ' + point2y + ' L ' + point3x + ' ' + point3y;
				if (markertype == 'diamond1') pathdescr += ' L ' + point4x + ' ' + point4y;
				if (markertype == 'arr1' || markertype == 'diamond1') pathdescr += ' z';

				return pathdescr;
			});

			marker.attr('stroke', _getHexadecimalColor(xprop.xstrokeProps.xcolor));
			marker.attr('stroke-width', function() {
				if (markertype == 'arr2') return xprop.xstrokeProps.xthickness;
				else return 1;
			});
			if (markertype == 'arr2') {
				marker.attr('stroke-linecap', 'round');
				marker.attr('stroke-linejoin', 'round');
			}

			marker.attr('stroke-opacity', xprop.xstrokeProps.xalpha / 100);

			marker.attr('fill', function() {
				if (markertype == 'diamond1' || markertype == 'arr1') {
					if (filled) return _getHexadecimalColor(xprop.xstrokeProps.xcolor);
					else return '#FFFFFF';
				} else return 'none';
			});

			break;

		case 'disc1':

			var r, cx, cy;

			r = xprop.xstrokeProps.xthickness + 3;
			if (startend == 'end') {
				cx = x2 - Math.cos(angle) * r;
				cy = y2 - Math.sin(angle) * r;
				endx = x2 - Math.cos(angle) * r * 2;
				endy = y2 - Math.sin(angle) * r * 2;
				line.setAttribute('x2', endx);
				line.setAttribute('y2', endy);
			} else if (startend == 'start') {
				cx = x1 + Math.cos(angle) * r;
				cy = y1 + Math.sin(angle) * r;
				endx = x1 + Math.cos(angle) * r * 2;
				endy = y1 + Math.sin(angle) * r * 2;
				line.setAttribute('x1', endx);
				line.setAttribute('y1', endy);
			}
			marker = $('<circle>').attr('cx', cx).attr('cy', cy).attr('r', r);
			marker.attr('stroke', _getHexadecimalColor(xprop.xstrokeProps.xcolor));
			marker.attr('fill', filled ? _getHexadecimalColor(xprop.xstrokeProps.xcolor) : '#FFFFFF');
			break;
	}
	return marker[0].outerHTML;
}


exports.createShape = function(xprop, csize, bibMapping, symbolManager) {
	var defs = "",
		shapeInfo = {};

	if (xprop.xshapeType === 'apishape' || xprop.xshapeType === 'beziershape') {
		if (xprop.xfillProps.xtype === 'gradientfill') {
			defs += _createGradient(xprop);
		} else if (xprop.xfillProps.xtype === 'patternfill') {
			defs += _createPattern(xprop);
		}
	}

	if (xprop.xshadowProps.xtype === 'global') {
		defs += _createShadow(xprop);
	}

	var shape;
	var parent;
	var markers = '';
	switch (xprop.xshapeType) {
		case 'apishape':
			var centerx, centery, width, height;
			var xcoords = [];
			var ycoords = [];
			var w, h, i;
			var angle;
			for (var j = 0; j < 4; j++) {
				xcoords.push(xprop.xanchors[j].x);
			}
			xcoords.sort(_compare_float_func);

			for (i = 0; i < 4; i++) {
				ycoords.push(xprop.xanchors[i].y);
			}
			ycoords.sort(_compare_float_func);
			var apirotation;

			switch (xprop.xdrawBehaviorCode) {
				case "K_API_LINE":
					shape = document.createElement("line");
					shape.setAttribute("x1", xprop.xanchors[0].x);
					shape.setAttribute("y1", xprop.xanchors[0].y);
					shape.setAttribute("x2", xprop.xanchors[2].x);
					shape.setAttribute("y2", xprop.xanchors[2].y);
					shape.setAttribute("stroke-linecap", "square");

					var markertype, filled;
					if (xprop.xstrokeProps.xstart) {
						markertype = xprop.xstrokeProps.xstart.xtype;
						filled = xprop.xstrokeProps.xstart.xfilled;

						if (markertype != 'none' && markertype != 'noarrow') {
							markers += _createLineMarker(xprop, markertype, filled, 'start', shape);
						}
					}

					if (xprop.xstrokeProps.xend) {
						markertype = xprop.xstrokeProps.xend.xtype;
						filled = xprop.xstrokeProps.xend.xfilled;

						if (markertype != 'none' && markertype != 'noarrow') {
							markers += _createLineMarker(xprop, markertype, filled, "end", shape);

						}
					}
					break;
				case "K_API_RECT":
					shape = document.createElement("rect");
					angle = Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, xprop.xanchors[1].x - xprop.xanchors[0].x);
					centerx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;
					centery = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;
					width = Math.sqrt((xprop.xanchors[1].x - xprop.xanchors[0].x) * (xprop.xanchors[1].x - xprop.xanchors[0].x) + (xprop.xanchors[1].y - xprop.xanchors[0].y) * (xprop.xanchors[1].y - xprop.xanchors[0].y));
					height = Math.sqrt((xprop.xanchors[3].x - xprop.xanchors[0].x) * (xprop.xanchors[3].x - xprop.xanchors[0].x) + (xprop.xanchors[3].y - xprop.xanchors[0].y) * (xprop.xanchors[3].y - xprop.xanchors[0].y));

					shape.setAttribute("x", centerx - width / 2);
					shape.setAttribute("y", centery - height / 2);
					shape.setAttribute("width", width);
					shape.setAttribute("height", height);
					w = centerx + width / 2 + Math.cos(angle) * xprop.xstrokeProps.xthickness / 2;
					h = centery + height / 2 + Math.sin(angle) * xprop.xstrokeProps.xthickness / 2;
					if (w > csize.x) {
						csize.x = w;
					}
					if (h > csize.y) {
						csize.y = h;
					}
					break;
				case "K_API_ELLIPSE":
					angle = Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, xprop.xanchors[1].x - xprop.xanchors[3].x);

					shape = document.createElement("ellipse");
					var rx = Math.sqrt((xprop.xanchors[2].x - xprop.xanchors[0].x) * (xprop.xanchors[2].x - xprop.xanchors[0].x) + (xprop.xanchors[2].y - xprop.xanchors[0].y) * (xprop.xanchors[2].y - xprop.xanchors[0].y)) / 2;

					var ry = Math.sqrt((xprop.xanchors[1].x - xprop.xanchors[3].x) * (xprop.xanchors[1].x - xprop.xanchors[3].x) + (xprop.xanchors[1].y - xprop.xanchors[3].y) * (xprop.xanchors[1].y - xprop.xanchors[3].y)) / 2;

					var cx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;
					var cy = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;
					shape.setAttribute('cx', cx);
					shape.setAttribute('cy', cy);
					shape.setAttribute('rx', rx);
					shape.setAttribute('ry', ry);
					w = cx + rx + Math.cos(angle) * xprop.xstrokeProps.xthickness / 2;
					h = cy + ry + Math.sin(angle) * xprop.xstrokeProps.xthickness / 2;
					if (w > csize.x) {
						csize.x = w;
					}
					if (h > csize.y) {
						csize.y = h;
					}
					break;
			}
			break;

		case 'beziershape':
			var xanchors = xprop.xanchors;
			var a = xanchors[0];
			if (!a) {
				return {
					defs: defs
				};
				// we get this in fill test
			}
			var d = 'M ' + a.x + ' ' + a.y;
			var len = xanchors.length + (xprop.xclosed ? 1 : 0);
			// control points are weaker than in flash - so I move them away by a factor of f
			// value is experimental.
			var f = 1.3;
			for (i = 1; i < len; i++) {
				var pa = a;
				a = xanchors[i % xanchors.length];
				var c2x = pa.x + f * (pa.c2x - pa.x);
				var c2y = pa.y + f * (pa.c2y - pa.y);
				var c1x = a.x + f * (a.c1x - a.x);
				var c1y = a.y + f * (a.c1y - a.y);
				d += ' C ' + c2x + ' ' + c2y + ' ' + c1x + ' ' + c1y + ' ' + a.x + ' ' + a.y;
			}
			if (xprop.xclosed) {
				d += 'z';
			}
			shape = document.createElement("path");
			shape.setAttribute('d', d);
			break;

		case 'clipshape':
		case 'fileshape':
			width = Math.sqrt((xprop.xanchors[1].x - xprop.xanchors[0].x) * (xprop.xanchors[1].x - xprop.xanchors[0].x) + (xprop.xanchors[1].y - xprop.xanchors[0].y) * (xprop.xanchors[1].y - xprop.xanchors[0].y));
			height = Math.sqrt((xprop.xanchors[2].x - xprop.xanchors[1].x) * (xprop.xanchors[2].x - xprop.xanchors[1].x) + (xprop.xanchors[2].y - xprop.xanchors[1].y) * (xprop.xanchors[2].y - xprop.xanchors[1].y));

			var bib = bibMapping[xprop.bibid];
			bib = {
				name: (bib && bib.type == 'swflib' && bib.bibfilename && bib.bibfilename.replace(/\.swf/, "")) || "",
				catSubpath: (bib && bib.catsubpath) || "",
				famSubpath: (bib && bib.familysubpath) || ""
			};

			var collection = bib.famSubpath + bib.catSubpath + bib.name,
				href = '/syracuse-ui/themes/desktop/sage/process/images/' + collection + '/' + xprop.eltid;
			if (xprop.xshapeType == 'clipshape') {
				href += '.png';
			}
			var imagedescr = '<image x="' + (xprop.xcenter.x - width / 2) + 'px" y="' + (xprop.xcenter.y - height / 2) + 'px" width="' + width + 'px" height="' + height + 'px" preserveAspectRatio="none" id="' + xprop.uniqueID + '" z-index="' + xprop.xlevel + '" xlink:href="' + href + '"';
			var opt = {};
			// images don't display on Opera if we set externalResourcesRequired (after clearing cache).
			// So don't set it!
			// imagedescr += ' externalResourcesRequired="true"';
			if (xprop.xshadowProps.xtype == 'global') {
				opt.filter = ' filter="url(#shadow' + xprop.uniqueID + ')"';
			}
			if (xprop.xlinkProps.xtype != 'none') {
				opt.link = ' link="' + _encodeLink(xprop.xlinkProps) + '"';
			}
			imagedescr += (opt.filter || "") + (opt.link || "") + '/>';
			var symbol = (xprop.xshapeType === 'clipshape') && symbolManager.get(collection, xprop.eltid);
			if (symbol) {
				defs += symbol.def;
				width = xprop.xsize.xwidth;
				height = xprop.xsize.xheight;
				imagedescr = symbolManager.getSvg(symbol, xprop.xcenter.x, xprop.xcenter.y, width, height, opt);
				shapeInfo.symbol = symbol;
			}

			if (debugBoundedBox) {
				// imagedescr += '<rect x="' + (xprop.xcenter.x - width / 2) + '" y="' + (xprop.xcenter.x - width / 2) + '" height="' + height + '" width="' + width + '" style="stroke:#cc0000;" fill-opacity="0" />';
				imagedescr += '<rect x="' + xprop.xanchors[0].x + '" y="' + xprop.xanchors[0].y + '" height="' + height + '" width="' + width + '" style="stroke:#00cc00;" fill-opacity="0" />';
			}
			shapeInfo.descr = imagedescr;
			shapeInfo.defs = defs;
			return shapeInfo;
	}

	if (xprop.xshapeType === 'apishape' || xprop.xshapeType === 'beziershape') {
		_setShapeStyles(shape, xprop);
	}
	if (xprop.xshapeType === 'beziershape') {

		if (xprop.xdrawBehaviorCode == "K_BZ_LINE") {
			shape.setAttribute('stroke-linecap', "square");
		} else if (xprop.xstrokeProps.xtype === 'solidstroke') {
			shape.setAttribute('stroke-linecap', "round");
			shape.setAttribute('stroke-linejoin', "round");
			shape.setAttribute('style', " border-style:none;");
		}

	}

	if (xprop.xshapeType === 'beziershape') {
		shape.setAttribute('fill-rule', "evenodd");
	}
	if (xprop.xshadowProps.xtype == 'global') {
		shape.setAttribute('filter', "url(#shadow" + xprop.uniqueID + ")");
	}
	if (xprop.xlinkProps.xtype != 'none') {
		shape.setAttribute('link', _encodeLink(xprop.xlinkProps));
	}
	shapeInfo.descr = shape.outerHTML + markers;
	shapeInfo.defs = defs;
	return shapeInfo;
};

function _convertWhitespaces(node) {
	if (node.nodeType == 3) {
		var str = node.nodeValue.replace(/\s\s/g, " &nbsp;");
		$(node).wrap('<textformat>');
		var parent = $(node).parent();
		parent.html(str);
	} else {
		for (var i = 0, len = node.childNodes.length; i < len; ++i) {
			_convertWhitespaces(node.childNodes[i]);
		}
	}
}

function _getFont(el) {
	var $el = $(el);
	return {
		size: $el.attr('size') && $el.attr('size') + 'px',
		face: $el.attr('face') && $el.attr('face'),
		color: $el.attr('color') && $el.attr('color')
	};
}

function _replaceFont(el) {
	var $el = $(el),
		size = $el.attr('size') ? 'font-size:' + $el.attr('size') + 'px;' : '',
		face = $el.attr('face') ? 'font-family:' + $el.attr('face') + ';' : '',
		color = $el.attr('color') ? 'color:' + $el.attr('color') + ';' : '';
	$el.replaceWith('<span style="' + size + face + color + '">' + $el.html() + '</span>');
}

function _removeTextformat(index, el) {
	var $el = $(el),
		parent = $el.parent();
	var contents = $el.contents();
	parent.append(contents);
	$el.remove();
}

function _replaceParagraph(index, el, xprop) {
	var $el = $(el),
		alignement = $el.attr('align');
	var textformat = $el.parents().filter('textformat');

	if ( /*index === 0 ||*/ textformat.length === 0) {
		$el.replaceWith('<div style="text-align: ' + alignement + '; margin-left:' + xprop.xtextFormat.leftMargin + 'px; margin-right:' + xprop.xtextFormat.rightMargin + 'px;">' + $el.html() + '</div>');
	} else {
		$el.replaceWith('<div style="text-align: ' + alignement + '; margin-left:' + xprop.xtextFormat.leftMargin + 'px; margin-right:' + xprop.xtextFormat.rightMargin + 'px;">' + $el.html() + '</br></div>');
	}
}

exports.appendText = function(forme, container) {
	var text = "";
	var style = '';
	if (forme.xshadowProps.xtype === 'global') style += 'text-shadow: silver 5px 5px 3px;';

	var div = document.createElement("div"),
		// ugly hack to slightly shift the vertical position
		top = forme.xcaptionPos.xtop + 2;
	div.setAttribute('id', forme.uniqueID + 'p');
	style += 'position:absolute; left:' + forme.xcaptionPos.xleft + 'px; top:' + top + 'px; width: ' + forme.xcaptionSize.xwidth + 'px; height: ' + (forme.xcaptionSize.xheight + 10) + 'px;';
	style += "vertical-align:" + forme.xcaptionProps.xvertAlignMode + '; z-index:' + forme.xlevel + ';';
	style += 'line-height: 1.2;';

	div.setAttribute('style', style);
	var $$div = $(div);
	$$div.html(forme.xtext);
	var fonts = $$div.find('font');
	var i, ii, jj;
	for (i = fonts.length; i > 0; i--) {
		_replaceFont(fonts[i - 1]);
	}

	var paragraphs = $$div.find('p');
	for (i = 0; i < paragraphs.length; i++) {
		_replaceParagraph(i, paragraphs[i], forme);
	}
	var textformats = $$div.find('textformat');
	textformats.each(_removeTextformat);

	_convertWhitespaces(div);
	container.appendChild(div);

	if (forme.xactionProps.targ || forme.xactionProps.trig) {
		var css = "";
		if (forme.xactionProps.targ) {
			for (ii = 0, jj = forme.xactionProps.targ.length; ii < jj; ii++) {
				css += " target" + forme.xactionProps.targ[ii];
			}
		}
		if (forme.xactionProps.trig) {
			for (ii = 0, jj = forme.xactionProps.trig.length; ii < jj; ii++) {
				css += " trigger" + forme.xactionProps.trig[ii];
			}
		}
		div.className += css;
	}
};

exports.createText_ie = function(xprop, arge2) {
	// TO FIX: shadow is not managed at the moment
	var shadow = '';
	if (xprop.xshadowProps.xtype === 'global') shadow = 'text-shadow: silver 5px 5px 3px;';

	var text = $("<text>" + xprop.xtext + "</text>"),
		svg = '<g transform="translate( ' + xprop.xcaptionPos.xleft + " " + xprop.xcaptionPos.xtop + ')">';
	svg += _transform(text[0]);
	return svg + "</g>";
};

var styleMap = {
	"face": "font-family",
	"size": "font-size",
	"color": "stroke",
	"letterspacing": "letter-spacing",
	"kerning": "kerning"
},
	attribMap = {
		"href": "href"
	};

function _transform(node, context) {
	context = context || {};
	if (node.nodeType === node.TEXT_NODE) {
		return node.nodeValue || "";
	} else if (node.nodeType === node.ELEMENT_NODE) {
		var tag = ["a", "text"].indexOf(node.localName) != -1 ? node.localName : "tspan";
		var res = "<" + tag,
			closeTag = "</" + tag + ">",
			styles = [];
		if (context.newline && tag === "tspan") {
			res += ' x="0" dy="1.2em"';
			context.newline = false;
		}
		switch (node.localName) {
			case "u":
				styles.push(["text-decoration", "underline"]);
				break;
			case "strike":
				styles.push(["text-decoration", "line-through"]);
				break;
		}

		res += _transformAttribute(node.attributes, styles) + ">";
		switch (node.localName) {
			case "a":
				res = '<tspan style="text-decoration: underline;">' + res + _transformChilds(node, context) + closeTag + "</tspan>";
				break;
			default:
				res += _transformChilds(node, context) + closeTag;
				break;
		}

		context.newline = context.newline || node.localName === "p";
		return res;
	}
	return "";
}

function _transformChilds(node, context) {
	var res = "",
		child;
	for (var i = 0, len = node.childNodes.length; i < len; ++i) {
		child = node.childNodes[i];
		res += _transform(child, context);
	}
	return res;
}

function _transformAttribute(list, styles) {
	var attrs = [],
		str = "",
		name, a, att;

	styles = styles || [];
	for (var i = 0, len = list.length; i < len; ++i) {
		att = list[i];
		name = att.localName;
		a = styleMap[name];
		if (a) {
			styles.push([a, att.value]);
		}
		a = attribMap[name];
		if (a) {
			attrs.push([a, att.value]);
		}
	}

	if (styles.length > 0) {
		str = styles.reduce(function(res, e) {
			var unit = "";
			if (e[0] === "font-size") unit = "px";
			return res + e[0] + ":" + e[1] + unit + "; ";
		}, ' style="');
		str += '"';
	}
	return attrs.reduce(function(res, e) {
		return res + " " + e[0] + '="' + e[1] + '"';
	}, str);
}

function _convertTextformat(node) {
	switch (node.nodeType) {
		case 1:
			// ELEMENT_NODE
			switch (node.nodeName) {
				case "p":
					break;
			}
			return "";
		case 3:
			// TEXT_NODE
			return node.nodeValue.replace(/\s\s/g, " &nbsp;");
	}
	for (var i = 0, len = node.childNodes.length; i < len; ++i) {
		_convertTextformat(node.childNodes[i]);
	}
}

exports.createText = function(xprop, arge2) {
	var foreignobj = $('<foreignObject>');
	foreignobj.attr('x', xprop.xcaptionPos.xleft + 'px').attr('y', xprop.xcaptionPos.xtop + 'px').attr('width', xprop.xcaptionSize.xwidth + 'px').attr('height', (xprop.xcaptionSize.xheight + 20) + 'px');
	var body = $('<body>').attr('xmlns', "http://www.w3.org/1999/xhtml");
	var style = '';
	if (xprop.xshadowProps.xtype === 'global') style += 'text-shadow: silver 5px 5px 3px;';

	style += "vertical-align: " + xprop.xcaptionProps.xvertAlignMode + ";";
	style += 'line-height: 1.2;';
	var stdiv = "<div style='" + style + "'>";

	var textobj = $(stdiv + xprop.xtext + "</div>");

	var fonts = textobj.find('font');
	var i;
	for (i = fonts.length; i > 0; i--)
		_replaceFont(fonts[i - 1]);

	var paragraphs = textobj.find('p');
	for (i = 0; i < paragraphs.length; i++) {
		_replaceParagraph(i, paragraphs[i], xprop);
	}

	var textformats = textobj.find('textformat');
	textformats.each(_removeTextformat);

	_convertWhitespaces(textobj[0]);

	body.html(textobj[0].outerHTML);
	body.appendTo(foreignobj);

	return foreignobj[0].outerHTML;
};

function appendLineMarkers(xprop, parent) {
	var markertype, filled;
	if (xprop.xstrokeProps.xstart) {
		markertype = xprop.xstrokeProps.xstart.xtype;
		filled = xprop.xstrokeProps.xstart.xfilled;

		if (markertype != 'none' && markertype != 'noarrow') {
			appendLineMarkers(xprop, parent, markertype, filled, 'start');
		}
	}

	if (xprop.xstrokeProps.xend) {
		markertype = xprop.xstrokeProps.xend.xtype;
		filled = xprop.xstrokeProps.xend.xfilled;

		if (markertype != 'none' && markertype != 'noarrow') {
			appendLineMarkers(xprop, parent, markertype, filled, 'end');
		}
	}

}

function updateLine(xprop, line, markertype, startend) {
	if (markertype == 'none' || markertype == 'noarrow') return;
	var spreadfactor = 0.5;
	var sz = 2 * xprop.xstrokeProps.xthickness + 11;
	var point1x, point1y, point3x, point3y;
	var x1, x2, y1, y2, angle;
	var endx, endy;

	x1 = xprop.xanchors[0].x;
	x2 = xprop.xanchors[2].x;
	y1 = xprop.xanchors[0].y;
	y2 = xprop.xanchors[2].y;
	angle = Math.atan2(y2 - y1, x2 - x1);
	switch (markertype) {
		case 'arr1':
		case 'arr2':
		case 'diamond1':
			if (startend == 'end') {
				if (markertype == 'arr1' || markertype == 'arr2') {
					point1x = x2 - Math.cos(angle + spreadfactor) * sz;
					point1y = y2 - Math.sin(angle + spreadfactor) * sz;
					point3x = x2 - Math.cos(angle - spreadfactor) * sz;
					point3y = y2 - Math.sin(angle - spreadfactor) * sz;
				}

				if (markertype == 'arr1') {
					endx = (point1x + point3x) / 2;
					endy = (point1y + point3y) / 2;
				} else if (markertype == 'arr2') {
					endx = x2 - Math.cos(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
					endy = y2 - Math.sin(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
				} else if (markertype == 'diamond1') {
					endx = x2 - Math.cos(angle) * sz / 2;
					endy = y2 - Math.sin(angle) * sz / 2;
				}
				line.attr('x2', endx).attr('y2', endy);

			} else if (startend == 'start') {
				if (markertype == 'arr1' || markertype == 'arr2') {
					point1x = x1 + Math.cos(angle + spreadfactor) * sz;
					point1y = y1 + Math.sin(angle + spreadfactor) * sz;
					point3x = x1 + Math.cos(angle - spreadfactor) * sz;
					point3y = y1 + Math.sin(angle - spreadfactor) * sz;

					if (markertype == 'arr1') {
						endx = Math.round((point1x + point3x) / 2);
						endy = Math.round((point1y + point3y) / 2);
					} else if (markertype == 'arr2') {
						endx = x1 + (Math.cos(angle) * xprop.xstrokeProps.xthickness / 2);
						endy = y1 + (Math.sin(angle) * xprop.xstrokeProps.xthickness / 2);
					}
				} else if (markertype == 'diamond1') {
					endx = x1 + Math.cos(angle) * sz / 2;
					endy = y1 + Math.sin(angle) * sz / 2;
				}
				line.attr('x1', endx).attr('y1', endy);
			}
			break;
		case 'disc1':
			var r = xprop.xstrokeProps.xthickness + 3;
			if (startend == 'end') {
				endx = x2 - Math.cos(angle) * r * 2;
				endy = y2 - Math.sin(angle) * r * 2;
				line.attr('x2', endx).attr('y2', endy);
			} else if (startend == 'start') {
				endx = x1 + Math.cos(angle) * r * 2;
				endy = y1 + Math.sin(angle) * r * 2;
				line.attr('x1', endx).attr('y1', endy);
			}
	}
}