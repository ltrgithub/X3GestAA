"use strict";

var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var Article = require("syracuse-ui/lib/article/article").Article;
var locale = require('syracuse-core/lib/locale');
var imagesRoot = "/syracuse-ui/themes/desktop/sage/process/images";
var libInfoRoot = "/syracuse-ui/lib/field";

var debug = false;
// Default values are the English one
var _localize = {};

function appendSvg(nom, attributs) {
	var svg = document.createElementNS("http://www.w3.org/2000/svg", nom);
	for (var cle in attributs) {
		var valeur = attributs[cle];
		svg.setAttribute(cle, valeur);
	}
	/*var appendices = this.length;
      for (var i = 0; i < appendices; i++)
      {
              this[i].appendChild(svg);
      }*/
	return svg;
}

function RecordArticle() {}

exports.RecordArticle = helpers.defineClass(RecordArticle, Article, {
	drawBox: function() {
		var slot = document.createElement("div");
		slot.style.display = "none";
		this.page.loadNewItem(this.boxParent.layoutSlot.appendChild(slot), {
			$category: "menus",
			$isMenusBag: true
		}, this);
	},
});

function ProcessPlayer() {}

exports.ProcessPlayer = helpers.defineClass(ProcessPlayer, null, {
	init: function($$div, /* options,*/ fld) {
		_localize = locale.resources(module)();
		var opt = {};
		this.$$div = $$div;
		this.uuid = $$div.attr("id");
		this.field = fld;
		this.layoutSlot = document.createElement("div");
		this.$$layoutSlot = $(this.layoutSlot).appendTo($$div);
		return this;
	},
	showErrors: function(messages) {
		this.field.showErrors(messages, {
			"noViewer": true
		});
	},
	loadProcess: function(process) {
		this.process = process.$data;
		this.info = process.$info;
		this._loadBibMapping();
		//this.$$layoutSlot.css('height', this.process.contentSize.xheight + 'px').css('width', this.process.contentSize.xwidth + 'px').css('top', this.process.docDims.xtop).css('left', this.process.docDims.xtop);
	},
	_loadBibMapping: function() {
		if (this.bibMapping != null) return;
		var libsinfo = this.info && this.info.libsinfo,
			bibMapping = {};

		libsinfo && libsinfo.forEach(function(lib) {
			lib.biblist && lib.biblist.forEach(function(bib) {
				bibMapping[bib.bibid] = bib;
			});
		});

		this.bibMapping = bibMapping;
	},

	// Retrieve "$links" from prototype
	show: function() {
		function _execLink(link, fld) {
			var context = {};
			var links = {};
			context.link = {
				$item: {
					$links: {
						$onlylink: link
					}
				}
			};
			debug && console.log("ProcessPlayer._execLink: link.id=" + context.id);
			link && _executeRecordMenu(context, fld);
		}

		function _executeRecordMenu(context, fld) {
			var item = context.link.$item;
			var recordArticle;
			if (!fld.recordArticle) {
				fld.recordArticle = new RecordArticle();
				//fld.recordArticle.$prototype=fld.$item ;
				fld.recordArticle.$prototype = fld.articleParent.$prototype || {};
				fld.page.initializeNewItem(fld.recordArticle, {}, fld);
				fld.recordArticle.loadBox(item);
			} else {
				fld.recordArticle.applyChange(item);
			}
			var menuItem = fld.recordArticle.menuItems[Object.keys(item["$links" || "$actions"])[0]][0];
			debug && console.log("ProcessPlayer._executeRecordMenu: url=" + menuItem.$url);
			menuItem.click();
		}

		var bibMapping = this.bibMapping;

		function getStroke(xprop) {
			return (xprop.xstrokeProps.xtype === 'none' || xprop.xstrokeProps.xtype === 'nostroke') ? //
			'none' : //
			getHexadecimalColor(xprop.xstrokeProps.xcolor);
		}

		function getStrokeDashArray(xprop) {

			if (xprop.xstrokeProps.xtype === 'dottedstroke') {
				return 2 * xprop.xstrokeProps.xthickness + ',' + 2 * xprop.xstrokeProps.xthickness;
			} else if (xprop.xstrokeProps.xtype === 'dashedstroke') {
				return 5 * xprop.xstrokeProps.xthickness + ',' + 5 * xprop.xstrokeProps.xthickness;
			} else {
				return '';
			}
		}

		function getFill(xprop) {
			if (xprop.xfillProps.xtype === 'nofill') return 'none';
			else if (xprop.xfillProps.xtype === 'solidfill') return getHexadecimalColor(xprop.xfillProps.xcolor);
			else if (xprop.xfillProps.xtype === 'gradientfill') return 'url(#grad' + xprop.uniqueID + ')';
			else if (xprop.xfillProps.xtype === 'patternfill') return 'url(#pattern' + xprop.uniqueID + ')';
		}

		function setStyles(shape, xprop) {
			shape.attr('stroke', getStroke(xprop));
			shape.attr('stroke-opacity', xprop.xstrokeProps.xalpha / 100);
			shape.attr('stroke-width', xprop.xstrokeProps.xthickness);
			shape.attr('stroke-dasharray', getStrokeDashArray(xprop));
			shape.attr('fill', getFill(xprop));
			shape.attr('fill-opacity', xprop.xfillProps.xalpha / 100);
		}

		function encodeLink(link) {
			if (link && link.xcode && link.xtype === "url") {
				link.xcode = $("<div/>").html(link.xcode).text();
			}
			return encodeURIComponent(JSON.stringify(link));
		}

		function decodeLink(str) {
			return tryParse(decodeURIComponent(str));
		}

		function tryParse(json) {
			try {
				return JSON.parse(json);
			} catch (e) {
				throw new Error("Failed to parse " + json + "\n[" + e.message + "]");
			}
		}

		function createShape(xprop) {
			function compare_float_func(a, b) {
				// Must return :
				// -1 if a < b
				//  0 if a = b
				//  1 if a > b
				return parseFloat(a) - parseFloat(b);
			}
			if (xprop.xshapeType === 'apishape' || xprop.xshapeType === 'beziershape') {
				if (xprop.xfillProps.xtype === 'gradientfill') {
					defs += createGradient(xprop);
				} else if (xprop.xfillProps.xtype === 'patternfill') {
					defs += createPattern(xprop);
				}
			}

			if (xprop.xshadowProps.xtype === 'global') defs += createShadow(xprop);

			var shape;
			var parent;
			var markers = '';
			switch (xprop.xshapeType) {
				case 'apishape':

					var centerx, centery, width, height;
					var xcoords = [];
					var ycoords = [];
					var w, h, i;
					var angle;
					for (var j = 0; j < 4; j++) {
						xcoords.push(xprop.xanchors[j].x);
					}
					xcoords.sort(compare_float_func);

					for (i = 0; i < 4; i++) {
						ycoords.push(xprop.xanchors[i].y);
					}
					ycoords.sort(compare_float_func);
					var apirotation;

					switch (xprop.xdrawBehaviorCode) {
						case "K_API_LINE":
							shape = $('<line>');

							shape.attr("x1", xprop.xanchors[0].x).attr("y1", xprop.xanchors[0].y) //
							.attr("x2", xprop.xanchors[2].x).attr("y2", xprop.xanchors[2].y);
							shape.attr("stroke-linecap", "square");

							var markertype, filled;
							if (xprop.xstrokeProps.xstart) {
								markertype = xprop.xstrokeProps.xstart.xtype;
								filled = xprop.xstrokeProps.xstart.xfilled;

								if (markertype != 'none' && markertype != 'noarrow') {
									markers += createLineMarker(xprop, markertype, filled, 'start', shape);
								}
							}

							if (xprop.xstrokeProps.xend) {
								markertype = xprop.xstrokeProps.xend.xtype;
								filled = xprop.xstrokeProps.xend.xfilled;

								if (markertype != 'none' && markertype != 'noarrow') {
									markers += createLineMarker(xprop, markertype, filled, "end", shape);

								}
							}
							break;

						case "K_API_RECT":
							shape = $('<rect>');
							angle = Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, //
								xprop.xanchors[1].x - xprop.xanchors[0].x);

							centerx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;
							centery = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;

							width = Math.sqrt( //
								(xprop.xanchors[1].x - xprop.xanchors[0].x) * //
								(xprop.xanchors[1].x - xprop.xanchors[0].x) + //
								(xprop.xanchors[1].y - xprop.xanchors[0].y) * //
								(xprop.xanchors[1].y - xprop.xanchors[0].y) //
							);
							height = Math.sqrt( //
								(xprop.xanchors[3].x - xprop.xanchors[0].x) * //
								(xprop.xanchors[3].x - xprop.xanchors[0].x) + //
								(xprop.xanchors[3].y - xprop.xanchors[0].y) * //
								(xprop.xanchors[3].y - xprop.xanchors[0].y) //
							);

							shape.attr("x", centerx - width / 2).attr("y", centery - height / 2) //
							.attr("width", width).attr("height", height);
							w = centerx + width / 2 + Math.cos(angle) * xprop.xstrokeProps.xthickness / 2;
							h = centery + height / 2 + Math.sin(angle) * xprop.xstrokeProps.xthickness / 2;
							if (w > csize.x) csize.x = w;
							if (h > csize.y) csize.y = h;
							break;

						case "K_API_ELLIPSE":
							angle = Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, //
								xprop.xanchors[1].x - xprop.xanchors[3].x);

							shape = $('<ellipse>');

							var rx = Math.sqrt((xprop.xanchors[2].x - xprop.xanchors[0].x) * (xprop.xanchors[2].x - xprop.xanchors[0].x) + //
								(xprop.xanchors[2].y - xprop.xanchors[0].y) * (xprop.xanchors[2].y - xprop.xanchors[0].y)) / 2;

							var ry = Math.sqrt((xprop.xanchors[1].x - xprop.xanchors[3].x) * (xprop.xanchors[1].x - xprop.xanchors[3].x) + //
								(xprop.xanchors[1].y - xprop.xanchors[3].y) * (xprop.xanchors[1].y - xprop.xanchors[3].y)) / 2;

							var cx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;
							var cy = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;
							shape.attr('cx', cx).attr('cy', cy).attr('rx', rx).attr('ry', ry);
							w = cx + rx + Math.cos(angle) * xprop.xstrokeProps.xthickness / 2;
							h = cy + ry + Math.sin(angle) * xprop.xstrokeProps.xthickness / 2;
							if (w > csize.x) csize.x = w;
							if (h > csize.y) csize.y = h;

							break;
					}
					break;

				case 'beziershape':
					var xanchors = xprop.xanchors;
					var a = xanchors[0];
					if (!a) return; // we get this in fill test
					var d = 'M ' + a.x + ' ' + a.y;
					var len = xanchors.length + (xprop.xclosed ? 1 : 0);
					// control points are weaker than in flash - so I move them away by a factor of f
					// value is experimental.
					var f = 1.3;

					for (i = 1; i < len; i++) {
						var pa = a;
						a = xanchors[i % xanchors.length];
						var c2x = pa.x + f * (pa.c2x - pa.x);
						var c2y = pa.y + f * (pa.c2y - pa.y);
						var c1x = a.x + f * (a.c1x - a.x);
						var c1y = a.y + f * (a.c1y - a.y);
						d += ' C ' + c2x + ' ' + c2y + ' ' + c1x + ' ' + c1y + ' ' + a.x + ' ' + a.y;
					}
					if (xprop.xclosed) d += 'z';
					shape = $('<path>').attr('d', d);
					break;

				case 'clipshape':
				case 'fileshape':
					width = Math.sqrt( //
						(xprop.xanchors[1].x - xprop.xanchors[0].x) * (xprop.xanchors[1].x - xprop.xanchors[0].x) + //
						(xprop.xanchors[1].y - xprop.xanchors[0].y) * (xprop.xanchors[1].y - xprop.xanchors[0].y));
					height = Math.sqrt( //
						(xprop.xanchors[2].x - xprop.xanchors[1].x) * (xprop.xanchors[2].x - xprop.xanchors[1].x) + //
						(xprop.xanchors[2].y - xprop.xanchors[1].y) * (xprop.xanchors[2].y - xprop.xanchors[1].y));

					var imagedescr = '<image x="' + (xprop.xcenter.x - width / 2) + 'px" y="' + (xprop.xcenter.y - height / 2) + //
					'px" width="' + width + 'px" height="' + //
					height + 'px" preserveAspectRatio="none" id="' + //
					xprop.uniqueID + '" z-index="' + xprop.xlevel + '" xlink:href="' + //
					getHRef(xprop) + '"';
					// images don't display on Opera if we set externalResourcesRequired (after clearing cache).
					// So don't set it!
					// imagedescr += ' externalResourcesRequired="true"';
					if (xprop.xshadowProps.xtype == 'global') imagedescr += "filter='url(#shadow" + xprop.uniqueID + ")'";

					if (xprop.xlinkProps.xtype != 'none') {
						imagedescr += ' link="' + encodeLink(xprop.xlinkProps) + '"';
						//shape.attr('link', encodeLink(xprop.xlinkProps)) ;
					}
					imagedescr += '/>';
					return imagedescr;
			}

			if (xprop.xshapeType === 'apishape' || xprop.xshapeType === 'beziershape') {
				setStyles(shape, xprop);
			}
			if (xprop.xshapeType === 'beziershape') {

				if (xprop.xdrawBehaviorCode == "K_BZ_LINE") shape.attr('stroke-linecap', "square");
				else if (xprop.xstrokeProps.xtype === 'solidstroke') {
					shape.attr('stroke-linecap', "round");
					shape.attr('stroke-linejoin', "round");
					shape.attr('style', " border-style:none;");
				}

			}

			if (xprop.xshapeType === 'beziershape') {
				shape.attr('fill-rule', "evenodd");
			}

			/*if (xprop.xactionProps.trig) xprop.xactionProps.trig.forEach(function (value, index, array) {
                shape.addClass('trigger' + value);
            });
            if (xprop.xactionProps.targ) xprop.xactionProps.targ.forEach(function (value, index, array) {
                shape.addClass('target' + value);
            });*/
			if (xprop.xshadowProps.xtype == 'global') shape.attr('filter', "url(#shadow" + xprop.uniqueID + ")");

			if (xprop.xlinkProps.xtype != 'none') {
				shape.attr('link', encodeLink(xprop.xlinkProps));
			}

			return shape[0].outerHTML + markers;
		}

		function getRotate(xprop) {
			var centerx, centery;
			if (xprop.xshapeType === 'clipshape' || xprop.xshapeType === 'fileshape') {
				centerx = xprop.xcenter.x;
				centery = xprop.xcenter.y;
			} else if (xprop.xshapeType === 'apishape') {
				var xcoords = [];
				var ycoords = [];
				for (var j = 0; j < 4; j++) {
					xcoords.push(xprop.xanchors[j].x);
				}
				xcoords.sort(compare_float_func);
				centerx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;

				for (var i = 0; i < 4; i++) {
					ycoords.push(xprop.xanchors[i].y);
				}
				ycoords.sort(compare_float_func);

				centery = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;
			}

			var anglerad;
			if (xprop.xshapeType == "apishape" && xprop.xdrawBehaviorCode == "K_API_ELLIPSE") anglerad = Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, xprop.xanchors[2].x - xprop.xanchors[0].x);
			else if (xprop.xshapeType == "apishape" && xprop.xdrawBehaviorCode == "K_API_LINE") {

				return "";

			} else anglerad = Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, xprop.xanchors[1].x - xprop.xanchors[0].x);
			var angle = 180 * anglerad / Math.PI;

			var result = 'rotate(' + angle + ',' + centerx + ',' + centery + ') ';
			return result;
		}

		function getHRef(xprop) {
			var bib = getBib(xprop.bibid),
				src = '/syracuse-ui/themes/desktop/sage/process/images/' + bib.famSubpath + bib.catSubpath + bib.name + '/' + xprop.eltid;
			// extension was .svg but images don't display in Chrome and have the wrong size on FF with this setting
			// things look much better with the .png files.
			if (xprop.xshapeType == 'clipshape') src += '.png';
			return src;
		}

		function getBib(bibid) {
			var bib = bibMapping[bibid];
			return {
				name: (bib && bib.type == 'swflib' && bib.bibfilename && bib.bibfilename.replace(/\.swf/, "")) || "",
				catSubpath: (bib && bib.catsubpath) || "",
				famSubpath: (bib && bib.familysubpath) || ""
			};
		}

		function createAction(action, index, array) {

			function clickHdl() {
				var targ = $$layoutSlot.find('.target' + action.id);
				targ.css('display', 'block');
			}
			var trigger = $$layoutSlot.find('.trigger' + action.id);
			var targ;
			trigger.attr('pointer-events', 'visible');
			/*trigger.hover(function () {
                    $(this).css('cursor', 'pointer');
                }, function () {
                    $(this).css('cursor', 'default');
                });*/
			trigger.css('cursor', 'pointer');
			switch (action.type) {
				case 'shotip':
					$$layoutSlot.find('.target' + action.id).hide();
					trigger.mouseover(function(e) {
						$$layoutSlot.find('.target' + action.id).css('display', 'block');
					});
					trigger.mouseout(function(e) {
						$$layoutSlot.find('.target' + action.id).css('display', 'none');
					});

					break;
				case 'sho':
					targ = $$layoutSlot.find('.target' + action.id);
					var isHideTarget = false;
					array.forEach(function(a, index, array) {
						if (a.type === 'hid' && targ.is('.target' + a.id)) isHideTarget = true;
					});
					if (!isHideTarget) targ.hide();
					trigger.click(function() {
						$$layoutSlot.find('.target' + action.id).show();
					});
					break;

				case 'shopopmenu':
					targ = $$layoutSlot.find('.target' + action.id);
					targ.hide();

					trigger.click(clickHdl);
					$$layoutSlot.click(function(e) {

						var parenttrigger = $(e.target).parents().filter(function(idx, el) {
							if ($(el).is('.trigger' + action.id)) return true;
						});
						var parenttarget = $(e.target).parents().filter(function(idx, el) {
							if ($(el).is('.target' + action.id)) return true;
						});

						if (!($(e.currentTarget).is('.trigger' + action.id)) && parenttrigger.size() === 0 && !($(e.currentTarget).is('.target' + action.id)) && parenttarget.size() === 0) {
							targ.hide();
						}
					});
					break;
				case 'hid':
					trigger.click(function() {
						$$layoutSlot.find('.target' + action.id).hide();
					});
					break;
				case 'shohid':
					trigger.click(function() {
						var targ = $$layoutSlot.find('.target' + action.id);
						var hidden = (targ.css('display') == 'none'); //(target.attr('display') == 'none');
						if (hidden) targ.css('display', 'block');
						else targ.css('display', 'none');
					});

					break;
				case 'shoallpopmenu':
					trigger.click(function(e) {
						array.forEach(function(a, index, array) {
							if (a.type === "shopopmenu") {
								var targets = $$layoutSlot.find('.target' + a.id); //+':hidden') ;
								var trig = $$layoutSlot.find('.trigger' + a.id);

								targets.each(function(index, el) {
									var hidden = ($(el).css('display') == 'none');
									if (hidden) {
										trig.unbind('click', clickHdl);
										$(el).css('display', 'block');
									} else {
										trig.bind('click', clickHdl);
										$(el).css('display', 'none');
									}

								});
							}
						});
						e.stopPropagation();
					});

					break;
			}

		}

		function constructLinksObj(params) {

			var obj = {},
				baseUrl = self.field.articleParent.$prototype.$baseUrl;
			switch (params.xtype) {


				case 'url':
					obj.$type = "application/json;vnd.sage=syracuse";
					obj.$url = params.xcode;
					break;
					/*
				case 'erpfunc':
					obj.$type = "application/json;vnd.sage=syracuse";
					obj.$title = params.xlabel;
					obj.$url = baseUrl.replace(/\/(\w+)\/(.*)/, "/trans/$2") + "/$sessions?f=" + params.xcode + "/2//M/" + params.xparam2;
					break;

				case 'url':
					obj.$type = "application/json;vnd.sage=syracuse";
					obj.$url = params.xcode;
					break;

				case 'page':
					obj.$type = "application/json;vnd.sage=syracuse";
					obj.$title = params.xlabel;
					obj.$url = baseUrl + "/PROCESS('" + params.xcode + "')?representation=PROCESS~" + params.xcode + ".$details";
					break;

				case 'syrapedia':
					obj.$type = "application/json;vnd.sage=syracuse";
					obj.$title = params.xlabel;
					obj.$url = baseUrl + "/" + params.xcode + "?representation=" + params.xcode + ".$" + params.xkey;
					break;
				*/

				default:
					//_localize = locale.resources(module)();
					self.showErrors([locale.format(module, "incorrectLinkType", params.xtype)]);
			}
			/*if (params.xtarget === "blank") {
				obj.$target = "blank";
			}*/
			if (params.xtarget != null) {
				obj.$target = params.xtarget;
			}
			return obj;
		}

		function manageLink(index, el) {

			var href = $(el).attr('href'),
				children = $(el).contents(),
				next = $(el).next(),
				uri_decoded = decodeURIComponent(href),
				uri = uri_decoded && uri_decoded.replace("asfunction:_global.ShapeLabelURLClicked,", ""),
				linksobj = constructLinksObj(tryParse(uri));
			// var next = $(el).next();
			if (next.length === 0) {
				$(el).parent().append(children);
			} else {
				next.before(children);
			}
			$(el).remove();
			if (!linksobj) {
				self.showErrors([locale.format(_localize.linkNotSupported, uri)]);
			} else {
				children && children.bind('click', function(e) {
					_execLink(linksobj, self.field);
				});
				children.css('cursor', 'pointer');
			}
		}

		function addLink(index, el) {
			//el.bind('click', function (e) {
			var href = $(el).attr('link');
			var params = decodeLink(href);
			$(el).removeAttr('link');

			var linksobj = constructLinksObj(params);
			var g = $(el).closest('g.link');
			g.click(function(e) { /*this. */
				_execLink(linksobj, self.field);
			});
			g.css('cursor', 'pointer');

			if (browsertype.msie) {
				var divtext = $$layoutSlot.find("div#" + $(el).attr('id') + 'p');
				divtext.bind('click', function(e) { /* this.*/
					_execLink(linksobj, self.field);
				});
				divtext.css('cursor', 'pointer');
			}

			g.attr('pointer-events', 'visible');
		}

		function makeClassAssignment(act, type) {
			return function(value, index, array) {
				act.addClass(type + value);
			};
		}

		var browsertype = $.browser;
		try {

			var self = this,
				$$layoutSlot = this.$$layoutSlot,
				layers = self.process && self.process.layersArr;
			var actions = (self.process.acts.a) ? self.process.acts.a : [];
			var csize = {
				x: self.process.contentSize.xwidth,
				y: self.process.contentSize.xheight
			};
			//var csize=getLargestContentSize() ;
			var result = "";
			var defs = '<defs>';
			var gn, group, i, sizeG;

			for (gn = 0, sizeG = layers.length; gn < sizeG; gn++) {
				group = layers[gn];

				for (i = 0; i < group.xpropsArr.length; i++) {

					var shapedescr = createShape(group.xpropsArr[i]);
					var rotation;
					if (group.xpropsArr[i].xshapeType == "apishape" && group.xpropsArr[i].xdrawBehaviorCode == "K_API_ELLIPSE") {
						rotation = (Math.atan2(group.xpropsArr[i].xanchors[2].y - group.xpropsArr[i].xanchors[0].y, //
							group.xpropsArr[i].xanchors[2].x - group.xpropsArr[i].xanchors[0].x) !== 0);
					} else if (group.xpropsArr[i].xshapeType == "clipshape" || (group.xpropsArr[i].xshapeType == "apishape" && group.xpropsArr[i].xdrawBehaviorCode != "K_API_LINE")) {
						rotation = (Math.atan2(group.xpropsArr[i].xanchors[1].y - group.xpropsArr[i].xanchors[0].y, //
							group.xpropsArr[i].xanchors[1].x - group.xpropsArr[i].xanchors[0].x) !== 0);
					}

					var ttext = '';
					if (group.xpropsArr[i].xlinkProps.xtype != 'none') {
						result += '<g class="link">';
					}

					if (group.xpropsArr[i].xactionProps.targ || group.xpropsArr[i].xactionProps.trig) {
						//result += '<g>';
						var gact = $('<g>');
						if (group.xpropsArr[i].xactionProps.targ) {
							group.xpropsArr[i].xactionProps.targ.forEach(makeClassAssignment(gact, "target"));
						}
						if (group.xpropsArr[i].xactionProps.trig) {
							group.xpropsArr[i].xactionProps.trig.forEach(makeClassAssignment(gact, "trigger"));
						}
						var gacthtml = gact[0].outerHTML;
						result += gacthtml.replace(/<\/g>/, "");
					}
					if (rotation) {
						result += '<g transform="' + getRotate(group.xpropsArr[i]) + '">';

					}

					result += shapedescr;
					if (rotation) {
						result += '</g>';
					}

					if (group.xpropsArr[i].xtext != "") {

						if (!browsertype.msie) {
							//console.log ("Internet Explorer") ;
							ttext = createText(group.xpropsArr[i], rotation);
							result += ttext;
						}
					}

					if (group.xpropsArr[i].xlinkProps.xtype != 'none') {
						result += '</g>';
					}

					if (group.xpropsArr[i].xactionProps.targ || group.xpropsArr[i].xactionProps.trig) {
						result += '</g>';
					}

				}

			}
			defs += '</defs>';
			var svgdescr = '<svg  xmlns="http://www.w3.org/TR/SVG11/" width="' + csize.x + 'px" height="' + csize.y + 'px"> ' + defs + result + '</svg>';
			//var svgtest='<svg xmlns="http://www.w3.org/TR/SVG11/" width="' + csize.x +'px" height="' + csize.y + 'px">'+ defs+result+'</svg>' ;
			//var svgf=$(svgtest) ;
			//$$layoutSlot.append(svgf);
			//var svgplot =  document.createNS("http://www.w3.org/2000/svg",svg)
			var svgplot = $(svgdescr);
			$$layoutSlot.append(svgplot);

			if (browsertype.msie) {
				//create the texts as div elements
				for (gn = 0, sizeG = layers.length; gn < sizeG; gn++) {
					group = layers[gn];

					for (i = 0; i < group.xpropsArr.length; i++) {
						if (group.xpropsArr[i].xtext != '') {
							appendText(group.xpropsArr[i], $$layoutSlot);
						}
					}
				}
			}

			actions.forEach(createAction);

			var textlinks = $$layoutSlot.find('a');
			textlinks.each(manageLink);

			var links = svgplot.find('*[link]');
			links.each(addLink);

		} catch (e) {
			throw e;
		}

		return this;
	},

	clear: function() {
		this.$$layoutSlot.empty();
		this.process = {};
		return this;
	},
	dispose: function() {
		this.process = null;
		this.field = null;
		// AJouter la method dispose dans ProcessPlayer
	}
});

/*
 * Montre / Cache pop up modal
 */

function showPopUp(divID) {
	// $("#" + divID).jqm({
	//  overlay: 10,
	//  modal: true
	// });
	// $("#" + divID).jqmShow();
	// $("#" + divID).addClass("montrer");
}

//Récupère le code hexadecimal de la couleur à partir du code décimal

function getHexadecimalColor(str) {
	if (typeof str == 'undefined') {
		str = 0;
	}
	var hex = Number(str).toString(16);
	hex = "#000000".substr(0, 7 - hex.length) + hex;
	return hex.toUpperCase();
}

function getGradientTransVector(alpha) {
	// l'angle de rotation est calculé par rapport au centre de la xprop, on considére donc ce point comme centre de notre graphe
	// le repère est orthonormée de longueur max 50 (la fenetre graphique éMath.tant de longueur et largeur 100)
	var x1, x2, y1, y2;

	//traitement cas spéciaux
	var margeArrondi = Math.PI / 100;
	if (!alpha || isEqual(alpha, 2 * Math.PI)) {
		x2 = 50;
		y2 = 0;
	} else if (isEqual(alpha, Math.PI / 2)) {
		x2 = 0;
		y2 = 50;
	} else if (isEqual(alpha, Math.PI)) {
		x2 = -50;
		y2 = 0;
	} else if (isEqual(alpha, 3 * Math.PI / 2)) {
		x2 = 0;
		y2 = -50;
	} else {
		x2 = 50 * Math.cos(alpha);
		y2 = 50 * Math.sin(alpha);
	}

	//calcul de x1 y1 en fonction de x2, y2. x1 et y1 sont opposé par rapport à l'origine
	x1 = -x2;
	y1 = -y2;
	// calcul pour basculer en coordonnées grphique (origine en haut a gauche)
	x1 += 50;
	y1 += 50;
	x2 += 50;
	y2 += 50;
	return {
		x1: x1,
		y1: y1,
		x2: x2,
		y2: y2
	};
}

function replaceFont(el) {
	var $el = $(el),
		size = $el.attr('size') ? 'font-size:' + $el.attr('size') + 'px;' : '',
		face = $el.attr('face') ? 'font-family:' + $el.attr('face') + ';' : '',
		color = $el.attr('color') ? 'color:' + $el.attr('color') + ';' : '';
	$el.replaceWith('<span style="' + size + face + color + '">' + $el.html() + '</span>');
}

function replaceParagraph(index, el, xprop) {
	var $el = $(el),
		alignement = $el.attr('align');
	var textformat = $el.parents().filter('textformat');

	if ( /*index === 0 ||*/ textformat.length === 0) {
		$el.replaceWith('<div style="text-align: ' + alignement + '; margin-left:' + xprop.xtextFormat.leftMargin + 'px; margin-right:' + xprop.xtextFormat.rightMargin + 'px;">' + $el.html() + '</div>');
	} else {
		$el.replaceWith('<div style="text-align: ' + alignement + '; margin-left:' + xprop.xtextFormat.leftMargin + 'px; margin-right:' + xprop.xtextFormat.rightMargin + 'px;">' + $el.html() + '</br></div>');
	}
}

function removeTextformat(index, el) {
	var $el = $(el),
		parent = $el.parent();
	var contents = $el.contents();
	parent.append(contents);
	$el.remove();
}

function convertWhitespaces(node) {
	if (node.nodeType == 3) {
		var str = node.nodeValue.replace(/\s\s/g, " &nbsp;");
		$(node).wrap('<textformat>');
		var parent = $(node).parent();
		parent.html(str);
	} else {
		for (var i = 0, len = node.childNodes.length; i < len; ++i) {
			convertWhitespaces(node.childNodes[i]);
		}
	}
}

function appendText(forme, cont) {
	var text = "";
	var shadow = '';
	if (forme.xshadowProps.xtype === 'global') shadow = 'text-shadow: silver 5px 5px 3px;';

	var div = $('<div>');
	div.attr('id', forme.uniqueID + 'p');
	div.attr('style', 'position:absolute; left:' + //
		forme.xcaptionPos.xleft + //
		'px; top:' + top + 'px;width: ' + //
		(forme.xcaptionSize.xwidth) + //
		'px; height: ' + (forme.xcaptionSize.xheight + 10) + 'px; ' + shadow + "vertical-align:" + //
		forme.xcaptionProps.xvertAlignMode + '; z-index:' + //
		forme.xlevel //
	);

	div.html(forme.xtext);
	var fonts = div.find('font');
	var i;
	for (i = fonts.length; i > 0; i--) {
		replaceFont(fonts[i - 1]);
	}

	var paragraphs = div.find('p');
	for (i = 0; i < paragraphs.length; i++) {
		replaceParagraph(i, paragraphs[i], forme);
	}
	var textformats = div.find('textformat');
	textformats.each(removeTextformat);

	convertWhitespaces(div[0]);
	cont.append(div);

	if (forme.xactionProps.targ || forme.xactionProps.trig) {

		if (forme.xactionProps.targ) {
			forme.xactionProps.targ.forEach(function(value, index, array) {

				div.addClass('target' + value);
			});
		}
		if (forme.xactionProps.trig) {
			forme.xactionProps.trig.forEach(function(value, index, array) {

				div.addClass('trigger' + value);
			});
		}
	}

	/*var textformat = divtext.find('textformat');
 var font = textformat.find('p>font');

 var a = font.selectAll('a').each(function() {
  $(this).attr('href', parseLien($(this).attr("href")))
 });
 text += font.html() + '<br />';*/

}

function createText(xprop) {


	var foreignobj = $('<foreignObject>');

	foreignobj.attr('x', xprop.xcaptionPos.xleft + 'px').attr('y', xprop.xcaptionPos.xtop + 'px') //
	.attr('width', xprop.xcaptionSize.xwidth + 'px') //
	.attr('height', (xprop.xcaptionSize.xheight + 20) + 'px');

	var body = $('<body>').attr('xmlns', "http://www.w3.org/1999/xhtml");
	var shadow = '';
	if (xprop.xshadowProps.xtype === 'global') shadow = 'text-shadow: silver 5px 5px 3px;';

	var stdiv = "<div style='" + shadow + "vertical-align:" + xprop.xcaptionProps.xvertAlignMode + ";'>";

	var textobj = $(stdiv + xprop.xtext + "</div>");

	var fonts = textobj.find('font');
	var i;
	for (i = fonts.length; i > 0; i--)
		replaceFont(fonts[i - 1]);

	var paragraphs = textobj.find('p');
	for (i = 0; i < paragraphs.length; i++) {
		replaceParagraph(i, paragraphs[i], xprop);
	}

	var textformats = textobj.find('textformat');
	textformats.each(removeTextformat);

	convertWhitespaces(textobj[0]);

	body.html(textobj[0].outerHTML);
	body.appendTo(foreignobj);

	return foreignobj[0].outerHTML;
}

function compare_float_func(a, b) {
	return parseFloat(a) - parseFloat(b);
}

function isEqual(a, b) {
	var epsilon = 0.000000000001;
	if ((a - b) < epsilon && (b - a) < epsilon) return true;
	else return false;
}

function appendLineMarkers(xprop, parent) {
	var markertype, filled;
	if (xprop.xstrokeProps.xstart) {
		markertype = xprop.xstrokeProps.xstart.xtype;
		filled = xprop.xstrokeProps.xstart.xfilled;

		if (markertype != 'none' && markertype != 'noarrow') {
			appendLineMarkers(xprop, parent, markertype, filled, 'start');
		}
	}

	if (xprop.xstrokeProps.xend) {
		markertype = xprop.xstrokeProps.xend.xtype;
		filled = xprop.xstrokeProps.xend.xfilled;

		if (markertype != 'none' && markertype != 'noarrow') {
			appendLineMarkers(xprop, parent, markertype, filled, 'end');
		}
	}

}

function updateLine(xprop, line, markertype, startend) {
	if (markertype == 'none' || markertype == 'noarrow') return;
	var spreadfactor = 0.5;
	var sz = 2 * xprop.xstrokeProps.xthickness + 11;
	var point1x, point1y, point3x, point3y;
	var x1, x2, y1, y2, angle;
	var endx, endy;

	x1 = xprop.xanchors[0].x;
	x2 = xprop.xanchors[2].x;
	y1 = xprop.xanchors[0].y;
	y2 = xprop.xanchors[2].y;
	angle = Math.atan2(y2 - y1, x2 - x1);
	switch (markertype) {
		case 'arr1':
		case 'arr2':
		case 'diamond1':
			if (startend == 'end') {
				if (markertype == 'arr1' || markertype == 'arr2') {
					point1x = x2 - Math.cos(angle + spreadfactor) * sz;
					point1y = y2 - Math.sin(angle + spreadfactor) * sz;
					point3x = x2 - Math.cos(angle - spreadfactor) * sz;
					point3y = y2 - Math.sin(angle - spreadfactor) * sz;
				}

				if (markertype == 'arr1') {
					endx = (point1x + point3x) / 2;
					endy = (point1y + point3y) / 2;
				} else if (markertype == 'arr2') {
					endx = x2 - Math.cos(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
					endy = y2 - Math.sin(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
				} else if (markertype == 'diamond1') {
					endx = x2 - Math.cos(angle) * sz / 2;
					endy = y2 - Math.sin(angle) * sz / 2;
				}
				line.attr('x2', endx).attr('y2', endy);

			} else if (startend == 'start') {
				if (markertype == 'arr1' || markertype == 'arr2') {
					point1x = x1 + Math.cos(angle + spreadfactor) * sz;
					point1y = y1 + Math.sin(angle + spreadfactor) * sz;
					point3x = x1 + Math.cos(angle - spreadfactor) * sz;
					point3y = y1 + Math.sin(angle - spreadfactor) * sz;

					if (markertype == 'arr1') {
						endx = Math.round((point1x + point3x) / 2);
						endy = Math.round((point1y + point3y) / 2);
					} else if (markertype == 'arr2') {
						endx = x1 + (Math.cos(angle) * xprop.xstrokeProps.xthickness / 2);
						endy = y1 + (Math.sin(angle) * xprop.xstrokeProps.xthickness / 2);
					}
				} else if (markertype == 'diamond1') {
					endx = x1 + Math.cos(angle) * sz / 2;
					endy = y1 + Math.sin(angle) * sz / 2;
				}
				line.attr('x1', endx).attr('y1', endy);
			}
			break;
		case 'disc1':
			var r = xprop.xstrokeProps.xthickness + 3;
			if (startend == 'end') {
				endx = x2 - Math.cos(angle) * r * 2;
				endy = y2 - Math.sin(angle) * r * 2;
				line.attr('x2', endx).attr('y2', endy);
			} else if (startend == 'start') {
				endx = x1 + Math.cos(angle) * r * 2;
				endy = y1 + Math.sin(angle) * r * 2;
				line.attr('x1', endx).attr('y1', endy);
			}
	}
}

function createLineMarker(xprop, markertype, filled, startend, line) {
	var marker;
	var sz = 2 * xprop.xstrokeProps.xthickness + 11;
	var x1, x2, y1, y2, angle, anglePoint;

	x1 = xprop.xanchors[0].x;
	x2 = xprop.xanchors[2].x;
	y1 = xprop.xanchors[0].y;
	y2 = xprop.xanchors[2].y;

	angle = Math.atan2(y2 - y1, x2 - x1);
	anglePoint = Math.PI / 2 - angle;
	switch (markertype) {
		case 'arr1':
		case 'arr2':
		case 'diamond1':

			var spreadfactor = 0.5;
			var point1x, point1y, point2x, point2y, point3x, point3y, point4x, point4y, endx, endy;
			var centerx, centery;
			var halfthickness = xprop.xstrokeProps.xthickness / 2;
			if (startend == 'end') {
				if (markertype == 'arr1' || markertype == 'arr2') {
					point1x = x2 - Math.cos(angle + spreadfactor) * sz;
					point1y = y2 - Math.sin(angle + spreadfactor) * sz;
					point3x = x2 - Math.cos(angle - spreadfactor) * sz;
					point3y = y2 - Math.sin(angle - spreadfactor) * sz;
					point2x = x2;
					point2y = y2;

					if (markertype == 'arr1') {
						endx = (point1x + point3x) / 2;
						endy = (point1y + point3y) / 2;
					} else if (markertype == 'arr2') {
						endx = x2 - Math.cos(angle) * halfthickness;
						endy = y2 - Math.sin(angle) * halfthickness;
					}
				} else if (markertype == 'diamond1') {
					centerx = x2 - Math.cos(angle) * sz / 2;
					centery = y2 - Math.sin(angle) * sz / 2;
					point1x = centerx + Math.cos(anglePoint) * sz / 2;
					point1y = centery - Math.sin(anglePoint) * sz / 2;
					point2x = x2 - Math.cos(angle) * sz;
					point2y = y2 - Math.sin(angle) * sz;
					point3x = centerx - Math.cos(anglePoint) * sz / 2;
					point3y = centery + Math.sin(anglePoint) * sz / 2;
					point4x = x2;
					point4y = y2;
					endx = centerx;
					endy = centery;
				}
				line.attr('x2', endx).attr('y2', endy);
			} else if (startend == 'start') {
				if (markertype == 'arr1' || markertype == 'arr2') {
					point1x = x1 + Math.cos(angle + spreadfactor) * sz;
					point1y = y1 + Math.sin(angle + spreadfactor) * sz;
					point3x = x1 + Math.cos(angle - spreadfactor) * sz;
					point3y = y1 + Math.sin(angle - spreadfactor) * sz;
					point2x = x1;
					point2y = y1;
					if (markertype == 'arr1') {
						endx = (point1x + point3x) / 2;
						endy = (point1y + point3y) / 2;
					} else if (markertype == 'arr2') {
						endx = x1 + (Math.cos(angle) * halfthickness);
						endy = y1 + (Math.sin(angle) * halfthickness);
					}
				} else if (markertype == 'diamond1') {

					centerx = x1 + Math.cos(angle) * sz / 2;
					centery = y1 + Math.sin(angle) * sz / 2;
					point1x = centerx - Math.cos(anglePoint) * sz / 2;
					point1y = centery + Math.sin(anglePoint) * sz / 2;
					point2x = x1 + Math.cos(angle) * sz;
					point2y = y1 + Math.sin(angle) * sz;
					point3x = centerx + Math.cos(anglePoint) * sz / 2;
					point3y = centery - Math.sin(anglePoint) * sz / 2;
					point4x = x1;
					point4y = y1;
					endx = centerx;
					endy = centery;
				}
				line.attr('x1', endx).attr('y1', endy);
			}

			marker = $('<path>').attr('d', function() {
				var pathdescr = 'M ' + point1x + ' ' + point1y + ' L ' + point2x + ' ' + point2y + ' L ' + point3x + ' ' + point3y;
				if (markertype == 'diamond1') pathdescr += ' L ' + point4x + ' ' + point4y;
				if (markertype == 'arr1' || markertype == 'diamond1') pathdescr += ' z';

				return pathdescr;
			});

			marker.attr('stroke', function() {
				return getHexadecimalColor(xprop.xstrokeProps.xcolor);
			});
			marker.attr('stroke-width', function() {
				if (markertype == 'arr2') return xprop.xstrokeProps.xthickness;
				else return 1;
			});
			if (markertype == 'arr2') {
				marker.attr('stroke-linecap', 'round');
				marker.attr('stroke-linejoin', 'round');
			}

			marker.attr('stroke-opacity', xprop.xstrokeProps.xalpha / 100);

			marker.attr('fill', function() {
				if (markertype == 'diamond1' || markertype == 'arr1') {
					if (filled) return getHexadecimalColor(xprop.xstrokeProps.xcolor);
					else return '#FFFFFF';
				} else return 'none';
			});

			break;

		case 'disc1':

			var r, cx, cy;

			r = xprop.xstrokeProps.xthickness + 3;
			if (startend == 'end') {
				cx = x2 - Math.cos(angle) * r;
				cy = y2 - Math.sin(angle) * r;
				endx = x2 - Math.cos(angle) * r * 2;
				endy = y2 - Math.sin(angle) * r * 2;
				line.attr('x2', endx).attr('y2', endy);
			} else if (startend == 'start') {
				cx = x1 + Math.cos(angle) * r;
				cy = y1 + Math.sin(angle) * r;
				endx = x1 + Math.cos(angle) * r * 2;
				endy = y1 + Math.sin(angle) * r * 2;
				line.attr('x1', endx).attr('y1', endy);
			}
			marker = $('<circle>').attr('cx', cx).attr('cy', cy).attr('r', r);
			marker.attr('stroke', function() {
				return getHexadecimalColor(xprop.xstrokeProps.xcolor);
			});
			marker.attr('fill', function() {
				if (filled) return getHexadecimalColor(xprop.xstrokeProps.xcolor);
				else return '#FFFFFF';
			});

			break;
	}
	return marker[0].outerHTML;
}

function createPattern(xprop) {

	function updateWidthAndHeight() {
		$('.' + this.name).attr('width', this.width).attr('height', this.height);
		return true;
	}

	var res;

	var tmpmage = new Image();
	tmpmage.src = "/syracuse-ui/themes/desktop/sage/process/images/patterns/" + xprop.xfillProps.xpatLinkId + ".gif";
	tmpmage.name = xprop.xfillProps.xpatLinkId;
	tmpmage.onload = updateWidthAndHeight;

	/*var image = $('<image >');//http://www.w3.org/2000/svg
    image.attr('xlink:href', "/syracuse-ui/themes/desktop/sage/process/images/patterns/" + xprop.xfillProps.xpatLinkId + ".gif");
    image.attr('class', xprop.xfillProps.xpatLinkId)
    image.attr('x', '0') //
    .attr('y', '0') //
    .attr('width', 0) //
    .attr('height', 0);
    var pattern = $('<pattern>').attr('id', 'pattern' + xprop.uniqueID).attr('class', xprop.xfillProps.xpatLinkId) //
    .attr('patternUnits', "userSpaceOnUse");
    pattern.attr('x', '0') //
    .attr('y', '0') //
    .attr('width', 0) //
    .attr('height', 0);
    res = pattern[0].outerHTML;
    res = res.replace(/<\/pattern>/, image[0].outerHTML + "</pattern>");*/

	res = '<pattern id="pattern' + xprop.uniqueID + '" class="' + xprop.xfillProps.xpatLinkId + '" patternUnits="userSpaceOnUse" x="0" y="0" width="0" height="0">';
	res += '<image xlink:href="/syracuse-ui/themes/desktop/sage/process/images/patterns/' + xprop.xfillProps.xpatLinkId + '.gif"';
	res += 'class="' + xprop.xfillProps.xpatLinkId + '" x="0" y="0" width="0" height="0"/>';
	res += "</pattern>";
	return res;
}

function createGradient(xprop) {
	function stops() {

		var stopset = "";

		for (var j = 0; j < xprop.xfillProps.xgcolors.length; j++) {
			var d;

			var newratio = xprop.xfillProps.xgratios[j] * 100 / 255;
			var stop = $('<stop>').attr('offset', newratio + '%'); /*Math.cos(xprop.xfillProps.xgrotation)*/
			stop.attr('style', 'stop-color:' + getHexadecimalColor(xprop.xfillProps.xgcolors[j]) + '; stop-opacity:' + xprop.xfillProps.xgalphas[j] / 100);
			stopset += stop[0].outerHTML;
		}
		return stopset;
	}

	var grad;
	var res;
	switch (xprop.xfillProps.xgtype) {
		case 'linear':
			var tabCoord = getGradientTransVector(xprop.xfillProps.xgrotation);
			grad = $('<lineargradient>').attr('id', 'grad' + xprop.uniqueID) //
			.attr('x1', tabCoord.x1 + '%') //
			.attr('y1', tabCoord.y1 + '%') //
			.attr('x2', tabCoord.x2 + '%') //
			.attr('y2', tabCoord.y2 + '%');
			res = grad[0].outerHTML;
			var st = stops();
			res = res.replace(/<\/lineargradient>/, st + "</lineargradient>");
			//var pos=lastIndexOf("</lineargradient>");
			break;
		case 'radial':
			//TODO les 50% c'ets codé en dur
			grad = $('<radialgradient>').attr('id', 'grad' + xprop.uniqueID) //
			.attr('cx', '50%') //
			.attr('cy', '50%') //
			.attr('r', '50%') //
			.attr('fx', '50%') //
			.attr('fy', '50%');
			res = grad[0].outerHTML;
			res = res.replace(/<\/radialgradient>/, stops() + "</radialgradient>");
			break;
	}
	return res;
}

function createShadow(xprop) {
	var res = '<filter id="shadow' + xprop.uniqueID + '">';
	//$('<filter>').attr('id',xprop.uniqueID) ;
	var feOffset = $('<feOffset>').attr('in', "SourceAlpha").attr('dx', "3").attr('dy', "3").attr("result", "offOut");
	res += feOffset[0].outerHTML;
	var feGaussianBlur = $('<feGaussianBlur>').attr('in', "offOut").attr('stdDeviation', "3").attr("result", "blurred");
	res += feGaussianBlur[0].outerHTML;
	var feBlend = $('<feBlend>').attr('in', "SourceGraphic").attr('in2', "blurred").attr("mode", "normal");
	res += feBlend[0].outerHTML;

	/*<filter id="shadow"+xprop.uniqueID x="0" y="0" width="200%" height="200%">
<feOffset in="SourceAlpha" dx="5" dy="5" result="offOut"/>
<feGaussianBlur in="offOut" stdDeviation="3" result="blurred"/>
<feBlend in="SourceGraphic" in2="blurred" mode="normal" />

</filter>*/

	return res += '</filter>';
}