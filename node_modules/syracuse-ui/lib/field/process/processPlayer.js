"use strict";

//var d3 = require("syracuse-ui/deps/d3");
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
require('syracuse-ui/lib/field/process/jquery.contextMenu');
require('syracuse-ui/deps/jqModal/jqModal');
var Article = require("syracuse-ui/lib/article/article").Article;

var debug = true;
var imagesRoot = "/syracuse-ui/themes/desktop/sage/process/images",
    libInfoRoot = "/syracuse-ui/lib/field";


function appendSvg(nom, attributs) {
    var svg = document.createElementNS("http://www.w3.org/2000/svg", nom);
    for (var cle in attributs) {
        var valeur = attributs[cle];
        svg.setAttribute(cle, valeur);
    }
/*var appendices = this.length;
      for (var i = 0; i < appendices; i++)
      {
              this[i].appendChild(svg);
      }*/
    return svg;
}

function RecordArticle() {};

exports.RecordArticle = helpers.defineClass(RecordArticle, Article, {
    drawBox: function() {
		var slot = document.createElement("div");
        slot.style.display = "none";
        this.page.loadNewItem(this.boxParent.layoutSlot.appendChild(slot), {
            $category: "menus",
			$isMenusBag : true
        }, this);
    },
});


function ProcessPlayer() {};

exports.ProcessPlayer = helpers.defineClass(ProcessPlayer, null, {
    init: function($$div, /* options,*/ fld) {
        var self = this;
        this.$$div = $$div;
        //this.options = options;
        this.uuid = $$div.attr("id");
        this.field = fld;

        var $$page = $('<div>').attr("id", "page").appendTo($$div);
        this.layoutSlot = $(this.$$layoutSlot = $$page);

        var technicPart = '<div id="fenetreTechnique" class="s-process-hidden s-process-fenetreImportExport">   \
    <div id="entetedivflottantFT"></div>    \
    <div id="DivDockToolBar" class="s-process-DivDockToolBar">    \
    <div id="menuprincipal" class="s-process-menuprincipal">    \
    <a id="titreMenuPrincipal" class="s-process-titreMenuPrincipal">Fichier</a>  \
    </div>  \
    </div>  \
    <div id="divSousMenu class="s-process-divSousMenu">  \
    <a class="sousMenuItem" id="importLink">Importer...</a> \
    <a class="sousMenuItem" id="exportLink">Exporter en texte...</a>    \
    </div>  \
    </div>';
        $(technicPart).appendTo($$div);

        // <!--pop-up "fenêtre Exporter"-->
        var exportPopup = '<div id="export" class="s-process-fenetreImportExport s-process-hidden"> \
    <div id="enteteExport" class="s-process-enteteFenetreImportExport"></div> \
    <p>Vos donn&eacute;es :</p> \
    <div>   \
    <textarea id="textAreaExport" class="s-process-textAreaImportExport"></textarea>  \
    </div>  \
    <div>   \
    <button id="btnValiderExport" class="s-process-btnFT">OK</button> \
    </div>  \
    </div>';
        $(exportPopup).appendTo($$div);

        // <!-- pop up message et traces -->
        var messagePopup = '<div id="msgEtTraces" class="s-process-hidden">   \
    <div id="enteteMsgEtTraces" class="s-process-enteteMsgEtTraces">    \
    <div id="titreMsgEtTraces" class="s-process-left"> Vos messages </div>    \
    <div id="divFermer" class="s-process-left"><img id="imageFermerMessageTrace" src="' + imagesRoot + '/fermer.png" width="20" height="20" alt="fermer"> </div> \
    <div style="clear:both"></div>  \
    </div>  \
    <div>   \
    <div id="divTextAreaMsgEtTraces" class="s-process-left">  \
    <textarea  id="textAreaMsgEtTraces" class="s-process-textAreaMsgEtTraces" readonly="readonly"></textarea> \
    </div>  \
    <div id="actions" class="s-process-left"> \
    <div class="s-process-divAction" id="btnMsg"> Messages </div> \
    <div class="s-process-divAction" id="btnDetail"> Détail </div>    \
    <div class="s-process-divAction" id="btnTrace"> Trace </div>  \
    <div class="s-process-divAction" id="btnCopier"> Copier </div>    \
    </div>  \
    <div style="clear:both"></div>  \
    </div>  \
    </div>';
        $(messagePopup).appendTo($$div);

        // <!-- pop up echange de donnees -->
        var exchangePopup = '<div id="divCadreEchangesDeDonnees" class="s-process-hidden s-process-divCadreEchangesDeDonnees">    \
    <div id="divContenuEchangesDeDonnees" class="s-process-divContenuEchangesDeDonnees">  \
    <textarea  id="textAreaContenuEchangesDeDonnees" class="s-process-textAreaContenuEchangesDeDonnees" readonly="readonly"></textarea>    \
    </div>  \
    </div>';
        $(exchangePopup).appendTo($$div);

        var contextMenu = '<ul id="myMenu" class="s-process-contextMenu"> \
    <li ><a href="#echangeDonnee">Echanges de donnees</a></li>  \
    <li class="cut"><a href="#messageEtTrace">Messages et trace</a></li>    \
    <li class="copy separator"><a href="#fenetreTechnique">Montrer/cacher fenetre technique</a></li>    \
    </ul>';
        $(contextMenu).appendTo($$div);

        /*******************************************************
         * Chargement du contenu de la page en JSon dans le pop up "exporter"
         *******************************************************/
        $("#exportLink").click(function(event) {
            showPopUp('export');
            $('#textAreaExport').text(options.process && options.process.getJson());
            $('#textAreaExport').select();
        });

        /*******************************************************
         * Affichage du popup "import"
         *******************************************************/
        $('#importLink').click(function(event) {
            showPopUp('import');
        });

        /*******************************************************
         * Fermeture de la fenêtre message et trace avec un click sur l'image de fermeture
         *******************************************************/
        $("#imageFermerMessageTrace").hover(function() {
            $(this).attr('src', imagesRoot + '/fermerHover.png');
        }, function() {
            $(this).attr('src', imagesRoot + '/fermer.png');
        }).click(function() {
            $("#msgEtTraces").toggle();
        });

        /*******************************************************
         * Gestion du menu de la fenetre technique
         *******************************************************/
        $("#menuprincipal").click(function(event) {

            if ($("#menuprincipal").hasClass('orangebackground')) {
                $("#menuprincipal").removeClass('orangebackground');
            } else {
                $("#menuprincipal").addClass('orangebackground');
                $("#divSousMenu").toggle();

                //empeche le declenchement du listener qui suit
                event.stopPropagation();

                //Ajout d'un listener de click sur toute la page qui ferme le menu      
                $('#body').bind('click', function() {
                    $("#menuprincipal").removeClass('orangebackground');
                    $("#divSousMenu").toggle();
                    //suppression du listener une fois celui ci utilisé
                    $('#body').unbind('click');
                });
            }
        });

        /*******************************************************
         * Gestion des boutons de importer/exporter
         *******************************************************/
        $("#btnValiderExport").click(function() {
            $('#export').jqmHide();
            $('#export').removeClass('montrer');
        });
        $("#btnAnnulerImport").click(function() {
            $('#import').jqmHide();
            $('#import').removeClass('montrer');
        });
        $('textarea').disableContextMenu();

        /*******************************************************
         * Gestion de l'import quand on entre le json à la main
         *******************************************************/
        $('#btnValiderImport').click(function() {
            // on recupere le json … 
            var jsonTxt = $('#textAreaImport').val();
            if (jsonTxt !== "") {
                // … et on le charge
                self.options.process && self.options.process.loadJson(jsonTxt);
                // on verifie ensuite que le json est importé, pour vérifier qu'il n'avait pas d'erreur.
                // donc getJson() doit renvoyé le même contenu que l'import
                self.options.process && self.options.process.loadJson(jsonTxt);
                if (self.options.process && (self.options.process.getJson() == jsonTxt)) {

                    // et on affiche tous les nouveaux
                    self.clear().show();
                    // sageInitPage($.sageJSON.getPageInfo()).sageDisplayPlayer($.sageJSON.getFormes());
                    // on vide le textarea 
                    $('#textAreaImport').val('');

                    // et on ferme la fenêtre     
                    $('#import').jqmHide();
                    $('#import').removeClass('montrer');

                } else {

                    // si ça ne correspond pas, on affiche un petit popup
                    alert("Le JSON importé n'est pas valide");
                }
            }
        });

        /*******************************************************
         * Fenetre echange de données
         *******************************************************/
        //Cacher la fenetre echange de donnée avec un clic sur la bordure
        $("#divContenuEchangesDeDonnees").click(function(event) {
            event.stopPropagation();
        });
        $("#divCadreEchangesDeDonnees").click(function() {
            $("#divCadreEchangesDeDonnees").hide();
        });

        /*******************************************************
         * Definition des draggable pour les popups
         *******************************************************/
        $("#msgEtTraces").draggable({
            containment: "body",
            scroll: false,
            handle: "#titreMsgEtTraces"
        });
        $("#fenetreTechnique").draggable({
            containment: "body",
            scroll: false
        });
        $("#import").draggable({
            containment: "body",
            scroll: false,
            handle: "#enteteImport"
        });
        $("#export").draggable({
            containment: "body",
            scroll: false,
            handle: "#enteteExport"
        });

        //$$page.css('height', pageInfoJson.contentSize.xheight + 'px').css('width', pageInfoJson.contentSize.xwidth + 'px').css('top', pageInfoJson.docDims.xtop).css('left', pageInfoJson.docDims.xtop);
        return this;
    },

    loadProcess: function(process) {
        this.process = process.$data;
        this.info = process.$info;
        this._loadBibMapping();
        this.$$layoutSlot.css('height', this.process.contentSize.xheight + 'px').css('width', this.process.contentSize.xwidth + 'px').css('top', this.process.docDims.xtop).css('left', this.process.docDims.xtop);
    },

    _loadBibMapping: function() {
        if (this.bibMapping != null) return;
        var libsinfo = this.info && this.info.libsinfo,
            bibMapping = {};

        libsinfo && libsinfo.forEach(function(lib) {
            lib.biblist && lib.biblist.forEach(function(bib) {
                bibMapping[bib.bibid] = bib;
            });
        });

        this.bibMapping = bibMapping;
    },


    // Retrieve "$links" from prototype

    show: function() {
        function _execLink(link, fld) {
            var context = {
                //id: link.id
            };
            var debug = true;
            /*if (typeof link === "string") {
            var links = this._getLinks();
            link = links && this._getMenuItem(links[link]);
            }*/
            var links={} ;
            context.link = { $item : { $links : {$onlylink  : link}}};
            //debug && console.log("ProcessPlayer._execLink: link.id=" + context.id);
            link && /*this. */
            _executeRecordMenu(context, fld);
        }

        /*function _getMenuItem(link) {
            var links = {},
                $link = links[link.id] = objectClone(link.link);

            // $link.$url = this.formatMenuUrl($link);
            return link && {
                $item: {
                    $links: links
                }
            };
        }*/

        function _executeRecordMenu(context, fld) {
            var item = context.link.$item;
            var recordArticle;
            if (!fld.recordArticle) {
                fld.recordArticle = new RecordArticle();
                //fld.recordArticle.$prototype=fld.$item ;
				fld.recordArticle.$prototype= fld.articleParent.$prototype ||{};
                fld.page.initializeNewItem(fld.recordArticle, {}, fld);
                fld.recordArticle.loadBox(item);
            } else {
                fld.recordArticle.applyChange(item);
            }
            var menuItem = fld.recordArticle.menuItems[Object.keys(item["$links" || "$actions"])[0]][0];
            debug && console.log("ProcessPlayer._executeRecordMenu: url=" + menuItem.$url );
            menuItem.click();
        }


        var bibMapping = this.bibMapping;

        function getStroke(xprop) {
            return (xprop.xstrokeProps.xtype === 'none' || xprop.xstrokeProps.xtype === 'nostroke') //
            ? 'none' : getHexadecimalColor(xprop.xstrokeProps.xcolor);
        }

        function getStrokeDashArray(xprop) {

            if (xprop.xstrokeProps.xtype === 'dottedstroke') {
                return 2 * xprop.xstrokeProps.xthickness + ',' + 2 * xprop.xstrokeProps.xthickness;
            } else if (xprop.xstrokeProps.xtype === 'dashedstroke') {
                return 5 * xprop.xstrokeProps.xthickness + ',' + 5 * xprop.xstrokeProps.xthickness;
            } else {
                return '';
            }
        }

        function getFill(xprop) {
            if (xprop.xfillProps.xtype === 'nofill') return 'none';
            else if (xprop.xfillProps.xtype === 'solidfill') return getHexadecimalColor(xprop.xfillProps.xcolor);
            else if (xprop.xfillProps.xtype === 'gradientfill') return 'url(#grad' + xprop.uniqueID + ')';
            else if (xprop.xfillProps.xtype === 'patternfill') return 'url(#pattern' + xprop.uniqueID + ')';
        }


        function setStyles(shape, xprop) {
            shape.attr('stroke', getStroke(xprop));
            shape.attr('stroke-opacity', xprop.xstrokeProps.xalpha / 100);
            shape.attr('stroke-width', xprop.xstrokeProps.xthickness);
            shape.attr('stroke-dasharray', getStrokeDashArray(xprop));
            shape.attr('fill', getFill(xprop));
        }

        function stringifyLink(link) {
            if (link && link.xcode && link.xtype === "url") {
                link.xcode = $("<div/>").html(link.xcode).text();
            }
            return JSON.stringify(link);
        }

        function createShape(xprop) {
            function compare_float_func(a, b) {
                // Elle doit retourner :
                // -1 si a < b
                //  0 si a = b
                //  1 si a > b
                return parseFloat(a) - parseFloat(b)
            }
            if (xprop.xshapeType === 'apishape' || xprop.xshapeType === 'beziershape') {
                if (xprop.xfillProps.xtype === 'gradientfill') defs += createGradient(xprop);
            }
            if (xprop.xshapeType === 'apishape' || xprop.xshapeType === 'beziershape') {
                if (xprop.xfillProps.xtype === 'patternfill') defs += createPattern(xprop);
            }

            if (xprop.xshadowProps.xtype === 'global') defs += createShadow(xprop);

            var shape;
            var parent;
            var markers = '';

            switch (xprop.xshapeType) {
            case 'apishape':


                var centerx, centery, width, height;
                var xcoords = [];
                var ycoords = [];
                for (var j = 0; j < 4; j++) {
                    xcoords.push(xprop.xanchors[j].x);
                }
                xcoords.sort(compare_float_func);


                for (var i = 0; i < 4; i++) {
                    ycoords.push(xprop.xanchors[i].y);
                }
                ycoords.sort(compare_float_func);
                var apirotation;

                switch (xprop.xdrawBehaviorCode) {
                case "K_API_LINE":
                    shape = $('<line>');


                    shape.attr("x1", xprop.xanchors[0].x).attr("y1", xprop.xanchors[0].y) //
                    .attr("x2", xprop.xanchors[2].x).attr("y2", xprop.xanchors[2].y);
                    shape.attr("stroke-linecap", "square");

                    var markertype, filled;
                    if (xprop.xstrokeProps.xstart) {
                        markertype = xprop.xstrokeProps.xstart.xtype;
                        filled = xprop.xstrokeProps.xstart.xfilled;

                        if (markertype != 'none' && markertype != 'noarrow') {
                            markers += createLineMarker(xprop, markertype, filled, 'start', shape);
                        }
                    }

                    if (xprop.xstrokeProps.xend) {
                        markertype = xprop.xstrokeProps.xend.xtype;
                        filled = xprop.xstrokeProps.xend.xfilled;

                        if (markertype != 'none' && markertype != 'noarrow') {
                            markers += createLineMarker(xprop, markertype, filled, "end", shape);

                        }
                    }
                    break;
                case "K_API_RECT":
                    shape = $('<rect>');
                    var angle = Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, //
                    xprop.xanchors[1].x - xprop.xanchors[0].x);


                    centerx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;
                    centery = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;

                    width = Math.sqrt( //
                    (xprop.xanchors[1].x - xprop.xanchors[0].x) * //
                    (xprop.xanchors[1].x - xprop.xanchors[0].x) + //
                    (xprop.xanchors[1].y - xprop.xanchors[0].y) * //
                    (xprop.xanchors[1].y - xprop.xanchors[0].y) //
                    );
                    height = Math.sqrt( //
                    (xprop.xanchors[3].x - xprop.xanchors[0].x) * //
                    (xprop.xanchors[3].x - xprop.xanchors[0].x) + //
                    (xprop.xanchors[3].y - xprop.xanchors[0].y) * //
                    (xprop.xanchors[3].y - xprop.xanchors[0].y) //
                    );

                    shape.attr("x", centerx - width / 2).attr("y", centery - height / 2) //
                    .attr("width", width).attr("height", height);
                    var w = centerx + width / 2 + Math.cos(angle) * xprop.xstrokeProps.xthickness / 2;
                    var h = centery + height / 2 + Math.sin(angle) * xprop.xstrokeProps.xthickness / 2;
                    if (w > csize.x) csize.x = w;
                    if (h > csize.y) csize.y = h;

                    break;
                case "K_API_ELLIPSE":
                    var angle = Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, //
                    xprop.xanchors[1].x - xprop.xanchors[3].x);

                    shape = $('<ellipse>');

                    var rx = Math.sqrt((xprop.xanchors[2].x - xprop.xanchors[0].x) * (xprop.xanchors[2].x - xprop.xanchors[0].x) //
                    + (xprop.xanchors[2].y - xprop.xanchors[0].y) * (xprop.xanchors[2].y - xprop.xanchors[0].y)) / 2;

                    var ry = Math.sqrt((xprop.xanchors[1].x - xprop.xanchors[3].x) * (xprop.xanchors[1].x - xprop.xanchors[3].x) //
                    + (xprop.xanchors[1].y - xprop.xanchors[3].y) * (xprop.xanchors[1].y - xprop.xanchors[3].y)) / 2;

                    var cx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;
                    var cy = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;
                    shape.attr('cx', cx).attr('cy', cy).attr('rx', rx).attr('ry', ry);
                    var w = cx + rx + Math.cos(angle) * xprop.xstrokeProps.xthickness / 2;
                    var h = cy + ry + Math.sin(angle) * xprop.xstrokeProps.xthickness / 2;
                    if (w > csize.x) csize.x = w;
                    if (h > csize.y) csize.y = h;

                    break;
                };

                break;
            case 'beziershape':
                var xanchors = xprop.xanchors;
                var a = xanchors[0];
                if (!a) return; // we get this in fill test
                var d = 'M ' + a.x + ' ' + a.y;
                var len = xanchors.length + (xprop.xclosed ? 1 : 0);
                // control points are weaker than in flash - so I move them away by a factor of f
                // value is experimental.
                var f = 1.3;

                for (var i = 1; i < len; i++) {
                    var pa = a;
                    a = xanchors[i % xanchors.length];
                    var c2x = pa.x + f * (pa.c2x - pa.x);
                    var c2y = pa.y + f * (pa.c2y - pa.y);
                    var c1x = a.x + f * (a.c1x - a.x);
                    var c1y = a.y + f * (a.c1y - a.y);
                    d += ' C ' + c2x + ' ' + c2y + ' ' + c1x + ' ' + c1y + ' ' + a.x + ' ' + a.y;
                }
                if (xprop.xclosed) d += 'z';
                shape = $('<path>').attr('d', d);
                break;
            case 'clipshape':
            case 'fileshape':

                var width = Math.sqrt( //
                (xprop.xanchors[1].x - xprop.xanchors[0].x) * (xprop.xanchors[1].x - xprop.xanchors[0].x) //
                + (xprop.xanchors[1].y - xprop.xanchors[0].y) * (xprop.xanchors[1].y - xprop.xanchors[0].y));
                var height = Math.sqrt( //
                (xprop.xanchors[2].x - xprop.xanchors[1].x) * (xprop.xanchors[2].x - xprop.xanchors[1].x) //
                + (xprop.xanchors[2].y - xprop.xanchors[1].y) * (xprop.xanchors[2].y - xprop.xanchors[1].y));


                var imagedescr = '<image x="' + (xprop.xcenter.x - width / 2) //
                + 'px" y="' + (xprop.xcenter.y - height / 2) //
                + 'px" width="' + width + 'px" height="' //
                + height + 'px" preserveAspectRatio="none" id="' //
                + xprop.uniqueID + '" z-index="' + xprop.xlevel + '" xlink:href="' //
                + getHRef(xprop) + '" externalResourcesRequired="true"';

                if (xprop.xshadowProps.xtype == 'global') imagedescr += "filter='url(#shadow" + xprop.uniqueID + ")'";

                if (xprop.xlinkProps.xtype != 'none') {
                    imagedescr += "link='" + stringifyLink(xprop.xlinkProps) + "'";
                    //shape.attr('link', stringifyLink(xprop.xlinkProps)) ;
                }
                imagedescr += '/>'
                return imagedescr;

                break;
            }

            if (xprop.xshapeType === 'apishape' || xprop.xshapeType === 'beziershape') {
                setStyles(shape, xprop);
            }
            if (xprop.xshapeType === 'beziershape') {

                if (xprop.xdrawBehaviorCode == "K_BZ_LINE") shape.attr('stroke-linecap', "square");
                else if (xprop.xstrokeProps.xtype === 'solidstroke') {
                    shape.attr('stroke-linecap', "round");
                    shape.attr('stroke-linejoin', "round");
                    shape.attr('style', " border-style:none;");
                }

            }

            if (xprop.xshapeType === 'beziershape') {
                shape.attr('fill-rule', "evenodd");
            }

/*if (xprop.xactionProps.trig) xprop.xactionProps.trig.forEach(function (value, index, array) {
                shape.addClass('trigger' + value);
            });
            if (xprop.xactionProps.targ) xprop.xactionProps.targ.forEach(function (value, index, array) {
                shape.addClass('target' + value);
            });*/
            if (xprop.xshadowProps.xtype == 'global') shape.attr('filter', "url(#shadow" + xprop.uniqueID + ")");


            if (xprop.xlinkProps.xtype != 'none') {
                shape.attr('link', stringifyLink(xprop.xlinkProps));
            }

            return shape[0].outerHTML + markers;
        }


        function getRotate(xprop) {
            var centerx, centery;
            if (xprop.xshapeType === 'clipshape' || xprop.xshapeType === 'fileshape') {
                centerx = xprop.xcenter.x;
                centery = xprop.xcenter.y;
            } else if (xprop.xshapeType === 'apishape') {
                var xcoords = [];
                var ycoords = [];
                for (var j = 0; j < 4; j++) {
                    xcoords.push(xprop.xanchors[j].x);
                }
                xcoords.sort(compare_float_func);
                centerx = xcoords[0] + (xcoords[3] - xcoords[0]) / 2;

                for (var i = 0; i < 4; i++) {
                    ycoords.push(xprop.xanchors[i].y);
                }
                ycoords.sort(compare_float_func);

                centery = ycoords[0] + (ycoords[3] - ycoords[0]) / 2;
            }

            var anglerad;
            if (xprop.xshapeType == "apishape" && xprop.xdrawBehaviorCode == "K_API_ELLIPSE") anglerad = Math.atan2(xprop.xanchors[2].y - xprop.xanchors[0].y, xprop.xanchors[2].x - xprop.xanchors[0].x);
            else if (xprop.xshapeType == "apishape" && xprop.xdrawBehaviorCode == "K_API_LINE") {

                return "";

            } else anglerad = Math.atan2(xprop.xanchors[1].y - xprop.xanchors[0].y, xprop.xanchors[1].x - xprop.xanchors[0].x);
            var angle = 180 * anglerad / Math.PI;


            var result = 'rotate(' + angle + ',' + centerx + ',' + centery + ') ';
            return result;
        }

        function getHRef(xprop) {
            var bib = getBib(xprop.bibid),
                src = '/syracuse-ui/themes/desktop/sage/process/images/' + bib.famSubpath + bib.catSubpath + bib.name + '/' + xprop.eltid;
            if (xprop.xshapeType == 'clipshape') src += '.svg';
            return src;
        }

        function getBib(bibid) {
            var bib = bibMapping[bibid];
            return {
                name: (bib && bib.type == 'swflib' && bib.bibfilename && bib.bibfilename.replace(/\.swf/, "")) || "",
                catSubpath: (bib && bib.catsubpath) || "",
                famSubpath: (bib && bib.familysubpath) || ""
            };
        }


        function createAction(action, index, array) {

            function clickHdl() {
                var targ = $$layoutSlot.find('.target' + action.id)
                targ.css('display', 'block');
            }
            var trigger = $$layoutSlot.find('.trigger' + action.id);
            trigger.attr('pointer-events', 'visible');
/*trigger.hover(function () {
                    $(this).css('cursor', 'pointer');
                }, function () {
                    $(this).css('cursor', 'default');
                });*/
            trigger.css('cursor', 'pointer');
            switch (action.type) {
            case 'shotip':
                $$layoutSlot.find('.target' + action.id).hide();
                trigger.mouseover(function(e) {
                    $$layoutSlot.find('.target' + action.id).css('display', 'block');
                });
                trigger.mouseout(function(e) {
                    $$layoutSlot.find('.target' + action.id).css('display', 'none');
                });

                break;
            case 'sho':
                var targ = $$layoutSlot.find('.target' + action.id);
                var isHideTarget = false;
                array.forEach(function(a, index, array) {
                    if (a.type === 'hid' && targ.is('.target' + a.id)) isHideTarget = true;
                });
                if (!isHideTarget) targ.hide();
                trigger.click(function() {
                    $$layoutSlot.find('.target' + action.id).show();
                });
                break;

            case 'shopopmenu':
                var targ = $$layoutSlot.find('.target' + action.id);
                targ.hide();

                trigger.click(clickHdl);
                $$layoutSlot.click(function(e) {

                    var parenttrigger = $(e.target).parents().filter(function(idx, el) {
                        if ($(el).is('.trigger' + action.id)) return true;
                    });
                    var parenttarget = $(e.target).parents().filter(function(idx, el) {
                        if ($(el).is('.target' + action.id)) return true;
                    });

                    if (!($(e.currentTarget).is('.trigger' + action.id)) && parenttrigger.size() == 0 //
                    && !($(e.currentTarget).is('.target' + action.id)) && parenttarget.size() == 0) targ.hide();
                });
                break;
            case 'hid':
                trigger.click(function() {
                    $$layoutSlot.find('.target' + action.id).hide();
                });
                break;
            case 'shohid':
                trigger.click(function() {
                    var targ = $$layoutSlot.find('.target' + action.id);
                    var hidden = (targ.css('display') == 'none'); //(target.attr('display') == 'none');
                    if (hidden) targ.css('display', 'block');
                    else targ.css('display', 'none');
                });

                break;
            case 'shoallpopmenu':
                trigger.click(function(e) {
                    array.forEach(function(a, index, array) {
                        if (a.type === "shopopmenu") {
                            var targets = $$layoutSlot.find('.target' + a.id); //+':hidden') ;
                            var trig = $$layoutSlot.find('.trigger' + a.id);

                            targets.each(function(index, el) {
                                var hidden = ($(el).css('display') == 'none');
                                if (hidden) {
                                    trig.unbind('click', clickHdl);
                                    $(el).css('display', 'block');
                                } else {
                                    trig.bind('click', clickHdl);
                                    $(el).css('display', 'none');
                                }

                            });
                        }
                    });
                    e.stopPropagation();
                });

                break;
            }

        }


        function constructLinksObj(params) {

            var obj = {};
            switch (params.xtype) {

            case 'erpfunc':

                obj.$type = "application/json;vnd.sage=syracuse";
                obj.$title = params.xlabel;
                obj.$url = "/trans/x3/erp/SUPERV/$sessions?f=" + params.xcode + "/2//M/" + params.xparam2;
                obj.$method = "POST";

                return obj;
            case 'url':
                obj.$type = "application/json;vnd.sage=syracuse";
                obj.$url = params.xcode;
                return obj;

            case 'page':
                obj.$type = "application/json;vnd.sage=syracuse";
                obj.$title = params.xlabel;
                obj.$url = "/sdata/x3/erp/SUPERV/PROCESS('" + params.xcode+"')?representation=PROCESS~"+params.xcode+".$details";
                //obj.$method = "POST";
                return obj;
            
            case 'syrapedia' :
                obj.$type = "application/json;vnd.sage=syracuse";
                obj.$title = params.xlabel;
                obj.$url = "/sdata/x3/erp/SUPERV/" +params.xcode+"?representation="+params.xcode+".$"+params.xkey;
                //obj.$method = "POST";
                return obj ;
            }
        }

        function tryParse(json) {
            try {
                return JSON.parse(json);
            } catch (e) {
                throw new Error("Failed to parse " + json + "\n[" + e.message + "]");
            }
        }

        function manageLink(index, el) {

            var href = $(el).attr('href');
            var children = $(el).contents();
            var uri_decoded = decodeURIComponent(href);
            var next = $(el).next();
            if (next.length == 0) $(el).parent().append(children);
            else next.before(children);
            $(el).remove();
            children.bind('click', function(e) {
                var obj = {};
                var temp = uri_decoded.replace("asfunction:_global.ShapeLabelURLClicked,", "");
                var params = tryParse(temp);
                var linksobj = constructLinksObj(params); /*this.*/
                 _execLink(linksobj, self.field);
               // document.controller.openPage(self.field.boxParent.getArticle(), linksobj, null);
            });
            children.css('cursor', 'pointer');
        }


        function addLink(index, el) {
            //el.bind('click', function (e) {
            var href = $(el).attr('link');
            var params = tryParse(href);
            $(el).removeAttr('link');

            var linksobj = constructLinksObj(params);
            var g = $(el).closest('g.link');
            g.click(function(e) { /*this. */
                 _execLink(linksobj, self.field);
               // document.controller.openPage(self.field.boxParent.getArticle(), linksobj, null);
            });
            g.css('cursor', 'pointer');

            if (browsertype.msie) {
                var divtext = $$layoutSlot.find("div#" + $(el).attr('id') + 'p');
                divtext.bind('click', function(e) { /* this.*/
                     _execLink(linksobj, self.field);
                    //document.controller.openPage(self.field.boxParent.getArticle(), linksobj, null);
                });
                divtext.css('cursor', 'pointer');

            }

            g.attr('pointer-events', 'visible');
        }

        var browsertype = $.browser;
        try {

            var self = this,
                $$layoutSlot = this.$$layoutSlot,
                layers = self.process && self.process.layersArr;
            var actions = (self.process.acts.a) ? self.process.acts.a : [];
            var csize = {
                x: self.process.contentSize.xwidth,
                y: self.process.contentSize.xheight
            };
            //var csize=getLargestContentSize() ;
            var result = "";
            var defs = '<defs>';

            for (var gn = 0, sizeG = layers.length; gn < sizeG; gn++) {
                var group = layers[gn];

                for (var i = 0; i < group.xpropsArr.length; i++) {

                    var shapedescr = createShape(group.xpropsArr[i]);
                    var rotation;
                    if (group.xpropsArr[i].xshapeType == "apishape" && group.xpropsArr[i].xdrawBehaviorCode == "K_API_ELLIPSE") {
                        rotation = (Math.atan2(group.xpropsArr[i].xanchors[2].y - group.xpropsArr[i].xanchors[0].y, //
                        group.xpropsArr[i].xanchors[2].x - group.xpropsArr[i].xanchors[0].x) != 0);
                    } else if (group.xpropsArr[i].xshapeType == "clipshape" //
                    || (group.xpropsArr[i].xshapeType == "apishape" //
                    && group.xpropsArr[i].xdrawBehaviorCode != "K_API_LINE")) {
                        rotation = (Math.atan2(group.xpropsArr[i].xanchors[1].y - group.xpropsArr[i].xanchors[0].y, //
                        group.xpropsArr[i].xanchors[1].x - group.xpropsArr[i].xanchors[0].x) != 0);
                    }

                    var ttext = '';
                    if (group.xpropsArr[i].xlinkProps.xtype != 'none') {
                        result += '<g class="link">'
                    }

                    if (group.xpropsArr[i].xactionProps.targ //
                    || group.xpropsArr[i].xactionProps.trig) {
                        //result += '<g>';
                        var gact = $('<g>');
                        if (group.xpropsArr[i].xactionProps.targ) {
                            group.xpropsArr[i].xactionProps.targ.forEach(function(value, index, array) {
                                //shape.addClass('target' + value);
                                gact.addClass('target' + value);
                            });
                        }
                        if (group.xpropsArr[i].xactionProps.trig) {
                            group.xpropsArr[i].xactionProps.trig.forEach(function(value, index, array) {
                                gact.addClass('trigger' + value);
                            });
                        }
                        var gacthtml = gact[0].outerHTML;
                        result += gacthtml.replace(/<\/g>/, "");
                    }
                    if (rotation) {
                        result += '<g transform="' + getRotate(group.xpropsArr[i]) + '">';

                    }


                    result += shapedescr;
                    if (rotation) {
                        result += '</g>';
                    }

                    if (group.xpropsArr[i].xtext != "") {

                        if (!browsertype.msie) {
                            //console.log ("Internet Explorer") ;
                            ttext = createText(group.xpropsArr[i], rotation);
                            result += ttext;
                        }
                    }

                    if (group.xpropsArr[i].xlinkProps.xtype != 'none') {
                        result += '</g>';
                    }

                    if (group.xpropsArr[i].xactionProps.targ || group.xpropsArr[i].xactionProps.trig) {
                        result += '</g>';
                    }

                }

            }
            defs += '</defs>';
            var svgdescr = '<svg  xmlns="http://www.w3.org/TR/SVG11/" width="' + csize.x + 'px" height="' + csize.y + 'px"> ' + defs + result + '</svg>';
            //var svgtest='<svg xmlns="http://www.w3.org/TR/SVG11/" width="' + csize.x +'px" height="' + csize.y + 'px">'+ defs+result+'</svg>' ;
            //var svgf=$(svgtest) ;
            //$$layoutSlot.append(svgf);
            //var svgplot =  document.createNS("http://www.w3.org/2000/svg",svg)
            var svgplot = $(svgdescr);
            $$layoutSlot.append(svgplot);


            if (browsertype.msie) {
                //create the texts as div elements
                for (var gn = 0, sizeG = layers.length; gn < sizeG; gn++) {
                    var group = layers[gn];

                    for (var i = 0; i < group.xpropsArr.length; i++) {
                        if (group.xpropsArr[i].xtext != '') {
                            appendText(group.xpropsArr[i], $$layoutSlot);

                        }
                    }
                }
            }

            actions.forEach(createAction);

            var textlinks = $$layoutSlot.find('a');
            textlinks.each(manageLink);


            var links = svgplot.find('*[link]');
            links.each(addLink);


        } catch (e) {
            throw e;
        }


        return this;
    },

    clear: function() {
        this.$$layoutSlot.empty();
        this.process = {};
        return this;
    },
    dispose: function() {
        this.process = null;
        this.field = null;
        // AJouter la method dispose dans ProcessPlayer
    }
});

/*
 * Montre / Cache pop up modal
 */

function showPopUp(divID) {
    // $("#" + divID).jqm({
    //  overlay: 10,
    //  modal: true
    // });
    // $("#" + divID).jqmShow();
    // $("#" + divID).addClass("montrer");
}

//Récupère le code hexadecimal de la couleur à partir du code décimal

function getHexadecimalColor(str) {
    if (typeof str == 'undefined') {
        str = 0;
    }
    var hex = Number(str).toString(16);
    hex = "#000000".substr(0, 7 - hex.length) + hex;
    return hex.toUpperCase();
}


function getGradientTransVector(alpha) {
    // l'angle de rotation est calculé par rapport au centre de la xprop, on considére donc ce point comme centre de notre graphe
    // le repère est orthonormée de longueur max 50 (la fenetre graphique éMath.tant de longueur et largeur 100)
    var x1, x2, y1, y2;

    //traitement cas spéciaux
    var margeArrondi = Math.PI / 100;
    if (alpha == 0 || isEqual(alpha, 2 * Math.PI)) {
        x2 = 50;
        y2 = 0;
    } else if (isEqual(alpha, Math.PI / 2)) {
        x2 = 0;
        y2 = 50;
    } else if (isEqual(alpha, Math.PI)) {
        x2 = -50;
        y2 = 0;
    } else if (isEqual(alpha, 3 * Math.PI / 2)) {
        x2 = 0;
        y2 = -50;
    } else {
        x2 = 50 * Math.cos(alpha);
        y2 = 50 * Math.sin(alpha);
    }


    //calcul de x1 y1 en fonction de x2, y2. x1 et y1 sont opposé par rapport à l'origine
    x1 = -x2;
    y1 = -y2;
    // calcul pour basculer en coordonnées grphique (origine en haut a gauche)
    x1 += 50;
    y1 += 50;
    x2 += 50;
    y2 += 50;
    return {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
    };
}


function appendText(forme, cont) {

    function replaceFont(el) {

        var size = $(el).attr('size') ? 'font-size:' + $(el).attr('size') + 'px;' : '';
        var face = $(el).attr('face') ? 'font-family:' + $(el).attr('face') + ';' : '';
        var color = $(el).attr('color') ? 'color:' + $(el).attr('color') + ';' : '';
        $(el).replaceWith('<span style="' + size + face + color + '">' + $(el).html() + '</span>');
    }

    function replaceParagraph(index, el, xprop) {
        var alignement = $(el).attr('align');
        var textformat = $(el).parents().filter('textformat');


        if (index == 0 || textformat.length == 0) $(el).replaceWith('<div style="text-align: ' + alignement + '; margin-left:' + xprop.xtextFormat.leftMargin //
        + 'px; margin-right:' + xprop.xtextFormat.rightMargin + 'px;">' + $(el).html() + '</div>');
        else {
            $(el).replaceWith('<div style="text-align: ' + alignement + '; margin-left:' + xprop.xtextFormat.leftMargin //
            + 'px; margin-right:' + xprop.xtextFormat.rightMargin + 'px;">' + $(el).html() + '</br></div>');
        }

    }

    function removeTextformat(index, el) {
        var parent = $(el).parent();
        var contents = $(el).contents();
        parent.append(contents);
        $(el).remove();
    }


    function convertWhitespaces(node) {
        if (node.nodeType == 3) {
            var str = node.nodeValue.replace(/\s\s/g, "&nbsp;&nbsp;");
            $(node).wrap('<textformat>');
            var parent = $(node).parent();
            parent.html(str);
        } else {
            for (var i = 0, len = node.childNodes.length; i < len; ++i) {
                convertWhitespaces(node.childNodes[i]);
            }
        }
    }

    var text = "";
    var shadow = '';
    if (forme.xshadowProps.xtype === 'global') shadow = 'text-shadow: silver 5px 5px 3px;';

    var div = $('<div>');
    div.attr('id', forme.uniqueID + 'p');
    div.attr('style', 'position:absolute; left:' //
    + forme.xcaptionPos.xleft //
    + 'px; top:' + forme.xcaptionPos.xtop + 'px;width: ' //
    + (forme.xcaptionSize.xwidth) //
    + 'px; height: ' + (forme.xcaptionSize.xheight + 10) + 'px; ' + shadow + "vertical-align:" //
    + forme.xcaptionProps.xvertAlignMode + '; z-index:' //
    + forme.xlevel //
    );


    div.html(forme.xtext);
    var fonts = div.find('font');
    var i;
    for (i = fonts.length; i > 0; i--)
    replaceFont(fonts[i - 1]);

    var paragraphs = div.find('p');
    for (var i = 0; i < paragraphs.length; i++) {
        replaceParagraph(i, paragraphs[i], forme);
    }
    var textformats = div.find('textformat');
    textformats.each(removeTextformat);

    convertWhitespaces(div[0]);
    cont.append(div);


    if (forme.xactionProps.targ || forme.xactionProps.trig) {

        if (forme.xactionProps.targ) {
            forme.xactionProps.targ.forEach(function(value, index, array) {

                div.addClass('target' + value);
            });
        }
        if (forme.xactionProps.trig) {
            forme.xactionProps.trig.forEach(function(value, index, array) {

                div.addClass('trigger' + value);
            });
        }
    }

/*var textformat = divtext.find('textformat');
 var font = textformat.find('p>font');

 var a = font.selectAll('a').each(function() {
  $(this).attr('href', parseLien($(this).attr("href")))
 });
 text += font.html() + '<br />';*/


}


function createText(xprop) {

    function replaceFont(el) {

        var size = $(el).attr('size') ? 'font-size:' + $(el).attr('size') + 'px;' : '';
        var face = $(el).attr('face') ? 'font-family:' + $(el).attr('face') + ';' : '';
        var color = $(el).attr('color') ? 'color:' + $(el).attr('color') + ';' : '';
        $(el).replaceWith('<span style="' + size + face + color + '">' + $(el).html() + '</span>');
    }

    function replaceParagraph(index, el, xprop) {
        var alignement = $(el).attr('align');
        var textformat = $(el).parents().filter('textformat');


        if (index == 0 || textformat.length == 0) $(el).replaceWith('<div style="text-align: ' + alignement + '; margin-left:' + xprop.xtextFormat.leftMargin //
        + 'px; margin-right:' + xprop.xtextFormat.rightMargin + 'px;">' + $(el).html() + '</div>');
        else {
            $(el).replaceWith('<div style="text-align: ' + alignement + '; margin-left:' + xprop.xtextFormat.leftMargin //
            + 'px; margin-right:' + xprop.xtextFormat.rightMargin + 'px;">' + $(el).html() + '</br></div>');
        }

    }

    function removeTextformat(index, el) {
        var parent = $(el).parent();
        var contents = $(el).contents();
        parent.append(contents);
        $(el).remove();
    }


    function convertWhitespaces(node) {
        if (node.nodeType == 3) {
            var str = node.nodeValue.replace(/\s\s/g, "&nbsp;&nbsp;");
            $(node).wrap('<textformat>');
            var parent = $(node).parent();
            parent.html(str);
        } else {
            for (var i = 0, len = node.childNodes.length; i < len; ++i) {
                convertWhitespaces(node.childNodes[i]);
            }
        }
    }


    var foreignobj = $('<foreignObject>');

    foreignobj.attr('x', xprop.xcaptionPos.xleft + 'px').attr('y', xprop.xcaptionPos.xtop + 'px') //
    .attr('width', xprop.xcaptionSize.xwidth + 'px') //
    .attr('height', (xprop.xcaptionSize.xheight + 10) + 'px');

    var body = $('<body>').attr('xmlns', "http://www.w3.org/1999/xhtml");
    var shadow = '';
    if (xprop.xshadowProps.xtype === 'global') shadow = 'text-shadow: silver 5px 5px 3px;';


    var stdiv = "<div style='" + shadow + "vertical-align:" + xprop.xcaptionProps.xvertAlignMode + ";'>";

    var textobj = $(stdiv + xprop.xtext + "</div>");

    var fonts = textobj.find('font');
    var i;
    for (i = fonts.length; i > 0; i--)
    replaceFont(fonts[i - 1]);

    var paragraphs = textobj.find('p');
    for (var i = 0; i < paragraphs.length; i++) {
        replaceParagraph(i, paragraphs[i], xprop);
    }

    var textformats = textobj.find('textformat');
    textformats.each(removeTextformat);

    convertWhitespaces(textobj[0]);

    body.html(textobj[0].outerHTML);
    body.appendTo(foreignobj);

    return foreignobj[0].outerHTML;
}


function compare_float_func(a, b) {
    return parseFloat(a) - parseFloat(b)
}

function isEqual(a, b) {
    var epsilon = 0.000000000001;
    if ((a - b) < epsilon && (b - a) < epsilon) return true;
    else return false;
}


function appendLineMarkers(xprop, parent) {
    var markertype, filled;
    if (xprop.xstrokeProps.xstart) {
        markertype = xprop.xstrokeProps.xstart.xtype;
        filled = xprop.xstrokeProps.xstart.xfilled;

        if (markertype != 'none' && markertype != 'noarrow') {
            appendLineMarker(xprop, parent, markertype, filled, 'start');
        }
    }

    if (xprop.xstrokeProps.xend) {
        markertype = xprop.xstrokeProps.xend.xtype;
        filled = xprop.xstrokeProps.xend.xfilled;

        if (markertype != 'none' && markertype != 'noarrow') {
            appendLineMarker(xprop, parent, markertype, filled, 'end');
        }
    }

}

function updateLine(xprop, line, markertype, startend) {
    if (markertype == 'none' || markertype == 'noarrow') return;
    var spreadfactor = 0.5;
    var sz = 2 * xprop.xstrokeProps.xthickness + 11;
    var point1x, point1y, point3x, point3y;
    var x1, x2, y1, y2, angle;
    var endx, endy;

    x1 = xprop.xanchors[0].x;
    x2 = xprop.xanchors[2].x;
    y1 = xprop.xanchors[0].y;
    y2 = xprop.xanchors[2].y;
    var angle = Math.atan2(y2 - y1, x2 - x1);
    switch (markertype) {
    case 'arr1':
    case 'arr2':
    case 'diamond1':
        if (startend == 'end') {
            if (markertype == 'arr1' || markertype == 'arr2') {
                point1x = x2 - Math.cos(angle + spreadfactor) * sz;
                point1y = y2 - Math.sin(angle + spreadfactor) * sz;
                point3x = x2 - Math.cos(angle - spreadfactor) * sz;
                point3y = y2 - Math.sin(angle - spreadfactor) * sz;
            }

            if (markertype == 'arr1') {
                endx = (point1x + point3x) / 2;
                endy = (point1y + point3y) / 2;
            } else if (markertype == 'arr2') {
                endx = x2 - Math.cos(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
                endy = y2 - Math.sin(angle + spreadfactor) * xprop.xstrokeProps.xthickness / 2;
            } else if (markertype == 'diamond1') {
                endx = x2 - Math.cos(angle) * sz / 2;
                endy = y2 - Math.sin(angle) * sz / 2;
            }
            line.attr('x2', endx).attr('y2', endy);

        } else if (startend == 'start') {
            if (markertype == 'arr1' || markertype == 'arr2') {
                point1x = x1 + Math.cos(angle + spreadfactor) * sz;
                point1y = y1 + Math.sin(angle + spreadfactor) * sz;
                point3x = x1 + Math.cos(angle - spreadfactor) * sz;
                point3y = y1 + Math.sin(angle - spreadfactor) * sz;

                if (markertype == 'arr1') {
                    endx = Math.round((point1x + point3x) / 2);
                    endy = Math.round((point1y + point3y) / 2);
                } else if (markertype == 'arr2') {
                    endx = x1 + (Math.cos(angle) * xprop.xstrokeProps.xthickness / 2);
                    endy = y1 + (Math.sin(angle) * xprop.xstrokeProps.xthickness / 2);
                }
            } else if (markertype == 'diamond1') {
                endx = x1 + Math.cos(angle) * sz / 2;
                endy = y1 + Math.sin(angle) * sz / 2;
            }
            line.attr('x1', endx).attr('y1', endy);
        }
        break;
    case 'disc1':
        var r = xprop.xstrokeProps.xthickness + 3;
        if (startend == 'end') {
            endx = x2 - Math.cos(angle) * r * 2;
            endy = y2 - Math.sin(angle) * r * 2;
            line.attr('x2', endx).attr('y2', endy);
        } else if (startend == 'start') {
            endx = x1 + Math.cos(angle) * r * 2;
            endy = y1 + Math.sin(angle) * r * 2;
            line.attr('x1', endx).attr('y1', endy);
        }
    }
}


function createLineMarker(xprop, markertype, filled, startend, line) {
    var marker;
    var sz = 2 * xprop.xstrokeProps.xthickness + 11;
    var x1, x2, y1, y2, angle, anglePoint;

    x1 = xprop.xanchors[0].x;
    x2 = xprop.xanchors[2].x;
    y1 = xprop.xanchors[0].y;
    y2 = xprop.xanchors[2].y;

    angle = Math.atan2(y2 - y1, x2 - x1);
    anglePoint = Math.PI / 2 - angle;
    switch (markertype) {
    case 'arr1':
    case 'arr2':
    case 'diamond1':

        var spreadfactor = 0.5;
        var point1x, point1y, point2x, point2y, point3x, point3y, point4x, point4y, endx, endy;
        var centerx, centery;
        var marker;
        var halfthickness = xprop.xstrokeProps.xthickness / 2;
        if (startend == 'end') {
            if (markertype == 'arr1' || markertype == 'arr2') {
                point1x = x2 - Math.cos(angle + spreadfactor) * sz;
                point1y = y2 - Math.sin(angle + spreadfactor) * sz;
                point3x = x2 - Math.cos(angle - spreadfactor) * sz;
                point3y = y2 - Math.sin(angle - spreadfactor) * sz;
                point2x = x2;
                point2y = y2;

                if (markertype == 'arr1') {
                    endx = (point1x + point3x) / 2;
                    endy = (point1y + point3y) / 2;
                } else if (markertype == 'arr2') {
                    endx = x2 - Math.cos(angle) * halfthickness;
                    endy = y2 - Math.sin(angle) * halfthickness;
                }
            } else if (markertype == 'diamond1') {
                centerx = x2 - Math.cos(angle) * sz / 2;
                centery = y2 - Math.sin(angle) * sz / 2;
                point1x = centerx + Math.cos(anglePoint) * sz / 2;
                point1y = centery - Math.sin(anglePoint) * sz / 2;
                point2x = x2 - Math.cos(angle) * sz;
                point2y = y2 - Math.sin(angle) * sz;
                point3x = centerx - Math.cos(anglePoint) * sz / 2;
                point3y = centery + Math.sin(anglePoint) * sz / 2;
                point4x = x2;
                point4y = y2;
                endx = centerx;
                endy = centery;
            }
            line.attr('x2', endx).attr('y2', endy);
        } else if (startend == 'start') {
            if (markertype == 'arr1' || markertype == 'arr2') {
                point1x = x1 + Math.cos(angle + spreadfactor) * sz;
                point1y = y1 + Math.sin(angle + spreadfactor) * sz;
                point3x = x1 + Math.cos(angle - spreadfactor) * sz;
                point3y = y1 + Math.sin(angle - spreadfactor) * sz;
                point2x = x1;
                point2y = y1;
                if (markertype == 'arr1') {
                    endx = (point1x + point3x) / 2;
                    endy = (point1y + point3y) / 2;
                } else if (markertype == 'arr2') {
                    endx = x1 + (Math.cos(angle) * halfthickness);
                    endy = y1 + (Math.sin(angle) * halfthickness);
                }
            } else if (markertype == 'diamond1') {

                centerx = x1 + Math.cos(angle) * sz / 2;
                centery = y1 + Math.sin(angle) * sz / 2;
                point1x = centerx - Math.cos(anglePoint) * sz / 2;
                point1y = centery + Math.sin(anglePoint) * sz / 2;
                point2x = x1 + Math.cos(angle) * sz;
                point2y = y1 + Math.sin(angle) * sz;
                point3x = centerx + Math.cos(anglePoint) * sz / 2;
                point3y = centery - Math.sin(anglePoint) * sz / 2;
                point4x = x1;
                point4y = y1;
                endx = centerx;
                endy = centery;
            }
            line.attr('x1', endx).attr('y1', endy);
        }


        marker = $('<path>').attr('d', function() {
            var pathdescr = 'M ' + point1x + ' ' + point1y + ' L ' + point2x + ' ' + point2y + ' L ' + point3x + ' ' + point3y;
            if (markertype == 'diamond1') pathdescr += ' L ' + point4x + ' ' + point4y;
            if (markertype == 'arr1' || markertype == 'diamond1') pathdescr += ' z';

            return pathdescr;
        });

        marker.attr('stroke', function() {
            return getHexadecimalColor(xprop.xstrokeProps.xcolor)
        });
        marker.attr('stroke-width', function() {
            if (markertype == 'arr2') return xprop.xstrokeProps.xthickness;
            else return 1;
        });
        if (markertype == 'arr2') {
            marker.attr('stroke-linecap', 'round');
            marker.attr('stroke-linejoin', 'round');
        }


        marker.attr('stroke-opacity', xprop.xstrokeProps.xalpha / 100);

        marker.attr('fill', function() {
            if (markertype == 'diamond1' || markertype == 'arr1') {
                if (filled) return getHexadecimalColor(xprop.xstrokeProps.xcolor);
                else return '#FFFFFF';
            } else return 'none';
        });

        break;

    case 'disc1':

        var r, cx, cy;

        r = xprop.xstrokeProps.xthickness + 3;
        if (startend == 'end') {
            cx = x2 - Math.cos(angle) * r;
            cy = y2 - Math.sin(angle) * r;
            endx = x2 - Math.cos(angle) * r * 2;
            endy = y2 - Math.sin(angle) * r * 2;
            line.attr('x2', endx).attr('y2', endy);
        } else if (startend == 'start') {
            cx = x1 + Math.cos(angle) * r;
            cy = y1 + Math.sin(angle) * r;
            endx = x1 + Math.cos(angle) * r * 2;
            endy = y1 + Math.sin(angle) * r * 2;
            line.attr('x1', endx).attr('y1', endy);
        }
        marker = $('<circle>').attr('cx', cx).attr('cy', cy).attr('r', r);
        marker.attr('stroke', function() {
            return getHexadecimalColor(xprop.xstrokeProps.xcolor)
        });
        marker.attr('fill', function() {
            if (filled) return getHexadecimalColor(xprop.xstrokeProps.xcolor);
            else return '#FFFFFF';
        });

        break;
    }
    return marker[0].outerHTML;
}


function createPattern(xprop) {

    function updateWidthAndHeight() {
        $('.' + this.name).attr('width', this.width).attr('height', this.height);
        // $('.' + this.name).attr('width', this.width).attr('height', this.height);
        return true;
    }

    var res;

    var tmpmage = new Image();
    tmpmage.src = "/syracuse-ui/themes/desktop/sage/process/images/patterns/" + xprop.xfillProps.xpatLinkId + ".gif";
    tmpmage.name = xprop.xfillProps.xpatLinkId;
    tmpmage.onload = updateWidthAndHeight;

/*var image = $('<image >');//http://www.w3.org/2000/svg
    image.attr('xlink:href', "/syracuse-ui/themes/desktop/sage/process/images/patterns/" + xprop.xfillProps.xpatLinkId + ".gif");
    image.attr('class', xprop.xfillProps.xpatLinkId)
    image.attr('x', '0') //
    .attr('y', '0') //
    .attr('width', 0) //
    .attr('height', 0);
    var pattern = $('<pattern>').attr('id', 'pattern' + xprop.uniqueID).attr('class', xprop.xfillProps.xpatLinkId) //
    .attr('patternUnits', "userSpaceOnUse");
    pattern.attr('x', '0') //
    .attr('y', '0') //
    .attr('width', 0) //
    .attr('height', 0);
    res = pattern[0].outerHTML;
    res = res.replace(/<\/pattern>/, image[0].outerHTML + "</pattern>");*/

    res = '<pattern id="pattern' + xprop.uniqueID + '" class="' + xprop.xfillProps.xpatLinkId + '" patternUnits="userSpaceOnUse" x="0" y="0" width="0" height="0">';
    res += '<image xlink:href="/syracuse-ui/themes/desktop/sage/process/images/patterns/' + xprop.xfillProps.xpatLinkId + '.gif"';
    res += 'class="' + xprop.xfillProps.xpatLinkId + '" x="0" y="0" width="0" height="0"/>'
    res += "</pattern>";
    return res;
}


function createGradient(xprop) {
    function stops() {

        var stopset = "";

        for (var j = 0; j < xprop.xfillProps.xgcolors.length; j++) {
            var d;

            var newratio = xprop.xfillProps.xgratios[j] * 100 / 255;
            var stop = $('<stop>').attr('offset', newratio + '%'); /*Math.cos(xprop.xfillProps.xgrotation)*/
            stop.attr('style', 'stop-color:' + getHexadecimalColor(xprop.xfillProps.xgcolors[j]) //
            + '; stop-opacity:' + xprop.xfillProps.xgalphas[j] / 100);
            stopset += stop[0].outerHTML;
        }
        return stopset;
    }

    var grad;
    var res;
    switch (xprop.xfillProps.xgtype) {
    case 'linear':
        var tabCoord = getGradientTransVector(xprop.xfillProps.xgrotation);
        grad = $('<lineargradient>').attr('id', 'grad' + xprop.uniqueID) //
        .attr('x1', tabCoord.x1 + '%') //
        .attr('y1', tabCoord.y1 + '%') //
        .attr('x2', tabCoord.x2 + '%') //
        .attr('y2', tabCoord.y2 + '%');
        res = grad[0].outerHTML;
        var st = stops();
        res = res.replace(/<\/lineargradient>/, st + "</lineargradient>");
        //var pos=lastIndexOf("</lineargradient>");
        break;
    case 'radial':
        //TODO les 50% c'ets codé en dur
        grad = $('<radialgradient>').attr('id', 'grad' + xprop.uniqueID) //
        .attr('cx', '50%') //
        .attr('cy', '50%') //
        .attr('r', '50%') //
        .attr('fx', '50%') //
        .attr('fy', '50%');
        var res = grad[0].outerHTML;
        res = res.replace(/<\/radialgradient>/, stops() + "</radialgradient>");
        break;
    }
    return res;
}

function createShadow(xprop) {
    var res = '<filter id="shadow' + xprop.uniqueID + '">';
    //$('<filter>').attr('id',xprop.uniqueID) ;
    var feOffset = $('<feOffset>').attr('in', "SourceAlpha").attr('dx', "3").attr('dy', "3").attr("result", "offOut");
    res += feOffset[0].outerHTML;
    var feGaussianBlur = $('<feGaussianBlur>').attr('in', "offOut").attr('stdDeviation', "3").attr("result", "blurred");
    res += feGaussianBlur[0].outerHTML;
    var feBlend = $('<feBlend>').attr('in', "SourceGraphic").attr('in2', "blurred").attr("mode", "normal");
    res += feBlend[0].outerHTML;

/*<filter id="shadow"+xprop.uniqueID x="0" y="0" width="200%" height="200%">
<feOffset in="SourceAlpha" dx="5" dy="5" result="offOut"/>
<feGaussianBlur in="offOut" stdDeviation="3" result="blurred"/>
<feBlend in="SourceGraphic" in2="blurred" mode="normal" />

</filter>*/


    return res += '</filter>';
}