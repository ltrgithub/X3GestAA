"use strict";
var dateApi = require('syracuse-core').types.date;
var _formatApi = {
	"application/x-integer": require('syracuse-core').types.integer,
	"application/x-decimal": require('syracuse-core').types.decimal,
	"application/x-real": require('syracuse-core').types.real,
	"application/x-date": dateApi,
	"application/x-time": require('syracuse-core').types.time,
	"application/x-datetime": require('syracuse-core').types.datetime
};

exports.getApi = function($type) {
	return _formatApi[$type];
};

var _typeComparator = {
	number: function(v1, v2) {
		return v1 - v2;
	},
	string: function(v1, v2) {
		return v1.localeCompare(v2);
	},
	date: function(v1, v2) {
		return dateApi.parse(v1).compare(v2);
	}
};

exports.compare = function(v1, v2, type, operator) {
	var res;
	if (operator == 'like' && type == 'string') {
		// "contains" operation
		if (/^%(([^%]|\%)*)%$/g.test(v2)) {
			// in case '%' has been escaped with '\%', removing '\'
			var cleanV2 = /^%(([^%]|\%)*)%$/g.exec(v2)[1].replace(/\\%/g, "%");
			res = v1.indexOf(cleanV2) >= 0;
		}
		// "starts with" operation
		else {
			if (/(([^%]|\%)*)%$/g.test(v2)) {
				// in case '%' has been escaped with '\%', removing '\'
				var cleanV2 = /(([^%]|\%)*)%$/g.exec(v2)[1].replace(/\\%/g, "%");
				var re = new RegExp('^' + cleanV2);
				res = re.test(v1);
			} else {
				throw new Error(syra_local.flFilter_err_wrong_value.replace('{operator}', operator).replace('{value}', v2));
			}
		}
	} else {
		if (operator == 'like' && type !== 'string') {
			throw new Error(syra_local.flFilter_err_wrong_type.replace('{operator}', operator).replace('{type}', type));
		} else {
			switch (operator) {
				case ">":
					res = _typeComparator[type](v1, v2) > 0;
					break;
				case ">=":
					res = _typeComparator[type](v1, v2) >= 0;
					break;
				case "<":
					res = _typeComparator[type](v1, v2) < 0;
					break;
				case "<=":
					res = _typeComparator[type](v1, v2) <= 0;
					break;
				case "=":
					res = _typeComparator[type](v1, v2) == 0;
					break;
				case "<>":
					res = _typeComparator[type](v1, v2) != 0;
					break;
				default:
					res = true;
			}
		}
	}
	return res;
};

var _defaultLocale = {
	getDateFormat: function(displayFormat) {
		return displayFormat == "DD" ? "dd MMMM yyyy" : "yyyy-MM-dd";
	},
	getTimeFormat: function(displayFormat) {
		return displayFormat == "TT" ? "HH:mm:ss" : "HH:mm";
	},
	getDatetimeFormat: function(displayFormat) {
		var format;
		switch (displayFormat) {
			case "F":
				// sortable datetime format
				format = "yyyy-MM-ddTHH:mm:ss";
				break;
			case "FF":
				// full datetime format
				format = "dd MMMM yyyy HH:mm:ss";
				break;
			case "U":
				// universal sortable datetime format 
				format = "yyyy-MM-dd HH:mm:ssZ";
				break;
			default:
				// datetime default format is dateformat + space + timeformat
				format = this.getDateFormat() + " " + this.getTimeFormat();
		}
		return format;
	},
	getNumberFormatObj: function(type) {
		return {
			numFormat: type == "application/x-integer" ? "#,##0" : "#,##0.##",
			decimalSeparator: ".",
			groupSeparator: "",
			groupSize: 3
		};
	},
	getNumberFormat: function(type) {
		return this.getNumberFormatObj(type).numFormat;
	},
	getTwoDigitYearMax: function() {
		return 2029;
	}
};


exports.getLocale = function() {
	return syra_site.userProfile || _defaultLocale;
};

exports.getLocalFormat = function(type, $displayFormat) { // return the corresponding date format
	var format;
	var locale = exports.getLocale();
	switch (type) {
		case "application/x-date":
			format = locale.getDateFormat($displayFormat);
			break;
		case "application/x-time":
			format = locale.getTimeFormat($displayFormat);
			break;
		case "application/x-datetime":
			format = locale.getDatetimeFormat($displayFormat);
			break;
		default:
			format = $displayFormat || locale.getNumberFormat(type);
			break;
	}
	return format;
};

/**
 * Returns JSON formatObj with some properties :
 * - dirOne : first directive
 * - dirTwo : second ...
 * - dirThree : third ...
 * each directive has properties : *directive* (actual directive) and *count* (minimum digits)
 * - maxLenght : maximum possible date length according to the format
 * @param {String} format : date format
 * @return {Object} formatObj
 */
// TO IMPROVE
var _formats = {};

var _directives = ["dirOne", "dirTwo", "dirThree"];

function _setMaxLength(formatObj) {
	var maxLength = 0;
	for (var ii = 0, jj = _directives.length - 1; ii < jj; ii++) {
		var dir = _directives[ii];
		maxLength += formatObj[dir].count > 2 ? formatObj[dir].count : 2;
	}
	maxLength += 2;
	formatObj.maxLength = maxLength;
}

exports.processFormat = function(format) {
	var formatObj = _formats[format];
	if (!formatObj) {
		var i = 0,
			len = format.length;
		formatObj = _formats[format] = {};

		while (i < len) {
			var c = format[i];
			switch (c) {
				case "'":
					i++;
					var literal = '';
					// going to the end of the following litteral or to the format end
					for (; i < len; i++) {
						if (format[i] === "'") {
							i++;
							// check wether the "'" is not doubled
							if (format[i] === "'") {
								literal += "'";
							} else
								break;
						} else {
							literal += format[i];
						}
					}
					if (!formatObj.separator) {
						formatObj.separator = literal;
					}
					break;
				case "d":
				case "M":
				case "y":
					var ch = format[i],
						repeat = 1;
					while (format[i + repeat] === ch) {
						repeat++;
					}
					for (var mm = 0, kk = _directives.length; mm < kk; mm++) {
						var d = _directives[mm];
						if (!formatObj[d]) {
							formatObj[d] = {};
							formatObj[d].dir = c;
							formatObj[d].count = repeat;
							formatObj[d].max = repeat < 2 ? 2 : repeat;
							break;
						}
					}

					i += repeat;
					break;
				default:
					if (!formatObj.separator) {
						formatObj.separator = c;
					}
					i++;
			}
		}
		_setMaxLength(formatObj);
	}
	return formatObj;
};

exports.utcToLocal = function(value) {
	var api = _formatApi["application/x-datetime"];
	value = value.replace(/(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2}:\d{2})(Z|\s*GMT)/, "$1T$2Z");
	var dtLocal = api.parse(value);
	return dtLocal.toString(exports.getLocale().format.datetime_full);
};