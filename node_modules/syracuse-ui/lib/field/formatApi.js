"use strict";
var dateApi = require('syracuse-core/lib/types/date');
var _formatApi = {
	"application/x-integer": require('syracuse-core/lib/types/integer'),
	"application/x-decimal": require('syracuse-core/lib/types/decimal'),
	"application/x-real": require('syracuse-core/lib/types/real'),
	"application/x-date": dateApi,
	"application/x-time": require('syracuse-core/lib/types/time'),
	"application/x-datetime": require('syracuse-core/lib/types/datetime')
};

exports.getApi = function($type) {
	return _formatApi[$type];
};

var _typeComparator = {
	number: function(v1, v2) {
		return v1 - v2;
	},
	string: function(v1, v2) {
		return v1.localeCompare(v2);
	},
	date: function(v1, v2) {
		return dateApi.parse(v1).compare(v2);
	}
};

exports.compare = function(v1, v2, type, operator) {
	var res;
	if (operator == 'like' && type == 'string') {
		// "contains" operation
		if (/^%(([^%]|\%)*)%$/g.test(v2)) {
			// in case '%' has been escaped with '\%', removing '\'
			var cleanV2 = /^%(([^%]|\%)*)%$/g.exec(v2)[1].replace(/\\%/g, "%");
			res = v1.indexOf(cleanV2) >= 0;
		}
		// "starts with" operation
		else {
			if (/(([^%]|\%)*)%$/g.test(v2)) {
				// in case '%' has been escaped with '\%', removing '\'
				var cleanV2 = /(([^%]|\%)*)%$/g.exec(v2)[1].replace(/\\%/g, "%");
				var re = new RegExp('^' + cleanV2);
				res = re.test(v1);
			} else {
				throw new Error(syra_local.flFilter_err_wrong_value.replace('{operator}', operator).replace('{value}', v2));
			}
		}
	} else {
		if (operator == 'like' && type !== 'string') {
			throw new Error(syra_local.flFilter_err_wrong_type.replace('{operator}', operator).replace('{type}', type));
		} else {
			switch (operator) {
				case ">":
					res = _typeComparator[type](v1, v2) > 0;
					break;
				case ">=":
					res = _typeComparator[type](v1, v2) >= 0;
					break;
				case "<":
					res = _typeComparator[type](v1, v2) < 0;
					break;
				case "<=":
					res = _typeComparator[type](v1, v2) <= 0;
					break;
				case "=":
					res = _typeComparator[type](v1, v2) == 0;
					break;
				case "<>":
					res = _typeComparator[type](v1, v2) != 0;
					break;
				default:
					res = true;
			}
		}
	}
	return res;
};

var _defaultLocale = {
	getDateFormat: function(displayFormat) {
		return displayFormat == "DD" ? "dd MMMM yyyy" : "yyyy-MM-dd";
	},
	getTimeFormat: function(displayFormat) {
		return displayFormat == "TT" ? "HH:mm:ss" : "HH:mm";
	},
	getDatetimeFormat: function(displayFormat) {
		var format;
		switch (displayFormat) {
			case "F":
				// sortable datetime format
				format = "yyyy-MM-ddTHH:mm:ss";
				break;
			case "FF":
				// full datetime format
				format = "dd MMMM yyyy HH:mm:ss";
				break;
			case "U":
				// universal sortable datetime format 
				format = "yyyy-MM-dd HH:mm:ssZ";
				break;
			default:
				// datetime default format is dateformat + space + timeformat
				format = this.getDateFormat() + " " + this.getTimeFormat();
		}
		return format;
	},
	getNumberFormatObj: function(type) {
		var formatObj = {};
		formatObj.numFormat = type == "application/x-integer" ? "#,##0" : "#,##0.##";
		formatObj.decimalSeparator = ".";
		formatObj.groupSeparator = "";
		formatObj.groupSize = 3;
		return formatObj;
	},
	getNumberFormat: function(type) {
		return this.getNumberFormatObj(type).numFormat;
	},
	getTwoDigitYearMax: function() {
		return 2029;
	}
};

function _getLocale() {
	return syra_site.userProfile || _defaultLocale;
}

exports.getLocale = _getLocale;

exports.getLocalFormat = function(type, $displayFormat) { // return the corresponding date format
	var format;
	var locale = _getLocale();
	switch (type) {
		case "application/x-date":
			format = locale.getDateFormat($displayFormat);
			break;
		case "application/x-time":
			format = locale.getTimeFormat($displayFormat);
			break;
		case "application/x-datetime":
			format = locale.getDatetimeFormat($displayFormat);
			break;
		default:
			format = $displayFormat || locale.getNumberFormat(type);
			break;
	}
	return format;
};

/**
 * Returns JSON formatObj with some properties :
 * - dirOne : first directive
 * - dirTwo : second ...
 * - dirThree : third ...
 * each directive has properties : *directive* (actual directive) and *count* (minimum digits)
 * - maxLenght : maximum possible date length according to the format
 * @param {String} format : date format
 * @return {Object} formatObj
 */
// TO IMPROVE
exports.processFormat = function(format) {
	var i = 0,
		len = format.length;
	var formatObj = {};
	var directives = ["dirOne", "dirTwo", "dirThree"];

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	function addSeparator(c) {
		if (!formatObj.separator) {
			formatObj.separator = c;
		}
	}

	function addDirective(c, count) {
		for (var i = 0; i < directives.length; i++) {
			var d = directives[i];
			if (!formatObj[d]) {
				formatObj[d] = {};
				formatObj[d].dir = c;
				formatObj[d].count = count;
				formatObj[d].max = count < 2 ? 2 : count;
				break;
			}
		}
	}

	function addMaxLength() {
		var maxLength = 0;
		for (var ii = 0, jj = directives.length - 1; ii < jj; ii++) {
			var dir = directives[ii];
			maxLength += formatObj[dir].count > 2 ? formatObj[dir].count : 2;
		}
		maxLength += 2;
		formatObj.maxLength = maxLength;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else
							break;
					} else {
						literal += format[i];
					}
				}
				addSeparator(literal);
				break;
			case "d":
			case "M":
			case "y":
				var repeat = count(i);
				addDirective(c, repeat);
				i += repeat;
				break;
			default:
				addSeparator(c);
				i++;
		}
	}

	addMaxLength();

	return formatObj;
};

exports.utcToLocal = function(value) {
	var api = _formatApi["application/x-datetime"];
	value = value.replace(/(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2}:\d{2})(Z|\s*GMT)/, "$1T$2Z");
	var dtLocal = api.parse(value);
	return dtLocal.toString(_getLocale().format.datetime_full);
};