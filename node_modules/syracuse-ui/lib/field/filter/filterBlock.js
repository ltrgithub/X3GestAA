"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Article = require("syracuse-ui/lib/article/article").Article;
var FilterField = require("./filterField").FilterField;
var parser = require('syracuse-sdata/lib/parser/parser');

function FilterBlock() {}

exports.FilterBlock = helpers.defineClass(FilterBlock, Article, {
	buildFilterBlock: function(filterWidget, filterBlockContainer, $prototype) {
		this.filterWidget = filterWidget;
		this.filterBlockContainer = filterBlockContainer;
		this.layoutSlot = this.filterBlockContainer;
		this.isFilterArticle = true;
		this.$facet = "$filter";
		this.$isEditMode = filterWidget.$isEditMode;
		this.$prototype = $prototype;
		this.$skin = filterWidget.$skin;
		this.$modifyFilter = null;

		filterWidget.page.initializeNewItem(this, {
			$layout: {}
		}, filterWidget.boxParent);

		this.loadBox();

		syra_site.dom.empty(this.filterBlockContainer);
		this.filterFields = {};
		var $binds = Object.keys(this.$prototype.$properties);
		for (var ii = 0, jj = $binds.length; ii < jj; ii++) {
			var $bind = $binds[ii];
			var $field = this.$prototype.$properties[$bind];
			if (!$field.$isExcluded && $field.$capabilities && $field.$capabilities.indexOf("filter") >= 0) {
				switch ($field.$type) {
					case "application/x-string":
					case "application/x-choice":
					case "application/x-boolean":
					case "application/x-integer":
					case "application/x-decimal":
					case "application/x-date":
					case "application/x-time":
					case "application/x-datetime":
					case "application/x-reference":
						this.filterFields[$bind] = new FilterField();
						this.filterFields[$bind].createField($bind, $field, this);
						break;
				}
			}
		}
	},
	drawBox: function() {
		this.domItem = this.filterBlockContainer;
	},
	onNotifyDataChange: function(field, value) {
		this._buildSDataWhere();
	},
	_buildSDataWhere: function() {
		var self = this;
		var sdataWhere;
		if (!self.filterFields)
			return;

		var exp = [];
		Object.keys(self.filterFields).forEach(function(key) {
			var filterField = self.filterFields[key];
			var value = filterField.getValue();
			if (value)
				exp.push(value);
		});
		sdataWhere = exp.join(" and ");
		self.filterWidget.setSDataWhere(sdataWhere);
		return sdataWhere;
	},
	setSDataWhere: function(sdataWhere) {
		var self = this;
		var matchedFields = "";
		var unmatchedFields = [];

		if (!self.filterFields)
			return;

		function expIdentifierWithOperator(exp) {
			var finalIdentifier = '';
			for (var ii = 0, jj = exp.children.length; ii < jj; ii++) {
				var id = exp.children[ii];
				finalIdentifier += id.type == 'identifier' ? id.value : expIdentifierWithOperator(id);
				finalIdentifier += ii < jj - 1 ? exp.value.text : "";
			}
			return finalIdentifier;
		}

		function expTraverseAnd(exp) {
			exp.children.forEach(function(child) {
				return traverseExpressions(child);
			});
		}

		function expIdentifierAndLiteral(exp) {
			if (!(exp.children.length === 2 && exp.children[0].type === "identifier" && exp.children[1].type === "literal")) {
				if (exp.children[0].type === "operator") {
					//var field = expIdentifierWithOperator(exp.children[0]);
					// temporary fix for reference field in filter block widget - FK
					var field = exp.children[0].children[0].value;
				} else {
					return;
				}
			}
			var field = field || exp.children[0].value;
			var value = exp.children[1].value;
			var op = exp.value.text;
			var filterField = self.filterFields && self.filterFields[field];
			if (!filterField) {
				unmatchedFields.push(field);
				return;
			}
			// fix issue #2623
			else {
				// in order not to update filter UI ("between" operator is mostly concerned)
				op = filterField.operator || op;
			}
			matchedFields += "," + field + ",";

			// fix issue #2623
			// in order not to update filter UI ("between" operator is mostly concerned)
			if (op == "between") {
				var fieldLowVal = filterField.getFieldValue(filterField.fieldLow);
				var fieldHighVal = filterField.getFieldValue(filterField.fieldHigh);
				if ((fieldLowVal || fieldHighVal) && (fieldLowVal == value || fieldHighVal == value)) {
					filterField.setFilterValues(op, fieldLowVal, fieldHighVal);
				} else {
					filterField.setFilterValues(op, value);
				}
			} else {
				filterField.setFilterValues(op, value);
			}
		}

		function expBetween(exp) {
			if (exp.children.length === 3 && exp.children[0].type === "identifier" && exp.children[1].type === "literal" && exp.children[2].type === "literal") {
				var field = exp.children[0].value;
				var low = exp.children[1].value;
				var high = exp.children[2].value;
				var op = exp.value.text;
				var filterField = self.filterFields && self.filterFields[field];
				if (!filterField) {
					unmatchedFields.push(field);
				} else {
					matchedFields += "," + field + ",";
					filterField.setFilterValues(op, low, high);
				}
			}
		}

		function traverseExpressions(exp) {
			if (exp && exp.type === "operator") {
				var operator = (exp.value && exp.value.text) || "unknown";
				var handler = operators[operator];
				handler && handler(exp);
			}
		};

		var operators = {
			"and": expTraverseAnd,
			"gt": expIdentifierAndLiteral,
			"ge": expIdentifierAndLiteral,
			"lt": expIdentifierAndLiteral,
			"le": expIdentifierAndLiteral,
			"like": expIdentifierAndLiteral,
			"eq": expIdentifierAndLiteral,
			"ne": expIdentifierAndLiteral,
			"between": expBetween,
		};

		traverseExpressions(parser.Parser.parse(sdataWhere));

		// remove values of unmatched fields
		Object.keys(self.filterFields).forEach(function(key) {
			if (matchedFields.indexOf("," + key + ",") < 0)
				self.filterFields[key].setFilterValues("none");
		});
	},
	applyStateMetaData: function(metaData, options) {
		var $modifyFilter = !metaData.$isDisabled && metaData.$isEditMode && !metaData.$isReadOnly;
		if (this.$modifyFilter != $modifyFilter) {
			this.$modifyFilter = $modifyFilter;
			this.applyModifyState();
		}
	},
	applyModifyState: function() {
		var self = this;
		if (self.filterFields) {
			Object.keys(self.filterFields).forEach(function($bind) {
				self.filterFields[$bind].applyModifyState(self.$modifyFilter);
			});
		}
	},
	dispose: function() {
		var self = this;
		delete self.filterWidget;
		if (self.filterFields) {
			Object.keys(self.filterFields).forEach(function($bind) {
				self.filterFields[$bind].dispose();
			});
			delete self.filterFields;
		}
	},
});