"use strict";

var helpers = require('syracuse-core/lib/helpers');

var Article = require("syracuse-ui/lib/article/article").Article;
var FilterField = require("./filterField").FilterField;
var parser = require('syracuse-sdata/lib/parser/parser');

// datatypes which show up as filter (others are not shown eg. x-graph)
var supportedTypes = ["application/x-string", "application/x-choice", "application/x-boolean", "application/x-integer", "application/x-decimal", "application/x-date", "application/x-time", "application/x-datetime", "application/x-reference"];

function _isFilterType($testType) {
	return supportedTypes.some(function($type) {
		return ($type === $testType);
	});
}

function FilterBlock() {}

exports.FilterBlock = helpers.defineClass(FilterBlock, Article, {
	buildFilterBlock: function(filterWidget, filterBlockContainer, $prototype) {
		this.filterWidget = filterWidget;
		this.filterBlockContainer = filterBlockContainer;
		this.layoutSlot = this.filterBlockContainer;
		this.isFilterArticle = true;
		this.$facet = "$filter";
		this.$isEditMode = filterWidget.$isEditMode;
		this.$prototype = $prototype;
		this.$skin = filterWidget.$skin;
		this.$modifyFilter = null;

		filterWidget.page.initializeNewItem(this, {
			$layout: {}
		}, filterWidget.boxParent);

		this.loadBox();

		this.removeFilterFields();
		this.buildFilterFields();
	},
	removeFilterFields: function() {
		var self = this;
		if (self.filterBlockContainer) {
			syra_site.dom.empty(self.filterBlockContainer);
		}
	},
	buildFilterFields: function() {
		var self = this;
		self.filterFields = {};
		Object.keys(self.$prototype.$properties).map(function($property) {
			var $item = self.$prototype.$properties[$property];
			if (_isFilterType($item.$type)) {
				self.filterFields[$property] = new FilterField();
				self.filterFields[$property].createField($property, $item, self);
			}
		});
	},
	drawBox: function() {
		this.domItem = this.filterBlockContainer;
	},
	onNotifyDataChange: function(field, value) {
		var self = this;
		self._buildSDataWhere();
	},
	_buildSDataWhere: function() {
		var self = this;
		var sdataWhere;

		if (!self.filterFields)
			return;

		var exp = [];

		Object.keys(self.filterFields).forEach(function(key) {
			var filterField = self.filterFields[key];
			var value = filterField.getValue();
			if (value)
				exp.push(value);
		});

		sdataWhere = exp.join(" and ");
		self.filterWidget.setSDataWhere(sdataWhere);
		return sdataWhere;
	},
	setSDataWhere: function(sdataWhere) {
		var self = this;
		var matchedFields = "";
		var unmatchedFields = [];

		if (!self.filterFields)
			return;

		function expIdentifierWithOperator(exp) {
			var finalIdentifier = '';
			for (var ii = 0, jj = exp.children.length; ii < jj; ii++) {
				var id = exp.children[ii];
				finalIdentifier += id.type == 'identifier' ? id.value : expIdentifierWithOperator(id);
				finalIdentifier += ii < jj - 1 ? exp.value.text : "";
			}
			return finalIdentifier;
		}

		function expTraverseAnd(exp) {
			exp.children.forEach(function(child) {
				return traverseExpressions(child);
			});
		}

		function expIdentifierAndLiteral(exp) {
			if (!(exp.children.length === 2 && exp.children[0].type === "identifier" && exp.children[1].type === "literal")) {
				if (exp.children[0].type === "operator") {
					//var field = expIdentifierWithOperator(exp.children[0]);
					// temporary fix for reference field in filter block widget - FK
					var field = exp.children[0].children[0].value;
				} else {
					return;
				}
			}
			var field = field || exp.children[0].value;
			var value = exp.children[1].value;
			var op = exp.value.text;
			var filterField = self.filterFields && self.filterFields[field];
			if (!filterField) {
				unmatchedFields.push(field);
				return;
			}
			// fix issue #2623
			else {
				// in order not to update filter UI ("between" operator is mostly concerned)
				op = filterField.operator || op;
			}
			matchedFields += "," + field + ",";

			// fix issue #2623
			// in order not to update filter UI ("between" operator is mostly concerned)
			if (op == "between") {
				var fieldLowVal = filterField.getFieldValue(filterField.fieldLow);
				var fieldHighVal = filterField.getFieldValue(filterField.fieldHigh);
				if ((fieldLowVal || fieldHighVal) && (fieldLowVal == value || fieldHighVal == value)) {
					filterField.setFilterValues(op, fieldLowVal, fieldHighVal);
				} else {
					filterField.setFilterValues(op, value);
				}
			} else {
				filterField.setFilterValues(op, value);
			}
		}

		function expBetween(exp) {
			if (!(exp.children.length === 3 && exp.children[0].type === "identifier" && exp.children[1].type === "literal" && exp.children[2].type === "literal"))
				return;
			var field = exp.children[0].value;
			var low = exp.children[1].value;
			var high = exp.children[2].value;
			var op = exp.value.text;
			var filterField = self.filterFields && self.filterFields[field];
			if (!filterField) {
				unmatchedFields.push(field);
				return;
			}
			matchedFields += "," + field + ",";
			filterField.setFilterValues(op, low, high);
		}

		function traverseExpressions(exp) {
			if (!exp)
				return;
			if (exp.type === "operator") {
				var operator = (exp.value && exp.value.text) || "unknown";
				var handler = operators[operator];
				if (handler)
					handler(exp);
			}
		};

		var operators = {
			"and": expTraverseAnd,
			"gt": expIdentifierAndLiteral,
			"ge": expIdentifierAndLiteral,
			"lt": expIdentifierAndLiteral,
			"le": expIdentifierAndLiteral,
			"like": expIdentifierAndLiteral,
			"eq": expIdentifierAndLiteral,
			"ne": expIdentifierAndLiteral,
			"between": expBetween,
		};

		var exp = parser.Parser.parse(sdataWhere);
		traverseExpressions(exp);

		// remove values of unmatched fields
		Object.keys(self.filterFields).forEach(function(key) {
			if (matchedFields.indexOf("," + key + ",") < 0)
				self.filterFields[key].setFilterValues("none");
		});
	},
	applyStateMetaData: function(metaData, options) {
		var self = this;
		var $modifyFilter = !metaData.$isDisabled && metaData.$isEditMode && !metaData.$isReadOnly;
		if (self.$modifyFilter != $modifyFilter) {
			self.$modifyFilter = $modifyFilter;
			self.applyModifyState();
		}
	},
	applyModifyState: function() {
		var self = this;
		if (self.filterFields) {
			Object.keys(self.filterFields).forEach(function($bind) {
				self.filterFields[$bind].applyModifyState(self.$modifyFilter);
			});
		}
	},
	dispose: function() {
		var self = this;
		delete self.filterWidget;

		if (self.filterFields) {
			Object.keys(self.filterFields).forEach(function($bind) {
				self.filterFields[$bind].dispose();
			});
			delete self.filterFields;
		}
	},
});