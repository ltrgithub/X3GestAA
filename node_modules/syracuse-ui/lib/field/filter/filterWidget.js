"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var FilterField = require("./filterField").FilterField;
var _parser = require('syracuse-sdata/lib/parser/parser');

function FilterBlock() {}

exports.FilterBlock = helpers.defineClass(FilterBlock, null, {
	applyChange: function(newData) {
		syra_article.applyChange(this, newData);
	},
	onNotifyDataChange: function(field, value) {
		var self = this;
		var sdataWhere;
		if (!self.filterFields)
			return;

		var exp = [];
		Object.keys(self.filterFields).forEach(function(key) {
			var filterField = self.filterFields[key];
			var value = filterField.getValue();
			if (value)
				exp.push(value);
		});
		sdataWhere = exp.join(" and ");
		self.filterWidget.setSDataWhere(sdataWhere);
	},
	setSDataWhere: function(sdataWhere) {
		var self = this;
		var matchedFields = "";
		var unmatchedFields = [];

		if (!self.filterFields)
			return;

		function expIdentifierWithOperator(exp) {
			var finalIdentifier = '';
			for (var ii = 0, jj = exp.children.length; ii < jj; ii++) {
				var id = exp.children[ii];
				finalIdentifier += id.type == 'identifier' ? id.value : expIdentifierWithOperator(id);
				finalIdentifier += ii < jj - 1 ? exp.value.text : "";
			}
			return finalIdentifier;
		}

		function expTraverseAnd(exp) {
			exp.children.forEach(function(child) {
				return traverseExpressions(child);
			});
		}

		function expIdentifierAndLiteral(exp) {
			if (!(exp.children.length === 2 && exp.children[0].type === "identifier" && exp.children[1].type === "literal")) {
				if (exp.children[0].type === "operator") {
					//var field = expIdentifierWithOperator(exp.children[0]);
					// temporary fix for reference field in filter block widget - FK
					var field = exp.children[0].children[0].value;
				} else {
					return;
				}
			}
			var field = field || exp.children[0].value;
			var value = exp.children[1].value;
			var op = exp.value.text;
			var filterField = self.filterFields && self.filterFields[field];
			if (!filterField) {
				unmatchedFields.push(field);
				return;
			}
			// fix issue #2623
			else {
				// in order not to update filter UI ("between" operator is mostly concerned)
				op = filterField.operator || op;
			}
			matchedFields += "," + field + ",";

			// fix issue #2623
			// in order not to update filter UI ("between" operator is mostly concerned)
			if (op == "between") {
				var fieldLowVal = filterField.getFieldValue(filterField.fieldLow);
				var fieldHighVal = filterField.getFieldValue(filterField.fieldHigh);
				if ((fieldLowVal || fieldHighVal) && (fieldLowVal == value || fieldHighVal == value)) {
					filterField.setFilterValues(op, fieldLowVal, fieldHighVal);
				} else {
					filterField.setFilterValues(op, value);
				}
			} else {
				filterField.setFilterValues(op, value);
			}
		}

		function expBetween(exp) {
			if (exp.children.length === 3 && exp.children[0].type === "identifier" && exp.children[1].type === "literal" && exp.children[2].type === "literal") {
				var field = exp.children[0].value;
				var low = exp.children[1].value;
				var high = exp.children[2].value;
				var op = exp.value.text;
				var filterField = self.filterFields && self.filterFields[field];
				if (!filterField) {
					unmatchedFields.push(field);
				} else {
					matchedFields += "," + field + ",";
					filterField.setFilterValues(op, low, high);
				}
			}
		}

		function traverseExpressions(exp) {
			if (exp && exp.type === "operator") {
				var operator = (exp.value && exp.value.text) || "unknown";
				var handler = operators[operator];
				handler && handler(exp);
			}
		};

		var operators = {
			"and": expTraverseAnd,
			"gt": expIdentifierAndLiteral,
			"ge": expIdentifierAndLiteral,
			"lt": expIdentifierAndLiteral,
			"le": expIdentifierAndLiteral,
			"like": expIdentifierAndLiteral,
			"eq": expIdentifierAndLiteral,
			"ne": expIdentifierAndLiteral,
			"between": expBetween,
		};

		traverseExpressions(_parser.Parser.parse(sdataWhere));

		// remove values of unmatched fields
		Object.keys(self.filterFields).forEach(function(key) {
			if (matchedFields.indexOf("," + key + ",") < 0)
				self.filterFields[key].setFilterValues("none");
		});
	},
	applyStateMetaData: function(metaData, options) {
		var $modifyFilter = !metaData.$isDisabled && metaData.$isEditMode && !metaData.$isReadOnly;
		if (this.$modifyFilter != $modifyFilter) {
			this.$modifyFilter = $modifyFilter;
			this.applyModifyState();
		}
	},
	applyModifyState: function() {
		var self = this;
		if (self.filterFields) {
			Object.keys(self.filterFields).forEach(function($bind) {
				self.filterFields[$bind].applyModifyState(self.$modifyFilter);
			});
		}
	},
	dispose: function() {
		var self = this;
		delete self.filterWidget;
		if (self.filterFields) {
			Object.keys(self.filterFields).forEach(function($bind) {
				self.filterFields[$bind].dispose();
			});
			delete self.filterFields;
		}
		syra_article.dispose(this);
	}
});

function _applyStateMetaData(field, metaData, options) {
	if (field.filterBlock && metaData) {
		metaData = {};
		metaData.$isReadOnly = field.$isReadOnly;
		metaData.$isEditMode = field.$isEditMode;
		metaData.$isDisabled = field.$isDisabled;
		field.filterBlock.applyStateMetaData(metaData, options);
	}
}

function _applyItemMetaData(field, metaData, options) {
	var $item = metaData && metaData.$item;
	if (!(field.$item.$inplace) && field.$isEditMode) {
		var block = field.filterBlock = new FilterBlock();
		block.filterWidget = field;
		block.layoutSlot = block.filterBlockContainer = field._filterBlockContainer;
		block.isFilterArticle = true;
		block.$facet = "$filter";
		block.$isEditMode = field.$isEditMode;
		block.$prototype = $item;
		block.$skin = field.$skin;
		block.$modifyFilter = null;
		syra_item.initialize(field.page, block, {
			$layout: {}
		}, field.boxParent);

		syra_article.beforeDrawBox(block);
		block.domItem = block.filterBlockContainer;
		syra_article.endDrawBox(block);

		syra_dom.empty(block.filterBlockContainer);
		block.filterFields = {};
		var $binds = Object.keys(block.$prototype.$properties);
		for (var ii = 0, jj = $binds.length; ii < jj; ii++) {
			var $bind = $binds[ii];
			var $field = block.$prototype.$properties[$bind];
			if (!$field.$isExcluded && $field.$capabilities && $field.$capabilities.indexOf("filter") >= 0) {
				switch ($field.$type) {
					case "application/x-string":
					case "application/x-choice":
					case "application/x-boolean":
					case "application/x-integer":
					case "application/x-decimal":
					case "application/x-date":
					case "application/x-time":
					case "application/x-datetime":
					case "application/x-reference":
						block.filterFields[$bind] = new FilterField();
						block.filterFields[$bind].createField($bind, $field, block, ii);
						break;
				}
			}
		}




		field.filterBlock.setSDataWhere(field.sdataWhere);
	}
}

function FilterWidget() {}


exports.FilterWidget = helpers.defineClass(FilterWidget, Field, {
	loadBox: function() {
		syra_menus.menus.initialize(this);
		syra_fields.ensureEditMode(this);

		this.$skinField = this.$skin = this.$item.$skin || (this.$item.$inplace ? "s-inplace" : "s-field");
		this.domItem = this.layoutSlot;
		if (!this.$item.$inplace) {
			this.domItem = this.layoutSlot.appendChild(document.createElement("div"));
		}

		// Align label at top if edit mode
		if (this.$isEditMode) {
			this.$skinField = this.$skin = this.$item.$skin || (this.$item.$inplace ? "s-inplace" : "s-field-filter");
			this.$skinInput = this.$skin + "-input";
			if (this.$item.$isTopLabelAlignment == null) {
				this.$item.$isTopLabelAlignment = true;
			}
		}

		syra_fields.initCss(this);

		this.domItem.className += " " + this._$cssField;

		syra_fields.addTitle(this);
		this._dataValue = document.createElement("div");
		this._dataValue.className = this._$cssField + "-value";
		this.domItem.appendChild(this._dataValue);
		if (!this.$item.$inplace) {
			this._filterBlockContainer = document.createElement("div");
			this._filterBlockContainer.className = this._$cssField + "-fields";
			this.domItem.appendChild(this._filterBlockContainer);
		}
		this.isField = true;
		this.domItem.syrainout = this.domItem.syraItem = this.id;
		this.domItem.syra_field_bind = this.$item.$bind || "";
		syra_fields.advancedState.setState(this);
		this.setTitle(this.$item.$title || this.$field.$title);
		syra_item.bind(this, this.$item.$bind);
		syra_fields.ensureLayoutMode(this);
	},
	applyMetaData: function(metaData, options) {
		var self = this;
		syra_fields.applyMetaData(self, metaData, options);
		if (metaData) {
			if (metaData.$isReadOnly !== undefined) {
				self.$isReadOnly = metaData.$isReadOnly;
			}
			if (metaData.$isEditMode !== undefined) {
				self.$isEditMode = metaData.$isEditMode;
			}
			if (metaData.$isDisabled !== undefined) {
				self.$isDisabled = metaData.$isDisabled;
			}

			if (metaData.$item) {
				_applyItemMetaData(self, metaData, options);
			}
			if (metaData.$item || metaData.$isEditMode || metaData.$isDisabled || metaData.$isReadOnly) {
				_applyStateMetaData(self, metaData, options);
			}
			//
			if (self.$isEditMode) {
				var p_url = syra_expression.parse(self.articleParent, (metaData.$links && metaData.$links.$prototype && metaData.$links.$prototype.$url) || (self.$field.$links && self.$field.$links.$prototype && self.$field.$links.$prototype.$url));
				if ((!self._prototypeUrl && p_url) || (self._prototypeUrl && (self._prototypeUrl != p_url))) {
					self._prototypeUrl = p_url;
					syra_http.get({
						page: self.articleParent,
						$url: p_url,
						success: function(data, response, requestUrl) {
							var proto = {
								$item: data
							};
							var dps = ((data.$properties && data.$properties.$resources && data.$properties.$resources.$item) || data).$properties;
							proto.$item.$properties = dps ? helpers.object.clone(dps, true) : {};
							_applyItemMetaData(self, proto, options);
							// apply state after filterBlock creation
							_applyStateMetaData(self, metaData, options);
						}
					});
				}
			}
		}
	},
	render: function() {

	},
	setValue: function(value, metaData) {
		this.sdataWhere = value;
		if (this._dataValue) {
			this._dataValue.textContent = value;
		}
		this.filterBlock && this.filterBlock.setSDataWhere(value);
		this.applyMetaData(metaData);
	},
	/* called by filterBlock on filter modification */
	setSDataWhere: function(sdataWhere) {
		// normalize sdataWhere
		sdataWhere = sdataWhere.replace(/\"/g, "'");
		if (this.$isEditMode) {
			if (this._dataValue) {
				syra_dom.empty(this._dataValue);
				this._dataValue.textContent = sdataWhere;
			}
			if (sdataWhere !== undefined && (this.sdataWhere !== sdataWhere)) {
				syra_form.notifyFieldChange(this, sdataWhere);
			}
			this.sdataWhere = sdataWhere;
		}
	},
	dispose: function() {
		this.filterBlock && this.filterBlock.dispose();
		Field.prototype.dispose.call(this);
	}
});