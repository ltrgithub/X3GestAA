"use strict";

var locale = require('streamline-locale');


var mapFormat = {};
/*
 *  provide a simple function to format a value
 *
 *  raise a exception if the format is not correct
 */

/*
 * raise an exception if the value doesn't correspond to a list of letter
 */

function checkLetter(value) {
	return !/[^A-Za-z]/.test(value);
}

function checkDigit(value) {
	return !/[^0-9]/.test(value);
}

function checkLetterDigit(value) {
	return !/[^A-Za-z0-9]/.test(value);
}

var _mapFormatExec = {
	'A': function(value) {
		return checkLetter(value) && value.toUpperCase();
	},
	'B': function(value) {
		return checkLetterDigit(value) && value.toUpperCase();
	},
	'a': function(value) {
		return checkLetter(value) && value.toLowerCase();
	},
	'b': function(value) {
		return checkLetterDigit(value) && value.toLowerCase();
	},
};



exports.format = function(value, format, type, formatExt) {


	function getFormatElems(format) {
		var elems = mapFormat[format];
		if (!elems) {
			var res = format.match(/K?(\w*):?(.*)/);
			console.log("res " + res);
			elems = mapFormat[format] = res.length >= 2 ? (res[2] || res[1]).match(/(\d*.)/g) : null;
		}
		console.log("eleme " + elems);
		return elems;
	}


	/*
	 * return a object that contain at least ok property with true of false that describe if the format succeeed or not
	 * if ok has true value, the objet should contain value that is formated value and formatLen that is the len treated
	 */
	function execElem(elemFormat, valueToFormat, treatedFormat, formatExt, formatExtStdType) { // for prevent loop
		treatedFormat = treatedFormat || [];


		var elem = elemFormat && elemFormat.match(/(\d*)(.)/);
		var formated = "";
		if (elem.length === 3) {

			var len = elem[1] ? parseInt(elem[1], 10) : 1;
			var fmt = elem[2];
			var val = len > valueToFormat.length ? valueToFormat : valueToFormat.substring(0, len);

			if (formatExt && formatExt[fmt] && treatedFormat.indexOf(fmt) !== -1) {
				// loop detected
				throw new Error(locale.format(module, "loopSuperFormat"));
			}



			if (formatExt && formatExt[fmt]) {
				formatExtStdType = formatExtStdType ||  formatExt[fmt].stdType;
				treatedFormat.push(formatExt);
				// execute super format
				// add the len + the computed format

				for (var j = 0; j < val.length; j++) {
					var char = val[j];
					// check for each type define in super type and if any of those match raise an excpetion else keep the first that match
					var found = {
						ok: false
					};
					for (var i = 0; i < formatExt[fmt].chars.length && !found.ok; i++) {
						// check if the character is a stdType character

						found = {
							ok: formatExtStdType && formatExtStdType.indexOf(char) >= 0,
							value: char,
							formatLen: 1
						};
						if (!found.ok) { // if not a stdType character check if it's a format
							found = execElem(formatExt[fmt].chars[i], char, treatedFormat, formatExt, formatExtStdType);
						}
					};

					if (found.ok) // if we found it we add to the formated value
						formated += found.value;

				};
				/*if (formated.length !== len) {
					return {
						ok: false
					};
				}*/

			} else {

				formated = _mapFormatExec[fmt] ? _mapFormatExec[fmt](val) : val;

			}
		} else {
			formated = valueToFormat;
		}
		if (formated !== false) {
			return {
				ok: true,
				formatLen: len,
				value: formated
			};
		} else
			return {
				ok: false
			};
	}

	function exec(elems, value, format, formatExt, treatedFormat) {


		var resValue = "";
		var idx = 0;
		var result;
		for (var i = 0; elems && i < elems.length; i++) {

			// get the digit if exists and the character part

			result = execElem(elems[i], value.substring(idx), treatedFormat, formatExt);

			if (!result.ok) {
				throw new Error(locale.format(module, "badFormat"));
			}
			idx += result.formatLen;
			resValue += result.value;

		}
		return {
			formatLen: idx,
			value: resValue
		};
	}

	if (!value ||  !format ||  !type) { // no value or no format we do nothin
		return value;
	}

	var resValue = "";
	if (type === "application/x-string") { // string treatment
		// check if the format is already compute or if we need to analyse it
		var elems = getFormatElems(format);

		var res = elems && exec(elems, value, format, formatExt);

		if (value.length > res.formatLen) { // value length is greater than format length
			throw new Error(locale.format(module, "valueTooLong")); // should never happen because $maxLength should be coherent with the format
		}
		resValue = res && res.value;

	} else {
		resValue = value;
	}


	return resValue;
};