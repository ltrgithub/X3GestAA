"use strict";

var locale = require("syracuse-core/lib/locale");


var mapFormat = {};
/*
 *  provide a simple function to format a value
 *
 *  raise a exception if the format is not correct
 */

exports.format = function(value, format, type, formatExt) {

	function exec(elems) {
		var resValue = "";
		var totalLen = 0;
		var idx = 0;
		var len;
		for (var i = 0; elems && i < elems.length; i++) {

			// get the digit if exists and the character part
			var elem = elems[i] && elems[i].match(/(\d*)(.)/);
			if (elem.length === 3) {

				len = elem[1] ? parseInt(elem[1], 10) : 1;

				totalLen += len;

				var end = len + idx > value.length ? idx + value.length : idx + len;

				var prev = value.substring(idx, end);

				switch (elem[2]) {
					case 'A':
						if (/[^A-Za-z]/.test(prev)) { // if we find any character that is not a letter
							throw new Error(locale.format(module, "badFormat"));
						}
					case 'B':
						if (/[^A-Za-z0-9]/.test(prev)) { // if we find any character that is not a letter or digit
							throw new Error(locale.format(module, "badFormat"));
						}
						resValue += prev.toUpperCase();
						break;
					case 'a':
						if (/[^A-Za-z]/.test(prev)) { // if we find any character that is not a letter
							throw new Error(locale.format(module, "badFormat"));
						}
					case 'b':
						if (/[^A-Za-z0-9]/.test(prev)) { // if we find any character that is not a letter or digit
							throw new Error(locale.format(module, "badFormat"));
						}
						resValue += prev.toLowerCase();
						break;
					default:
						resValue += prev;
						// nothin
				}
				idx = end;

			}
		}
		return {
			formatLen: totalLen,
			value: resValue
		};
	}

	if (!value ||  !format ||  !type) { // no value or no format we do nothin
		return value;
	}

	var resValue = "";
	if (type === "application/x-string") { // string treatment
		// check if the format is already compute or if we need to analyse it
		var elems = mapFormat[format];
		if (!elems) {
			var res = format.match(/K?(\w*):?(.*)/);

			elems = mapFormat[format] = res.length >= 2 ? (res[1] || res[2]).match(/(\d*.)/g) : null;
		}

		res = elems && exec(elems);

		if (value.length > res.formatLen) { // value length is greater than format length
			throw new Error(locale.format(module, "valueTooLong")); // should never happen because $maxLength should be coherent with the format
		}
		resValue = res && res.value;

	} else {
		resValue = value;
	}


	return resValue;
};