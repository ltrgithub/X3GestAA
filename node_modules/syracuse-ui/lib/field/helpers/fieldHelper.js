"use strict";
var _format = require('syracuse-ui/lib/field/helpers/format');
//syra_fields.embedded
exports.advancedState = require('syracuse-ui/lib/field/helpers/advancedState');
exports.embedded = require('syracuse-ui/lib/field/helpers/embedded');
exports.format = _format.format;

var _smartWidth = {
	charWidth: 8,
	small: 15, //10
	medium: 30, //20
	large: 50
};

var _widths = {
	"application/x-icon": {
		$width: 50
	},
	"application/x-date": {
		$maxLength: 10
	},
	"application/x-time": {
		$maxLength: 8
	},
	"application/x-datetime": {
		$maxLength: 20
	},
	"application/x-binary": {
		$width: 30
	},
	"image": {
		$width: 40
	}
};

exports.getCardFieldWidth = function($field) {
	var $width = ($field.$type && _widths[$field.$type]) || {};
	var widthValue = $width.$width;
	var $maxLength = 0;
	if ($field.$precision) {
		$maxLength = $field.$precision + 2 * ($field.$precision / 3); //separator
	}
	if ($field.$scale) {
		$maxLength += $field.$scale + 1; //for separator
	}
	if (!$maxLength) {
		$maxLength = $field.$displayLength || $field.$maxLength || $width.$maxLength;
	}
	$maxLength = $maxLength || _smartWidth.large;
	if ($maxLength <= _smartWidth.small) {
		$maxLength = _smartWidth.small;
	} else {
		if ($maxLength <= _smartWidth.medium) {
			$maxLength = _smartWidth.medium;
		} else {
			$maxLength = _smartWidth.large;
		}
	}
	widthValue = (_smartWidth.charWidth * $maxLength);
	return widthValue;
};


/************************************   Custom Style  ***********************************/
function _updateFusionStyle(field, saveKey, target, newStyle) {
	var previous = field[saveKey];
	if (previous) {
		//clean
		var domStyle = target.getAttribute("style");
		var domStyleParts = domStyle.split(";");
		for (var mm = 0, kk = domStyleParts.length; mm < kk; mm++) {
			domStyleParts[mm] = domStyleParts[mm].trim();
		}
		var previousParts = previous.split(";");
		for (var ii = 0, jj = previousParts.length; ii < jj; ii++) {
			if (previousParts[ii]) {
				var parts = previousParts[ii].split(":");
				if (parts.length > 0) {
					parts[0] = parts[0].trim();
					for (var mm = 0, kk = domStyleParts.length; mm < kk; mm++) {
						if (domStyleParts[mm].indexOf(parts[0]) == 0) {
							domStyleParts.splice(mm, 1);
							break;
						}
					}
				}
			}
		}
		target.setAttribute("style", domStyleParts.join(";"));
	}
	if (newStyle) {
		field[saveKey] = newStyle;
		target.setAttribute("style", (target.getAttribute("style") || "") + ";" + newStyle);
	} else {
		delete field[saveKey];
	}
}

exports.applyCustomStyle = function(field, metaData) {
	if (field.variantItem) {
		exports.applyCustomStyle(field.variantItem, metaData);
	} else {
		var target;
		var newStyle = metaData.$fieldStyle || metaData.$valueStyle;
		if (newStyle !== undefined) {
			target = field.customStyleTarget || (field.input ? field.input : field._dataValue);
			if (field.page.isFusionPage) {
				_updateFusionStyle(field, "$valueStyle", target, newStyle);
			} else {
				if (field.$valueStyle) {
					syra_dom.toggleClass(target, field.$valueStyle, false);
				}
				syra_dom.toggleClass(target, (field.$valueStyle = (newStyle || "").replace("cst_sty_", "s-cst-sty-")), true);
			}
		}
		newStyle = metaData.$fieldStyle || metaData.$titleStyle;
		if (field.domTitle && newStyle !== undefined) {
			if (field.page.isFusionPage) {
				_updateFusionStyle(field, "$titleStyle", field.domTitle, newStyle);
			} else {
				if (field.$titleStyle) {
					syra_dom.toggleClass(field.domTitle, field.$titleStyle, false);
				}
				syra_dom.toggleClass(field.domTitle, (field.$titleStyle = (newStyle || "").replace("cst_sty_", "s-cst-sty-")), true);
			}
		}
	}
};

exports.getTypeFieldIcon = function($type) {
	var type = $type.replace("application/x-", "");
	switch (type) {
		case "decimal":
		case "integer":
		case "real":
		case "quantity":
			type = "number";
			break;
		case "cube":
			type = "graph";
			break;
		case "icon":
		case "binary":
		case "document":
			type = "image";
			break;
		default:
			if (type.indexOf("text/") >= 0) {
				type = "text";
			}
			break;
	}
	type = "field_" + type;
	if (!syra_icon.font[type]) {
		type = "field_string";
	}
	return type;
};

exports.checkbox = {
	render: function(item, id, css, isRadio) {
		var box = {
			slot: document.createElement("div"),
			icon: document.createElement("label"),
			input: document.createElement("input")
		};
		box.slot.className = css + " s-checkbox-slot";
		box.icon.setAttribute("for", id);
		box.icon.className = css + " s-checkbox-icon s-fonticon-btn";
		box.input = document.createElement("input");
		box.input.id = id;
		box.input.className = css + " s-checkbox-input";
		box.icon.syraIsRadio = isRadio;
		if (isRadio) {
			box.icon.innerHTML = syra_icon.font.field_radio_off;
			box.input.setAttribute("type", "checkbox");
		} else {
			box.icon.innerHTML = syra_icon.font.field_checkbox_off;
			box.input.setAttribute("type", "checkbox");
		}
		box.slot.appendChild(box.icon);
		var slot = syra_dom.div(css + " s-checkbox-input-slot");
		slot.appendChild(box.input);
		box.slot.appendChild(slot);
		item.checkBox = box;
	},
	setIcon: function(item, isChecked) {
		var icon = item.checkBox.icon;
		if (icon.syraIsChecked !== isChecked) {
			icon.syraIsChecked = isChecked;
			if (icon.syraIsRadio) {
				icon.innerHTML = isChecked ? syra_icon.font.field_radio_on : syra_icon.font.field_radio_off;
			} else {
				icon.innerHTML = isChecked ? syra_icon.font.field_checkbox_on : syra_icon.font.field_checkbox_off;
			}
			item.checkBox.input.setAttribute("data-s-selected", isChecked);
		}
	},
	setValue: function(item, isChecked) {
		this.setIcon(item, isChecked);
		item.checkBox.input.checked = isChecked;
	}
};

exports.onFieldFocusChange = function(field, isIn, event) {
	if (isIn) {
		field.page.focusField = field;
		field.articleParent.onFieldFocusChange && field.articleParent.onFieldFocusChange(field, true);
		exports.ensureRecordUniqueSelection(field);
		syra_site.closePopups(field, event);
	} else {
		if (field.page && field.page.focusField == field) {
			field.articleParent.onFieldFocusChange && field.articleParent.onFieldFocusChange(field, false);
			field.page.focusField = null;
		}
	}
};

exports.ensureRecordUniqueSelection = function(list, onSelect) {
	var record;
	while (list && !list.isArrayField) {
		if (list.isRecordArticle) {
			record = list;
		}
		list = list.articleParent;
	}
	if (list && !list.isArrayField) {
		list = null;
	}
	if (syra_site._selectedList && syra_site._selectedList.selector) {
		//if (list != syra_site._selectedList || (record && !record.$isSelected)) { // && !syra_site._selectedList.selector.isMulti)) {
		if (list != syra_site._selectedList || (record && !record.$isSelected && !syra_site._selectedList.selector.isMulti)) {
			syra_site._selectedList.selector.unSelectAll();
		}
	}
	if (onSelect) {
		syra_site._selectedList = list;
	}
};


exports.addDetailLink = function(field, value, $detailsLink) {
	if (!field.$isDetailLinkDisabled) {
		if (field.builder) {
			value = (field.$selectedEnum && field.$selectedEnum.$title) || value;
		}
		var link = field.picker_menus && field.picker_menus.link;
		syra_dom.remove(link);
		syra_dom.empty(field._dataValue);
		var mn = field.page.addItem(field._dataValue, {
			$bind: "$detail",
			$title: $detailsLink.$title = value + "",
			$category: "link",
			$skin: field.$skin + "-link",
			$format: field.$field.$format
		}, field.boxParent);
		mn.detailFieldId = field.id;
		mn.setMenu($detailsLink);
		link && field._dataValue.appendChild(link);
	}
};

exports.scrollToField = function(field) {
	if (!field._isScollToTieldDisabled) {
		var list = field.articleParent.isRecordArticle && field.articleParent.list;
		if (list && list.scrollToRecordField) {
			list.scrollToRecordField(field);
		} else {
			field.page.scrollToItem(field);
		}
	}
};

exports.ensureEditMode = function(field) {
	if (field.$isEditMode === undefined) {
		field.$isEditMode = field.$field.$isEditMode;
		if (field.$isEditMode === undefined) {
			field.$isEditMode = field.$item.$isEditMode;
		}
		if (field.$isEditMode === undefined) {
			field.$isEditMode = field.articleParent.$isEditMode;
		}
	}
};

exports.setDescription = function(field, $description) {
	if ($description !== undefined) {
		if (field.variantItem) {
			field = field.variantItem;
		}
		if (field.setDescription) {
			return field.setDescription(value);
		}
		field.descriptionText = field.$description = $description || "";
		if (field.descriptionText.length > 0) {
			if (field.descriptionText[1] == "@") {
				field.descriptionText = syra_expression.render(field.boxParent, field.descriptionText);
			}
			if (!field.$item.$inplace) {
				if (!field.descriptionItem) {
					field.descriptionItem = document.createElement("div");
					var css = field.$skinField + "-desc";
					if (field.$item.$css) {
						css += " " + field.$item.$css;
					}
					field.descriptionItem.className = css;
					field._dataValue.parentNode.insertBefore(field.descriptionItem, field._dataValue.nextSibling);
				}
				field.descriptionItem.textContent = field.descriptionText;
			}
		} else {
			if (field.descriptionItem) {
				syra_dom.remove(field.descriptionItem);
				field.descriptionItem = null;
			}
		}
	}
};


function _getCsBeside(field) {
	if (!field.$item.$inplace && !field.$item.$isTopLabelAlignment) {
		return field.$isEditMode ? " s-beside-edit" : " s-beside-read";
	}
	return "";
}

exports.addTitle = function(field, isDesignMeta) {
	if (field.variantItem) {
		field = field.variantItem;
	}
	if (!(field.$item.$inplace || field.$item.$isTitleHidden)) {
		if (field.isTabletDevice) {
			// On a tablet the label is sensitive - click sets focus on attached field
			field.domTitle = document.createElement("div");
		} else {
			field.domTitle = document.createElement("label");
			if (field.inputId) {
				field.domTitle.setAttribute("for", field.inputId);
			}
		}
		field.domTitle.className = field._$cssField + "-title" + _getCsBeside(field);
		if (isDesignMeta) {
			field.domItem.appendChild(field.domTitle);
		} else {
			field.domItem.insertBefore(field.domTitle, field.domItem.firstChild);
		}
	}
};

exports.addValueSlot = function(field) {
	var css = field._$cssField + (field.$isEditMode ? "-value-edit" : "-value-read");
	field._dataValue = field._dataValue || document.createElement("div");
	if (field.$item.$inplace) {
		if (field.$isEditMode && field.$item.$isGridCell) {
			css = "s-grid-cell-value-edit " + css;
		}
		field._core = field._dataValue;
	} else {
		field._core = syra_dom.div(field._$cssField + "-core" + _getCsBeside(field));
		field._core.appendChild(field._dataValue);
	}
	field._dataValue.className = css;
	field.domItem.className += " " + field._$cssField + _getCsBeside(field);
	field.domItem.appendChild(field._core);

	if (field.$cssFieldType) {
		field._dataValue.className += " " + field.$cssFieldType;
	}
};


exports.showField = function(field, show) {
	if (field.variantItem) {
		field = field.variantItem;
	}
	field.isInvisible = !show;
	if (field.$item.$inplace) {
		syra_dom.hide(field._dataValue, !show);
	} else {
		field.layoutParent && field.layoutParent.ensureItemVisibility(field, !show);
		syra_dom.hide(field.domItem, !show);
		exports.ensureSectionVisibility(field);
	}
};


exports.ensureSectionVisibility = function(field) {
	if (!field.$item.$inplace && field.page.isPageLoaded) {
		var section = field.boxParent;
		if (field.isInvisible) {
			while (section && !section.isInvisible) {
				syra_layout.ensureSectionVisibility(section);
				if (!section.isInvisible) {
					break; //section is visible, so no need to continue to hide parent
				}
				section = section.boxParent;
			}
		} else {
			while (section && section.isInvisible) {
				syra_layout.ensureSectionVisibility(section);
				section = section.boxParent;
			}
		}
	}
};

exports.setState = function(field, state) {
	if (field.variantItem) {
		field = field.variantItem;
	}
	if (!field.$item.$isFilterMode) {
		if (state.$isMandatory !== undefined) {
			field.$isMandatory = state.$isMandatory;
			if (field.$isEditMode) {
				if (field.domTitle && field.getTitle().length > 0) {
					syra_dom.toggleClass(field.domTitle, "s-mandatory", state.$isMandatory);
					if (state.$isMandatory) {
						if (!field._mandatoryFlag) {
							field._mandatoryFlag = syra_button.add({
								isIndicator: true,
								parent: field,
								slot: field.domTitle,
								iconOnly: true,
								css: "s-field-mandatory-flag",
								fontIcon: "mandatory"
							});
						}
					} else {
						syra_button.remove(field._mandatoryFlag);
						field._mandatoryFlag = null;
					}
				}
				syra_dom.toggleClass(field._dataValue, "s-mandatory", state.$isMandatory);
			}
		}
		if (state.$isDisabled !== undefined) {
			field.$isDisabled = state.$isDisabled;
			syra_dom.disable(field.domItem, state.$isDisabled, true);
			if (field.input) {
				syra_dom.disable(field.input, state.$isDisabled);
				if (field.$item.$contentEditable) {
					_contentEditable.setState(field, state);
				}
			}
			field.domTitle && syra_dom.disable(field.domTitle, state.$isDisabled);
			field.descriptionItem && syra_dom.disable(field.descriptionItem, state.$isDisabled);
			syra_dom.disable(field._dataValue, state.$isDisabled);
		}
		if (state.$isReadOnly !== undefined) {
			field.$isReadOnly = state.$isReadOnly;
			field._onSetReadOnly && field._onSetReadOnly(state.$isReadOnly);
		}
		if (field._mandatoryFlag) {
			syra_button.disable(field._mandatoryFlag, field.$isDisabled || field.$isReadOnly);
		}
		field.$isEditMode && syra_menus.applyFieldState(field);
	}
	if (state.$isHidden !== undefined) {
		exports.showField(field, !(field.$isHidden = state.$isHidden));
	}
};

exports.applyMetaData = function(field, metaData, options) {
	if (field._dataValue) { //important for reloading and initiliaze method called before render
		if (metaData) {
			if (metaData.$title !== undefined) {
				field.setTitle(metaData.$title);
			}
			if (metaData.$description !== undefined) {
				exports.setDescription(field, metaData.$description);
			}
			field.setState(metaData);
			if (metaData.$diagnoses !== undefined) {
				syra_alert.show(metaData.$diagnoses, field, options);
			}
			syra_menus.applyChange(field, metaData);
			if (!field.$isEditMode && field.currentValue && !field.$isDetailLinkDisabled) {
				if (metaData.$links && metaData.$links.$details) {
					exports.addDetailLink(field, field.currentValue, metaData.$links.$details);
				}
			}
			//$valueStyle can be "" (clear style)  in field case  metaData.$valueStyle is false
			if (metaData.$fieldStyle || metaData.$valueStyle != undefined || metaData.$titleStyle) {
				exports.applyCustomStyle(field, metaData);
			}

			if (field.page.isFusionPage) {
				if (metaData.tit != undefined) {
					field.setTitle(metaData.tit);
				}
				if (metaData.stt != undefined && field.setState) {
					field.setState(syra_fusion.sapUtil.getState(metaData.stt));
				}
				if (metaData.sty != undefined) {
					exports.applyCustomStyle(field, {
						$valueStyle: metaData.sty
					});
				}
			}
		}
	}
};

exports.applyDesignMeta = function(field, metaData, designing) {
	if (field.variantItem) {
		field = field.variantItem;
	}
	if (metaData.$isHidden !== undefined) {
		field.setState(metaData);
	}
	if (designing !== false) {
		if (metaData.$isTopLabelAlignment !== undefined) {
			field.$item.$isTopLabelAlignment = metaData.$isTopLabelAlignment;
			if (field.$item.$isTopLabelAlignment) {
				metaData.$isRightTextLabelAlignment = false;
			}
			var beside = field.$isEditMode ? " s-beside-edit" : " s-beside-read";
			if (field.domTitle) {
				syra_dom.toggleClass(field.domTitle, beside, !field.$item.$isTopLabelAlignment);
			}
			syra_dom.toggleClass(field._core, beside, !field.$item.$isTopLabelAlignment);
			syra_dom.toggleClass(field.domItem, beside, !field.$item.$isTopLabelAlignment);
		}
		if (metaData.$isAdvanced !== undefined) {
			exports.advancedState.setState(field, metaData.$isAdvanced, designing);
		}
	}
	if (metaData.$isTitleHidden !== undefined) {
		field.$item.$isTitleHidden = metaData.$isTitleHidden;
		if (!metaData.$isTitleHidden && !field.domTitle) {
			exports.addTitle(field, true);
			field.setTitle(field.getTitle());
		}
	}
	if (metaData.$isTitleEmpty !== undefined) {
		field.$item.$isTitleEmpty = metaData.$isTitleEmpty;
	}
	if (field.domTitle) {
		if (metaData.$isTitleEmpty !== undefined) {
			field.setTitle(field.getTitle());
		}
		if (metaData.$isTitleHidden !== undefined) {
			syra_dom.hide(field.domTitle, metaData.$isTitleHidden);
		}
		if (metaData.$isRightTextLabelAlignment !== undefined) {
			field.domTitle.style.textAlign = (field.$item.$isRightTextLabelAlignment = metaData.$isRightTextLabelAlignment) ? "right" : "left";
		}
	}
};

exports.initCss = function(field) {
	field._$cssField = (field.$item.$css) ? (field.$item.$css + " " + field.$skinField) : field.$skinField;
};


exports.getTitle = function(field) {
	if (field.variantItem) {
		field = field.variantItem;
	}
	if (field.titleText == null && field.$titleValue) {
		field.titleText = field.$titleValue || "";
		if (field.titleText.length > 0 && field.titleText[1] == "@") {
			field.titleText = syra_expression.render(field.boxParent, field.titleText);
		}
	}
	return field.titleText || "";
};
exports.setTitle = function(field, $title) {
	if (field.variantItem) {
		field = field.variantItem;
	}
	field.$titleValue = $title;
	delete field.titleText;
	if (field.domTitle) {
		if (field._mandatoryFlag) {
			syra_dom.remove(field._mandatoryFlag.link);
			field.domTitle.textContent = field.$item.$isTitleEmpty ? "" : field.getTitle();
			field.domTitle.appendChild(field._mandatoryFlag.link);
		} else {
			field.domTitle.textContent = field.$item.$isTitleEmpty ? "" : field.getTitle();
		}
	} else {
		if (field.input && field.$item.$isTitlePlaceHolder) {
			field.input.setAttribute("placeholder", field.getTitle());
			if (field.$item.$contentEditable && field.currentValue == null) {
				field.setInputValue("");
			}
		}
	}
};

exports.ensureLayoutMode = function(field) {
	if (field.ensureLayoutMode) {
		field.ensureLayoutMode();
	} else {
		if (field.variantItem) {
			field = field.variantItem;
		}
		field.layoutParent && field.layoutParent.ensureLayoutSlot(field);
	}
};


exports.invalidate = function(field, errors, options) {
	if (field.variantItem) {
		exports.invalidate(field.variantItem, errors, options);
	} else {
		var diagnoses = [];
		errors = errors || [];
		if (!Array.isArray(errors)) {
			errors = [errors];
		}
		for (var ii = 0, jj = errors.length; ii < jj; ii++) {
			diagnoses.push({
				$message: errors[ii],
				$severity: "error"
			});
		}
		syra_alert.error(diagnoses, field, options);
		field.isInvalid = errors.length > 0;
	}
};