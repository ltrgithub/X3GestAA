"use strict";
/// !doc
///
/// # Html editor widget that supports RFT conversion
///
/// `HtmlEditor` class subclasses the `Field` class
/// ```javascript
/// var htmlEditor = require('syracuse-ui/lib/field/editor/htmlEditor').HtmlEditor;
/// ```
///
var helpers = require('syracuse-core/lib/helpers');
var resUtil = require('syracuse-core/lib/resource/util');
var aspect = require('syracuse-core/lib/aspect');
var locale = require('syracuse-core/lib/locale');
var Field = require('syracuse-ui/lib/field/field').Field;
var rtf = require("syracuse-rtf");
// require('syracuse-ui/deps/cleditor/jquery.cleditor.min');
require('syracuse-ui/deps/cleditor/jquery.cleditor');

var debug = false;

var ie = $.browser.msie,
    fontSizes = "8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,72";

// Default values are the English one
var _localize = {};

function normalizeRawText(text) {
    return text.replace(/&nbsp;/gi, " ") //
    .replace(/<br\s*[\/]?>/gi, "\r\n") //
    .replace(/<p>/gi, "\r\n");
}

function normalizeHtmlText(html) {
    return html.replace(/\r\n/g, "<br/>") //
    .replace(/\n/g, "<br/>") //
    .replace(/\s/g, "&nbsp;");
}

function fixHtml(html) {
    return html.replace(/<br\s*[\/]?>$/gi, "");
}

function sanitize(html) {
    return rtf.toHtml(rtf.fromHtml(html));
}

// checksum - returns a checksum using the Adler-32 method

function checksum(text) {
    var a = 1,
        b = 0;
    for (var index = 0; index < text.length; ++index) {
        a = (a + text.charCodeAt(index)) % 65521;
        b = (b + a) % 65521;
    }
    return (b << 16) | a;
}

function lazyInit($) {
    // var cleditor = require.async('syracuse-ui/deps/cleditor/jquery.cleditor', function(err, module){});
    var $buttons = $.cleditor.buttons;

    function localize() {
        helpers.object.forEachKey($buttons, function(key) {
            $buttons[key].title = _localize[key] || key + ":<undefined>";
        });
        if ($buttons.rawMode) $buttons.rawMode.title = _localize.rawMode;
    }

    _localize = locale.resources(module)();
    localize();

    if ($buttons.rawMode != null) {
        return;
    }

    var popupRawModeContent = '<div class="s-msgbox" style="display: inline-block;">' //
    + '<div class="s-msgbox-header">' //
    + '<div class="s-msgbox-header-title s-msgbox-msg-warning">' + _localize.aboutToSwitchToRawTitle + '</div>' //
    + '</div>' //
    + '<div class="s-msgbox-body">' + _localize.aboutToSwitchToRawConfirm + '</div>' //
    + '<div class="s-msgbox-foot">' //
    + '<a class="s-msgbox-button s-msgbox-button-default" data-s-id="yes">' + _localize.yes + '</a>' //
    + '<a class="s-msgbox-button" data-s-id="no">' + _localize.no + '</a>' //
    + '</div>' //
    + '</div>' //
    + '</div>';

    $buttons.rawMode = {
        name: "rawMode",
        title: _localize.rawMode,
        popupName: "rawMode",
        popupClass: "cleditorPrompt",
        popupContent: popupRawModeContent,
    };


/*$.each(textModes.split(","), function(i, mode){
     $('<div>').appendTo( $$popupRawModeContent).html(mode);
     });*/
/*var  $$listRawMode = $('<select>').attr('mode', function(){
     if ($.cleditor._isRaw)
     return 'rawtext' ;
     else return 'richtext'}) ;
     $$popupRawModeContent.append($$listRawMode);
     $.each(textModes.split(","), function(i, mode){
     $('<option>').append(mode).appendTo( $$listRawMode);
     });*/
    $buttons.rawMode.getEnabled = function(data) {
        var rawAllowed = data.editor.options._rawAllowed();
        if (rawAllowed && data.editor.options._isRaw()) {
            data.button.title = _localize.richMode;
            $(data.button).removeClass("buttonRichText").addClass("buttonRawText");
        } else {
            data.button.title = _localize.rawMode;
            $(data.button).removeClass("buttonRawText").addClass("buttonRichText");
        }
        return rawAllowed;
    }

    // $buttons.rawMode.popupContent = $$popupRawModeContent.html();
    $buttons.rawMode.buttonClick = function(e, data) {
        var button = e.target,
            editor = data.editor,
            $$popup = $(data.popup),
            html;


        if (editor.options._isRaw()) {
            editor.options._setRaw(false);
            html = normalizeHtmlText(fixHtml(editor.$area.val()));
            var $$content = $(html);
            if ($$content.is('pre')) {
                html = $$content.html();
            }
            $(editor.doc.body).html(html);
            editor.options._setRaw(false);
            button.title = _localize.rawMode;
            $(button).removeClass("buttonRawText").addClass("buttonRichText");
            editor.updateTextArea();
            editor.focus(editor);
            return false;
        }

        $$popup.css("padding", "0");
        // Wire up the submit button click event handler
        $$popup.find(".s-msgbox-button").unbind("click").bind("click", function() {
            if ($(this).attr('data-s-id') === "yes") {
                if (!editor.options._isRaw()) {
                    var rawtext = $('<div>').html(normalizeRawText(editor.$area.val())).text(),
                        $$pre = $('<pre>').appendTo('<div>').html(rawtext);
                    editor.$area.val($$pre.parent().html());

                    editor.options._setRaw(true);
                    button.title = _localize.richMode;
                    $(button).removeClass("buttonRichText").addClass("buttonRawText");
                }
                editor.updateFrame();
                editor.disable(editor.disabled);
            }
            editor.hidePopups();
            editor.focus(editor);
        });

        return true;
    };


    var $$popupContent = $('<div>'),
        $$list = $('<select>').attr('size', '8');
    $$popupContent.append($$list);
    $.each(fontSizes.split(","), function(i, size) {
        $('<option>').append(size).appendTo($$list);
        // $('<div>').append($('<span>').prepend(size)).appendTo($$popupContent);
    });

    // font size button
    $buttons.size.popupContent = $$popupContent.html();
    $buttons.size.popupClass = "cleditorList";
    $buttons.size.popupClick = function(e, data) {
        // TODO: fix text selection which is reset after inserting html contents. see createSelection
        // var editor = data.editor,
        //     text = editor.selectedText();
        // // var range = _getRange(editor);
        // var value = target.value || data.value;
        // var html = '<span style="font-size:' + e.target.value + 'pt">' + text + '</span>';
        // editor.execCommand("inserthtml", html, null, data.button);
        // editor.hidePopups();
        // editor.focus(editor);
        // range && range.select();
        // return false;
        data.command = "inserthtml";
        data.value = '<span style="font-size:' + e.target.value + 'pt; ">' + data.editor.selectedText() + '</span>';
        return true;
    };

    $buttons.source.getEnabled = function(data) {
        var rawAllowed = data.editor.options._rawAllowed();
        return !(rawAllowed && data.editor.options._isRaw());
    }

    // paste button
    // $buttons.paste.buttonClick = function(e, data) {
    //     data.editor.execCommand(data.command, data.value, data.useCSS, data.button);
    //     return false;
    // };
    var formattingbuttons = "bold italic underline strikethrough subscript superscript font size " //
    + "color highlight bullets numbering outdent indent alignleft center alignright " //
    + "justify rule image link unlink removeformat";
    $.each(formattingbuttons.split(" "), function(idx, buttonName) {

        $buttons[buttonName].getEnabled = function(data) {
            return !data.editor.options._isRaw();
        }
    });
}

function _getRange(editor) {
    // if (ie) return _getSelection(editor).createRange();
    return _getSelection(editor).getRangeAt(0);
}

function _getSelection(editor) {
    // supported by all browsers including ie9
    return editor.$frame[0].contentWindow.getSelection();
}


function HtmlEditor() {}

exports.HtmlEditor = helpers.defineClass(HtmlEditor, Field, {
    initialize: function() {
        this.$item.$isAutoSizeDisabled = true;
        this.$item.$isAutoSize = true;
        this._cache = {};
    },

    onWindowResize: function() {
        if (this._editor && this._editor.$frame && this._editor.$frame[0] && this._editor.$frame[0].contentWindow) {
            this._editor.refresh();
        }
    },

    /// -------------
    /// ## setDataValue(value)
    /// 
    /// Sets the content value.
    ///   
    /// This method is not intended to be called directly.  
    /// The normal way to set the value with its metadata is to call `setDataBind(value, record, metaData)`
    /// 
    /// **Overrides:** Field.setDataValue(...)
    /// 
    setDataValue: function(value) {
        debug && console.log('htmlEditor.setDataValue 1: ' + this.id + '\n$isEditMode=' + this.$isEditMode + '\ncurrent:\n' + this.currentValue + '\nnew value:\n' + value);
        try {
            if (this.currentValue != value) {
                var styles = this.$field.$styles;
                // var styles = Array.isArray(value.$styles) ? styles = value.$styles.join("\n") : styles = value.$styles;
                // this._editor.options.headStyle = styles || this._editor.options.headStyle;
                this._setContents(value, true);
                this._cache.oldValue = this.currentValue = this._getPersistentContents();
                // this._cache.dirtyChecksum = this._cache.checksum;
            }
        } catch (error) {
            this.showErrors([error.message]);
        }
        debug && console.log('htmlEditor.setDataValue 2: ' + this.id + '\n$isEditMode=' + this.$isEditMode + ', checksum=' + this._cache.dirtyChecksum + //
        '\ncurrent:\n' + this.currentValue + '\nnew:\n' + value);

        this._refreshToolbar();
    },
    /// -------------
    /// ## getInputValue()
    /// 
    /// Gets the content value.
    /// 
    /// **Overrides:** Field.getInputValue()
    /// 
    getInputValue: function() {
        debug && console.log('htmlEditor.getInputValue: ' + this.id + ' isDirty=' + this.isDirty() + '\n' + this._getPersistentContents());
        if (this.isEditable() && this._editor && this._editor.$area) {
            var contents = this._getPersistentContents();
            // this._cache.changedChecksum = this._cache.checksum;
            return contents;
        }
        return "";
    },
    /// -------------
    /// ## isDirty()
    /// 
    /// Returns `true` if the content has changed since the field gained the focus or since the last setDataValue.
    /// 
    isDirty: function() {
        // Get the current content to compute the checksum
        var value = this._getPersistentContents(),
            dirty = (this._cache.oldValue !== value);
        // dirty = (this._cache.dirtyChecksum !== this._cache.checksum);
        debug && console.log('htmlEditor.isDirty: ' + this.id + ' isDirty=' + dirty + //
        ", checksum=" + this._cache.checksum + '\nnew:\n' + value + '\nold:\n' + //
        this._cache.oldValue + '\ncached:\n' + this._cache.value + '\nraw:\n' + this._cache.raw);
        return dirty;
    },
    // -------------
    // ## hasChanged()
    // 
    // Returns `true` if the content has changed since the last call to `getInputValue`.
    // 
    // hasChanged: function() {
    //     return (this._cache.changedChecksum == null) || this._cache.changedChecksum !== this._cache.checksum;
    // },
    /// -------------
    /// ## validateType(errors, value)
    /// 
    /// Validates the current value and reports errors.
    /// 
    /// This method is called during the validation process and is not intended to be called directly.  
    /// 
    /// **See:** Field.validate(...)
    /// 
    validateType: function(errors, value) {
        if (this.currentValue && this.$maxLength && this.currentValue.length > this.$maxLength) {
            errors.push(locale.format(_localize.errorMaxLength, this.$maxLength));
        }
        debug && console.log('htmlEditor.validateType: ' + this.id + '\nValue: ' + this.currentValue);
    },
    /// -------------
    /// ## focus()
    /// 
    /// Sets the focus to the edit part of the widget.
    /// 
    /// **Overrides:** Field.focus()
    /// 
    focus: function() {
        debug && console.log('htmlEditor.focus: ' + this.id);
        var self = this;
        // Hack! Delayed call to ensure that the text do not vanish
        setTimeout(function() {
            debug && console.log('htmlEditor.focus: actual delayed call');
            self.isEditable() && self._editor && self._editor.focus();
        }, 100);
    },
    /// -------------
    /// ## getCaretPosition()
    /// 
    /// Gets the current 0 based caret position in the editor.
    /// 
    /// **Overrides:** Field.getCaretPosition()
    /// 
    getCaretPosition: function() {
        if (!(this.isEditable() && this._editor && this._editor.doc.body && this.$$caret)) return 0;

        var doc = this._editor.doc,
            root = doc.body,
            sel = _getSelection(this._editor),
            $$caret = this.$$caret,
            caretPos, range, contents;

        range = doc.createRange();
        range.setStart(root, 0);
        sel.focusNode && range.setEnd(sel.focusNode, sel.focusOffset);
        contents = range.cloneContents();

        if (contents) {
            $$caret.append(contents);
            $$caret.html($$caret.html().replace(/<br\s*[\/]?>/gi, "\n"));
            caretPos = $$caret.text().length;
            $$caret.empty();
        }
        return caretPos;
    },

    isEditable: function() {
        return this.$isEditMode;
    },

    setState: function(state) {
        debug && console.log('htmlEditor.setState: ' + this.id + "\n" + (state ? JSON.stringify(state) : "<undefined>"));
        if (state && state.$isDisabled !== undefined) {
            this._editor && this._editor.disable(state.$isDisabled);
        }
        Field.prototype.setState.call(this, state);
    },

    toggleEditMode: function($isEditMode) {
        // reset value because setDataValue will check the equality
        this.currentValue = undefined;
        Field.prototype.toggleEditMode.call(this, $isEditMode);
    },
    _onSetReadOnly: function($isReadOnly) {
        this._editor && this._editor.disable($isReadOnly);
        Field.prototype._onSetReadOnly.call(this, $isReadOnly);
    },
    render: function() {
        this.$maxLength = this.$field.$maxLength || this.$field.$maxByteLength;
        this.$capabilities = this.$capabilities || resUtil.parseCapabilities(this.$field.$capabilities);
        lazyInit(jQuery);
        debug && console.log('htmlEditor.render ' + this.id);
        var self = this;
        var id = helpers.uuid.generate();
        self.$$dataValue.attr("id", self.id + "-data");
        if (this.isEditable()) {
            // self.standalone = this.boxParent && this.boxParent.$prototype && (this.boxParent.$prototype.$baseUrl === "/sdata/x3stb/erp/stubs");
            this.$$caret = $("<div>").attr("id", id + "-caret").attr("style", "display:none;").appendTo(self.$$dataValue);

            // var css = ((this.$item.$css) ? this.$item.$css + " " : "") + this.$skinInput;
            // this.$$input = $('<textarea>').attr('id', "i" + id).attr('name', "i" + id).addClass(css).appendTo(self.$$fieldValue);
            var $$area = $('<textarea>').attr('id', "html-editor-" + id).attr('name', "html-editor-" + id).attr("data-s-field", id).appendTo($(self.fieldValue));
            this.$item.$rows && $$area.attr("rows", this.$item.$rows);

            self._editor = $$area.cleditor({
                resizeSelector: self.resizeSelector = "resize." + helpers.uuid.generate(),
                // width not including margins, borders or padding
                // width: self.$item.$textWidth || "100%",
                width: self.$item.$textWidth || "auto",
                // height not including margins, borders or padding
                // height: self.$item.$textHeight || 480,
                height: self.$item.$textHeight || "auto",
                controls: "bold italic underline strikethrough subscript superscript | font size | color" //
                + " highlight removeformat | bullets" /*+" numbering"*/
                + " | outdent indent alignleft center alignright justify" //
                + " | undo redo | rule image link unlink" //
                + " | cut copy paste pastetext" //
                + " | print source rawMode",
                // style to assign to document body contained within the editor
                // bodyStyle: "margin:4px; font:10pt Arial,Verdana; cursor:text"
                bodyStyle: "",
                // sizes in the font size popup
                sizes: fontSizes,
                useCSS: true,
                // _field: self,
                _rawAllowed: function() {
                    return self._rawAllowed()
                },
                _isRaw: function() {
                    return self._rawAllowed() && self._isRaw;
                },
                _setRaw: function(v) {
                    if (self._rawAllowed()) self._isRaw = v;
                },
                // Handlers
                updateFrame: function(html) {
                    // TODO: cleanup HTML if necessary
                    debug && console.log('>>>> htmlEditor.editor.updateFrame:\n' + html);
                    return html;
                },
                updateTextArea: function(html) {
                    debug && console.log('>>>> htmlEditor.editor.updateTextArea:\n' + html);
                    return html;
                }
            })[0];

            setTimeout(function() {
                self._finalizeCreate();
            }, 200);
        }
    },

    _isRtfMimeType: function() {
        return this.$field.$type == "text/rtf";
    },

    _finalizeCreate: function() {
        debug && console.log('htmlEditor._finalizeCreate ' + this.id);
        this.setState(this.$field);
        this._refreshToolbar();
        this._editor.refresh();

        // Intercept paste event to get the opportunity of sanitizing the contents
        var $$input = $(this._editor.doc.body);

        this._isRtfMimeType() && $$input.bind('paste', function(e) {
            // this code corrupts the undo stack!!!
            var pastedText = undefined;
            if (e && e.clipboardData && e.clipboardData.getData) {
                if (/text\/html/.test(e.clipboardData.types)) {
                    pastedText = e.clipboardData.getData('text/html');
                } else if (/text\/plain/.test(e.clipboardData.types)) {
                    pastedText = e.clipboardData.getData('text/plain');
                } else {
                    pastedText = "";
                }
            } else if (window.clipboardData && window.clipboardData.getData) { // IE
                pastedText = window.clipboardData.getData('Text');
            } else {
                var el = $(this);
                // Hiding the underlying element causes some unpredictable behavior
                // var display;
                // $.browser.mozilla && (display = el.css('display')) && el.css('display', 'none');
                setTimeout(function() {
                    var text = $(el).html();
                    if (text) {
                        $(el).html(sanitize(text));
                    }
                    // display && el.css('display', display);
                    debug && console.log("htmlEditor..paste after timeout:\n" + text);
                }, 300);
            }
            if (pastedText) {
                $(this).html(sanitize(pastedText));
                e.preventDefault();
                e.stopPropagation();
            }

        });

        this._bindInput(true);
    },
    _refreshToolbar: function() {
        // hack to refresh the toolbar state and disable the toolbar buttons if necessary
        this.isEditable() && this._editor.disable(this._editor.disabled);
    },

    _beforeInputFocusin: function($$input, event) {
        // Get the content to compute the checksum
        this._cache.oldValue = this._getPersistentContents();
        // this._cache.dirtyChecksum = this._cache.checksum;
        debug && console.log("htmlEditor._beforeInputFocusin " + this.id + " checksum=" + this._cache.checksum + "\n" + this._cache.oldValue);
    },

    _bindInput: function(bind) {
        if (this._editor == null) return;

        var self = this;
        debug && console.log("htmlEditor._bindInput " + this.id);
        var doc = this._editor.doc,
            $$doc = $(doc),
            $$input = $(doc.body),
            contentWindow = this._editor.$frame[0].contentWindow,
            $$inputWindow = $.browser.mozilla ? $$doc : $(contentWindow);

        if (bind) {
            $$input //
            .on("change keydown keypress keyup focusin focusout", function(event) {
                debug && console.log("htmlEditor.bindInputEvent $$input: " + event.type + " " + self.id);
                self.onFieldInputEvent(event);
                event.stopPropagation();
            });

            $$inputWindow //
            .on("click", function(event) {
                debug && console.log("htmlEditor.bindInputEvent click --> click" + self.id);
                self.onFieldInputEvent(event);
                event.stopPropagation();
            }) //
            .focus(function(event) {
                debug && console.log("htmlEditor.bindInputEvent focus --> focusin " + self.id);
                self._beforeInputFocusin($$input, event);
                $$input.trigger("focusin");
                self._editor.$main.addClass("cleditorMain-focus");
                event.stopPropagation();
            }) //
            .blur(function(event) {
                debug && console.log("htmlEditor.bindInputEvent blur --> focusout " + self.id);
                debug && console.log("\tCaret position: " + self.getCaretPosition());
                self._editor.$main.removeClass("cleditorMain-focus");

                if (self.isDirty()) {
                    $$input.trigger("change");
                }
                $$input.trigger("focusout");
                event.stopPropagation();
            }) //
            ;
        } else {
            $$input.off();
            $$inputWindow.off();
        }
    },

    _rawAllowed: function() {
        return this._isRtfMimeType() && this.$capabilities && this.$capabilities.raw;
    },

    _setRawEditContents: function(contents) {
        if (this.isEditable() && this._editor && this._editor.$area) {
            debug && console.log('htmlEditor._setRawEditContents:\n' + contents);
            this._editor.$area.val(contents || '');
            this._editor.updateFrame();
        }
    },

    _getRawEditContents: function() {
        return this.isEditable() && this._editor && this._editor.$area && fixHtml(this._editor.$area.val());
    },

    _setContents: function(contents, saveStyles) {
        debug && console.log('htmlEditor._setContents 1: isEditable()=' + this.isEditable() + '\n' + contents);
        this._isRaw = false;
        if (!contents || contents.length === 0) {
            // No contents, assume we want to edit Rich Text or HTML
        } else {
            switch (this.$field.$type) {
            case "text/rtf":
                if (contents.match(/^\s*{\\rtf/)) {
                    contents = rtf.toHtml(contents);
                } else if (this._rawAllowed()) {
                    this._isRaw = true;
                    if (!contents.match(/<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i)) {
                        // Not an HTML contents, so wrap it in <pre> tag
                        contents = "<pre>" + contents + "</pre>";
                    }
                } else {
                    this.showDiagnoses([{
                        message: locale.format(_localize.errorRtfExpected, contents),
                        severity: "error"
                    }, {
                        message: _localize.warnContentsNotSet,
                        severity: "warning"
                    }]);
                    return;
                }
                break;
            case "text/html":
                // contents as is
                break;
            }
        }
        debug && console.log('htmlEditor._setContents 2: _isRaw=' + this._isRaw + '\n' + contents);

        if (saveStyles && contents) {
            this.$$savedStyles = $(contents).find('style');
        }
        if (this.isEditable()) {
            this._setRawEditContents(contents);
        } else {
            document.site.emptyDom(this.fieldValue);
            this.fieldValue.innnerHTML = contents;
        }
    },


    _getPersistentContents: function(contents) {
        if (!this.isEditable()) return null;

        if (contents === undefined) {
            contents = this._getRawEditContents();
        }
        var hash = checksum(contents);
        if (hash === this._cache.checksum) return this._cache.value;
        this._cache.raw = contents;
        debug && console.log('htmlEditor._getPersistentContents change: checksum=' + hash + '\nraw:\n' + contents);

        this._cache.checksum = hash;

        if (this.$$savedStyles) {
            var $$contents = $('<div>').append(contents);
            if ($$contents.find('style').length === 0) {
                $$contents.prepend(this.$$savedStyles);
                contents = $$contents.html();
            }
        }
        if (this._isRaw) {
            var outer = $(contents);
            if (outer.is('pre')) contents = normalizeRawText(outer.html());
        } else {
            if (this._isRtfMimeType()) {
                contents = rtf.fromHtml(contents);
            }
        }
        debug && console.log('htmlEditor._getPersistentContents return: checksum=' + hash + '\ncontents:\n' + contents);
        return this._cache.value = contents;
    },

    dispose: function() {
        debug && console.log('htmlEditor.dispose ' + this.id);
        if (this.resizeSelector) {
            $(window).unbind(this.resizeSelector);
        }
        this._bindInput(false);
        if (this._editor) {
            this._editor.dispose();
            delete this._editor;
        }
        Field.prototype.dispose.call(this);
    }

});