"use strict";
/// !doc
///
/// # Html editor widget that supports RFT conversion
///
/// `HtmlEditor` class subclasses the `Field` class
/// ```javascript
/// var htmlEditor = require('syracuse-ui/lib/field/editor/htmlEditor').HtmlEditor;
/// ```
///
var helpers = require('syracuse-core/lib/helpers');
var resUtil = require('syracuse-core/lib/resource/util');
var locale = require('syracuse-core/lib/locale');
var Field = require('syracuse-ui/lib/field/field').Field;
var rtf = require("syracuse-rtf");
// require('syracuse-ui/deps/cleditor/jquery.cleditor.min');
require('syracuse-ui/deps/cleditor/jquery.cleditor');

var debug = false;

var fontSizes = "8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,72";

// Default values are the English one
var _localize = {};

function normalizeRawText(text) {
	return text.replace(/&nbsp;/gi, " ") //
	.replace(/<br\s*[\/]?>/gi, "\r\n") //
	.replace(/<p>/gi, "\r\n");
}

function normalizeHtmlText(html) {
	return html.replace(/\r\n/g, "<br/>") //
	.replace(/\n/g, "<br/>") //
	.replace(/\s/g, "&nbsp;");
}

function fixHtml(html) {
	return html.replace(/<br\s*[\/]?>$/gi, "");
}

function sanitize(html) {
	return rtf.toHtml(rtf.fromHtml(html));
}

// checksum - returns a checksum using the Adler-32 method

function checksum(text) {
	var a = 1,
		b = 0;
	for (var index = 0; index < text.length; ++index) {
		a = (a + text.charCodeAt(index)) % 65521;
		b = (b + a) % 65521;
	}
	return (b << 16) | a;
	// return md5(text);
}

function lazyInit($) {
	// var cleditor = require.async('syracuse-ui/deps/cleditor/jquery.cleditor', function(err, module){});
	var $buttons = $.cleditor.buttons;

	function localize() {
		helpers.object.forEachKey($buttons, function(key) {
			$buttons[key].title = _localize[key] || key + ":<undefined>";
		});
		if ($buttons.rawMode) {
			$buttons.rawMode.title = _localize.rawMode;
		}
	}

	_localize = locale.resources(module)();
	localize();

	if ($buttons.rawMode) {
		return;
	}
	/*
     var popupRawModeContent = '<div class="s-msgbox" style="display: inline-block;">' + //
     '<div class="s-msgbox-head">' + //
     '<div class="s-msgbox-title s-msgbox-msg-warning">' + _localize.aboutToSwitchToRawTitle + '</div>' + //
     '</div>' + //
     '<div class="s-msgbox-body">' + _localize.aboutToSwitchToRawConfirm + '</div>' + //
     '<div class="s-msgbox-foot">' + //
     '<a class="s-msgbox-button s-msgbox-button-default" data-s-id="yes">' + _localize.yes + '</a>' + //
     '<a class="s-msgbox-button" data-s-id="no">' + _localize.no + '</a>' + //
     '</div>' + //
     '</div>' + //
     '</div>';
     */
	// msgbox options
	var options = {
		$type: "warning",
		$buttons: "yesno",
		$title: _localize.aboutToSwitchToRawTitle,
		$message: _localize.aboutToSwitchToRawConfirm,
		$minWidth: "380" //px
	};

	// building msgbox (2nd parameter set to true not to display msgbox in syracuse mode)
	document.site.showMessage(options, true);
	// adding data-s-id attribute
	var menus = Object.keys(document.site.messageBox.menuItems);
	for (var ii = 0, jj = menus.length; ii < jj; ii++) {
		var menuItem = document.site.messageBox.menuItems[menus[ii]];
		menuItem[0].mn.setAttribute("data-s-id", menuItem[0].$title);
	}
	// getting msgbox raw
	var popupRawModeContent = document.site.messageBox.$$item[0];

	$buttons.rawMode = {
		name: "rawMode",
		title: _localize.rawMode,
		popupName: "rawMode",
		popupClass: "cleditorPrompt",
		popupContent: popupRawModeContent,
	};


	/*$.each(textModes.split(","), function(i, mode){
     $('<div>').appendTo( $$popupRawModeContent).html(mode);
     });*/
	/*var  $$listRawMode = $('<select>').attr('mode', function(){
     if ($.cleditor._isRaw)
     return 'rawtext' ;
     else return 'richtext'}) ;
     $$popupRawModeContent.append($$listRawMode);
     $.each(textModes.split(","), function(i, mode){
     $('<option>').append(mode).appendTo( $$listRawMode);
     });*/
	$buttons.rawMode.getEnabled = function(data) {
		var rawAllowed = data.editor.options._rawAllowed();
		if (rawAllowed && data.editor.options._isRaw()) {
			data.button.title = _localize.richMode;
			$(data.button).removeClass("buttonRichText").addClass("buttonRawText");
		} else {
			data.button.title = _localize.rawMode;
			$(data.button).removeClass("buttonRawText").addClass("buttonRichText");
		}
		return rawAllowed;
	};

	// $buttons.rawMode.popupContent = $$popupRawModeContent.html();
	$buttons.rawMode.buttonClick = function(e, data) {
		var button = e.target,
			editor = data.editor,
			$$popup = $(data.popup),
			html;

		if (editor.options._isRaw()) {
			editor.options._setRaw(false);
			html = normalizeHtmlText(fixHtml(editor.$area.val()));
			var $$content = $(html);
			if ($$content.is('pre')) {
				html = $$content.html();
			}
			$(editor.doc.body).html(html);
			editor.options._setRaw(false);
			button.title = _localize.rawMode;
			$(button).removeClass("buttonRawText").addClass("buttonRichText");
			editor.options._freezeCacheChange();
			editor.updateTextArea();
			editor.focus(editor);
			return false;
		}

		$$popup.css("padding", "0");
		// Wire up the submit button click event handler
		$$popup.find(".s-msgbox-buttons-link").unbind("click").bind("click", function(event) {
			event.preventDefault();
			if ($(this).attr('data-s-id') === document.site.localize.msgbox_yes) {
				if (!editor.options._isRaw()) {
					var rawtext = $('<div>').html(normalizeRawText(editor.$area.val())).text(),
						$$pre = $('<pre>').appendTo('<div>').html(rawtext);
					editor.$area.val($$pre.parent().html());

					editor.options._setRaw(true);
					button.title = _localize.richMode;
					$(button).removeClass("buttonRichText").addClass("buttonRawText");
				}
				editor.options._freezeCacheChange();
				editor.updateFrame();
				editor.disable(editor.disabled);
			}
			editor.hidePopups();
			editor.focus(editor);
		});
		/*$$popup.find(".s-msgbox-button").unbind("click").bind("click", function(){
         if ($(this).attr('data-s-id') === "yes") {
         if (!editor.options._isRaw()) {
         var rawtext = $('<div>').html(normalizeRawText(editor.$area.val())).text(), $$pre = $('<pre>').appendTo('<div>').html(rawtext);
         editor.$area.val($$pre.parent().html());
         editor.options._setRaw(true);
         button.title = _localize.richMode;
         $(button).removeClass("buttonRichText").addClass("buttonRawText");
         }
         editor.updateFrame();
         editor.disable(editor.disabled);
         }
         editor.hidePopups();
         editor.focus(editor);
         });*/
		return true;
	};

	var $$popupContent = $('<div>'),
		$$list = $('<select>').attr('size', '8');
	$$popupContent.append($$list);
	$.each(fontSizes.split(","), function(i, size) {
		$('<option>').append(size).appendTo($$list);
		// $('<div>').append($('<span>').prepend(size)).appendTo($$popupContent);
	});

	// font size button
	$buttons.size.popupContent = $$popupContent.html();
	$buttons.size.popupClass = "cleditorList";
	$buttons.size.popupClick = function(e, data) {
		// TODO: fix text selection which is reset after inserting html contents. see createSelection
		// var editor = data.editor,
		//     text = editor.selectedText();
		// // var range = _getRange(editor);
		// var value = target.value || data.value;
		// var html = '<span style="font-size:' + e.target.value + 'pt">' + text + '</span>';
		// editor.execCommand("inserthtml", html, null, data.button);
		// editor.hidePopups();
		// editor.focus(editor);
		// range && range.select();
		// return false;
		data.command = "inserthtml";
		data.value = '<span style="font-size:' + e.target.value + 'pt; ">' + data.editor.selectedText() + '</span>';
		return true;
	};

	$buttons.source.getEnabled = function(data) {
		var rawAllowed = data.editor.options._rawAllowed();
		return !(rawAllowed && data.editor.options._isRaw());
	};

	// paste button
	// $buttons.paste.buttonClick = function(e, data) {
	//     data.editor.execCommand(data.command, data.value, data.useCSS, data.button);
	//     return false;
	// };
	var formattingbuttons = "bold italic underline strikethrough subscript superscript font size " + //
	"color highlight bullets numbering outdent indent alignleft center alignright " + //
	"justify rule image link unlink removeformat";
	$.each(formattingbuttons.split(" "), function(idx, buttonName) {

		$buttons[buttonName].getEnabled = function(data) {
			return !data.editor.options._isRaw();
		};
	});
}

function _getRange(editor) {
	return _getSelection(editor).getRangeAt(0);
}

function _getSelection(editor) {
	// supported by all browsers including ie9
	var elt = editor.sourceMode() ? document : editor.$frame[0].contentWindow,
		sel;
	if (elt && elt.getSelection) {
		sel = elt.getSelection();
	}
	if (!sel && elt.selection)
		sel = elt.selection.createRange();
	return sel;
}

function HtmlEditor() {}

exports.HtmlEditor = helpers.defineClass(HtmlEditor, Field, {
	initialize: function() {
		this.$item.$isAutoSizeDisabled = true;
		this.$item.$isAutoSize = true;
		this._cache = {};
	},
	onWindowResize: function() {
		if (this.$$item && this.$$item[0].clientWidth) {
			if (this.isEditable()) {
				if (!this.isCreated) {
					this.isCreated = true;
					this._finalizeCreate();
					if (this._isFocusRequested) {
						this._editor.focus();
						delete this._isFocusRequested;
					}
				}
			}
			this._refreshEditor();
		}
	},

	getLazyUrl: function(value) {
		return this.articleParent.parseExpression(value && value.$url || this.$field.$url);
	},

	/// -------------
	/// ## setDataValue(value)
	///
	/// Sets the content value.
	///
	/// This method is not intended to be called directly.
	/// The normal way to set the value with its metadata is to call `setDataBind(value, record, metaData)`
	///
	/// **Overrides:** Field.setDataValue(...)
	///
	setDataValue: function(value) {
		debug && console.log('htmlEditor.setDataValue 1: ' + this.id + '\n$isEditMode=' + this.$isEditMode + '\ncurrent:\n' + this.currentValue + '\nnew value:\n' + value);
		var self = this;
		this.$lazyUrl = this.getLazyUrl(value);
		if (this.$lazyUrl && value && typeof(value) === 'object') {
			// lazy loading
			self.$contentType = value.$contentType || (this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type);
			document.controller.sendRequest(null, {
				$location: {
					$url: self.$lazyUrl,
					$contentType: self.$contentType,
					$type: self.$contentType
				}
			}, function(data, response) {
				debug && console.log('htmlEditor.lazyload: ' + self.id + '\n$isEditMode=' + self.$isEditMode + '\ncurrent:\n' + self.currentValue + '\nnew value:\n' + data);
				if (typeof(data) === 'string') {
					self.setDataValue(data);
				} else {
					self.showErrors([locale.format(self.localize.fieldBadDataType, "string", typeof(data))]);
				}
			}, function(error, httpquery) {
				debug && console.log('htmlEditor.lazyload: ' + self.id + ' error=' + error.message);
				self.showErrors([error.message]);
			});
		} else {
			try {
				if (this.currentValue != value) {
					var styles = this.$field.$styles;
					// var styles = Array.isArray(value.$styles) ? styles = value.$styles.join("\n") : styles = value.$styles;
					// this._editor.options.headStyle = styles || this._editor.options.headStyle;
					this._setContents(value, true);
					this._cache.oldValue = this.currentValue = this._getPersistentContents();
					// this._cache.dirtyChecksum = this._cache.checksum;
				}
			} catch (error) {
				this.showErrors([error.message]);
			}
			debug &&
				console.log('htmlEditor.setDataValue 2: ' + this.id + '\n$isEditMode=' + this.$isEditMode + ', checksum=' + this._cache.dirtyChecksum + //
					'\ncurrent:\n' +
					this.currentValue +
					'\nnew:\n' +
					value);

			this._refreshToolbar();
		}
	},
	/// -------------
	/// ## getInputValue()
	///
	/// Gets the content value.
	///
	/// **Overrides:** Field.getInputValue()
	///
	getInputValue: function() {
		debug && console.log('htmlEditor.getInputValue: ' + this.id + ' isDirty=' + this.isDirty() + ', contents=\n' + this._getPersistentContents());
		if (this.isEditable() && this._editor && this._editor.$area) {
			var contents = this._getPersistentContents();
			// this._cache.changedChecksum = this._cache.checksum;
			return contents;
		}
		return "";
	},
	/// -------------
	/// ## isDirty()
	///
	/// Returns `true` if the content has changed since the field gained the focus or since the last setDataValue.
	///
	isDirty: function() {
		// Get the current content to compute the checksum
		var value = this._getPersistentContents(),
			dirty = (this._cache.oldValue !== value);
		// dirty = (this._cache.dirtyChecksum !== this._cache.checksum);
		debug &&
			console.log( //
				'htmlEditor.isDirty: ' + this.id + ' isDirty=' + dirty + //
				", checksum=" +
				this._cache.checksum +
				'\nnew:\n' +
				value +
				'\nold:\n' +
				this._cache.oldValue + //
				'\ncached:\n' +
				this._cache.value +
				'\nraw:\n' +
				this._cache.raw //
		);
		return dirty;
	},
	// -------------
	// ## hasChanged()
	//
	// Returns `true` if the content has changed since the last call to `getInputValue`.
	//
	// hasChanged: function() {
	//     return (this._cache.changedChecksum == null) || this._cache.changedChecksum !== this._cache.checksum;
	// },
	/// -------------
	/// ## validateType(errors, value)
	///
	/// Validates the current value and reports errors.
	///
	/// This method is called during the validation process and is not intended to be called directly.
	///
	/// **See:** Field.validate(...)
	///
	validateType: function(errors, value) {
		if (this.currentValue && this.$maxLength && this.currentValue.length > this.$maxLength) {
			errors.push(locale.format(_localize.errorMaxLength, this.$maxLength));
		}
		debug && console.log('htmlEditor.validateType: ' + this.id + '\nValue: ' + this.currentValue);
	},

	/// -------------
	/// ## notifyFieldChange(newValue, validated)
	///
	/// Notified the change to the server.
	///
	/// This method is called during the validation process and is not intended to be called directly.
	/// It overides the standard behavior to allow update of lazy loaded contents.
	///
	/// **See:** Field.notifyFieldChange(...)
	///
	notifyFieldChange: function(newValue, validated) {
		var self = this;
		this.$lazyUrl = this.getLazyUrl();
		if (this.$lazyUrl) {
			debug && console.log('htmlEditor.notifyFieldChange lazy content: ' + self.id + '\nValue: ' + newValue);
			document.controller.sendRequest(null, {
				$location: {
					$url: self.$lazyUrl,
					$contentType: self.$contentType,
					$type: self.$contentType
				},
				data: newValue,
				method: "PUT"
			}, function(data, response, requestUrl) {
				debug && console.log('htmlEditor.notifyFieldChange lazy upload: ' + self.id + '\ndata: ' + data + ', response=' + JSON.stringify(response));
			});
		} else {
			Field.prototype.notifyFieldChange.call(this, newValue, validated);
		}
	},

	/// -------------
	/// ## focus()
	///
	/// Sets the focus to the edit part of the widget.
	///
	/// **Overrides:** Field.focus()
	///
	focus: function() {
		debug && console.log('htmlEditor.focus: ' + this.id);
		if (this.isEditable() && this._editor) {
			if (!this.isCreated) {
				this._isFocusRequested = true;
			} else {
				this._editor.focus();
			}
		}
	},
	/// -------------
	/// ## getCaretPosition()
	///
	/// Gets the current 0 based caret position in the editor.
	///
	/// **Overrides:** Field.getCaretPosition()
	///
	getCaretPosition: function() {
		if (!(this.isEditable() && this._editor && this._editor.doc.body && this.$$caret)) {
			return 0;
		}

		var doc = this._editor.doc,
			root = doc.body,
			sel = _getSelection(this._editor),
			$$caret = this.$$caret,
			caretPos, range, contents;

		try {
			range = doc.createRange();
			range.setStart(root, 0);
			sel.focusNode && range.setEnd(sel.focusNode, sel.focusOffset);
			contents = range.cloneContents();
		} catch (e) {
			return 0;
		}
		if (contents) {
			$$caret.append(contents);
			$$caret.html($$caret.html().replace(/<br\s*[\/]?>/gi, "\n"));
			caretPos = $$caret.text().length;
			$$caret.empty();
		}
		return caretPos || 0;
	},

	isEditable: function() {
		return this.$isEditMode;
	},

	setState: function(state) {
		debug && console.log('htmlEditor.setState: ' + this.id + "\n" + (state ? JSON.stringify(state) : "<undefined>"));
		if (state && state.$isDisabled !== undefined) {
			this._editor && this._editor.disable(state.$isDisabled);
		}
		Field.prototype.setState.call(this, state);
	},

	toggleEditMode: function($isEditMode) {
		// reset value because setDataValue will check the equality
		this.currentValue = undefined;
		Field.prototype.toggleEditMode.call(this, $isEditMode);
	},
	_onSetReadOnly: function($isReadOnly) {
		this._editor && this._editor.disable($isReadOnly);
		Field.prototype._onSetReadOnly.call(this, $isReadOnly);
	},
	render: function() {
		this.$maxLength = this.$field.$maxLength || this.$field.$maxByteLength;
		this.$capabilities = this.$capabilities || resUtil.parseCapabilities(this.$field.$capabilities);
		this.$lazyUrl = this.getLazyUrl();
		this.$contentType = this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type;

		lazyInit(jQuery);
		debug && console.log('htmlEditor.render ' + this.id);
		var self = this;
		var id = helpers.uuid.generate();
		self._dataValue.setAttribute("id", self.id + "-data");
		if (this.isEditable()) {
			// self.standalone = this.boxParent && this.boxParent.$prototype && (this.boxParent.$prototype.$baseUrl === "/sdata/x3stb/erp/stubs");
			this.$$caret = $("<div>").attr("id", id + "-caret").attr("style", "display:none;").appendTo(self._dataValue);

			// var css = ((this.$item.$css) ? this.$item.$css + " " : "") + this.$skinInput;
			// this.$$input = $('<textarea>').attr('id', "i" + id).attr('name', "i" + id).addClass(css).appendTo(self.$$fieldValue);
			var $$area = $('<textarea>').attr('id', "html-editor-" + id).attr('name', "html-editor-" + id).appendTo($(self.fieldValue));

			// add attribute to disable browser spellcheck and autocorrect
			document.site.setSpecificAttributes($$area[0]);

			$$area[0].syra_field_id = id;
			$$area[0].setAttribute("data-s-field", id);
			$$area[0].setAttribute("data-s-inout", id);
			this.$item.$rows && $$area.attr("rows", this.$item.$rows);

			self._editor = $$area.cleditor({
				resizeSelector: self.resizeSelector = "resize." + helpers.uuid.generate(),
				// width not including margins, borders or padding
				// width: self.$item.$textWidth || "100%",
				width: self.$item.$textWidth || "auto",
				// height not including margins, borders or padding
				// height: self.$item.$textHeight || 480,
				height: self.$item.$textHeight || "auto",
				controls: "bold italic underline strikethrough subscript superscript | font size | color" + //
				" highlight removeformat | bullets" + /*+" numbering" */ " | outdent indent alignleft center alignright justify" + //
				" | undo redo | rule image link unlink" + //
				" | cut copy paste pastetext" + //
				" | print source rawMode",
				// style to assign to document body contained within the editor
				// bodyStyle: "margin:4px; font:10pt Arial,Verdana; cursor:text"
				bodyStyle: "",
				// sizes in the font size popup
				sizes: fontSizes,
				useCSS: true,
				// _field: self,
				_rawAllowed: function() {
					return self._rawAllowed();
				},
				_isRaw: function() {
					return self._rawAllowed() && self._isRaw;
				},
				_setRaw: function(v) {
					if (self._rawAllowed())
						self._isRaw = v;
				},
				_freezeCacheChange: function() {
					debug && console.log('>>>> htmlEditor.editor._freezeCacheChange');
					self._cache.frozen = true;
				},
				// Handlers
				updateFrame: function(html) {
					// TODO: cleanup HTML if necessary
					debug && console.log('>>>> htmlEditor.editor.updateFrame:\n' + html);
					return html;
				},
				updateTextArea: function(html) {
					debug && console.log('>>>> htmlEditor.editor.updateTextArea:\n' + html);
					return html;
				}
			})[0];
		}
	},

	_isRtfMimeType: function() {
		return this.$field.$type == "text/rtf";
	},

	_finalizeCreate: function() {
		debug && console.log('htmlEditor._finalizeCreate ' + this.id);
		this.setState(this.$field);
		this._refreshToolbar();
		this._refreshEditor();

		// Intercept paste event to get the opportunity of sanitizing the contents
		var $$input = $(this._editor.doc.body);

		this._isRtfMimeType() &&
			$$input.bind('paste', function(e) {
				// this code corrupts the undo stack!!!
				var pastedText;
				if (e && e.clipboardData && e.clipboardData.getData) {
					if (/text\/html/.test(e.clipboardData.types)) {
						pastedText = e.clipboardData.getData('text/html');
					} else
					if (/text\/plain/.test(e.clipboardData.types)) {
						pastedText = e.clipboardData.getData('text/plain');
					} else {
						pastedText = "";
					}
				} else
				if (window.clipboardData && window.clipboardData.getData) { // IE
					pastedText = window.clipboardData.getData('Text');
				} else {
					var el = $(this);
					// Hiding the underlying element causes some unpredictable behavior
					// var display;
					// $.browser.mozilla && (display = el.css('display')) && el.css('display', 'none');
					setTimeout(function() {
						var text = $(el).html();
						if (text) {
							$(el).html(sanitize(text));
						}
						// console.log("htmlEditor..paste after timeout:\n" + (text && text.substring(0,50)));
						// display && el.css('display', display);
					}, 300);
				}
				if (pastedText) {
					// debug && console.log("htmlEditor..paste from clipboard:\n" + pastedText);
					$(this).html(sanitize(pastedText));
					e.preventDefault();
					e.stopPropagation();
				}

			});

		this._bindInput(true);
	},

	_refreshToolbar: function() {
		// hack to refresh the toolbar state and disable the toolbar buttons if necessary
		this.isEditable() && this._editor.disable(this._editor.disabled);
	},

	_refreshEditor: function() {
		if (this._editor && this._editor.$frame && this._editor.$frame[0] && this._editor.$frame[0].contentWindow) {
			this._editor.refresh();
			this.bindEvent && this._bindInput(true);
		}
	},

	_beforeInputFocusin: function($$input, event) {
		// Get the content to compute the checksum
		if (!this._cache.frozen) {
			this._cache.oldValue = this._getPersistentContents();
		}
		// this._cache.dirtyChecksum = this._cache.checksum;
		debug && console.log("htmlEditor._beforeInputFocusin " + this.id + " cache.frozen=" + this._cache.frozen + ", checksum=" + this._cache.checksum + "\n" + this._cache.oldValue);
		this._cache.frozen = false;
	},

	_bindInput: function(bind) {
		this.bindEvent = bind;
		if (!(this._editor && this._editor.doc)) {
			return;
		}

		var self = this;
		var doc = this._editor.doc,
			$$doc = $(doc),
			$$input = $(doc.body),
			contentWindow = this._editor.$frame[0].contentWindow,
			$$inputWindow = $.browser.mozilla ? $$doc : $(contentWindow);

		debug && console.log("htmlEditor._bindInput " + this.id + ": bind=" + bind + ", doc=" + doc + ", contentWindow=" + contentWindow);
		if (bind) {
			$$input.on("change keydown keypress keyup focusin focusout", function(event) {
				debug && console.log("htmlEditor.bindInputEvent $$input: " + event.type + " " + self.id);
				self.onFieldInputEvent(event);
				event.stopPropagation();
			});

			$$inputWindow.on("click", function(event) {
				debug && console.log("htmlEditor.bindInputEvent click --> click" + self.id);
				self.onFieldInputEvent(event);
				event.stopPropagation();
			});
			$$inputWindow.focus(function(event) {
				debug && console.log("htmlEditor.bindInputEvent focus --> focusin " + self.id);
				self._beforeInputFocusin($$input, event);
				$$input.trigger("focusin");
				// self._editor.$main.addClass("cleditorMain-focus");
				document.site.toggleClass(self._dataValue, "cleditorMain-focus", true);
				event.stopPropagation();
			});
			$$inputWindow.blur(function(event) {
				debug && console.log("htmlEditor.bindInputEvent blur --> focusout " + self.id);
				debug && console.log("\tCaret position: " + self.getCaretPosition());
				// self._editor.$main.removeClass("cleditorMain-focus");
				document.site.toggleClass(self._dataValue, "cleditorMain-focus", false);
				if (self.isDirty()) {
					$$input.trigger("change");
				}
				$$input.trigger("focusout");
				event.stopPropagation();
			});
		} else {
			$$input.off();
			$$inputWindow.off();
		}
	},

	_rawAllowed: function() {
		return this._isRtfMimeType() && this.$capabilities && this.$capabilities.raw;
	},

	_setRawEditContents: function(contents) {
		if (this.isEditable() && this._editor && this._editor.$area) {
			debug && console.log('htmlEditor._setRawEditContents:\n' + contents);
			this._editor.$area.val(contents || '');
			this._editor.updateFrame();
		}
	},

	_getRawEditContents: function() {
		if (this.isEditable() && this._editor && this._editor.doc) {
			if (this._editor.doc.body) {
				return fixHtml(this._editor.doc.body.innerHTML || "");
			} else
			if (this._editor.$area) {
				// iframe is not yet created so return the textarea content
				return fixHtml(this._editor.$area[0].innerHTML || "");
			}
		}
	},

	_setContents: function(contents, saveStyles) {
		debug && console.log('htmlEditor._setContents 1: isEditable()=' + this.isEditable() + '\n' + contents);
		this._isRaw = false;
		if (!contents || contents.length === 0) {
			// No contents, assume we want to edit Rich Text or HTML
		} else {
			switch (this.$field.$type) {
				case "text/rtf":
					if (contents.match(/^\s*{\\rtf/)) {
						contents = rtf.toHtml(contents);
					} else
					if (this._rawAllowed()) {
						this._isRaw = true;
						if (!contents.match(/<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i)) {
							// Not an HTML contents, so wrap it in <pre> tag
							contents = "<pre>" + contents + "</pre>";
						}
					} else {
						this.showDiagnoses([{
							$message: locale.format(_localize.errorRtfExpected, contents),
							$severity: "error"
						}, {
							$message: _localize.warnContentsNotSet,
							$severity: "warning"
						}]);
						return;
					}
					break;
				case "text/html":
					// contents as is
					break;
			}
		}
		debug && console.log('htmlEditor._setContents 2: _isRaw=' + this._isRaw + '\n' + contents);

		if (saveStyles && contents) {
			this.$$savedStyles = $(contents).find('style');
		}
		if (this.isEditable()) {
			this._setRawEditContents(contents);
		} else {
			document.site.emptyDom(this.fieldValue);
			this.fieldValue.innerHTML = contents;
		}
	},

	_getPersistentContents: function(contents) {
		if (!this.isEditable())
			return null;

		if (contents === undefined) {
			contents = this._getRawEditContents();
		}
		if (contents === undefined) {
			return null;
		}
		var hash = checksum(contents);
		if (hash === this._cache.checksum)
			return this._cache.value;
		this._cache.raw = contents;
		debug && console.log('htmlEditor._getPersistentContents change: checksum=' + hash + '\nraw:\n' + contents);

		this._cache.checksum = hash;

		if (this.$$savedStyles) {
			var $$contents = $('<div>').append(contents);
			if ($$contents.find('style').length === 0) {
				$$contents.prepend(this.$$savedStyles);
				contents = $$contents.html();
			}
		}
		if (this._isRaw) {
			var outer = $(contents);
			if (outer.is('pre'))
				contents = normalizeRawText(outer.html());
		} else {
			if (this._isRtfMimeType()) {
				contents = (contents || "").length === 0 ? "" : rtf.fromHtml(contents);
			}
		}
		debug && console.log('htmlEditor._getPersistentContents return: checksum=' + hash + '\ncontents:\n' + contents);
		this._cache.value = contents;
		return contents;
	},

	dispose: function() {
		if (this.resizeSelector) {
			$(window).unbind(this.resizeSelector);
		}
		this._bindInput(false);
		if (this._editor) {
			this._editor.dispose();
			delete this._editor;
		}
		this.$$caret = this.$$savedStyles = this._cache = this.$capabilities = null;
		Field.prototype.dispose.call(this);
	}

});