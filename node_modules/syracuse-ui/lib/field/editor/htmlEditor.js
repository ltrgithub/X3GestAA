"use strict";
/// !doc
///
/// # Html editor widget that supports RFT conversion
///
/// `HtmlEditor` class subclasses the `Field` class
/// ```javascript
/// var htmlEditor = require('syracuse-ui/lib/field/editor/htmlEditor').HtmlEditor;
/// ```
///
var helpers = require('syracuse-core/lib/helpers');
var resUtil = require('syracuse-core/lib/resource/util');
var locale = require('syracuse-core/lib/locale');
var Field = require('syracuse-ui/lib/field/field').Field;
var rtf = require("syracuse-rtf");
// require('syracuse-ui/deps/cleditor/jquery.cleditor.min');
require('syracuse-ui/deps/cleditor/jquery.cleditor');

var debug = false;

var fontSizes = "8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,72";

var htmlStyles = [
	["paragraph", "<p>"],
	["h3", "<h3>"],
	["h4", "<h4>"]
];

// Default values are the English one
var _localize = {};

function normalizeRawText(text) {
	return text.replace(/&nbsp;/gi, " ") //
	.replace(/<br\s*[\/]?>/gi, "\r\n") //
	.replace(/<p>/gi, "\r\n");
}

function normalizeHtmlText(html) {
	return html.replace(/\r\n/g, "<br/>") //
	.replace(/\n/g, "<br/>") //
	.replace(/\s/g, "&nbsp;");
}

function fixHtml(html) {
	return html.replace(/<br\s*[\/]?>$/gi, "");
}

function sanitize(html) {
	return rtf.toHtml(rtf.fromHtml(html));
}

// checksum - returns a checksum using the Adler-32 method

function checksum(text) {
	var a = 1,
		b = 0;
	for (var index = 0; index < text.length; ++index) {
		a = (a + text.charCodeAt(index)) % 65521;
		b = (b + a) % 65521;
	}
	return (b << 16) | a;
	// return md5(text);
}

function lazyInit($) {
	// var cleditor = require.async('syracuse-ui/deps/cleditor/jquery.cleditor', function(err, module){});
	var $buttons = $.cleditor.buttons;

	function localize() {
		helpers.object.forEachKey($buttons, function(key) {
			$buttons[key].title = _localize[key] || key + ":<undefined>";
		});
		if ($buttons.rawMode) {
			$buttons.rawMode.title = _localize.rawMode;
		}
		htmlStyles.forEach(function(style) {
			style[0] = _localize[style[0]] || style[0];
		});
	}

	_localize = locale.resources(module)();
	localize();

	if ($buttons.rawMode) {
		return;
	}
	var options = {
		$type: "warning",
		$buttons: "yesno",
		$title: _localize.aboutToSwitchToRawTitle,
		$message: _localize.aboutToSwitchToRawConfirm,
		$minWidth: "380" //px
	};

	// building msgbox (2nd parameter set to true not to display msgbox in syracuse mode)
	var messageBox = syra_diagnose.showBox(options, true);
	// adding data-s-id attribute
	var menus = Object.keys(messageBox.menuItems);
	for (var ii = 0, jj = menus.length; ii < jj; ii++) {
		var menuItem = messageBox.menuItems[menus[ii]];
		menuItem[0].domItem.setAttribute("data-s-id", menuItem[0].$title);
	}
	// get msgbox raw content
	var popupRawModeContent = messageBox.domItem.outerHTML;
	syra_diagnose.closeBox();

	$buttons.rawMode = {
		name: "rawMode",
		title: _localize.rawMode,
		popupName: "rawMode",
		popupClass: "cleditorPrompt",
		popupContent: popupRawModeContent,
	};

	$buttons.rawMode.getEnabled = function(data) {
		var rawAllowed = data.editor.options._rawAllowed();
		if (rawAllowed && data.editor.options._isRaw()) {
			data.button.title = _localize.richMode;
			$(data.button).removeClass("buttonRichText").addClass("buttonRawText");
		} else {
			data.button.title = _localize.rawMode;
			$(data.button).removeClass("buttonRawText").addClass("buttonRichText");
		}
		return rawAllowed;
	};

	$buttons.rawMode.buttonClick = function(e, data) {
		var button = e.target,
			editor = data.editor,
			field = ((editor || {}).options || {})._field,
			$$popup = $(data.popup),
			html;

		if (editor.options._isRaw()) {
			editor.options._setRaw(false);
			html = normalizeHtmlText(fixHtml(editor.$area.val()));
			var $$content = $(html);
			if ($$content.is('pre')) {
				html = $$content.html();
			}
			$(editor.doc.body).html(html);
			editor.options._setRaw(false);
			button.title = _localize.rawMode;
			$(button).removeClass("buttonRawText").addClass("buttonRichText");
			editor.updateTextArea();
			editor.focus();
			return false;
		}

		$$popup.css("padding", "0");
		// Wire up the submit button click event handler
		$$popup.find(".s-msgbox-buttons-link").unbind("click").bind("click", function(event) {
			event.preventDefault();
			if ($(this).attr('data-s-id') === syra_local.msgbox_yes) {
				if (!editor.options._isRaw()) {
					var rawtext = $('<div>').html(normalizeRawText(editor.$area.val())).text(),
						$$pre = $('<pre>').appendTo('<div>').html(rawtext);
					editor.$area.val($$pre.parent().html());

					editor.options._setRaw(true);
					button.title = _localize.richMode;
					$(button).removeClass("buttonRichText").addClass("buttonRawText");
				}
				editor.updateFrame();
				field._disable(editor.disabled);
			}
			editor.hidePopups();
			editor.focus();
		});
		return true;
	};


	$buttons.insertTable = {
		name: "insertTable",
		title: _localize.insertTable,
		popupName: "insertTable"
	};

	$buttons.insertTable.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		$(data.button).addClass("buttonInsertTable");
		return field && !field._isRtfMimeType();
	};

	$buttons.insertTable.buttonClick = function(e, data) {
		syra_site.dialogManager.closePopups();
		var editor = data.editor;
		editor.focus();
		var range = _getRange(editor);

		syra_site.dialogManager.openPopup(syra_site.page, {
			$isAutoClose: true,
			$itemPage: {
				$isEditMode: true,
				$facet: "$edit",
				$representation: {
					$prototype: {
						$properties: {
							$rows: {
								$type: "application/x-integer",
								$title: _localize.tableRows,
								$maxLength: 5
							},
							$columns: {
								$type: "application/x-integer",
								$title: _localize.tableCol,
								$maxLength: 5
							},
							$borderSize: {
								$type: "application/x-integer",
								$title: _localize.tableBorderSize,
								$maxLength: 5
							},
							$withHeader: {
								$type: "application/x-boolean",
								$title: _localize.tableWithHeader
							}
						},
						$links: {}
					},
					$article: {
						$title: _localize.tableTitle,
						$category: "section",
						$layout: {
							$items: [{
								$layoutType: "stack",
								$items: [{
									$layoutType: "row",
									$autoSize: true,
									$items: [{
										$bind: "$rows",
									}, {
										$bind: "$columns"
									}]
								}, {
									$layoutType: "row",
									$autoSize: true,
									$items: [{
										$bind: "$borderSize",
									}, {
										$bind: "$withHeader"
									}]
								}]
							}]
						}
					}
				}
			},
			onValidate: function(page) {
				page.validateFields();
				if (page.dataset && Object.keys(page.dataset).length > 0) {
					var rows = parseInt(page.dataset.$rows, 10),
						cols = parseInt(page.dataset.$columns, 10),
						border = parseInt(page.dataset.$borderSize, 10),
						header = page.dataset.$withHeader,
						i, j;
					var html = '<div><table cellspacing="1" cellpadding="1" border="' + (border || 0) + '">';
					if (header) {
						html += '<thead><tr>';
						for (j = 0; j < cols; j++) {
							html += '<th><br></th>';
						}
						html += '</tr></thead>';
					}

					html += '<tbody>';
					for (i = 0; i < rows; i++) {
						html += '<tr>';
						for (j = 0; j < cols; j++) {
							html += '<td><br></td>';
						}
						html += '</tr>';
					}
					html += '</tbody>';
					html += '</table></div>';
					editor.execCommand("inserthtml", html, null, data.button);
				}
				editor.focus();
			},
			position: {
				my: "left bottom",
				at: "right top",
				of: $(e.target)
			}
		});
		return false;
	};
	$buttons.link.buttonClick = function(e, data) {
		var $popup = $(data.popup),
			$$focusNode = $(_getSelection(data.editor).focusNode),
			href = ($$focusNode.closest("a").attr("href") || $$focusNode.find("a").attr("href"));
		if (href && href != "") {
			$popup.find(":text").val(href);
		}
	};
	// font size button
	var $$popupContent = $('<div>'),
		$$list = $('<select>').attr('size', '8');
	$$popupContent.append($$list);
	$.each(fontSizes.split(","), function(i, size) {
		$('<option>').append(size).appendTo($$list);
		// $('<div>').append($('<span>').prepend(size)).appendTo($$popupContent);
	});

	$buttons.size.popupContent = $$popupContent.html();
	$buttons.size.popupClass = "cleditorList";
	$buttons.size.popupClick = function(e, data) {
		data.command = "inserthtml";
		data.value = '<span style="font-size:' + e.target.value + 'pt; ">' + data.editor.selectedText() + '</span>';
		return true;
	};

	// paste button
	// $buttons.paste.buttonClick = function(e, data) {
	//     data.editor.execCommand(data.command, data.value, data.useCSS, data.button);
	//     return false;
	// };
	var formattingbuttons = "bold italic underline strikethrough subscript superscript font size style" + //
	"color highlight bullets numbering outdent indent alignleft center alignright " + //
	"justify rule image link unlink removeformat source";
	$.each(formattingbuttons.split(" "), function(idx, buttonName) {
		if ($buttons[buttonName]) {
			$buttons[buttonName].getEnabled = function(data) {
				var rawAllowed = data.editor.options._rawAllowed();
				return !(rawAllowed && data.editor.options._isRaw());
			};
		}
	});

	var heightList = ["auto", "400px", "600px", "800px"];
	// Extend the size of the writing area.
	$buttons.extendSize = {
		name: "extendSize",
		title: _localize.extendSize,

		getEnabled: function(data) {
			$(data.button).addClass("buttonExtendSize");
			return true;
		},

		buttonClick: function(e, data) {
			var editor = data.editor;
			editor.$heightIndex = ((editor.$heightIndex || 0) + 1) % heightList.length;
			editor.options.height = heightList[editor.$heightIndex];
			editor.refresh();
			editor.focus();
			return false;
		}
	};
	$buttons.style.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.image.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.link.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.unlink.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.rule.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.superscript.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.subscript.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
}

function _getRange(editor) {
	try {
		var sel = _getSelection(editor);
		return sel && sel.getRangeAt(0);
	} catch (e) {}
}

function _getSelection(editor) {
	// supported by all browsers including ie9
	var elt = editor.sourceMode() ? document : editor.$frame[0].contentWindow,
		sel;
	if (elt && elt.getSelection) {
		sel = elt.getSelection();
	}
	if (!sel && elt.selection)
		sel = elt.selection.createRange();
	return sel;
}

function HtmlEditor() {}

exports.HtmlEditor = helpers.defineClass(HtmlEditor, Field, {
	initialize: function() {
		this.$item.$isAutoSizeDisabled = true;
		this.$item.$isAutoSize = true;
		this._cache = {};
	},
	resizeField: function() {
		if (this.domItem && this.domItem.clientWidth) {
			if (this.isEditable() && !this.isCreated) {
				this.isCreated = true;
				this._finalizeCreate();
				if (this._isFocusRequested) {
					this._editor.focus();
					delete this._isFocusRequested;
				}
			}
			this._refreshEditor();
		}
	},

	getLazyUrl: function(value) {
		return syra_site.expressionMaker.parse(this.articleParent, value && value.$url || this.$field.$url);
	},

	/// -------------
	/// ## setDataValue(value)
	///
	/// Sets the content value.
	///
	/// This method is not intended to be called directly.
	/// The normal way to set the value with its metadata is to call `setDataBind(value, record, metaData)`
	///
	/// **Overrides:** Field.setDataValue(...)
	///
	setDataValue: function(value) {
		debug && console.log('htmlEditor.setDataValue 1: ' + this.id + '\n$isEditMode=' + this.$isEditMode + '\ncurrent:\n' + this.currentValue + '\nnew value:\n' + value);
		var self = this;
		this.$lazyUrl = this.getLazyUrl(value);
		if (this.$lazyUrl && value && typeof(value) === 'object') {
			// lazy loading
			self.$contentType = value.$contentType || (this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type);
			syra_controller.sendRequest(null, {
				$location: {
					$url: self.$lazyUrl,
					$contentType: self.$contentType,
					$type: self.$contentType
				}
			}, function(data, response) {
				debug && console.log('htmlEditor.lazyload: ' + self.id + '\n$isEditMode=' + self.$isEditMode + '\ncurrent:\n' + self.currentValue + '\nnew value:\n' + data);
				if (typeof(data) === 'string') {
					self.setDataValue(data);
				} else {
					self.showErrors([locale.format(syra_local.fieldBadDataType, "string", typeof(data))]);
				}
			}, function(error) {
				debug && console.log('htmlEditor.lazyload: ' + self.id + ' error=' + error.message);
				self.showErrors([error.message]);
			});
		} else {
			try {
				if (this.currentValue != value) {
					var styles = this.$field.$styles;
					// var styles = Array.isArray(value.$styles) ? styles = value.$styles.join("\n") : styles = value.$styles;
					// this._editor.options.headStyle = styles || this._editor.options.headStyle;
					this._setContents(value, true);
					this.currentValue = this._getPersistentContents();
					if (!this.dirty()) {
						this._cache.dirtyChecksum = this._cache.checksum;
					}
				}
			} catch (error) {
				this.showErrors([error.message]);
			}
			debug &&
				console.log('htmlEditor.setDataValue 2: ' + this.id + '\n$isEditMode=' + this.$isEditMode + ', checksum=' + this._cache.dirtyChecksum + //
					'\ncurrent:\n' +
					this.currentValue +
					'\nnew:\n' +
					value);

			this._refreshToolbar();
		}
	},
	/// -------------
	/// ## getInputValue()
	///
	/// Gets the content value.
	///
	/// **Overrides:** Field.getInputValue()
	///
	getInputValue: function() {
		debug && console.log('htmlEditor.getInputValue: ' + this.id + ' isDirty=' + this.isDirty() + ', contents=\n' + this._getPersistentContents());
		if (this.isEditable() && this._editor && this._editor.$area) {
			var contents = this._getPersistentContents();
			// this._cache.changedChecksum = this._cache.checksum;
			return contents;
		}
		return "";
	},
	/// -------------
	/// ## isDirty()
	///
	/// Returns `true` if the content has changed since the field gained the focus or since the last setDataValue.
	///
	isDirty: function(dontHidePopup) {
		// Get the current content to compute the checksum
		if (this._editor && !dontHidePopup) {
			this._editor.hidePopups();
		}
		var value = this._getPersistentContents(),
			dirty = (this._cache.dirtyChecksum != this._cache.checksum);
		if (debug) {
			console.log('htmlEditor.isDirty: ' + this.id + ' isDirty=' + dirty + ', dirty()=' + this.dirty() + ", checksum=" + this._cache.checksum + ", dirtyChecksum=" + this._cache.dirtyChecksum);
			console.log('new:\n' + value);
			console.log('cached:\n' + this._cache.value);
			console.log('raw:\n' + this._cache.raw);
		}
		return dirty;
	},
	/// -------------
	/// ## setDirty()
	///
	/// Change the dirty state.
	///
	/// **Overrides:** Field.setDirty()
	///
	setDirty: function(dirty) {
		if (!dirty) {
			var contents = this._getPersistentContents(); // to compute checksum;
			this._cache.dirtyChecksum = this._cache.checksum;
			//console.log(this._editor.$area.val())
			if (this.isEditable()) this._setRawEditContents(rtf.toHtml(contents));
			//console.log(contents)
			//console.log(rtf.toHtml(contents))

		}
		debug && console.log('htmlEditor.setDirty(' + dirty + '): ' + this.id + ' dirty()=' + this.dirty() + ", checksum=" + this._cache.checksum);
		debug && console.log('cached:\n' + this._cache.value + '\nraw:\n' + this._cache.raw);
		this.dirty(dirty);
	},

	/// -------------
	/// ## dirty()
	///
	/// Get or set the internal dirty state.
	///
	/// **Overrides:** Field.dirty()
	///
	dirty: function(set) {

		if (set !== undefined) {
			this._isDirty = set;
		} else
			return this._isDirty;
	},

	// -------------
	// ## hasChanged()
	//
	// Returns `true` if the content has changed since the last call to `getInputValue`.
	//
	// hasChanged: function() {
	//     return (this._cache.changedChecksum == null) || this._cache.changedChecksum !== this._cache.checksum;
	// },
	/// -------------
	/// ## validateType(errors, value)
	///
	/// Validates the current value and reports errors.
	///
	/// This method is called during the validation process and is not intended to be called directly.
	///
	/// **See:** Field.validate(...)
	///
	validateType: function(errors, value) {
		if (this.currentValue && this.$maxLength && this.currentValue.length > this.$maxLength) {
			errors.push(locale.format(_localize.errorMaxLength, this.$maxLength));
		}
		debug && console.log('htmlEditor.validateType: ' + this.id + '\nValue: ' + this.currentValue);
	},

	/// -------------
	/// ## notifyFieldChange(newValue, validated)
	///
	/// Notified the change to the server.
	///
	/// This method is called during the validation process and is not intended to be called directly.
	/// It overides the standard behavior to allow update of lazy loaded contents.
	///
	/// **See:** Field.notifyFieldChange(...)
	//TODO :
	//A revoir : pourquoi un url particulieret ne pas traiter les datas editeur lazyload comme n'importe qu'elle autre
	notifyFieldChange: function(newValue, validated) {
		var self = this;
		self.$lazyUrl = self.getLazyUrl();
		self.currentValue = newValue;
		if (self.$lazyUrl) {
			if (self.page.isServerNotifyDisabled) {
				self.setDatasetValue(newValue);
			} else {
				debug && console.log('htmlEditor.notifyFieldChange lazy content: ' + self.id + '\nValue: ' + newValue);
				syra_controller.sendRequest(null, {
					$location: {
						$url: self.$lazyUrl,
						$contentType: self.$contentType,
						$type: self.$contentType
					},
					data: newValue,
					method: "PUT"
				}, function(data, response, requestUrl) {
					debug && console.log('htmlEditor.notifyFieldChange lazy upload: ' + self.id + '\ndata: ' + data + ', response=' + JSON.stringify(response));
				});
			}
		} else {
			Field.prototype.notifyFieldChange.call(self, newValue, validated);
		}
	},

	/// -------------
	/// ## focus()
	///
	/// Sets the focus to the edit part of the widget.
	///
	/// **Overrides:** Field.focus()
	///
	focus: function() {
		debug && console.log('htmlEditor.focus: ' + this.id);
		if (this.isEditable() && this._editor) {
			if (!this.isCreated) {
				this._isFocusRequested = true;
			} else {
				this._editor.focus();
			}
		}
	},
	/// -------------
	/// ## getCaretPosition()
	///
	/// Gets the current 0 based caret position in the editor.
	///
	/// **Overrides:** Field.getCaretPosition()
	///
	getCaretPosition: function() {
		if (!(this.isEditable() && ((this._editor || {}).doc || {}).body && this.$$caret)) {
			return 0;
		}

		var doc = this._editor.doc,
			root = doc.body,
			sel = _getSelection(this._editor),
			$$caret = this.$$caret,
			caretPos, range, contents;

		try {
			range = doc.createRange();
			range.setStart(root, 0);
			sel.focusNode && range.setEnd(sel.focusNode, sel.focusOffset);
			contents = range.cloneContents();
		} catch (e) {
			return 0;
		}
		if (contents) {
			$$caret.append(contents);
			$$caret.html($$caret.html().replace(/<br\s*[\/]?>/gi, "\n"));
			caretPos = $$caret.text().length;
			$$caret.empty();
		}
		return caretPos || 0;
	},

	isEditable: function() {
		return this.$isEditMode;
	},

	setState: function(state) {
		debug && console.log('htmlEditor.setState: ' + this.id + "\n" + (state ? JSON.stringify(state) : "<undefined>"));
		if (state && state.$isDisabled !== undefined) {
			this._disable(state.$isDisabled);
		}
		Field.prototype.setState.call(this, state);
	},

	_onSetReadOnly: function($isReadOnly) {
		this._disable($isReadOnly);
		Field.prototype._onSetReadOnly.call(this, $isReadOnly);
	},
	render: function() {
		this.$maxLength = this.$field.$maxLength || this.$field.$maxByteLength;
		this.$capabilities = this.$capabilities || resUtil.parseCapabilities(this.$field.$capabilities);
		this.$lazyUrl = this.getLazyUrl();
		this.$contentType = this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type;

		lazyInit(jQuery);
		debug && console.log('htmlEditor.render ' + this.id);
		var self = this,
			id = self.id || helpers.uuid.generate();
		self._dataValue.setAttribute("id", self.id + "-data");
		if (this.isEditable()) {
			// self.standalone = this.boxParent && this.boxParent.$prototype && (this.boxParent.$prototype.$baseUrl === "/sdata/x3stb/erp/stubs");
			this.$$caret = $("<div>").attr("id", id + "-caret").attr("style", "display:none;").appendTo(self._dataValue);

			// var css = ((this.$item.$css) ? this.$item.$css + " " : "") + this.$skinInput;
			// this.$$input = $('<textarea>').attr('id', "i" + id).attr('name', "i" + id).addClass(css).appendTo(self.fieldValue);
			var $$area = $('<textarea>').attr('id', "html-editor-" + id).attr('name', "html-editor-" + id).appendTo($(self.fieldValue));

			// add attribute to disable browser spellcheck and autocorrect
			syra_site.setSpecificAttributes($$area[0]);

			$$area[0].syraItem = id;
			$$area[0].setAttribute("data-s-field", id);
			(this.$$area = $$area)[0].syrainout = this.id;
			this.$item.$rows && $$area.attr("rows", this.$item.$rows);

			self._editor = $$area.cleditor({
				// resizeSelector: "resize" + helpers.uuid.generate(),
				// width not including margins, borders or padding
				// width: self.$item.$textWidth || "100%",
				width: self.$item.$textWidth || "auto",
				// height not including margins, borders or padding
				// height: self.$item.$textHeight || 480,
				height: self.$item.$textHeight || "auto",
				controls: "bold italic underline strikethrough subscript superscript | font size style | color" + //
				" highlight removeformat | bullets" + //
				// " numbering" +
				" | insertTable " + //
				" | outdent indent alignleft center alignright justify" + //
				" | undo redo | rule image link unlink" + //
				" | cut copy paste pastetext" + //
				" | print source rawMode " + //
				" | extendSize",
				docCSSFile: "/syracuse-ui/themes/desktop/sage/cleditor/jquery.cleditor-doc.css",
				// style to assign to document body contained within the editor
				// bodyStyle: "margin:4px; font:10pt Arial,Verdana; cursor:text"
				bodyStyle: "",
				// sizes in the font size popup
				sizes: fontSizes,
				styles: htmlStyles,
				useCSS: true,
				_field: self,
				_rawAllowed: function() {
					return self._rawAllowed();
				},
				_isRaw: function() {
					return self._rawAllowed() && self._isRaw;
				},
				_setRaw: function(v) {
					if (self._rawAllowed())
						self._isRaw = v;
				},
				// Handlers
				updateFrame: function(html) {
					// TODO: cleanup HTML if necessary
					debug && console.log('>>>> htmlEditor.editor.updateFrame:\n' + html);
					return html;
				},
				updateTextArea: function(html) {
					debug && console.log('>>>> htmlEditor.editor.updateTextArea:\n' + html);
					return html;
				}
			})[0];
		}
	},

	_isRtfMimeType: function() {
		return this.$field.$type == "text/rtf";
	},

	_finalizeCreate: function() {
		debug && console.log('htmlEditor._finalizeCreate ' + this.id);
		this.setState(this.$field);
		this._refreshToolbar();
		this._refreshEditor();

		// Intercept paste event to get the opportunity of sanitizing the contents
		var $$input = $(this._editor.doc.body);

		this._isRtfMimeType() &&
			$$input.bind('paste', function(e) {
				// this code corrupts the undo stack!!!
				var pastedText;
				if (e && e.clipboardData && e.clipboardData.getData) {
					if (/text\/html/.test(e.clipboardData.types)) {
						pastedText = e.clipboardData.getData('text/html');
					} else
					if (/text\/plain/.test(e.clipboardData.types)) {
						pastedText = e.clipboardData.getData('text/plain');
					} else {
						pastedText = "";
					}
				} else
				if (window.clipboardData && window.clipboardData.getData) { // IE
					pastedText = window.clipboardData.getData('Text');
				} else {
					var el = $(this);
					// Hiding the underlying element causes some unpredictable behavior
					// var display;
					// $.browser.mozilla && (display = el.css('display')) && el.css('display', 'none');
					setTimeout(function() {
						var text = $(el).html();
						if (text) {
							$(el).html(sanitize(text));
						}
						// console.log("htmlEditor..paste after timeout:\n" + (text && text.substring(0,50)));
						// display && el.css('display', display);
					}, 300);
				}
				if (pastedText) {
					// debug && console.log("htmlEditor..paste from clipboard:\n" + pastedText);
					$(this).html(sanitize(pastedText));
					e.preventDefault();
					e.stopPropagation();
				}

			});

		this._bindInput(true);
	},

	_refreshToolbar: function() {
		// hack to refresh the toolbar state and disable the toolbar buttons if necessary
		this.isEditable() && this._disable(this._editor.disabled);
	},

	_refreshEditor: function() {
		var editor = this._editor;
		if (editor && editor.$frame && editor.$frame[0] && editor.$frame[0].contentWindow) {
			editor.refresh();
			this.bindEvent && this._bindInput(true);
		}
	},

	_isReady: function() {
		// debug && console.log('htmlEditor._isReady ' + this.id + ": hasDoc=" + ( !! (this._editor || {}).doc) + ", hasBody=" + ( !! ((this._editor || {}).doc || {}).body));
		return !!(this._editor || {}).doc;
	},

	_disable: function(disabled) {
		this._isReady() && this._editor.disable(this.$isReadOnly || !this.isEditable() || disabled);
	},

	_beforeInputFocusin: function($$input, event) {
		debug && console.log("htmlEditor._beforeInputFocusin " + this.id + ", checksum=" + this._cache.checksum);
	},

	_bindInput: function(bind) {
		this.bindEvent = bind;
		if (!(this._editor && this._editor.doc)) {
			return;
		}

		var self = this;
		var doc = this._editor.doc,
			$$doc = $(doc),
			$$input = $(doc.body),
			contentWindow = this._editor.$frame[0].contentWindow,
			$$inputWindow = $.browser.mozilla ? $$doc : $(contentWindow);

		debug && console.log("htmlEditor._bindInput " + this.id + ": bind=" + bind + ", doc=" + doc + ", contentWindow=" + contentWindow);
		if (bind) {
			$$input.on("change keydown keypress keyup focusin focusout", function(event) {
				debug && console.log("htmlEditor.bindInputEvent $$input: " + event.type + " " + self.id);
				/*if (event.type=="change"){
                 var text=$$input.html()
                 var rtftxt=rtf.fromHtml(text)
                 var htmlsanitized=sanitize(text)
                 var log="--------------------------- Change -------------------------------------\n";
                 log+="html :\n"+text;
                 log+="\nrtf :\n"+rtftxt;
                 log+="\nhtmlsanitized :\n"+htmlsanitized;
                 log+="\n--------------------------- End Change ---------------------------------";
                 console.log(log)
                 }*/
				self.onFieldInputEvent(event);
				event.stopPropagation();
			});
			$$inputWindow.on("click", function(event) {
				debug && console.log("htmlEditor.bindInputEvent click --> click" + self.id);
				self.onFieldInputEvent(event);
				event.stopPropagation();
			});
			$$inputWindow.focus(function(event) {
				debug && console.log("htmlEditor.bindInputEvent focus --> focusin " + self.id);
				self._beforeInputFocusin($$input, event);
				$$input.trigger("focusin");
				// self._editor.$main.addClass("cleditorMain-focus");
				syra_site.dom.toggleClass(self._dataValue, "cleditorMain-focus", true);
				event.stopPropagation();
			});
			$$inputWindow.blur(function(event) {
				debug && console.log("htmlEditor.bindInputEvent blur --> focusout " + self.id);
				debug && console.log("\tCaret position: " + self.getCaretPosition());
				// self._editor.$main.removeClass("cleditorMain-focus");
				syra_site.dom.toggleClass(self._dataValue, "cleditorMain-focus", false);
				if (self.isDirty(syra_site.browser.getIdentity().isMSIE)) { // When popup is opening $$inputWindow is onblur with IE 
					$$input.trigger("change");
				}
				$$input.trigger("focusout");
				event.stopPropagation();
			});
		} else {
			$$input.off();
			$$inputWindow.off();
		}
	},

	_rawAllowed: function() {
		return this._isRtfMimeType() && this.$capabilities && this.$capabilities.raw;
	},

	_setRawEditContents: function(contents) {
		if (this.isEditable() && this._editor && this._editor.$area) {
			debug && console.log('htmlEditor._setRawEditContents:\n' + contents);
			this._editor.$area.val(contents || '');
			this._editor.updateFrame();
		}
	},

	_getRawEditContents: function() {
		if (this.isEditable() && this._editor && this._editor.doc) {
			if (this._editor.doc.body) {
				return fixHtml(this._editor.doc.body.innerHTML || "");
			} else
			if (this._editor.$area) {
				// iframe is not yet created so return the textarea content
				return fixHtml(this._editor.$area[0].innerHTML || "");
			}
		}
	},

	_setContents: function(contents, saveStyles) {
		//console.log("rtf : " + contents)
		debug && console.log('htmlEditor._setContents 1: isEditable()=' + this.isEditable() + '\n' + contents);
		this._isRaw = false;
		if (!contents || contents.length === 0) {
			// No contents, assume we want to edit Rich Text or HTML
		} else {
			switch (this.$field.$type) {
				case "text/rtf":
					if (contents.match(/^\s*{\\(u|)rtf/)) {
						contents = rtf.toHtml(contents);
					} else
					if (this._rawAllowed()) {
						this._isRaw = true;
						if (!contents.match(/<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i)) {
							// Not an HTML contents, so wrap it in <pre> tag
							contents = "<pre>" + contents + "</pre>";
						}
					} else {
						this.showDiagnoses([{
							$message: locale.format(_localize.errorRtfExpected, contents),
							$severity: "error"
						}, {
							$message: _localize.warnContentsNotSet,
							$severity: "warning"
						}]);
						return;
					}
					break;
				case "text/html":
					// contents as is
					break;
			}
		}
		debug && console.log('htmlEditor._setContents 2: _isRaw=' + this._isRaw + '\n' + contents);

		if (saveStyles && contents) {
			this.$$savedStyles = $("<div>").append(contents).find('style');
		}
		if (this.isEditable()) {
			this._setRawEditContents(contents);
		} else {
			this.fieldValue.innerHTML = contents;
		}
		//console.log("html : " + contents)
	},

	_getPersistentContents: function(contents) {
		if (!this.isEditable())
			return null;

		if (contents === undefined) {
			contents = this._getRawEditContents();
		}
		if (contents === undefined) {
			return null;
		}
		var hash = checksum(contents);
		if (hash === this._cache.checksum)
			return this._cache.value;
		this._cache.raw = contents;
		debug && console.log('htmlEditor._getPersistentContents change: checksum=' + hash + '\nraw:\n' + contents);

		this._cache.checksum = hash;

		if (this.$$savedStyles) {
			var $$contents = $('<div>').append(contents);
			if ($$contents.find('style').length === 0) {
				$$contents.prepend(this.$$savedStyles);
				contents = $$contents.html();
			}
		}
		if (this._isRaw) {
			var outer = $(contents);
			if (outer.is('pre'))
				contents = normalizeRawText(outer.html());
		} else {
			if (this._isRtfMimeType()) {
				contents = (contents || "").length === 0 ? "" : rtf.fromHtml(contents);
			}
		}
		debug && console.log('htmlEditor._getPersistentContents 2 return: checksum=' + hash + '\ncontents:\n' + contents);
		this._cache.value = contents;
		return contents;
	},

	dispose: function() {
		if (this.resizeSelector) {
			$(window).unbind(this.resizeSelector);
		}
		this._bindInput(false);
		if (this._editor) {
			this._editor.hidePopups();
			this._editor.dispose();
		}
		this.$$area = this._editor = this.$$caret = this.$$savedStyles = this._cache = this.$capabilities = null;
		Field.prototype.dispose.call(this);
	}

});