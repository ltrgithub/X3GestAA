"use strict";
/// !doc
///
/// # Html editor widget that supports RFT conversion
///
/// `HtmlEditor` class subclasses the `Field` class
/// ```javascript
/// var htmlEditor = require('syracuse-ui/lib/field/editor/htmlEditor').HtmlEditor;
/// ```
///
var helpers = require('syracuse-core/lib/helpers');
var resUtil = require('syracuse-core/lib/resource/util');
var aspect = require('syracuse-core/lib/aspect');
var locale = require('syracuse-core/lib/locale');
var Field = require('syracuse-ui/lib/field/field').Field;
var rtf = require("syracuse-rtf");
// require('syracuse-ui/deps/cleditor/jquery.cleditor.min');
require('syracuse-ui/deps/cleditor/jquery.cleditor');

var debug = false;

var ie = $.browser.msie,
    fontSizes = "8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,72";

// Default values are the English one
var _localize = {};

function normalizeRawText(text) {
    return text.replace(/&nbsp;/gi, " ") //
    .replace(/<br\s*[\/]?>/gi, "\r\n") //
    .replace(/<p>/gi, "\r\n");
}

function normalizeHtmlText(html) {
    return html.replace(/\r\n/g, "<br/>") //
    .replace(/\n/g, "<br/>") //
    .replace(/\s/g, "&nbsp;");
}

function fixHtml(html) {
    return html.replace(/<br\s*[\/]?>$/gi, "");
}

function sanitize(html) {
    return rtf.toHtml(rtf.fromHtml(html));
}

// checksum - returns a checksum using the Adler-32 method

function checksum(text) {
    var a = 1,
        b = 0;
    for (var index = 0; index < text.length; ++index) {
        a = (a + text.charCodeAt(index)) % 65521;
        b = (b + a) % 65521;
    }
    return (b << 16) | a;
    // return md5(text);
}

function lazyInit($) {
    // var cleditor = require.async('syracuse-ui/deps/cleditor/jquery.cleditor', function(err, module){});
    var $buttons = $.cleditor.buttons;

    function localize() {
        helpers.object.forEachKey($buttons, function(key) {
            $buttons[key].title = _localize[key] || key + ":<undefined>";
        });
        if ($buttons.rawMode) $buttons.rawMode.title = _localize.rawMode;
    }

    _localize = locale.resources(module)();
    localize();

    if ($buttons.rawMode) {
        return;
    }

    var popupRawModeContent = '<div class="s-msgbox" style="display: inline-block;">' + //
    '<div class="s-msgbox-head">' + //
    '<div class="s-msgbox-title s-msgbox-msg-warning">' + _localize.aboutToSwitchToRawTitle + '</div>' + //
    '</div>' + //
    '<div class="s-msgbox-body">' + _localize.aboutToSwitchToRawConfirm + '</div>' + //
    '<div class="s-msgbox-foot">' + //
    '<a class="s-msgbox-button s-msgbox-button-default" data-s-id="yes">' + _localize.yes + '</a>' + //
    '<a class="s-msgbox-button" data-s-id="no">' + _localize.no + '</a>' + //
    '</div>' + //
    '</div>' + //
    '</div>';

    $buttons.rawMode = {
        name: "rawMode",
        title: _localize.rawMode,
        popupName: "rawMode",
        popupClass: "cleditorPrompt",
        popupContent: popupRawModeContent,
    };


/*$.each(textModes.split(","), function(i, mode){
     $('<div>').appendTo( $$popupRawModeContent).html(mode);
     });*/
/*var  $$listRawMode = $('<select>').attr('mode', function(){
     if ($.cleditor._isRaw)
     return 'rawtext' ;
     else return 'richtext'}) ;
     $$popupRawModeContent.append($$listRawMode);
     $.each(textModes.split(","), function(i, mode){
     $('<option>').append(mode).appendTo( $$listRawMode);
     });*/
    $buttons.rawMode.getEnabled = function(data) {
        var rawAllowed = data.editor.options._rawAllowed();
        if (rawAllowed && data.editor.options._isRaw()) {
            data.button.title = _localize.richMode;
            $(data.button).removeClass("buttonRichText").addClass("buttonRawText");
        } else {
            data.button.title = _localize.rawMode;
            $(data.button).removeClass("buttonRawText").addClass("buttonRichText");
        }
        return rawAllowed;
    };

    // $buttons.rawMode.popupContent = $$popupRawModeContent.html();
    $buttons.rawMode.buttonClick = function(e, data) {
        var button = e.target,
            editor = data.editor,
            $$popup = $(data.popup),
            html;


        if (editor.options._isRaw()) {
            editor.options._setRaw(false);
            html = normalizeHtmlText(fixHtml(editor.$area.val()));
            var $$content = $(html);
            if ($$content.is('pre')) {
                html = $$content.html();
            }
            $(editor.doc.body).html(html);
            editor.options._setRaw(false);
            button.title = _localize.rawMode;
            $(button).removeClass("buttonRawText").addClass("buttonRichText");
            editor.updateTextArea();
            editor.focus(editor);
            return false;
        }

        $$popup.css("padding", "0");
        // Wire up the submit button click event handler
        $$popup.find(".s-msgbox-button").unbind("click").bind("click", function() {
            if ($(this).attr('data-s-id') === "yes") {
                if (!editor.options._isRaw()) {
                    var rawtext = $('<div>').html(normalizeRawText(editor.$area.val())).text(),
                        $$pre = $('<pre>').appendTo('<div>').html(rawtext);
                    editor.$area.val($$pre.parent().html());

                    editor.options._setRaw(true);
                    button.title = _localize.richMode;
                    $(button).removeClass("buttonRichText").addClass("buttonRawText");
                }
                editor.updateFrame();
                editor.disable(editor.disabled);
            }
            editor.hidePopups();
            editor.focus(editor);
        });

        return true;
    };


    var $$popupContent = $('<div>'),
        $$list = $('<select>').attr('size', '8');
    $$popupContent.append($$list);
    $.each(fontSizes.split(","), function(i, size) {
        $('<option>').append(size).appendTo($$list);
        // $('<div>').append($('<span>').prepend(size)).appendTo($$popupContent);
    });

    // font size button
    $buttons.size.popupContent = $$popupContent.html();
    $buttons.size.popupClass = "cleditorList";
    $buttons.size.popupClick = function(e, data) {
        // TODO: fix text selection which is reset after inserting html contents. see createSelection
        // var editor = data.editor,
        //     text = editor.selectedText();
        // // var range = _getRange(editor);
        // var value = target.value || data.value;
        // var html = '<span style="font-size:' + e.target.value + 'pt">' + text + '</span>';
        // editor.execCommand("inserthtml", html, null, data.button);
        // editor.hidePopups();
        // editor.focus(editor);
        // range && range.select();
        // return false;
        data.command = "inserthtml";
        data.value = '<span style="font-size:' + e.target.value + 'pt; ">' + data.editor.selectedText() + '</span>';
        return true;
    };

    $buttons.source.getEnabled = function(data) {
        var rawAllowed = data.editor.options._rawAllowed();
        return !(rawAllowed && data.editor.options._isRaw());
    };

    // paste button
    // $buttons.paste.buttonClick = function(e, data) {
    //     data.editor.execCommand(data.command, data.value, data.useCSS, data.button);
    //     return false;
    // };
    var formattingbuttons = "bold italic underline strikethrough subscript superscript font size " + //
    "color highlight bullets numbering outdent indent alignleft center alignright " + //
    "justify rule image link unlink removeformat";
    $.each(formattingbuttons.split(" "), function(idx, buttonName) {

        $buttons[buttonName].getEnabled = function(data) {
            return !data.editor.options._isRaw();
        };
    });
}

function _getRange(editor) {
    // if (ie) return _getSelection(editor).createRange();
    return _getSelection(editor).getRangeAt(0);
}

function _getSelection(editor) {
    // supported by all browsers including ie9
    return editor.$frame[0].contentWindow.getSelection();
}


function HtmlEditor() {}

exports.HtmlEditor = helpers.defineClass(HtmlEditor, Field, {
    initialize: function() {
        this.$item.$isAutoSizeDisabled = true;
        this.$item.$isAutoSize = true;
        this._cache = {};
    },
    onWindowResize: function() {
        if (this.$$item && this.$$item[0].clientWidth) {
            if (this.isEditable()) {
                if (!this.isCreated) {
                    this.isCreated = true;
                    this._finalizeCreate();
                    if (this._isFocusRequested) {
                        this._editor.focus();
                        delete this._isFocusRequested;
                    }
                }
            }
            this._refreshEditor();
        }
    },

    getLazyUrl: function(value) {
        return this.articleParent.parseExpression(value && value.$url || this.$field.$url);
    },

    /// -------------
    /// ## setDataValue(value)
    ///
    /// Sets the content value.
    ///
    /// This method is not intended to be called directly.
    /// The normal way to set the value with its metadata is to call `setDataBind(value, record, metaData)`
    ///
    /// **Overrides:** Field.setDataValue(...)
    ///
    setDataValue: function(value) {
        debug && console.log('htmlEditor.setDataValue 1: ' + this.id + '\n$isEditMode=' + this.$isEditMode + '\ncurrent:\n' + this.currentValue + '\nnew value:\n' + value);
        var self = this;
        this.$lazyUrl = this.getLazyUrl(value);
        if (this.$lazyUrl && value && typeof(value) === 'object') {
            // lazy loading
            self.$contentType = value.$contentType || (this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type);
            document.controller.sendRequest(null, {
                $location: {
                    $url: self.$lazyUrl,
                    $contentType: self.$contentType,
                    $type: self.$contentType
                }
            }, function(data, response) {
                debug && console.log('htmlEditor.lazyload: ' + self.id + '\n$isEditMode=' + self.$isEditMode + '\ncurrent:\n' + self.currentValue + '\nnew value:\n' + data);
                if (typeof(data) === 'string') {
                    self.setDataValue(data);
                } else {
                    self.showErrors([locale.format(self.getLocalize().f_badDataType, "string", typeof(data))]);
                }
            }, function(error, httpquery) {
                debug && console.log('htmlEditor.lazyload: ' + self.id + ' error=' + error.message);
                self.showErrors([error.message]);
            });
        } else {
            try {
                if (this.currentValue != value) {
                    var styles = this.$field.$styles;
                    // var styles = Array.isArray(value.$styles) ? styles = value.$styles.join("\n") : styles = value.$styles;
                    // this._editor.options.headStyle = styles || this._editor.options.headStyle;
                    this._setContents(value, true);
                    this._cache.oldValue = this.currentValue = this._getPersistentContents();
                    // this._cache.dirtyChecksum = this._cache.checksum;
                }
            } catch (error) {
                this.showErrors([error.message]);
            }
            debug && console.log('htmlEditor.setDataValue 2: ' + this.id + '\n$isEditMode=' + this.$isEditMode + ', checksum=' + this._cache.dirtyChecksum + //
            '\ncurrent:\n' + this.currentValue + '\nnew:\n' + value);

            this._refreshToolbar();
        }
    },
    /// -------------
    /// ## getInputValue()
    ///
    /// Gets the content value.
    ///
    /// **Overrides:** Field.getInputValue()
    ///
    getInputValue: function() {
        debug && console.log('htmlEditor.getInputValue: ' + this.id + ' isDirty=' + this.isDirty() + ', contents=\n' + this._getPersistentContents());
        if (this.isEditable() && this._editor && this._editor.$area) {
            var contents = this._getPersistentContents();
            // this._cache.changedChecksum = this._cache.checksum;
            return contents;
        }
        return "";
    },
    /// -------------
    /// ## isDirty()
    ///
    /// Returns `true` if the content has changed since the field gained the focus or since the last setDataValue.
    ///
    isDirty: function() {
        // Get the current content to compute the checksum
        var value = this._getPersistentContents(),
            dirty = (this._cache.oldValue !== value);
        // dirty = (this._cache.dirtyChecksum !== this._cache.checksum);
        debug && console.log('htmlEditor.isDirty: ' + this.id + ' isDirty=' + dirty + //
        ", checksum=" + this._cache.checksum + '\nnew:\n' + value + '\nold:\n' + //
        this._cache.oldValue + '\ncached:\n' + this._cache.value + '\nraw:\n' + this._cache.raw);
        return dirty;
    },
    // -------------
    // ## hasChanged()
    //
    // Returns `true` if the content has changed since the last call to `getInputValue`.
    //
    // hasChanged: function() {
    //     return (this._cache.changedChecksum == null) || this._cache.changedChecksum !== this._cache.checksum;
    // },
    /// -------------
    /// ## validateType(errors, value)
    ///
    /// Validates the current value and reports errors.
    ///
    /// This method is called during the validation process and is not intended to be called directly.
    ///
    /// **See:** Field.validate(...)
    ///
    validateType: function(errors, value) {
        if (this.currentValue && this.$maxLength && this.currentValue.length > this.$maxLength) {
            errors.push(locale.format(_localize.errorMaxLength, this.$maxLength));
        }
        debug && console.log('htmlEditor.validateType: ' + this.id + '\nValue: ' + this.currentValue);
    },

    /// -------------
    /// ## notifyFieldChange(newValue, validated)
    ///
    /// Notified the change to the server.
    ///
    /// This method is called during the validation process and is not intended to be called directly.
    /// It overides the standard behavior to allow update of lazy loaded contents.
    ///
    /// **See:** Field.notifyFieldChange(...)
    ///
    notifyFieldChange: function(newValue, validated) {
        var self = this;
        this.$lazyUrl = this.getLazyUrl();
        if (this.$lazyUrl) {
            debug && console.log('htmlEditor.notifyFieldChange lazy content: ' + self.id + '\nValue: ' + newValue);
            document.controller.sendRequest(null, {
                $location: {
                    $url: self.$lazyUrl,
                    $contentType: self.$contentType,
                    $type: self.$contentType
                },
                data: newValue,
                method: "PUT"
            }, function(data, response, requestUrl) {
                debug && console.log('htmlEditor.notifyFieldChange lazy upload: ' + self.id + '\ndata: ' + data + ', response=' + JSON.stringify(response));
            });
        } else {
            Field.prototype.notifyFieldChange.call(this, newValue, validated);
        }
    },


    /// -------------
    /// ## focus()
    ///
    /// Sets the focus to the edit part of the widget.
    ///
    /// **Overrides:** Field.focus()
    ///
    focus: function() {
        debug && console.log('htmlEditor.focus: ' + this.id);
        if (this.isEditable() && this._editor) {
            if (!this.isCreated) {
                this._isFocusRequested = true;
            } else {
                this._editor.focus();
            }
        }
    },
    /// -------------
    /// ## getCaretPosition()
    ///
    /// Gets the current 0 based caret position in the editor.
    ///
    /// **Overrides:** Field.getCaretPosition()
    ///
    getCaretPosition: function() {
        if (!(this.isEditable() && this._editor && this._editor.doc.body && this.$$caret)) return 0;

        var doc = this._editor.doc,
            root = doc.body,
            sel = _getSelection(this._editor),
            $$caret = this.$$caret,
            caretPos, range, contents;

        range = doc.createRange();
        range.setStart(root, 0);
        sel.focusNode && range.setEnd(sel.focusNode, sel.focusOffset);
        contents = range.cloneContents();

        if (contents) {
            $$caret.append(contents);
            $$caret.html($$caret.html().replace(/<br\s*[\/]?>/gi, "\n"));
            caretPos = $$caret.text().length;
            $$caret.empty();
        }
        return caretPos;
    },

    isEditable: function() {
        return this.$isEditMode;
    },

    setState: function(state) {
        debug && console.log('htmlEditor.setState: ' + this.id + "\n" + (state ? JSON.stringify(state) : "<undefined>"));
        if (state && state.$isDisabled !== undefined) {
            this._editor && this._editor.disable(state.$isDisabled);
        }
        Field.prototype.setState.call(this, state);
    },

    toggleEditMode: function($isEditMode) {
        // reset value because setDataValue will check the equality
        this.currentValue = undefined;
        Field.prototype.toggleEditMode.call(this, $isEditMode);
    },
    _onSetReadOnly: function($isReadOnly) {
        this._editor && this._editor.disable($isReadOnly);
        Field.prototype._onSetReadOnly.call(this, $isReadOnly);
    },
    render: function() {
        this.$maxLength = this.$field.$maxLength || this.$field.$maxByteLength;
        this.$capabilities = this.$capabilities || resUtil.parseCapabilities(this.$field.$capabilities);
        this.$lazyUrl = this.getLazyUrl();
        this.$contentType = this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type;

        lazyInit(jQuery);
        debug && console.log('htmlEditor.render ' + this.id);
        var self = this;
        var id = helpers.uuid.generate();
        self.$$dataValue.attr("id", self.id + "-data");
        if (this.isEditable()) {
            // self.standalone = this.boxParent && this.boxParent.$prototype && (this.boxParent.$prototype.$baseUrl === "/sdata/x3stb/erp/stubs");
            this.$$caret = $("<div>").attr("id", id + "-caret").attr("style", "display:none;").appendTo(self.$$dataValue);

            // var css = ((this.$item.$css) ? this.$item.$css + " " : "") + this.$skinInput;
            // this.$$input = $('<textarea>').attr('id', "i" + id).attr('name', "i" + id).addClass(css).appendTo(self.$$fieldValue);
            var $$area = $('<textarea>').attr('id', "html-editor-" + id).attr('name', "html-editor-" + id).attr("data-s-field", id).appendTo($(self.fieldValue));
            this.$item.$rows && $$area.attr("rows", this.$item.$rows);

            self._editor = $$area.cleditor({
                resizeSelector: self.resizeSelector = "resize." + helpers.uuid.generate(),
                // width not including margins, borders or padding
                // width: self.$item.$textWidth || "100%",
                width: self.$item.$textWidth || "auto",
                // height not including margins, borders or padding
                // height: self.$item.$textHeight || 480,
                height: self.$item.$textHeight || "auto",
                controls: "bold italic underline strikethrough subscript superscript | font size | color" + //
                " highlight removeformat | bullets" + /*+" numbering" */
                " | outdent indent alignleft center alignright justify" + //
                " | undo redo | rule image link unlink" + //
                " | cut copy paste pastetext" + //
                " | print source rawMode",
                // style to assign to document body contained within the editor
                // bodyStyle: "margin:4px; font:10pt Arial,Verdana; cursor:text"
                bodyStyle: "",
                // sizes in the font size popup
                sizes: fontSizes,
                useCSS: true,
                // _field: self,
                _rawAllowed: function() {
                    return self._rawAllowed();
                },
                _isRaw: function() {
                    return self._rawAllowed() && self._isRaw;
                },
                _setRaw: function(v) {
                    if (self._rawAllowed()) self._isRaw = v;
                },
                // Handlers
                updateFrame: function(html) {
                    // TODO: cleanup HTML if necessary
                    debug && console.log('>>>> htmlEditor.editor.updateFrame:\n' + html);
                    return html;
                },
                updateTextArea: function(html) {
                    debug && console.log('>>>> htmlEditor.editor.updateTextArea:\n' + html);
                    return html;
                }
            })[0];
        }
    },

    _isRtfMimeType: function() {
        return this.$field.$type == "text/rtf";
    },

    _finalizeCreate: function() {
        debug && console.log('htmlEditor._finalizeCreate ' + this.id);
        this.setState(this.$field);
        this._refreshToolbar();
        this._refreshEditor();

        // Intercept paste event to get the opportunity of sanitizing the contents
        var $$input = $(this._editor.doc.body);

        this._isRtfMimeType() && $$input.bind('paste', function(e) {
            // this code corrupts the undo stack!!!
            var pastedText;
            if (e && e.clipboardData && e.clipboardData.getData) {
                if (/text\/html/.test(e.clipboardData.types)) {
                    pastedText = e.clipboardData.getData('text/html');
                } else if (/text\/plain/.test(e.clipboardData.types)) {
                    pastedText = e.clipboardData.getData('text/plain');
                } else {
                    pastedText = "";
                }
            } else if (window.clipboardData && window.clipboardData.getData) { // IE
                pastedText = window.clipboardData.getData('Text');
            } else {
                var el = $(this);
                // Hiding the underlying element causes some unpredictable behavior
                // var display;
                // $.browser.mozilla && (display = el.css('display')) && el.css('display', 'none');
                setTimeout(function() {
                    var text = $(el).html();
                    if (text) {
                        $(el).html(sanitize(text));
                    }
                    // display && el.css('display', display);
                    debug && console.log("htmlEditor..paste after timeout:\n" + text);
                }, 300);
            }
            if (pastedText) {
                $(this).html(sanitize(pastedText));
                e.preventDefault();
                e.stopPropagation();
            }

        });

        this._bindInput(true);
    },

    _refreshToolbar: function() {
        // hack to refresh the toolbar state and disable the toolbar buttons if necessary
        this.isEditable() && this._editor.disable(this._editor.disabled);
    },

    _refreshEditor: function() {
        if (this._editor && this._editor.$frame && this._editor.$frame[0] && this._editor.$frame[0].contentWindow) {
            this._editor.refresh();
            this.bindEvent && this._bindInput(true);
        }
    },

    _beforeInputFocusin: function($$input, event) {
        // Get the content to compute the checksum
        this._cache.oldValue = this._getPersistentContents();
        // this._cache.dirtyChecksum = this._cache.checksum;
        debug && console.log("htmlEditor._beforeInputFocusin " + this.id + " checksum=" + this._cache.checksum + "\n" + this._cache.oldValue);
    },

    _bindInput: function(bind) {
        this.bindEvent = bind;
        if (!this._editor) {
            return;
        }

        var self = this;
        var doc = this._editor.doc,
            $$doc = $(doc),
            $$input = $(doc.body),
            contentWindow = this._editor.$frame[0].contentWindow,
            $$inputWindow = $.browser.mozilla ? $$doc : $(contentWindow);

        debug && console.log("htmlEditor._bindInput " + this.id + ": bind=" + bind + ", doc=" + doc + ", contentWindow=" + contentWindow);
        if (bind) {
            $$input //
            .on("change keydown keypress keyup focusin focusout", function(event) {
                debug && console.log("htmlEditor.bindInputEvent $$input: " + event.type + " " + self.id);
                self.onFieldInputEvent(event);
                event.stopPropagation();
            });

            $$inputWindow //
            .on("click", function(event) {
                debug && console.log("htmlEditor.bindInputEvent click --> click" + self.id);
                self.onFieldInputEvent(event);
                event.stopPropagation();
            }) //
            .focus(function(event) {
                debug && console.log("htmlEditor.bindInputEvent focus --> focusin " + self.id);
                self._beforeInputFocusin($$input, event);
                $$input.trigger("focusin");
                // self._editor.$main.addClass("cleditorMain-focus");
                self.$$dataValue.addClass("cleditorMain-focus");
                event.stopPropagation();
            }) //
            .blur(function(event) {
                debug && console.log("htmlEditor.bindInputEvent blur --> focusout " + self.id);
                debug && console.log("\tCaret position: " + self.getCaretPosition());
                // self._editor.$main.removeClass("cleditorMain-focus");
                self.$$dataValue.removeClass("cleditorMain-focus");

                if (self.isDirty()) {
                    $$input.trigger("change");
                }
                $$input.trigger("focusout");
                event.stopPropagation();
            }) //
            ;
        } else {
            $$input.off();
            $$inputWindow.off();
        }
    },

    _rawAllowed: function() {
        return this._isRtfMimeType() && this.$capabilities && this.$capabilities.raw;
    },

    _setRawEditContents: function(contents) {
        if (this.isEditable() && this._editor && this._editor.$area) {
            debug && console.log('htmlEditor._setRawEditContents:\n' + contents);
            this._editor.$area.val(contents || '');
            this._editor.updateFrame();
        }
    },

    _getRawEditContents: function() {
        return this.isEditable() && this._editor && this._editor.$area && fixHtml(this._editor.$area.val());
    },

    _setContents: function(contents, saveStyles) {
        debug && console.log('htmlEditor._setContents 1: isEditable()=' + this.isEditable() + '\n' + contents);
        this._isRaw = false;
        if (!contents || contents.length === 0) {
            // No contents, assume we want to edit Rich Text or HTML
        } else {
            switch (this.$field.$type) {
            case "text/rtf":
                if (contents.match(/^\s*{\\rtf/)) {
                    contents = rtf.toHtml(contents);
                } else if (this._rawAllowed()) {
                    this._isRaw = true;
                    if (!contents.match(/<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i)) {
                        // Not an HTML contents, so wrap it in <pre> tag
                        contents = "<pre>" + contents + "</pre>";
                    }
                } else {
                    this.showDiagnoses([{
                        $message: locale.format(_localize.errorRtfExpected, contents),
                        $severity: "error"
                    }, {
                        $message: _localize.warnContentsNotSet,
                        $severity: "warning"
                    }]);
                    return;
                }
                break;
            case "text/html":
                // contents as is
                break;
            }
        }
        debug && console.log('htmlEditor._setContents 2: _isRaw=' + this._isRaw + '\n' + contents);

        if (saveStyles && contents) {
            this.$$savedStyles = $(contents).find('style');
        }
        if (this.isEditable()) {
            this._setRawEditContents(contents);
        } else {
            document.site.emptyDom(this.fieldValue);
            this.fieldValue.innerHTML = contents;
        }
    },


    _getPersistentContents: function(contents) {
        if (!this.isEditable()) return null;

        if (contents === undefined) {
            contents = this._getRawEditContents();
        }
        var hash = checksum(contents);
        if (hash === this._cache.checksum) return this._cache.value;
        this._cache.raw = contents;
        debug && console.log('htmlEditor._getPersistentContents change: checksum=' + hash + '\nraw:\n' + contents);

        this._cache.checksum = hash;

        if (this.$$savedStyles) {
            var $$contents = $('<div>').append(contents);
            if ($$contents.find('style').length === 0) {
                $$contents.prepend(this.$$savedStyles);
                contents = $$contents.html();
            }
        }
        if (this._isRaw) {
            var outer = $(contents);
            if (outer.is('pre')) contents = normalizeRawText(outer.html());
        } else {
            if (this._isRtfMimeType()) {
                contents = (contents || "").length === 0 ? "" : rtf.fromHtml(contents);
            }
        }
        debug && console.log('htmlEditor._getPersistentContents return: checksum=' + hash + '\ncontents:\n' + contents);
        this._cache.value = contents;
        return contents;
    },

    dispose: function() {
        debug && console.log('htmlEditor.dispose ' + this.id);
        if (this.resizeSelector) {
            $(window).unbind(this.resizeSelector);
        }
        this._bindInput(false);
        if (this._editor) {
            this._editor.dispose();
            delete this._editor;
        }
        Field.prototype.dispose.call(this);
    }

});