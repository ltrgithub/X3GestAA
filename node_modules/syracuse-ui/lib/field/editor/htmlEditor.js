"use strict";
/// !doc
///
/// # Html editor widget that supports RFT conversion
///
/// `HtmlEditor` class subclasses the `Field` class
/// ```javascript
/// var htmlEditor = require('syracuse-ui/lib/field/editor/htmlEditor').HtmlEditor;
/// ```
///
var helpers = require('syracuse-core/lib/helpers');
var resUtil = require('syracuse-core/lib/resource/util');
var aspect = require('syracuse-core/lib/aspect');
var locale = require('syracuse-core/lib/locale');
var Field = require('syracuse-ui/lib/field/field').Field;
var fieldHelper = require('syracuse-ui/lib/field/fieldHelper');
var rtf = require("syracuse-rtf");
// require('syracuse-ui/deps/cleditor/jquery.cleditor.min');
require('syracuse-ui/deps/cleditor/jquery.cleditor');

var debug = false;
var inject = false;

var ie = $.browser.msie, fontSizes = "8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,72";

// Default values are the English one
var _localize = {
    bold: "Bold",
    italic: "Italic",
    underline: "Underlined",
    strikethrough: "Strikethrough",
    subscript: "Subscript",
    superscript: "Superscript",
    font: "Font",
    size: "Font Size",
    color: "Font Color",
    highlight: "Text Highlight Color",
    removeformat: "Remove Formatting",
    bullets: "Bullets",
    outdent: "Outdent",
    indent: "Indent",
    alignleft: "Align Text Left",
    center: "Center",
    alignright: "Align Text Right",
    justify: "Justify",
    undo: "Undo",
    redo: "Redo",
    rule: "Insert Horizontal Rule",
    image: "Insert Image",
    link: "Insert Hyper Link",
    unlink: "Remove Hyper Link",
    cut: "Cut",
    copy: "Copy",
    paste: "Paste",
    pastetext: "Paste as Text",
    print: "Print",
    source: "Show source",
    richMode: "Show Rich Text",
    rawMode: "Show Plain Text",
    aboutToSwitchToRawTitle: "Confirm switching to plain text mode.",
    aboutToSwitchToRawConfirm: "All formatting will be lost.<br/>Do you really want to switch?",
    yes: "Yes",
    no: "No",
    errorMaxLength: "The RTF contents exceed the maximum length of {0} bytes"
};

// Fusion page hacking for test purpose
debug && inject &&
(function(){
    var WorkBook = require('syracuse-ui/lib/fusion/workBook').WorkBook, WinStack = require('syracuse-ui/lib/fusion/core/client/sap/window').WinStack, typeMap = {
        "text/rtf": function(p, key){
            if (p.$maxByteLength) {
                p.$maxLength = p.$maxByteLength;
            }
            else 
                if (p.$maxLength && p.$maxLength < 12) {
                    p.$maxLength = 512 * (2 ^ p.$maxLength) - 2;
                }
            p.$capabilities = (p.$capabilities || "").split().push("raw").join();
        }
    };
    
    aspect.before(WorkBook, ["loadSheet"], function(context, args, result){
        var $prototype = args[0] && args[0].$representation && args[0].$representation.$prototype || {}, $properties = $prototype.$properties;
        helpers.object.forEachKey($properties, function(key, p){
            typeMap[p.$type] && typeMap[p.$type](p, key);
        });
    });
    
    // applyChange: function(winId, change, options)
    aspect.before(WinStack, ["applyChange"], function(context, args, result){
        var winId = args[0] || {}, change = args[1] || {}, options = args[2] || {};
        
        var idEx = this._getWinIdEx(winId), model = this._windows[idEx.id], proto = model && model.getProto();
        
        helpers.object.forEachKey(change.entities, function(key, p){
            var $type = proto && proto[key].$type;
            if ($type === "text/rtf") {
                // p.$style = ";font-family:MS Sans Serif;font-size:8pt;color:#000000;font-weight:normal;font-style:normal;background-color:#78A7F5";
            }
        });
    });
})();

function normalizeRawText(text){
    return text.replace(/&nbsp;/gi, " ") //
.replace(/<br\s*[\/]?>/gi, "\r\n") //
.replace(/<p>/gi, "\r\n");
}

function normalizeHtmlText(html){
    return html.replace(/\r\n/g, "<br/>") //
.replace(/\n/g, "<br/>") //
.replace(/\s/g, "&nbsp;");
}

function sanitize(html){
    return rtf.toHtml(rtf.fromHtml(html));
}

// checksum - returns a checksum using the Adler-32 method

function checksum(text){
    var a = 1, b = 0;
    for (var index = 0; index < text.length; ++index) {
        a = (a + text.charCodeAt(index)) % 65521;
        b = (b + a) % 65521;
    }
    return (b << 16) | a;
}

function lazyInit($){
    // var cleditor = require.async('syracuse-ui/deps/cleditor/jquery.cleditor', _);
    var $buttons = $.cleditor.buttons;
    
    function localize(){
        helpers.object.forEachKey($buttons, function(key){
            $buttons[key].title = _localize[key] || key + ":<undefined>";
        });
        if ($buttons.rawMode) 
            $buttons.rawMode.title = _localize.rawMode;
    }
    
    _localize = locale.resources(module)();
    localize();
    
    if ($buttons.rawMode != null) {
        return;
    }
    
    // var maxStripIndex = Object.keys($buttons).reduce(function(previousValue, currentValue) {
    //     return Math.max($buttons[previousValue] && $buttons[previousValue].stripIndex || 0, $buttons[currentValue].stripIndex);
    // });
    var popupRawModeContent = '<div class="s-msgbox" style="display: inline-block;">' //
 +
    '<div class="s-msgbox-header">' //
 +
    '<div class="s-msgbox-header-title s-msgbox-msg-warning">' +
    _localize.aboutToSwitchToRawTitle +
    '</div>' //
    // + '<div class="s-msgbox-header-title s-cleditor-raw-text" style="display: none">' + _localize.aboutToSwitchToRawTitle + '</div>' //
    // + '<div class="s-msgbox-header-title s-cleditor-rich-text"  style="display: none">' + _localize.aboutToSwitchToRichTitle + '</div>' //
    +
    '</div>' //
 +
    '<div class="s-msgbox-body">' +
    _localize.aboutToSwitchToRawConfirm +
    '</div>' //
    // + '<div class="s-msgbox-body s-msgbox-msg-warning s-cleditor-raw-text" style="display: none">' + _localize.aboutToSwitchToRawConfirm + '</div>' //
    // + '<div class="s-msgbox-body s-msgbox-msg-warning s-cleditor-rich-text" style="display: none">' + _localize.aboutToSwitchToRichConfirm + '</div>' //
    +
    '<div class="s-msgbox-foot">' //
 +
    '<a class="s-msgbox-button s-msgbox-button-default" data-s-id="yes">' +
    _localize.yes +
    '</a>' //
 +
    '<a class="s-msgbox-button" data-s-id="no">' +
    _localize.no +
    '</a>' //
 +
    '</div>' //
 +
    '</div>' //
 +
    '</div>';
    
    $buttons.rawMode = {
        name: "rawMode",
        title: _localize.rawMode,
        popupName: "rawMode",
        // stripIndex: maxStripIndex + 1
        popupClass: "cleditorPrompt",
        popupContent: popupRawModeContent,
    };
    
    
    /*$.each(textModes.split(","), function(i, mode){
     $('<div>').appendTo( $$popupRawModeContent).html(mode);
     });*/
    /*var  $$listRawMode = $('<select>').attr('mode', function(){
     if ($.cleditor._isRaw)
     return 'rawtext' ;
     else return 'richtext'}) ;
     $$popupRawModeContent.append($$listRawMode);
     $.each(textModes.split(","), function(i, mode){
     $('<option>').append(mode).appendTo( $$listRawMode);
     });*/
    $buttons.rawMode.getEnabled = function(data){
        var rawAllowed = data.editor.options._rawAllowed();
        if (rawAllowed && data.editor.options._isRaw()) {
            data.button.title = _localize.richMode;
            $(data.button).removeClass("buttonRichText").addClass("buttonRawText");
        }
        else {
            data.button.title = _localize.rawMode;
            $(data.button).removeClass("buttonRawText").addClass("buttonRichText");
        }
        return rawAllowed;
    }
    
    // $buttons.rawMode.popupContent = $$popupRawModeContent.html();
    $buttons.rawMode.buttonClick = function(e, data){
        var button = e.target, editor = data.editor, $$popup = $(data.popup), html;
        
        
        if (editor.options._isRaw()) {
            editor.options._setRaw(false);
            html = normalizeHtmlText(editor.$area.val());
            var $$content = $(html);
            if ($$content.is('pre')) {
                html = $$content.html();
            }
            // editor.$area.val(html);
            $(editor.doc.body).html(html);
            editor.options._setRaw(false);
            button.title = _localize.rawMode;
            $(button).removeClass("buttonRawText").addClass("buttonRichText");
            editor.updateTextArea();
            editor.focus(editor);
            return false;
        }
        
        $$popup.css("padding", "0");
        // Wire up the submit button click event handler
        $$popup.find(".s-msgbox-button").unbind("click").bind("click", function(){
            if ($(this).attr('data-s-id') === "yes") {
                if (!editor.options._isRaw()) {
                    var rawtext = $('<div>').html(normalizeRawText(editor.$area.val())).text(), $$pre = $('<pre>').appendTo('<div>').html(rawtext);
                    editor.$area.val($$pre.parent().html());
                    
                    editor.options._setRaw(true);
                    button.title = _localize.richMode;
                    $(button).removeClass("buttonRichText").addClass("buttonRawText");
                }
                editor.updateFrame();
                editor.disable(editor.disabled);
            }
            editor.hidePopups();
            editor.focus(editor);
        });
        
        return true;
    };
    
    
    var $$popupContent = $('<div>'), $$list = $('<select>').attr('size', '8');
    $$popupContent.append($$list);
    $.each(fontSizes.split(","), function(i, size){
        $('<option>').append(size).appendTo($$list);
        // $('<div>').append($('<span>').prepend(size)).appendTo($$popupContent);
    });
    
    // font size button
    $buttons.size.popupContent = $$popupContent.html();
    $buttons.size.popupClass = "cleditorList";
    $buttons.size.popupClick = function(e, data){
        // TODO: fix text selection which is reset after inserting html contents. see createSelection
        // var editor = data.editor,
        //     text = editor.selectedText();
        // // var range = _getRange(editor);
        // var value = target.value || data.value;
        // var html = '<span style="font-size:' + e.target.value + 'pt">' + text + '</span>';
        // editor.execCommand("inserthtml", html, null, data.button);
        // editor.hidePopups();
        // editor.focus(editor);
        // range && range.select();
        // return false;
        data.command = "inserthtml";
        data.value = '<span style="font-size:' + e.target.value + 'pt; ">' + data.editor.selectedText() + '</span>';
        return true;
    };
    
    $buttons.source.getEnabled = function(data){
        var rawAllowed = data.editor.options._rawAllowed();
        return !(rawAllowed && data.editor.options._isRaw());
    }
    
    // paste button
    // $buttons.paste.buttonClick = function(e, data) {
    //     data.editor.execCommand(data.command, data.value, data.useCSS, data.button);
    //     return false;
    // };
    var formattingbuttons = "bold italic underline strikethrough subscript superscript font size " //
 +
    "color highlight bullets numbering outdent indent alignleft center alignright " //
 +
    "justify rule image link unlink removeformat";
    $.each(formattingbuttons.split(" "), function(idx, buttonName){
    
        $buttons[buttonName].getEnabled = function(data){
            return !data.editor.options._isRaw();
        }
    });
}

function _getRange(editor){
    // if (ie) return _getSelection(editor).createRange();
    return _getSelection(editor).getRangeAt(0);
}

function _getSelection(editor){
    // supported by all browsers including ie9
    return editor.$frame[0].contentWindow.getSelection();
}


function HtmlEditor(){
}

exports.HtmlEditor = helpers.defineClass(HtmlEditor, Field, {
    initialize: function(){
        this.$isLayoutContentSizeDisabled = true;
        this.$item.$isAutoSize = true;
        this._cache = {};
    },
    
    onWindowResize: function(){
        if (this._editor && this._editor.$frame && this._editor.$frame[0] && this._editor.$frame[0].contentWindow) {
            this._editor.refresh();
        }
    },
    
    /// -------------
    /// ## setDataValue(value)
    /// 
    /// Sets the content value.
    ///   
    /// This method is not intended to be called directly.  
    /// The normal way to set the value with its metadata is to call `setDataBind(value, record, metaData)`
    /// 
    /// **Overrides:** Field.setDataValue(...)
    /// 
    setDataValue: function(value){
        debug && console.log('htmlEditor.setDataValue: ' + this.id + '\n$isEditMode=' + this.$isEditMode + '\ncurrent:\n' + this.currentValue + '\nnew value:\n' + value);
        if (this.currentValue != value) {
            this.currentValue = value;
            var styles = this.$field.$styles;
            // var styles = Array.isArray(value.$styles) ? styles = value.$styles.join("\n") : styles = value.$styles;
            // this._editor.options.headStyle = styles || this._editor.options.headStyle;
            this._setContents(value, true);
        }
        
        this._refreshToolbar();
    },
    /// -------------
    /// ## getInputValue()
    /// 
    /// Gets the content value.
    /// 
    /// **Overrides:** Field.getInputValue()
    /// 
    getInputValue: function(){
        debug && console.log('htmlEditor.getInputValue: ' + this.id + '\n' + this._getPersistentContents());
        if (this.isEditable() && this._editor && this._editor.$area) {
            var contents = this._getPersistentContents();
            this._cache.snapshotChecksum = this._cache.checksum;
            return contents;
        }
        return "";
    },
    /// -------------
    /// ## isDirty()
    /// 
    /// Returns `true` if the content has changed since a call to `setDataValue`.
    /// 
    isDirty: function(){
        return this.currentValue !== this._getPersistentContents();
    },
    /// -------------
    /// ## hasChanged()
    /// 
    /// Returns `true` if the content has changed since the last call to `getInputValue`.
    /// 
    hasChanged: function(){
        return (this._cache.snapshotChecksum == null) || this._cache.snapshotChecksum !== this._cache.checksum;
    },
    /// -------------
    /// ## validateType(errors, value)
    /// 
    /// Validates the current value and reports errors.
    /// 
    /// This method is called during the validation process and is not intended to be called directly.  
    /// 
    /// **See:** Field.validate(...)
    /// 
    validateType: function(errors, value){
        if (this.currentValue && this.$maxLength && this.currentValue.length > this.$maxLength) {
            errors.push(locale.format(_localize.errorMaxLength, this.$maxLength));
        }
    },
    /// -------------
    /// ## focus()
    /// 
    /// Sets the focus to the edit part of the widget.
    /// 
    /// **Overrides:** Field.focus()
    /// 
    focus: function(){
        debug && console.log('htmlEditor.focus: ' + this.id);
        var self = this;
        // Hack! Delayed call to ensure that the text do not vanish
        setTimeout(function(){
            debug && console.log('htmlEditor.focus: actual delayed call');
            self.isEditable() && self._editor && self._editor.focus();
        }, 100);
    },
    /// -------------
    /// ## getCaretPosition()
    /// 
    /// Gets the current 0 based caret position in the editor.
    /// 
    /// **Overrides:** Field.getCaretPosition()
    /// 
    getCaretPosition: function(){
        if (!(this.isEditable() && this._editor && this._editor.doc.body && this.$$caret)) 
            return 0;
        
        var doc = this._editor.doc, root = doc.body, sel = _getSelection(this._editor), $$caret = this.$$caret, caretPos, range, contents;
        
        range = doc.createRange();
        range.setStart(root, 0);
        sel.focusNode && range.setEnd(sel.focusNode, sel.focusOffset);
        contents = range.cloneContents();
        
        if (contents) {
            $$caret.append(contents);
            $$caret.html($$caret.html().replace(/<br\s*[\/]?>/gi, "\n"));
            caretPos = $$caret.text().length;
            $$caret.empty();
        }
        return caretPos;
    },
    
    isEditable: function(){
        return this.$isEditMode;
    },
    
    setState: function(state){
        debug && console.log('htmlEditor.setState ' + this.id + "\n" + JSON.stringify(state));
        if (state.$isDisabled !== undefined) {
            this._editor && this._editor.disable(state.$isDisabled);
        }
        Field.prototype.setState.call(this, state);
    },
    
    toggleEditMode: function($isEditMode){
        // reset value because setDataValue will check the equality
        this.currentValue = undefined;
        Field.prototype.toggleEditMode.call(this, $isEditMode);
    },
    
    setReadOnly: function($isReadOnly){
        this._editor && this._editor.disable($isReadOnly);
        Field.prototype.setReadOnly.call(this, $isReadOnly);
    },
    
    render: function(){
        this.$maxLength = this.$field.$maxLength || this.$field.$maxByteLength;
        this.$capabilities = this.$capabilities || resUtil.parseCapabilities(this.$field.$capabilities);
        lazyInit(jQuery);
        debug && console.log('htmlEditor.render ' + this.id);
        var self = this;
        var id = helpers.uuid.generate();
        self.$$dataValue.attr("id", self.id + "-data");
        if (this.isEditable()) {
            // self.standalone = this.boxParent && this.boxParent.$prototype && (this.boxParent.$prototype.$baseUrl === "/sdata/x3stb/erp/stubs");
            this.$$caret = $("<div>").attr("id", id + "-caret").attr("style", "display:none;").appendTo(self.$$dataValue);
            
            // var css = ((this.$item.$css) ? this.$item.$css + " " : "") + this.$skinInput;
            // this.$$input = $('<textarea>').attr('id', "i" + id).attr('name', "i" + id).addClass(css).appendTo(self.$$fieldValue);
            var $$area = $('<textarea>').attr('id', "html-editor-" + id).attr('name', "html-editor-" + id).attr("data-s-field", id).appendTo($(self.fieldValue));
            this.$item.$rows && $$area.attr("rows", this.$item.$rows);
            
            self._editor = $$area.cleditor({
                resizeSelector: self.resizeSelector = "resize." + helpers.uuid.generate(),
                // width not including margins, borders or padding
                // width: self.$item.$textWidth || "100%",
                width: self.$item.$textWidth || "auto",
                // height not including margins, borders or padding
                // height: self.$item.$textHeight || 480,
                height: self.$item.$textHeight || "auto",
                controls: "bold italic underline strikethrough subscript superscript | font size | color" //
 +
                " highlight removeformat | bullets" /*+" numbering"*/ +
                " | outdent indent alignleft center alignright justify" //
 +
                " | undo redo | rule image link unlink" //
 +
                " | cut copy paste pastetext" //
 +
                " | print source rawMode",
                // style to assign to document body contained within the editor
                // bodyStyle: "margin:4px; font:10pt Arial,Verdana; cursor:text"
                bodyStyle: "",
                // sizes in the font size popup
                sizes: fontSizes,
                useCSS: true,
                // _field: self,
                _rawAllowed: function(){
                    return self._rawAllowed()
                },
                _isRaw: function(){
                    return self._rawAllowed() && self._isRaw;
                },
                _setRaw: function(v){
                    if (self._rawAllowed()) 
                        self._isRaw = v;
                },
                // Handlers
                updateFrame: function(html){
                    // TODO: cleanup HTML if necessary
                    debug && console.log('htmlEditor.editor.updateFrame:\n' + html);
                    return html;
                },
                updateTextArea: function(html){
                    debug && console.log('htmlEditor.editor.updateTextArea:\n' + html);
                    return html;
                }
            })[0];
            
            setTimeout(function(){
                self._finalizeCreate();
            }, 200);
        }
    },
    
    _isRtfMimeType: function(){
        return this.$field.$type == "text/rtf";
    },
    
    _finalizeCreate: function(){
        debug && console.log('htmlEditor._finalizeCreate ' + this.id);
        this.setState(this.$field);
        this._refreshToolbar();
        this._editor.refresh();
        
        // Intercept paste event to get the opportunity of sanitizing the contents
        var $$input = $(this._editor.doc.body);
        
        this._isRtfMimeType() &&
        $$input.bind('paste', function(e){
            // this code corrupts the undo stack!!!
            var pastedText = undefined;
            if (e && e.clipboardData && e.clipboardData.getData) {
                if (/text\/html/.test(e.clipboardData.types)) {
                    pastedText = e.clipboardData.getData('text/html');
                }
                else 
                    if (/text\/plain/.test(e.clipboardData.types)) {
                        pastedText = e.clipboardData.getData('text/plain');
                    }
                    else {
                        pastedText = "";
                    }
            }
            else 
                if (window.clipboardData && window.clipboardData.getData) { // IE
                    pastedText = window.clipboardData.getData('Text');
                }
                else {
                    var el = $(this);
                    // Hiding the underlying element causes some unpredictable behavior
                    // var display;
                    // $.browser.mozilla && (display = el.css('display')) && el.css('display', 'none');
                    setTimeout(function(){
                        var text = $(el).html();
                        if (text) {
                            $(el).html(sanitize(text));
                        }
                        // display && el.css('display', display);
                        debug && console.log("htmlEditor..paste after timeout:\n" + text);
                    }, 300);
                }
            if (pastedText) {
                $(this).html(sanitize(pastedText));
                e.preventDefault();
                e.stopPropagation();
            }
            
            // debug && console.log("htmlEditor..paste:\n" + pastedText);
        });
        
        this._bindInput(true);
    },
    _refreshToolbar: function(){
        // hack to refresh the toolbar state and disable the toolbar buttons if necessary
        this.isEditable() && this._editor.disable(this._editor.disabled);
    },
    
    _bindInput: function(bind){
        if (this._editor == null) 
            return;
        
        var self = this;
        debug && console.log("htmlEditor._bindInput " + this.id);
        var doc = this._editor.doc, $$doc = $(doc), $$input = $(doc.body), contentWindow = this._editor.$frame[0].contentWindow, $$inputWindow = $.browser.mozilla ? $$doc : $(contentWindow);
        
        if (bind) {
            $$input //
.on("change keydown keypress keyup focusin focusout", function(event){
                debug && console.log("htmlEditor.bindInputEvent $$input: " + event.type);
                self.onFieldInputEvent(event);
                event.stopPropagation();
            }) //
            // .on("click", function(event) {
            // 	self.onClickPicker($(this));
            // 	return false;
            // }) //
            ;
            $$inputWindow //
.on("click", function(event){
                debug && console.log("htmlEditor.bindInputEvent click --> click");
                self.onFieldInputEvent(event);
                event.stopPropagation();
            }) //
.focus(function(event){
                debug && console.log("htmlEditor.bindInputEvent focus --> focusin");
                $$input.trigger("focusin");
                self._editor.$main.addClass("cleditorMain-focus");
                event.stopPropagation();
            }) //
.blur(function(event){
                debug && console.log("htmlEditor.bindInputEvent blur --> focusout");
                debug && console.log("\tCaret position: " + self.getCaretPosition());
                self._editor.$main.removeClass("cleditorMain-focus");
                
                if (self.isDirty()) {
                    $$input.trigger("change");
                }
                $$input.trigger("focusout");
                event.stopPropagation();
            }) //
;
        }
        else {
            $$input.off();
            $$inputWindow.off();
        }
    },
    
    _rawAllowed: function(){
        return this._isRtfMimeType() && this.$capabilities && this.$capabilities.raw;
    },
    
    _setRawEditContents: function(contents){
        if (this.isEditable() && this._editor && this._editor.$area) {
            debug && console.log('htmlEditor._setRawEditContents:\n' + contents);
            this._editor.$area.val(contents || '');
            this._editor.updateFrame();
        }
    },
    
    _getRawEditContents: function(){
        return (this.isEditable() && this._editor && this._editor.$area && this._editor.$area.val()) || '';
    },
    
    _setContents: function(contents, saveStyles){
        debug && console.log('htmlEditor._setContents 1: isEditable()=' + this.isEditable() + '\n' + contents);
        
        this._isRaw = false;
        if (!contents || contents.length === 0) {
            // No contents, assume we want to edit Rich Text or HTML
        }
        else {
            switch (this.$field.$type) {
                case "text/rtf":
                    if (contents.match(/^\s*{\\rtf/)) {
                        // debug && console.log('htmlEditor._setContents toHtml 1:\n' + contents);
                        contents = rtf.toHtml(contents);
                    // debug && console.log('htmlEditor._setContents toHtml 2:\n' + contents);
                    }
                    else 
                        if (this._rawAllowed()) {
                            this._isRaw = true;
                            if (!contents.match(/<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i)) {
                                // Not an HTML contents, so wrap it in <pre> tag
                                contents = "<pre>" + contents + "</pre>";
                            }
                        }
                    break;
                case "text/html":
                    // contents as is
                    break;
            }
        }
        debug && console.log('htmlEditor._setContents 2: _isRaw=' + this._isRaw + '\n' + contents);
        
        
        if (saveStyles && contents) {
            this.$$savedStyles = $(contents).find('style');
        }
        if (this.isEditable()) {
            this._setRawEditContents(contents);
        }
        else {
            document.site.emptyDom(this.fieldValue);
            this.fieldValue.innnerHTML = contents;
        }
    },
    
    _getPersistentContents: function(contents){
        if (!this.isEditable()) 
            return null;
        
        if (contents === undefined) {
            contents = this._editor.$area.val();
        }
        var hash = checksum(contents);
        if (hash === this._cache.checksum) 
            return this._cache.value;
        
        this._cache.checksum = hash;
        
        if (this.$$savedStyles) {
            var $$contents = $('<div>').append(contents);
            if ($$contents.find('style').length === 0) {
                $$contents.prepend(this.$$savedStyles);
                contents = $$contents.html();
            }
        }
        if (this._isRaw) {
            var outer = $(contents);
            if (outer.is('pre')) 
                contents = normalizeRawText(outer.html());
            debug && console.log('htmlEditor._getPersistentContents raw:\n' + contents);
        }
        else {
            debug && console.log('htmlEditor._getPersistentContents:\n' + contents);
            if (this._isRtfMimeType()) {
                contents = rtf.fromHtml(contents);
                debug && console.log('htmlEditor._getPersistentContents from Html:\n' + contents);
            }
        }
        return this._cache.value = contents;
    },
    
    dispose: function(){
        debug && console.log('htmlEditor.dispose ' + this.id);
        debugger;
        if (this.resizeSelector) {
            $(window).unbind(this.resizeSelector);
        }
        this._bindInput(false);
        if (this._editor) {
            this._editor.dispose();
            delete this._editor;
        }
        Field.prototype.dispose.call(this);
    }
    
});
