"use strict";
var helpers = require('syracuse-core/lib/helpers');
var resUtil = require('syracuse-core/lib/resource/util');
var locale = require('syracuse-core/lib/locale');
var Field = require('syracuse-ui/lib/field/field').Field;
var rtf = require("syracuse-rtf");
var _keyboardHandlers = require('syracuse-ui/lib/events/keyboardHandlers');

var _fontSizes = "8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,72";
var _htmlStyles = [
	["paragraph", "<p>"],
	["h4", "<h4>"],
	["h5", "<h5>"]
];
var _extendColors = ["BF7F00", "7F0000"];
var _localize = {};
var _styles = {};

function _normalizeRawText(text) {
	return text.replace(/&nbsp;/gi, " ").replace(/<br\s*[\/]?>/gi, "\r\n").replace(/<p>/gi, "\r\n");
}

function _fixHtml(html) {
	return html.replace(/<br\s*[\/]?>$/gi, "").replace(/<p><\/p>/gi, "<br>");
}

// use html sanitizer from https://github.com/google/googlecrisismap/blob/master/aux/html-css-sanitizer.js
function sanitize(html) {
	return rtf.toHtml(rtf.fromHtml(sanitizeHtml(html)));
}

function sanitizeHtml(html) {
	return html_sanitize(html, uriRewriter);
}

function uriRewriter(uri) {
	return uri;
}

function escapeHtml(str) {
	var div = document.createElement('div');
	div.appendChild(document.createTextNode(str));
	return div.innerHTML;
}

function safeSetHtml(editor, html) {
	if (html && html.indexOf("<") !== -1)
		html = escapeHtml(html);
	editor.doc.body.innerHTML = html;
}

// checksum - returns a checksum using the Adler-32 method

function _checksum(text) {
	var a = 1,
		b = 0;
	for (var index = 0; index < text.length; ++index) {
		a = (a + text.charCodeAt(index)) % 65521;
		b = (b + a) % 65521;
	}
	return (b << 16) | a;
	// return md5(text);
}

function _setButtonMode(button, isRaw) {
	button.title = isRaw ? _localize.richMode : _localize.rawMode;
	syra_dom.toggleClass(button, "buttonRichText", !isRaw);
	syra_dom.toggleClass(button, "buttonRawText", isRaw);
}

function _setColorTitle(popup) {
	$(popup).children(":not([title]), [title='']").attr("title", function() {
		var toHex = function(n) {
			n = parseInt(n, 10);
			return ("00" + n.toString(16)).slice(-2);
		};
		var re = new RegExp("\\d+\,\\s+\\d+\,\\s+\\d+");
		var c = re.exec($(this).css("backgroundColor"))[0].split(",");
		return "#" + toHex(c[0]) + toHex(c[1]) + toHex(c[2]);
	});
}

function _getSelection(editor) {
	// supported by all browsers including ie9
	var elt = editor.sourceMode() ? document : editor.$frame[0].contentWindow,
		sel;
	if (elt && elt.getSelection) {
		sel = elt.getSelection();
	}
	if (!sel && elt.selection)
		sel = elt.selection.createRange();
	return sel;
}

var _buttons = {
	rawMode: function($buttons) {
		var messageBox = syra_diagnose.box.show({
			$type: "warning",
			$buttons: "yesno",
			$title: _localize.aboutToSwitchToRawTitle,
			$message: _localize.aboutToSwitchToRawConfirm,
			$minWidth: "380" //px
		}, true);
		// adding data-s-id attribute
		var menus = Object.keys(messageBox.menuItems);
		for (var ii = 0, jj = menus.length; ii < jj; ii++) {
			var menuItem = messageBox.menuItems[menus[ii]];
			menuItem[0].domItem.setAttribute("data-s-id", menuItem[0].$title);
		}
		// get msgbox raw content
		var popup = messageBox.domItem.outerHTML;
		syra_diagnose.box.close();
		$buttons.rawMode = {
			name: "rawMode",
			title: _localize.rawMode,
			popupName: "rawMode",
			popupClass: "cleditorPrompt",
			popupContent: popup,
			getEnabled: function(data) {
				var rawAllowed = data.editor.options._field.isRawAllowed;
				var isRaw = rawAllowed && data.editor.options._isRaw();
				_setButtonMode(data.button, isRaw);
				return rawAllowed;
			},
			buttonClick: function(e, data) {
				var button = e.target;
				var editor = data.editor;
				var field = ((editor || {}).options || {})._field;
				var $$popup = $(data.popup),
					html;
				if (editor.options._isRaw()) {
					editor.options._setRaw(false);
					html = syra_dom.textToHTML(_fixHtml(editor.$area.val()));
					var $$content = $(html);
					if ($$content.is('pre')) {
						html = $$content.html();
					}
					safeSetHtml(editor, html);
					editor.options._setRaw(false);
					_setButtonMode(button, false);
					editor.updateTextArea();
					editor.focus();
					return false;
				}

				$$popup.css("padding", "0");
				// Wire up the submit button click event handler
				$$popup.find(".s-msgbox-buttons-link").unbind("click").bind("click", function(event) {
					event.preventDefault();
					if ($(this).attr('data-s-id') === syra_local.msgbox_yes) {
						if (!editor.options._isRaw()) {
							// use text function instead of html function to prevent xss attack
							var rawtext = _normalizeRawText(editor.doc.body.textContent),
								$$pre = $('<pre>').appendTo('<div>').text(rawtext);
							editor.$area.val($$pre.parent().html());
							editor.options._setRaw(true);
							_setButtonMode(button, true);
						}
						editor.updateFrame();
						_disable(field, editor.disabled);
					}
					editor.hidePopups();
					editor.focus();
				});
			}
		};
	},
	size: function($buttons) {
		$buttons.size.buttonClick = function(e, data) {
			var range = _getSelection(data.editor);
			var fs = _getStyle(range && range.anchorNode, "font-size");
			if (parseInt(fs, 0) > 0) {
				fs = fs.replace("pt", "");
				for (var ii = 0, jj = data.popup.children[0].length; ii < jj; ii++) {
					if (data.popup.children[0][ii].value == fs) {
						data.popup.children[0][ii].selected = true;
						break;
					}
				}
			}
		};
		var list = document.createElement("select");
		list.setAttribute("size", "8");
		var sizes = _fontSizes.split(",");
		for (var ii = 0, jj = sizes.length; ii < jj; ii++) {
			list.appendChild(document.createElement("option")).textContent = sizes[ii];
		}
		var popup = document.createElement("div");
		popup.appendChild(list);
		$buttons.size.popupContent = $(popup).html();
		$buttons.size.popupClass = "cleditorList";
		$buttons.size.popupClick = function(e, data) {
			var range = _getSelection(data.editor);
			var styles = _getStyles(range && range.anchorNode);
			var props = Object.keys(styles);
			var ns = "";
			for (var ii = 0, jj = props.length; ii < jj; ii++) {
				if (props[ii] !== "font-size") {
					ns += " " + props[ii] + ": " + styles[props[ii]];
				}
			}
			var tagNames = _getTagNames(range && range.anchorNode);
			var tagS = "";
			var tagE = "";
			for (var ii = 0, jj = tagNames.length; ii < jj; ii++) {
				tagS += "<" + tagNames[ii] + ">";
				tagE += "</" + tagNames[ii] + ">";
			}
			data.command = "inserthtml";
			var sel = data.editor.selectedHTML();
			var divS = "";
			var divE = "";
			if (data.editor.$area.context.value === sel) {
				divS = "<div>";
				divE = "</div>";
			}
			data.value = divS + tagS + '<span style="font-size:' + e.target.value + 'pt;' + ns + '">' + data.editor.selectedHTML().replace(/font-size:[0-9. ]+p(t|x);*/g, '').replace(/<span style=""><\/span>/g, '').replace(/<p><\/p>/gi, "").replace(/<div><div>/gi, "<div>").replace(/<\/div><\/div>/gi, "<\/div>") + '</span>' + tagE + divE;
			return true;
		};
	},
	color: function($buttons) {
		$buttons.color.buttonClick = function(e, data) {
			_setColorTitle(data.popup);
		};
		$buttons.highlight.buttonClick = function(e, data) {
			_setColorTitle(data.popup);
		};
	},
	link: function($buttons) {
		$buttons.link.buttonClick = function(e, data) {
			var $$focusNode = $(_getSelection(data.editor).focusNode);
			var href = $$focusNode.closest("a").attr("href") || $$focusNode.find("a").attr("href");
			if (href && href != "") {
				$(data.popup).find(":text").val(href);
			}
		};
	},
	insertTable: function($buttons) {
		$buttons.insertTable = {
			name: "insertTable",
			title: _localize.insertTable,
			popupName: "insertTable",
			getEnabled: function(data) {
				syra_dom.toggleClass(data.button, "buttonInsertTable", true);
				return !data.editor.options.isRtfMimeType;
			},
			buttonClick: function(e, data) {
				syra_site.closePopups();
				var editor = data.editor;
				editor.focus();
				var range;
				try {
					var sel = _getSelection(editor);
					range = sel && sel.getRangeAt(0);
				} catch (e) {}
				syra_dlg.openPopup(syra_site.page, {
					$itemPage: {
						$isEditMode: true,
						$facet: "$edit",
						$representation: {
							$prototype: {
								$properties: {
									$rows: {
										$type: "application/x-integer",
										$title: _localize.tableRows,
										$maxLength: 5
									},
									$columns: {
										$type: "application/x-integer",
										$title: _localize.tableCol,
										$maxLength: 5
									},
									$borderSize: {
										$type: "application/x-integer",
										$title: _localize.tableBorderSize,
										$maxLength: 5
									},
									$withHeader: {
										$type: "application/x-boolean",
										$title: _localize.tableWithHeader
									}
								},
								$links: {}
							},
							$article: {
								$title: _localize.tableTitle,
								$category: "section",
								$layout: {
									$items: [{
										$layoutType: "stack",
										$items: [{
											$layoutType: "row",
											$items: [{
												$bind: "$rows",
											}, {
												$bind: "$columns"
											}]
										}, {
											$layoutType: "row",
											$items: [{
												$bind: "$borderSize",
											}, {
												$bind: "$withHeader"
											}]
										}]
									}]
								}
							}
						}
					},
					onValidate: function(page) {
						syra_workingCopy.validateAllInputs(page);
						if (page.dataset && Object.keys(page.dataset).length > 0) {
							var rows = parseInt(page.dataset.$rows, 10),
								cols = parseInt(page.dataset.$columns, 10),
								border = parseInt(page.dataset.$borderSize, 10),
								header = page.dataset.$withHeader,
								i, j;
							var html = '<div><table cellspacing="1" cellpadding="1" border="' + (border || 0) + '">';
							if (header) {
								html += '<thead><tr>';
								for (j = 0; j < cols; j++) {
									html += '<th><br></th>';
								}
								html += '</tr></thead>';
							}

							html += '<tbody>';
							for (i = 0; i < rows; i++) {
								html += '<tr>';
								for (j = 0; j < cols; j++) {
									html += '<td><br></td>';
								}
								html += '</tr>';
							}
							html += '</tbody>';
							html += '</table></div>';
							editor.execCommand("inserthtml", html, null, data.button);
						}
						editor.focus();
					},
					position: {
						my: "left bottom",
						at: "right top",
						of: $(e.target)
					}
				});
				return false;
			}
		};
	},
	extendSize: function($buttons) {
		$buttons.extendSize = {
			name: "extendSize",
			title: _localize.extendSize,
			getEnabled: function(data) {
				syra_dom.toggleClass(data.button, "buttonExtendSize", true);
				return true;
			},
			buttonClick: function(e, data) {
				var heightList = ["auto", "400px", "600px", "800px"];
				var editor = data.editor;
				editor.$heightIndex = ((editor.$heightIndex || 0) + 1) % heightList.length;
				editor.options.height = heightList[editor.$heightIndex];
				var page = editor.options._field.page;
				page && page.dialogWrapper && page.dialogWrapper.resizeDialog();
				_refreshEditor(editor.options._field);
				editor.options._field.onFieldInputEvent(e);
				return false;
			}
		};
	},
	misc: function($buttons) {
		var ids = ("bold italic underline strikethrough subscript superscript font size style " + //
			"color highlight bullets numbering outdent indent alignleft center alignright " + //
			"justify rule image link unlink removeformat source").split(" ");
		for (var ii = 0, jj = ids.length; ii < jj; ii++) {
			var btn = $buttons[ids[ii]];
			if (btn) {
				btn.getEnabled = function(data) {
					var rawAllowed = data.editor.options._field.isRawAllowed;
					return !(rawAllowed && data.editor.options._isRaw());
				};
			}
		}
		$buttons.style.getEnabled = function(data) {
			return !data.editor.options.isRtfMimeType;
		};
		$buttons.image.getEnabled = function(data) {
			return !data.editor.options.isRtfMimeType;
		};
		$buttons.link.getEnabled = function(data) {
			return !data.editor.options.isRtfMimeType;
		};
		$buttons.unlink.getEnabled = function(data) {
			return !data.editor.options.isRtfMimeType;
		};
		$buttons.rule.getEnabled = function(data) {
			return !data.editor.options.isRtfMimeType;
		};
		$buttons.superscript.getEnabled = function(data) {
			return !data.editor.options.isRtfMimeType;
		};
		$buttons.subscript.getEnabled = function(data) {
			return !data.editor.options.isRtfMimeType;
		};
	}
};

var _content = {
	set: function(field, contents, saveStyles) {
		field._isRaw = false;
		if (!contents || contents.length === 0) {
			// No contents, assume we want to edit Rich Text or HTML
		} else {
			switch (field.$field.$type) {
				case "text/rtf":
					if (contents.match(/^\s*{\\(u|)rtf/)) {
						contents = rtf.toHtml(contents);
					} else
					if (field.isRawAllowed) {
						field._isRaw = true;
						if (!contents.match(/<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i)) {
							// Not an HTML contents, so wrap it in <pre> tag
							contents = "<pre>" + contents + "</pre>";
						}
					} else {
						syra_diagnose.showDiagnoses({
							$diagnoses: [{
								$message: locale.format(_localize.errorRtfExpected, contents),
								$severity: "error"
							}, {
								$message: _localize.warnContentsNotSet,
								$severity: "warning"
							}]
						}, field);
						return;
					}
					break;
				case "text/html":
					// contents as is
					break;
			}
		}
		if (saveStyles && contents) {
			field.$$savedStyles = $("<div>").append(contents).find('style');
		}
		_content.setRawEdit(field._editor, contents);
		!field.$isEditMode && _disable(field);

	},
	getRawEdit: function(editor) {
		if (editor && editor.doc) {
			if (editor.doc.body) {
				return _fixHtml(editor.doc.body.innerHTML || "");
			} else {
				if (editor.$area) {
					// iframe is not yet created so return the textarea content
					return _fixHtml(editor.$area[0].innerHTML || "");
				}
			}
		}
	},
	setRawEdit: function(editor, contents) {
		if (editor && editor.$area) {
			editor.$area.val(contents || '');
			editor.updateFrame();
		}
	},
	getPersistent: function(field, contents) {
		if (!field.$isEditMode)
			return null;

		if (contents === undefined) {
			contents = _content.getRawEdit(field._editor);
		}
		if (contents === undefined) {
			return null;
		}
		var hash = _checksum(contents);
		if (hash === field._cache.checksum)
			return field._cache.value;
		field._cache.raw = contents;
		field._cache.checksum = hash;

		if (field.$$savedStyles) {
			var $$contents = $('<div>').append(contents);
			if ($$contents.find('style').length === 0) {
				$$contents.prepend(field.$$savedStyles);
				contents = $$contents.html();
			}
		}
		if (field._isRaw) {
			if (contents.indexOf('<pre>') == 0) {
				contents = _normalizeRawText(contents);
				if (contents.indexOf('<pre>') != 0) {
					var preElement = document.createElement('pre');
					preElement.innerHTML = contents;
					contents = preElement.outerHTML;
				}
			} else {
				var preElement = document.createElement('pre');
				preElement.innerHTML = contents;
				contents = _normalizeRawText(preElement.outerHTML);
			}
		} else {
			if (field.isRtfMimeType) {
				contents = (contents || "").length === 0 ? "" : rtf.fromHtml(contents);
			}
		}
		field._cache.value = contents;
		return contents;
	}

};

function _refreshEditor(field) {
	var editor = field._editor;
	if (editor && editor.$frame) {
		editor.refresh();
		_fitToContent(field);
		field.bindEvent && _bindInput(field, true);
	}
}

function _fitToContent(field) {
	var editor = field._editor;
	var frame = editor && editor.$frame && editor.$frame[0];
	if (frame) {
		var childDoc = frame && frame.contentWindow && frame.contentWindow.document;
		if (childDoc) {
			frame.style.width = "100%";
			var height = (childDoc.body.scrollHeight) + 17 + "px"; //40 is security margin for iframe
			frame.style[field.$isEditMode ? "minHeight" : "height"] = height;
		}
	}
}


function _disable(field, disabled) {
	var editor = field._editor;
	editor && editor.doc && editor.disable(field.$isReadOnly || !field.$isEditMode || disabled);
	if (editor.disabled && !field.$isEditMode)
		editor.$toolbar.hide();
}

function _bindInput(field, bind) {
	field.bindEvent = bind;
	if (!(field._editor && field._editor.doc)) {
		return;
	}
	var doc = field._editor.doc,
		$$doc = $(doc),
		$$input = $(doc.body),
		contentWindow = field._editor.$frame[0].contentWindow,
		$$inputWindow = syra_site.getBrowserIdentity().isFireFox ? $$doc : $(contentWindow);
	if (bind) {
		$$input.on("change focusin focusout", function(event) {
			field.onFieldInputEvent(event);
			event.stopPropagation();
		});
		$$input.on("keydown keypress keyup", function(event) {
			if (_keyboardHandlers[event.type]) {
				if (!(event.type == "keypress" && _keyboardHandlers.keyCodeMap[event.keyCode] == "enter")) {
					_keyboardHandlers[event.type](event, field);
				}
			} else {
				field.onFieldInputEvent(event);
			}
			event.stopPropagation();
		});
		$$inputWindow.on("click", function(event) {
			field.onFieldInputEvent(event);
			event.stopPropagation();
		});
		$$inputWindow.focus(function(event) {
			$$input.trigger("focusin");
			event.stopPropagation();
		});
		$$inputWindow.blur(function(event) {
			if (field.isDirty(syra_site.getBrowserIdentity().isMSIE)) {
				$$input.trigger("change");
			}
			$$input.trigger("focusout");
			event.stopPropagation();
		});
	} else {
		$$input.off();
		$$inputWindow.off();
	}
}

function _setLazyUrl(field, value) {
	field.$lazyUrl = syra_expression.parse(field.articleParent, value && value.$url || field.$field.$url);
}


function _finalizeCreate(field) {
	field.setState(field.$field);
	field.$isEditMode && _disable(field, field._editor.disabled);
	if (field.$valueStyle)
		field._editor.options.bodyStyle = field.$valueStyle;
	_refreshEditor(field);

	// Intercept paste event to get the opportunity of sanitizing the contents
	field.isRtfMimeType &&
		$(field._editor.doc.body).bind('paste', function(e) {
			// this code corrupts the undo stack!!!
			var pastedText;
			if (e && e.clipboardData && e.clipboardData.getData) {
				if (/text\/html/.test(e.clipboardData.types)) {
					pastedText = e.clipboardData.getData('text/html');
				} else
				if (/text\/plain/.test(e.clipboardData.types)) {
					pastedText = e.clipboardData.getData('text/plain');
				} else {
					pastedText = "";
				}
			} else
			if (window.clipboardData && window.clipboardData.getData) { // IE
				pastedText = window.clipboardData.getData('Text');
			} else {
				var el = $(this);
				// Hiding the underlying element causes some unpredictable behavior
				setTimeout(function() {
					var text = $(el).html();
					if (text) {
						$(el).html(sanitize(text));
					}
					// display && el.css('display', display);
				}, 300);
			}
			if (pastedText) {
				$(this).html(sanitize(pastedText));
				e.preventDefault();
				e.stopPropagation();
			}

		});

	_bindInput(field, true);
}

function _getStyle(node, styleProp) {
	// do not use window.getComputedStyle because it returns font-size in px instead of pt
	while (node && (node.nodeType != Node.ELEMENT_NODE || node.style[styleProp] == null)) {
		node = node.parentNode;
	}
	return node && node.style[styleProp];
}

function _getStyles(node) {
	_styles = {};
	_getStylesFromNode(node);
	return _styles;
}

function _getStylesFromNode(node) {

	// do not use window.getComputedStyle because it returns font-size in px instead of pt
	while (node && node.nodeType != Node.ELEMENT_NODE) {
		node = node.parentNode;
	}
	var styles = "";
	if (node && node.style) {
		var styleProp;
		for (var ii = 0, jj = node.style.length; ii < jj; ii++) {
			if (node.style[ii] != "") {
				styleProp = node.style[ii];
				_styles[styleProp] = node.style[styleProp];
			}
		}
	}
}

function _getTagNames(node) {
	var tagNames = [];
	while (node && node.parentNode) {
		if (node.tagName) {
			if (node.tagName === "SPAN") break;
			tagNames.push(node.tagName);
		}
		node = node.parentNode;
	}
	return tagNames;
}

function HtmlEditor() {}

exports.HtmlEditor = helpers.defineClass(HtmlEditor, Field, {
	loadBox: function(initData) {
		var self = this;
		syra_site.loadStyleSheet("cleditor/jquery.cleditor.css");
		require.async('syracuse-ui/deps/cleditor/jquery.cleditor', function(err, module) {
			Field.prototype.loadBox.call(self, initData);
			if (self.page && self.page.dialogWrapper) {
				self.page.resizeArticle();
			} else {
				self.resizeArticle();
			}
			syra_quality.page_endChange(self.page);
		});
	},
	initialize: function() {
		this.isRtfMimeType = this.$field.$type == "text/rtf";
		this.$item.$isTopLabelAlignment = true;
		this.$item.$isAutoSizeDisabled = true;
		this.$item.$isAutoSize = true;
		this._cache = {};
	},
	resizeArticle: function() {
		if (!this.disposed && syra_dom.isVisible(this.domItem)) {
			if (!this.isCreated) {
				this.isCreated = true;
				_finalizeCreate(this);
				if (this._isFocusRequested) {
					this._editor.focus();
					delete this._isFocusRequested;
				}
			}
			_refreshEditor(this);
		}
	},
	highlightOnFocus: function(on, event) {
		Field.prototype.highlightOnFocus.call(this, on, event);
		on && this._setInputFocus();
	},
	setDataValue: function(value) {
		var self = this;
		_setLazyUrl(this, value);
		if (this.$lazyUrl && value && typeof(value) === 'object') {
			// lazy loading
			self.$contentType = value.$contentType || (this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type);
			syra_controller.callServer(null, {
				$location: {
					$url: self.$lazyUrl,
					$contentType: self.$contentType,
					$type: self.$contentType
				}
			}, function(data, response) {
				if (typeof(data) === 'string') {
					self.setDataValue(data);
				} else {
					self.showErrors([locale.format(syra_local.fieldBadDataType, "string", typeof(data))]);
				}
			}, function(error) {
				self.showErrors([error.message]);
			});
		} else {
			try {
				if (this.currentValue != value) {
					_content.set(this, value, true);
					if (this.$isEditMode) {
						this.currentValue = _content.getPersistent(this);
					} else {
						this.currentValue = value;
						_fitToContent(this);
					}
					if (!this.dirty()) {
						this._cache.dirtyChecksum = this._cache.checksum;
					}
				}
			} catch (error) {
				this.showErrors([error.message]);
			}
			this.$isEditMode && _disable(this, this._editor.disabled);
		}
	},
	getInputValue: function() {
		if (this.$isEditMode && this._editor && this._editor.$area) {
			return _content.getPersistent(this);
		}
		return "";
	},
	isDirty: function(dontHidePopup) {
		// Get the current content to compute the checksum
		if (this._editor && !dontHidePopup) {
			this._editor.hidePopups();
		}
		var value = _content.getPersistent(this),
			dirty = (this._cache.dirtyChecksum != this._cache.checksum);
		return dirty;
	},
	setDirty: function(dirty) {
		if (!dirty) {
			var contents = _content.getPersistent(this); // to compute checksum;
			this._cache.dirtyChecksum = this._cache.checksum;
			this.$isEditMode && !this._isRaw && _content.setRawEdit(this._editor, rtf.toHtml(contents));
		}
		this.dirty(dirty);
	},
	dirty: function(set) {
		if (set !== undefined) {
			this._isDirty = set;
		} else
			return this._isDirty;
	},
	validateInput: function(errors, value) {
		if (this.currentValue && this.$maxLength && this.currentValue.length > this.$maxLength) {
			errors.push(locale.format(_localize.errorMaxLength, this.$maxLength));
		}
	},
	//TODO :
	//A revoir : pourquoi un url particulieret ne pas traiter les datas editeur lazyload comme n'importe qu'elle autre
	notifyFieldChange: function(newValue, validated) {
		_setLazyUrl(this);
		this.currentValue = newValue;
		if (this.$lazyUrl) {
			if (this.page.isServerNotifyDisabled) {
				this.setDatasetValue(newValue);
			} else {
				syra_controller.callServer(null, {
					$location: {
						$url: this.$lazyUrl,
						$contentType: this.$contentType,
						$type: this.$contentType
					},
					data: newValue,
					method: "PUT"
				}, function(data, response, requestUrl) {});
			}
			return false; //disable default notifyFieldChange
		}
		return true;
	},
	_setInputFocus: function(select) {
		if (this.$isEditMode && this._editor) {
			if (!this.isCreated) {
				this._isFocusRequested = true;
			} else {
				this._editor.focus();
				return true;
			}
		}
	},
	getCaretPosition: function() {
		if (!(this.$isEditMode && ((this._editor || {}).doc || {}).body && this._caret)) {
			return -1;
		}
		var sel = _getSelection(this._editor),
			caretPos, range, contents;
		try {
			range = this._editor.doc.createRange();
			range.setStart(this._editor.doc.body, 0);
			sel.focusNode && range.setEnd(sel.focusNode, sel.focusOffset);
			contents = range.cloneContents();
		} catch (e) {
			return -1;
		}
		if (contents) {
			$(this._caret).append(contents);
			this._caret.innerHTML = this._caret.innerHTML.replace(/<br\s*[\/]?>/gi, "\n");
			caretPos = this._caret.textContent.length;
			syra_dom.empty(this._caret);
		}
		return caretPos || 0;
	},
	setState: function(state) {
		if (state && state.$isDisabled !== undefined) {
			_disable(this, state.$isDisabled);
		}
		Field.prototype.setState.call(this, state);
	},
	_onSetReadOnly: function($isReadOnly) {
		_disable(this, $isReadOnly);
		Field.prototype._onSetReadOnly.call(this, $isReadOnly);
	},
	_createValueContainer: function() {
		this.domItem.className += " " + this._$cssField;
		this._core = this._dataValue = syra_dom.addDiv(this._$cssField + "-htmleditor-value", this.domItem);
	},
	render: function() {
		var self = this;
		self.$maxLength = self.$field.$maxLength || self.$field.$maxByteLength;
		self.hasRawCapability = self.$field.$capabilities && (self.$field.$capabilities.indexOf("raw") >= 0);
		self.isRawAllowed = self.isRtfMimeType && self.hasRawCapability;

		_setLazyUrl(self);
		self.$contentType = self.$field.$type === 'application/x-document' && self.$field.$contentType || self.$field.$type;

		self._dataValue.setAttribute("id", self.id + "-data");
		self._caret = document.createElement("div");
		self._caret.id = self.id + "-caret";
		syra_dom.hide(self._caret, true);
		self._dataValue.appendChild(self._caret);

		self.textArea = document.createElement("textarea");
		self.textArea.setAttribute("spellcheck", false);
		self.textArea.setAttribute("autocorrect", "off");
		self.textArea.setAttribute("name", self.textArea.id = "html-editor-" + self.id);
		self.textArea.syraItem = self.textArea.syrainout = self.id;
		self._dataValue.appendChild(self.textArea);

		self.$item.$rows && self.textArea.setAttribute("rows", self.$item.$rows);

		var $buttons = jQuery.cleditor.buttons;
		_localize = locale.resources(module)();
		var ids = Object.keys($buttons);
		for (var ii = 0, jj = ids.length; ii < jj; ii++) {
			var title = _localize[ids[ii]];
			if (title) {
				$buttons[ids[ii]].title = title;
			}
		}
		for (var ii = 0, jj = _htmlStyles.length; ii < jj; ii++) {
			var style = _htmlStyles[ii];
			style[0] = _localize[style[0]] || style[0];
		}
		var _colors = jQuery.cleditor.defaultOptions.colors + " " + _extendColors.join(" ");
		if (!$buttons.rawMode) {
			_buttons.rawMode($buttons);
			_buttons.insertTable($buttons);
			_buttons.link($buttons);
			_buttons.color($buttons);
			_buttons.size($buttons);
			_buttons.extendSize($buttons);
			_buttons.misc($buttons);
		}
		self._editor = $(self.textArea).cleditor({
			width: self.$item.$textWidth || "auto",
			height: self.$item.$textHeight || "auto",
			controls: "bold italic underline strikethrough subscript superscript | font size style | color" + //
			" highlight removeformat | bullets" + //
			// " numbering" +
			" | insertTable " + //
			" | outdent indent alignleft center alignright justify" + //
			" | undo redo | rule image link unlink" + //
			" | cut copy paste pastetext" + //
			// condition source feature to development mode to prevent xss attack
			" | print" + (syra_site.developpementMode ? " source" : "") + " rawMode " + //
			" | extendSize",
			colors: _colors,
			bodyStyle: /^(ar|iw|he)/.test(syra_site.userProfile.currentLangCode) ? "direction:rtl" : "",
			// sizes in the font size popup
			sizes: _fontSizes,
			styles: _htmlStyles,
			useCSS: true,
			isRtfMimeType: self.isRtfMimeType,
			_field: self,
			_isRaw: function() {
				return self.isRawAllowed && self._isRaw;
			},
			_setRaw: function(v) {
				if (self.isRawAllowed)
					self._isRaw = v;
			},
			_sanitizeHtml: sanitizeHtml,
			// Handlers
			updateFrame: function(html) {
				return sanitizeHtml(html);
			},
			updateTextArea: function(html) {
				html = sanitizeHtml(html);
				syra_workingCopy.notifyFieldChange(self, self.isRtfMimeType ? rtf.fromHtml(html) : html);
				return html;
			}
		})[0];

	},
	applyShortCut: function(shortcuts, event) {
		if (shortcuts.enter || shortcuts.backspace || shortcuts.down || shortcuts.up)
			return true;
		return false;
	},
	dispose: function() {
		if (this.resizeSelector) {
			$(window).unbind(this.resizeSelector);
		}
		_bindInput(this, false);
		if (this._editor) {
			this._editor.hidePopups();
			this._editor.dispose();
		}
		Field.prototype.dispose.call(this);
	}
});