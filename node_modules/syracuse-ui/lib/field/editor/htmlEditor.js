"use strict";
/// !doc
///
/// # Html editor widget that supports RFT conversion
///
/// `HtmlEditor` class subclasses the `Field` class
/// ```javascript
/// var htmlEditor = require('syracuse-ui/lib/field/editor/htmlEditor').HtmlEditor;
/// ```
///
var helpers = require('syracuse-core/lib/helpers');
var resUtil = require('syracuse-core/lib/resource/util');
var locale = require('syracuse-core/lib/locale');
var Field = require('syracuse-ui/lib/field/field').Field;
var rtf = require("syracuse-rtf");
// require('syracuse-ui/deps/cleditor/jquery.cleditor.min');
require('syracuse-ui/deps/cleditor/jquery.cleditor');

var debug = false;

var fontSizes = "8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,72";

var htmlStyles = [
	["paragraph", "<p>"],
	["h4", "<h4>"],
	["h5", "<h5>"]
];
var _extendColors = ["BF7F00", "7F0000"];
// Default values are the English one
var _localize = {};
var _styles = {};

function normalizeRawText(text) {
	return text.replace(/&nbsp;/gi, " ") //
	.replace(/<br\s*[\/]?>/gi, "\r\n") //
	.replace(/<p>/gi, "\r\n");
}

function fixHtml(html) {
	return html.replace(/<br\s*[\/]?>$/gi, "").replace(/<p><\/p>/gi, "").replace(/<p style="font-size: 11.2px;">/gi, '<p>');
}

function _fixEmptyPre(value) {
	return value.charCodeAt(0) == 1 ? value.substring(1) : value;
}

// use html sanitizer from https://github.com/google/googlecrisismap/blob/master/aux/html-css-sanitizer.js
function sanitize(html) {
	return rtf.toHtml(rtf.fromHtml(sanitizeHtml(html)));
}

function sanitizeHtml(html) {
	return html_sanitize(html, uriRewriter);
}

function uriRewriter(uri) {
	return uri;
}

// checksum - returns a checksum using the Adler-32 method
function checksum(text) {
	var a = 1,
		b = 0;
	for (var index = 0; index < text.length; ++index) {
		a = (a + text.charCodeAt(index)) % 65521;
		b = (b + a) % 65521;
	}
	return (b << 16) | a;
	// return md5(text);
}

function lazyInit($) {
	// var cleditor = require.async('syracuse-ui/deps/cleditor/jquery.cleditor', function(err, module){});
	var $buttons = $.cleditor.buttons;

	function localize() {
		helpers.object.forEachKey($buttons, function(key) {
			$buttons[key].title = _localize[key] || key + ":<undefined>";
		});
		if ($buttons.rawMode) {
			$buttons.rawMode.title = _localize.rawMode;
		}
		htmlStyles.forEach(function(style) {
			style[0] = _localize[style[0]] || style[0];
		});
	}
	_localize = locale.resources(module)();
	localize();
	if ($buttons.rawMode) {
		return;
	}
	$buttons.rawMode = {
		name: "rawMode",
		title: _localize.rawMode,
		popupName: "rawMode",
		popupClass: "cleditorPrompt",
		popupContent: document.createElement("div")
	};

	$buttons.rawMode.getEnabled = function(data) {
		var rawAllowed = data.editor.options._rawAllowed();
		if (rawAllowed && data.editor.options._isRaw()) {
			data.button.title = _localize.richMode;
			$(data.button).removeClass("buttonRichText").addClass("buttonRawText");
		} else {
			data.button.title = _localize.rawMode;
			$(data.button).removeClass("buttonRawText").addClass("buttonRichText");
		}
		return rawAllowed;
	};

	$buttons.rawMode.buttonClick = function(e, data) {
		var button = e.target,
			editor = data.editor,
			field = ((editor || {}).options || {})._field,
			html;

		if (editor.options._isRaw()) {
			editor.options._setRaw(false);

			// Fix HTML
			html = fixHtml(editor.$area.val());
			html = (html || "").replace(/\r\n/g, "<br/>").replace(/\n/g, "<br/>").replace(/<\/pre><pre>/gi, "<br/>").replace(/\s/g, "&nbsp;");
			var $$content = $(html);
			if ($$content.is('pre')) {
				html = $$content.html();
			}
			html = _fixEmptyPre(html);

			// SafeSetHtml
			if (html && html.indexOf("<") !== -1) {
				// EscapeHtml
				var div = document.createElement('div');
				div.appendChild(document.createTextNode(html));
				html = div.innerHTML;
			}
			editor.doc.body.innerHTML = _htmlUnescape(html);

			// Update widget
			editor.options._setRaw(false);
			button.title = _localize.rawMode;
			$(button).removeClass("buttonRawText").addClass("buttonRichText");
			editor.updateTextArea();
			editor.focus();
			return false;
		}
		syra_diagnose.showBox({
			$type: "warning",
			$buttons: "yesno",
			$title: _localize.aboutToSwitchToRawTitle,
			$message: _localize.aboutToSwitchToRawConfirm,
			callback: function(response) {
				if (response.$clientId === "yes") {
					if (!editor.options._isRaw()) {
						// Use text function instead of html function to prevent xss attack
						var rawtext = normalizeRawText(_editorHelpers.getEditorInnerText(editor.doc.body, editor.$frame[0].contentWindow)),
							$$pre = $('<pre>').appendTo('<div>').text(rawtext || String.fromCharCode(1));
						editor.$area.val($$pre.parent().html());

						editor.options._setRaw(true);
						button.title = _localize.richMode;
						$(button).removeClass("buttonRichText").addClass("buttonRawText");
					}
					editor.updateFrame();
					field._disable(editor.disabled);
				}
				editor.hidePopups();
				editor.focus();
			}
		});
		syra_site.dom.removeChild(data.popup);
		return true;
	};


	$buttons.insertTable = {
		name: "insertTable",
		title: _localize.insertTable,
		popupName: "insertTable"
	};

	$buttons.insertTable.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		$(data.button).addClass("buttonInsertTable");
		return field && !field._isRtfMimeType();
	};

	$buttons.insertTable.buttonClick = function(e, data) {
		syra_site.dialogManager.closePopups();
		var editor = data.editor;
		editor.focus();
		var range = _getRange(editor);

		syra_site.dialogManager.openPopup(syra_site.page, {
			$isAutoClose: true,
			$itemPage: {
				$isEditMode: true,
				$facet: "$edit",
				$representation: {
					$prototype: {
						$properties: {
							$rows: {
								$type: "application/x-integer",
								$title: _localize.tableRows,
								$maxLength: 5
							},
							$columns: {
								$type: "application/x-integer",
								$title: _localize.tableCol,
								$maxLength: 5
							},
							$borderSize: {
								$type: "application/x-integer",
								$title: _localize.tableBorderSize,
								$maxLength: 5
							},
							$withHeader: {
								$type: "application/x-boolean",
								$title: _localize.tableWithHeader
							}
						},
						$links: {}
					},
					$article: {
						$title: _localize.tableTitle,
						$category: "section",
						$layout: {
							$items: [{
								$layoutType: "stack",
								$items: [{
									$layoutType: "row",
									$autoSize: true,
									$items: [{
										$bind: "$rows",
									}, {
										$bind: "$columns"
									}]
								}, {
									$layoutType: "row",
									$autoSize: true,
									$items: [{
										$bind: "$borderSize",
									}, {
										$bind: "$withHeader"
									}]
								}]
							}]
						}
					}
				}
			},
			onValidate: function(page) {
				page.validateFields();
				if (page.dataset && Object.keys(page.dataset).length > 0) {
					var rows = parseInt(page.dataset.$rows, 10),
						cols = parseInt(page.dataset.$columns, 10),
						border = parseInt(page.dataset.$borderSize, 10),
						header = page.dataset.$withHeader,
						i, j;
					var html = '<div><table cellspacing="1" cellpadding="1" border="' + (border || 0) + '">';
					if (header) {
						html += '<thead><tr>';
						for (j = 0; j < cols; j++) {
							html += '<th><br></th>';
						}
						html += '</tr></thead>';
					}

					html += '<tbody>';
					for (i = 0; i < rows; i++) {
						html += '<tr>';
						for (j = 0; j < cols; j++) {
							html += '<td><br></td>';
						}
						html += '</tr>';
					}
					html += '</tbody>';
					html += '</table></div>';
					editor.execCommand("inserthtml", html, null, data.button);
				}
				editor.focus();
			},
			position: {
				my: "left bottom",
				at: "right top",
				of: $(e.target)
			}
		});
		return false;
	};
	$buttons.link.buttonClick = function(e, data) {
		var $popup = $(data.popup),
			$$focusNode = $(_getSelection(data.editor).focusNode),
			href = ($$focusNode.closest("a").attr("href") || $$focusNode.find("a").attr("href"));
		if (href && href != "") {
			$popup.find(":text").val(href);
		}
	};
	$buttons.color.buttonClick = function(e, data) {
		_setColorTitle(data.popup);
	};
	$buttons.highlight.buttonClick = function(e, data) {
		_setColorTitle(data.popup);
	};

	function _setColorTitle(popup) {
		$(popup).children(":not([title]), [title='']").attr("title", function() {
			var toHex = function(n) {
				n = parseInt(n, 10);
				return ("00" + n.toString(16)).slice(-2);
			};
			var re = new RegExp("\\d+\,\\s+\\d+\,\\s+\\d+");
			var c = re.exec($(this).css("backgroundColor"))[0].split(",");
			return "#" + toHex(c[0]) + toHex(c[1]) + toHex(c[2]);
		});
	}
	// 
	// font size button
	var $$popupContent = $('<div>'),
		$$list = $('<select>').attr('size', '8');
	$$popupContent.append($$list);
	$.each(fontSizes.split(","), function(i, size) {
		$('<option>').append(size).appendTo($$list);
		// $('<div>').append($('<span>').prepend(size)).appendTo($$popupContent);
	});

	$buttons.font.buttonClick = function(e, data) {
		var fs, range = _getSelection(data.editor);
		var highlight = "rgb(250, 0, 0)";
		try {
			fs = _getStyle(range && range.anchorNode, "font-Family");
			if (!fs) {
				fs = _getStyle(range && range.anchorNode, "fontFamily");
			}
			if (!fs) {
				fs = _getFontFace(range && range.anchorNode);
			}
		} catch (e) {
			fs = "";
		}
		fs = fs ? fs.replace(/"/g, "").replace(/'/g, "") : "";
		if (!fs) {
			fs = rtf.getDefaultFontFace();
		}
		for (var ii = 0, jj = data.popup.children.length; ii < jj; ii++) {
			if (data.popup.children[ii].innerHTML == fs) {
				$(data.popup.children[ii]).css("color", highlight);
			} else if ($(data.popup.children[ii]).css("color") == highlight) {
				$(data.popup.children[ii]).css("color", "white");
			}
		}
	};
	$buttons.size.popupContent = $$popupContent.html();
	$buttons.size.popupClass = "cleditorList";
	$buttons.size.buttonClick = function(e, data) {
		var range = _getSelection(data.editor);
		var fs = _getStyle(range && range.anchorNode, "font-size");
		if (!fs) {
			fs = rtf.getDefaultFontSize();
		}
		if (parseInt(fs, 0) > 0) {
			fs = fs.replace("pt", "");
			if (fs.indexOf(".") > 0) {
				fs = fs.substr(0, fs.indexOf("."));
			}
			for (var ii = 0, jj = data.popup.children[0].length; ii < jj; ii++) {
				if (data.popup.children[0][ii].value == fs) {
					data.popup.children[0][ii].selected = true;
					break;
				}
			}
		}
	};
	$buttons.size.popupClick = function(e, data) {
		var range = _getSelection(data.editor);
		var styles = _getStyles(range && range.anchorNode);
		var props = Object.keys(styles);
		var ns = "";
		for (var ii = 0, jj = props.length; ii < jj; ii++) {
			if (props[ii] !== "font-size") {
				ns += " " + props[ii] + ": " + styles[props[ii]];
			}
		}
		var tagNames = _getTagNames(range && range.anchorNode);
		var tagS = "";
		var tagE = "";
		for (var ii = 0, jj = tagNames.length; ii < jj; ii++) {
			tagS += "<" + tagNames[ii] + ">";
			tagE += "</" + tagNames[ii] + ">";
		}
		data.command = "inserthtml";
		var sel = data.editor.selectedHTML().replace(/\r\n/gi, "");
		var divS = "";
		var divE = "";
		var ev = data.editor.$area.context.value;
		if (ev.startsWith("<p></p>"))
			ev = ev.substring(7);
		if (ev.endsWith("<p></p>"))
			ev = ev.substring(0, ev.length - 7);
		if (ev === sel || sel.toLowerCase().startsWith("<p>")) {
			divS = "<div>";
			divE = "</div>";
		}
		sel = sel.replace(/font-size:[0-9. ]+p(t|x);*/g, '').replace(/\<span style=""\>([^\<]*)\<\/span\>/g, '$1').replace(/<p><\/p>/gi, "").replace(/<div><div>/gi, "<div>").replace(/<\/div><\/div>/gi, "<\/div>");
		data.value = divS + tagS + '<span style="font-size:' + e.target.value + 'pt;' + ns + '">' + sel + '</span>' + tagE + divE;
		return true;
	};

	// paste button
	// $buttons.paste.buttonClick = function(e, data) {
	//     data.editor.execCommand(data.command, data.value, data.useCSS, data.button);
	//     return false;
	// };
	var formattingbuttons = "bold italic underline strikethrough subscript superscript font size style " + //
	"color highlight bullets numbering outdent indent alignleft center alignright " + //
	"justify rule image link unlink removeformat source";
	$.each(formattingbuttons.split(" "), function(idx, buttonName) {
		if ($buttons[buttonName]) {
			$buttons[buttonName].getEnabled = function(data) {
				var rawAllowed = data.editor.options._rawAllowed();
				return !(rawAllowed && data.editor.options._isRaw());
			};
		}
	});

	var heightList = ["auto", "400px", "600px", "800px"];
	// Extend the size of the writing area.
	$buttons.extendSize = {
		name: "extendSize",
		title: _localize.extendSize,

		getEnabled: function(data) {
			$(data.button).addClass("buttonExtendSize");
			return true;
		},

		buttonClick: function(e, data) {
			var editor = data.editor;
			editor.$heightIndex = ((editor.$heightIndex || 0) + 1) % heightList.length;
			editor.options.height = heightList[editor.$heightIndex];
			var page = editor.options._field.page;
			page && page.dialogWrapper && page.dialogWrapper.resizeDialog();
			editor.options._field._refreshEditor();
			editor.options._field.onFieldInputEvent(e);
			return false;
		}
	};
	$buttons.style.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.image.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.link.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.unlink.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.rule.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.superscript.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
	$buttons.subscript.getEnabled = function(data) {
		var field = ((data.editor || {}).options || {})._field;
		return field && !field._isRtfMimeType();
	};
}

function _getRange(editor) {
	try {
		var sel = _getSelection(editor);
		return sel && sel.getRangeAt(0);
	} catch (e) {}
}

function _getSelection(editor) {
	// supported by all browsers including ie9
	var elt = editor.sourceMode() ? document : editor.$frame[0].contentWindow,
		sel;
	if (elt && elt.getSelection) {
		sel = elt.getSelection();
	}
	if (!sel && elt.selection)
		sel = elt.selection.createRange();
	return sel;
}

function _getFontFace(node, styleProp) {
	while (node && (node.nodeType != Node.ELEMENT_NODE || node.nodeName !== "FONT")) {
		node = node.parentNode;
	}
	return node && node.face;
}

function _getStyle(node, styleProp) {
	// do not use window.getComputedStyle because it returns font-size in px instead of pt
	while (node && (node.nodeType != Node.ELEMENT_NODE || node.style[styleProp] == null)) {
		node = node.parentNode;
	}
	return node && node.style[styleProp];
}

function _getStyles(node) {
	_styles = {};
	_getStylesFromNode(node);
	return _styles;
}

function _getStylesFromNode(node) {

	// do not use window.getComputedStyle because it returns font-size in px instead of pt
	while (node && node.nodeType != Node.ELEMENT_NODE) {
		node = node.parentNode;
	}
	var styles = "";
	if (node && node.style) {
		var styleProp;
		for (var ii = 0, jj = node.style.length; ii < jj; ii++) {
			if (node.style[ii] != "") {
				styleProp = node.style[ii];
				_styles[styleProp] = node.style[styleProp];
			}
		}
	}
}

function _getTagNames(node) {
	var tagNames = [];
	while (node && node.parentNode) {
		if (node.tagName) {
			if (node.tagName === "SPAN" || node.tagName === "BODY" || node.tagName === "HTML" || node.tagName === "P" || node.tagName === "FONT")
				break;
			tagNames.push(node.tagName);
		}
		node = node.parentNode;
	}
	return tagNames;
}

var _editorHelpers = {
	htmlEscapeMap: {
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;',
		'"': '&quot;',
		"'": '&#x27;',
		'/': '&#x2F;',
		'`': '&#x60;'
	},
	createEscaper: function(map) {
		var escaper = function(match) {
			return map[match];
		};
		var source = '(?:' + Object.keys(map).join('|') + ')';
		var testRegexp = RegExp(source);
		var replaceRegexp = RegExp(source, 'g');
		return function(string) {
			string = string == null ? '' : '' + string;
			return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
		};
	},
	objInvert: function(obj) {
		var result = {}, keys = Object.keys(obj),
			i, length = keys.length;
		for (i = 0; i < length; i++) {
			result[obj[keys[i]]] = keys[i];
		}
		return result;
	},
	getEditorInnerText: function(el, win) {
		if (el.innerText !== undefined) {
			return el.innerText.replace(/\x0A{2}/g, "\n").replace(/\r\n\r\n/g, "\r\n");
		} else {
			win = win || window;
			var doc = win.document,
				sel, range, prevRange, selString;
			if (win.getSelection && doc.createRange) {
				sel = win.getSelection();
				if (sel.rangeCount) {
					prevRange = sel.getRangeAt(0);
				}
				range = doc.createRange();
				range.selectNodeContents(el);
				sel.removeAllRanges();
				sel.addRange(range);
				selString = sel.toString();
				sel.removeAllRanges();
				prevRange && sel.addRange(prevRange);
			} else if (doc.body.createTextRange) {
				range = doc.body.createTextRange();
				range.moveToElementText(el);
				range.select();
			}
			return selString.replace(/\x0A{2}/g, "\n");
		}
	}
};
var _htmlEscape = _editorHelpers.createEscaper(_editorHelpers.htmlEscapeMap);
var _htmlUnescape = _editorHelpers.createEscaper(_editorHelpers.objInvert(_editorHelpers.htmlEscapeMap));
if (!String.prototype.endsWith) {
	String.prototype.endsWith = function(suffix) {
		return this.length >= suffix.length && this.substr(this.length - suffix.length) == suffix;
	};
}

function HtmlEditor() {}

exports.HtmlEditor = helpers.defineClass(HtmlEditor, Field, {
	initialize: function() {
		this.$item.$isAutoSizeDisabled = true;
		this.$item.$isAutoSize = true;
		this._cache = {};
	},
	resizeField: function() {
		if (this.domItem && this.domItem.clientWidth) {
			if (!this.isCreated) {
				this.isCreated = true;
				this._finalizeCreate();
				if (this._isFocusRequested) {
					this._editor.focus();
					delete this._isFocusRequested;
				}
			}
			this._refreshEditor();
		}
	},

	getLazyUrl: function(value) {
		return syra_site.expressionMaker.parse(this.articleParent, value && value.$url || this.$field.$url);
	},

	/// -------------
	/// ## setDataValue(value)
	///
	/// Sets the content value.
	///
	/// This method is not intended to be called directly.
	/// The normal way to set the value with its metadata is to call `setDataBind(value, record, metaData)`
	///
	/// **Overrides:** Field.setDataValue(...)
	///
	setDataValue: function(value) {
		debug && console.log('htmlEditor.setDataValue 1: ' + this.id + '\n$isEditMode=' + this.$isEditMode + '\ncurrent:\n' + this.currentValue + '\nnew value:\n' + value);
		var self = this;
		this.$lazyUrl = this.getLazyUrl(value);
		if (this.$lazyUrl && value && typeof(value) === 'object') {
			// lazy loading
			self.$contentType = value.$contentType || (this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type);
			syra_controller.sendRequest(null, {
				$location: {
					$url: self.$lazyUrl,
					$contentType: self.$contentType,
					$type: self.$contentType
				}
			}, function(data, response) {
				debug && console.log('htmlEditor.lazyload: ' + self.id + '\n$isEditMode=' + self.$isEditMode + '\ncurrent:\n' + self.currentValue + '\nnew value:\n' + data);
				if (typeof(data) === 'string') {
					self.setDataValue(data);
				} else {
					self.showErrors([locale.format(syra_local.fieldBadDataType, "string", typeof(data))]);
				}
			}, function(error) {
				debug && console.log('htmlEditor.lazyload: ' + self.id + ' error=' + error.message);
				self.showErrors([error.message]);
			});
		} else {
			try {
				if (this.currentValue != value) {
					var styles = this.$field.$styles;
					// var styles = Array.isArray(value.$styles) ? styles = value.$styles.join("\n") : styles = value.$styles;
					// this._editor.options.headStyle = styles || this._editor.options.headStyle;
					this._setContents(value, true);
					this.currentValue = this._getPersistentContents();
					if (!this.dirty()) {
						this._cache.dirtyChecksum = this._cache.checksum;
					}
				}
			} catch (error) {
				this.showErrors([error.message]);
			}
			debug &&
				console.log('htmlEditor.setDataValue 2: ' + this.id + '\n$isEditMode=' + this.$isEditMode + ', checksum=' + this._cache.dirtyChecksum + //
					'\ncurrent:\n' +
					this.currentValue +
					'\nnew:\n' +
					value);

			this._refreshToolbar();
		}
	},
	/// -------------
	/// ## getInputValue()
	///
	/// Gets the content value.
	///
	/// **Overrides:** Field.getInputValue()
	///
	getInputValue: function() {
		var value = "";
		debug && console.log('htmlEditor.getInputValue: ' + this.id + ' isDirty=' + this.isDirty() + ', contents=\n' + this._getPersistentContents());
		if (this.isEditable() && this._editor && this._editor.$area) {
			value = this._getPersistentContents();
			// this._cache.changedChecksum = this._cache.checksum;
			if (this._isRaw && value) {
				value = value.replace(/<\/pre><pre>/gi, "\n").replace(/<pre>/gi, "").replace(/<\/pre>/gi, "");
				value = _fixEmptyPre(value);
			}
		}
		return value;
	},
	/// -------------
	/// ## isDirty()
	///
	/// Returns `true` if the content has changed since the field gained the focus or since the last setDataValue.
	///
	isDirty: function(dontHidePopup) {
		// Get the current content to compute the checksum
		if (this._editor && !dontHidePopup) {
			this._editor.hidePopups();
		}
		var value = this._getPersistentContents(),
			dirty = (this._cache.dirtyChecksum != this._cache.checksum);
		if (debug) {
			console.log('htmlEditor.isDirty: ' + this.id + ' isDirty=' + dirty + ', dirty()=' + this.dirty() + ", checksum=" + this._cache.checksum + ", dirtyChecksum=" + this._cache.dirtyChecksum);
			console.log('new:\n' + value);
			console.log('cached:\n' + this._cache.value);
			console.log('raw:\n' + this._cache.raw);
		}
		return dirty;
	},
	/// -------------
	/// ## setDirty()
	///
	/// Change the dirty state.
	///
	/// **Overrides:** Field.setDirty()
	///
	setDirty: function(dirty) {
		if (!dirty) {
			var contents = this._getPersistentContents(); // to compute checksum;
			this._cache.dirtyChecksum = this._cache.checksum;
			//console.log(this._editor.$area.val())
			if (this.isEditable() && !this._isRaw)
				this._setRawEditContents(rtf.toHtml(this.$field.$type != "text/html" ? _htmlEscape(contents) : contents));
			//console.log(contents)
			//console.log(rtf.toHtml(contents))

		}
		debug && console.log('htmlEditor.setDirty(' + dirty + '): ' + this.id + ' dirty()=' + this.dirty() + ", checksum=" + this._cache.checksum);
		debug && console.log('cached:\n' + this._cache.value + '\nraw:\n' + this._cache.raw);
		this.dirty(dirty);
	},

	/// -------------
	/// ## dirty()
	///
	/// Get or set the internal dirty state.
	///
	/// **Overrides:** Field.dirty()
	///
	dirty: function(set) {

		if (set !== undefined) {
			this._isDirty = set;
		} else
			return this._isDirty;
	},

	// -------------
	// ## hasChanged()
	//
	// Returns `true` if the content has changed since the last call to `getInputValue`.
	//
	// hasChanged: function() {
	//     return (this._cache.changedChecksum == null) || this._cache.changedChecksum !== this._cache.checksum;
	// },
	/// -------------
	/// ## validateType(errors, value)
	///
	/// Validates the current value and reports errors.
	///
	/// This method is called during the validation process and is not intended to be called directly.
	///
	/// **See:** Field.validate(...)
	///
	validateType: function(errors, value) {
		if (this.currentValue && this.$maxLength && this.currentValue.length > this.$maxLength) {
			errors.push(locale.format(_localize.errorMaxLength, this.$maxLength));
		}
		debug && console.log('htmlEditor.validateType: ' + this.id + '\nValue: ' + this.currentValue);
	},

	/// -------------
	/// ## notifyFieldChange(newValue, validated)
	///
	/// Notified the change to the server.
	///
	/// This method is called during the validation process and is not intended to be called directly.
	/// It overides the standard behavior to allow update of lazy loaded contents.
	///
	/// **See:** Field.notifyFieldChange(...)
	//TODO :
	//A revoir : pourquoi un url particulieret ne pas traiter les datas editeur lazyload comme n'importe qu'elle autre
	notifyFieldChange: function(newValue, validated) {
		var self = this;
		self.$lazyUrl = self.getLazyUrl();
		self.currentValue = newValue;
		if (self.$lazyUrl) {
			if (self.page.isServerNotifyDisabled) {
				self.setDatasetValue(newValue);
			} else {
				debug && console.log('htmlEditor.notifyFieldChange lazy content: ' + self.id + '\nValue: ' + newValue);
				syra_controller.sendRequest(null, {
					$location: {
						$url: self.$lazyUrl,
						$contentType: self.$contentType,
						$type: self.$contentType
					},
					data: newValue,
					method: "PUT"
				}, function(data, response, requestUrl) {
					debug && console.log('htmlEditor.notifyFieldChange lazy upload: ' + self.id + '\ndata: ' + data + ', response=' + JSON.stringify(response));
				});
			}
		} else {
			Field.prototype.notifyFieldChange.call(self, newValue, validated);
		}
	},

	/// -------------
	/// ## focus()
	///
	/// Sets the focus to the edit part of the widget.
	///
	/// **Overrides:** Field.focus()
	///
	focus: function() {
		debug && console.log('htmlEditor.focus: ' + this.id);
		if (this.isEditable() && this._editor) {
			if (!this.isCreated) {
				this._isFocusRequested = true;
			} else {
				this._editor.focus();
			}
		}
	},
	/// -------------
	/// ## getCaretPosition()
	///
	/// Gets the current 0 based caret position in the editor.
	///
	/// **Overrides:** Field.getCaretPosition()
	///
	getCaretPosition: function() {
		if (!(this.isEditable() && ((this._editor || {}).doc || {}).body && this.$$caret)) {
			return 0;
		}

		var doc = this._editor.doc,
			root = doc.body,
			sel = _getSelection(this._editor),
			$$caret = this.$$caret,
			caretPos, range, contents;

		try {
			range = doc.createRange();
			range.setStart(root, 0);
			sel.focusNode && range.setEnd(sel.focusNode, sel.focusOffset);
			contents = range.cloneContents();
		} catch (e) {
			return 0;
		}
		if (contents) {
			$$caret.append(contents);
			$$caret.html($$caret.html().replace(/<br\s*[\/]?>/gi, "\n"));
			caretPos = $$caret.text().length;
			$$caret.empty();
		}
		return caretPos || 0;
	},

	isEditable: function() {
		return this.$isEditMode;
	},

	setState: function(state) {
		debug && console.log('htmlEditor.setState: ' + this.id + "\n" + (state ? JSON.stringify(state) : "<undefined>"));
		if (state && state.$isDisabled !== undefined) {
			this._disable(state.$isDisabled);
		}
		Field.prototype.setState.call(this, state);
	},

	_onSetReadOnly: function($isReadOnly) {
		this._disable($isReadOnly);
		Field.prototype._onSetReadOnly.call(this, $isReadOnly);
	},
	render: function() {
		this.$maxLength = this.$field.$maxLength || this.$field.$maxByteLength;
		this.$capabilities = this.$capabilities || resUtil.parseCapabilities(this.$field.$capabilities);
		this.$lazyUrl = this.getLazyUrl();
		this.$contentType = this.$field.$type === 'application/x-document' && this.$field.$contentType || this.$field.$type;

		lazyInit(jQuery);
		debug && console.log('htmlEditor.render ' + this.id);
		var self = this,
			id = self.id || helpers.uuid.generate();
		self._dataValue.setAttribute("id", self.id + "-data");

		this.$$caret = $("<div>").attr("id", id + "-caret").attr("style", "display:none;").appendTo(self._dataValue);

		var $$area = $('<textarea>').attr('id', "html-editor-" + id).attr('name', "html-editor-" + id).appendTo($(self._dataValue));

		// add attribute to disable browser spellcheck and autocorrect
		syra_site.setSpecificAttributes($$area[0]);

		$$area[0].syraItem = id;
		$$area[0].setAttribute("data-s-field", id);
		(this.$$area = $$area)[0].syrainout = this.id;
		this.$item.$rows && $$area.attr("rows", this.$item.$rows);
		var _colors = jQuery.cleditor.defaultOptions.colors + " " + _extendColors.join(" ");
		self._editor = $$area.cleditor({
			// resizeSelector: "resize" + helpers.uuid.generate(),
			// width not including margins, borders or padding
			// width: self.$item.$textWidth || "100%",
			width: self.$item.$textWidth || "auto",
			// height not including margins, borders or padding
			// height: self.$item.$textHeight || 480,
			height: self.$item.$textHeight || "auto",
			controls: "bold italic underline strikethrough subscript superscript | font size style | color" + //
			" highlight removeformat | bullets" + //
			// " numbering" +
			" | insertTable " + //
			" | outdent indent alignleft center alignright justify" + //
			" | undo redo | rule image link unlink" + //
			" | cut copy paste pastetext" + //
			// condition source feature to development mode to prevent xss attack
			" | print" +
				(syra_site.developpementMode ? " source" : "") +
				" rawMode " + //
			" | extendSize",
			colors: _colors,
			docCSSFile: "/syracuse-ui/themes/desktop/sage/cleditor/jquery.cleditor-doc.css",
			// style to assign to document body contained within the editor
			// bodyStyle: "margin:4px; font:10pt Arial,Verdana; cursor:text"
			bodyStyle: /^(ar|iw|he)/.test(syra_site.userProfile.currentLangCode) ? "direction:rtl" : "",
			// sizes in the font size popup
			sizes: fontSizes,
			styles: htmlStyles,
			useCSS: true,
			_field: self,
			_rawAllowed: function() {
				return self._rawAllowed();
			},
			_isRaw: function() {
				return self._rawAllowed() && self._isRaw;
			},
			_setRaw: function(v) {
				if (self._rawAllowed())
					self._isRaw = v;
			},
			_sanitizeHtml: sanitizeHtml,
			// Handlers
			updateFrame: function(html) {
				return self.$isEditMode ? sanitizeHtml(html) : html;
			},
			updateTextArea: function(html) {
				return self.$isEditMode ? sanitizeHtml(html) : html;
			}
		})[0];
	},
	_isRtfMimeType: function() {
		return this.$field.$type == "text/rtf";
	},
	_finalizeCreate: function() {
		debug && console.log('htmlEditor._finalizeCreate ' + this.id);
		this.setState(this.$field);
		if (this.$field.$valueStyle)
			this._editor.options.bodyStyle = this.$field.$valueStyle;
		this._refreshToolbar();
		this._refreshEditor();

		// Intercept paste event to get the opportunity of sanitizing the contents
		var $$input = $(this._editor.doc.body);

		this._isRtfMimeType() &&
			$$input.bind('paste', function(e) {
				// this code corrupts the undo stack!!!
				var pastedText;
				if (e && e.clipboardData && e.clipboardData.getData) {
					if (/text\/html/.test(e.clipboardData.types)) {
						pastedText = e.clipboardData.getData('text/html');
					} else
					if (/text\/plain/.test(e.clipboardData.types)) {
						pastedText = e.clipboardData.getData('text/plain');
					} else {
						pastedText = "";
					}
				} else
				if (window.clipboardData && window.clipboardData.getData) { // IE
					pastedText = window.clipboardData.getData('Text');
				} else {
					var el = $(this);
					// Hiding the underlying element causes some unpredictable behavior
					// var display;
					// $.browser.mozilla && (display = el.css('display')) && el.css('display', 'none');
					setTimeout(function() {
						var text = $(el).html();
						if (text) {
							$(el).html(sanitize(text));
						}
						// console.log("htmlEditor..paste after timeout:\n" + (text && text.substring(0,50)));
						// display && el.css('display', display);
					}, 300);
				}
				if (pastedText) {
					// debug && console.log("htmlEditor..paste from clipboard:\n" + pastedText);
					$(this).html(sanitize(pastedText));
					e.preventDefault();
					e.stopPropagation();
				}

			});

		this._bindInput(true);
	},

	_refreshToolbar: function() {
		// hack to refresh the toolbar state and disable the toolbar buttons if necessary
		this.isEditable() && this._disable(this._editor.disabled);
	},

	_refreshEditor: function() {
		var editor = this._editor;
		if (editor && editor.$frame && editor.$frame[0] && editor.$frame[0].contentWindow) {
			editor.refresh();
			this.bindEvent && this._bindInput(true);
		}
	},

	_isReady: function() {
		// debug && console.log('htmlEditor._isReady ' + this.id + ": hasDoc=" + ( !! (this._editor || {}).doc) + ", hasBody=" + ( !! ((this._editor || {}).doc || {}).body));
		return !!(this._editor || {}).doc;
	},

	_disable: function(disabled) {
		this._isReady() && this._editor.disable(this.$isReadOnly || !this.isEditable() || disabled);
		if (this._editor.disabled && !this.isEditable())
			this._editor.$toolbar.hide();
	},

	_beforeInputFocusin: function($$input, event) {
		debug && console.log("htmlEditor._beforeInputFocusin " + this.id + ", checksum=" + this._cache.checksum);
	},

	_bindInput: function(bind) {
		this.bindEvent = bind;
		if (!(this._editor && this._editor.doc)) {
			return;
		}

		var self = this;
		var doc = this._editor.doc,
			$$doc = $(doc),
			$$input = $(doc.body),
			contentWindow = this._editor.$frame[0].contentWindow,
			$$inputWindow = $.browser.mozilla ? $$doc : $(contentWindow);

		debug && console.log("htmlEditor._bindInput " + this.id + ": bind=" + bind + ", doc=" + doc + ", contentWindow=" + contentWindow);
		if (bind) {
			$$input.on("change keydown keypress keyup focusin focusout", function(event) {
				debug && console.log("htmlEditor.bindInputEvent $$input: " + event.type + " " + self.id);
				/*if (event.type=="change"){
                 var text=$$input.html()
                 var rtftxt=rtf.fromHtml(text)
                 var htmlsanitized=sanitize(text)
                 var log="--------------------------- Change -------------------------------------\n";
                 log+="html :\n"+text;
                 log+="\nrtf :\n"+rtftxt;
                 log+="\nhtmlsanitized :\n"+htmlsanitized;
                 log+="\n--------------------------- End Change ---------------------------------";
                 console.log(log)
                 }*/
				self.onFieldInputEvent(event);
				event.stopPropagation();
			});
			$$inputWindow.on("click", function(event) {
				debug && console.log("htmlEditor.bindInputEvent click --> click" + self.id);
				self.onFieldInputEvent(event);
				event.stopPropagation();
			});
			$$inputWindow.focus(function(event) {
				debug && console.log("htmlEditor.bindInputEvent focus --> focusin " + self.id);
				self._beforeInputFocusin($$input, event);
				$$input.trigger("focusin");
				// self._editor.$main.addClass("cleditorMain-focus");
				syra_site.dom.toggleClass(self._dataValue, "cleditorMain-focus", true);
				event.stopPropagation();
			});
			$$inputWindow.blur(function(event) {
				debug && console.log("htmlEditor.bindInputEvent blur --> focusout " + self.id);
				debug && console.log("\tCaret position: " + self.getCaretPosition());
				// self._editor.$main.removeClass("cleditorMain-focus");
				syra_site.dom.toggleClass(self._dataValue, "cleditorMain-focus", false);
				if (self.isDirty(syra_site.browser.getIdentity().isMSIE)) { // When popup is opening $$inputWindow is onblur with IE 
					$$input.trigger("change");
				}
				$$input.trigger("focusout");
				event.stopPropagation();
			});
		} else {
			$$input.off();
			$$inputWindow.off();
		}
	},

	_rawAllowed: function() {
		return this._isRtfMimeType() && this.$capabilities && this.$capabilities.raw;
	},

	_setRawEditContents: function(contents) {
		if (this._editor && this._editor.$area) {
			debug && console.log('htmlEditor._setRawEditContents:\n' + contents);
			this._editor.$area.val(contents || '');
			this._editor.updateFrame();
		}
	},

	_getRawEditContents: function() {
		if (this.isEditable() && this._editor && this._editor.doc) {
			if (this._editor.doc.body) {
				return fixHtml(this._editor.doc.body.innerHTML || "");
			} else
			if (this._editor.$area) {
				// iframe is not yet created so return the textarea content
				return fixHtml(this._editor.$area[0].innerHTML || "");
			}
		}
	},

	_setContents: function(contents, saveStyles) {
		//console.log("rtf : " + contents)
		debug && console.log('htmlEditor._setContents 1: isEditable()=' + this.isEditable() + '\n' + contents);
		this._isRaw = false;
		if (!contents || contents.length === 0) {
			// No contents, assume we want to edit Rich Text or HTML
		} else {
			switch (this.$field.$type) {
				case "text/rtf":
					if (contents.match(/^\s*{\\(u|)rtf/)) {
						contents = rtf.toHtml(_htmlEscape(contents));
					} else
					if (this._rawAllowed()) {
						this._isRaw = true;
						if (!contents.match(/<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i)) {
							// Not an HTML contents, so wrap it in <pre> tag
							contents = "<pre>" + _htmlEscape(contents) + "</pre>";
						}
					} else {
						syra_site.showDiagnoses({
							$diagnoses: [{
								$message: locale.format(_localize.errorRtfExpected, contents),
								$severity: "error"
							}, {
								$message: _localize.warnContentsNotSet,
								$severity: "warning"
							}]
						}, this);
						return;
					}
					break;
				case "text/html":
					// contents as is
					break;
			}
		}
		debug && console.log('htmlEditor._setContents 2: _isRaw=' + this._isRaw + '\n' + contents);

		if (saveStyles && contents) {
			this.$$savedStyles = $("<div>").append(contents).find('style');
		}
		this._setRawEditContents(contents);
		if (!this.isEditable()) {
			this._disable();
		}
		//if (this.isEditable()) {

		//} else {
		//	this.fieldValue.innerHTML = contents;
		//}
		//console.log("html : " + contents)
	},

	_getPersistentContents: function(contents) {
		if (!this.isEditable())
			return null;

		if (contents === undefined) {
			contents = this._getRawEditContents();
		}
		if (contents === undefined) {
			return null;
		}
		var hash = checksum(contents);
		if (hash === this._cache.checksum) {
			if (!this._isRaw || contents.indexOf('<pre>') < 0)
				return this._cache.value;
		}
		this._cache.raw = contents;
		debug && console.log('htmlEditor._getPersistentContents change: checksum=' + hash + '\nraw:\n' + contents);

		this._cache.checksum = hash;

		if (this.$$savedStyles) {
			var $$contents = $('<div>').append(contents);
			if ($$contents.find('style').length === 0) {
				$$contents.prepend(this.$$savedStyles);
				contents = $$contents.html();
			}
		}
		if (this._isRaw) {
			var preElement;
			if (contents.indexOf('<pre>') == 0) {
				contents = normalizeRawText(contents);
				if (contents.indexOf('<pre>') != 0) {
					preElement = document.createElement('pre');
					preElement.innerHTML = contents;
					contents = preElement.outerHTML;
				}
			} else {
				preElement = document.createElement('pre');
				preElement.innerHTML = contents;
				contents = normalizeRawText(preElement.outerHTML);
			}
			contents = _htmlUnescape(contents);
		} else {
			if (this._isRtfMimeType()) {
				contents = (contents || "").length === 0 ? "" : rtf.fromHtml(contents);
			}
		}
		debug && console.log('htmlEditor._getPersistentContents 2 return: checksum=' + hash + '\ncontents:\n' + contents);
		this._cache.value = contents;
		return contents;
	},

	dispose: function() {
		if (this.resizeSelector) {
			$(window).unbind(this.resizeSelector);
		}
		this._bindInput(false);
		if (this._editor) {
			this._editor.hidePopups();
			this._editor.dispose();
		}
		this.$$area = this._editor = this.$$caret = this.$$savedStyles = this._cache = this.$capabilities = null;
		Field.prototype.dispose.call(this);
	}
});