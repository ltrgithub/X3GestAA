"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var datetime = require('syracuse-core/lib/types/datetime');
var cubeHelper = require('syracuse-ui/lib/field/cube/cubeHelper');
var Article = require("syracuse-ui/lib/article/article").Article;
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var arrayHelper = require("./arrayHelper");
var TabularChartRecord = require('./tabularChartRecord').TabularChartRecord;
require('syracuse-ui/deps/highcharts/highcharts.src');
require('syracuse-ui/deps/highcharts/highcharts-more.src');
require('syracuse-ui/deps/highcharts/modules/exporting.src');
Highcharts.theme = require('syracuse-ui/themes/desktop/sage/highcharts/theme').theme;
var debug = false;
Highcharts.setOptions(Highcharts.theme);
var forEachKey = helpers.object.forEachKey,
	objectCopy = helpers.object.copy,
	objectClone = helpers.object.clone,
	stringify = helpers.object.stringify;

var _style = (function() {
	var map = {
		xy: "line",
		point: "scatter",
		stick: "column",
		radar: "spiderweb"
	};

	return function($style) {
		// return 'bar';
		return $style && (map[$style] || $style);
	};
})();

var _merge = Highcharts.merge;

var _formatApi = require('syracuse-ui/lib/field/formatApi');

// TODO:
// - event management
// - dynamic loading of series

function delayed(obj, name, cb, delay) {
	var tm = "timer_" + name;
	if (obj[tm]) clearTimeout(obj[tm]);
	obj[tm] = setTimeout(cb, delay || 100);
}

function TabularChart() {}

exports.TabularChart = helpers.defineClass(TabularChart, Article, {
	onWindowResize: function() {
		// debug && console.log("HighCharts.onWindowResize " + this.id + " : displayed=" + this.displayed + " , size=(" + this.$$container.innerWidth() + ", " + this.$$container.innerHeight() + ")");
		// if (this.displayed && !this._chart && this.$$container.innerWidth() !== 0) {
		//     // defer chart creation when we are ready to display
		//     this._createChart(this._settingsFromValue());
		// }
		debug && console.log("HighCharts.onWindowResize " + this.id + " : chart.isResizing=" + (this._chart && this._chart.isResizing) + " , size=(" + this.layoutSlot.clientWidth + ", " + this.layoutSlot.clientHeight + ")");
		if (this._chart && this._chart.container) {
			var self = this;
			if (this.resizeTimer) clearTimeout(this.resizeTimer);
			this.resizeTimer = setTimeout(function() {
				debug && self._chart && console.log("HighCharts.resizeTimer " + self.id + ": About to resize - chart.isResizing=" + (self._chart && self._chart.isResizing) + " , size=(" + self.layoutSlot.clientWidth + ", " + self.layoutSlot.style.clientHeight + ")");
				debug && self._chart && console.log("    ... display=" + self.layoutSlot.style.display);

				if (self._chart && self._chart.container && !self._chart.isResizing) {
					if (self.layoutSlot.clientWidth) {
						var height = self._chart.chartHeight || self.layoutSlot.style.clientHeight || self.layoutSlot.clientHeight;
						debug && self._chart && console.log("HighCharts.resizeTimer " + self.id + ": setSize(" + self.layoutSlot.clientWidth + "," + height + ")");
						self._chart.setSize(self.layoutSlot.clientWidth, height);
						self._redraw();
					}
				}
			}, 200);
		}

	},

	dispose: function() {
		this._chart && this._chart.destroy();
		this._localize = null;
		Article.prototype.dispose.call(this);
	},

	applyDesignMetaData: function(metadata) {
		var self = this,
			meta = self._meta,
			chart = self._chart,
			designMeta = this._mergeDesignData(metadata),
			needRefresh = false;

		this._updateMeasures(designMeta);

		if (!chart) {
			return;
		}

		if (meta && designMeta.$style) {
			this._setStyle(designMeta.$style);
		}
		if (meta && designMeta.$cube && designMeta.$cube.$measures) {
			forEachKey(designMeta.$cube.$measures, function(k, m) {
				var s = meta.series[k],
					serie = chart.get(s.options.id);

				debug && console.log("HighCharts.applyDesignMetaData: " + s.options.id + ", meta=" + stringify(m));
				if (serie) { //Hack lv to avoid error. waiting best fix if necessary (change style is not used for this)
					needRefresh = true;
					m.$style && serie.update({
						type: _style(m.$style)
					}, false);
				}
			});
			needRefresh && this._redraw();
		}
	},

	createChoices: function() {
		// var $choices = ["area", "areaspline", "bar", "column", "line", "scatter", "spline", "pie"];
		var $choices = ["area", "areaspline", "column", "line", "scatter", "spline", "pie"];
		var $enums = [];
		for (var ii = 0, jj = $choices.length; ii < jj; ii++) {
			var $choice = $choices[ii];
			$enums.push(typeof($choice) === "string" ? {
				$value: $choice,
				$title: this._localize[$choice] || $choice
			} : {
				$value: $choice.$value,
				$title: $choice.$title || this._localize[$choice.$value] || $choice.$value
			});
		}
		return {
			$type: "application/x-choice",
			$title: "",
			$value: {
				$type: "application/x-string",
				$enum: $enums
			}
		};
	},

	drawBox: function() {
		this.dataset = null;
		this.$authoringType = "cube$highCharts";
		this.$localization = this.articleParent.$prototype.$localization;
		this._localize = locale.resources(module)();
		// debug && console.log("HighCharts.drawBox " + this.id);
		var proto = this.$prototype;
		// create an alias
		proto.$properties = proto.$item.$properties;

		// this._cube = cube(this);
		this._initializeMeta();
		this._initializeToobar();
		this._createMenuContainer();

		if (!this.$item.$isListEmbeded) {
			this.articleParent.bind(this, this.$item.$bind);
		}
	},

	_mergeDesignData: function(metadata) {
		var m = {};
		if (metadata && metadata.$cube) m.$cube = metadata.$cube;
		if (metadata && metadata.$style) m.$style = metadata.$style;
		this.designMetadata = _merge(this.designMetadata || {}, m);
		return this.designMetadata;
	},

	_setDataSet: function(dataRecordSet) {
		this.dataset = arrayHelper.fixDataSet(this, dataRecordSet);
	},


	setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		debug && console.log("HighCharts.setDataBind " + this.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length) + "\n" + stringify(dataRecordSet));
		if (metaData) {
			this._processMeta(metaData);
		}
		this._setDataSet(dataRecordSet);
		debug && console.log("HighCharts.setDataBind " + this.id + ": dataset=" + (this.dataset && this.dataset.length) + "\n" + stringify(this.dataset));

		var settings;
		if (this.dataset && this.dataset.length > 0) {
			settings = this._settingsFromValue();
		}

		if (!this._chart && settings) {
			this._createChart(settings);
		} else if (this._chart && settings) {
			var self = this;
			self._chart.xAxis && self._chart.xAxis[0].setCategories(settings.categories, false);

			var series = self._chart.series;
			if (self._chart.options.chart.polar) {
				for (var j = series.length - 1; j >= 0; j--) {
					series[j].remove(false);
				}
			}
			if (!series || series.length === 0) {
				forEachKey(settings.series, function(key, s) {
					self._chart.addSeries(settings.series[key], false);
				});
			} else {
				for (var ii = 0; ii < series.length; ii++) {
					var chartSerie = series[ii],
						key = chartSerie.options.id.slice(3),
						serie = settings.series[key],
						update = {};
					chartSerie.setData(serie.data, false);
					if (chartSerie.name !== serie.name) {
						update.name = serie.name;
					}
					if (chartSerie.type !== serie.type) {
						update.type = serie.type;
					}
					if (Object.keys(update).length) {
						chartSerie.update(update, false);
					}
					// serie.data = [];
				}
			}
			self._redraw();
		}

		this._showDrillUp(false);
	},

	_createMenuContainer: function() {
		// var $$menu = $("<div>").appendTo(this.$$container);
		// // $$menu.addClass();
		// $$menu.attr("style", "position: absolute; z-index: 1000; padding: 24px; display: none; right: -14px; top: 10px;");
		// $$menu.append("<div>");
		// <div class="s-field-menus-popup" style="position: absolute; z-index: 106; top: 111.5px; left: 34px;" id="a6afea62-897d-49e7-a532-f82ca3df2af4">
		//   <div class="s-field-menus-slot">
		//     <nav class="s-list-menus">
		//       <ul style="" class="s-list-menus-body">
		//         <li class="s-list-menus-li"><a style="" class="s-list-menus-link" data-s-menu="18-4" data-s-article="18-1" title="Créer une diapositive Powerpoint" target="blank" href="/sdata/x3stb/erp/stubs/HighCharts?representation=HighCharts.$query&amp;pptMode=newSlide&amp;format=application/syracuse-ppt-slide">
		//           <div class="s-list-menus-link-icon" style="background-image: url(&quot;/syracuse-ui/themes/desktop/desktop/sage/images/file/s-link-syracuse-ppt-slide.png&quot;);"></div>
		//           <div class="s-list-menus-link-label s-external-link">Créer une diapositive Powerpoint</div>
		//           </a>
		//         </li>
		//       </ul>
		//     </nav>
		//   </div>
		// </div>
		// $$menu.
		// <div class="highcharts-menu0" style="position: absolute; z-index: 1000; padding: 24px; display: none; right: -14px; top: 10px;">
		//   <div style="box-shadow: 3px 3px 10px rgb(136, 136, 136); border: 1px solid rgb(160, 160, 160); background: none repeat scroll 0% 0% rgb(255, 255, 255);">
		//     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download PNG image</div>
		//     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download JPEG image</div>
		//     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download PDF document</div>
		//     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download SVG vector image</div>
		//   </div>
		// </div>
	},

	_settingsFromValue: function() {
		var self = this,
			$cube = this.designMetadata.$cube,
			settings;

		if ($cube.$style === "spiderweb") {
			settings = {};
			settings.categories = Object.keys(self._meta.series).map(function(key) {
				return self._meta.series[key].options.name;
			});

			settings.series = {};
			self.dataset && self.dataset.reduce(function(res, current) {
				var serie = {
					name: self._getMeasureLabel(current, self._meta.xAxis[0].code),
					data: [],
					pointPlacement: 'on'
				};
				if (serie.name) {
					serie.id = "#s-" + serie.name;
					forEachKey(self._meta.series, function(key, s) {
						serie.data.push([key, parseFloat(current.$rawV && current.$rawV[key] && current.$rawV[key].v || current[key])]);
					});
					res.series[serie.name] = serie;
				}
				return res;
			}, settings);
		} else {
			settings = {
				categories: [],
				series: {}
			};
			self.dataset && self.dataset.reduce(function(res, current) {
				var categoryName = self._getMeasureLabel(current, self._meta.xAxis[0].code);
				if (categoryName) {
					res.categories.push(categoryName);
					forEachKey(self._meta.series, function(key, s) {
						var serie = res.series[key];
						if (!serie) {
							serie = objectClone(s.options);
							serie.data = [];
							res.series[key] = serie;
						}
						serie.data.push([categoryName, parseFloat(current.$rawV && current.$rawV[key] && current.$rawV[key].v || current[key]) || 0]);
					});
				}
				return res;
			}, settings);
		}
		return settings;
	},

	_createChart: function(settings) {
		var self = this,
			options = _merge(self._getPref(), self._getOptions(self.$prototype));

		if (settings) {
			options.xAxis[0].categories = settings.categories;
			forEachKey(settings.series, function(key, s) {
				var serie = objectClone(s);
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				options.series.push(serie);
			});

			// forEachKey(self._meta.series, function(key, s) {
			//     var serie = objectClone(settings.series[key]);
			//     if (options.chart.polar && serie && serie.type) {
			//         delete serie.type;
			//     }
			//     options.series.push(serie);
			// });
		} else {
			forEachKey(self._meta.series, function(key, s) {
				var serie = objectClone(s.options);
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				serie.data = [0];
				options.series.push(serie);
			});
		}
		self._chart = new Highcharts.Chart(options);

		// To test: create a clickable area for drillUp
		// var renderer = self._chart;
		// self._drillUpGroup = renderer.g().add();
		// renderer.circle(10, 10, 5).on("click", function(event) {
		//     self._drill(this, event.shiftKey);
		//     if (self._meta.drill.currAxisHier > 0) {
		//         self._drillUpGroup.show();
		//     } else {
		//         self._drillUpGroup.hide();
		//     }
		// }).attr({
		//     fill: 'red',
		//     stroke: 'black',
		//     'stroke-width': 1
		// }).add(self._drillUpGroup);
		// renderer.path(['M', 12.981, 9.073, 'V', 6.817, 'l', -12.106, 6.99, 'l', 12.106, 6.99, 'v', -2.422, 'c', 3.285, -0.002, 9.052, 0.28, 9.052, 2.269, 'c', 0, 2.78, -6.023, 4.263, -6.023, 4.263, 'v', 2.132, 'c', 0, 0, 13.53, 0.463, 13.53, -9.823, 'C', 29.54, 9.134, 17.952, 8.831, 12.981, 9.073, 'z']).attr({
		//     'stroke-width': 2,
		//     stroke: 'red'
		// }).add(self._drillUpGroup);
		// renderer.text('drill up', 200, 100).attr({
		//     rotation: 45
		// }).css({
		//     fontSize: '16pt',
		//     color: 'green'
		// }).add(self._drillUpGroup);
		this._showDrillUp(false);
	},

	_localizedText: function(val) {
		var $localization = this.$localization;
		return val && val.replace(/\{(@[\w-]+)\}/g, function(match, p1) {
			return ($localization && $localization[p1]) || match;
		});
	},

	_setSerie: function(id) {
		this._chart.series.map(function(s) {
			s.hide();
		});
		this._chart.get(id).show();
	},

	_redraw: function() {
		this._chart && this._chart.redraw();
	},

	_getFieldEvalTitle: function() {
		return this.page.externalAdapter.getFieldEvalTitle(this) || [];
	},

	_getOptions: function(proto) {
		var self = this,
			$cube = this.designMetadata.$cube,
			defOptions = Highcharts.getOptions(),
			buttons = defOptions.exporting.buttons,
			measuresTitle = this._getFieldEvalTitle(),
			axe = proto.$axes && proto.$axes[0] || {},
			axeTitle = axe.$hierarchies && measuresTitle[axe.$hierarchies[0][0]] || axe.$title;

		var options = {
			chart: {
				renderTo: this.layoutSlot,
				marginLeft: 30,
				marginRight: 150,
				// witdh: self.layoutSlot.clientWidth,
				// height: self.layoutSlot.style.clientHeight
				zoomType: 'x'
			},
			lang: {
				drillDown: self._localize.drillDown,
				drillUp: self._localize.drillUp
			},

			legend: {
				align: 'right',
				verticalAlign: 'top',
				x: 0,
				y: 130,
				/*              align: 'center',
                 verticalAlign: 'bottom',
                 x: 0,
                 y: 0,*/
				// floating: true
			},

			title: ($cube && self._localizedText($cube.$title)) || '',

			xAxis: [{
				categories: [],
				title: {
					text: self._localizedText(axeTitle)
				},
				labels: {
					rotation: -45,
					align: 'right',
					// style: {
					//     fontSize: '13px',
					//     fontFamily: 'Verdana, sans-serif'
					// }
				}
			}],

			yAxis: [{
				title: {
					text: ''
				},
				// type: 'logarithmic',
			}],

			plotOptions: {
				series: {
					cursor: 'pointer',
					events: { // legendItemClick: function(e) {
						//     // use e.mousePageX and e.mousePageY for mouse coordinates
						//     console.log("legendItemClick: (" + e.mousePageX + ", " + e.mousePageY + ")");
						// }
					},
					point: {
						events: {
							click: function(event) {
								self._onMeasureClick({
									data: this,
									event: event
								});
							}
						}
					},
					stacking: self._meta.stacking
				}
			},

			tooltip: {
				formatter: function() {
					var seriesMeta = self._meta.series,
						serie = this.key && seriesMeta[this.key] || seriesMeta[this.series.options.id.slice(3)],
						measure = serie && serie.measure,
						data = this.series.processedYData,
						y = this.y;

					if (measure) {
						self._ensureFormatter(measure);
					}
					var label = this.series.name || measure && measure.$title,
						mformat = measure && measure.formatApi,
						mlocale = measure && measure.localeFormat;
					label = (label ? label + "<br>" : "") + (this.x || this.key) + ': <b> ' + (mformat ? mformat.format(y, mlocale) : y) + '</b>';
					if (measure && (measure.$isNormalized) && data.length > 0) {
						var sum = data.reduce(function(a, b) {
							return a + b;
						});
						label += ' (' + (mformat ? mformat.format(y / sum * 100, mlocale) : y / sum * 100) + '%)';
					}

					var hCount = $cube.$hierarchies && Object.keys($cube.$hierarchies).length || 0;

					if (self._meta.drillDownLink || hCount > 1) {
						label += '<br/><span style="font-size: 10px; font-style:italic;">' + self._localize.clickToDrill + '</span>';
					}
					// label += '<br/><span style="font-size: 10px; font-style:italic;">' + self._localize.clickToDrill + '</span><br/><span style="font-size: 10px; font-style:italic;">Shift+Click to drill up</span>'
					return label;
					/*  var items = this.points || splat(this),
                     series = items[0].series,
                     s;
                     // build the header
                     s = [series.tooltipHeaderFormatter(items[0].key)];
                     // build the values
                     items.map(function(item) {
                     series = item.series;
                     s.push((series.tooltipFormatter && series.tooltipFormatter(item)) || item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
                     });
                     // footer
                     s.push(options.footerFormat || '');
                     return s.join('');*/
				}
			},
			series: [],
		};
		if (Highcharts.theme.version[0] === 3) {
			// For Highcarts 3.0.0
			options.exporting = {
				//enabled: true,
				//filename: 'chart',
				type: 'image/png',
				url: 'http://export.highcharts.com/',
				//width: undefined, // docs
				//scale: 2 // docs
				buttons: {
					contextButton: { // docs
						//x: -10, // docs: x is different now
						symbol: 'menu',
						_titleKey: 'contextButtonTitle',
						menuItems: [{
							textKey: 'drillUp',
							onclick: function() {
								setTimeout(function() {
									self._drill(null, true);
								}, 100);
							}
						}, {
							separator: true
						}, {
							text: 'Print chart',
							onclick: function() {
								this.print();
							}
						}, {
							separator: true
						}, {
							textKey: 'downloadPNG',
							onclick: function() {
								this.exportChart();
							}
						}, {
							textKey: 'downloadJPEG',
							onclick: function() {
								this.exportChart({
									type: 'image/jpeg'
								});
							}
						}, {
							textKey: 'downloadPDF',
							onclick: function() {
								this.exportChart({
									type: 'application/pdf'
								});
							}
						}, {
							textKey: 'downloadSVG',
							onclick: function() {
								this.exportChart({
									type: 'image/svg+xml'
								});
							}
						}, // Enable this block to add "View SVG" to the dropdown menu
						// {
						//     text: 'View SVG',
						//     onclick: function() {
						//         var svg = this.getSVG().replace(/</g, '\n&lt;').replace(/>/g, '&gt;');
						//         document.body.innerHTML = '<pre>' + svg + '</pre>';
						//     }
						// }
						]
					}
				}
			};
		} else if (Highcharts.theme.version[0] === 2) {
			// For Highcharts 2.0.x
			options.exporting = {
				buttons: {
					drillUp: {
						symbol: 'triangle',
						x: -62,
						symbolFill: 'rgba(250,250,250,0.5)',
						hoverSymbolStroke: '#fff',
						hoverSymbolFill: 'rgba(250,250,250,0.5)',
						_id: 'drillUp',
						_titleKey: 'drillUp',
						onclick: function() {
							self._drill(null, true);
						}
					},
					printButton: buttons.printButton,
					exportButton: buttons.exportButton
				}
			};
		}

		if (options.xAxis[0].title.text !== options.title) {
			options.xAxis[0].title.text = options.title + (options.xAxis[0].title.text ? ' / ' + options.xAxis[0].title.text : '');
		}

		if ($cube.$style === "spiderweb") {
			options.chart.polar = true;
			options.chart.type = 'area';
			delete options.xAxis[0].title;
			options.xAxis[0] = _merge(options.xAxis[0], {
				tickmarkPlacement: 'on',
				lineWidth: 0
			});
			delete options.xAxis[0].labels;
			delete options.yAxis;
			options.yAxis = {
				gridLineInterpolation: 'polygon',
				lineWidth: 0,
				// min: 0
			};
			// options.yAxis[0] = _merge(options.yAxis[0], {
			//     gridLineInterpolation: 'polygon',
			//     lineWidth: 0,
			//     min: 0
			// });
		} else {
			options.chart.type = self._meta.defaultStyle;
		}
		return options;
	},

	_initializeMeta: function() {
		this._mergeDesignData(this.$prototype);
		this._mergeDesignData(this.$item);

		var proto = this.$prototype;
		var cube = this.designMetadata;


		this._meta = {
			xAxis: [{}],
			series: {},
			displaysOneMeasure: cube && cube.$displaysOneMeasure,
			hasMeasureSelector: cube && cube.$hasMeasureSelector,
			hasStyleSelector: cube && cube.$hasStyleSelector,
			defaultStyle: _style(cube.$style) || 'column',
			drill: {
				minLevel: 1,
				maxLevel: 0,
				currLevel: 1,
				currAxisHier: 0,
				levelsProperties: [],
				members: [],
				stack: [{
					$axes: proto.$axes,
					$item: proto.$item,
					$slicer: proto.$slicer
				}]
				/*              code: proto.$codeStat || "UNKNOWN",
                 axis0FieldCode: self._meta.xAxis[0].code || ""*/
			}
		};
		this._processMeta(proto);
	},
	_initializeToobar: function() {
		var self = this;
		// self._toolBox && self._toolBox.show({
		//     series: (self._meta.hasMeasureSelector && self._meta.displaysOneMeasure),
		//     chartTypes: self._meta.hasStyleSelector
		// });
		// self._toolBox && self._toolBox.selectChartType(self._meta.defaultStyle);
	},
	_processMeta: function(proto) {
		this._processMeasures(proto);
		this._processLinks(proto);
		this._processAxes(proto);
	},
	_processMeasures: function(proto) {
		var self = this,
			$cube = this.designMetadata.$cube,
			items = this.$prototype.$properties;

		// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
		// we used all the measures defined in the cube
		var measures = this._getRestraintMeasures(proto, $cube);
		if (measures) {
			forEachKey(measures, function(key, m) {
				// Because duplicate properties is possible for cube definition... we keep the last defined
				var code = (m.$property || key);
				//options.xAxis[0].categories.push(measure.$title || proto.$properties[code].$title || "???");
				var measure = _merge(m, items[code]);
				if (proto && proto.$item && proto.$item.$properties) {
					measure = _merge(measure, proto.$item.$properties[code]);
				}
				self._ensureFormatter(measure);

				var serie = self._meta.series[code] = {
					options: {
						id: '#s-' + code,
						// legendIndex: "",
						name: measure.$title === "" ? "" : self._localizedText(measure.$title) || '???',
						type: _style(measure.$style),
						visible: !! (!self._meta.displaysOneMeasure || measure.$isDefault)
					},
					measure: measure
				};

				if (!serie.options.visible) {
					debug && console.log("Highcharts._processMeasures: Serie '" + serie.options.name + "' is not visible");
				}

				if (measure.$isStacked || measure.$stackingGroup) {
					serie.options.stack = measure.$stackingGroup || 0; // a stack ID
					self._meta.stacking = measure.$isNormalized ? 'percent' : self._meta.stacking || 'normal';
				}
			});
		}
	},

	_getRestraintMeasures: function(proto, $cube) {
		var measures = $cube && $cube.$measures,
			restraintMeasures = measures;
		if (measures) {
			if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
				restraintMeasures = {};
				_.each(proto.$axes[1].$members[0][0], function(measureCode) {
					restraintMeasures[measureCode] = measures[measureCode];
				});
			}
		}
		return restraintMeasures;
	},

	_updateMeasures: function(metadata) {
		var self = this,
			proto = this.$prototype,
			$cube = metadata.$cube || proto.$cube,
			items = proto.$properties;

		var measures = this._getRestraintMeasures(proto, $cube);
		if (measures) {
			forEachKey(measures, function(key, m) {
				// Because duplicate properties is possible for cube definition... we keep the last defined
				var code = (m.$property || key);
				//options.xAxis[0].categories.push(measure.$title || proto.$properties[code].$title || "???");
				var measure = _merge(items[code], m);

				var serie = self._meta.series[code];
				if (serie) {
					serie.options.type = _style(measure.$style), serie.options.name = measure.$title === "" ? "" : self._localizedText(measure.$title) || '???';
				}

				if (measure.$isStacked || measure.$stackingGroup) {
					serie.options.stack = measure.$stackingGroup || 0; // a stack ID
					self._meta.stacking = measure.$isNormalized ? 'percent' : self._meta.stacking || 'normal';
				}
			});
		}
	},

	_ensureFormatter: function(measure) {
		measure.formatApi = measure.formatApi || _formatApi.getApi(measure.$type);
		measure.formatObj = measure.formatObj || _formatApi.getLocale().getNumberFormatObj(measure.$type);
		measure.localeFormat = measure.localeFormat || measure.$format || measure.formatObj.numFormat;
	},
	_processLinks: function(proto) {
		var meta = this._meta,
			xAxis = meta.xAxis && meta.xAxis[0],
			reprUrl = this.page.$prototype && this.page.$prototype.$representationUrl;
		meta.links = meta.links || {};
		proto.$links = proto.$links || {};

		if (reprUrl && !this.page.externalAdapter.fusionSite) {
			proto.$links.$pptslide = {
				"$title": this._localize.powerpointSlide,
				"$url": reprUrl + "&pptMode=newSlide&$bind=" + this.$item.$bind,
				"$type": httpHelper.mediaTypes.ppt_slide,
				"$confirm": this._localize.installOfficeAddin,
				"$officeAddinSetup": "/msoffice/lib/general/addIn/SyracuseOfficeAddinsSetup.EXE?&format=application/x-msi"
			};
		}

		this._applyLinks(proto, "$links");
		this._applyLinks(proto, "$actions");
		this._applyLinks(proto.$item, "$links");

		if (xAxis && xAxis.code && proto.$properties && proto.$properties[xAxis.code].$thumb && proto.$properties[xAxis.code].$thumb.$links) {
			this._applyLinks(proto.$properties[xAxis.code].$thumb, "$links");
		}

		meta.drillDownLink = this._getLink("$drillDown");
		meta.drillUpLink = this._getLink("$drillUp");
	},
	_getLink: function(name) {
		var meta = this._meta;
		return meta.links && meta.links[name] && this._getMenuItem(meta.links[name]);
	},
	_applyLinks: function(prop, col) {
		var self = this;
		if (col && prop && prop[col]) {
			forEachKey(prop[col], function(id, link) {
				// self._meta.links.push(self._getLinkDef(col, id, link));
				var lnk = self._meta.links[id];
				if (lnk) {
					forEachKey(link, function(k, v) {
						lnk[k] = v;
					});
				} else {
					self._meta.links[id] = self._getLinkDef(col, id, link);
				}
			}, self);
		}
	},
	_getMenuItem: function(link) {
		var links = {};
		var $link = links[link.id] = objectClone(link.link);
		// $link.$url = this.formatMenuUrl($link);
		return link && {
			$item: {
				$links: links
			}
		};
	},
	_processAxes: function(proto) {
		var cube = this.$prototype.$cube;
		if (!_isCubeValid(cube, proto)) return false;

		var self = this,
			currAxisHier = 0,
			axis0 = proto.$axes && proto.$axes[0];

		// TODO: review this
		// Get axis analysis
		var mainHLevelsTab = null;
		if (axis0) {
			forEachKey(axis0.$hierarchies, function(idx, hierarchy) {
				if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
					mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
					if (mainHLevelsTab) {
						self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
						currAxisHier = idx;
					}
				}
			});
			if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
				mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
				if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
			}
			// Get drill definition
			var properties;
			_.each(axis0.$hierarchies, function(hierarchie) {
				properties = cube.$hierarchies[hierarchie[0]].$properties;
				_.each(properties, function(property) {
					this.levelsProperties[this.maxLevel++] = property;
				}, self._meta.drill);
			});
			if (axis0.$members) {
				_.each(axis0.$members, function(tuple) {
					_.each(tuple, function(value) {
						if (value.length > 0) {
							this.members[this.currLevel++-1] = value[0];
						}
					}, this);
				}, self._meta.drill);
			}
		}
		self._meta.drill.code = proto.$codeStat || "UNKNOWN";
		self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";
		self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
	},

	// set graph style
	_setGraphStyle: function(cube, measures) {
		// Init
		var graphStyle = {},
		mDefault = null;
		var msCode = [],
			i = 0;
		var self = this;

		if (cube.$style == "pie") {
			_.each(measures, function(measure) {
				/*              msCode.push(measure.property);
                 if(measure.definition.$isDefault)
                 mDefault = measure.property;
                 */
			});
		} else {
			_.each(measures, function(measure) {
				/*
                 // So, "xy" style
                 switch (measure.definition.$style) {
                 case "stick":
                 break;
                 }
                 if(measure.definition.$isStacked) {
                 } else if(measure.definition.$isNormalized) {
                 }
                 if(measure.definition.$isDefault)
                 mDefault = measure.property;
                 msCode.push(measure.property);
                 */
			});
		}

		// Misc properties
		graphStyle.defaultMeasures = (!cube.$displaysOneMeasure ? msCode.join(";") : (mDefault ? mDefault : msCode[0]));
		graphStyle.hasMeasureSelector = !! cube.$hasMeasureSelector;
		graphStyle.hasStyleSelector = !! cube.$hasStyleSelector;

		return graphStyle;
	},
	// Build a syra link full description object (type : "$link", "$action"... id = "$edit", $delete, etc...)
	_getLinkDef: function(type, id, link) {
		return {
			"type": type,
			"id": id,
			"link": link,
			"title": this._localizedText(link.$title)
		};
	},
	_getPref: function() {
		// TODO: change default preference by using authoring mode
		var options = Highcharts.getOptions();
		return _merge(options, {
			// chart: {
			//     defaultSeriesType: 'column' // 'line', 'spline', 'area', 'areaspline', 'column', 'bar', 'pie', 'scatter',
			// },
			// credits: {
			//     enabled: false
			// },
			legend: {
				layout: 'vertical',
				align: 'left',
				verticalAlign: 'top',
				x: 100,
				y: 70,
				floating: true
			},
			// plotOptions: {
			//     column: {
			//         pointPadding: 0.2,
			//         borderWidth: 0,
			//         //stacking : 'normal',
			//     }
			// },
		});
	},

	_getMeasureLabel: function(measure, code) {
		// return cubeHelper.getMeasureLabel(measure, code, this.$prototype && this.$prototype.$properties);
		var label = this._localizedText(measure.$title);
		if (label) return label;
		var self = this;
		var item = self.$prototype.$properties[code];
		if (!item) return null;
		switch (item.$type) {
			case "application/x-choice":
				label = measure[code];
				item.$value.$enum.some(function(element, i, array) {
					if (element.$value === label) {
						label = this._localizedText(element.$title);
						return true;
					}
					return false;
				});
				break;
			case "application/x-date":
				item.formatApi = item.formatApi || _formatApi.getApi(item.$type);
				item.localeFormat = item.localeFormat || _formatApi.getLocale().getDateFormat(item.$format);
				label = datetime.parse(measure[code]).toString(item.localeFormat);
				break;
			case "application/x-integer":
			case "application/x-decimal":
				item.formatApi = item.formatApi || _formatApi.getApi(item.$type);
				item.formatObj = item.formatObj || _formatApi.getLocale().getNumberFormatObj(item.$type);
				item.localeFormat = item.localeFormat || item.$format || item.formatObj.numFormat;
				label = item.formatApi.format(measure[code], item.localeFormat);
				break;
			default:
				label = "" + measure[code];
				break;
		}
		return label;
	},
	_ensureChartRecord: function($item, recordIndex) {
		if (!this.recordArticle) {
			this.recordArticle = new TabularChartRecord();
			this.recordArticle.$prototype = this.$prototype.$item;
			this.recordArticle.dataset = this.dataset && this.dataset[recordIndex || 0] || {};
			this.page.initializeNewItem(this.recordArticle, {}, this);
			this.recordArticle.loadBox($item);
		} else {
			this.recordArticle.applyChange($item);
		}
		return this.recordArticle;
	},
	_execLink: function(link, recordIndex) {
		if (typeof link === "string") {
			var links = this._meta && this._meta.links;
			link = links && this._getMenuItem(links[link]);
		}
		debug && console.log("TabularChart._execLink: link.id=" + link.id + ", x=" + recordIndex);
		this._ensureChartRecord(link.$item, recordIndex);
		var menuItem = this.recordArticle.menuItems[Object.keys(link.$item["$links" || "$actions"])[0]][0];
		debug && console.log("TabularChart._execLink: url=" + menuItem.$url + "\nrecord=" + stringify(this.recordArticle.dataset));
		menuItem.click();
	},

	_showDrillUp: function(show) {
		//     if (show) {
		//         this._drillUpGroup.show();
		//     } else {
		//         this._drillUpGroup.hide();
		//     }
		// TODO: Does not work. Find an alternative
		// -----------------------------------------
		// var drillElt = this._chart.exportSVGElements && this._chart.exportSVGElements.filter(function(e) {
		//     return e.id === "drillUp";
		// });
		// if (!(drillElt[0] && drillElt[0].element)) return;
		// if (show) {
		//     drillElt[0].element.removeAttribute("display");
		// } else {
		//     drillElt[0].element.setAttribute("display", "none");
		// }
	},
	_drill: function(serie, up) {
		var self = this,
			cube = this.$prototype.$cube,
			meta = self._meta,
			i = meta.drill.currAxisHier,
			stack = self._meta.drill.stack;

		if (up && meta.drillUpLink) {
			return this._execLink(meta.drillUpLink);
		} else if (!up && meta.drillDownLink) {
			return this._execLink(meta.drillDownLink, serie.x);
		}

		if (up) {
			// already on top ?
			if (stack.length < 2) return;
			stack.shift();
			meta.drill.currAxisHier--;
			self._showDrillUp(meta.drill.currAxisHier > 0);
			self._fetch(stack[0]);
			return;
		}

		var proto = stack[0],
			axis0 = proto.$axes && proto.$axes[0];

		if (!axis0) return;

		var members = axis0.$members = (axis0.$members || []);

		stack.unshift(objectClone(proto, true));
		proto = stack[0];
		axis0 = proto.$axes && proto.$axes[0];
		members = axis0.$members;
		var hierarchies = axis0.$hierarchies;

		var hierName = hierarchies[i][0],
			cubeHier = cube.$hierarchies[hierName];
		if (hierarchies[i][2] == (cubeHier.$properties ? cubeHier.$properties.length - 1 : -1)) {
			hierarchies[i].splice(1, 2, 0, 0);
			hierarchies[i + 1].splice(1, 2, 1, 0);
			meta.drill.currAxisHier++;
		} else {
			hierarchies[i][2]++;
		}
		if (members.length < i + 1) {
			members[i] = [];
		}
		var rawData = this.dataset && this.dataset[serie.x],
			member = rawData && (rawData[hierName] + "");

		// use the raw data from the dataset instead of serie.name because this one can be formatted
		members[i].push([member]);

		self._showDrillUp(meta.drill.currAxisHier > 0);

		this._fetch(proto);
	},
	_fetch: function(proto) {
		this.fetch({
			jsonParams: {
				$axes: proto.$axes,
				$slicer: proto.$slicer
			}
		});
	},

	// --------------------------------------------------------------------------------
	// Event management
	// --------------------------------------------------------------------------------
	_onMeasureClick: function(context) {
		var self = this;
		var event = context.event || {},
		data = context.data || {},
		line = data.x + 1;

		if (!self.attachedField.$isDisabled) {
			if (self.page.externalAdapter.fusionSite) {
				self.page.externalAdapter.onGraphClickPicker({
					field: self,
					rcdUuid: line,
					pickerType: "menus",
					grapLevel: "measure",
					doEvent: function(err, menus) {
						var $links = {},
						menuCount = menus && menus.length || 0;
						if (menuCount === 0) {
							return;
						}
						for (var ii = 0; ii < menuCount; ii++) {
							$links["link-" + ii] = menus[ii];
						}
						self._ensureChartRecord({}, data.x).openMenuBox({
							$links: $links
						}, event, function(menuItem) {
							var data = {
								field: self,
								link: {
									linkCtx: menuItem.linkCtx || "",
									linkId: menuItem.linkId
								}
							};

							if (self.page.externalAdapter.onGraphClickLink(data)) {
								// We should never come here in a Convergence context!!!
								// debug && console.log("onGraphClickLink returns true!!!")
								// self._execLink(menuItem);
							}
							return false;
						});
					}
				});
			} else {
				// no longer drill up if shiftKey is pressed
				if (!event.shiftKey) self._drill(data, event.shiftKey);
			}
		}

	},
	// --------------------------------------------------------------------------------
	// Chart management
	// --------------------------------------------------------------------------------
	_setChart: function(categories, series, data) {
		var self = this;
		throw new Error('_setChart NIY');
		/*
         self._chart.xAxis[0].setCategories(categories);
         self._chart.series[0].remove();
         self._chart.addSeries({
         name : name,
         proto : proto,
         //color : color || 'red'
         });
         */
	},

	_setStyle: function(type) {
		var self = this,
			count = Object.keys(self._meta.series).length,
			size = 80,
			slice = Math.round(size / count);
		forEachKey(self._meta.series, function(key, s) {
			s.type = type;
			if (self._chart) {
				var serie = self._chart.get(s.options.id);
				if (serie) {
					self._setType(serie, type, size, size - slice);
					size -= slice;
				}
			}
		});
		self._redraw();
	},

	_setType: function(serie, type, size, innerSize) {
		var self = this,
			chart = serie.chart;
		var s = {
			id: serie.options.id,
			type: type,
			name: serie.name,
			data: serie.options.data,
			visible: serie.visible,
			stack: serie.stack,
			color: serie.color
		};
		var opt = {
			type: type
		};

		if (type === "spiderweb") {
			// chart.polar = true;
			// chart.type = 'area';
			// delete options.xAxis[0].title;
			// options.xAxis[0] = _merge(options.xAxis[0], {
			//     tickmarkPlacement: 'on',
			//     lineWidth: 0
			// });
			// delete options.xAxis[0].labels;
			// delete options.yAxis;
			// options.yAxis = {
			//     gridLineInterpolation: 'polygon',
			//     lineWidth: 0,
			//     // min: 0
			// };
		} else if (type === "pie") {
			opt = s;
			opt.size = size + "%";
			opt.innerSize = innerSize + "%";
			opt.showInLegend = false;
			opt.dateLabels = {
				enabled: false
			};
			this._meta.cache = this._meta.cache || {};
			this._meta.cache.xAxis = chart.xAxis;
			delete chart.xAxis;
		} else if (!chart.xAxis) {
			s.showInLegend = true;
			s.dateLabels = {
				enabled: true
			};
			chart.xAxis = self._meta.cache.xAxis;
		}
		serie.remove();
		chart.addSeries(s, false);
		// serie.update(opt);
	},

	destroy: function() {
		this._chart && this._chart.destroy();
	}
});

function _isCubeValid(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
	proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
}