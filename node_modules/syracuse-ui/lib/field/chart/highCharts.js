"use strict";
var helpers = require('syracuse-core/lib/helpers');
var RecordArticle = require("syracuse-ui/lib/field/array/recordArticle").RecordArticle;
var datetime = require('syracuse-core/lib/types/datetime');
var cubeHelper = require('syracuse-ui/lib/field/chart/cubeHelper');
var ChartArticle = require("./chartArticle").ChartArticle;
var syraUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Syra;

var forEachKey = helpers.object.forEachKey;
var _formatApi = require('syracuse-ui/lib/field/formatApi');

/*****************************************************************
 exporting.src updated for print : add syra_site.resize
 ******************************************************************/
var _style = (function() {
	var map = {
		xy: "line",
		point: "scatter",
		stick: "column",
		radar: "spiderweb"
	};

	return function($style) {
		return $style && (map[$style] || $style);
	};
})();

function delayed(obj, name, cb, delay) {
	var tm = "timer_" + name;
	if (obj[tm])
		clearTimeout(obj[tm]);
	obj[tm] = setTimeout(cb, delay || 100);
}

function mergeChanges(update, chartSerie, serie) {
	["name", "type", "color", "visible"].map(function(key) {
		if (chartSerie[key] !== serie[key]) {
			update[key] = serie[key];
		}
	});
}

function _mergeMetaData(article, metadata) {
	var m = {};
	if (metadata && metadata.$cube)
		m.$cube = metadata.$cube;
	if (metadata && metadata.$axes)
		m.$axes = metadata.$axes;
	if (metadata && metadata.$style)
		m.$style = metadata.$style;
	if (metadata && metadata.$color)
		m.$color = metadata.$color;
	article.currentMetaData = Highcharts.merge(article.currentMetaData || {}, m);

	if (metadata && metadata.$item && metadata.$item.$properties && article.currentMetaData && article.currentMetaData.$cube && article.currentMetaData.$cube.$measures) {
		forEachKey(article.currentMetaData.$cube.$measures, function(key, m) {
			if (metadata.$item.$properties[key] && metadata.$item.$properties[key].$title) {
				m.$title = metadata.$item.$properties[key].$title;
			}
		});
	}
	return article.currentMetaData;
}

function _processMeasures(article, metaData, init) {
	_mergeMetaData(article, metaData);
	var items = article.$prototype.$properties;

	// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
	// we used all the measures defined in the cube
	var proto = article.currentMetaData,
		$cube = proto.$cube,
		$measures = $cube && $cube.$measures,
		measures = $measures;
	if ($measures) {
		if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
			measures = {};
			_.each(proto.$axes[1].$members[0][0], function(measureCode) {
				measures[measureCode] = $measures[measureCode];
			});
		}
	}

	var icolor = 0;
	if (measures) {
		forEachKey(measures, function(key, m) {
			// Because duplicate properties is possible for cube definition... we keep the last defined
			var code = (m.$property || key);
			var measure = Highcharts.merge(items[code], m);
			if (metaData && metaData.$item && metaData.$item.$properties) {
				measure = Highcharts.merge(measure, metaData.$item.$properties[code]);
			}
			// measures[key] = measure;
			var serie = article._meta.series[code];

			if (init) {
				_ensureFormatter(measure);
				serie = article._meta.series[code] = {
					options: {
						id: '#s-' + code,
						// legendIndex: "",
						name: article.getLocalizeText(measure.$title) || String.fromCharCode(160),
						// visible: measure.$title !== "" && !!(!article._meta.displaysOneMeasure || measure.$isDefault)
					},
					measure: measure
				};
			}
			if (serie) {
				serie.isHidden = measure.$title === "";
				serie.options.type = _style(measure.$style);
				serie.options.color = measure.$color || Highcharts.theme.colors[icolor++];
				serie.options.name = article.getLocalizeText(measure.$title) || String.fromCharCode(160);
				serie.options.visible = measure.$title !== "" && !! (!article._meta.displaysOneMeasure || measure.$isDefault);
			}
			if (measure.$isStacked || measure.$stackingGroup) {
				serie.options.stack = measure.$stackingGroup || 0; // a stack ID
				article._meta.stacking = measure.$isNormalized ? 'percent' : article._meta.stacking || 'normal';
			}
		});
	}
}


function _processAxes(article, proto, init) {
	var cube = article.$prototype.$cube;
	if (_isCubeValid(cube, proto)) {
		var currAxisHier = 0,
			axis0 = proto.$axes && proto.$axes[0];
		// TODO: review this
		// Get axis analysis
		var mainHLevelsTab = null;
		if (axis0) {
			forEachKey(axis0.$hierarchies, function(idx, hierarchy) {
				if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
					mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
					if (mainHLevelsTab) {
						article._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
						currAxisHier = idx;
					}
				}
			});
			if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
				mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
				if (mainHLevelsTab && mainHLevelsTab.length > 0)
					article._meta.xAxis[0].code = mainHLevelsTab[0];
			}
			// Get drill definition
			var properties;
			_.each(axis0.$hierarchies, function(hierarchie) {
				properties = cube.$hierarchies[hierarchie[0]].$properties;
				_.each(properties, function(property) {
					this.levelsProperties[this.maxLevel++] = property;
				}, article._meta.drill);
			});
			if (axis0.$members) {
				_.each(axis0.$members, function(tuple) {
					_.each(tuple, function(value) {
						if (value.length > 0) {
							this.members[(this.currLevel++) - 1] = value[0];
						}
					}, this);
				}, article._meta.drill);
			}
		}
		article._meta.drill.code = proto.$codeStat || "UNKNOWN";
		article._meta.drill.axis0FieldCode = article._meta.xAxis[0].code || "";
		article._meta.drill.maxLevel = Math.max(article._meta.drill.maxLevel, article._meta.drill.minLevel);
	}
}

function _ensureFormatter(measure) {
	measure.formatApi = measure.formatApi || _formatApi.getApi(measure.$type);
	measure.formatObj = measure.formatObj || _formatApi.getLocale().getNumberFormatObj(measure.$type);
	measure.localeFormat = measure.localeFormat || measure.$format || measure.formatObj.numFormat;
}

function _applyLinks(article, prop, col) {
	if (col && prop && prop[col]) {
		forEachKey(prop[col], function(id, link) {
			var lnk = article._meta.links[id];
			if (lnk) {
				forEachKey(link, function(k, v) {
					lnk[k] = v;
				});
			} else {
				article._meta.links[id] = {
					"type": col,
					"id": id,
					"link": link,
					"title": article.getLocalizeText(link.$title)
				};
			}
		}, article);
	}
}

function _pushData(article, serie, categoryName, key, data) {
	var val = parseFloat(data.$rawV && data.$rawV[key] && data.$rawV[key].v || data[key]) || 0;
	if (article.useLogarithmicAxis) {
		article.maxValue = Math.max(article.maxValue || -Infinity, val);
		article.minValue = Math.min(article.maxValue || Infinity, val);
	}
	serie.data.push([categoryName, val]);
}

function _settingsFromValue(article) {
	var $cube = article.currentMetaData.$cube,
		icolor = 0,
		settings;
	if ($cube.$style === "spiderweb") {
		settings = {};
		settings.categories = Object.keys(article._meta.series).map(function(key) {
			return article._meta.series[key].options.name;
		});

		settings.series = {};
		article.dataset &&
			article.dataset.reduce(function(res, current) {
				var serie = {
					name: _getMeasureLabel(article, current, article._meta.xAxis[0].code),
					color: Highcharts.theme.colors[icolor++],
					data: [],
					pointPlacement: 'on'
				};
				if (serie.name) {
					serie.id = "#s-" + serie.name;
					forEachKey(article._meta.series, function(key, s) {
						if (!s.isHidden)
							_pushData(article, serie, key, key, current);
					});
					res.series[serie.name] = serie;
				}
				return res;
			}, settings);
	} else {
		settings = {
			categories: [],
			series: {}
		};
		article.dataset &&
			article.dataset.reduce(function(res, current) {
				var $bindSelector = article.currentMetaData.$cube.$displaySelector;
				var displaySelectoValue = $bindSelector ? (current[$bindSelector] == "0" || current[$bindSelector] == "") : true;
				var categoryName = _getMeasureLabel(article, current, article._meta.xAxis[0].code);
				if (categoryName != null) {
					if (displaySelectoValue) {
						res.categories.push(categoryName);
					}
					forEachKey(article._meta.series, function(key, s) {
						var serie = res.series[key];
						if (!serie) {
							serie = helpers.object.clone(s.options);
							serie.data = [];
							res.series[key] = serie;
						}
						if (displaySelectoValue) {
							_pushData(article, serie, categoryName, key, current);
						}
					});
				}
				return res;
			}, settings);
	}
	return settings;
}

function _canDrill(meta, up) {
	var i = meta.drill.currAxisHier,
		stack = meta.drill.stack,
		proto = stack[0],
		axis0 = proto.$axes && proto.$axes[0],
		hierarchies = axis0.$hierarchies || [];
	return up && (meta.drillUpLink || stack.length > 1) || !up && (meta.drillDownLink || (axis0 && i < hierarchies.length - 1));
}

function _fetch(article, proto) {
	article.page.fetch({
		jsonParams: {
			$axes: proto.$axes,
			$slicer: proto.$slicer
		}
	});
}

function _displayLegend(article, display) {
	var legend = article._chart.legend;
	if (legend && legend.options && legend.options.enabled) {
		if (display) {
			legend.group.show();
			legend.box.show();
			article.__highlight(article._chart);
		} else {
			legend.group.hide();
			legend.box.hide();
		}
		article.displayLegend = legend.display = display;
	}
}

function _setType(article, serie, type, size, innerSize) {
	var chart = serie.chart;
	var s = {
		id: serie.options.id,
		type: type,
		name: serie.name,
		data: serie.options.data,
		visible: serie.visible,
		stack: serie.stack,
		color: serie.color
	};
	var opt = {
		type: type
	};

	if (type === "spiderweb") {
		// chart.polar = true;
		// chart.type = 'area';
		// delete options.xAxis[0].title;
		// options.xAxis[0] = Highcharts.merge(options.xAxis[0], {
		//     tickmarkPlacement: 'on',
		//     lineWidth: 0
		// });
		// delete options.xAxis[0].labels;
		// delete options.yAxis;
		// options.yAxis = {
		//     gridLineInterpolation: 'polygon',
		//     lineWidth: 0,
		//     // min: 0
		// };
	} else
	if (type === "pie") {
		opt = s;
		opt.size = size + "%";
		opt.innerSize = innerSize + "%";
		opt.showInLegend = false;
		opt.dateLabels = {
			enabled: false
		};
		article._meta.cache = article._meta.cache || {};
		article._meta.cache.xAxis = chart.xAxis;
		delete chart.xAxis;
	} else
	if (!chart.xAxis) {
		s.showInLegend = true;
		s.dateLabels = {
			enabled: true
		};
		chart.xAxis = article._meta.cache.xAxis;
	}
	serie.remove();
	chart.addSeries(s, false);
	// serie.update(opt);
}


function _getMeasureLabel(article, measure, code) {
	var label = article.getLocalizeText(measure.$title);
	if (!label) {
		var item = article.$prototype.$properties[code];
		if (!item)
			return null;
		switch (item.$type) {
			case "application/x-choice":
				label = measure[code];
				item.$value.$enum.some(function(element, i, array) {
					if (element.$value === label) {
						label = article.getLocalizeText(element.$title);
						return true;
					}
					return false;
				});
				break;
			case "application/x-date":
				item.formatApi = item.formatApi || _formatApi.getApi(item.$type);
				item.localeFormat = item.localeFormat || _formatApi.getLocale().getDateFormat(item.$format);
				label = datetime.parse(measure[code]).toString(item.localeFormat);
				break;
			case "application/x-integer":
			case "application/x-decimal":
				item.formatApi = item.formatApi || _formatApi.getApi(item.$type);
				item.formatObj = item.formatObj || _formatApi.getLocale().getNumberFormatObj(item.$type);
				item.localeFormat = item.localeFormat || item.$format || item.formatObj.numFormat;
				label = item.formatApi.format(measure[code], item.localeFormat);
				break;
			default:
				label = "" + measure[code];
				break;
		}
	}
	return label;
}

function TabularChart() {
	this.useLogarithmicAxis = false;
}

exports.TabularChart = helpers.defineClass(TabularChart, ChartArticle, {
	loadBox: function(initData) {
		var self = this;
		require.async('syracuse-ui/deps/highcharts/highcharts.src', function(err, module) {
			require.async('syracuse-ui/deps/highcharts/highcharts-more.src', function(err, module) {
				require.async('syracuse-ui/deps/highcharts/draggable-legend', function(err, module) {
					require.async('syracuse-ui/deps/highcharts/modules/exporting.src', function(err, module) {
						require.async('syracuse-ui/themes/desktop/highcharts/theme', function(err, module) {
							Highcharts.setOptions(Highcharts.theme = module.theme);
							self.isLoaded = true;
							ChartArticle.prototype.loadBox.call(self, initData);
							self.applyDesignMetaData(self.attachedField.$item);
							if (self.isDatabindRequested) {
								var $bind = self.attachedField.$item.$bind;
								var dataset = self.articleParent.dataset;
								self.setDataBind(dataset[$bind], dataset, dataset.$properties && dataset.$properties[$bind], $bind);
								delete self.isDatabindRequested;
							}
							if (self.page && self.page.dialogWrapper) {
								self.page.resizeArticle();
							}
						});
					});
				});
			});
		});
	},
	setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		if (this.isLoaded) {
			ChartArticle.prototype.setDataBind.call(this, dataRecordSet, parentDataRecord, metaData);
		} else {
			this.isDatabindRequested = true;
		}
	},
	resizeChart: function() {
		if (this._chart && this._chart.container) {
			var self = this;
			if (this.resizeTimer)
				clearTimeout(this.resizeTimer);
			this.resizeTimer = setTimeout(function() {
				if (self._chart && self._chart.container && !self._chart.isResizing) {
					if (self.layoutSlot.clientWidth) {
						var height = Math.max(self._chart.chartHeight || self.layoutSlot.style.clientHeight || self.layoutSlot.clientHeight, 250);
						self._chart.setSize(self.layoutSlot.clientWidth, height);
						self._redraw();
						if (self.currentMetaData.$cube.$displaysOneMeasure) {
							self._selectChartMeasure();
						}
					}
				}
			}, 200);
		}
	},
	applyDesignMetaData: function(metadata) {
		var self = this;
		if (self.isLoaded) {
			_processMeasures(self, metadata);
			if (self._chart) {
				var meta = self._meta,
					chart = self._chart,
					designMeta = self.currentMetaData,
					needRefresh = false,
					needInverted = false;
				if (meta && designMeta.$style) {
					var count = Object.keys(self._meta.series).length,
						size = 80,
						slice = Math.round(size / count);
					forEachKey(self._meta.series, function(key, s) {
						s.type = designMeta.$style;
						if (self._chart) {
							var serie = self._chart.get(s.options.id);
							if (serie) {
								_setType(self, serie, designMeta.$style, size, size - slice);
								size -= slice;
							}
						}
					});
					self._redraw();
				}
				if (meta && designMeta.$cube && designMeta.$cube.$measures) {
					forEachKey(designMeta.$cube.$measures, function(k, m) {
						var s = meta.series[k],
							serie = chart.get(s.options.id);

						if (serie) { //Hack lv to avoid error. waiting best fix if necessary (change style is not used for this)
							if (m.$style || m.$color) {
								needRefresh = true;
								var newOpt = {};
								if (m.$style) {
									newOpt.type = _style(m.$style);
								}
								if (m.$color) {
									newOpt.color = m.$color;
								}
								serie.update(newOpt, false);
							}
						}
					});
					// Default Highcharts behavior is to invert axes if a serie of bar type is present among all series
					chart.series.forEach(function(s) {
						needInverted = needInverted || s.type === "bar";
					});
					if (chart.inverted ? !needInverted : needInverted) {
						self._chart.destroy();
						self._chart = null;
						self._createChart(_settingsFromValue(self));
					} else {
						needRefresh && self._redraw();
					}
				}
			}
		}
	},

	drawBox: function() {
		ChartArticle.prototype.drawBox.call(this);
		this._processMeta = this.__processMeta;
		this.dataset = null;
		this.designGraphType = "cube$highCharts";
		this.$localization = this.articleParent.$prototype.$localization;
		// this._cube = cube(this);
		_mergeMetaData(this, this.$prototype);
		_mergeMetaData(this, this.$item);

		var proto = this.$prototype;
		var cube = this.currentMetaData;

		this._meta = {
			xAxis: [{}],
			series: {},
			displaysOneMeasure: cube && cube.$displaysOneMeasure,
			hasMeasureSelector: cube && cube.$hasMeasureSelector,
			hasStyleSelector: cube && cube.$hasStyleSelector,
			defaultStyle: _style(cube.$style) || 'column',
			drill: {
				minLevel: 1,
				maxLevel: 0,
				currLevel: 1,
				currAxisHier: 0,
				levelsProperties: [],
				members: [],
				stack: [{
					$axes: proto.$axes,
					$item: proto.$item,
					$slicer: proto.$slicer
				}]
				/*              code: proto.$codeStat || "UNKNOWN",
                 axis0FieldCode: self._meta.xAxis[0].code || ""*/
			}
		};
		this.__processMeta(proto, true);
		this._createMenuContainer();

		if (!this.$item.$isListEmbeded) {
			this.articleParent.bind(this, this.$item.$bind);
		}
	},
	__highlight: function(chart) {
		$(chart.series).each(function(i, serie) {
			if (serie.legendItem) {
				serie.legendItem.element.onmouseover = function() {
					highlight(chart.series, serie.index, true);
				};
				serie.legendItem.element.onmouseout = function() {
					highlight(chart.series, serie.index, false);
				};
			}
		});

		function highlight(series, index, hil) {
			var s = (chart.options.chart.type === "area") ? series[index].area.element.style : null;
			if (hil) {
				series[index].group.toFront();
				if (s) {
					s.fillOpacity = "0.6";
				}
			} else {
				if (s) {
					s.fillOpacity = "";
				}
			}
		}
	},
	getEnumeration: function(code) {
		var $fusionController = syraUtil.getFusionController(this),
			fusionSess = $fusionController ? $fusionController.getSession() : null;
		return fusionSess && code ? fusionSess.getMenloc(code) : null;
	},
	__setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		var settings;
		if (this.dataset && this.dataset.length > 0) {
			settings = _settingsFromValue(this);
		}
		if (settings) {
			if (!this._chart) {
				this._createChart(settings);
			} else {
				var self = this;
				self._chart.xAxis && self._chart.xAxis[0].setCategories(settings.categories, false);

				var series = self._chart.series;
				if (series && series.length == 1 && series[0].name) {
					self._chart.xAxis && self._chart.xAxis[0].options && self._chart.xAxis[0].options.title && (self._chart.xAxis[0].options.title.text != series[0].name) && (self._chart.xAxis[0].options.title.text = series[0].name);
				}
				if (self._chart.options.chart.polar) {
					for (var j = series.length - 1; j >= 0; j--) {
						series[j].remove(false);
					}
				}
				if (!series || series.length === 0) {
					forEachKey(settings.series, function(key, s) {
						if (!s.isHidden) {
							self._chart.addSeries(settings.series[key], false);
						}
					});
				} else {
					var toRemove = [];
					for (var ii = 0, len = series.length; ii < len; ii++) {
						var chartSerie = series[ii],
							key = chartSerie.options.id.slice(3),
							serie = settings.series[key],
							update = {};
						// Update series options before setting new data because of an Highcharts issue that restores old values
						mergeChanges(update, chartSerie, serie);
						if (Object.keys(update).length) {
							chartSerie.update(update, false);
						}
						if (serie.isHidden) {
							toRemove.push(chartSerie);
						} else {
							chartSerie.setData(serie.data, false);
						}
						// serie.data = [];
					}
					toRemove.map(function(s) {
						s.remove();
					});
				}
				if (this.useLogarithmicAxis) {
					var yAxisType = 'linear';
					if ((this.maxValue || 0) / (this.minValue || 1) > 10) {
						yAxisType = 'logarithmic';
					}
					if (self._chart.yAxis[0].type !== yAxisType) {
						self._chart.yAxis[0].update({
							type: yAxisType
						});
					}
				}
				self._redraw();
			}
		} else {
			if (this._chart) {
				this._chart.destroy();
				this._chart = null;
			}
		}

		this._showDrillUp(false);
	},

	_createMenuContainer: function() {
		//  var $$menu = $("<div>").appendTo(this.$$container);
		// // $$menu.addClass();
		// $$menu.attr("style", "position: absolute; z-index: 1000; padding: 24px; display: none; right: -14px; top: 10px;");
		// $$menu.append("<div>");
		// <div class="s-field-menus-popup" style="position: absolute; z-index: 106; top: 111.5px; left: 34px;" id="a6afea62-897d-49e7-a532-f82ca3df2af4">
		//   <div class="s-field-menus-slot">
		//     <nav class="s-list-menus">
		//       <ul style="" class="s-list-menus-body">
		//         <li class="s-list-menus-li"><a style="" class="s-list-menus-link" data-s-menu="18-4" data-s-article="18-1" title="Créer une diapositive Powerpoint" target="blank" href="/sdata/x3stb/erp/stubs/HighCharts?representation=HighCharts.$query&amp;pptMode=newSlide&amp;format=application/syracuse-ppt-slide">
		//           <div class="s-list-menus-link-icon" style="background-image: url(&quot;/syracuse-ui/themes/desktop/desktop/images/file/s-link-syracuse-ppt-slide.png&quot;);"></div>
		//           <div class="s-list-menus-link-label s-external">Créer une diapositive Powerpoint</div>
		//           </a>
		//         </li>
		//       </ul>
		//     </nav>
		//   </div>
		// </div>
		// $$menu.
		// <div class="highcharts-menu0" style="position: absolute; z-index: 1000; padding: 24px; display: none; right: -14px; top: 10px;">
		//   <div style="box-shadow: 3px 3px 10px rgb(136, 136, 136); border: 1px solid rgb(160, 160, 160); background: none repeat scroll 0% 0% rgb(255, 255, 255);">
		//     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download PNG image</div>
		//     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download JPEG image</div>
		//     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download PDF document</div>
		//     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download SVG vector image</div>
		//   </div>
		// </div>
	},


	_createChart: function(settings) {
		var self = this,
			options = Highcharts.merge(self._getPref(), self._getOptions(self.$prototype));
		var hasBar;
		if (settings) {
			options.xAxis[0].categories = settings.categories;
			forEachKey(settings.series, function(key, s) {
				var serie = helpers.object.clone(s),
					serieMeta = self._meta.series[key];
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				if (!(serieMeta && serieMeta.isHidden)) {
					if (serie.type == "bar") {
						hasBar = true;
					}
					options.series.push(serie);
				}
			});
		} else {
			forEachKey(self._meta.series, function(key, s) {
				var serie = helpers.object.clone(s.options);
				if (options.chart.polar && serie && serie.type) {
					delete serie.type;
				}
				serie.data = [0];
				if (!s.isHidden) {
					if (serie.type == "bar") {
						hasBar = true;
					}
					options.series.push(serie);
				}
			});
		}
		options.navigation = options.navigation || {};
		options.navigation.buttonOptions = options.navigation.buttonOptions || {};
		options.navigation.buttonOptions.align = syra_site.isDocumentRTL ? "left" : "right";

		options.legend = options.legend || {};
		options.legend.useHTML = syra_site.isDocumentRTL;
		options.legend.align = syra_site.isDocumentRTL ? "left" : "right", options.legend.rtl = syra_site.isDocumentRTL;

		if (options.tooltip) {
			options.tooltip.useHTML = syra_site.isDocumentRTL;
		}
		var xAxis = options.xAxis = options.xAxis && options.xAxis[0];
		if (xAxis && xAxis.title) {
			options.series && (options.series.length == 1) && (xAxis.title.text = options.series[0].name);
			xAxis.title.useHTML = syra_site.isDocumentRTL;
		}
		var yAxis = options.yAxis = options.yAxis && options.yAxis[0];
		if (yAxis) {
			if (yAxis.title) {
				yAxis.title.useHTML = syra_site.isDocumentRTL;
			}
			if (yAxis.labels) {
				yAxis.labels.useHTML = syra_site.isDocumentRTL;
			}
		}
		if (hasBar) {
			if (xAxis) {
				xAxis.opposite = syra_site.isDocumentRTL;
				if (xAxis.labels) {
					xAxis.labels.align = syra_site.isDocumentRTL ? "left" : "right";
					xAxis.labels.useHTML = syra_site.isDocumentRTL;
				}
			}
			if (yAxis) {
				yAxis.reversed = syra_site.isDocumentRTL;
				if (yAxis.labels) {
					yAxis.labels.align = syra_site.isDocumentRTL ? "left" : "right";
				}
			}
		} else {
			if (xAxis) {
				xAxis.reversed = syra_site.isDocumentRTL;
				if (xAxis.labels) {
					xAxis.labels.align = syra_site.isDocumentRTL ? "left" : "right";
				}
			}
			if (yAxis) {
				yAxis.opposite = syra_site.isDocumentRTL;
				if (yAxis.labels) {
					yAxis.labels.align = syra_site.isDocumentRTL ? "left" : "right";
				}
			}

		}
		if (!(self.$prototype.$cube && self.$prototype.$cube.$style == "spiderweb")) {
			options.series.reverse();
		}
		if (this.useLogarithmicAxis) {
			if ((this.maxValue || 0) / (this.minValue || 1) > 10) {
				options.yAxis.type = 'logarithmic';
			}
		}
		self._chart = new Highcharts.Chart(options);

		var legend = this._chart.legend;
		self.displayLegend = self.currentMetaData.$cube.$displaysOneMeasure ? false : legend && legend.display;

		var chartSeries = self._chart.series,
			serie, serieMeta;
		for (var j = chartSeries.length - 1; j >= 0; j--) {
			serie = chartSeries[j];
			serieMeta = serie && serie.options.id && self._meta.series[serie.options.id.slice(3)];
			if (serieMeta && serieMeta.measure) {
				serieMeta.measure.$color = serieMeta.options.color = serie.color;
			}
		}

		this._showDrillUp(false);

		if (self.currentMetaData.$cube.$displaysOneMeasure) {
			self._selectChartMeasure();
		}
	},
	_selectChartMeasure: function() {
		var self = this;
		var comboDiv = self.layoutSlot.getElementsByClassName("s-high-chart-combo")[0];
		self.layoutSlot.style.position = "relative";

		var rect = self.layoutSlot.getBoundingClientRect();
		var graphElement = self.layoutSlot.getElementsByClassName("highcharts-grid");
		var graphRect = graphElement.length ? graphElement[0].getBoundingClientRect() : rect;

		if (comboDiv) {
			comboDiv.style.left = (graphRect.left - rect.left) + 10 + "px";
			return;
		}

		comboDiv = document.createElement("div");
		comboDiv.className = "s-high-chart-combo";
		comboDiv.style.left = (graphRect.left - rect.left) + 10 + "px";
		self.layoutSlot.appendChild(comboDiv);

		var $enums = [];
		for (var ii = 0, jj = self._chart.series.length; ii < jj; ii++) {
			var item = self._chart.series[ii];
			$enums.push({
				$value: ii,
				$title: item.name
			});
			item.setVisible(ii === 0, true);
		}

		self.choice = self.page.loadNewItem(comboDiv, {
			$title: syra_local.select_measure,
			$bind: "$seriesChoice",
			$category: "field",
			$isEditMode: true,
			$inplace: false,
			$format: "$combo",
			$field: {
				$type: "application/x-choice",
				$maxLength: 15,
				$value: {
					$type: "application/x-string",
					$enum: $enums
				}
			}
		});

		self.choice.chart = self._chart;
		self.choice.setDataValue(0);
		self.choice.setDatasetValue = function(selectedIndex) {
			for (var ii = 0, jj = self._chart.series.length; ii < jj; ii++) {
				self._chart.series[ii].setVisible(ii == selectedIndex, true);
			}
		};
	},
	_setSerie: function(id) {
		this._chart.series.map(function(s) {
			s.hide();
		});
		this._chart.get(id).show();
	},
	_redraw: function() {
		if (!this.layoutSlot || !this._chart || this.layoutSlot.style.display === "none") {
			return;
		}
		this._chart.redraw();
		_displayLegend(this, this.displayLegend);
	},
	_getFieldEvalTitle: function() {
		return this.page.externalAdapter.getFieldEvalTitle(this) || [];
	},
	_getOptions: function(proto) {
		var self = this,
			$cube = this.currentMetaData.$cube,
			defOptions = Highcharts.getOptions(),
			buttons = defOptions.exporting.buttons,
			measuresTitle = this._getFieldEvalTitle(),
			axe = proto.$axes && proto.$axes[0] || {}, axeTitle = axe.$hierarchies && measuresTitle[axe.$hierarchies[0][0]] || axe.$title,
			enuml;
		var options = {
			chart: {
				renderTo: this.layoutSlot,
				// marginLeft: 30,
				// marginRight: 150,
				// witdh: self.layoutSlot.clientWidth,
				// height: self.layoutSlot.style.clientHeight
				zoomType: 'x',
				ignoreHiddenSeries: false
			},
			lang: {
				showHideLegend: syra_local.highCharts_showHideLegend,
				drillDown: syra_local.highCharts_drillDown,
				drillUp: syra_local.highCharts_drillUp
			},
			legend: {
				layout: 'vertical',
				verticalAlign: 'top',
				y: 60,
				x: -10,
				floating: true,
				draggable: true,
				zIndex: 20
			},
			title: ($cube && self.getLocalizeText($cube.$title)) || '',

			xAxis: [{
				categories: [],
				title: {
					text: self.getLocalizeText(axeTitle)
				},
				labels: {
					rotation: -45,
					// style: {
					//     fontSize: '13px',
					//     fontFamily: 'Verdana, sans-serif'
					// }
				}
			}],

			yAxis: [{
				title: {
					text: ''
				},
				labels: {}
				// type: 'logarithmic',
			}],

			plotOptions: {
				series: {
					cursor: 'pointer',
					events: { // legendItemClick: function(e) {
						//     // use e.mousePageX and e.mousePageY for mouse coordinates
						//     console.log("legendItemClick: (" + e.mousePageX + ", " + e.mousePageY + ")");
						// }
					},
					point: {
						events: {
							click: function(event) {
								var s = this;
								setTimeout(function() {
									self._onMeasureClick({
										data: s,
										event: event
									});
								}, 100);
							}
						}
					},
					stacking: self._meta.stacking
				}
			},

			tooltip: {
				formatter: function() {
					var seriesMeta = self._meta.series,
						serie = this.key && seriesMeta[this.key] || seriesMeta[this.series.options.id.slice(3)],
						measure = serie && serie.measure,
						data = this.series.processedYData,
						y = this.y;

					measure && _ensureFormatter(measure);

					var label = this.series.name || measure && measure.$title,
						mformat = measure && measure.formatApi,
						mlocale = measure && measure.localeFormat;
					label = (label ? label + "<br>" : "") + (this.x || this.key) + ': <b> ' + (mformat ? mformat.format(y, mlocale) : y) + '</b>';
					if (measure && (measure.$isNormalized) && data.length > 0) {
						var sum = data.reduce(function(a, b) {
							return a + b;
						});
						label += ' (' + (mformat ? mformat.format(y / sum * 100, mlocale) : y / sum * 100) + '%)';
					}

					if (_canDrill(self._meta, false)) {
						label += '<br/><span style="font-size: 10px; font-style:italic;">' + syra_local.highCharts_clickToDrill + '</span>';
					}
					return label;
				}
			},

			series: [],
		};
		if (Highcharts.theme.version[0] === 3) {
			// For Highcarts 3.0.0
			options.exporting = {
				//enabled: true,
				//filename: 'chart',
				type: 'image/png',
				url: 'http://export.highcharts.com/',
				//width: undefined, // docs
				//scale: 2 // docs
				buttons: {
					contextButton: { // docs
						//x: -10, // docs: x is different now
						symbol: 'menu',
						_titleKey: 'contextButtonTitle',
						menuItems: [{
								textKey: 'showHideLegend',
								onclick: function() {
									setTimeout(function() {
										self._chart && self._chart.legend && _displayLegend(self, !self._chart.legend.display);
									}, 100);
								}
							}, {
								separator: true
							}, {
								textKey: 'drillUp',
								onclick: function() {
									setTimeout(function() {
										self._drill(null, true);
									}, 100);
								}
							} // Enable this block to add "View SVG" to the dropdown menu
							// {
							//     text: 'View SVG',
							//     onclick: function() {
							//         var svg = this.getSVG().replace(/</g, '\n&lt;').replace(/>/g, '&gt;');
							//         document.body.innerHTML = '<pre>' + syra_site.dom.formatHTMLText(svg, true) + '</pre>';
							//     }
							// }
						]
					}
				}
			};
			var menuItems = options.exporting.buttons.contextButton.menuItems;
			if (!syra_site.isTabletDevice) {
				menuItems.push({
					separator: true
				});
				menuItems.push({
					text: 'Print chart',
					onclick: function() {
						this.print(self);
					}
				});
			}
			if (!syra_site.isTabletDevice) {
				menuItems.push({
					separator: true
				});
				menuItems.push({
					textKey: 'downloadPNG',
					onclick: function() {
						this.exportChart();
					}
				});
				menuItems.push({
					textKey: 'downloadJPEG',
					onclick: function() {
						this.exportChart({
							type: 'image/jpeg'
						});
					}
				});
				menuItems.push({
					textKey: 'downloadPDF',
					onclick: function() {
						this.exportChart({
							type: 'application/pdf'
						});
					}
				});
				menuItems.push({
					textKey: 'downloadSVG',
					onclick: function() {
						this.exportChart({
							type: 'image/svg+xml'
						});
					}
				});
			}
		}

		if (options.xAxis[0].title.text !== options.title) {
			options.xAxis[0].title.text = options.title + (options.xAxis[0].title.text ? ' / ' + options.xAxis[0].title.text : '');
		}

		if ($cube.$style === "spiderweb") {
			if ($cube.$mnu) {
				enuml = this.getEnumeration($cube.$mnu);
			}
			options.chart.polar = true;
			options.chart.type = 'area';
			delete options.xAxis[0].title;
			options.xAxis[0] = Highcharts.merge(options.xAxis[0], {
				tickmarkPlacement: 'on',
				lineWidth: 0
			});
			delete options.xAxis[0].labels;
			delete options.yAxis;
			delete options.tooltip;
			options.yAxis = {
				gridLineInterpolation: 'polygon',
				lineWidth: 0,
				min: 0,
				labels: {
					x: 6,
					y: 4,
					formatter: function() {
						return ((enuml && enuml[this.value - 1]) ? enuml[this.value - 1] : " ");
					}
				},
			};
			options.chart.events = {
				click: function() {
					this.tooltip.hide();
				}
			};
			options.tooltip = {
				formatter: function() {
					return this.series.name;
				},
				hideDelay: 0,
				animation: false
			};
			if (enuml) {
				options.yAxis.showLastLabel = true;
				options.yAxis.tickInterval = 1;
			}
			if ($cube.$scale) {
				options.yAxis.max = parseInt($cube.$scale, 10);
			}
		} else {
			options.chart.type = self._meta.defaultStyle;
		}
		return options;
	},
	__processMeta: function(metaData, init) {
		_processMeasures(this, metaData, init);
		var xAxis = this._meta.xAxis && this._meta.xAxis[0];
		this._meta.links = this._meta.links || {};
		metaData.$links = metaData.$links || {};
		_applyLinks(this, metaData, "$links");
		_applyLinks(this, metaData, "$actions");
		_applyLinks(this, metaData.$item, "$links");

		if (xAxis && xAxis.code && metaData.$properties && metaData.$properties[xAxis.code].$thumb && metaData.$properties[xAxis.code].$thumb.$links) {
			_applyLinks(this, metaData.$properties[xAxis.code].$thumb, "$links");
		}

		this._meta.drillDownLink = this._getLink("$drillDown");
		this._meta.drillUpLink = this._getLink("$drillUp");
		_processAxes(this, metaData, init);
	},
	_getLink: function(name) {
		var meta = this._meta;
		return meta.links && meta.links[name] && this._getMenuItem(meta.links[name]);
	},
	_getMenuItem: function(link) {
		var links = {};
		var $link = links[link.id] = helpers.object.clone(link.link);
		return link && {
			$item: {
				$links: links
			}
		};
	},
	_getPref: function() {
		return Highcharts.getOptions();
	},

	_execLink: function(context, recordIndex) {
		if (!this.record) {
			this.record = new RecordArticle();
			this.record.$prototype = this.$prototype.$item;
			this.record.$facet = this.attachedField.$recordFacet;
			this.record.$isEditMode = this.attachedField.$isEditMode && !this.attachedField.treeDecorator;
			this.record.list = this.attachedField;
			this.record.dataset = this.dataset && this.dataset[recordIndex || 0] || {};
			this.page.initializeNewItem(this.record, {}, this);
			this.record.loadBox(context.$item);
		} else {
			this.record.applyChange(context.$item);
		}
		var $links = context.$item["$links" || "$actions"];
		$links && syra_menus.click.menuId(this.record, Object.keys($links)[0]);
	},
	_showDrillUp: function(show) {
		//     if (show) {
		//         this._drillUpGroup.show();
		//     } else {
		//         this._drillUpGroup.hide();
		//     }
		// TODO: Does not work. Find an alternative
		// -----------------------------------------
		// var drillElt = this._chart.exportSVGElements && this._chart.exportSVGElements.filter(function(e) {
		//     return e.id === "drillUp";
		// });
		// if (!(drillElt[0] && drillElt[0].element)) return;
		// if (show) {
		//     drillElt[0].element.removeAttribute("display");
		// } else {
		//     drillElt[0].element.setAttribute("display", "none");
		// }
	},
	_drill: function(serie, up) {
		var self = this,
			cube = this.$prototype.$cube,
			meta = self._meta,
			i = meta.drill.currAxisHier,
			stack = meta.drill.stack;

		function pushProto() {
			stack.unshift(helpers.object.clone(proto, true));
			return stack[0];
		}

		if (up && meta.drillUpLink) {
			return this._execLink(meta.drillUpLink);
		} else
		if (!up && meta.drillDownLink) {
			return this._execLink(meta.drillDownLink, serie.x);
		}

		if (up) {
			// already on top ?
			if (stack.length < 2)
				return;
			stack.shift();
			meta.drill.currAxisHier--;
			self._showDrillUp(meta.drill.currAxisHier > 0);
			_fetch(self, stack[0]);
			return;
		}

		var proto = stack[0],
			axis0 = proto.$axes && proto.$axes[0];

		// no axis or reach the end of drilling
		if (!_canDrill(this._meta, up)) {
			return;
		}

		var members = axis0.$members = (axis0.$members || []);

		proto = pushProto();

		axis0 = proto.$axes && proto.$axes[0];
		members = axis0.$members;
		var hierarchies = axis0.$hierarchies;

		var hierName = hierarchies[i][0],
			cubeHier = cube.$hierarchies[hierName];
		if (hierarchies[i][2] == (cubeHier.$properties ? cubeHier.$properties.length - 1 : -1)) {
			hierarchies[i].splice(1, 2, 0, 0);
			hierarchies[i + 1].splice(1, 2, 1, 0);
			meta.drill.currAxisHier++;
		} else {
			hierarchies[i][2]++;
		}
		if (members.length < i + 1) {
			members[i] = [];
		}
		var rawData = this.dataset && this.dataset[serie.x],
			member = rawData && (rawData[hierName] + "");

		// use the raw data from the dataset instead of serie.name because this one can be formatted
		members[i].push([member]);

		self._showDrillUp(meta.drill.currAxisHier > 0);

		_fetch(this, proto);
	},

	// --------------------------------------------------------------------------------
	// Event management
	// --------------------------------------------------------------------------------
	_onMeasureClick: function(context) {
		var self = this;
		var event = context.event || {}, data = context.data || {};

		if (!self.attachedField.$isDisabled) {
			if (self.page.externalAdapter.fusionSite) {
				self._openMenu(data.x, event);
			} else {
				// no longer drill up if shiftKey is pressed
				if (!event.shiftKey)
					self._drill(data, event.shiftKey);
			}
		}

	},

	dispose: function() {
		this._chart && this._chart.destroy();
		ChartArticle.prototype.dispose.call(this);
	}
});

function _isCubeValid(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
		proto.$axes[0].$hierarchies &&
		proto.$axes[0].$hierarchies.length > 0);
}