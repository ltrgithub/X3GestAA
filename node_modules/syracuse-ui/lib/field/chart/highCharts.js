"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var datetime = require('syracuse-core/lib/types/datetime');
var cubeHelper = require('syracuse-ui/lib/field/cube/cubeHelper');
var Article = require("syracuse-ui/lib/article/article").Article;
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var TabularChartRecord = require('./tabularChartRecord').TabularChartRecord;
// require('syracuse-ui/deps/highcharts/highcharts');
require('syracuse-ui/deps/highcharts/highcharts.src');
require('syracuse-ui/deps/highcharts/highcharts-more.src');

require('syracuse-ui/deps/highcharts/modules/exporting');
Highcharts.theme = require('syracuse-ui/themes/desktop/sage/highcharts/theme').theme;

var highchartsOptions = Highcharts.setOptions(Highcharts.theme);

var forEachKey = helpers.object.forEachKey,
    objectCopy = helpers.object.copy,
    objectClone = helpers.object.clone,
    stringify = helpers.object.stringify;

var debug = false;
var _style = (function() {
    var map = {
        point: "scatter",
        stick: "column",
    };

    return function($style) {
        // return 'bar';
        return $style && (map[$style] || $style);
    };
})();

var _merge = Highcharts.merge;

var _formatApi = require('syracuse-ui/lib/field/formatApi');

// TODO: 
// - event management
// - dynamic loading of series

function delayed(obj, name, cb, delay) {
    var tm = "timer_" + name;
    if (obj[tm]) clearTimeout(obj[tm]);
    obj[tm] = setTimeout(cb, delay || 100);
}

function TabularChart() {}

exports.TabularChart = helpers.defineClass(TabularChart, Article, {
    onWindowResize: function(display) {
        // debug && console.log("HighCharts.onWindowResize " + this.id + " : display=" + display + ", displayed=" + this.displayed + " , size=(" + this.$$container.innerWidth() + ", " + this.$$container.innerHeight() + ")");
        // if (display) this.displayed = true;
        // if (this.displayed && !this._chart && this.$$container.innerWidth() !== 0) {
        //     // defer chart creation when we are ready to display
        //     this._createChart(this._settingsFromValue());
        // }
        // if (this._chart && !this._chart.isResizing) {
        if (this._chart) {
            var self = this;
            if (this.resizeTimer) clearTimeout(this.resizeTimer);
            this.resizeTimer = setTimeout(function() {
                self._chart && self._chart.setSize(self.layoutSlot.clientWidth, self._chart.chartHeight || self.layoutSlot.style.clientHeight);
            }, 100);
        }

    },

    dispose: function() {
        this._chart && this._chart.destroy();
        this._localize = null;
        Article.prototype.dispose.call(this);
    },
    applyDesignMetaData: function(metadata, onAuthoring) {
        if (metadata.$style) {
            if (this._meta) {
                this._setStyle(metadata.$style);
            }
        }
    },
    _createChoices: function() {
        var $choices = ["area", "areaspline", "bar", "column", "line", "scatter", "spline" /*, "pie"*/ ];
        var $enums = [];
        for (var ii = 0, jj = $choices.length; ii < jj; ii++) {
            var $choice = $choices[ii];
            $enums.push(typeof($choice) === "string" ? {
                $value: $choice,
                $title: this._localize[$choice] || $choice
            } : {
                $value: $choice.$value,
                $title: $choice.$title || this._localize[$choice.$value] || $choice.$value
            });
        }
        return {
            $type: "application/x-choice",
            $title: title,
            $value: {
                $type: "application/x-string",
                $enum: $enums
            }
        };
    },
    drawBox: function() {
        this.dataset = null;
        this.$localization = this.getArticleParent().$prototype.$localization;
        this._localize = locale.resources(module)();
        // debug && console.log("HighCharts.drawBox " + this.id);
        var proto = this.$prototype;
        // create an alias
        proto.$properties = proto.$item.$properties;

        // cubeHelper._initializeMeta(this);
        this._initializeMeta();
        this._initializeToobar();
        this._createMenuContainer();
        // this.applyDesignMetaData(this.$item, false); //temp for  test
        this._createChart();
        if (!this.$item.$isListEmbeded) {
            this.getArticleParent().bind(this, this.$item.$bind);
        }
    },
    setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
        debug && console.log(Date.now() + " - HighCharts.setDataBind " + this.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length));
        if (metaData) {
            this._processMeta(metaData);
        }
        this.dataset = dataRecordSet;
        if (this._chart && this.dataset && this.dataset.length > 0) {
            var self = this;
            // delayed(self, "setDataBind", function() {
            //     debug && console.log(Date.now() + " - HighCharts.delayed.setDataBind " + this.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length));
            var settings = self._settingsFromValue();
            self._chart.xAxis[0].setCategories(settings.categories, false);

            var series = self._chart.series;
            if (!series || series.length === 0) {
                forEachKey(self._meta.series, function(key, s) {
                    self._chart.addSeries(settings.series[key], false);
                });
            } else {
                for (var ii = 0; ii < series.length; ii++) {
                    var key = series[ii].options.id.slice(3),
                        serie = settings.series[key];
                    series[ii].setData(serie.data, false);
                    // serie.data = [];
                }
            }
            self._redraw();
            // }, 200);
        }
        this._showDrillUp(false);
    },

    _createMenuContainer: function() {
        // var $$menu = $("<div>").appendTo(this.$$container);
        // // $$menu.addClass(); 
        // $$menu.attr("style", "position: absolute; z-index: 1000; padding: 24px; display: none; right: -14px; top: 10px;");
        // $$menu.append("<div>");
        // <div class="s-field-menus-popup" style="position: absolute; z-index: 106; top: 111.5px; left: 34px;" id="a6afea62-897d-49e7-a532-f82ca3df2af4">
        //   <div class="s-field-menus-slot">
        //     <nav class="s-list-menus">
        //       <ul style="" class="s-list-menus-body">
        //         <li class="s-list-menus-li"><a style="" class="s-list-menus-link" data-s-menu="18-4" data-s-article="18-1" title="Créer une diapositive Powerpoint" target="blank" href="/sdata/x3stb/erp/stubs/HighCharts?representation=HighCharts.$query&amp;pptMode=newSlide&amp;format=application/syracuse-ppt-slide">
        //           <div class="s-list-menus-link-icon" style="background-image: url(&quot;/syracuse-ui/themes/desktop/images-general/file/s-link-syracuse-ppt-slide.png&quot;);"></div>
        //           <div class="s-list-menus-link-label s-external-link">Créer une diapositive Powerpoint</div>
        //           </a>
        //         </li>
        //       </ul>
        //     </nav>
        //   </div>
        // </div>
        // $$menu.
        // <div class="highcharts-menu0" style="position: absolute; z-index: 1000; padding: 24px; display: none; right: -14px; top: 10px;">
        //   <div style="box-shadow: 3px 3px 10px rgb(136, 136, 136); border: 1px solid rgb(160, 160, 160); background: none repeat scroll 0% 0% rgb(255, 255, 255);">
        //     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download PNG image</div>
        //     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download JPEG image</div>
        //     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download PDF document</div>
        //     <div style="cursor: pointer; padding: 0px 5px; background: none repeat scroll 0% 0% transparent; color: rgb(48, 48, 48); font-size: 11px;">Download SVG vector image</div>
        //   </div>
        // </div>        
    },

    _settingsFromValue: function() {
        var self = this;
        return self.dataset && self.dataset.reduce(function(res, current) {
            var categoryName = self._getMeasureLabel(current, self._meta.xAxis[0].code);
            categoryName && res.categories.push(categoryName);
            forEachKey(self._meta.series, function(key, s) {
                var serie = res.series[key];
                if (serie == null) {
                    serie = objectClone(s.options);
                    serie.data = [];
                    res.series[key] = serie;
                }
                serie.data.push(parseFloat(current[key]));
            });
            return res;
        }, {
            categories: [],
            series: {}
        });
    },

    _createChart: function(settings) {

        var self = this,
            options = _merge(self._getPref(), self._getOptions(self.$prototype));


        if (settings) {
            options.xAxis[0].categories = settings.categories;
            forEachKey(self._meta.series, function(key, s) {
                var serie = objectClone(settings.series[key]);
                if (options.chart.polar && serie && serie.type) {
                    delete serie.type;
                }
                options.series.push(serie);
            });
        } else {
            forEachKey(self._meta.series, function(key, s) {
                var serie = objectClone(s.options);
                if (options.chart.polar && serie && serie.type) {
                    delete serie.type;
                }
                serie.data = [0];
                options.series.push(serie);
            });
        }
        self._chart = new Highcharts.Chart(options);

        // To test: create a clickable area for drillUp
        // var renderer = self._chart;
        // self._drillUpGroup = renderer.g().add();
        // renderer.circle(10, 10, 5).on("click", function(event) {
        //     self._drill(this, event.shiftKey);            
        //     if (self._meta.drill.currAxisHier > 0) {
        //         self._drillUpGroup.show();
        //     } else {
        //         self._drillUpGroup.hide();
        //     }
        // }).attr({
        //     fill: 'red',
        //     stroke: 'black',
        //     'stroke-width': 1
        // }).add(self._drillUpGroup);
        // renderer.path(['M', 12.981, 9.073, 'V', 6.817, 'l', -12.106, 6.99, 'l', 12.106, 6.99, 'v', -2.422, 'c', 3.285, -0.002, 9.052, 0.28, 9.052, 2.269, 'c', 0, 2.78, -6.023, 4.263, -6.023, 4.263, 'v', 2.132, 'c', 0, 0, 13.53, 0.463, 13.53, -9.823, 'C', 29.54, 9.134, 17.952, 8.831, 12.981, 9.073, 'z']).attr({
        //     'stroke-width': 2,
        //     stroke: 'red'
        // }).add(self._drillUpGroup);
        // renderer.text('drill up', 200, 100).attr({
        //     rotation: 45
        // }).css({
        //     fontSize: '16pt',
        //     color: 'green'
        // }).add(self._drillUpGroup);
        this._showDrillUp(false);
    },

    _localizedText: function(val) {
        var $localization = this.$localization;
        return val && val.replace(/\{(@[\w-]+)\}/g, function(match, p1) {
            return ($localization && $localization[p1]) || match;
        });
    },

    _setSerie: function(id) {
        process.removeAllListeners(type);
        this._chart.series.map(function(s) {
            s.hide();
        });
        this._chart.get(id).show();
    },

    _redraw: function() {
        this._chart && this._chart.redraw();
    },

    _getFieldEvalTitle: function() {
        return this.page.externalAdapter.getFieldEvalTitle(this) || [];
    },

    _getOptions: function(proto) {
        var self = this,
            $cube = proto.$cube,
            defOptions = Highcharts.getOptions(),
            buttons = defOptions.exporting.buttons,
            measuresTitle = this._getFieldEvalTitle(),
            axe = proto.$axes && proto.$axes[0] || {},
            axeTitle = axe.$hierarchies && measuresTitle[axe.$hierarchies[0][0]] || axe.$title;

        var options = {
            chart: {
                renderTo: this.layoutSlot,
                marginRight: 150
            },

            lang: {
                drillUp: self._localize.drillUp
            },

            legend: {
                align: 'right',
                verticalAlign: 'top',
                x: 0,
                y: 130,
/*              align: 'center',
                 verticalAlign: 'bottom',
                 x: 0,
                 y: 0,*/
                // floating: true
            },

            title: ($cube && self._localizedText($cube.$title)) || '',

            xAxis: [{
                categories: [],
                title: {
                    text: self._localizedText(axeTitle)
                }
            }],

            yAxis: [{
                min: 0,
                title: {
                    text: ''
                }
            }],

            plotOptions: {
                series: {
                    cursor: 'pointer',
                    events: { // legendItemClick: function(e) {
                        //     // use e.mousePageX and e.mousePageY for mouse coordinates
                        //     console.log("legendItemClick: (" + e.mousePageX + ", " + e.mousePageY + ")");
                        // }
                    },
                    point: {
                        events: {
                            click: function(event) {
                                self._onMeasureClick({
                                    data: this,
                                    event: event
                                });
                            }
                        }
                    }
                }
            },

            tooltip: {
                formatter: function() {
                    var seriesMeta = self._meta.series,
                        measure = seriesMeta[this.series.options.id.slice(3)].measure,
                        label = '' + this.x + ': <b> ' + (measure ? measure.formatApi.format(this.y, measure.localeFormat) : this.y) + '</b>',
                        data = this.series.processedYData;
                    if (measure && (measure.$isNormalized) && data.length > 0) {
                        var sum = data.reduce(function(a, b) {
                            return a + b;
                        });
                        label += ' (' + measure.formatApi.format(this.y / sum * 100, measure.localeFormat) + '%)';
                    }

                    var proto = self.$prototype,
                        $cube = proto.$cube,
                        hCount = $cube.$hierarchies && Object.keys($cube.$hierarchies).length || 0;

                    if (self._meta.drillDownLink || hCount > 1) {
                        label += '<br/><span style="font-size: 10px; font-style:italic;">' + self._localize.clickToDrill + '</span>'
                    }
                    // label += '<br/><span style="font-size: 10px; font-style:italic;">' + self._localize.clickToDrill + '</span><br/><span style="font-size: 10px; font-style:italic;">Shift+Click to drill up</span>'
                    return label;
/*  var items = this.points || splat(this),
                     series = items[0].series,
                     s;
                     // build the header
                     s = [series.tooltipHeaderFormatter(items[0].key)];
                     // build the values
                     items.map(function(item) {
                     series = item.series;
                     s.push((series.tooltipFormatter && series.tooltipFormatter(item)) || item.point.tooltipFormatter(series.tooltipOptions.pointFormat));
                     });
                     // footer
                     s.push(options.footerFormat || '');
                     return s.join('');*/
                }
            },
            series: [],

            exporting: {
                buttons: {
                    drillUp: {
                        symbol: 'triangle',
                        x: -62,
                        symbolFill: 'rgba(250,250,250,0.5)',
                        hoverSymbolStroke: '#fff',
                        hoverSymbolFill: 'rgba(250,250,250,0.5)',
                        _id: 'drillUp',
                        _titleKey: 'drillUp',
                        onclick: function() {
                            self._drill(null, true);
                        }
                    },
                    printButton: buttons.printButton,
                    exportButton: buttons.exportButton
                }
            }
        };

        if (options.xAxis[0].title.text !== options.title) {
            options.xAxis[0].title.text = options.title + (options.xAxis[0].title.text ? ' / ' + options.xAxis[0].title.text : '');
        }

        if ($cube.$style === "spiderweb") {
            options.chart.polar = true;
            options.chart.type = 'area';
            delete options.xAxis[0].title;
            options.xAxis[0] = _merge(options.xAxis[0], {
                tickmarkPlacement: 'on',
                lineWidth: 0
            });

            delete options.yAxis;
            options.yAxis = {
                gridLineInterpolation: 'polygon',
                lineWidth: 0,
                min: 0
            };
            // options.yAxis[0] = _merge(options.yAxis[0], {
            //     gridLineInterpolation: 'polygon',
            //     lineWidth: 0,
            //     min: 0
            // });
        }
        return options;
    },

    _initializeMeta: function() {
        var proto = this.$prototype;
        var cube = proto.$cube;
        this._meta = {
            xAxis: [{}],
            series: {},
            displaysOneMeasure: cube && cube.$displaysOneMeasure,
            hasMeasureSelector: cube && cube.$hasMeasureSelector,
            hasStyleSelector: cube && cube.$hasStyleSelector,
            defaultStyle: _style(cube.$style) || 'column',
            drill: {
                minLevel: 1,
                maxLevel: 0,
                currLevel: 1,
                currAxisHier: 0,
                levelsProperties: [],
                members: [],
                stack: [{
                    $axes: proto.$axes,
                    $item: proto.$item,
                    $slicer: proto.$slicer
                }]
/*              code: proto.$codeStat || "UNKNOWN",
                 axis0FieldCode: self._meta.xAxis[0].code || ""*/
            }
        };
        this._processMeta(proto);
    },
    _initializeToobar: function() {
        var self = this;
        // self._toolBox && self._toolBox.show({
        //     series: (self._meta.hasMeasureSelector && self._meta.displaysOneMeasure),
        //     chartTypes: self._meta.hasStyleSelector
        // });
        // self._toolBox && self._toolBox.selectChartType(self._meta.defaultStyle);
    },
    _processMeta: function(proto) {
        this._processMeasures(proto);
        this._processLinks(proto);
        this._processAxes(proto);
    },
    _processMeasures: function(proto) {
        var self = this,
            cube = this.$prototype.$cube,
            items = this.$prototype.$properties;

        // Get measures definition. If measures are not defined in the second axis members (Cf. specs),
        // we used all the measures defined in the cube
        var measures = cube && cube.$measures;
        if (measures) {
            var restraintMeasures = measures;
            if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
                restraintMeasures = {};
                _.each(proto.$axes[1].$members[0][0], function(measureCode) {
                    restraintMeasures[measureCode] = measures[measureCode];
                });
            }
            forEachKey(restraintMeasures, function(key, m) {
                // Because duplicate properties is possible for cube definition... we keep the last defined
                var code = (m.$property || key);
                //options.xAxis[0].categories.push(measure.$title || proto.$properties[code].$title || "???");
                var measure = _merge(items[code], m);
                measure.formatApi = measure.formatApi || _formatApi.getApi(measure.$type);
                measure.formatObj = measure.formatObj || _formatApi.getLocale().getNumberFormatObj(measure.$type);
                measure.localeFormat = measure.localeFormat || measure.$format || measure.formatObj.numFormat;

                self._meta.series[code] = {
                    options: {
                        id: '#s-' + code,
                        // legendIndex: "",
                        name: self._localizedText(measure.$title) || '???',
                        stack: measure.$isStacked,
                        type: _style(measure.$style),
                        visible: !! (!self._meta.displaysOneMeasure || measure.$isDefault)
                    },
                    measure: measure
                };
            });
        }
    },
    _processLinks: function(proto) {
        var meta = this._meta,
            xAxis = meta.xAxis && meta.xAxis[0],
            reprUrl = this.page.$prototype && this.page.$prototype.$representationUrl;
        meta.links = meta.links || {};
        proto.$links = proto.$links || {};

        if (reprUrl) {
            proto.$links.$pptslide = {
                "$title": this._localize.powerpointSlide,
                "$url": reprUrl + "&pptMode=newSlide",
                "$type": httpHelper.mediaTypes.ppt_slide
            };
        }

        this._applyLinks(proto, "$links");
        this._applyLinks(proto, "$actions");
        this._applyLinks(proto.$item, "$links");

        if (xAxis && xAxis.code && proto.$properties && proto.$properties[xAxis.code].$thumb && proto.$properties[xAxis.code].$thumb.$links) {
            this._applyLinks(proto.$properties[xAxis.code].$thumb, "$links");
        }

        meta.drillDownLink = meta.links && meta.links["$drillDown"] && this._getMenuItem(meta.links["$drillDown"]);
        meta.drillUpLink = meta.links && meta.links["$drillUp"] && this._getMenuItem(meta.links["$drillUp"]);
    },

    _applyLinks: function(prop, col) {
        var self = this;
        if (col && prop && prop[col]) {
            forEachKey(prop[col], function(id, link) {
                // self._meta.links.push(self._getLinkDef(col, id, link));
                var lnk = self._meta.links[id];
                if (lnk) {
                    forEachKey(link, function(k, v) {
                        lnk[k] = v;
                    });
                } else {
                    self._meta.links[id] = self._getLinkDef(col, id, link);
                }
            }, self);
        }
    },
    _getMenuItem: function(link) {
        var links = {};
        var $link = links[link.id] = objectClone(link.link);
        // $link.$url = this.formatMenuUrl($link);
        return link && {
            $item: {
                $links: links
            }
        };
    },
    _processAxes: function(proto) {
        var cube = this.$prototype.$cube;
        if (!_isCubeValid(cube, proto)) return false;

        var self = this,
            currAxisHier = 0,
            axis0 = proto.$axes && proto.$axes[0];

        // TODO: review this
        // Get axis analysis
        var mainHLevelsTab = null;
        if (axis0) {
            forEachKey(axis0.$hierarchies, function(idx, hierarchy) {
                if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
                    mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
                    if (mainHLevelsTab) {
                        self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
                        currAxisHier = idx;
                    }
                }
            });
            if (!mainHLevelsTab && axis0.$hierarchies[0].length > 0) {
                mainHLevelsTab = cube.$hierarchies[axis0.$hierarchies[0][0]].$properties;
                if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
            }
            // Get drill definition
            var properties;
            _.each(axis0.$hierarchies, function(hierarchie) {
                properties = cube.$hierarchies[hierarchie[0]].$properties;
                _.each(properties, function(property) {
                    this.levelsProperties[this.maxLevel++] = property;
                }, self._meta.drill);
            });
            if (axis0.$members) {
                _.each(axis0.$members, function(tuple) {
                    _.each(tuple, function(value) {
                        if (value.length > 0) {
                            this.members[this.currLevel++-1] = value[0];
                        }
                    }, this);
                }, self._meta.drill);
            }
        }
        self._meta.drill.code = proto.$codeStat || "UNKNOWN";
        self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";
        self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
    },

    // set graph style
    _setGraphStyle: function(cube, measures) {
        // Init
        var graphStyle = {},
            mDefault = null;
        var msCode = [],
            i = 0;
        var self = this;

        if (cube.$style == "pie") {
            _.each(measures, function(measure) {
/*              msCode.push(measure.property);
                 if(measure.definition.$isDefault)
                 mDefault = measure.property;
                 */
            });
        } else {
            _.each(measures, function(measure) {
/*
                 // So, "xy" style
                 switch (measure.definition.$style) {
                 case "stick":
                 break;
                 }
                 if(measure.definition.$isStacked) {
                 } else if(measure.definition.$isNormalized) {
                 }
                 if(measure.definition.$isDefault)
                 mDefault = measure.property;
                 msCode.push(measure.property);
                 */
            });
        }

        // Misc properties
        graphStyle.defaultMeasures = (!cube.$displaysOneMeasure ? msCode.join(";") : (mDefault ? mDefault : msCode[0]));
        graphStyle.hasMeasureSelector = !! cube.$hasMeasureSelector;
        graphStyle.hasStyleSelector = !! cube.$hasStyleSelector;

        return graphStyle;
    },
    // Build a syra link full description object (type : "$link", "$action"... id = "$edit", $delete, etc...)
    _getLinkDef: function(type, id, link) {
        return {
            "type": type,
            "id": id,
            "link": link,
            "title": this._localizedText(link.$title)
        };
    },
    _getPref: function() {
        // TODO: change default preference by using authoring mode
        var options = Highcharts.getOptions();
        return _merge(options, {
            // chart: {
            //     defaultSeriesType: 'column' // 'line', 'spline', 'area', 'areaspline', 'column', 'bar', 'pie', 'scatter',
            // },
            credits: {
                enabled: false
            },
            legend: {
                layout: 'vertical',
                align: 'left',
                verticalAlign: 'top',
                x: 100,
                y: 70,
                floating: true
            },
            // plotOptions: {
            //     column: {
            //         pointPadding: 0.2,
            //         borderWidth: 0,
            //         //stacking : 'normal',
            //     }
            // },
        });
    },

    _getMeasureLabel: function(measure, code) {
        // return cubeHelper.getMeasureLabel(measure, code, this.$prototype && this.$prototype.$properties);
        var label = this._localizedText(measure.$title);
        if (label) return label;
        var self = this;
        var item = self.$prototype.$properties[code];
        if (!item) return null;
        switch (item.$type) {
        case "application/x-choice":
            label = measure[code];
            item.$value.$enum.some(function(element, i, array) {
                if (element.$value === label) {
                    label = this._localizedText(element.$title);
                    return true;
                }
                return false;
            });
            break;
        case "application/x-date":
            item.formatApi = item.formatApi || _formatApi.getApi(item.$type);
            item.localeFormat = item.localeFormat || _formatApi.getLocale().getDateFormat(item.$format);
            label = datetime.parse(measure[code]).toString(item.localeFormat);
            break;
        case "application/x-integer":
        case "application/x-decimal":
            item.formatApi = item.formatApi || _formatApi.getApi(item.$type);
            item.formatObj = item.formatObj || _formatApi.getLocale().getNumberFormatObj(item.$type);
            item.localeFormat = item.localeFormat || item.$format || item.formatObj.numFormat;
            label = item.formatApi.format(measure[code], item.localeFormat);
            break;
        default:
            label = "" + measure[code];
            break;
        }
        return label;
    },
    _ensureChartRecord: function($item, recordIndex) {
        if (!this.recordArticle) {
            this.recordArticle = new TabularChartRecord();
            this.recordArticle.$prototype = this.$prototype.$item;
            this.recordArticle.dataset = this.dataset && this.dataset[recordIndex || 0] || {};
            this.page.initializeNewItem(this.recordArticle, {}, this);
            this.recordArticle.loadBox($item);
        } else {
            this.recordArticle.applyChange($item);
        }
        return this.recordArticle;
    },
    _execLink: function(link, recordIndex) {
        if (typeof link === "string") {
            var links = this._meta && this._meta.links;
            link = links && this._getMenuItem(links[link]);
        }
        debug && console.log("TabularChart._execLink: link.id=" + link.id + ", x=" + recordIndex);
        this._ensureChartRecord(link.$item, recordIndex);
        var menuItem = this.recordArticle.menuItems[Object.keys(link.$item["$links" || "$actions"])[0]][0];
        debug && console.log("TabularChart._execLink: url=" + menuItem.$url + "\nrecord=" + stringify(this.recordArticle.dataset));
        menuItem.click();
    },

    _showDrillUp: function(show) {
        //     if (show) {
        //         this._drillUpGroup.show();
        //     } else {
        //         this._drillUpGroup.hide();
        //     }
        // TODO: Does not work. Find an alternative
        // -----------------------------------------
        // var drillElt = this._chart.exportSVGElements && this._chart.exportSVGElements.filter(function(e) {
        //     return e.id === "drillUp";
        // });
        // if (!(drillElt[0] && drillElt[0].element)) return;
        // if (show) {
        //     drillElt[0].element.removeAttribute("display");
        // } else {
        //     drillElt[0].element.setAttribute("display", "none");
        // }
    },
    _drill: function(serie, up) {
        var self = this,
            cube = this.$prototype.$cube,
            meta = self._meta,
            i = meta.drill.currAxisHier,
            stack = self._meta.drill.stack;

        if (up && meta.drillUpLink) {
            return this._execLink(meta.drillUpLink);
        } else if (!up && meta.drillDownLink) {
            return this._execLink(meta.drillDownLink, serie.x);
        }

        if (up) {
            // already on top ?
            if (stack.length < 2) return;
            stack.shift();
            meta.drill.currAxisHier--;
            self._showDrillUp(meta.drill.currAxisHier > 0);
            self._fetch(stack[0]);
            return;
        }

        var proto = stack[0],
            axis0 = proto.$axes && proto.$axes[0];

        if (!axis0) return;

        var members = axis0.$members = (axis0.$members || []);

        stack.unshift(objectClone(proto, true));
        proto = stack[0];
        axis0 = proto.$axes && proto.$axes[0];
        members = axis0.$members;
        var hierarchies = axis0.$hierarchies;

        var cubeHier = cube.$hierarchies[hierarchies[i][0]];
        if (hierarchies[i][2] == (cubeHier.$properties ? cubeHier.$properties.length - 1 : -1)) {
            hierarchies[i].splice(1, 2, 0, 0);
            hierarchies[i + 1].splice(1, 2, 1, 0);
            meta.drill.currAxisHier++;
        } else {
            hierarchies[i][2]++;
        }
        if (members.length < i + 1) {
            members[i] = [];
        }
        members[i].push([serie ? "" + serie.x : "???"]);

        self._showDrillUp(meta.drill.currAxisHier > 0);

        this._fetch(proto);
    },
    _fetch: function(proto) {
        this.fetch({
            jsonParams: {
                $axes: proto.$axes,
                $slicer: proto.$slicer
            }
        });
    },

    // --------------------------------------------------------------------------------
    // Event management
    // --------------------------------------------------------------------------------
    _onMeasureClick: function(context) {
        var self = this;
        var event = context.event || {},
            data = context.data || {},
            line = data.x + 1;

        if (!self.attachedField.$isDisabled) {
            if (self.page.externalAdapter.fusionSite) {
                self.page.externalAdapter.onGraphClickPicker({
                    field: self,
                    rcdUuid: line,
                    pickerType: "menus",
                    grapLevel: "measure",
                    doEvent: function(err, menus) {
                        var $links = {};
                        for (var ii = 0, jj = menus.length; ii < jj; ii++) {
                            $links["link-" + ii] = menus[ii];
                        }
                        self._ensureChartRecord({}, data.x).openMenuBox({
                            $links: $links
                        }, event, function(menuItem) {
                            var data = {
                                field: self,
                                link: {
                                    linkCtx: menuItem.linkCtx || "",
                                    linkId: menuItem.linkId
                                }
                            };

                            if (self.page.externalAdapter.onGraphClickLink(data)) {
                                // We should never come here in a Convergence context!!!
                                // debug && console.log("onGraphClickLink returns true!!!")
                                // self._execLink(menuItem);
                            }
                            return false;
                        });
                    }
                });
            } else {
                // no longer drill up if shiftKey is pressed
                if (!event.shiftKey) self._drill(data, event.shiftKey);
            }
        }

    },
    // --------------------------------------------------------------------------------
    // Chart management
    // --------------------------------------------------------------------------------
    _setChart: function(categories, series, data) {
        var self = this;
        alert('_setChart NIY');
/*
         self._chart.xAxis[0].setCategories(categories);
         self._chart.series[0].remove();
         self._chart.addSeries({
         name : name,
         proto : proto,
         //color : color || 'red'
         });
         */
    },

    _setStyle: function(type) {
        var self = this,
            count = Object.keys(self._meta.series).length,
            size = 80,
            slice = Math.round(size / count);
        forEachKey(self._meta.series, function(key, s) {
            s.type = type;
            if (self._chart) {
                var serie = self._chart.get(s.options.id);
                if (serie) {
                    self._setType(serie, type, size, size - slice);
                    size -= slice;
                }
            }
        });
        self._redraw();
    },

    _setType: function(serie, type, size, innerSize) {
        var chart = serie.chart,
            size;
        var s = {
            id: serie.options.id,
            type: type,
            name: serie.name,
            data: serie.options.data,
            visible: serie.visible,
            stack: serie.stack,
            color: serie.color
        };
        // if (type === "pie") {
        //     s.size = size + "%";
        //     s.innerSize = innerSize + "%";
        //     s.showInLegend = false;
        //     s.dateLabels = {
        //         enabled: false
        //     };
        //     this._meta.cache = this._meta.cache || {};
        //     this._meta.cache.xAxis = chart.xAxis;
        //     delete chart.xAxis;
        // } else if (!chart.xAxis) {
        //     s.showInLegend = true;
        //     s.dateLabels = {
        //         enabled: true
        //     };
        //     chart.xAxis = self._meta.cache.xAxis;
        // }
        serie.remove();
        chart.addSeries(s, false);
    },

    destroy: function() {
        this._chart && this._chart.destroy();
    }
});

function _isCubeValid(cube, proto) {
    return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 //
    && proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
}