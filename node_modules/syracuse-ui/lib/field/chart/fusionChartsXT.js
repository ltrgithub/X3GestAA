"use strict";
var helpers = require('syracuse-core/lib/helpers');
var cubeHelper = require('syracuse-ui/lib/field/cube/cubeHelper');
var Article = require("syracuse-ui/lib/article/article").Article;
require('syracuse-ui/deps/fusionCharts/charts/FusionCharts');
require('syracuse-ui/deps/fusionCharts/charts/FusionCharts.jqueryplugin');
require('syracuse-ui/deps/fusionCharts/charts/FusionCharts.HC');
require('syracuse-ui/deps/fusionCharts/charts/FusionCharts.HC.Charts');

var forEachKey = helpers.object.forEachKey;
var objectCopy = helpers.object.copy;
var objectClone = helpers.object.clone;

var chartStyles = {
	classic: ["Column2D", "Column3D", "Line", "Area2D", "Bar2D", "Pie2D", "Pie3D", "Doughnut2D", "Doughnut3D", "Pareto2D", "Pareto3D"],
	multiSeries: ["MSColumn2D", "MSColumn3D", "MSLine", "MSBar2D", "MSBar3D", "MSArea", "Marimekko", "ZoomLine"],
	stacked: ["StackedColumn2D", "StackedColumn3D", "StackedBar2D", "StackedBar3D", "StackedArea2D", "MSStackedColumn2D"],
	combination: ["MSCombi2D", "MSCombi3D", "MSColumnLine3D", "StackedColumn2DLine", "StackedColumn3DLine", "MSCombiDY2D", "MSColumn3DLineDY", "MSStackedColumn2DLineDY", "StackedColumn3DLineDY"],
	xyPlot: ["Scatter", "Bubble"],
	scroll: ["ScrollColumn2D", "ScrollLine2D", "ScrollArea2D", "ScrollStackedColumn2D", "ScrollCombi2D", "ScrollCombiDY2D"],
	grid: ["SSGrid"]
};

var styleMap = {
	$default: "MSCombi3D",
	stick: "MSCombi3D",
	pie: "Pie3D"
};

function _getChartStyle(type) {
	return "FusionCharts/" + styleMap[type] + ".swf";
};

var _merge = function() {
	var args = arguments;
	return $.extend(true, null, args[0], args[1], args[2], args[3]);
};

var _formatApi = require('syracuse-ui/lib/field/formatApi');

function ToolBar() {}

helpers.defineClass(ToolBar, null, {
	create: function(container, id, handlers) {
		var self = this;
		self.id = id;
		self.state = {
			series: false,
			chartTypes: true
		};
		// TODO: be compliant with syracuse theme
		self.$$bar = $("<div />").attr("style", "display:none").appendTo(container);
		self.$$series = $("<select />").attr("id", "select_series_" + id) //
		.appendTo(self.$$bar) //
		.change(function() {
			$(this).children("option:selected").each(function() {
				handlers && handlers.serieChange.call(null, $(this).attr("value"));
			});
		});
		self.$$chartTypes = $("<select />").attr("id", "select_chart_type_" + id) //
		.appendTo(self.$$bar) //
		.change(function() {
			$(this).children("option:selected").each(function() {
				handlers && handlers.serieStyleChange.call(null, $(this).attr("value"));
			});
		});
		/*		chartStyles.forEach(function(style) {
         $("<option />").attr("value", style).text(style).appendTo(self.$$chartTypes);
         });*/
		return this;
	},
	show: function(opt) {
		var self = this;
		this.$$bar && this.$$bar.show();
		if (opt) {
			opt = _merge(self.state, opt);
			opt.series && self.$$series && self.$$series.show();
			opt.chartTypes && self.$$chartTypes && self.$$chartTypes.show();
		}
	},
	hide: function(opt) {
		var self = this;
		if (opt) {
			opt = _merge(self.state, opt);
			opt.series && self.$$series && self.$$series.hide();
			opt.chartTypes && self.$$chartTypes && self.$$chartTypes.hide();
		} else {
			this.$$bar && this.$$bar.hide();
		}
	},
	addSeries: function(choices) {
		var self = this;
		choices = Array.isArray(choices) ? choices : ( !! choices ? [choices] : []);
		choices.map(function(choice) {
			$("<option />").attr("value", choice.id).text(choice.title).appendTo(self.$$series);
		});
	},
	removeAllSeries: function() {
		this.$$series.empty();
	},
	selectSerie: function(val) {
		this._selectChoice(this.$$series, val);
	},
	selectChartType: function(val) {
		this._selectChoice(this.$$chartTypes, val);
	},
	_selectChoice: function($$obj, val) {
		$$obj.children('option[value="' + val + '"]').attr("selected", "selected");
	}
});

function RecordArticle() {}

exports.RecordArticle = helpers.defineClass(RecordArticle, Article, {
	drawBox: function() {
		this.page.($("<div style='display:none'/>").appendTo($(this.boxParent.layoutSlot)), {
			$category: "menus",
			$isMenusBag: true
		}, this);
	},
});

function TabularChart() {}

exports.TabularChart = helpers.defineClass(TabularChart, Article, {
	drawBox: function() {
		FusionCharts.setCurrentRenderer('javascript');
		/*		FusionCharts.debugMode.enabled(true);
         FusionCharts.debugMode.outputTo(function() {
         console.log(arguments);
         });*/
		var self = this;
		var id = 'chart_' + self.id;
		self._toolbar = new ToolBar().create($(self.layoutSlot), self.id, {
			serieChange: function(id) {
				/*				self._chart.series.map(function(s) {
                 s.hide();
                 });
                 self._chart.get(id).show();*/
			},
			serieStyleChange: function(type) {
				/*				forEachKey(self._meta.series, function(key, s) {
                 var series = self._chart.get(s.options.id);
                 self._setType(series, type);
                 });
                 self._chart.redraw();*/
			}
		});
		$('<div />').attr('id', id).appendTo($(self.layoutSlot));

		var proto = self.$prototype;
		// create an alias of item's definition
		proto.$properties = proto.$item.$properties;

		self.$$chart = $('#' + id);
		self.$$chart.insertFusionCharts({
			swfUrl: _getChartStyle("$default"),
			width: "900",
			height: "500",
			id: "my" + id
		});

		/*		self.$$chart.bind("fusionchartsdrawcomplete", function(e, args) {
         console.log("Chart named " + e.sender.id + " drawcomplete.");
         });
         self.$$chart.bind("fusionchartslinkeditemopened", function(e, args) {
         console.log("Chart named " + e.sender.id + " LinkedItemOpened.");
         });
         */
		cubeHelper.initializeMeta(this, styleMap);
		/*
         self._initializeMeta();
         self._initializeToobar();
         */
		if (!self.$item.$isListEmbeded) {
			self.articleParent.bind(self, self.$item.$bind);
		}
	},
	setDataBind: function(value, record, metaData) {
		//this.value = value;
		if (metaData) {
			this._processMeta(metaData);
		}
		if (value) {
			var self = this;

			var source = self._getSource(value, metaData);
			self.$$chart.updateFusionCharts({
				swfUrl: _getChartStyle("stick"),
				dataSource: source,
				dataFormat: "json"
			});
			/*			
             self._chart.xAxis[0].setCategories(settings.categories, false);
             // todo use series.setData
             // remove all current series
             var series = self._chart.series;
             for (var i = series.length; i > 0; i--) {
             // for (var i = 0; i < series.length; i++) {
             series[0].remove(false);
             // series[i].setData(settings.series[series[i].options.id.slice(3)].data);
             }
             self._toolbar.removeAllSeries();
             //add series
             forEachKey(self._meta.series, function(key, s) {
             self._chart.addSeries(settings.series[key], false);
             self._toolbar.addSeries({
             id: s.options.id,
             title: s.options.name
             });
             });
             self._chart.redraw();*/
		}
	},
	onMenuClick: function() {
		console.log('' + this.y);
	},
	_getSource: function(value, metaData) {
		var self = this,
			proto = this.$prototype,
			cube = proto.$cube,
			items = proto.$item.$properties,
			xAxisCode = self._meta.xAxis[0].code;

		var settings = value.reduce(function(res, current) {
			var categoryName = cubeHelper.getMeasureLabel(current, xAxisCode, items);
			categoryName && res.categories.push({
				label: categoryName
			});
			forEachKey(self._meta.series, function(key, s) {
				var serie = res.series[key];
				if (serie == null) {
					serie = {
						seriesname: s.options && s.options.name,
						data: []
					};
					res.series[key] = serie;
					res.dataset.push(serie);
				}
				var value = parseFloat(current[key]);
				serie.data.push({
					value: value,
					// link: "JavaScript: function inspect(o){var s = ''; for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) s +=o[k]; return s;}; console.log(inspect(this)); console.log('" + value + "');"
					// link: "JavaScript: function inspect(o){var s = ''; for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) s += k + '=' + o[k] + ', '; return s;}; console.log(inspect(this);"
					link: "JavaScript: console.log(typeof(this.series));"
				});
			});
			return res;
		}, {
			categories: [],
			series: {},
			dataset: []
		});

		return {
			chart: {
				caption: cube.$title || '',
				// subcaption: "Six Months",
				xaxisname: proto.$axes && proto.$axes.length > 0 && proto.$axes[0].$title,
				yaxisname: '',
				// bgcolor: "E9E9E9",
				canvasbgcolor: "D9E5F1",
				canvasbasecolor: "D9E5F1",
				outcnvbasefontcolor: "666666",
				showlabels: "1",
				showvalues: "0",
				plotfillalpha: "70",
				numvdivlines: "10",
				showalternatevgridcolor: "1",
				alternatevgridcolor: "e1f5ff",
				divlinecolor: "e1f5ff",
				vdivlinecolor: "e1f5ff",
				basefontcolor: "666666",
				canvasborderthickness: "1",
				showplotborder: "0",
				plotborderthickness: "0",
				startangx: "7",
				endangx: "7",
				startangy: "-18",
				endangy: "-18",
				zgapplot: "20",
				zdepth: "60",
				exetime: "2",
				chartorder: "area,column"
			},
			styles: {
				definition: [{
					name: "myToolTipFont",
					type: "font",
					font: "Arial",
					size: "12",
					color: "FF5904"
				}],
				application: [{
					toobject: "ToolTip",
					styles: "myToolTipFont"
				}]
			},

			categories: [{
				category: [settings.categories]
			}],
			dataset: settings.dataset
		};

		/*		var source = {
         legend: {
         align: 'left',
         verticalAlign: 'top',
         x: 30,
         y: 30,
         // floating: true
         },
         xAxis: [{
         categories: [],
         title: {
         text: proto.$axes && proto.$axes.length > 0 && proto.$axes[0].$title
         }
         }],
         yAxis: [{
         min: 0,
         title: {
         text: ''
         }
         }],
         plotOptions: {
         series: {
         cursor: 'pointer',
         point: {
         events: {
         click: function(event) {
         // drill up if shiftKey is pressed
         self._drill(this, event.shiftKey);
         }
         }
         }
         }
         },
         tooltip: {
         formatter: function() {
         var measure = self._meta.series[this.series.options.id.slice(3)].measure;
         var label = '' + this.x + ': <b> ' + (measure ? measure.formatApi.format(this.y, measure.localeFormat) : this.y) + '</b>';
         var data = this.series.processedYData;
         if (measure && (measure.$isNormalized) && data.length > 0) {
         var sum = data.reduce(function(a, b) {
         return a + b;
         });
         label += ' (' + measure.formatApi.format(this.y / sum * 100, measure.localeFormat) + '%)';
         }
         label += '<br/><span style="font-size: 10px; font-style:italic;">Click to drill down</span><br/><span style="font-size: 10px; font-style:italic;">Shift+Click to drill up</span>'
         return label;
         }
         },
         series: []
         };
         if (options.xAxis[0].title.text != options.title) {
         options.xAxis[0].title.text = options.title + ' / ' + options.xAxis[0].title.text;
         }
         return source;
         */
	},
	_initializeToobar: function() {
		var self = this;
		self._toolbar && self._toolbar.show({
			series: (self._meta.hasMeasureSelector && self._meta.displaysOneMeasure),
			chartTypes: self._meta.hasStyleSelector
		});

		self._toolbar && self._toolbar.selectChartType(self._meta.defaultStyle);
	},
	_processMeta: function(proto) {
		// this._processMeasures(proto);
		// this._processLinks(proto);
		// this._processAxes(proto);
	},
	_processMeasures: function(proto) {
		var self = this;
		var cube = this.$prototype.$cube;
		var items = this.$prototype.$properties;

		// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
		// we used all the measures defined in the cube
		var measures = cube.$measures;
		if (measures) {
			var restraintMeasures = measures;
			if (proto.$axes && proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
				restraintMeasures = {};
				_.each(proto.$axes[1].$members[0][0], function(measureCode) {
					restraintMeasures[measureCode] = measures[measureCode];
				});
			}
			_.each(restraintMeasures, function(m, key) {
				// Because duplicate properties is possible for cube definition... we keep the last defined
				var code = (m.$property || key);
				//options.xAxis[0].categories.push(measure.$title || proto.$properties[code].$title || "???");
				var measure = _merge(items[code], m);
				measure.formatApi = _formatApi.getApi(measure.$type);
				measure.numFormatObj = _formatApi.getLocale().getNumberFormatObj(measure.$type);
				measure.localeFormat = measure.$format || measure.numFormatObj.numFormat;

				self._meta.series[code] = {
					options: {
						id: '#s-' + code,
						// legendIndex: "",
						name: measure.$title || '???',
						stack: measure.$isStacked,
						type: measure.$style && (styleMap[measure.$style] || measure.$style),
						visible: !! (!self._meta.displaysOneMeasure || measure.$isDefault)
					},
					measure: measure
				};
				// self._chart && self._chart.addSeries(self._meta.series[code].options);
			});
		}
	},
	_processLinks: function(proto) {
		var self = this;
		self._meta.links = [];
		if (proto.$links) {
			_.each(proto.$links, function(link, id) {
				self._meta.links.push(self._getLinkDef("$links", id, link));
			}, self);
		}
		// need to validate the spec about these points
		/*
         if(proto.$actions) {
         _.each(proto.$actions, function(link, id) {
         self._meta.links.push(self._getLinkDef("$actions", id, link));
         }, self);
         }
         if(self._meta.xAxis[0].code && proto.$properties && proto.$properties[self._meta.xAxis[0].code].$thumb && proto.$properties[self._meta.xAxis[0].code].$thumb.$links) {
         _.each(proto.$properties[self._meta.xAxis[0].code].$thumb.$links, function(link, id) {
         self._meta.links.push(self._getLinkDef("$links", id, link));
         }, self);
         }
         */
	},
	_processAxes: function(proto) {
		var cube = this.$prototype.$cube;
		if (!cubeHelper.isValid(cube, proto)) return false;

		var self = this;
		var currAxisHier = 0;
		// TODO: review this
		// Get axis analysis
		var mainHLevelsTab = null;
		_.each(proto.$axes[0].$hierarchies, function(hierarchy, idx) {
			if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
				mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
				if (mainHLevelsTab) {
					self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
					currAxisHier = idx;
				}
			}
		});
		if (!mainHLevelsTab && proto.$axes[0].$hierarchies[0].length > 0) {
			mainHLevelsTab = cube.$hierarchies[proto.$axes[0].$hierarchies[0][0]].$properties;
			if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
		}

		// Get drill definition
		var properties;
		self._meta.drill.code = proto.$codeStat || "UNKNOWN";
		self._meta.drill.axis0FieldCode = self._meta.xAxis[0].code || "";

		_.each(proto.$axes[0].$hierarchies, function(hierarchie) {
			properties = cube.$hierarchies[hierarchie[0]].$properties;
			_.each(properties, function(property) {
				this.levelsProperties[this.maxLevel++] = property;
			}, self._meta.drill);
		});
		self._meta.drill.maxLevel = Math.max(self._meta.drill.maxLevel, self._meta.drill.minLevel);
		if (proto.$axes[0].$members) {
			_.each(proto.$axes[0].$members, function(tuple) {
				_.each(tuple, function(value) {
					if (value.length > 0) {
						this.members[this.currLevel++-1] = value[0];
					}
				}, this);
			}, self._meta.drill);
		}
	},
	_getLinkDef: function(type, id, link) {
		return {
			"type": type,
			"id": id,
			"link": link,
			"title": link.$title
		};
	},

	// --------------------------------------------------------------------------------
	// Chart action management
	// --------------------------------------------------------------------------------
	_executeRecordMenu: function(context) {
		if (!this.recordArticle) {
			this.recordArticle = new RecordArticle();
			this.recordArticle.$prototype = this.$prototype.$item;
			this.page.initializeNewItem(this.recordArticle, {}, this);
			this.recordArticle.loadBox(context.$item);
		} else {
			this.recordArticle.applyChange(context.$item);
		}
		this.recordArticle.menuItems[Object.keys(context["$links" || "$actions"])[0]][0].click();
	},
	_execLink: function(context) {
		this._executeRecordMenu(context);
	},
	_drill: function(serie, up) {
		//alert('Category: ' + serie.category + ', value: ' + serie.y);
		var self = this;
		var cube = this.$prototype.$cube;
		var meta = self._meta;
		var i = meta.drill.currAxisHier;
		var stack = self._meta.drill.stack;

		if (up) {
			// already on top ?
			if (stack.length < 2) return;
			stack.shift();
			meta.drill.currAxisHier--;
			this._fetch(stack[0]);
			return;
		}
		var proto = stack[0];
		var members = proto.$axes[0].$members;
		if (!members) {
			members = proto.$axes[0].$members = [];
		}
		stack.unshift(objectClone(proto, true));
		proto = stack[0];
		members = proto.$axes[0].$members;
		var hierarchies = proto.$axes[0].$hierarchies;

		var cubeHier = cube.$hierarchies[hierarchies[i][0]];
		if (hierarchies[i][2] == (cubeHier.$properties ? cubeHier.$properties.length - 1 : -1)) {
			hierarchies[i].splice(1, 2, 0, 0);
			hierarchies[i + 1].splice(1, 2, 1, 0);
			meta.drill.currAxisHier++;
		} else {
			hierarchies[i][2]++;
		}
		if (members.length < i + 1) {
			members[i] = [];
		}
		members[i].push([serie ? "" + serie.x : "???"]);

		this._fetch(proto);
	},
	_fetch: function(proto) {
		this.fetch({
			jsonParams: {
				$axes: proto.$axes,
				$slicer: proto.$slicer
			}
		});
	},
});