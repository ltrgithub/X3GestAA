"use strict";

var helpers = require('syracuse-core/lib/helpers');
var d3 = require('syracuse-ui/deps/d3');

function D3Legend() {
	//
	this._align = "bottom";
	this._cols = 4;
	this._memberWidth = 80;
	this._margin = 10;
	this._memberMargin = 5;
	this._memberHeight = 12;
	//
	this.left = 0;
	this.top = 0;
}

exports.D3Legend = helpers.defineClass(D3Legend, null, {
	align: function(type) {
		this._align = type;
		return this;
	},
	cols: function(nbCols) {
		this._cols = nbCols;
		return this;
	},
	memberWidth: function(w) {
		this._memberWidth = w;
		return this;
	},
	memberMargin: function(m) {
		this._memberMargin = m;
		return this;
	},
	memberHeight: function(h) {
		this._memberHeight = h;
		return this;
	},
	margin: function(m) {
		this._margin = m;
		return this;
	},
	colors: function(clr) {
		this._colors = clr;
		return this;
	},
	items: function(it) {
		this._items = it;
		return this;
	},
	render: function(container, selectedMap, onLegendClick) {
		// TODO : manage other orientations than "bottom"
		var legend = this;
		// TODO: see if we should compute w,h differently
		var containerW = +container.attr("width");
		var containerH = +container.attr("height");
		//
        var legendRowCount = Math.ceil((this._items || []).length / this._cols);
        this.left = Math.round((containerW - 2 * this._margin - (this._cols * (this._memberWidth + this._memberMargin))) / 2);
        this.top = containerH - (legendRowCount * this._memberHeight + 2 * this._memberMargin + 2 * this._margin);
        //
        var itemX = this._memberMargin, itemY = this._memberMargin;
        var crtRow = 0, crtCol = 0;
        // container should be an SVG
        var svgLegend = container.append("svg:g").attr("class", "d3-graph-svg-legend-container").attr("transform", "translate("+this.left+","+this.top+")");
        var i = 0;
        (this._items || []).forEach(function(categ) {
        	selectedMap[categ.$title] = categ.$selected;
        	// add member
        	var item = svgLegend.append("svg:rect").attr("class", "d3-graph-svg-legend-check").attr("category", categ.$title)
        			.attr("x", itemX).attr("y", itemY).attr("width", legend._memberHeight).attr("height", legend._memberHeight)
        			.attr("rx", 2).attr("ry", 2);
        	item.style("fill", function(d) {
        		return legend._colors[i++];
        	});
        	var textId = "a" + helpers.uuid.generate();
        	item.attr("text-node-id", textId);
        	var text = svgLegend.append("svg:text").attr("id", textId).attr("category", categ.$title)
        			.attr("class", "d3-graph-legend-nodetext").attr("x", itemX+legend._memberMargin*2+legend._memberHeight)
        			.attr("y", itemY+legend._memberHeight-3).text(categ.$title);
        	if(!categ.$selected) text.attr("class", "d3-graph-legend-nodetext-unselected");
        	text.on("click", function(d) {
        		var categName = this.attributes["category"].nodeValue;
        		selectedMap[categName] = !selectedMap[categName];
        		// grey / ungrey text
        		svgLegend.select("#"+this.id).classed("d3-graph-legend-nodetext-unselected", !selectedMap[categName]);
        		//
        		if(onLegendClick && (typeof onLegendClick === "function")) onLegendClick(categName, selectedMap[categName]);
        	});
        	item.on("click", function(d) {
        		var categName = this.attributes["category"].nodeValue;
        		selectedMap[categName] = !selectedMap[categName];
        		// grey / ungrey text
        		svgLegend.select("#"+this.attributes["text-node-id"].nodeValue).classed("d3-graph-legend-nodetext-unselected", !selectedMap[categName]);
        		//         		
        		if(onLegendClick && (typeof onLegendClick === "function")) onLegendClick(categName, selectedMap[categName]);
        	});
        	// compute next position
        	if(crtCol++ == legend._cols-1) {
        		crtCol = 0;
        		crtRow++;
        	}
        	itemX = crtCol*(legend._memberWidth + legend._memberMargin) + legend._memberMargin;
        	itemY = crtRow*(legend._memberHeight + legend._memberMargin) + legend._memberMargin;
        });
	}
});