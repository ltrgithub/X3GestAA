"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Article = require("syracuse-ui/lib/article/article").Article;
var sapUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Fusion;
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
require('syracuse-ui/deps/fullcalendar/planningfullcalendar');
require('syracuse-ui/deps/fullcalendar/fullcalendar');
var formatApi = require('syracuse-ui/lib/field/formatApi');

var aspectRatio = 2.5;
var _days = [0, 1, 2, 3, 4, 5, 6];
var _months = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
var debug = false;

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== 'undefined' && obj !== null;
}

var _tip;

function _toggleEventTip(calEvent, jsEvent) {
	if (!calEvent) {
		_tip && _tip.popup.close();
		_tip = null;
	} else {
		if (_tip) {
			var target = _tip.target;
			_toggleEventTip();
			if (target == $(jsEvent.target).parent())
				return;
		}
		_tip = {
			slot: document.createElement("aside"),
			target: $(jsEvent.target).parent()
		};
		_tip.slot.className = "s-agenda-tip";
		var div = document.createElement("header");
		div.className = "s-agenda-tip-title";
		div.textContent = calEvent.title;
		_tip.slot.appendChild(div);

		div = document.createElement("div");
		div.className = "s-agenda-tip-period";

		["start", "end"].forEach(function(key) {
			var dt = calEvent[key];
			var item = document.createElement("div");
			item.className = "s-agenda-tip-period-dt";

			var lb = document.createElement("div");
			lb.className = "s-agenda-tip-period-dt-lb";
			lb.textContent = syra_local["plcal_" + key];
			item.appendChild(lb);

			var val = document.createElement("div");
			val.className = "s-agenda-tip-period-dt-val";

			val.textContent = datetime.parse(dt._i, dt.f).toString("yyyy-MM-dd HH:mmZ").slice(0, -1);
			item.appendChild(val);
			div.appendChild(item);
		});

		_tip.slot.appendChild(div);

		if (calEvent.description) {
			div = document.createElement("div");
			div.className = "s-agenda-tip-description";
			div.innerHTML = calEvent.description;
			_tip.slot.appendChild(div);
		}

		if (calEvent.summary) {
			div = document.createElement("div");
			div.className = "s-agenda-tip-summary";
			div.textContent = calEvent.summary;
			_tip.slot.appendChild(div);
		}

		_tip.popup = syra_site.dialogManager.openPopup(syra_site, {
			content: {},
			slot: _tip.slot,
			position: {
				my: "left top",
				at: "right top",
				of: $(_tip.target)
			}
		});
	}
}

function PlanningCalendar() {}

exports.PlanningCalendar = helpers.defineClass(PlanningCalendar, Article, {
	dispose: function() {
		_toggleEventTip();
		Article.prototype.dispose.call(this);
	},
	resizeChart: function() {
		var self = this;
		debug && console.log("PlanningCalendar.resize");

		self.displayed = true;

		if (self.calendar) {

			if (self.resizeTimer)
				clearTimeout(self.resizeTimer);

			self.resizeTimer = setTimeout(function() {
				if (self.calendar) {
					if (self.layoutSlot.clientWidth) {
						debug && self.calendar && console.log("PlanningCalendar.resizeTimer " + self.id + ": resize(" + self.calendar.size.width + ")");

						// width minus 1 because of scrollbar issue on firefox
						var calWidth = self.calendar.size.width;
						self._resize(Math.max(calWidth ? calWidth : 0, self.layoutSlot.clientWidth) - 1);
					}
				}
			}, 200);
		}
	},
	drawBox: function() {
		this.page.defaultItemsPerPage = 500;
		//this.attacheField.$item.$graphPosition = "front";
		var proto = this.$prototype;
		proto.$properties = proto.$item && proto.$item.$properties;
		this._drawBox && this._drawBox();
		this.page && this.page.vignetteField && this.page.vignetteField.enableDesigner(false);
	},
	setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		var self = this;
		var tabularChart = false;

		debug && console.log("PlanningCalendar.setDataBind");

		if (self._preSetDataBind && !self._preSetDataBind(dataRecordSet, parentDataRecord, metaData)) {
			return;
		}

		if ((self.$item.$category && self.$item.$category == "tabularChart") || (self.$prototype.$type == "application/x-array")) {
			self._fixDataSet();
			tabularChart = true;
		}

		self._setDataBind && self._setDataBind(tabularChart ? self.dataset : dataRecordSet, parentDataRecord, metaData);
	},

	_resize: function(width) {
		if (this._widget) {

			this._widget.attr('style', 'width: ' + width + 'px; margin: 0 auto;');

			if (this.calendar) {
				if (self.usingPlanningCalendar) {
					this._widget.planningFullCalendar('option', 'aspectRatio', aspectRatio);
				} else {
					this._widget.fullCalendar('option', 'aspectRatio', aspectRatio);
					$('.fc-more').each(function(index, elem) {
						elem.text = elem.text.slice(1);
					});
				}
			}
		}
	},

	_createLandingPageCalendarWidget: function(calendarType) {
		var self = this;
		var calendar = self._widget.fullCalendar({
			lang: formatApi.getLocale().currentLangCode,
			aspectRatio: aspectRatio,
			defaultView: self.attachedField.$item.$calendarView,
			header: {
				left: 'prev,next today',
				center: 'title',
				right: 'month,agendaWeek,basicWeek,agendaDay,basicDay'
			},

			monthNames: _months.map(function(i) {
				return date.monthName(i + 1);
			}),
			monthNamesShort: _months.map(function(i) {
				return date.monthName(i + 1, true);
			}),
			dayNames: _days.map(function(i) {
				return date.dayName(i);
			}),
			dayNamesShort: _days.map(function(i) {
				return date.dayName(i, true);
			}),
			allDayHtml: syra_local.plcal_allday,

			eventLimitText: syra_local.plcal_more,

			firstDay: 1,
			axisFormat: 'H(:mm)',
			timeFormat: 'H(:mm)',

			//timezone: 'local',

			buttonText: {
				month: syra_local.plcal_month,
				week: syra_local.plcal_week,
				day: syra_local.plcal_day,
				today: syra_local.plcal_today
			},

			eventClick: function(calEvent, jsEvent, view) {
				_toggleEventTip(calEvent, jsEvent);
				return false;
			},

			eventAfterAllRender: function() {
				$('.fc-more').each(function(index, elem) {
					elem.text = elem.text.slice(1);
				});
			},

			viewRender: function() {
				if (self.calendar) {
					var selected = self.calendar.fullCalendar("getView").name;
					self.attachedField.$userPreferences = self.attachedField.$userPreferences || {};
					self.attachedField.$userPreferences.$calendarView = self.attachedField.$item.$calendarView = selected;
					self.attachedField.savePreferences(false);
				}
				$('.fc-button.fc-agendaWeek-button.fc-state-default', $('.fc-right')).text(syra_local.plcal_week);
				$('.fc-button.fc-agendaWeek-button.fc-state-default', $('.fc-right')).prepend('<span class="fc-tab-icon s-fonticon-btn">\uf101</span>');

				$('.fc-button.fc-agendaDay-button.fc-state-default', $('.fc-right')).text(syra_local.plcal_day);
				$('.fc-button.fc-agendaDay-button.fc-state-default', $('.fc-right')).prepend('<span class="fc-tab-icon s-fonticon-btn">\uf101</span>');

				$('.fc-right').find('.fc-month-button').addClass('s-button-right');
				$('.fc-right').find('.fc-basicWeek-button').addClass('s-button-right');
			},

			selectable: true,
			selectHelper: false,

			defaultDate: new Date(),
			eventLimit: true,

			events: function(start, end, timezone, callback) {
				var events = self._events;
				callback(events || []);
			}
		});
		self.calendar = calendar;
	},

	_createPlanningCalendarWidget: function(calendarType) {
		var self = this;

		var calendar = self._widget.planningFullCalendar({
			aspectRatio: aspectRatio,

			header: {
				left: 'prev,next',
				center: 'title',
				right: 'planningYear,planningMonth'
			},

			planningCalendar: true,
			planningSlotsPerCell: self.planningSlotsPerCell,
			planningDayTypes: self.planningDayTypes,
			defaultView: self.defaultView,
			defaultDate: self.calendarYear,

			buttonText: {
				year: syra_local.plcal_year,
				month: syra_local.plcal_month,
				week: syra_local.plcal_week,
				day: syra_local.plcal_day
			},

			monthNames: _months.map(function(i) {
				return date.monthName(i + 1);
			}),
			monthNamesShort: _months.map(function(i) {
				return date.monthName(i + 1, true);
			}),
			dayNames: _days.map(function(i) {
				return date.dayName(i);
			}),
			dayNamesShort: _days.map(function(i) {
				return date.dayName(i, true);
			}),
			firstDay: 1,

			selectable: false,
			selectHelper: false,

			select: function(start, end, allDay) {},
			unselect: function(ev) {
				debug && console.log("calendar.unselect " + ev);
			},
			editable: false,

			events: function(start, end, timezone, callback) {
				var events = self._events;
				callback(events || []);
			},

			// ui events
			loading: function(inProgress) {
				debug && console.log("planningCalendar.loading " + inProgress);
			},
			viewRender: function(planningView) {
				// set the default view to the new view name in order to maintain the view type when changing between years.
				self.defaultView = planningView.name;
				debug && console.log("planningCalendar.viewRender");
			},
			viewDisplay: function() {
				debug && console.log("planningCalendar.viewDisplay");
			},
			windowResize: function() {
				debug && console.log("planningCalendar.windowResize");
			},
			eventRender: function(event) {
				debug && console.log("planningCalendar.eventRender " + event);
			},
			eventAfterRender: function(event) {
				debug && console.log("planningCalendar.eventAfterRender " + event);
			},
			eventResizeStart: function(event) {
				debug && console.log("planningCalendar.eventResizeStart " + event);
			},
			eventResizeStop: function(event) {
				debug && console.log("planningCalendar.eventResizeStop " + event);
			},
			eventResize: function(event, dayDelta, minuteDelta) {
				debug && console.log("planningCalendar.eventResize " + event);
			},
			dayClick: function(date, allDay) {
				debug && console.log("planningCalendar.dayClick " + date);
			},
			eventClick: function(event) {
				debug && alert(event.title);
			},
			eventMouseover: function(event) {
				debug && console.log("planningCalendar.eventMouseover " + event);
			},
			eventMouseout: function(event) {
				debug && console.log("planningCalendar.eventMouseout " + event);
			},
			eventDragStart: function(event) {
				debug && console.log("planningCalendar.eventDragStart " + event);
			},
			eventDragStop: function(event) {
				debug && console.log("calendar.eventDragStop " + event);
			},
			eventDrop: function(event, dayDelta, minuteDelta, allDay) {
				debug && console.log("planningCalendar.eventDrop " + event);
			},
			drop: function(date, b) {
				debug && console.log("planningCalendar.drop " + date);
			},
		});
		self.calendar = calendar;
	},

	_events: function() {
		debug && console.log("Events");
	},

	_drawBox: function() {
		var self = this;
		var id = "a" + helpers.uuid.generate();
		self._widget = $('<div />').attr('id', "cal_" + id).appendTo(self.layoutSlot);
	},

	_preSetDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		return !(parentDataRecord && parentDataRecord.$isPartialDelta);
	},

	_setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		var self = this;
		debug && console.log("PlanningCalendar.setDataBind " + self.id + ": dataset=" + (self.dataset && self.dataset.length) + " , size=(" + self.layoutSlot.clientWidth + ", " + self.layoutSlot.clientHeight + ")");

		var $bindings = self.$prototype.$decorator.$bindings;
		if ($bindings) {
			self._setPlanningCalendarDataBind($bindings, dataRecordSet, parentDataRecord, metaData);
		} else {
			self._setLandingPageCalendarDataBind(self.$prototype.$item.$properties, dataRecordSet, parentDataRecord, metaData);
			// var list = self.attachedField;
			// if (list.pagging) {
			// 	list.pagging.draw();
			// 	list.pagging.pagerTop && list.pagging._showPager(list.pagging.pagerTop, true);
			// }
		}
	},
	_setLandingPageCalendarDataBind: function($bindings, dataRecordSet, parentDataRecord, metaData) {
		var self = this;

		if (parentDataRecord && parentDataRecord.agenda) {
			self._events = [];
			var $events = parentDataRecord.agenda.$events;

			$events.forEach(function(event) {

				/*
				 * If we have neither start nor end datetimes, we can't display the event.
				 */
				if (!((event.start.datetime && event.start.datetime.length) || (event.end.datetime && event.end.datetime.length))) {
					return;
				}

				if (event.start.datetime && event.start.datetime.length) {
					/*
					 * Parse to ensure correct format.
					 */
					event.start.datetime = datetime.parse(event.start.datetime).toString();
				}

				if (event.end.datetime && event.end.datetime.length) {
					/*
					 * Parse to ensure correct format.
					 */
					event.end.datetime = datetime.parse(event.end.datetime).toString();
				}

				var fcEvent = {};

				fcEvent.title = event.summary;
				fcEvent.description = event.description;
				fcEvent.id = event.id;

				if (!(event.start.datetime && event.start.datetime.length)) {
					/*
					 * We don't have a start datetime, so make the start datetime the same as the end datetime
					 */
					fcEvent.start = event.end.datetime;
					fcEvent.end = event.end.datetime;
				} else
				if (!(event.end.datetime && event.end.datetime.length)) {
					/*
					 * We don't have an end datetime, so make the end datetime the same as the start datetime
					 */
					fcEvent.start = event.start.datetime;
					fcEvent.end = event.start.datetime;
				} else {

					var startDate = datetime.parse(event.start.datetime).utcDate;
					var endDate = datetime.parse(event.end.datetime).utcDate;

					if (startDate > endDate) {
						/*
						 * With some X3 requests, we get the event endtime starting before the starttime!
						 * In this case, make the end date the same as the start date.
						 */

						fcEvent.start = event.start.datetime;
						fcEvent.end = event.start.datetime;

					} else {

						var startHour = new Date(event.start.datetime).getUTCHours();
						var startMinutes = new Date(event.start.datetime).getMinutes();

						var endHour = new Date(event.end.datetime).getUTCHours();
						var endMinutes = new Date(event.end.datetime).getMinutes();

						if (startHour === 0 && startMinutes === 0 && endHour === 0 && endMinutes === 0) {

							fcEvent.start = event.start.datetime;

							/*
							 * A one-day all-day event from the server is from 00:00 to 00:00 on the SAME day.
							 * So, we need to add 24 hours to the end date that we get from the server.
							 */
							fcEvent.end = datetime.parse(event.end.datetime).addDays(1).toString();
							fcEvent.allDay = true;
						} else {
							fcEvent.start = event.start.datetime;
							fcEvent.end = event.end.datetime;
						}
					}
				}

				self._events.push(fcEvent);
			});

			self._createLandingPageCalendarWidget();
		}
	},

	_setPlanningCalendarDataBind: function($bindings, dataRecordSet, parentDataRecord, metaData) {
		var self = this;
		self.usingPlanningCalendar = true;

		if (dataRecordSet === 'undefined' || dataRecordSet.length === 0) {
			return;
		};

		self.planningSlotsPerCell = $bindings.SLOT.length;

		var renderedYear = self.calendarYear && self.calendarYear.slice(0, 4);

		if (dataRecordSet) {
			self._events = [];
			dataRecordSet.forEach(function(e) {
				var eventDate = e[$bindings.TECDAT].substring(0, 10);
				var eventType = e[$bindings.TYPDAY];
				var eventSlotData = $bindings.SLOT &&
					$bindings.SLOT.map(function($bind) {
						return e[$bind];
					}) || [];

				eventSlotData.forEach(function(slot, i) {
					self._events.push({
						title: '',
						start: eventDate,
						end: eventDate,
						dayType: eventType,
						slotType: slot,
						slot: i
					});
				});
			});

			self.calendarYear = self._events[5].start;
		}

		self.planningDayTypes = [];
		self.$prototype.$decorator.$events &&
			self.$prototype.$decorator.$events.forEach(function(dayType) {
				self.planningDayTypes.push(syra_site.expressionMaker.render(self, dayType));
			});

		if (self.calendar) {
			if (renderedYear && renderedYear !== self.calendarYear.slice(0, 4)) {
				// We've changed calendar year, so regenerate the entire calendar - not just the events!
				$(self.layoutSlot).find("div[id*=cal]").remove();
				self._drawBox();
			} else {
				self._widget.planningFullCalendar('refetchEvents');
			}
		} else {
			var view = self.$prototype.$decorator.$style;
			if (view == 'year') {
				self.defaultView = 'planningYear';
			} else {
				self.defaultView = 'planningMonth';
			}
		}

		self._createPlanningCalendarWidget();
	},

	_fixDataSet: function() {
		var self = this;
		self.ensureDataSet();

		var fixedDataSet = self.dataset;
		if (self.page.externalAdapter.fusionSite) {
			var last = fixedDataSet && fixedDataSet.length > 0 && fixedDataSet[fixedDataSet.length - 1] || {};

			// An improvement can be done be using getDataStoreRecordsNumber() exposed by Convergence window class
			if (sapUtil.isEmptyGridDataRecordEx(self.$prototype.$properties, last)) {
				fixedDataSet = fixedDataSet.slice(0, -1);
			}
		}
		self.dataset = fixedDataSet;
	}
});