"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Article = require("syracuse-ui/lib/article/article").Article;
var sapUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Fusion;
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var formatApi = require('syracuse-ui/lib/field/formatApi');
var _moment;
var aspectRatio = 2.5;
var _days = [0, 1, 2, 3, 4, 5, 6];
var _months = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
var debug = false;

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== 'undefined' && obj !== null;
}

var _tip;

function _toggleEventTip(calEvent, jsEvent) {
	if (!calEvent) {
		_tip && _tip.popup.close();
		_tip = null;
	} else {
		if (_tip) {
			var target = _tip.target;
			_toggleEventTip();
			if (target == $(jsEvent.target) || target == $(jsEvent.target).parent())
				return;
		}
		_tip = {
			slot: document.createElement("aside")
		};

		if ($.inArray($(jsEvent.target).parent().context.className, ["fc-time", "fc-title"]) == -1)
			_tip.target = $(jsEvent.target);
		else
			_tip.target = $(jsEvent.target).parent();

		_tip.slot.className = "s-agenda-tip";
		var div = document.createElement("header");
		div.className = "s-agenda-tip-title";
		div.textContent = calEvent.title;
		_tip.slot.appendChild(div);

		div = document.createElement("div");
		div.className = "s-agenda-tip-subtitle";
		div.textContent = calEvent.subtitle;
		_tip.slot.appendChild(div);

		div = document.createElement("div");
		div.className = "s-agenda-tip-period"; // s-fc-category-type-" + calEvent.category;
		if (calEvent.category > 0) {
			var statusDiv = document.createElement("div");
			statusDiv.className = "ted pb-pattern o-lines-bold s-fc-tip-status s-fc-status-color-" + calEvent.category;
			div.appendChild(statusDiv);
		} else {
			div.className += " s-fc-status-color-0";
		}

		["start", "end"].forEach(function(key) {

			var dt = calEvent[key === "end" ? "actualEnd" : key];
			var item = document.createElement("div");
			item.className = "s-agenda-tip-period-dt";

			var lb = document.createElement("div");
			lb.className = "s-agenda-tip-period-dt-lb";
			lb.textContent = syra_local["plcal_" + key];
			item.appendChild(lb);

			var val = document.createElement("div");
			val.className = "s-agenda-tip-period-dt-val";

			if (key === "end" && calEvent.endFormat) {
				val.textContent = datetime.parse(dt._i, dt.f).toString(formatApi.getLocalFormat(calEvent.endFormat));
			} else {
				val.textContent = datetime.parse(dt._i, dt.f).toString(formatApi.getLocalFormat("application/x-datetime") + "Z").slice(0, -1);
			}

			item.appendChild(val);
			div.appendChild(item);
		});

		_tip.slot.appendChild(div);

		if (calEvent.description) {
			div = document.createElement("div");
			div.className = "s-agenda-tip-description";
			div.appendChild(calEvent.description);
			_tip.slot.appendChild(div);
		}

		if (calEvent.summary) {
			div = document.createElement("div");
			div.className = "s-agenda-tip-summary";
			div.textContent = calEvent.summary;
			_tip.slot.appendChild(div);
		}

		_tip.popup = syra_dlg.openPopup(syra_site, {
			content: {},
			slot: _tip.slot,
			position: {
				my: "left top",
				at: "right top",
				of: $(_tip.target)
			}
		});
	}
}

function PlanningCalendar() {}

exports.PlanningCalendar = helpers.defineClass(PlanningCalendar, Article, {
	loadBox: function(initData) {
		var self = this;
		syra_site.loadStyleSheet("fullcalendar/fullcalendar.css");
		syra_site.loadStyleSheet("fullcalendar/planningfullcalendar.css");
		syra_site.loadStyleSheet("patternbolt/patternbolt.css");
		require.async('syracuse-ui/deps/fullcalendar/planningfullcalendar', function(err, module) {
			require.async('syracuse-ui/deps/fullcalendar/fullcalendar', function(err, module) {
				require.async('syracuse-ui/deps/fullcalendar/moment', function(err, module) {
					_moment = module;
					self.isLoaded = true;
					Article.prototype.loadBox.call(self, initData);
					if (self.isDatabindRequested) {
						var $bind = self.attachedField.$item.$bind;
						var dataset = self.articleParent.dataset;
						self.setDataBind(dataset[$bind], dataset, dataset.$properties && dataset.$properties[$bind], $bind);
						delete self.isDatabindRequested;
					}
					if (self.page && self.page.dialogWrapper) {
						self.page.resizeArticle();
					}
				});
			});
		});
	},
	dispose: function() {
		_toggleEventTip();
		Article.prototype.dispose.call(this);
	},
	resizeChart: function() {
		var self = this;
		self.displayed = true;
		if (self.calendar) {
			self.resizeTimer && clearTimeout(self.resizeTimer);
			self.resizeTimer = setTimeout(function() {
				if (self.calendar) {
					if (self.layoutSlot.clientWidth) {
						// width minus 1 because of scrollbar issue on firefox
						var calWidth = self.calendar.size.width;
						self._resize(Math.max(calWidth ? calWidth : 0, self.layoutSlot.clientWidth) - 1);
					}
				}
			}, 200);
		}
	},
	drawBox: function() {
		this.page.defaultItemsPerPage = 500;
		var proto = this.$prototype;
		proto.$properties = proto.$item && proto.$item.$properties;
		this._drawBox && this._drawBox();
		if (this.page.vignetteField) {
			this.page.vignetteField.isDesignModeEnabled = false;
		}
	},
	setDataBind: function(dataRecordSet, parentDataRecord, metaData) {

		function filtersActive() {
			var filterProp = (parentDataRecord.agenda.$calendars[0]).$pageFilter;
			var startFilterProp = filterProp.start[0];
			var endFilterProp = filterProp.end[0];

			return startFilterProp &&
				self.page.$prototype.$properties.$criteria &&
				self.page.$prototype.$properties.$criteria.$item.$properties[startFilterProp] &&
				endFilterProp &&
				self.page.$prototype.$properties.$criteria.$item.$properties[endFilterProp];
		}

		var self = this;
		if (self.isLoaded) {
			if (self._preSetDataBind && !self._preSetDataBind(dataRecordSet, parentDataRecord, metaData)) {
				return;
			}
			if ((self.$item.$category && self.$item.$category == "tabularChart") || (self.$prototype.$type == "application/x-array")) {
				self._fixDataSet();
				dataRecordSet = self.dataset;
			}
			var $bindings = self.$prototype.$decorator.$bindings;
			if ($bindings) {
				self._setPlanningCalendarDataBind($bindings, dataRecordSet, parentDataRecord, metaData);
			} else {
				self._events = [];

				if (parentDataRecord && parentDataRecord.agenda) {
					if (parentDataRecord.agenda.$calendars[0]) {
						if (parentDataRecord.agenda.$calendars[0].$colorLegend) {
							self._addCalendarLegend(parentDataRecord.agenda.$calendars[0].$colorLegend.legend);
						}
						self.$categoryLegend = (parentDataRecord.agenda.$calendars[0]).$categoryLegend;

						/*
						 * We're disabling paging until such time as the "or" operator is implemented for requests.
						 */
						// if (filtersActive()) {
						// 	self.$prototype.$filter = (parentDataRecord.agenda.$calendars[0]).$pageFilter;						
						// } else {
						self._setLandingPageCalendarDataBind(self.$prototype.$item.$properties, dataRecordSet, parentDataRecord, metaData);
						// }
						self._widget.planningFullCalendar('refetchEvents');
					}
				}

				self._createLandingPageCalendarWidget();

				// var list = self.attachedField;
				// if (list.paging) {
				// 	list.paging.draw();
				// 	list.paging.pagerTop && list.paging._showPager(list.paging.pagerTop, true);
				// }
			}
		} else {
			self.isDatabindRequested = true;
		}
	},
	_resize: function(width) {
		if (this._widget) {

			this._widget.attr('style', 'width: ' + width + 'px; margin: 0 auto;');

			if (this.calendar) {
				if (self.usingPlanningCalendar) {
					this._widget.planningFullCalendar('option', 'aspectRatio', aspectRatio);
				} else {
					this._widget.fullCalendar('option', 'aspectRatio', aspectRatio);
					$('.fc-more').each(function(index, elem) {
						elem.text = elem.text.slice(1);
					});
				}
			}
		}
	},

	_createLandingPageCalendarWidget: function(calendarType) {
		var self = this;
		var calendar = self._widget.fullCalendar({
			lang: formatApi.getLocale().currentLangCode,
			aspectRatio: aspectRatio,
			defaultView: self.attachedField.$item.$calendarView,
			header: {
				left: 'prev,next today',
				center: 'title',
				right: 'month,agendaWeek,basicWeek,agendaDay,basicDay'
			},

			monthNames: _months.map(function(i) {
				return date.monthName(i + 1);
			}),
			monthNamesShort: _months.map(function(i) {
				return date.monthName(i + 1, true);
			}),
			dayNames: _days.map(function(i) {
				return date.dayName(i);
			}),
			dayNamesShort: _days.map(function(i) {
				return date.dayName(i, true);
			}),
			allDayHtml: syra_local.plcal_allday,

			eventLimitText: syra_local.plcal_more,

			firstDay: 1,
			axisFormat: 'H(:mm)',
			timeFormat: 'H:mm',

			//timezone: 'local',
			slotEventOverlap: false,

			buttonText: {
				month: syra_local.plcal_month,
				week: syra_local.plcal_week,
				day: syra_local.plcal_day,
				today: syra_local.plcal_today
			},

			eventClick: function(calEvent, jsEvent, view) {
				_toggleEventTip(calEvent, jsEvent);
				return false;
			},

			eventAfterAllRender: function() {
				$('.fc-more').each(function(index, elem) {
					elem.text = elem.text.slice(1);
				});
			},

			eventMouseover: function(event, jsEvent, view) {
				this.showTimeOut = setTimeout(function() {

					if (self.$categoryLegend) {
						var toolTip = self.$categoryLegend.legend[event.category];
						if (toolTip) {
							syra_tip.titleTip.show(toolTip, $(jsEvent.target) || target == $(jsEvent.target).parent(), false);
						}
					}
				}, 100); // short delay required to prevent tool tip being cleared when moving over event sub-elements e.g. event text.
			},

			eventAfterRender: function(event, element, view) {

				element.addClass("s-fc-color-type-" + event.color);

				var childNode = element[0].firstChild; // childNode == fc-content
				var infoDiv = document.createElement("div");
				infoDiv.className = "s-fc-info";

				var children = childNode.childNodes;
				for (var i = 0; i < children.length; i++) {
					infoDiv.appendChild(children[i]);
				}
				childNode.appendChild(infoDiv);

				if (event.category > 0) {
					var statusDiv = document.createElement("div");
					statusDiv.className = "ted pb-pattern o-lines-bold s-fc-status s-fc-status-color-" + event.category;
					childNode.insertBefore(statusDiv, childNode.firstChild); // add status div as a first child of fc-content.
				}

				if (self._eventPreceedsView(event, view)) {
					view.segEach(function(seg) {
						if ((seg.row == 0) && seg.el == element) {
							self._addPreviousArrow(event, element, view);
						}
					}, event);
				}
				if (self._eventExceedsView(event, view)) {
					view.segEach(function(seg) {
						if ((seg.row == view.rowCnt - 1) && seg.el == element) {
							self._addNextArrow(event, element, view);
						}
					}, event);
				}
			},

			viewRender: function(view) {
				if (self.calendar) {
					var selected = self.calendar.fullCalendar("getView").name;
					self.attachedField.$userPreferences = self.attachedField.$userPreferences || {};
					self.attachedField.$userPreferences.$calendarView = self.attachedField.$item.$calendarView = selected;
					self.attachedField.saveListDesign(false, self.attachedField.$userPreferences);
				}
				var $$right = $('.fc-right');
				$('.fc-button.fc-agendaWeek-button.fc-state-default', $$right).text(syra_local.plcal_week);
				$('.fc-button.fc-agendaWeek-button.fc-state-default', $$right).prepend('<span class="fc-tab-icon s-fonticon-btn">' + syra_menus.fontIcons.time + '</span>');

				$('.fc-button.fc-agendaDay-button.fc-state-default', $$right).text(syra_local.plcal_day);
				$('.fc-button.fc-agendaDay-button.fc-state-default', $$right).prepend('<span class="fc-tab-icon s-fonticon-btn">' + syra_menus.fontIcons.time + '</span>');

				$$right.find('.fc-month-button').addClass('s-button-right');
				$$right.find('.fc-basicWeek-button').addClass('s-button-right');
			},

			selectable: true,
			selectHelper: false,

			defaultDate: new Date(),
			eventLimit: true,

			events: function(start, end, timezone, callback) {
				/*
				 * We're disabling paging for the moment, as requests do not currently support the "or" operator.
				 * This is required in order to include events that do not start and/or end within the page,
				 * but traverse the page.
				 */
				// if (self.$prototype.$filter && self._isFetchNeeded(self._widget.fullCalendar('getView'))) {
				// 	self._fetchCalendarEvents(self.page.$prototype.$representationUrl, self._widget.fullCalendar('getView'));
				// }
				callback(self._events || []);
			}
		});
		self.calendar = calendar;
	},

	_isFetchNeeded: function(view) {
		var self = this;

		if (self.startDateFetchedEvents && self.endDateFetchedEvents) {
			var range = self._fetchDataRange(view);
			return range.start.isBefore(self.startDateFetchedEvents) || range.end.isAfter(self.endDateFetchedEvents);
		}
		return true;
	},

	_fetchDataRange: function(view) {
		var range = {};

		/*
		 * The month view is a special case - the intervalStart date is not always the first cell in the view.
		 * Additionaly, the intervalEnd is not always the last cell in the view.
		 * We have to show events in the previous and next month cells, so we have to compute the date of the
		 * first cell in month - 1 and the date of the last cell in month + 1
		 */
		if (view.name === 'month') {
			var cellsPerView = view.rowCnt * view.colCnt;

			var firstDateInLastView = view.incrementDate(view.intervalStart, -1);
			range.start = firstDateInLastView.subtract(firstDateInLastView.weekday(), 'days');

			var firstDateInNextView = view.incrementDate(view.intervalStart, 1);
			range.end = firstDateInNextView.add(cellsPerView - firstDateInNextView.weekday() - 1, 'days');
		} else {
			range.start = view.intervalStart;
			range.end = view.intervalEnd;
		}

		return range;
	},

	_fetchCalendarEvents: function(representationUrl, view) {
		var self = this;

		var where = "";

		var filterStartProp = self.$prototype.$filter.start[0];
		var filterEndProp = self.$prototype.$filter.end[0];
		var range = self._fetchDataRange(view);

		function dateFilterRightValue(date) {
			return '@' + date.format('YYYY-MM-DD') + '@';
		}

		/*
		 * TODO -  Deal with events with end dates within the range, but start dates out of the range!
		 */
		if (self.startDateFetchedEvents && self.endDateFetchedEvents) {

			if (range.start.isBefore(self.startDateFetchedEvents)) {
				where = "&where=((" + filterStartProp + " GE " + dateFilterRightValue(range.start) + ") and " +
					"(" +
					filterStartProp +
					" LT " +
					dateFilterRightValue(self.startDateFetchedEvents) +
					"))";

				self.startDateFetchedEvents = range.start;
				self._sendCalendarRequest(representationUrl + where, true);
			}

			if (range.end.isAfter(self.endDateFetchedEvents)) {

				where = "&where=((" + filterStartProp + " GT " + dateFilterRightValue(self.endDateFetchedEvents) + ") and " +
					"(" +
					filterStartProp +
					" LE " +
					dateFilterRightValue(range.end) +
					"))";

				self.endDateFetchedEvents = range.end;
				self._sendCalendarRequest(representationUrl + where, true);
			}

		} else {
			where = "&where=((" + filterStartProp + " GE " + dateFilterRightValue(range.start) + ") and " +
				"(" +
				filterStartProp +
				" LE " +
				dateFilterRightValue(range.end) +
				"))";

			self.startDateFetchedEvents = range.start;
			self.endDateFetchedEvents = range.end;
			self._sendCalendarRequest(representationUrl + where, false);
		}

		/*
		 * We also need to look for long events that start before and end after the fetched range.
		 * These will be regenerated each time we send a request to prevent any potential event duplications.
		 */
		where = "&where=((" + filterStartProp + " LT " + dateFilterRightValue(range.start) + ") and " +
			"(" +
			filterStartProp +
			" GT " +
			dateFilterRightValue(range.end) +
			"))";

		self._sendCalendarRequest(representationUrl + where, true, true);
	},




	_sendCalendarRequest: function(url, append, isOverlapping) {
		var self = this;

		var httpQuery = syra_controller.parseUrl(url);
		httpQuery.sendNewRequest({
			method: "GET",
			onSuccess: function(data, response) {
				if (data.agenda.$events.length > 0) {
					self._setLandingPageCalendarDataBind(self.$prototype.$item.$properties, data, data, null, append, isOverlapping);
					self._widget.planningFullCalendar('refetchEvents');
				}
			},
			onError: function(data, response) {
				console.log("landing page calendar fetch error");
			}
		});
	},

	_addCalendarLegend: function(legendObj) {
		var self = this;

		if (legendObj && document.getElementsByClassName("s-fc-header").length === 0) {
			var keys = Object.keys(legendObj);
			if (keys.length) {
				var legendDiv = document.createElement("div");
				legendDiv.className = "s-fc-header";

				for (var ii = 0, jj = keys.length; ii < jj; ii++) {
					var iconSpan = document.createElement("span");
					var descriptionSpan = document.createElement("span");

					iconSpan.className = "s-fc-header-day-type-" + (ii + 1) + " s-legendwhiteborder";
					descriptionSpan.className = "s-fc-header-day-type";
					descriptionSpan.textContent = legendObj[keys[ii]];

					var legendSpan = document.createElement("span");
					legendSpan.className = "s-fc-legend";
					legendSpan.appendChild(iconSpan);
					legendSpan.appendChild(descriptionSpan);
					legendDiv.appendChild(legendSpan);
					/*					legendDiv.appendChild(iconSpan);
                     legendDiv.appendChild(descriptionSpan);*/
				}
				self.layoutSlot.insertBefore(legendDiv, self._widget[0]);
			}
		}
	},

	_eventPreceedsView: function(event, view) {
		return view.dateToDayOffset(event.start) < 0;
	},

	_eventExceedsView: function(event, view) {
		return view.dateToDayOffset(event.end) >= (view.rowCnt * view.colCnt);
	},

	_addPreviousArrow: function(event, element) {
		var startEvent = event.start ? event.start : event.actualStart;
		var iconDiv = document.createElement("div");
		var arrowTextDiv = document.createElement("div");
		var previousArrowDiv = document.createElement("div");
		var previousArrowText = datetime.parse(startEvent._i, startEvent.f).toString(formatApi.getLocalFormat("application/x-date"));

		arrowTextDiv.textContent = syra_local["plcal_start"] + " " + previousArrowText;
		previousArrowDiv.appendChild(arrowTextDiv);

		iconDiv.className = "fc-tab-icon s-fonticon-btn";
		iconDiv.innerHTML = syra_menus.fontIcons.left_arrow;
		previousArrowDiv.appendChild(iconDiv);

		previousArrowDiv.className = "s-previous-arrow";
		element[0].firstChild.insertBefore(previousArrowDiv, null);
	},

	_addNextArrow: function(event, element) {
		var endEvent = event.end ? event.end : event.actualEnd;
		var iconDiv = document.createElement("div");
		var arrowTextDiv = document.createElement("div");
		var nextArrowDiv = document.createElement("div");
		var nextArrowText = datetime.parse(endEvent._i, endEvent.f).toString(formatApi.getLocalFormat("application/x-date"));

		arrowTextDiv.textContent = syra_local["plcal_end"] + " " + nextArrowText;
		nextArrowDiv.appendChild(arrowTextDiv);

		iconDiv.className = "fc-tab-icon s-fonticon-btn";
		iconDiv.innerHTML = syra_menus.fontIcons.right_arrow;
		nextArrowDiv.appendChild(iconDiv);

		nextArrowDiv.className = "s-next-arrow";
		element[0].appendChild(nextArrowDiv);
	},

	_createPlanningCalendarWidget: function(calendarType) {
		var self = this;

		var calendar = self._widget.planningFullCalendar({
			aspectRatio: aspectRatio,

			header: {
				left: 'prev,next',
				center: 'title',
				right: 'planningYear,planningMonth'
			},

			planningCalendar: true,
			planningSlotsPerCell: self.planningSlotsPerCell,
			planningDayTypes: self.planningDayTypes,
			defaultView: self.defaultView,
			defaultDate: self.calendarYear,

			buttonText: {
				year: syra_local.plcal_year,
				month: syra_local.plcal_month,
				week: syra_local.plcal_week,
				day: syra_local.plcal_day
			},

			monthNames: _months.map(function(i) {
				return date.monthName(i + 1);
			}),
			monthNamesShort: _months.map(function(i) {
				return date.monthName(i + 1, true);
			}),
			dayNames: _days.map(function(i) {
				return date.dayName(i);
			}),
			dayNamesShort: _days.map(function(i) {
				return date.dayName(i, true);
			}),
			firstDay: 1,

			selectable: false,
			selectHelper: false,

			select: function(start, end, allDay) {},
			editable: false,

			events: function(start, end, timezone, callback) {
				var events = self._events;
				callback(events || []);
			},
			viewRender: function(planningView) {
				// set the default view to the new view name in order to maintain the view type when changing between years.
				self.defaultView = planningView.name;
			},
		});
		self.calendar = calendar;
	},

	_events: function() {
		debug && console.log("Events");
	},

	_drawBox: function() {
		var self = this;
		syra_menus.button.hide(this.attachedField.btnRefresh, true);
		var id = "a" + helpers.uuid.generate();
		self._widget = $('<div />').attr('id', "cal_" + id).appendTo(self.layoutSlot);
	},

	_preSetDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		return !(parentDataRecord && parentDataRecord.$isPartialDelta);
	},
	_setLandingPageCalendarDataBind: function($bindings, dataRecordSet, parentDataRecord, metaData, append, isOverlapping) {
		var self = this;

		function getPropertyDescription(descriptionProps) {
			var descriptionKeys = Object.keys(descriptionProps);
			var slot = document.createElement("div");
			slot.className = "s-agenda-description-inner";

			for (var ii = 0, jj = descriptionKeys.length; ii < jj; ii++) {
				var descriptionKey = descriptionKeys[ii];

				var item;
				var hyperlink = descriptionProps[descriptionKey] && $bindings[descriptionKey].$links && $bindings[descriptionKey].$links.$details && $bindings[descriptionKey].$links.$details;
				if (hyperlink) {
					item = syra_menus.button.add({
						parent: self,
						text: descriptionProps[descriptionKey],
						css: "s-agenda-description-item-ref",
						title: hyperlink.$title,
						btnclick: function(event) {
							event.syraRetValue = true;
						}
					}).link;

					syra_url.history.setHref({
						$url: syra_expression.parse(self, hyperlink.$url, descriptionProps),
						domItem: item
					});

					item.target = "blank";
					slot.appendChild(item);
				} else {
					item = document.createElement("div");
					item.className = "s-agenda-description-item";

					var itemField = self.page.loadNewItem(item, {
						$bind: descriptionKey,
						$inplace: true
					}, self);

					slot.appendChild(itemField.domItem);
				}
			}
			self.applyChange(descriptionProps);
			return slot;
		}

		function validColorIndex(index) {
			return (index % 1 === 0) && index > 0 && index < 21;
		}

		if (parentDataRecord && parentDataRecord.agenda) {

			if (append && self._events.length) {
				for (var ii = 0; ii < self._events.length; ii++) {
					var ev = self._events[ii];
					if (ev.isOverlapping) {
						ev.splice(ii, 1);
					}
				}
			}

			var $events = parentDataRecord.agenda.$events;

			$events.forEach(function(event) {
				/*
				 * If we have neither start nor end datetimes, we can't display the event.
				 */
				if (!((event.start.datetime && event.start.datetime.length) || (event.end.datetime && event.end.datetime.length))) {
					return;
				}

				if (event.start.datetime && event.start.datetime.length) {
					/*
					 * Parse to ensure correct format.
					 */
					event.start.datetime = datetime.parse(event.start.datetime).toString();
				}

				if (event.end.datetime && event.end.datetime.length) {
					/*
					 * Parse to ensure correct format.
					 */
					event.end.datetime = datetime.parse(event.end.datetime).toString();
				}

				var fcEvent = {};

				fcEvent.title = event.summary;
				fcEvent.subtitle = event.subtitle;
				fcEvent.description = getPropertyDescription(event.description);
				fcEvent.id = event.id;
				fcEvent.isOverlapping = isOverlapping;

				fcEvent.category = validColorIndex(event.category) ? event.category : 0;
				fcEvent.color = validColorIndex(event.color) ? event.color : 0;

				if (!(event.start.datetime && event.start.datetime.length)) {
					/*
					 * We don't have a start datetime, so make the start datetime the same as the end datetime, then increment the endtime by 1 minute.
					 */
					fcEvent.start = event.end.datetime;
					fcEvent.actualEnd = _moment(fcEvent.start);
					fcEvent.end = datetime.parse(fcEvent.start).addMinutes(30).toString();
				} else
				if (!(event.end.datetime && event.end.datetime.length)) {
					/*
					 * We don't have an end datetime, so make the end datetime 1 minute after the start datetime
					 */
					fcEvent.start = event.start.datetime;
					fcEvent.actualEnd = _moment(fcEvent.start);
					fcEvent.endFormat = "application/x-date";
					fcEvent.end = datetime.parse(fcEvent.start).addMinutes(30).toString();
				} else {

					var startDate = datetime.parse(event.start.datetime);
					var endDate = datetime.parse(event.end.datetime);

					if (startDate > endDate) {
						/*
						 * With some X3 requests, we get the event endtime starting before the starttime!
						 * In this case, make the end date the same as the start date.
						 */
						fcEvent.start = event.start.datetime;
						fcEvent.actualEnd = _moment(fcEvent.start);
						fcEvent.endFormat = "application/x-date";
						fcEvent.end = datetime.parse(fcEvent.start).addMinutes(30).toString();

					} else {

						var startHour = new Date(event.start.datetime).getUTCHours();
						var startMinutes = new Date(event.start.datetime).getMinutes();

						var endHour = new Date(event.end.datetime).getUTCHours();
						var endMinutes = new Date(event.end.datetime).getMinutes();

						if (startHour === 0 && startMinutes === 0 && endHour === 0 && endMinutes === 0) {

							fcEvent.start = event.start.datetime;

							/*
							 * A one-day all-day event from the server is from 00:00 to 00:00 on the SAME day.
							 * So, we need to add 24 hours to the end date that we get from the server.
							 */
							fcEvent.end = datetime.parse(event.end.datetime).addDays(1).toString();
							fcEvent.actualEnd = _moment(fcEvent.end);
							fcEvent.allDay = true;
						} else {
							fcEvent.start = event.start.datetime;
							fcEvent.actualEnd = _moment(event.end.datetime);

							var duration = Math.round(datetime.parse(event.end.datetime).millisDiff(datetime.parse(event.start.datetime)) / 60000);
							if (duration < 30) {
								fcEvent.end = datetime.parse(fcEvent.start).addMinutes(30).toString();
							} else {
								fcEvent.end = event.end.datetime;
							}
						}
					}
				}

				self._events.push(fcEvent);
			});
		}
	},

	_setPlanningCalendarDataBind: function($bindings, dataRecordSet, parentDataRecord, metaData) {
		var self = this;
		self.usingPlanningCalendar = true;

		if (dataRecordSet === 'undefined' || dataRecordSet.length === 0) {
			return;
		};

		self.planningSlotsPerCell = $bindings.SLOT.length;

		var renderedYear = self.calendarYear && self.calendarYear.slice(0, 4);

		if (dataRecordSet) {
			self._events = [];
			dataRecordSet.forEach(function(e) {
				var eventDate = e[$bindings.TECDAT].substring(0, 10);
				var eventType = e[$bindings.TYPDAY];
				var eventSlotData = $bindings.SLOT &&
					$bindings.SLOT.map(function($bind) {
						return e[$bind];
					}) || [];

				eventSlotData.forEach(function(slot, i) {
					self._events.push({
						title: '',
						start: eventDate,
						end: eventDate,
						dayType: eventType,
						slotType: slot,
						slot: i
					});
				});
			});

			self.calendarYear = self._events[5].start;
		}

		self.planningDayTypes = [];
		self.$prototype.$decorator.$events &&
			self.$prototype.$decorator.$events.forEach(function(dayType) {
				self.planningDayTypes.push(syra_expression.render(self, dayType));
			});

		if (self.calendar) {
			if (renderedYear && renderedYear !== self.calendarYear.slice(0, 4)) {
				// We've changed calendar year, so regenerate the entire calendar - not just the events!
				$(self.layoutSlot).find("div[id*=cal]").remove();
				self._drawBox();
			} else {
				self._widget.planningFullCalendar('refetchEvents');
			}
		} else {
			var view = self.$prototype.$decorator.$style;
			self.defaultView = (view == 'year') ? 'planningYear' : 'planningMonth';
		}
		self._createPlanningCalendarWidget();
	},

	_fixDataSet: function() {
		this.ensureDataSet();
		var fixedDataSet = this.dataset;
		if (this.page.externalAdapter.fusionSite) {
			var last = fixedDataSet && fixedDataSet.length > 0 && fixedDataSet[fixedDataSet.length - 1] || {};
			// An improvement can be done be using getDataStoreRecordsNumber() exposed by Convergence window class
			if (sapUtil.isEmptyGridDataRecordEx(this.$prototype.$properties, last)) {
				fixedDataSet = fixedDataSet.slice(0, -1);
			}
		}
		this.dataset = fixedDataSet;
	}
});