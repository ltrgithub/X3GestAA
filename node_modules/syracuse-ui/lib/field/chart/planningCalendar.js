"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Article = require("syracuse-ui/lib/article/article").Article;
var sapUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Fusion;
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var formatApi = require('syracuse-ui/lib/field/formatApi');
var _moment;
var aspectRatio = 2.5;
var _days = [0, 1, 2, 3, 4, 5, 6];
var _months = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
var debug = false;

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== 'undefined' && obj !== null;
}

var _tip;

function _toggleEventTip(calEvent, jsEvent) {
	if (!calEvent) {
		_tip && _tip.popup.close();
		_tip = null;
	} else {
		if (_tip) {
			var target = _tip.target;
			_toggleEventTip();
			if (target == $(jsEvent.target) || target == $(jsEvent.target).parent())
				return;
		}
		_tip = {
			slot: document.createElement("aside")
		};

		if ($.inArray($(jsEvent.target).parent().context.className, ["fc-time", "fc-title"]) == -1)
			_tip.target = $(jsEvent.target);
		else
			_tip.target = $(jsEvent.target).parent();

		_tip.slot.className = "s-agenda-tip";
		var div = document.createElement("header");
		div.className = "s-agenda-tip-title";
		div.textContent = calEvent.title;
		_tip.slot.appendChild(div);

		div = document.createElement("div");
		div.className = "s-agenda-tip-period";

		["start", "end"].forEach(function(key) {
			var dt = calEvent[key === "end" ? "actualEnd" : key];
			var item = document.createElement("div");
			item.className = "s-agenda-tip-period-dt";

			var lb = document.createElement("div");
			lb.className = "s-agenda-tip-period-dt-lb";
			lb.textContent = syra_local["plcal_" + key];
			item.appendChild(lb);

			var val = document.createElement("div");
			val.className = "s-agenda-tip-period-dt-val";

			if (key === "end" && calEvent.endFormat) {
				val.textContent = datetime.parse(dt._i, dt.f).toString(formatApi.getLocalFormat(calEvent.endFormat));
			} else {
				val.textContent = datetime.parse(dt._i, dt.f).toString(formatApi.getLocalFormat("application/x-datetime") + "Z").slice(0, -1);
			}

			item.appendChild(val);
			div.appendChild(item);
		});

		_tip.slot.appendChild(div);

		if (calEvent.description) {
			div = document.createElement("div");
			div.className = "s-agenda-tip-description";
			div.innerHTML = calEvent.description;
			_tip.slot.appendChild(div);
		}

		if (calEvent.summary) {
			div = document.createElement("div");
			div.className = "s-agenda-tip-summary";
			div.textContent = calEvent.summary;
			_tip.slot.appendChild(div);
		}

		_tip.popup = syra_site.dialogManager.openPopup(syra_site, {
			content: {},
			slot: _tip.slot,
			position: {
				my: "left top",
				at: "right top",
				of: $(_tip.target)
			}
		});
	}
}

function PlanningCalendar() {}

exports.PlanningCalendar = helpers.defineClass(PlanningCalendar, Article, {
	loadBox: function(initData) {
		var self = this;
		syra_site.loadStyleSheet("fullcalendar/fullcalendar.css");
		syra_site.loadStyleSheet("fullcalendar/planningfullcalendar.css");
		require.async('syracuse-ui/deps/fullcalendar/planningfullcalendar', function(err, module) {
			require.async('syracuse-ui/deps/fullcalendar/fullcalendar', function(err, module) {
				require.async('syracuse-ui/deps/fullcalendar/moment', function(err, module) {
					_moment = module;
					self.isLoaded = true;
					Article.prototype.loadBox.call(self, initData);
					if (self.isDatabindRequested) {
						var $bind = self.attachedField.$item.$bind;
						var dataset = self.articleParent.dataset;
						self.setDataBind(dataset[$bind], dataset, dataset.$properties && dataset.$properties[$bind], $bind);
						delete self.isDatabindRequested;
					}
					if (self.page && self.page.dialogWrapper) {
						self.page.resizeArticle();
					}
				});
			});
		});
	},
	dispose: function() {
		_toggleEventTip();
		Article.prototype.dispose.call(this);
	},
	resizeChart: function() {
		var self = this;
		self.displayed = true;
		if (self.calendar) {
			self.resizeTimer && clearTimeout(self.resizeTimer);
			self.resizeTimer = setTimeout(function() {
				if (self.calendar) {
					if (self.layoutSlot.clientWidth) {
						// width minus 1 because of scrollbar issue on firefox
						var calWidth = self.calendar.size.width;
						self._resize(Math.max(calWidth ? calWidth : 0, self.layoutSlot.clientWidth) - 1);
					}
				}
			}, 200);
		}
	},
	drawBox: function() {
		this.page.defaultItemsPerPage = 500;
		var proto = this.$prototype;
		proto.$properties = proto.$item && proto.$item.$properties;
		this._drawBox && this._drawBox();
		this.page.vignetteField && this.page.vignetteField.showButton("design", this.page.isDesignModeEnabled = false);
	},
	setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		var self = this;
		if (self.isLoaded) {
			if (self._preSetDataBind && !self._preSetDataBind(dataRecordSet, parentDataRecord, metaData)) {
				return;
			}
			if ((self.$item.$category && self.$item.$category == "tabularChart") || (self.$prototype.$type == "application/x-array")) {
				self._fixDataSet();
				dataRecordSet = self.dataset;
			}
			var $bindings = self.$prototype.$decorator.$bindings;
			if ($bindings) {
				self._setPlanningCalendarDataBind($bindings, dataRecordSet, parentDataRecord, metaData);
			} else {
				self._setLandingPageCalendarDataBind(self.$prototype.$item.$properties, dataRecordSet, parentDataRecord, metaData);
				// var list = self.attachedField;
				// if (list.pagging) {
				// 	list.pagging.draw();
				// 	list.pagging.pagerTop && list.pagging._showPager(list.pagging.pagerTop, true);
				// }
			}
		} else {
			self.isDatabindRequested = true;
		}
	},
	_resize: function(width) {
		if (this._widget) {

			this._widget.attr('style', 'width: ' + width + 'px; margin: 0 auto;');

			if (this.calendar) {
				if (self.usingPlanningCalendar) {
					this._widget.planningFullCalendar('option', 'aspectRatio', aspectRatio);
				} else {
					this._widget.fullCalendar('option', 'aspectRatio', aspectRatio);
					$('.fc-more').each(function(index, elem) {
						elem.text = elem.text.slice(1);
					});
				}
			}
		}
	},

	_createLandingPageCalendarWidget: function(calendarType) {
		var self = this;
		var calendar = self._widget.fullCalendar({
			lang: formatApi.getLocale().currentLangCode,
			aspectRatio: aspectRatio,
			defaultView: self.attachedField.$item.$calendarView,
			header: {
				left: 'prev,next today',
				center: 'title',
				right: 'month,agendaWeek,basicWeek,agendaDay,basicDay'
			},

			monthNames: _months.map(function(i) {
				return date.monthName(i + 1);
			}),
			monthNamesShort: _months.map(function(i) {
				return date.monthName(i + 1, true);
			}),
			dayNames: _days.map(function(i) {
				return date.dayName(i);
			}),
			dayNamesShort: _days.map(function(i) {
				return date.dayName(i, true);
			}),
			allDayHtml: syra_local.plcal_allday,

			eventLimitText: syra_local.plcal_more,

			firstDay: 1,
			axisFormat: 'H(:mm)',
			timeFormat: 'H:mm',

			//timezone: 'local',
			slotEventOverlap: false,

			buttonText: {
				month: syra_local.plcal_month,
				week: syra_local.plcal_week,
				day: syra_local.plcal_day,
				today: syra_local.plcal_today
			},

			eventClick: function(calEvent, jsEvent, view) {
				_toggleEventTip(calEvent, jsEvent);
				return false;
			},

			eventAfterAllRender: function() {
				$('.fc-more').each(function(index, elem) {
					elem.text = elem.text.slice(1);
				});
			},

			viewRender: function() {
				if (self.calendar) {
					var selected = self.calendar.fullCalendar("getView").name;
					self.attachedField.$userPreferences = self.attachedField.$userPreferences || {};
					self.attachedField.$userPreferences.$calendarView = self.attachedField.$item.$calendarView = selected;
					self.attachedField.saveListDesign(false, self.attachedField.$userPreferences);
				}
				var $$right = $('.fc-right');
				$('.fc-button.fc-agendaWeek-button.fc-state-default', $$right).text(syra_local.plcal_week);
				$('.fc-button.fc-agendaWeek-button.fc-state-default', $$right).prepend('<span class="fc-tab-icon s-fonticon-btn">' + syra_menus.fontIcons.time + '</span>');

				$('.fc-button.fc-agendaDay-button.fc-state-default', $$right).text(syra_local.plcal_day);
				$('.fc-button.fc-agendaDay-button.fc-state-default', $$right).prepend('<span class="fc-tab-icon s-fonticon-btn">' + syra_menus.fontIcons.time + '</span>');

				$$right.find('.fc-month-button').addClass('s-button-right');
				$$right.find('.fc-basicWeek-button').addClass('s-button-right');
			},

			selectable: true,
			selectHelper: false,

			defaultDate: new Date(),
			eventLimit: true,

			events: function(start, end, timezone, callback) {
				callback(self._events || []);
			}
		});
		self.calendar = calendar;
	},

	_createPlanningCalendarWidget: function(calendarType) {
		var self = this;

		var calendar = self._widget.planningFullCalendar({
			aspectRatio: aspectRatio,

			header: {
				left: 'prev,next',
				center: 'title',
				right: 'planningYear,planningMonth'
			},

			planningCalendar: true,
			planningSlotsPerCell: self.planningSlotsPerCell,
			planningDayTypes: self.planningDayTypes,
			defaultView: self.defaultView,
			defaultDate: self.calendarYear,

			buttonText: {
				year: syra_local.plcal_year,
				month: syra_local.plcal_month,
				week: syra_local.plcal_week,
				day: syra_local.plcal_day
			},

			monthNames: _months.map(function(i) {
				return date.monthName(i + 1);
			}),
			monthNamesShort: _months.map(function(i) {
				return date.monthName(i + 1, true);
			}),
			dayNames: _days.map(function(i) {
				return date.dayName(i);
			}),
			dayNamesShort: _days.map(function(i) {
				return date.dayName(i, true);
			}),
			firstDay: 1,

			selectable: false,
			selectHelper: false,

			select: function(start, end, allDay) {},
			editable: false,

			events: function(start, end, timezone, callback) {
				var events = self._events;
				callback(events || []);
			},
			viewRender: function(planningView) {
				// set the default view to the new view name in order to maintain the view type when changing between years.
				self.defaultView = planningView.name;
			}
		});
		self.calendar = calendar;
	},

	_events: function() {
		debug && console.log("Events");
	},

	_drawBox: function() {
		var self = this;
		var id = "a" + helpers.uuid.generate();
		self._widget = $('<div />').attr('id', "cal_" + id).appendTo(self.layoutSlot);
	},

	_preSetDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		return !(parentDataRecord && parentDataRecord.$isPartialDelta);
	},


	_setLandingPageCalendarDataBind: function($bindings, dataRecordSet, parentDataRecord, metaData) {
		var self = this;
		if (parentDataRecord && parentDataRecord.agenda) {
			self._events = [];
			var $events = parentDataRecord.agenda.$events;

			$events.forEach(function(event) {

				/*
				 * If we have neither start nor end datetimes, we can't display the event.
				 */
				if (!((event.start.datetime && event.start.datetime.length) || (event.end.datetime && event.end.datetime.length))) {
					return;
				}

				if (event.start.datetime && event.start.datetime.length) {
					/*
					 * Parse to ensure correct format.
					 */
					event.start.datetime = datetime.parse(event.start.datetime).toString();
				}

				if (event.end.datetime && event.end.datetime.length) {
					/*
					 * Parse to ensure correct format.
					 */
					event.end.datetime = datetime.parse(event.end.datetime).toString();
				}

				var fcEvent = {};

				fcEvent.title = event.summary;
				fcEvent.description = event.description;
				fcEvent.id = event.id;

				if (!(event.start.datetime && event.start.datetime.length)) {
					/*
					 * We don't have a start datetime, so make the start datetime the same as the end datetime, then increment the endtime by 1 minute.
					 */
					fcEvent.start = event.end.datetime;
					fcEvent.actualEnd = _moment(fcEvent.start);
					fcEvent.end = datetime.parse(fcEvent.start).addMinutes(30).toString();
				} else
				if (!(event.end.datetime && event.end.datetime.length)) {
					/*
					 * We don't have an end datetime, so make the end datetime 1 minute after the start datetime
					 */
					fcEvent.start = event.start.datetime;
					fcEvent.actualEnd = _moment(fcEvent.start);
					fcEvent.endFormat = "application/x-date";
					fcEvent.end = datetime.parse(fcEvent.start).addMinutes(30).toString();
				} else {

					var startDate = datetime.parse(event.start.datetime);
					var endDate = datetime.parse(event.end.datetime);

					if (startDate > endDate) {
						/*
						 * With some X3 requests, we get the event endtime starting before the starttime!
						 * In this case, make the end date the same as the start date.
						 */
						fcEvent.start = event.start.datetime;
						fcEvent.actualEnd = _moment(fcEvent.start);
						fcEvent.endFormat = "application/x-date";
						fcEvent.end = datetime.parse(fcEvent.start).addMinutes(30).toString();

					} else {

						var startHour = new Date(event.start.datetime).getUTCHours();
						var startMinutes = new Date(event.start.datetime).getMinutes();

						var endHour = new Date(event.end.datetime).getUTCHours();
						var endMinutes = new Date(event.end.datetime).getMinutes();

						if (startHour === 0 && startMinutes === 0 && endHour === 0 && endMinutes === 0) {

							fcEvent.start = event.start.datetime;

							/*
							 * A one-day all-day event from the server is from 00:00 to 00:00 on the SAME day.
							 * So, we need to add 24 hours to the end date that we get from the server.
							 */
							fcEvent.end = datetime.parse(event.end.datetime).addDays(1).toString();
							fcEvent.actualEnd = _moment(fcEvent.end);
							fcEvent.allDay = true;
						} else {
							fcEvent.start = event.start.datetime;
							fcEvent.actualEnd = _moment(event.end.datetime);

							var duration = Math.round(datetime.parse(event.end.datetime).millisDiff(datetime.parse(event.start.datetime)) / 60000);
							if (duration < 30) {
								fcEvent.end = datetime.parse(fcEvent.start).addMinutes(30).toString();
							} else {
								fcEvent.end = event.end.datetime;
							}
						}
					}
				}

				self._events.push(fcEvent);
			});

			self._createLandingPageCalendarWidget();
		}
	},

	_setPlanningCalendarDataBind: function($bindings, dataRecordSet, parentDataRecord, metaData) {
		var self = this;
		self.usingPlanningCalendar = true;

		if (dataRecordSet === 'undefined' || dataRecordSet.length === 0) {
			return;
		};

		self.planningSlotsPerCell = $bindings.SLOT.length;

		var renderedYear = self.calendarYear && self.calendarYear.slice(0, 4);

		if (dataRecordSet) {
			self._events = [];
			dataRecordSet.forEach(function(e) {
				var eventDate = e[$bindings.TECDAT].substring(0, 10);
				var eventType = e[$bindings.TYPDAY];
				var eventSlotData = $bindings.SLOT &&
					$bindings.SLOT.map(function($bind) {
						return e[$bind];
					}) || [];

				eventSlotData.forEach(function(slot, i) {
					self._events.push({
						title: '',
						start: eventDate,
						end: eventDate,
						dayType: eventType,
						slotType: slot,
						slot: i
					});
				});
			});

			self.calendarYear = self._events[5].start;
		}

		self.planningDayTypes = [];
		self.$prototype.$decorator.$events &&
			self.$prototype.$decorator.$events.forEach(function(dayType) {
				self.planningDayTypes.push(syra_site.expressionMaker.render(self, dayType));
			});

		if (self.calendar) {
			if (renderedYear && renderedYear !== self.calendarYear.slice(0, 4)) {
				// We've changed calendar year, so regenerate the entire calendar - not just the events!
				$(self.layoutSlot).find("div[id*=cal]").remove();
				self._drawBox();
			} else {
				self._widget.planningFullCalendar('refetchEvents');
			}
		} else {
			var view = self.$prototype.$decorator.$style;
			self.defaultView = (view == 'year') ? 'planningYear' : 'planningMonth';
		}
		self._createPlanningCalendarWidget();
	},

	_fixDataSet: function() {
		this.ensureDataSet();
		var fixedDataSet = this.dataset;
		if (this.page.externalAdapter.fusionSite) {
			var last = fixedDataSet && fixedDataSet.length > 0 && fixedDataSet[fixedDataSet.length - 1] || {};
			// An improvement can be done be using getDataStoreRecordsNumber() exposed by Convergence window class
			if (sapUtil.isEmptyGridDataRecordEx(this.$prototype.$properties, last)) {
				fixedDataSet = fixedDataSet.slice(0, -1);
			}
		}
		this.dataset = fixedDataSet;
	}
});