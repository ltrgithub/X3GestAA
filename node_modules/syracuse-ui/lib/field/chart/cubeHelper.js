"use strict";
var helpers = require('syracuse-core').helpers;
var forEachKey = helpers.object.forEachKey;

var _formatApi = require('syracuse-ui/lib/field/formatApi');

function _merge() {
	var args = arguments;
	return $.extend(true, null, args[0], args[1], args[2], args[3]);
};

exports.initializeMeta = function(self, styleMap) {
	var proto = self.$prototype,
		cube = proto.$cube = proto.$cube || {},
		items = proto.$item.$properties;

	self._meta = {
		xAxis: [{}],
		yAxis: [{}],
		series: {},
		displaysOneMeasure: cube.$displaysOneMeasure,
		hasMeasureSelector: cube.$hasMeasureSelector,
		hasStyleSelector: cube.$hasStyleSelector,
		defaultStyle: styleMap[cube.$style] || cube.$style || styleMap.$default,
		drill: {
			minLevel: 1,
			maxLevel: 0,
			currLevel: 1,
			currAxisHier: 0,
			levelsProperties: [],
			members: [],
			stack: [{
				$axes: proto.$axes,
				$item: proto.$item,
				$slicer: proto.$slicer
			}]
			/*              code: proto.$codeStat || "UNKNOWN",
                axis0FieldCode: self._meta.xAxis[0].code || ""*/
		}
	};

	if (!proto.$axes) return false;

	// Get measures definition. If measures are not defined in the second axis members (Cf. specs),
	// we used all the measures defined in the cube
	var measures = cube.$measures;
	if (measures) {
		var restraintMeasures = measures;
		if (proto.$axes.length > 1 && proto.$axes[1].$members && proto.$axes[1].$members[0][0].length > 0) {
			restraintMeasures = {};
			forEachKey(proto.$axes[1].$members[0][0], function(key) {
				restraintMeasures[key] = measures[key];
			});
		}
		forEachKey(restraintMeasures, function(key, m) {
			// Because duplicate properties is possible for cube definition... we keep the last defined
			var code = (m.$property || key);
			var measure = _merge(items[code], m);
			measure.formatApi = _formatApi.getApi(measure.$type);
			measure.numFormatObj = _formatApi.getLocale().getNumberFormatObj(measure.$type);
			measure.localeFormat = measure.$format || measure.numFormatObj.numFormat;

			self._meta.series[code] = {
				options: {
					id: '#s-' + code,
					name: measure.$title || '???',
					stack: measure.$isStacked,
					type: measure.$style && (styleMap[measure.$style] || measure.$style),
					visible: !! (!self._meta.displaysOneMeasure || measure.$isDefault)
				},
				measure: measure
			};
		});
	}

	_processAxes(self, proto);

	return true;
};

function _processAxes(self, proto) {
	var cube = proto.$cube;

	// TODO: review this
	// Get axis analysis
	var mainHLevelsTab = null;
	_.each(proto.$axes[0].$hierarchies, function(hierarchy, idx) {
		if (!mainHLevelsTab && hierarchy.length > 1 && hierarchy[1] == 1) {
			mainHLevelsTab = cube.$hierarchies[hierarchy[0]].$properties;
			if (mainHLevelsTab) {
				self._meta.xAxis[0].code = mainHLevelsTab[hierarchy.length > 2 ? hierarchy[2] : 0];
				self._meta.drill.currAxisHier = idx;
			}
		}
	});
	if (!mainHLevelsTab && proto.$axes[0].$hierarchies[0].length > 0) {
		mainHLevelsTab = cube.$hierarchies[proto.$axes[0].$hierarchies[0][0]].$properties;
		if (mainHLevelsTab && mainHLevelsTab.length > 0) self._meta.xAxis[0].code = mainHLevelsTab[0];
	}
};

exports.getMeasureLabel = function(measure, code, items) {
	var label = measure.$title;
	if (label) return label;
	var item = items[code];
	if (!item) return null;
	switch (item.$type) {
		case "application/x-string":
			label = measure[code];
			break;
		case "application/x-choice":
			item.$value.$enum.some(function(element, i, array) {
				if (element.$value === measure[code]) {
					label = element.$title;
					return true;
				}
				return false;
			});
			label = measure[code];
			break;
	}
	return label;
};

exports.isValid = function(cube, proto) {
	return !!(cube && cube.$hierarchies && proto.$axes && proto.$axes.length > 0 && //
		proto.$axes[0].$hierarchies && proto.$axes[0].$hierarchies.length > 0);
};