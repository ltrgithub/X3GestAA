"use strict";
var _helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
var _colors = ["#024731", "#69923a", "#a8b400", "#3a3565", "#652d86", "#c1afe5"];
var width = 500,
	height = 400;

function NodeChart() {}

exports.nodeChart = _helpers.defineClass(NodeChart, Field, {
	renderLegend: function() {
		var self = this;
		var member = {
			height: 12,
			width: 80,
			margin: 5
		};
		var cols = 4,
			margin = 10;
		var $nodeCategories = self.$field.$nodeCategories || [];
		var rowCount = Math.ceil(($nodeCategories).length / cols);
		var left = Math.round((self.forceWidth - 2 * margin - (cols * (member.width + member.margin))) / 2);
		var top = self.forceHeight - (rowCount * member.height + 2 * member.margin + 2 * margin);
		var itemX = member.margin,
			itemY = member.margin;
		var crtRow = 0,
			crtCol = 0;
		// container should be an SVG
		self.categories = {};
		var i = 0;
		var svgLegend = self.$$svg.append("svg:g").attr("class", "d3-graph-svg-legend-container").attr("transform", "translate(" + left + "," + top + ")");
		$nodeCategories.forEach(function($categ) {
			var $selected = self.selectedCategories[$categ.$title];
			if ($selected === undefined) {
				$selected = self.selectedCategories[$categ.$title] = $categ.$selected;
			}
			var category = self.categories[$categ.$title] = {
				item: svgLegend.append("svg:rect").attr("class", "d3-graph-svg-legend-check").attr("category", $categ.$title).attr("x", itemX).attr("y", itemY).attr("width", member.height).attr("height", member.height).attr("rx", 2).attr("ry", 2)
			};
			category.item.style("fill", function(d) {
				return _colors[i++];
			});
			var textId = "a" + _helpers.uuid.generate();
			category.item.attr("text-node-id", textId);
			category.text = svgLegend.append("svg:text").attr("id", textId).attr("category", $categ.$title).attr("class", "d3-graph-legend-nodetext").attr("x", itemX + member.margin * 2 + member.height).attr("y", itemY + member.height - 3).text($categ.$title);
			!$selected && category.text.attr("class", "d3-graph-legend-nodetext-unselected");
			category.text.on("click", function(d) {
				var name = this.attributes["category"].nodeValue;
				self.selectedCategories[name] = !self.selectedCategories[name];
				svgLegend.select("#" + this.id).classed("d3-graph-legend-nodetext-unselected", !self.selectedCategories[name]);
				self._updateGraph();
			});
			category.item.on("click", function(d) {
				var name = this.attributes["category"].nodeValue;
				self.selectedCategories[name] = !self.selectedCategories[name];
				svgLegend.select("#" + this.attributes["text-node-id"].nodeValue).classed("d3-graph-legend-nodetext-unselected", !self.selectedCategories[name]);
				self._updateGraph();
			});
			if (crtCol++ == cols - 1) {
				crtCol = 0;
				crtRow++;
			}
			itemX = crtCol * (member.width + member.margin) + member.margin;
			itemY = crtRow * (member.height + member.margin) + member.margin;
		});
	},
	_updateGraph: function() {
		var self = this;
		self.nodeElements && self.nodeElements.on("click", null);
		self.$$svg.selectAll("g.d3-graph-node").remove();
		self.$$svg.selectAll("line.d3-graph-link").remove();
		var nodes = (self.$data.$nodes || []).map(function(node, i) {
			var proto = self.$field.$nodeCategories[node.$category];
			return (self.selectedCategories[proto.$title]) ? {
				value: syra_expression.parse(self.articleParent, proto.$prototype.$properties.$value, node),
				title: proto.$title,
				$field: proto,
				$item: node,
			} : null;
		});
		self.$links = (self.$data.$links || []).filter(function(link) {
			return (nodes[link.$source] && nodes[link.$target]);
		}).map(function(link) {
			return {
				source: nodes[link.$source],
				target: nodes[link.$target],
				$field: self.$field.$linkCategories[link.$category]
			};
		});
		self.$nodes = nodes.filter(function(node) {
			return node != null;
		});

		self.$force.nodes(self.$nodes).links(self.$links).start();
		var link = self.$$svg.selectAll("line.d3-graph-link").data(self.$links);
		// select missing links, create lines
		self.linkElements = link.enter().insert("svg:line", ".node").attr("class", "d3-graph-link").attr("x1", function(d) {
			return d.source.x;
		}).attr("y1", function(d) {
			return d.source.y;
		}).attr("x2", function(d) {
			return d.target.x;
		}).attr("y2", function(d) {
			return d.target.y;
		});

		// nodes
		// make nodes as groups to allow text elements grouped with circles
		var node = self.$$svg.selectAll("g.d3-graph-node").data(self.$nodes);
		// create nodes
		self.nodeElements = node.enter().append("svg:g").attr("class", "d3-graph-node").call(self.$force.drag);
		// add circle element
		self.nodeElements.append("circle").attr("class", "d3-graph-node").attr("r", function(d) {
			return (d.$item.$category == 0) ? 20 : 10;
		}).style("fill", function(d) {
			return _colors[d.$item.$category];
		}).on("click", function(d) {
			var $links = d.$field.$prototype && d.$field.$prototype.$links;
			var $link = $links && $links.$default;
			if ($link) {
				$link = _helpers.object.clone($link);
				$link.$url = syra_expression.parse(self.articleParent, $link.$url, d.$item);
				syra_controller.executeMenu($link, self.articleParent);
			}
		}).on('mouseover', function(d) { //Show the tooltip
			var parentDom = self.domItem.getBoundingClientRect();

			if (self.graphTip.data == d || this.style.opacity == "0") {
				return;
			}
			//Store which data element we are displaying data for
			self.graphTip.data = d;

			//Clear the contents of the tooltip
			var graphTip = $(".d3-graph-tip")["0"];
			syra_dom.empty(graphTip);

			//Add the task details to the tool tip
			self._d3.select(".d3-graph-tip").append("div").attr("class", "d3-graph-tiptext").text(d.title + ": " + d.value);
			//Position and show the tooltip			
			self._d3.select(".d3-graph-tip")
				.style("left", (self._d3.event.pageX - parentDom.left) + "px")
				.style("top", (self._d3.event.pageY - parentDom.top - 50) + "px")
				.classed("hidden", false);

		}).on('mouseout', function() { //Hide the tooltip
			self.graphTip.data = null;
			self._d3.select(".d3-graph-tip")
				.classed("hidden", true);
		});
		self.nodeElements.append("title").text(function(d) {
			return d.title + ": " + d.value;
		});

		// self.textElements = self.nodeElements.append("svg:text").attr("class", "d3-graph-nodetext").attr("dx", 12).attr("dy", ".35em").text(function(d) {
		// 	return d.value;
		// });
	},
	setDataValue: function(value) {
		this.currentValue = value;
		var self = this,
			fetch;
		if (value && typeof(value) === 'object') {
			if (!self.$lazyUrl) {
				self.$lazyUrl = self.$field.$url;
				fetch = !! self.$lazyUrl;
			}
			if (value && value.$url) {
				self.$lazyUrl = value.$url;
				fetch = true;
			}
			if (fetch) {
				self.$lazyUrl = syra_expression.parse(self.articleParent, self.$lazyUrl);
				self.page.fetch({
					$location: {
						$url: self.$lazyUrl
					}
				}, function(data, response) {
					self.$data = data;
					self.render();
				});
			} else {
				if (value.$nodes || value.$links) {
					self.$data = value;
					self.render();
				}
			}
		}
	},
	loadBox: function() {
		var self = this;
		syra_site.loadStyleSheet("d3.css");
		require.async('syracuse-ui/deps/d3/index', function(err, module) {
			self._d3 = module;
			self.selectedCategories = {};
			self.$item.$isAutoSize = true;
			self.$item.$isTopLabelAlignment = true;
			self.width = self.$item.$width || width;
			self.height = self.$item.$height || height;
			Field.prototype.loadBox.call(self);
			if (self.page && self.page.dialogWrapper) {
				self.page.resizeArticle();
			}
		});
	},
	resizeArticle: function() {
		this._d3 && this.render();
	},
	render: function() {
		var self = this;
		if (self.$data) {
			if (self.$data.$properties) {
				syra_delta.applyObjectDelta(self.page, self.$field, self.$data.$properties);
			}
			syra_dom.empty(self._dataValue);
			self._dataValue.className = "d3-graph-field";
			self.$$svg = self._d3.select(syra_dom.addDiv("d3-graph-svg-wrap", self._dataValue)).append("svg");
			var svgDom = self.$$svg.node();

			var rect = this._dataValue.getBoundingClientRect();
			self.forceWidth = Math.round(rect.width);
			self.forceHeight = Math.round(self.forceWidth * 0.8);
			if (self.page.scrollview) {
				var maxHeight = self.page.scrollview.getBoundingClientRect().height;
				if (self.page.header) {
					maxHeight -= self.page.header.getBoundingClientRect().height;
				}
				self.forceHeight = Math.round(Math.min(self.forceHeight, maxHeight * 0.9));

			}
			svgDom.setAttribute("width", self.forceWidth);
			svgDom.setAttribute("height", self.forceHeight);
			self.forceWidth = 500;
			self.forceHeight = 400;
			svgDom.setAttribute("viewBox", "0 0 " + self.forceWidth + " " + self.forceHeight);
			svgDom.setAttribute("perserveAspectRatio", "xMinYMin");


			self.renderLegend();
			self.$nodes = [];
			self.$links = [];
			self.$force = self._d3.layout.force() //
			.linkStrength(2) //
			.gravity(0.4) //
			.friction(0.8) //
			.charge(-500) //
			.linkDistance(self.forceHeight / 4) //
			//.linkDistance(self.forceHeight / 3) //
			//.linkDistance([250])
			//.charge([-1500])
			//.gravity(0.3)

			.size([self.forceWidth, self.forceHeight]) //
			.nodes(self.$nodes) //
			.links(self.$links);

			//Define the toolTip slot
			self.graphTip = {
				slot: null,
				data: null
			};
			self.graphTip.slot = syra_dom.addDiv("d3-graph-tip hidden", self.domItem);

			self._updateGraph();

			self.$force.on("tick", function() {
				self.linkElements &&
					self.linkElements.attr("x1", function(d) {
						return d.source.x;
					}).attr("y1", function(d) {
						return d.source.y;
					}).attr("x2", function(d) {
						return d.target.x;
					}).attr("y2", function(d) {
						return d.target.y;
					});
				self.nodeElements &&
					self.nodeElements.attr("cx", function(d) {
						return d.x;
					}).attr("cy", function(d) {
						return d.y;
					});
				self.nodeElements &&
					self.nodeElements.attr("transform", function(d) {
						return "translate(" + d.x + "," + d.y + ")";
					});
				self.textElements &&
					self.textElements.attr("dx", function(d) {
						var dx = d.$item.$category == 0 ? 30 : 15;
						return (d.x >= self.forceWidth / 2) ? dx : -((d.value.length * 6) + dx);
					});
			});


		}
	},
	dispose: function() {
		if (this.$force) {
			this.$force.stop();
			this.$force.on("tick", null);
		}
		if (this.categories) {
			var ids = Object.keys(this.categories);
			for (var ii = 0, jj = ids.length; ii < jj; ii++) {
				var cat = this.categories[ids[ii]];
				cat.item && cat.item.on("click", null);
				cat.text && cat.text.on("click", null);
			}
		}
		this.nodeElements && this.nodeElements.on("click", null);
		Field.prototype.dispose.call(this);
	}
});