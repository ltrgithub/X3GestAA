"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;

function _addLegend() {
	return {
		_align: "bottom",
		_cols: 4,
		_memberWidth: 80,
		_margin: 10,
		_memberMargin: 5,
		_memberHeight: 12,
		left: 0,
		top: 0,
		align: function(type) {
			this._align = type;
			return this;
		},
		cols: function(nbCols) {
			this._cols = nbCols;
			return this;
		},
		memberWidth: function(w) {
			this._memberWidth = w;
			return this;
		},
		memberMargin: function(m) {
			this._memberMargin = m;
			return this;
		},
		memberHeight: function(h) {
			this._memberHeight = h;
			return this;
		},
		margin: function(m) {
			this._margin = m;
			return this;
		},
		colors: function(clr) {
			this._colors = clr;
			return this;
		},
		items: function(it) {
			this._items = it;
			return this;
		},
		render: function(container, selectedMap, onLegendClick) {
			var legend = this;
			var containerW = +container.attr("width");
			var containerH = +container.attr("height");
			var legendRowCount = Math.ceil((this._items || []).length / this._cols);
			this.left = Math.round((containerW - 2 * this._margin - (this._cols * (this._memberWidth + this._memberMargin))) / 2);
			this.top = containerH - (legendRowCount * this._memberHeight + 2 * this._memberMargin + 2 * this._margin);
			var itemX = this._memberMargin,
				itemY = this._memberMargin;
			var crtRow = 0,
				crtCol = 0;
			// container should be an SVG
			var svgLegend = container.append("svg:g").attr("class", "d3-graph-svg-legend-container").attr("transform", "translate(" + this.left + "," + this.top + ")");
			var i = 0;
			(this._items || []).forEach(function(categ) {
				selectedMap[categ.$title] = categ.$selected;
				// add member
				var item = svgLegend.append("svg:rect").attr("class", "d3-graph-svg-legend-check").attr("category", categ.$title).attr("x", itemX).attr("y", itemY).attr("width", legend._memberHeight).attr("height", legend._memberHeight).attr("rx", 2).attr("ry", 2);
				item.style("fill", function(d) {
					return legend._colors[i++];
				});
				var textId = "a" + helpers.uuid.generate();
				item.attr("text-node-id", textId);
				var text = svgLegend.append("svg:text").attr("id", textId).attr("category", categ.$title).attr("class", "d3-graph-legend-nodetext").attr("x", itemX + legend._memberMargin * 2 + legend._memberHeight).attr("y", itemY + legend._memberHeight - 3).text(categ.$title);
				if (!categ.$selected)
					text.attr("class", "d3-graph-legend-nodetext-unselected");
				text.on("click", function(d) {
					var categName = this.attributes["category"].nodeValue;
					selectedMap[categName] = !selectedMap[categName];
					svgLegend.select("#" + this.id).classed("d3-graph-legend-nodetext-unselected", !selectedMap[categName]);
					if (onLegendClick && (typeof onLegendClick === "function"))
						onLegendClick(categName, selectedMap[categName]);
				});
				item.on("click", function(d) {
					var categName = this.attributes["category"].nodeValue;
					selectedMap[categName] = !selectedMap[categName];
					svgLegend.select("#" + this.attributes["text-node-id"].nodeValue).classed("d3-graph-legend-nodetext-unselected", !selectedMap[categName]);
					if (onLegendClick && (typeof onLegendClick === "function"))
						onLegendClick(categName, selectedMap[categName]);
				});
				if (crtCol++ == legend._cols - 1) {
					crtCol = 0;
					crtRow++;
				}
				itemX = crtCol * (legend._memberWidth + legend._memberMargin) + legend._memberMargin;
				itemY = crtRow * (legend._memberHeight + legend._memberMargin) + legend._memberMargin;
			});
		}
	};
}

var width = 500,
	height = 400;
var forceWidth = width,
	forceHeight = height - 100,
	forceMargin = 0;
var legendMemberHeight = 12,
	legendMemberMargin = 5,
	legendWidth = 80,
	legendMargin = 10;
var legendCols = 4;
var color = ["#024731", "#69923a", "#a8b400", "#3a3565", "#652d86", "#c1afe5"];
var nodeElements, linkElements, textElements;

function _makeData(field) {
	// create D3 node/links structures
	// clone $nodes as it will be modified
	var nodes = (field.$data.$nodes || []).map(function(node, i) {
		var proto = field.$field.$nodeCategories[node.$category];
		var value = syra_site.expressionMaker.parse(field.articleParent, proto.$prototype.$properties.$value, node);
		var title = proto.$title;
		//
		return (field.$categories[proto.$title]) ? {
			value: value,
			title: title,
			$field: proto,
			$item: node,
		} : null;
	});
	// clone links
	field.$links = (field.$data.$links || []).filter(function(link) {
		// filter selected nodes
		return (nodes[link.$source] && nodes[link.$target]);
	}).map(function(link) {
		return {
			source: nodes[link.$source],
			target: nodes[link.$target],
			$field: field.$field.$linkCategories[link.$category]
		};
	});
	//
	// filter null records
	field.$nodes = nodes.filter(function(node) {
		return node != null;
	});
}

function _updateGraph(field) {
	var self = field;
	var svg = self.$$svg;
	// cleanup
	svg.selectAll("g.d3-graph-node").remove();
	svg.selectAll("line.d3-graph-link").remove();
	//
	_makeData(field);
	//
	var force = field.$force;
	force.nodes(field.$nodes).links(field.$links).start();
	// links
	// update links data
	var link = svg.selectAll("line.d3-graph-link").data(field.$links);
	// select missing links, create lines
	linkElements = link.enter().insert("svg:line", ".node").attr("class", "d3-graph-link").attr("x1", function(d) {
		return d.source.x;
	}).attr("y1", function(d) {
		return d.source.y;
	}).attr("x2", function(d) {
		return d.target.x;
	}).attr("y2", function(d) {
		return d.target.y;
	});

	// nodes
	// make nodes as groups to allow text elements grouped with circles
	var node = svg.selectAll("g.d3-graph-node").data(field.$nodes);
	// create nodes
	var newNodes = nodeElements = node.enter().append("svg:g").attr("class", "d3-graph-node").call(force.drag);
	// add circle element
	newNodes.append("circle").attr("class", "d3-graph-node").attr("r", function(d) {
		return (d.$item.$category == 0) ? 20 : 10;
	}).style("fill", function(d) {
		return color[d.$item.$category];
	}).on("click", function(d) {
		d.$field.$prototype && d.$field.$prototype.$links && d.$field.$prototype.$links.$default && syra_controller.openPage(field.articleParent, d.$field.$prototype.$links.$default, d.$item);
	});
	//    .on("mouseenter", function(d){})
	//    .on("mouseleave", function(d){})

	newNodes.append("title").text(function(d) {
		return d.title + ": " + d.value;
	});

	textElements = nodeElements.append("svg:text").attr("class", "d3-graph-nodetext").attr("dx", 12).attr("dy", ".35em").text(function(d) {
		return d.value;
	});
}

function NodeChart() {}

exports.nodeChart = helpers.defineClass(NodeChart, Field, {
	setDataValue: function(value) {
		this.currentValue = value;
		var self = this;
		if (value && value.$url) {
			self.page.fetch({
				$location: {
					$url: syra_site.expressionMaker.parse(self.articleParent, value.$url)
				}
			}, function(data, response) {
				self.$data = data;
				_updateGraph(self);
			});
		}
	},
	loadBox: function() {
		var self = this;
		syra_site.loadStyleSheet("d3.css");
		require.async('syracuse-ui/deps/d3/index', function(err, module) {
			self._d3 = module;
			self.$item.$isAutoSizeDisabled = true;
			self.$item.$isTopLabelAlignment = true;
			self.width = self.$item.$width || width;
			self.height = self.$item.$height || height;
			self.forceWidth = self.width;
			self.forceHeight = self.height - 100;
			Field.prototype.loadBox.call(self);
		});
	},
	render: function() {
		var self = this;
		var id = "a" + helpers.uuid.generate();
		var $$d3 = $("<div/>").addClass("d3-graph-field").appendTo(self._dataValue);
		$$d3.append($("<div/>").addClass("d3-graph-svg-wrap").css({
			width: self.width + "px",
			height: self.height + "px"
		}).attr("id", id));
		var svgDiv = self._d3.select("#" + id);
		self.$$svg = svgDiv.append("svg").attr("width", self.width).attr("height", self.height);
		// compute sizes
		self.$categories = {};
		// svg legend
		// HORZ LEGEND
		self.$legend = _addLegend();
		self.$legend.items(self.$field.$nodeCategories).align("bottom").colors(color).render(self.$$svg, self.$categories, function(memberName) {
			// update graph here
			_updateGraph(self);
		});
		//
		forceHeight = self.$legend.top;
		self.$nodes = [];
		self.$links = [];
		self.$force = self._d3.layout.force() //
		.linkStrength(2) //
		.gravity(0.4) //
		.friction(0.8) //
		.charge(-300) //
		.linkDistance(60) //
		.size([self.forceWidth - 2 * forceMargin, self.forceHeight - 2 * forceMargin]) //
		.nodes(self.$nodes) //
		.links(self.$links);

		self.$force.on("tick", function() {
			linkElements.attr("x1", function(d) {
				return d.source.x;
			}).attr("y1", function(d) {
				return d.source.y;
			}).attr("x2", function(d) {
				return d.target.x;
			}).attr("y2", function(d) {
				return d.target.y;
			});
			var node = nodeElements;
			node.attr("cx", function(d) {
				return d.x;
			}).attr("cy", function(d) {
				return d.y;
			});
			node.attr("transform", function(d) {
				return "translate(" + d.x + "," + d.y + ")";
			});
			textElements.attr("dx", function(d) {
				var dx = d.$item.$category == 0 ? 30 : 15;
				return (d.x >= self.forceWidth / 2) ? dx : -(d.value.length * 6 + dx);
			});
		});
	}
});