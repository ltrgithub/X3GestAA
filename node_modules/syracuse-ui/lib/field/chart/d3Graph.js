"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Field = require('syracuse-ui/lib/field/field').Field;
//var d3 = require('syracuse-ui/deps/graph/d3v2').d3;
var d3 = require('syracuse-ui/deps/d3');
var D3Legend = require('./d3Legend').D3Legend;

var width = 500, height = 400;
var forceWidth = width, forceHeight = height - 100, forceMargin = 20;
var legendMemberHeight = 12, legendMemberMargin = 5, legendWidth = 80, legendMargin = 10;
var legendCols = 4;

var color = ["#024731", "#69923a", "#a8b400", "#3a3565", "#652d86", "#c1afe5"];

// global node/link elements avoid reselecting on "ontick"
var nodeElements, linkElements, textElements;

function _makeData(field){
    // create D3 node/links structures
    // clone $nodes as it will be modified
    var nodes = (field.$data.$nodes || []).map(function(node){
        var proto = field.$field.$nodeCategories[node.$category];
        var value = field.articleParent.parseExpression(proto.$prototype.$properties.$value, node);
        var title = proto.$title;
        //
        return (field.$categories[proto.$title]) ? {
            value: value,
            title: title,
            $field: proto,
            $item: node
        } : null;
    });
    // clone links
    field.$links = (field.$data.$links || []).filter(function(link){
        // filter selected nodes
        return (nodes[link.$source] && nodes[link.$target]);
    }).map(function(link){
        return {
            source: nodes[link.$source],
            target: nodes[link.$target],
            $field: field.$field.$linkCategories[link.$category]
        }
    });
    //
    // filter null records
    field.$nodes = nodes.filter(function(node){
        return node != null;
    });
}

function _updateGraph(field){
    var self = field;
    var svg = self.$$svg;
    // cleanup
    svg.selectAll("g.d3-graph-node").remove();
    svg.selectAll("line.d3-graph-link").remove();
    //
    _makeData(field);
    //
    var force = field.$force;
    force.nodes(field.$nodes).links(field.$links).start();
    // links
    // update links data
    var link = svg.selectAll("line.d3-graph-link").data(field.$links);
    // select missing links, create lines
    linkElements = link.enter().insert("svg:line", ".node").attr("class", "d3-graph-link").attr("x1", function(d){
        return d.source.x;
    }).attr("y1", function(d){
        return d.source.y;
    }).attr("x2", function(d){
        return d.target.x;
    }).attr("y2", function(d){
        return d.target.y;
    });
    
    // nodes
    // make nodes as groups to allow text elements grouped with circles
    var node = svg.selectAll("g.d3-graph-node").data(field.$nodes);
    // create nodes
    var newNodes = nodeElements = node.enter().append("svg:g").attr("class", "d3-graph-node").call(force.drag);
    // add circle element
    newNodes.append("circle").attr("class", "d3-graph-node").attr("r", function(d){
        return (d.$item.$category == 0) ? 20 : 10;
    }).style("fill", function(d){
        return color[d.$item.$category];
    }).on("click", function(d){
        d.$field.$prototype && d.$field.$prototype.$links && d.$field.$prototype.$links.$default &&
        document.controller.openPage(field.articleParent, d.$field.$prototype.$links.$default, d.$item);
    });
    //    .on("mouseenter", function(d){})
    //    .on("mouseleave", function(d){})
    
    newNodes.append("title").text(function(d){
        return d.title + ": " + d.value;
    });
    
    textElements = nodeElements.append("svg:text").attr("class", "d3-graph-nodetext").attr("dx", 12).attr("dy", ".35em").text(function(d){
        return d.value
    });
}

function NodeChart(){
}

exports.nodeChart = helpers.defineClass(NodeChart, Field, {
    onWindowResize: function(){
        //si this.$item.$isAutoSize = true ou this.applyAutoSize(true) 
    },
    setDataValue: function(value){
        this.currentValue = value;
        var self = this;
        if (value && value.$url) {
            self.articleParent.fetch({
                $location: {
                    $url: self.articleParent.parseExpression(value.$url)
                }
            }, function(data, response){
                self.$data = data;
                _updateGraph(self);
            });
        }
    },
    loadBox: function(){
        this.$isLayoutContentSizeDisabled = true;
        this.$item.$isTopLabelAlignment = true;
        Field.prototype.loadBox.call(this);
    },
    render: function(){
        var self = this;
        var id = "a" + helpers.uuid.generate();
        var $$d3 = $("<div/>").addClass("d3-graph-field").appendTo(this.$$dataValue);
        $$d3.append($("<div/>").addClass("d3-graph-svg-wrap").css({
            width: width + "px",
            height: height + "px"
        }).attr("id", id));
        var svgDiv = d3.select("#" + id);
        //var svgDiv = fieldContainer.append("div").attr("class", "d3-graph-svg-wrap").attr("width", width).attr("height", height);
        /*this.$$svg = $("<div/>").attr("width", width).attr("height", height).appendTo(svgDiv);
         return;*/
        this.$$svg = svgDiv.append("svg").attr("width", width).attr("height", height);
        // compute sizes
        this.$categories = {}
        // svg legend
        // HORZ LEGEND
        this.$legend = new D3Legend();
        this.$legend.items(this.$field.$nodeCategories).align("bottom").colors(color).render(this.$$svg, self.$categories, function(memberName){
            // update graph here
            _updateGraph(self);
        });
        //
        forceHeight = this.$legend.top;
        // force component setup
        this.$nodes = [];
        this.$links = [];
        //
        this.$force = d3.layout.force().friction(0.8).charge(-300).linkDistance(60).size([forceWidth - 2 * forceMargin, forceHeight - 2 * forceMargin]).nodes(this.$nodes).links(this.$links);
        // mouvement callback
        this.$force.on("tick", function(){
            linkElements.attr("x1", function(d){
                return d.source.x;
            }).attr("y1", function(d){
                return d.source.y;
            }).attr("x2", function(d){
                return d.target.x;
            }).attr("y2", function(d){
                return d.target.y;
            });
            //
            var node = nodeElements;
            node.attr("cx", function(d){
                return d.x;
            }).attr("cy", function(d){
                return d.y;
            });
            //
            node.attr("transform", function(d){
                return "translate(" + d.x + "," + d.y + ")";
            });
            //
            textElements.attr("dx", function(d){
                return (d.x >= forceWidth / 2) ? 15 : -(d.value.length * 5 + 15);
            });
        });
    }
});
