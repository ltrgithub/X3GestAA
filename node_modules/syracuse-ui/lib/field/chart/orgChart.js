"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var datetime = require('syracuse-core/lib/types/datetime');
var Article = require("syracuse-ui/lib/article/article").Article;
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var TabularChartRecord = require('./tabularChartRecord').TabularChartRecord;
require('syracuse-ui/deps/highcharts-3.0.1/highcharts.src');
require('syracuse-ui/deps/highcharts-3.0.1/highcharts-more');
require('syracuse-ui/deps/highcharts-3.0.1/modules/exporting');
// Highcharts.theme = require('syracuse-ui/themes/desktop/sage/highcharts/theme').theme;
var debug = false;
// Highcharts.setOptions(Highcharts.theme);
var forEachKey = helpers.object.forEachKey,
    objectCopy = helpers.object.copy,
    objectClone = helpers.object.clone,
    stringify = helpers.object.stringify;

var _merge = Highcharts.merge;

var _formatApi = require('syracuse-ui/lib/field/formatApi');

function OrgChart() {}

exports.OrgChart = helpers.defineClass(OrgChart, Article, {
    onWindowResize: function(display) {
        console.log("OrgChart.onWindowResize " + this.id + " : display=" + display + ", displayed=" + this.displayed + " , size=(" + this.layoutSlot.clientWidth + ", " + this.layoutSlot.clientHeight + ")");
        if (display) this.displayed = true;
        if (this.displayed && !this._chart && this.layoutSlot.clientWidth !== 0) {
            // defer chart creation when we are ready to display
            this._createChart();
        }
    },

    dispose: function() {
        this._chart && this._chart.destroy();
        this._localize = null;
        Article.prototype.dispose.call(this);
    },

    applyDesignMetaData: function(metadata, onAuthoring) {},

    drawBox: function() {
        this.dataset = null;
        this.$authoringType = "orgview$highCharts";
        this.$localization = this.getArticleParent().$prototype.$localization;
        this._localize = locale.resources(module)();
        // debug && console.log("HighCharts.drawBox " + this.id);
        var proto = this.$prototype;
        // create an alias
        proto.$properties = proto.$item.$properties;

        if (!this.$item.$isListEmbeded) {
            this.getArticleParent().bind(this, this.$item.$bind);
        }
    },

    setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
        console.log(Date.now() + " - OrgChart.setDataBind " + this.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length) + " , size=(" + this.layoutSlot.clientWidth + ", " + this.layoutSlot.clientHeight + ")");
        var self = this;
        if (metaData) {
            // this._processMeta(metaData);
        }
        this.dataset = dataRecordSet;

        var settings;
        if (this.dataset && this.dataset.length > 0) {
            // settings = this._settingsFromValue();
            settings = {};
            // var tm = "timer_createChart",
            //     fnc = function() {
            //         console.log(Date.now() + " - OrgCharts.delayed.setDataBind " + self.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length));
            //         if (!self._chart && self.layoutSlot.clientWidth !== 0) {
            //             return self._createChart({});
            //         }
            //         if (!self._chart) {
            //             setTimeout(fnc, 100);
            //         }
            //     };
            // if (this[tm]) clearTimeout(this[tm]);
            // this[tm] = setTimeout(fnc, 100);
            // ======
            // if (!this._chart && settings) {
            //     this._createChart(settings);
            // } else if (this._chart && settings) {
            //     var self = this;
        }
    },

    _buildTree: function(dataset) {
        var _map = this._map = {},
            $bindings = this.$prototype.$decorator.$bindings;
        dataset.forEach(function(e, i, a) {
            var parentId = e[$bindings.$parent],
                id = e[$bindings.$id],
                parent = _map[parentId],
                node = _map[id];
            // if (parentId == null || parentId.length == 0) {
            // parentId = "$";
            // }
            if (!parent) {
                parent = {
                    children: [],
                    id: parentId
                }
                _map[parentId] = parent;
            }
            if (!node) {
                node = {
                    parent: parent,
                    children: [],
                    id: id,
                    desc: e[$bindings.$description],
                    image: e[$bindings.$image],
                    values: []
                }
                _map[id] = node;
                Object.keys(e).forEach(function(key) {
                    if (key.charAt(0) != "$") {
                        node.values.push(e[k]);
                    }
                });
                parent.children.push(node);
            }
        });

        var root = _map[""];
        // var root = {
        //     children: [],
        //     parentId: dataset[$bindings.$parent],
        //     id: dataset[$bindings.$id],
        //     // slot: slot,
        //     // item: document.createElement("div"),
        //     // desc: document.createElement("div"),
        //     // picker: document.createElement("a"),
        // };
    },

    _createChart: function(settings) {
        var addEvent = Highcharts.addEvent,
            each = Highcharts.each;

        if (this.dataset && this.dataset.length > 0) {
            this._buildTree(this.dataset);
        }
        var self = this,
            // options = _merge(self._getPref(), self._getOptions(self.$prototype));
            options = {
                chart: {
                    renderTo: self.layoutSlot,
                    events: {
                        load: function() {
                            // _drawTest.call(this);
                            _drawOrg.call(this, self._map[""]);
                        }
                    }
                },
                title: {
                    text: 'Org chart view'
                }

            };

        self._chart = new Highcharts.Chart(options);
    },

    _localizedText: function(val) {
        // TODO: use getLocalizeText
        var $localization = this.$localization;
        return val && val.replace(/\{(@[\w-]+)\}/g, function(match, p1) {
            return ($localization && $localization[p1]) || match;
        });
    },

    _redraw: function() {
        this._chart && this._chart.redraw();
    },

    _getFieldEvalTitle: function() {
        return this.page.externalAdapter.getFieldEvalTitle(this) || [];
    },

    // --------------------------------------------------------------------------------
    // Event management
    // --------------------------------------------------------------------------------
    _onMeasureClick: function(context) {},

    // --------------------------------------------------------------------------------
    // Chart management
    // --------------------------------------------------------------------------------
    destroy: function() {
        this._chart && this._chart.destroy();
    }
});

function _drawOrg(root) {
    var ren = this.renderer,
        colors = Highcharts.getOptions().colors,
        rightArrow = ['M', 0, 0, 'L', 100, 0, 'L', 95, 5, 'M', 100, 0, 'L', 95, -5],
        leftArrow = ['M', 100, 0, 'L', 0, 0, 'L', 5, 5, 'M', 0, 0, 'L', 5, -5],
        minHeight = 50,
        minWidth = 50;

    console.log("OrgChart._drawOrg: root=" + stringify(root));
    // var root = {
    //     children: [],
    //     parentId: dataset[$bindings.$parent],
    //     id: dataset[$bindings.$id],
    //     // slot: slot,
    //     // item: document.createElement("div"),
    //     // desc: document.createElement("div"),
    //     // picker: document.createElement("a"),
    // };

    function positionNode(node, left, top) {
        var x = 0,
            y = 0,
            vGap = 10,
            hGap = 10,
            cw = 0;
        node.rect = node.rect || {};
        node.rect.height = node.rect.height || minHeight;
        node.rect.width = node.rect.width || minWidth;
        if (node.children.length > 0) {
            x = left;
            // the top coordinate of children
            y = top + node.rect.height + vGap;
            node.children.forEach(function(child) {
                cw = positionNode(child, x, y)
                // the left coordinate of the next child
                x += cw + hGap;
            });
            // center Node between Left and(x - GapH) with top coordinate at Top
            node.rect.x = (left + (x - hGap)) / 2;
            node.rect.y = top;
            // store node rectangle in NodeLoc for future reference with Node as the key
            // return max (width of node, x - GapH - Left) // width of tree rooted at Node
            return Math.max(node.rect.width, x - hGap - left);
        } else { // Node has no children
            // position Node with top-left coordinate at (Left, Top)
            node.rect.x = left;
            node.rect.y = top;
            // store node rectangle for future refecence with Node as the key
            // return width of Node
            return node.rect.width;
        }
    }

    function drawNode(node) {
        var rect = node.rect;
        // draw Node into the rectangle
        ren.label(node.desc, node.rect.x, node.rect.y).attr({
            r: 5,
            width: node.rect.width,
            fill: colors[1]
        }).css({
            color: 'white',
            fontWeight: 'normal'
        }).add();

        // draw children
        node.children.forEach(function(child) {
            drawNode(child);
        });
    }

    root.rect = {
        width: 0,
        height: 0
    };
    positionNode(root, 20, 20);
    drawNode(root);
}

function _drawTest() {
    // Draw the flow chart
    var ren = this.renderer,
        colors = Highcharts.getOptions().colors,
        rightArrow = ['M', 0, 0, 'L', 100, 0, 'L', 95, 5, 'M', 100, 0, 'L', 95, -5],
        leftArrow = ['M', 100, 0, 'L', 0, 0, 'L', 5, 5, 'M', 0, 0, 'L', 5, -5];


    // Separator, client from service
    ren.path(['M', 120, 40, 'L', 120, 330]).attr({
        'stroke-width': 2,
        stroke: 'silver',
        dashstyle: 'dash'
    }).add();

    // Separator, CLI from service
    ren.path(['M', 420, 40, 'L', 420, 330]).attr({
        'stroke-width': 2,
        stroke: 'silver',
        dashstyle: 'dash'
    }).add();

    // Headers
    ren.label('Web client', 20, 40).css({
        fontWeight: 'bold'
    }).add();
    ren.label('Web service / CLI', 220, 40).css({
        fontWeight: 'bold'
    }).add();
    ren.label('Command line client', 440, 40).css({
        fontWeight: 'bold'
    }).add();

    // SaaS client label
    ren.label('SaaS client<br/>(browser or<br/>script)', 10, 82).attr({
        fill: colors[0],
        stroke: 'white',
        'stroke-width': 2,
        padding: 5,
        r: 5
    }).css({
        color: 'white'
    }).add().shadow(true);

    // Arrow from SaaS client to Phantom JS
    ren.path(rightArrow).attr({
        'stroke-width': 2,
        stroke: colors[3]
    }).translate(95, 95).add();

    ren.label('POST options in JSON', 90, 75).css({
        fontSize: '10px',
        color: colors[3]
    }).add();

    ren.label('PhantomJS', 210, 82).attr({
        r: 5,
        width: 100,
        fill: colors[1]
    }).css({
        color: 'white',
        fontWeight: 'bold'
    }).add();

    // Arrow from Phantom JS to Batik
    ren.path(['M', 250, 110, 'L', 250, 185, 'L', 245, 180, 'M', 250, 185, 'L', 255, 180]).attr({
        'stroke-width': 2,
        stroke: colors[3]
    }).add();

    ren.label('SVG', 255, 120).css({
        color: colors[3],
        fontSize: '10px'
    }).add();

    ren.label('Batik', 210, 200).attr({
        r: 5,
        width: 100,
        fill: colors[1]
    }).css({
        color: 'white',
        fontWeight: 'bold'
    }).add();
    // Arrow from Batik to SaaS client
    ren.path(['M', 235, 185, 'L', 235, 155, 'C', 235, 130, 235, 130, 215, 130, 'L', 95, 130, 'L', 100, 125, 'M', 95, 130, 'L', 100, 135]).attr({
        'stroke-width': 2,
        stroke: colors[3]
    }).add();

    ren.label('Rasterized image', 100, 110).css({
        color: colors[3],
        fontSize: '10px'
    }).add();

    // Browser label
    ren.label('Browser<br/>running<br/>Highcharts', 10, 180).attr({
        fill: colors[0],
        stroke: 'white',
        'stroke-width': 2,
        padding: 5,
        r: 5
    }).css({
        color: 'white',
        width: '100px'
    }).add().shadow(true);


    // Arrow from Browser to Batik
    ren.path(rightArrow).attr({
        'stroke-width': 2,
        stroke: colors[1]
    }).translate(95, 205).add();

    ren.label('POST SVG', 110, 185).css({
        color: colors[1],
        fontSize: '10px'
    }).add();

    // Arrow from Batik to Browser
    ren.path(leftArrow).attr({
        'stroke-width': 2,
        stroke: colors[1]
    }).translate(95, 215).add();

    ren.label('Rasterized image', 100, 215).css({
        color: colors[1],
        fontSize: '10px'
    }).add();

    // Script label
    ren.label('Script', 450, 82).attr({
        fill: colors[2],
        stroke: 'white',
        'stroke-width': 2,
        padding: 5,
        r: 5
    }).css({
        color: 'white',
        width: '100px'
    }).add().shadow(true);

    // Arrow from Script to PhantomJS
    ren.path(leftArrow).attr({
        'stroke-width': 2,
        stroke: colors[2]
    }).translate(330, 90).add();

    ren.label('Command', 340, 70).css({
        color: colors[2],
        fontSize: '10px'
    }).add();

    // Arrow from PhantomJS to Script
    ren.path(rightArrow).attr({
        'stroke-width': 2,
        stroke: colors[2]
    }).translate(330, 100).add();

    ren.label('Rasterized image', 330, 100).css({
        color: colors[2],
        fontSize: '10px'
    }).add();
}