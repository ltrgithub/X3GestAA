"use strict";

var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var datetime = require('syracuse-core/lib/types/datetime');
var Article = require("syracuse-ui/lib/article/article").Article;
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var TabularChartRecord = require('./tabularChartRecord').TabularChartRecord;
require('syracuse-ui/deps/highcharts-3.0.1/highcharts.src');
require('syracuse-ui/deps/highcharts-3.0.1/highcharts-more');
require('syracuse-ui/deps/highcharts-3.0.1/modules/exporting');
// Highcharts.theme = require('syracuse-ui/themes/desktop/sage/highcharts/theme').theme;
var debug = false;
// Highcharts.setOptions(Highcharts.theme);
var forEachKey = helpers.object.forEachKey,
    objectCopy = helpers.object.copy,
    objectClone = helpers.object.clone,
    stringify = helpers.object.stringify;

var _merge = Highcharts.merge;

var _formatApi = require('syracuse-ui/lib/field/formatApi');

function OrgChart() {}

exports.OrgChart = helpers.defineClass(OrgChart, Article, {
    onWindowResize: function(display) {
        debug && console.log("OrgChart.onWindowResize " + this.id + " : display=" + display + ", displayed=" + this.displayed + " , size=(" + this.layoutSlot.clientWidth + ", " + this.layoutSlot.clientHeight + ")");
        if (display) this.displayed = true;
        if (this.displayed && !this._chart && this.layoutSlot.clientWidth !== 0) {
            // defer chart creation when we are ready to display
            this._createChart();
        }
    },

    dispose: function() {
        this.destroy();
        this._localize = null;
        Article.prototype.dispose.call(this);
    },

    applyDesignMetaData: function(metadata, onAuthoring) {},

    drawBox: function() {
        this.dataset = null;
        this.$authoringType = "orgview$highCharts";
        this.$localization = this.getArticleParent().$prototype.$localization;
        this._localize = locale.resources(module)();
        this._map = {};
        // debug && console.log("HighCharts.drawBox " + this.id);
        var proto = this.$prototype;
        // create an alias
        proto.$properties = proto.$item.$properties;

        if (!this.$item.$isListEmbeded) {
            this.getArticleParent().bind(this, this.$item.$bind);
        }
    },

    setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
        debug && console.log(Date.now() + " - OrgChart.setDataBind " + this.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length) + " , size=(" + this.layoutSlot.clientWidth + ", " + this.layoutSlot.clientHeight + ")");
        var self = this;
        if (metaData) {
            // this._processMeta(metaData);
        }
        this.dataset = dataRecordSet;

        var settings;
        if (this.dataset && this.dataset.length > 0) {
            if (this.displayed && !this._chart && this.layoutSlot.clientWidth !== 0) {
                // defer chart creation when we are ready to display
                this._createChart();
            }
            // settings = this._settingsFromValue();
            settings = {};
            // var tm = "timer_createChart",
            //     fnc = function() {
            //         console.log(Date.now() + " - OrgCharts.delayed.setDataBind " + self.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length));
            //         if (!self._chart && self.layoutSlot.clientWidth !== 0) {
            //             return self._createChart({});
            //         }
            //         if (!self._chart) {
            //             setTimeout(fnc, 100);
            //         }
            //     };
            // if (this[tm]) clearTimeout(this[tm]);
            // this[tm] = setTimeout(fnc, 100);
            // ======
            // if (!this._chart && settings) {
            //     this._createChart(settings);
            // } else if (this._chart && settings) {
            //     var self = this;
        }
    },

    externalCall: function(proxy, values, opt) {
        var self = this;

        function _resultCallback(res) {
            var err = !res ? {
                "message": "Error"
            } : res.$diagnoses || null;
        }

        if (this.page && this.page.externalAdapter && this.page.externalAdapter.onBlockExRpc) {
            this.page.externalAdapter.onBlockExRpc({
                field: self.attachedField,
                call: {
                    proxy: proxy,
                    values: values,
                    callback: opt && opt.callback || _resultCallback
                }
            });
        }
    },

    _buildTree: function(dataset) {
        var _map = this._map,
            $bindings = this.$prototype.$decorator.$bindings,
            binds = Object.keys($bindings).map(function(k) {
                return $bindings[k];
            });

        dataset.forEach(function(e, i, a) {
            var parentId = e[$bindings.$parent],
                id = e[$bindings.$id],
                parent = _map[parentId],
                node = _map[id];

            if (!parent && parentId.length !== 0) {
                parent = {
                    children: [],
                    id: parentId
                };
                _map[parentId] = parent;
            }
            node = node || {
                children: [],
                id: id,
                i: i
            };
            node.i = node.i || i;
            _map[id] = node;
            if (!node.parent) {
                node.parent = parent;
                node.desc = e[$bindings.$description];
                // node.desc ='<img class="" src="http://dummyimage.com/60x60/ff6600/ffffff"/>'
                // node.desc = '<img src="http://static.adzerk.net/Advertisers/bd294ce7ff4c43b6aad4aa4169fb819b.jpg" title="" alt="" border="0" height="50" width="50">' + //
                // '<span style="font-size: 9pt; font-style:italic;">' + e[$bindings.$description] + '</span>';
                // node.image = e[$bindings.$image];
                // node.image = 'url(http://highcharts.com/demo/gfx/sun.png)';
                node.values = [];
                Object.keys(e).forEach(function(k) {
                    if (k.charAt(0) != "$" && binds.indexOf(k) == -1) {
                        node.values.push(e[k]);
                    }
                });
                parent && parent.children.push(node);
            }
            if (!parent) {
                _map[""] = node;
            }
        });
    },

    _createChart: function(settings) {
        var addEvent = Highcharts.addEvent,
            each = Highcharts.each;

        if (this.dataset && this.dataset.length > 0) {
            this._buildTree(this.dataset);
        }
        var root = this._map[""];
        if (!root) {
            return;
        }
        var self = this,
            // options = _merge(self._getPref(), self._getOptions(self.$prototype));
            options = {
                chart: {
                    renderTo: self.layoutSlot,
                    events: {
                        load: function() {
                            self.orgWidget = new OrgChartWidget(self, this);
                            self.orgWidget.draw(root);
                        }
                    }
                },
                title: {
                    text: 'Org chart view'
                },
                tooltip: {
                    formatter: function() {
                        return "tooltip";
                    }
                }
            };

        self._chart = new Highcharts.Chart(options);
    },

    _localizedText: function(val) {
        // TODO: use getLocalizeText
        var $localization = this.$localization;
        return val && val.replace(/\{(@[\w-]+)\}/g, function(match, p1) {
            return ($localization && $localization[p1]) || match;
        });
    },

    _redraw: function() {
        this._chart && this._chart.redraw();
    },

    _getFieldEvalTitle: function() {
        return this.page.externalAdapter.getFieldEvalTitle(this) || [];
    },

    // --------------------------------------------------------------------------------
    // Event management
    // --------------------------------------------------------------------------------
    _onMeasureClick: function(context) {},

    // --------------------------------------------------------------------------------
    // Chart management
    // --------------------------------------------------------------------------------
    destroy: function() {
        this._chart && this._chart.renderer.destroy();
        // this._chart && this._chart.destroy && this._chart.destroy();
    }
});

// For interaction with X3 the following subprog from AMAJHIER is used
// Subprog MAJHIER(CODACT,NLI,FATHVAL,RANGNIV,MESSAGE,CODRET)
// #     CODACT  : Action code 
// #           D : Delete
// #           M : Modify
// #           E : Click on a leaf element
// #     NLI     : Line number of the element (1..n)
// #     FATHVAL : Line number of the parent element (1..n)
// #     RANGNIV : Rang de rattachement par rapport au père (1 à n)
// #               Si RANGNIV<0 on rattache "avant", si >0 "après"
// #     MESSAGE : Message
// #     CODRET  : Return status: 1 if OK
//
// changing parent ==> AMAJHIER.MAJHIER("M", node, parent, RANGNIV=(-1 or 1) when ?, "", -1)
// double-click ==> AMAJHIER.MAJHIER("E",node,"", 0, "", -1)

function OrgChartWidget(article, chart) {
    this.article = article;
    this.chart = chart;
}

OrgChartWidget.prototype = {
    // see http://jsfiddle.net/7UsbM/7/ for drag'n drop
    draw: function(root) {
        var self = this,
            chart = this.chart,
            ren = chart.renderer,
            addEvent = Highcharts.addEvent,
            each = Highcharts.each,
            options = Highcharts.getOptions(),
            colors = options.colors,
            minHeight = 50,
            minWidth = 50;

        var bbox = null,
            worker = _nodeSlot(ren, "", -999, -999).add();

        var hasTouch = 'ontouchstart' in window,
            START = 'mousedown',
            MOVE = 'mousemove',
            END = 'mouseup';

        if (hasTouch) {
            START = 'touchstart';
            MOVE = 'touchmove';
            END = 'touchend';
        }

        function normalizeEvent(e) {
            var props = ['clientX', 'clientY', 'pageX', 'pageY'],
                i, l, n;

            if (['touchstart', 'touchmove', 'touchend'].indexOf(e.type) > -1) {
                for (i = 0, l = props.length; i < l; i++) {
                    n = props[i];
                    e[n] = e.originalEvent.targetTouches[0][n];
                }
            }

            return e;
        }

        function positionNode(node, left, top) {
            var x = 0,
                y = 0,
                vGap = 10,
                hGap = 10,
                cw = 0;
            node.rect = node.rect || {};
            bbox = worker.attr({
                text: node.desc,
                // symbol: node.image
            }).getBBox();

            node.rect.width = Math.max(Math.ceil(bbox.width), minWidth);
            node.rect.height = Math.ceil(bbox.height);
            // node.rect.height = node.rect.height || minHeight;
            // node.rect.width = node.rect.width || minWidth;
            if (node.children.length > 0) {
                x = left;
                // the top coordinate of children
                y = top + node.rect.height + vGap;
                node.children.forEach(function(child) {
                    cw = positionNode(child, x, y);
                    // the left coordinate of the next child
                    x += cw + hGap;
                    debug && console.log("--> cw=" + cw + ", x=" + x);
                });
                // center Node between Left and(x - GapH) with top coordinate at Top
                node.rect.x = (left + (x - hGap) - node.rect.width) / 2;
                node.rect.y = top;
                debug && console.log("OrgChart.positionNode: " + node.desc + "(" + node.rect.x + "," + node.rect.y + ")" + "(" + (node.rect.x + node.rect.width) + "," + (node.rect.y + node.rect.height) + ")");
                // width of tree rooted at Node
                return Math.max(node.rect.width, x - hGap - left);
            } else {
                // position Node with top-left coordinate at (Left, Top)
                node.rect.x = left;
                node.rect.y = top;
                debug && console.log("OrgChart.positionNode: " + node.desc + "(" + node.rect.x + "," + node.rect.y + ")" + "(" + (node.rect.x + node.rect.width) + "," + (node.rect.y + node.rect.height) + ")");
                return node.rect.width;
            }
        }

        function drawNode(node) {
            var rect = node.rect,
                parent = node.parent,
                pRect = parent ? parent.rect : rect,
                p1 = {
                    x: rect.x + rect.width / 2,
                    y: rect.y
                },
                p2 = {
                    x: pRect.x + pRect.width / 2,
                    y: pRect.y + pRect.height
                };
            // draw Node into the rectangle
            if (debug) {
                var indent = "";
                for (var p = parent; p; indent += "  ", p = p.parent);
                console.log(indent + node.desc + "(" + rect.x + "," + rect.y + "," + rect.width + "," + rect.height + ")");
            }
            if (parent) {
                node.junction && node.junction.destroy();
                node.junction = ren.path(['M', p1.x, p1.y, 'L', p1.x, (p1.y + p2.y) / 2, 'L', p2.x, (p1.y + p2.y) / 2, 'L', p2.x, p2.y]).attr({
                    'stroke-width': 2,
                    stroke: colors[3]
                }).add();
            }
            // var nodeSlot = ren.label(node.desc, rect.x, rect.y).attr({
            // var nodeSlot = ren.label(node.desc, rect.x, rect.y, node.image, null, null, true).attr({
            // var nodeSlot = ren.label(node.desc, rect.x, rect.y).attr({
            node.slot && node.slot.destroy();
            var nodeSlot = node.slot = _nodeSlot(ren, node.desc, rect.x, rect.y).add();

            Highcharts.addEvent(nodeSlot.element, 'mouseenter', function() {
                debug && console.log("mouseenter: " + node.desc + "@" + node.id + "(" + node.i + ")");
                if (drag && drag.node && drag.node !== node) {
                    drag.target = node;
                }
                chart.hoverNode = node;
                nodeSlot.attr('fill', colors[2]);
                nodeSlot.css({
                    color: 'white'
                });
            });
            Highcharts.addEvent(nodeSlot.element, 'mouseleave', function() {
                debug && console.log("mouseleave: " + node.desc + "@" + node.id + "(" + node.i + ")");
                if (drag && drag.target) {
                    delete drag.target;
                }
                delete chart.hoverNode;
                nodeSlot.attr('fill', colors[1]);
                nodeSlot.css({
                    color: 'black'
                });
            });
            Highcharts.addEvent(nodeSlot.element, 'dblclick', function(e) {
                debug && console.log("dblclick: " + node.desc + "@" + node.id + "(" + node.i + ")");
                onDoubleClick(node);
            });
            nodeSlot.on('click', function() {
                debug && console.log("click " + node.desc + "@" + node.id + "(" + node.i + ") parent: " + (node.parent ? node.parent.desc : "") + //
                "\nrect: " + stringify(rect) + //
                "\nvalues: " + node.values.reduce(function(a, b) {
                    return a + "," + b;
                }));
            });

            // draw children
            node.children.forEach(function(child) {
                drawNode(child);
            });
        }

        var container = chart.container,
            drag;

        function bringToBack(el) {
            el.parentNode.insertBefore(el, worker.element.nextSibling);
        }

        // chart.redraw(); // kill animation (why was this again?)
        Highcharts.addEvent(container, START, function(e) {
            e = normalizeEvent(e);
            var hoverNode = chart.hoverNode;
            // if (hoverNode && hoverNode.series.options.draggable) {
            if (hoverNode) {
                drag = {
                    node: hoverNode,
                    x: e.pageX,
                    y: e.pageY
                };
                dragSnapshot(drag.node);
                debug && console.log("Drag start: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
            }
        });

        function dragSnapshot(tree) {
            traverse(tree, function(node) {
                if (!node) return;
                bringToBack(node.slot.element);
                node.drag = {
                    slot: {
                        x: node.slot.translateX,
                        y: node.slot.translateY
                    }
                };
                if (node.junction) {
                    node.drag.junction = {
                        x: node.junction.translateX || 0,
                        y: node.junction.translateY || 0
                    };
                }
            });
        }

        function dragSnapshotClear(tree) {
            traverse(tree, function(node) {
                debug && console.log("Drag clear: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
                node.drag && delete node.drag;
                node.children.forEach(function(child) {
                    dragSnapshotClear(child);
                });
            });
        }

        Highcharts.addEvent(container, MOVE, function(e) {
            move(e);
        });

        function move(e) {
            e = normalizeEvent(e);
            if (drag && drag.node) {
                var delta = {
                    x: e.pageX - drag.x,
                    y: e.pageY - drag.y
                };
                // e._debug && console.log("Drag drop: delta=(" + delta.x + "," + delta.y + "), node=(" + drag.node.drag.slot.x + "," + drag.node.drag.slot.y);
                drag.node.junction && drag.node.junction.hide();
                moveSubtree(drag.node, delta);
            }
        }

        function traverse(node, visitor) {
            visitor(node);
            // visit children
            node.children.forEach(function(child) {
                traverse(child, visitor);
            });
        }

        function moveSubtree(tree, delta) {
            traverse(tree, function(node) {
                node.junction && node.drag.junction && node.junction.translate(node.drag.junction.x + delta.x, node.drag.junction.y + delta.y);
                node.slot.translate(node.drag.slot.x + delta.x, node.drag.slot.y + delta.y);
            });
        }

        function restorePosition(tree) {
            traverse(tree, function(node) {
                if (node.drag) {
                    if (node.drag.slot) {
                        node.slot.translate(node.drag.slot.x, node.drag.slot.y);
                    }
                    if (node.drag.junction) {
                        node.junction.translate(node.drag.junction.x || 0.001, node.drag.junction.y || 0.001);
                    }
                }
            });
        }

        function drop(e) {
            if (drag && drag.node) {
                debug && console.log("Drag drop: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
                e._debug = debug;
                if (drag && drag.target) {
                    debug && console.log("Drag drop to target: " + drag.target.desc);
                    reparent(drag.node, drag.target);
                    // move(e);
                } else {
                    restorePosition(drag.node);
                }

                if (drag) {
                    dragSnapshotClear(drag.node);
                    drag.node.junction && drag.node.junction.show();
                    drag = undefined;
                }
            }
        }

        function reparent(node, parent) {
            if (node.parent === parent) {
                return;
            }

            var i = node.parent.children.indexOf(node);
            node.parent.children.splice(i, 1);
            node.parent = parent;
            parent.children.splice(0, 0, node);
            redraw();
            onReparent(node, parent, 0);
        }

        function drawTree() {
            positionNode(root, 20, 80);
            drawNode(root);

        }

        function redraw() {
            traverse(root, function(node) {
                node.rect = undefined;
                node.slot.destroy();
                node.junction && node.junction.destroy();
            });
            drawTree();
        }

        function onDoubleClick(node) {
            // X3 table are 1 base
            self.article.externalCall("MAJHIER", ["E", node.i + 1, node.parent && (node.parent.i + 1) || 0, 0, "", -1]);
        }

        function onReparent(node, parent, rank) {
            self.article.externalCall("MAJHIER", ["M", node.i + 1, parent.i + 1, rank, "", -1]);
        }

        addEvent(document, END, drop);
        addEvent(container, 'mouseleave', drop);

        drawTree();
    }

};

// function label(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

function _nodeSlot(ren, str, x, y) {
    var options = Highcharts.getOptions(),
        colors = options.colors;
    // ren.label("", -999, -999, null, null, null, true, null, 'worker').attr({
    return ren.label(str, x, y, null, null, null).attr({
        r: 5,
        // y: 30,
        // height: 60,
        fill: colors[1]
    }).css({
        color: 'black',
        fontWeight: 'normal',
        'text-align': 'center'
    });
}