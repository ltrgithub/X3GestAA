"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var datetime = require('syracuse-core/lib/types/datetime');
var Article = require("syracuse-ui/lib/article/article").Article;
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var TabularChartRecord = require('./tabularChartRecord').TabularChartRecord;
var syraUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Syra;

require('syracuse-ui/deps/highcharts-3.0/highcharts.src');
require('syracuse-ui/deps/highcharts-3.0/highcharts-more.src');
require('syracuse-ui/deps/highcharts-3.0/modules/exporting.src');

Highcharts.theme = require('syracuse-ui/themes/desktop/sage/highcharts/theme').theme;
var debug = false;
Highcharts.setOptions(Highcharts.theme);
var forEachKey = helpers.object.forEachKey,
    objectCopy = helpers.object.copy,
    objectClone = helpers.object.clone,
    stringify = helpers.object.stringify;

var merge = Highcharts.merge,
    extend = Highcharts.extend,
    each = Highcharts.each,
    addEvent = Highcharts.addEvent,
    removeEvent = Highcharts.removeEvent,
    HCElement = Highcharts.SVGElement,
    mathRound = Math.round,
    rightArrowPath = "M0,0L0,16L10,8L0,0z",
    leftArrowPath = "M0,0L0,16L-10,8L0,0z",
    bottomArrowPath = "M0,0L16,0L8,10L0,0z",
    STROKE_WIDTH = 'stroke-width',
    IMAGE_PLACEHOLER = "$placeholder",
    UNDEFINED;

var _formatApi = require('syracuse-ui/lib/field/formatApi');

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */

function defined(obj) {
    return obj !== UNDEFINED && obj !== null;
}

function OrgChart() {}

exports.OrgChart = helpers.defineClass(OrgChart, Article, {
    onWindowResize: function() {
        debug && console.log("OrgChart.onWindowResize " + this.id + " : displayed=" + this.displayed + " , size=(" + this.layoutSlot.clientWidth + ", " + this.layoutSlot.clientHeight + ")");
        this.displayed = this.displayed || this.layoutSlot.clientWidth !== 0;
        if (this.displayed && !this._chart) {
            // defer chart creation when we are ready to display
            this._createChart();
        }
    },

    dispose: function() {
        this.destroy();
        this._localize = null;
        Article.prototype.dispose.call(this);
    },

    applyDesignMetaData: function(metadata, onAuthoring) {},

    drawBox: function() {
        this.dataset = null;
        this.$authoringType = "orgview$highCharts";
        this.$localization = this.getArticleParent().$prototype.$localization;
        this._localize = locale.resources(module)();
        this._map = {};
        // debug && console.log("HighCharts.drawBox " + this.id);
        var proto = this.$prototype;
        // create an alias
        proto.$properties = proto.$item.$properties;

        if (!this.$item.$isListEmbeded) {
            this.getArticleParent().bind(this, this.$item.$bind);
        }
    },

    setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
        debug && console.log(Date.now() + " - OrgChart.setDataBind " + this.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length) + " , size=(" + this.layoutSlot.clientWidth + ", " + this.layoutSlot.clientHeight + ")");
        var self = this;
        if (metaData) {
            // this._processMeta(metaData);
        }
        this.dataset = dataRecordSet;

        var settings;
        if (this.dataset && this.dataset.length > 0) {
            if (this.displayed && !this._chart) {
                // defer chart creation when we are ready to display
                this._createChart();
            }
            // settings = this._settingsFromValue();
            settings = {};
            // var tm = "timer_createChart",
            //     fnc = function() {
            //         console.log(Date.now() + " - OrgCharts.delayed.setDataBind " + self.id + ": dataRecordSet=" + (dataRecordSet && dataRecordSet.length));
            //         if (!self._chart && self.layoutSlot.clientWidth !== 0) {
            //             return self._createChart({});
            //         }
            //         if (!self._chart) {
            //             setTimeout(fnc, 100);
            //         }
            //     };
            // if (this[tm]) clearTimeout(this[tm]);
            // this[tm] = setTimeout(fnc, 100);
            // ======
            // if (!this._chart && settings) {
            //     this._createChart(settings);
            // } else if (this._chart && settings) {
            //     var self = this;
        }
    },

    externalCall: function(proxy, values, opt) {
        var self = this;

        function _resultCallback(res) {
            var err = !res ? {
                "message": "Error"
            } : res.$diagnoses || null;
        }

        if (this.page && this.page.externalAdapter && this.page.externalAdapter.onBlockExRpc) {
            this.page.externalAdapter.onBlockExRpc({
                field: self.attachedField,
                call: {
                    proxy: proxy,
                    values: values,
                    callback: opt && opt.callback || _resultCallback
                }
            });
        }
    },

    _buildTree: function(dataset) {
        var $fusionController = syraUtil.getFusionController(this),
            imageBaseUrl = null,
            _map = this._map,
            $bindings = this.$prototype.$decorator.$bindings,
            binds = Object.keys($bindings).map(function(k) {
                return $bindings[k];
            });
        if ($fusionController) {
            imageBaseUrl = this.page.$urlParts.uri && this.page.$urlParts.uri.replace(/\$sessions/, '$files') + "/RES/";
        } else {
            // imageBaseUrl = "/syracuse-ui/themes/desktop/sage/highcharts/";
        }

        dataset.forEach(function(e, i, a) {
            var parentId = e[$bindings.$parent],
                id = e[$bindings.$id],
                parent = _map[parentId],
                node = _map[id];

            if (!parent && parentId.length !== 0) {
                parent = {
                    children: [],
                    id: parentId
                };
                _map[parentId] = parent;
            }
            node = node || {
                children: [],
                id: id,
                i: i
            };
            node.i = node.i || i;
            _map[id] = node;
            if (!node.parent) {
                node.parent = parent;
                node.desc = e[$bindings.$description];
                // '<span style="font-size: 9pt; font-style:italic;">' + e[$bindings.$description] + '</span>';
                var image = e[$bindings.$image];
                node.image = image && imageBaseUrl && (imageBaseUrl + image);
                node.values = [];
                Object.keys(e).forEach(function(k) {
                    if (k.charAt(0) != "$" && binds.indexOf(k) == -1) {
                        node.values.push(e[k]);
                    }
                });
                parent && parent.children.push(node);
            }
            if (!parent) {
                _map[""] = node;
            }
        });
    },

    _createChart: function(settings) {
        var addEvent = Highcharts.addEvent,
            each = Highcharts.each;

        if (this.dataset && this.dataset.length > 0) {
            this._buildTree(this.dataset);
        }
        var root = this._map[""];
        if (!root) {
            return;
        }
        var self = this,
            // options = merge(self._getPref(), self._getOptions(self.$prototype));
            options = {
                chart: {
                    renderTo: self.layoutSlot,
                    events: {
                        load: function() {
                            debug && console.log("OrgChart.chart.events.load");
                            self.orgWidget = new OrgChartWidget(self, this);
                            self.orgWidget.draw(root);
                        },
                        redraw: function(){
                            debug && console.log("OrgChart.chart.events.redraw");
                        }
                    }
                },
                title: {
                    text: 'Org chart view'
                },
                tooltip: {
                    formatter: function() {
                        return "tooltip";
                    }
                }
            };

        self._chart = new Highcharts.Chart(options);
    },

    _localizedText: function(val) {
        // TODO: use getLocalizeText
        var $localization = this.$localization;
        return val && val.replace(/\{(@[\w-]+)\}/g, function(match, p1) {
            return ($localization && $localization[p1]) || match;
        });
    },

    _redraw: function() {
        this._chart && this._chart.redraw();
    },

    _getFieldEvalTitle: function() {
        return this.page.externalAdapter.getFieldEvalTitle(this) || [];
    },

    // --------------------------------------------------------------------------------
    // Event management
    // --------------------------------------------------------------------------------
    _onMeasureClick: function(context) {},

    // --------------------------------------------------------------------------------
    // Chart management
    // --------------------------------------------------------------------------------
    destroy: function() {
        this._chart && this._chart.renderer.destroy();
        // this._chart && this._chart.destroy && this._chart.destroy();
    },

    _drawOrg: function(root) {

    }
});

// For interaction with X3 the following subprog from AMAJHIER is used
// Subprog MAJHIER(CODACT,NLI,FATHVAL,RANGNIV,MESSAGE,CODRET)
// #     CODACT  : Action code 
// #           D : Delete
// #           M : Modify
// #           E : Click on a leaf element
// #     NLI     : Line number of the element (1..n)
// #     FATHVAL : Line number of the parent element (1..n)
// #     RANGNIV : Where to move
// #           0 : As a child of the target
// #          -1 : As a sibling before the target
// #           1 : As a sibling after the target
// #     MESSAGE : Message
// #     CODRET  : Return status: 1 if OK
//
// changing parent ==> AMAJHIER.MAJHIER("M", node, parent, RANGNIV=(-1 or 1) when ?, "", -1)
// double-click ==> AMAJHIER.MAJHIER("E",node,"", 0, "", -1)

function OrgChartWidget(article, chart) {
    this.article = article;
    this.chart = chart;
}

var options = Highcharts.getOptions(),
    colors = options.colors,
    orgOptions = {
        node: {
            textColor: 'black',
            borderColor: colors[1],
            borderWidth: 2,
            backgroundColor: 'white',
            fontWeight: 'normal',
            hover: {
                backgroundColor: colors[2],
                textColor: 'white'
            }
        },
        junction: {
            lineColor: colors[3],
            lineWidth: 2
        }
    };

OrgChartWidget.prototype = {
    // see http://jsfiddle.net/7UsbM/7/ for drag'n drop
    draw: function(root) {
        var self = this,
            chart = this.chart,
            renderer = chart.renderer,
            addEvent = Highcharts.addEvent,
            each = Highcharts.each,
            minHeight = 50,
            minWidth = 50;
        var bbox = null,
            rightArrow = renderer.path([]).attr({
                d: rightArrowPath,
                fill: 'red'
            }).add().translate(-999, -999),
            leftArrow = renderer.path([]).attr({
                d: leftArrowPath,
                fill: 'red'
            }).add().translate(-999, -999),
            bottomArrow = renderer.path([]).attr({
                d: bottomArrowPath,
                fill: 'red'
            }).add().translate(-999, -999),
            workerNoImage = self._nodeSlot("", -999, -999).add(),
            worker = self._nodeSlot("", -999, -999, IMAGE_PLACEHOLER).add();

        var hasTouch = 'ontouchstart' in window,
            START = 'mousedown',
            MOVE = 'mousemove',
            END = 'mouseup';

        if (hasTouch) {
            START = 'touchstart';
            MOVE = 'touchmove';
            END = 'touchend';
        }

        function normalizeEvent(e) {
            var props = ['clientX', 'clientY', 'pageX', 'pageY'],
                i, l, n;

            if (['touchstart', 'touchmove', 'touchend'].indexOf(e.type) > -1) {
                for (i = 0, l = props.length; i < l; i++) {
                    n = props[i];
                    e[n] = e.originalEvent.targetTouches[0][n];
                }
            }

            return e;
        }

        function positionNode(node, left, top) {
            var x = 0,
                y = 0,
                vGap = 10,
                hGap = 10,
                cw = 0;
            node.rect = node.rect || {};
            bbox = (node.image ? worker : workerNoImage).attr({
                text: node.desc,
                // image: node.image
            }).getBBox();

            node.rect.width = Math.max(Math.ceil(bbox.width), minWidth);
            node.rect.height = Math.ceil(bbox.height);
            // node.rect.height = node.rect.height || minHeight;
            // node.rect.width = node.rect.width || minWidth;
            if (node.children.length > 0) {
                x = left;
                // the top coordinate of children
                y = top + node.rect.height + vGap;
                node.children.forEach(function(child) {
                    cw = positionNode(child, x, y);
                    // the left coordinate of the next child
                    x += cw + hGap;
                    debug && console.log("--> cw=" + cw + ", x=" + x);
                });
                // center Node between Left and(x - GapH) with top coordinate at Top
                node.rect.x = (left + (x - hGap) - node.rect.width) / 2;
                node.rect.y = top;
                debug && console.log("OrgChart.positionNode: " + node.desc + "(" + node.rect.x + "," + node.rect.y + ")" + "(" + (node.rect.x + node.rect.width) + "," + (node.rect.y + node.rect.height) + ")");
                // width of tree rooted at Node
                return Math.max(node.rect.width, x - hGap - left);
            } else {
                // position Node with top-left coordinate at (Left, Top)
                node.rect.x = left;
                node.rect.y = top;
                debug && console.log("OrgChart.positionNode: " + node.desc + "(" + node.rect.x + "," + node.rect.y + ")" + "(" + (node.rect.x + node.rect.width) + "," + (node.rect.y + node.rect.height) + ")");
                return node.rect.width;
            }
        }

        function drawNode(node) {
            var rect = node.rect,
                parent = node.parent,
                pRect = parent ? parent.rect : rect,
                p1 = {
                    x: rect.x + rect.width / 2,
                    y: rect.y
                },
                p2 = {
                    x: pRect.x + pRect.width / 2,
                    y: pRect.y + pRect.height
                };
            // draw Node into the rectangle
            if (debug) {
                var indent = "";
                for (var p = parent; p; indent += "  ", p = p.parent);
                console.log(indent + node.desc + "(" + rect.x + "," + rect.y + "," + rect.width + "," + rect.height + ")");
            }
            if (parent) {
                node.junction && node.junction.destroy();
                node.junction = renderer.path(['M', p1.x, p1.y, 'L', p1.x, (p1.y + p2.y) / 2, 'L', p2.x, (p1.y + p2.y) / 2, 'L', p2.x, p2.y]).attr({
                    'stroke-width': orgOptions.junction.lineWidth,
                    stroke: orgOptions.junction.lineColor
                }).add();
            }
            node.slot && node.slot.destroy();
            var nodeSlot = node.slot = self._nodeSlot(node.desc, rect.x, rect.y, node.image).add();

            Highcharts.addEvent(nodeSlot.element, 'mouseenter', function() {
                debug && console.log("mouseenter: " + node.desc + "@" + node.id + "(" + node.i + ")");
                if (drag && drag.node && drag.node !== node) {
                    drag.target = node;
                }
                chart.hoverNode = node;
                nodeSlot.attr('fill', orgOptions.node.hover.backgroundColor);
                nodeSlot.css({
                    color: orgOptions.node.hover.textColor
                });
            });
            Highcharts.addEvent(nodeSlot.element, 'mouseleave', function() {
                debug && console.log("mouseleave: " + node.desc + "@" + node.id + "(" + node.i + ")");
                if (drag && drag.target) {
                    delete drag.target;
                }
                delete chart.hoverNode;
                // nodeSlot.attr('fill', orgOptions.node.backgroundColor);
                nodeSlot.attr('fill', 'white');
                nodeSlot.css({
                    color: orgOptions.node.textColor
                });
            });
            Highcharts.addEvent(nodeSlot.element, 'dblclick', function(e) {
                debug && console.log("dblclick: " + node.desc + "@" + node.id + "(" + node.i + ")");
                onDoubleClick(node);
            });
            nodeSlot.on('click', function() {
                debug && console.log("click " + node.desc + "@" + node.id + "(" + node.i + ") parent: " + (node.parent ? node.parent.desc : "") + //
                "\nrect: " + stringify(rect) + //
                "\nvalues: " + node.values.reduce(function(a, b) {
                    return a + "," + b;
                }));
            });

            // draw children
            node.children.forEach(function(child) {
                drawNode(child);
            });
        }

        var container = chart.container,
            drag;

        function bringToBack(el) {
            el.parentNode.insertBefore(el, worker.element.nextSibling);
        }

        // chart.redraw(); // kill animation (why was this again?)
        Highcharts.addEvent(container, START, function(e) {
            e = normalizeEvent(e);
            var hoverNode = chart.hoverNode;
            // if (hoverNode && hoverNode.series.options.draggable) {
            if (hoverNode) {
                drag = {
                    node: hoverNode,
                    x: e.pageX,
                    y: e.pageY
                };
                dragSnapshot(drag.node);
                debug && console.log("Drag start: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
            }
        });

        function dragSnapshot(tree) {
            traverse(tree, function(node) {
                if (!node) return;
                bringToBack(node.slot.element);
                node.drag = {
                    slot: {
                        x: node.slot.translateX,
                        y: node.slot.translateY
                    }
                };
                if (node.junction) {
                    node.drag.junction = {
                        x: node.junction.translateX || 0,
                        y: node.junction.translateY || 0
                    };
                }
            });
        }

        function dragSnapshotClear(tree) {
            traverse(tree, function(node) {
                debug && console.log("Drag clear: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
                node.drag && delete node.drag;
                node.children.forEach(function(child) {
                    dragSnapshotClear(child);
                });
            });
        }

        Highcharts.addEvent(container, MOVE, function(e) {
            move(e);
        });

        function move(e) {
            e = normalizeEvent(e);
            if (drag && drag.node) {
                var delta = {
                    x: e.pageX - drag.x,
                    y: e.pageY - drag.y
                };
                // e._debug && console.log("Drag drop: delta=(" + delta.x + "," + delta.y + "), node=(" + drag.node.drag.slot.x + "," + drag.node.drag.slot.y);
                drag.node.junction && drag.node.junction.hide();
                moveSubtree(drag.node, delta);
            }
        }

        function traverse(node, visitor) {
            visitor(node);
            // visit children
            node.children.forEach(function(child) {
                traverse(child, visitor);
            });
        }

        function moveSubtree(tree, delta) {
            traverse(tree, function(node) {
                node.junction && node.drag.junction && node.junction.translate(node.drag.junction.x + delta.x, node.drag.junction.y + delta.y);
                node.slot.translate(node.drag.slot.x + delta.x, node.drag.slot.y + delta.y);
            });
        }

        function restorePosition(tree) {
            traverse(tree, function(node) {
                if (node.drag) {
                    if (node.drag.slot) {
                        node.slot.translate(node.drag.slot.x, node.drag.slot.y);
                    }
                    if (node.drag.junction) {
                        node.junction.translate(node.drag.junction.x || 0.001, node.drag.junction.y || 0.001);
                    }
                }
            });
        }

        function drop(e) {
            if (drag && drag.node) {
                debug && console.log("Drag drop: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
                e._debug = debug;
                if (drag && drag.target) {
                    debug && console.log("Drag drop to target: " + drag.target.desc);
                    reparent(drag.node, drag.target);
                    // move(e);
                } else {
                    restorePosition(drag.node);
                }

                if (drag) {
                    dragSnapshotClear(drag.node);
                    drag.node.junction && drag.node.junction.show();
                    drag = undefined;
                }
            }
        }

        function reparent(node, parent) {
            if (node.parent === parent) {
                return;
            }

            var i = node.parent.children.indexOf(node);
            node.parent.children.splice(i, 1);
            node.parent = parent;
            parent.children.splice(0, 0, node);
            redraw();
            onReparent(node, parent, 0);
        }

        function drawTree() {
            positionNode(root, 20, 80);
            drawNode(root);
        }

        function redraw() {
            traverse(root, function(node) {
                node.rect = undefined;
                node.slot.destroy();
                node.junction && node.junction.destroy();
            });
            drawTree();
        }

        function onDoubleClick(node) {
            // X3 table are 1 base
            // self.article.externalCall("MAJHIER", ["E", node.i + 1, node.parent && (node.parent.i + 1) || 0, 0, "", -1]);
            self.article.externalCall("MAJHIER", ["E", node.i + 1, 0, 0, "", -1]);
        }

        function onReparent(node, parent, rank) {
            self.article.externalCall("MAJHIER", ["M", node.i + 1, parent.i + 1, rank, "", -1]);
        }

        addEvent(document, END, drop);
        addEvent(container, 'mouseleave', drop);

        drawTree();
    },

    _nodeSlot: function(str, x, y, img) {
        var options = Highcharts.getOptions(),
            colors = options.colors,
            renderer = this.chart.renderer;
        return this._nodeElement(str, x, y, img, null, null).attr({
            // r: 5,
            // y: 30,
            // height: 60,
            fill: orgOptions.node.backgroundColor,
            'stroke-width': orgOptions.node.borderWidth,
            stroke: orgOptions.node.borderColor
        }).css({
            color: orgOptions.node.textColor,
            fontWeight: orgOptions.node.fontWeight,
            'text-align': 'center'
        });
    },

    _nodeElement: function(str, x, y, img) {

        var renderer = this.chart.renderer,
            wrapper = renderer.g("tree"),
            text = renderer.text('', 0, 0, false).attr({
                zIndex: 1
            }),
            image, imgBox, box, bBox, alignFactor = 0,
            padding = 3,
            paddingLeft = 0,
            width, height, wrapperX, wrapperY, crispAdjust = 0,
            deferredAttr = {},
            baselineOffset, attrSetters = wrapper.attrSetters,
            needsBox;

        /**
         * This function runs after this element is added to the DOM (when the bounding box is
         * available), and after the text of the label is updated to detect the new bounding
         * box and reflect it in the border box.
         */

        function updateBoxSize() {
            var boxX, boxY, style = text.element.style;

            bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && text.getBBox();
            if (img) {
                imgBox = {
                    x: padding,
                    y: padding,
                    width: Math.max(bBox.width, 32),
                    height: 32
                };
                bBox.width = imgBox.width;
                bBox.height += imgBox.height + padding;
            }
            wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
            wrapper.height = (height || bBox.height || 0) + 2 * padding;

            // update the label-scoped y offset
            baselineOffset = padding + renderer.fontMetrics(style && style.fontSize).b;

            if (needsBox) {

                // create the border box if it is not already present
                if (!box) {
                    // boxX = mathRound(-alignFactor * padding);
                    boxX = 0;
                    // boxY = baseline ? -baselineOffset : 0;
                    boxY = 0;

                    wrapper.box = box = renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
                    box.add(wrapper);
                }

                // apply the box attributes
                box.attr(merge({
                    width: wrapper.width,
                    height: wrapper.height
                }, deferredAttr));
                deferredAttr = null;
            }
            if (img && !image && (img !== IMAGE_PLACEHOLER)) {
                image = renderer.image(img, imgBox.x, imgBox.y, bBox.width, imgBox.height).attr({
                    preserveAspectRatio: 'xMidYMid'
                }).add(wrapper);
            }
        }

        /**
         * This function runs after setting text or padding, but only if padding is changed
         */

        function updateTextPadding() {
            var styles = wrapper.styles,
                textAlign = styles && styles.textAlign,
                x = paddingLeft + padding * (1 - alignFactor),
                y;

            // determin y based on the baseline
            // y = baseline ? 0 : baselineOffset;
            y = baselineOffset;

            // compensate for alignment
            if (defined(width) && (textAlign === 'center' || textAlign === 'right')) {
                x += {
                    center: 0.5,
                    right: 1
                }[textAlign] * (width - bBox.width);
            }

            if (img) {
                // x += padding;
                y += padding + imgBox.height;
            }

            // update if anything changed
            if (x !== text.x || y !== text.y) {
                text.attr({
                    x: x,
                    y: y
                });
            }

            // record current values
            text.x = x;
            text.y = y;
        }

        /**
         * Set a box attribute, or defer it if the box is not yet created
         * @param {Object} key
         * @param {Object} value
         */

        function boxAttr(key, value) {
            if (box) {
                box.attr(key, value);
            } else {
                deferredAttr[key] = value;
            }
        }

        function getSizeAfterAdd() {
            text.add(wrapper);
            wrapper.attr({
                text: str,
                // alignment is available now
                x: x,
                y: y
            });

            // if (box && defined(anchorX)) {
            //     wrapper.attr({j
            //         anchorX: anchorX,
            //         anchorY: anchorY
            //     });
            // }
        }

        /**
         * After the text element is added, get the desired size of the border box
         * and add it before the text in the DOM.
         */
        addEvent(wrapper, 'add', getSizeAfterAdd);

        /*
         * Add specific attribute setters.
         */

        // only change local variables
        attrSetters.width = function(value) {
            width = value;
            return false;
        };
        attrSetters.height = function(value) {
            height = value;
            return false;
        };
        attrSetters.padding = function(value) {
            if (defined(value) && value !== padding) {
                padding = value;
                updateTextPadding();
            }
            return false;
        };
        attrSetters.paddingLeft = function(value) {
            if (defined(value) && value !== paddingLeft) {
                paddingLeft = value;
                updateTextPadding();
            }
            return false;
        };


        // change local variable and set attribue as well
        attrSetters.align = function(value) {
            alignFactor = {
                left: 0,
                center: 0.5,
                right: 1
            }[value];
            return false; // prevent setting text-anchor on the group
        };

        // apply these to the box and the text alike
        attrSetters.text = function(value, key) {
            text.attr(key, value);
            updateBoxSize();
            updateTextPadding();
            return false;
        };

        // apply these to the box but not to the text
        attrSetters[STROKE_WIDTH] = function(value, key) {
            needsBox = true;
            crispAdjust = value % 2 / 2;
            boxAttr(key, value);
            return false;
        };
        attrSetters.stroke = attrSetters.fill = attrSetters.r = function(value, key) {
            if (key === 'fill') {
                needsBox = true;
            }
            boxAttr(key, value);
            return false;
        };
        // attrSetters.anchorX = function(value, key) {
        //     anchorX = value;
        //     boxAttr(key, value + crispAdjust - wrapperX);
        //     return false;
        // };
        // attrSetters.anchorY = function(value, key) {
        //     anchorY = value;
        //     boxAttr(key, value - wrapperY);
        //     return false;
        // };
        // rename attributes
        attrSetters.x = function(value) {
            wrapper.x = value; // for animation getter
            value -= alignFactor * ((width || bBox.width) + padding);
            wrapperX = mathRound(value);

            wrapper.attr('translateX', wrapperX);
            return false;
        };
        attrSetters.y = function(value) {
            wrapperY = wrapper.y = mathRound(value);
            wrapper.attr('translateY', wrapperY);
            return false;
        };

        // Redirect certain methods to either the box or the text
        var baseCss = wrapper.css;
        return extend(wrapper, {
            /**
             * Pick up some properties and apply them to the text instead of the wrapper
             */
            css: function(styles) {
                if (styles) {
                    var textStyles = {};
                    styles = merge(styles); // create a copy to avoid altering the original object (#537)
                    each(['fontSize', 'fontWeight', 'fontFamily', 'color', 'lineHeight', 'width'], function(prop) {
                        if (styles[prop] !== UNDEFINED) {
                            textStyles[prop] = styles[prop];
                            delete styles[prop];
                        }
                    });
                    text.css(textStyles);
                }
                return baseCss.call(wrapper, styles);
            },
            /**
             * Return the bounding box of the box, not the group
             */
            getBBox: function() {
                return {
                    width: bBox.width + 2 * padding,
                    height: bBox.height + 2 * padding,
                    x: bBox.x - padding,
                    y: bBox.y - padding
                };
            },
            /**
             * Apply the shadow to the box
             */
            shadow: function(b) {
                if (box) {
                    box.shadow(b);
                }
                return wrapper;
            },
            /**
             * Destroy and release memory.
             */
            destroy: function() {
                removeEvent(wrapper, 'add', getSizeAfterAdd);

                // Added by button implementation
                removeEvent(wrapper.element, 'mouseenter');
                removeEvent(wrapper.element, 'mouseleave');

                if (text) {
                    text = text.destroy();
                }
                if (box) {
                    box = box.destroy();
                }
                // Call base implementation to destroy the rest
                HCElement.prototype.destroy.call(wrapper);

                // Release local pointers (#1298)
                wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = getSizeAfterAdd = null;
            }
        });
    },
};