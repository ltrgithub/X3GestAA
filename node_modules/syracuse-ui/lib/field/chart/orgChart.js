"use strict";
var helpers = require('syracuse-core/lib/helpers');
var datetime = require('syracuse-core/lib/types/datetime');
var ChartArticle = require("./chartArticle").ChartArticle;
var TabularChartRecord = require('./tabularChartRecord').TabularChartRecord;
var syraUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Syra;

require('syracuse-ui/deps/highcharts/highcharts.src');
require('syracuse-ui/deps/highcharts/highcharts-more.src');
require('syracuse-ui/deps/highcharts/modules/exporting.src');

// TODO: manage $boxSize and $style
Highcharts.theme = require('syracuse-ui/themes/desktop/sage/highcharts/theme').theme;
var debug = false;
Highcharts.setOptions(Highcharts.theme);
var forEachKey = helpers.object.forEachKey,
	objectCopy = helpers.object.copy,
	objectClone = helpers.object.clone,
	stringify = helpers.object.stringify;

var merge = Highcharts.merge,
	extend = Highcharts.extend,
	each = Highcharts.each,
	addEvent = Highcharts.addEvent,
	removeEvent = Highcharts.removeEvent,
	HCElement = Highcharts.SVGElement,
	mathRound = Math.round,
	STROKE_WIDTH = 'stroke-width',
	IMAGE_PLACEHOLER = "$placeholder",
	UNDEFINED;

var _formatApi = require('syracuse-ui/lib/field/formatApi');
var INTERACT_DESC = {
	"spgm": "AMAJHIER:MAJHIER",
	"params": [{
		"dim": 1,
		"typ": "STRU",
		"siz": 1
	}, {
		"dim": 1,
		"typ": "INT",
		"siz": 0
	}, {
		"dim": 1,
		"typ": "INT",
		"siz": 0
	}, {
		"dim": 1,
		"typ": "INT",
		"siz": 0
	}, {
		"dim": 1,
		"typ": "STRU",
		"siz": 100
	}, {
		"dim": 1,
		"typ": "INT",
		"siz": 0
	}]
};

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== UNDEFINED && obj !== null;
}

function OrgChart() {}

exports.OrgChart = helpers.defineClass(OrgChart, ChartArticle, {
	resizeChart: function() {
		//this.displayed = this.displayed || (this.layoutSlot.clientWidth !== 0);
		this.displayed = true;
		if (this.displayed && !this._chart) {
			// defer chart creation when we are ready to display
			this._createChart();
		}
		if (this._chart && this._chart.container) {
			var self = this;
			if (this.resizeTimer)
				clearTimeout(this.resizeTimer);
			this.resizeTimer = setTimeout(function() {
				debug && self._chart && console.log("OrgChart.resizeTimer " + self.id + ": About to resize - chart.isResizing=" + (self._chart && self._chart.isResizing) + " , size=(" + self.layoutSlot.clientWidth + ", " + self.layoutSlot.clientHeight + "), css-size=(" + self.layoutSlot.style.clientWidth + ", " + self.layoutSlot.style.clientHeight + ")");
				debug && self._chart && console.log("    ... display=" + self.layoutSlot.style.display);

				if (self._chart && self._chart.container && !self._chart.isResizing) {
					if (self.layoutSlot.clientWidth) {
						// width minus 1 because of scrollbar issue on firefox
						var size = {
							width: Math.max(self.orgWidget.size.width, self.layoutSlot.clientWidth) - 1,
							height: self.orgWidget.size.height || self.layoutSlot.style.clientHeight || self.layoutSlot.clientHeight
						};
						debug && self._chart && console.log("OrgChart.resizeTimer " + self.id + ": setSize(" + size.width + "," + size.height + ")");
						self._chart.setSize(size.width, size.height);
						self._redraw();
					}
				}
			}, 200);
		}
	},

	__applyDesignMetaData: function(metadata, designing) {},

	__drawBox: function() {
		this.dataset = null;
		this.$authoringType = "orgview$highCharts";
		this.$localization = this.articleParent.$prototype.$localization;
		// debug && console.log("HighCharts.drawBox " + this.id);
		// var proto = this.$prototype;
		// proto.$allowMove = false;
		// proto.$allowDoubleClick = false;
		// proto.$interact = "ZMAJHIER";
		// proto.$boxSize = "60,120";
		// proto.$boxSize = "60,120,30";
		// proto.$style = 'text-align:center;margin-left:0px;font-size:8pt;white-space:nowrap;'
		if (!this.$item.$isListEmbeded) {
			this.articleParent.bind(this, this.$item.$bind);
		}
	},

	__setDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		var self = this;
		// debug && console.log("OrgChart.setDataBind " + this.id + ": dataset=" + (this.dataset && this.dataset.length) + "\n" + stringify(this.dataset));
		debug && console.log("OrgChart.setDataBind " + this.id + ": dataset=" + (this.dataset && this.dataset.length) + " , size=(" + this.layoutSlot.clientWidth + ", " + this.layoutSlot.clientHeight + ")");

		var settings;
		if (this.dataset) {
			if (this._chart) {
				this.displayed = this.layoutSlot.clientWidth !== 0;
			}
			if (this.displayed) {
				this._createChart();
			}
			settings = {};
		}
	},

	__preSetDataBind: function(dataRecordSet, parentDataRecord, metaData) {
		// optimization: do not recreate the chart in that case
		return true //Does not work when deleting a leaf !(parentDataRecord && parentDataRecord.$isPartialDelta);  ;
	},

	externalCall: function(proxy, values, opt) {
		var self = this,
			callDesc;

		function _resultCallback(res) {
			var err = !res ? [{
				message: "No result",
				severity: "error"
			}] : res.$diagnoses || null;

			err &&
				syra_site.showDiagnoses({
					$diagnoses: err
				});

		}

		if (typeof proxy === 'object') {
			callDesc = proxy;
			proxy = undefined;
		}
		if (this.page && this.page.externalAdapter && this.page.externalAdapter.onBlockExRpc) {
			this.page.externalAdapter.onBlockExRpc({
				field: self.attachedField,
				call: {
					proxy: proxy,
					callDesc: callDesc,
					values: values,
					callback: opt && opt.callback || _resultCallback
				}
			});
		}
	},

	_buildTree: function(dataset) {
		this._buildTreeBase(dataset);
		var root = ((this.head || {}).children || [])[0];
		root && root.parent && delete root.parent;


		if (root) _normalizeNode(root, 0); // in some case root is null ??? must be investigated to know why
	},

	_buildTreeBase: function(dataset) {
		var $fusionController = syraUtil.getFusionController(this),
			imageBaseUrl = null,
			$bindings = this.$prototype.$decorator.$bindings,
			binds = Object.keys($bindings).map(function(k) {
				return $bindings[k];
			});
		if ($fusionController) {
			imageBaseUrl = this.page.openerUrlSegments.uri && this.page.openerUrlSegments.uri.replace(/\$sessions/, '$files') + "/RES/";
		} else {
			// imageBaseUrl = "/syracuse-ui/themes/desktop/sage/highcharts/";
		}

		// the root node
		var parent, node, parentId, idx, parentMap = {};
		// First create a map with potential valid parent
		parentMap[""] = this.head;
		dataset.forEach(function(e, i, a) {
			var id = e[$bindings.$parent];
			if (id && !parentMap[id]) {
				parentMap[id] = {
					children: [],
					id: id
				};
			}
		});

		dataset.forEach(function(e, i, a) {
			// WARNING: id can be a duplicate key
			var id = e[$bindings.$clientId];

			if (id) {
				var data = $bindings.$data &&
					$bindings.$data.map(function($bind) {
						return e[$bind];
					}) || [];

				parentId = e[$bindings.$parent];
				parent = parentMap[parentId];

				node = parentMap[id] || {};
				node.children = node.children || [];
				node.id = node.id || id;
				node.i = node.i || i;
				node.parentId = parentId;

				debug && console.log("OrgChart._buildTreeBase: [" + node.i + "] id=" + node.id + ", parentId=" + parentId + ", desc=" + ($bindings.$title ? e[$bindings.$title] : ""));

				if (!node.parent) {
					node.parent = parent;
					node.desc = ($bindings.$title ? e[$bindings.$title] : "") + ((data.length && $bindings.$title) ? "<br/>" : "") + data.join(" ");
					node.tooltipDesc = e[$bindings.$description];
					// '<span style="font-size: 9pt; font-style:italic;">' + e[$bindings.$description] + '</span>';
					var image = e[$bindings.$image];
					node.image = image && imageBaseUrl && (imageBaseUrl + image);
					node.values = [];
					Object.keys(e).forEach(function(k) {
						if (k.charAt(0) != "$" && binds.indexOf(k) == -1) {
							node.values.push(e[k]);
						}
					});
				}
				parent.children.push(node);
			} else
			if (debug) {
				console.log("OrgChart._buildTreeBase: [" + i + "] id=<null>");
			}
		});
	},

	_clearTree: function() {
		_clearNode(this.head);
		this.head = {
			children: []
		};
	},

	_createChart: function(settings) {
		this._clearTree();
		if (this.dataset && this.dataset.length > 0) {
			this._buildTree(this.dataset);
		}
		var root = ((this.head || {}).children || [])[0];
		if (!root) {
			return;
		}
		if (this.orgWidget)
			delete this.orgWidget;

		// add scrolls
		this.layoutSlot.style.overflow = "auto";

		var self = this, // options = merge(self._getPref(), self._getOptions(self.$prototype));
			options = {
				chart: {
					renderTo: self.layoutSlot,
					events: {
						load: function() {
							debug && console.log("OrgChart.chart.events.load");
							self.orgWidget = new OrgChartWidget(self, this);
							self.orgWidget.draw(root);
						},
						redraw: function() {
							debug && console.log("OrgChart.chart.events.redraw");
							self.orgWidget.redraw();
						}
					},
					spacingTop: 15,
					marginTop: 0
				},
				title: {
					text: ''
				},
				navigation: {
					buttonOptions: {
						align: "left"
					}
				}
			};

		// For Highcharts 3.0.x
		options.exporting = {
			type: 'image/png',
			// url: 'http://export.highcharts.com/',
			buttons: {
				contextButton: {
					symbol: 'menu',
					_titleKey: 'contextButtonTitle',
					menuItems: [{
						text: 'Print chart',
						onclick: function() {
							this.print(self);
						}
					}]
				}
			}
		};

		self._chart = new Highcharts.Chart(options);
	},

	_redraw: function() {
		this._chart && this._chart.redraw();
	},

	_getFieldEvalTitle: function() {
		return this.page.externalAdapter.getFieldEvalTitle(this) || [];
	},

	// --------------------------------------------------------------------------------
	// Event management
	// --------------------------------------------------------------------------------
	_onMeasureClick: function(context) {},

	__dispose: function() {
		this._chart && this._chart.renderer.destroy();
		this._chart = null;
	},
});

// For interaction with X3 the following subprog from AMAJHIER is used
// Subprog MAJHIER(CODACT,NLI,FATHVAL,RANGNIV,MESSAGE,CODRET)
// #     CODACT  : Action code
// #           D : Delete
// #           M : Modify
// #           E : Click on a leaf element
// #     NLI     : Line number of the element (1..n)
// #     FATHVAL : Line number of the parent element (1..n)
// #     RANGNIV : Where to move
// #           0 : As a child of the target
// #          -1 : As a sibling before the target
// #           1 : As a sibling after the target
// #     MESSAGE : Message
// #     CODRET  : Return status: 1 if OK
//
// changing parent ==> AMAJHIER.MAJHIER("M", node, parent, RANGNIV=(-1 or 1) when ?, "", -1)
// double-click ==> AMAJHIER.MAJHIER("E",node,"", 0, "", -1)
//
// MODHIE => !$allowMove
// EXECFL => $allowDoubleClick
// PINTER => $interact
// SIZEB  => $boxSize
//        Format : H,W or H,W,S
//             H : Height in pixel
//             W : Width in pixel
//             S : Text height in pixel, defauly is 20px
// styles => $style
var options = Highcharts.getOptions(),
	colors = options.colors,
	orgOptions = options.orgChart,
	reparenter = {
		left: function(node, target) {
			return this.sibling(node, target, 0, -1);
		},
		right: function(node, target) {
			return this.sibling(node, target, 1, 1);
		},
		sibling: function(node, target, n, r) {
			if (!target.parent) {
				return null;
			}
			var i = node.parent.children.indexOf(node),
				parent = target.parent;
			node.parent.children.splice(i, 1);
			node.parent = parent;
			i = parent.children.indexOf(target);
			parent.children.splice(i + n, 0, node);
			return r;
		},
		bottom: function(node, target) {
			if (node.parent === target) {
				return null;
			}
			var i = node.parent.children.indexOf(node);
			node.parent.children.splice(i, 1);
			node.parent = target;
			target.children.splice(0, 0, node);
			return 0;
		}
	};

var minHeight = 50,
	minWidth = 50,
	chartSpacingLeft = 45,
	chartSpacingTop = 45;

function OrgChartWidget(article, chart) {
	this.article = article;
	this.chart = chart;
	this.useHtml = false;
	this.scaleX = 1.0;
	this.scaleY = 1.0;
	this.xMax = 0;
	this.yMax = 0;
}

OrgChartWidget.prototype = {
	// see http://jsfiddle.net/7UsbM/7/ for drag'n drop
	draw: function(root) {
		var self = this,
			chart = this.chart,
			renderer = chart.renderer,
			options = chart.options,
			$prototype = self.article.$prototype,
			$decorator = $prototype.$decorator,
			$allowDoubleClick = ($decorator.$allowDoubleClick !== false),
			$allowMove = ($decorator.$allowMove !== false),
			$boxSize = $decorator.$boxSize,
			$style = $decorator.$style;

		var bbox = null,
			tree = renderer.g("tree").attr({
				scaleX: this.scaleX,
				scaleY: this.scaleY
			}).add(),
			dropMarker = renderer.rect(-999, -999, 10, 10).attr({
				'stroke-width': orgOptions.dropMarker.borderWidth,
				stroke: orgOptions.dropMarker.borderColor,
				fill: orgOptions.dropMarker.backgroundColor,
				'fill-opacity': orgOptions.dropMarker.backgroundOpacity
			}).add(tree),
			workerNoImage = self._nodeSlot("", -999, -999).add(tree),
			worker = self._nodeSlot("", -999, -999, IMAGE_PLACEHOLER).add(tree), // create the label
			tooltip = renderer.label('', 0, 0, null, null, null, true, null, 'tooltip').attr({
				// padding: padding,
				fill: orgOptions.tooltip.backgroundColor,
				'fill-opacity': orgOptions.tooltip.backgroundOpacity,
				stroke: orgOptions.tooltip.borderColor,
				'stroke-width': orgOptions.tooltip.borderWidth,
				r: orgOptions.tooltip.borderRadius,
				zIndex: 8
			}).css(orgOptions.tooltip.style).hide().add(tree);

		var hasTouch = 'ontouchstart' in window,
			START = 'mousedown',
			MOVE = 'mousemove',
			END = 'mouseup';

		if (hasTouch) {
			START = 'touchstart';
			MOVE = 'touchmove';
			END = 'touchend';
		}

		var interactDesc = objectClone(INTERACT_DESC, true);
		interactDesc.spgm = ($decorator.$interact || "AMAJHIER") + ":MAJHIER";

		function normalizeEvent(e) {
			var props = ['clientX', 'clientY', 'pageX', 'pageY'],
				i, l, n;

			if (['touchstart', 'touchmove', 'touchend'].indexOf(e.type) > -1) {
				for (i = 0, l = props.length; i < l; i++) {
					n = props[i];
					e[n] = e.originalEvent.targetTouches[0][n];
				}
			}

			return e;
		}

		function positionNode(node, left, top) {
			var x = 0,
				y = 0,
				vGap = 10,
				hGap = 10,
				cw = 0;

			node.rect = node.rect || {};
			bbox = (node.image ? worker : workerNoImage).attr({
				text: node.desc,
				// image: node.image
			}).getBBox();
			node.rect.width = Math.max(Math.ceil(bbox.width), minWidth);
			node.rect.height = Math.ceil(bbox.height);
			debug && console.log("Start OrgChart.positionNode: " + node.desc + "@" + node.id + ", left=" + left + ", top=" + top + " (" + node.rect.x + "," + node.rect.y + "," + node.rect.width + "," + node.rect.height + ")");
			// node.rect.height = node.rect.height || minHeight;
			// node.rect.width = node.rect.width || minWidth;
			if (node.children.length > 0) {
				x = left;
				// the top coordinate of children
				y = top + node.rect.height + vGap;
				node.children.forEach(function(child) {
					cw = positionNode(child, x, y);
					// the left coordinate of the next child
					x += cw + hGap;
					debug && console.log("--> cw=" + cw + ", x=" + x + ", y=" + y);
				});
				// center Node between Left and(x - GapH) with top coordinate at Top
				node.rect.x = Math.abs(left + (x - hGap) - node.rect.width) / 2;
				node.rect.y = top;
				self.xMax = Math.max(self.xMax || 0, node.rect.x + node.rect.width);
				self.yMax = Math.max(self.yMax || 0, node.rect.y + node.rect.height);
				debug && console.log("End OrgChart.positionNode: " + node.desc + "@" + node.id + "(" + node.rect.x + "," + node.rect.y + ")" + "(" + (node.rect.x + node.rect.width) + "," + (node.rect.y + node.rect.height) + ")");
				// width of tree rooted at Node
				return Math.max(node.rect.width, x - hGap - left);
			} else {
				// position Node with top-left coordinate at (Left, Top)
				node.rect.x = left;
				node.rect.y = top;
				self.xMax = Math.max(self.xMax || 0, node.rect.x + node.rect.width);
				self.yMax = Math.max(self.yMax || 0, node.rect.y + node.rect.height);
				debug && console.log("End OrgChart.positionNode: " + node.desc + "@" + node.id + "(" + node.rect.x + "," + node.rect.y + ")" + "(" + (node.rect.x + node.rect.width) + "," + (node.rect.y + node.rect.height) + ")");
				return node.rect.width;
			}
		}

		function showDropMarker(node, dropHint) {
			var x = node.slot.x,
				y = node.slot.y,
				w = node.slot.width,
				h = node.slot.height,
				size = 5,
				margin = 2;
			switch (dropHint) {
				case "left":
					x -= (size + margin);
					w = size;
					break;
				case "right":
					x += w + margin;
					w = size;
					break;
				case "bottom":
					y += h + margin;
					h = size;
					break;
			}
			dropMarker.toFront().attr({
				x: x,
				y: y,
				width: w,
				height: h
			}).show();
		}

		function hideDropMarker() {
			dropMarker.hide();
			if (drag)
				delete drag.dropHint;
			tooltip.hide();
		}

		function drawNode(node, parent) {
			parent = parent || node.parent;
			var rect = node.rect,
				pRect = parent ? parent.rect : rect;

			if (debug && !pRect) {
				console.log("no pRect for " + node.desc + "@" + node.id + "(" + rect.x + "," + rect.y + "," + rect.width + "," + rect.height + ")");
			}
			var p1 = {
				x: rect.x + rect.width / 2,
				y: rect.y
			},
				p2 = {
					x: pRect.x + pRect.width / 2,
					y: pRect.y + pRect.height
				};
			// draw Node into the rectangle
			if (debug) {
				var indent = "";
				for (var p = parent; p; indent += "  ", p = p.parent)
				;
				console.log(indent + node.desc + "@" + node.id + "(" + rect.x + "," + rect.y + "," + rect.width + "," + rect.height + ")");
			}
			if (parent) {
				node.junction && node.junction.destroy();
				node.junction = renderer.path(['M', p1.x, p1.y, 'L', p1.x, (p1.y + p2.y) / 2, 'L', p2.x, (p1.y + p2.y) / 2, 'L', p2.x, p2.y]).attr({
					'stroke-width': orgOptions.junction.lineWidth,
					stroke: orgOptions.junction.lineColor
				}).add(tree);
			}
			node.slot && node.slot.destroy();
			var nodeSlot = node.slot = self._nodeSlot(node.desc, rect.x, rect.y, node.image).add(tree);

			addEvent(nodeSlot.element, 'mouseenter', function(e) {
				debug && console.log("mouseenter: " + node.desc + "@" + node.id + "(" + node.i + ")");
				if (drag && drag.node && drag.node !== node) {
					drag.target = node;
				}
				chart.hoverNode = node;
				showTooltip(e);
				nodeSlot.attr('fill', orgOptions.node.hover.backgroundColor);
				nodeSlot.css({
					color: orgOptions.node.hover.textColor
				});
			});
			addEvent(nodeSlot.element, 'mouseleave', function(e) {
				debug && console.log("mouseleave: " + node.desc + "@" + node.id + "(" + node.i + ")");

				if (drag && drag.target) {
					delete drag.target;
				}
				hideDropMarker();
				tooltip.hide();
				delete chart.hoverNode;
				nodeSlot.attr('fill', orgOptions.node.backgroundColor);
				nodeSlot.css({
					color: orgOptions.node.textColor
				});
			});
			addEvent(nodeSlot.element, 'dblclick', function(e) {
				debug && console.log("dblclick: " + node.desc + "@" + node.id + "(" + node.i + ")");
				onDoubleClick(node);
			});
			// addEvent(nodeSlot.element, 'click', function(e) {
			// 	debug && console.log("click: " + node.desc + "@" + node.id + "(" + node.i + ")");
			// 	setTimeout(function() {
			// 		onClick(node, e);
			// 	}, 100);
			// });
			nodeSlot.on('click', function(e) {
				debug &&
					console.log("click " + node.desc + "@" + node.id + "(" + node.i + "), parent: " + (node.parent ? node.parent.desc : "") + //
						"\nrect: " +
						stringify(rect) + //
						"\nvalues: " +
						node.values.reduce(function(a, b) {
							return a + "," + b;
						}));
				setTimeout(function() {
					onClick(node, e);
				}, 100);
			});

			// draw children
			node.children.forEach(function(child) {
				drawNode(child, node);
			});
		}

		var container = chart.container,
			$container = $(container),
			drag, initDrag = {
				x: 0,
				y: 0
			};;

		function bringToBack(el) {
			el.parentNode.insertBefore(el, worker.element.nextSibling);
		}

		function initStartDrag(e) { //onmousedown
			initDrag = {
				x: e.pageX,
				y: e.pageY
			};
		}

		function startDrag(e) { //move if initdrag
			e = normalizeEvent(e);
			var hoverNode = chart.hoverNode;
			// if (hoverNode && hoverNode.series.options.draggable) {
			if (hoverNode) {
				tooltip.hide();
				drag = {
					node: hoverNode,
					x: e.pageX,
					y: e.pageY
				};
				dragSnapshot(drag.node);
				debug && console.log("Drag start: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
			}
		}

		function dragSnapshot(tree) {
			traverse(tree, function(node) {
				if (!node)
					return;
				bringToBack(node.slot.element);
				node.drag = {
					slot: {
						x: node.slot.translateX,
						y: node.slot.translateY
					}
				};
				if (node.junction) {
					node.drag.junction = {
						x: node.junction.translateX || 0,
						y: node.junction.translateY || 0
					};
				}
			});
		}

		function dragSnapshotClear(tree) {
			traverse(tree, function(node) {
				debug && console.log("Drag clear: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
				node.drag && delete node.drag;
				node.children.forEach(function(child) {
					dragSnapshotClear(child);
				});
			});
		}

		function move(e) {
			if ((initDrag.x || initDrag.y) && ((initDrag.x - e.pageX) || (initDrag.y - e.pageY))) {
				startDrag(e);
				initDrag = {
					x: 0,
					y: 0
				};
			}
			var parentOffset, dropHint, pos;
			e = normalizeEvent(e);
			if (drag && drag.node) {
				var delta = {
					x: e.pageX - drag.x,
					y: e.pageY - drag.y
				};
				if (drag.target) {
					parentOffset = $container.offset();
					//or $(this).offset(); if you really just want the current element's offset
					pos = {
						x: e.pageX - parentOffset.left,
						y: e.pageY - parentOffset.top
					};
					var rect = drag.target.rect;
					if (!drag.target.parent) {
						dropHint = "bottom";
					} else
					if (pos.y > rect.y + rect.height / 2) {
						dropHint = "bottom";
					} else
					if (pos.x < rect.x + rect.width / 2) {
						dropHint = "left";
					} else {
						dropHint = "right";
					}
					if (dropHint !== drag.dropHint) {
						// debug && console.log("Drag move dropHint change :" + drag.dropHint + " to " + dropHint);
						drag.dropHint = dropHint;
						showDropMarker(drag.target, dropHint);
					}
					debug && console.log("Drag move:" + drag.dropHint + ", rect=" + stringify(rect) + ", pos={" + pos.x + "," + pos.y + "}");
				}
				// e._debug && console.log("Drag drop: delta=(" + delta.x + "," + delta.y + "), node=(" + drag.node.drag.slot.x + "," + drag.node.drag.slot.y);
				drag.node.junction && drag.node.junction.hide();
				moveSubtree(drag.node, delta);
			} else
			if (chart.hoverNode) {
				showTooltip(e);
			}
		}

		function showTooltip(e) {
			var hoverNode = chart.hoverNode,
				parentOffset = $container.offset(),
				pos = {
					x: e.pageX - parentOffset.left + 20,
					y: e.pageY - parentOffset.top
				};
			debug && console.log("showTooltip: pos=" + stringify(pos));
			chart.hoverNode.tooltipDesc &&
				tooltip.attr({
					text: chart.hoverNode.tooltipDesc
				}).translate(pos.x, pos.y).show();
		}

		function moveSubtree(tree, delta) {
			traverse(tree, function(node) {
				node.junction && node.drag.junction && node.junction.translate(node.drag.junction.x + delta.x, node.drag.junction.y + delta.y);
				node.slot.translate(node.drag.slot.x + delta.x, node.drag.slot.y + delta.y);
			});
		}

		function restorePosition(tree) {
			debug && console.log("restorePosition: " + tree.desc + "@" + tree.id + "(" + tree.i + ")");
			traverse(tree, function(node) {
				if (node.drag) {
					if (node.drag.slot) {
						node.slot.translate(node.drag.slot.x, node.drag.slot.y);
					}
					if (node.drag.junction) {
						node.junction.translate(node.drag.junction.x || 0.001, node.drag.junction.y || 0.001);
					}
				}
			});
		}

		function drop(e) {
			var dropHint;
			if (drag && drag.node) {
				debug && console.log("Drag drop: " + drag.node.desc + "@" + drag.node.id + "(" + drag.node.i + ") drag=(" + drag.x + "," + drag.y + "), drag.node=(" + drag.node.slot.x + "," + drag.node.slot.y + "), drag.node.translate=(" + drag.node.slot.translateX + "," + drag.node.slot.translateY + ")");
				e._debug = debug;
				if (drag && drag.target) {
					dropHint = drag.dropHint;
					debug && console.log("Drag drop to the " + dropHint + " of target: " + drag.target.desc);
				}
				if (dropHint) {
					reparent(drag.node, drag.target, dropHint);
				} else {
					restorePosition(drag.node);
				}

				if (drag) {
					hideDropMarker();
					dragSnapshotClear(drag.node);
					drag.node.junction && drag.node.junction.show();
					drag = undefined;
				}
			}
		}

		function reparent(node, target, dropHint) {
			var rank = reparenter[dropHint](node, target);
			if (rank === null) {
				restorePosition(node);
				return;
			}

			redraw();
			onReparent(node, target, rank);
		}

		function drawTree() {
			// traverse(root, function(node) {
			// 	for (var p = node.parent, indent = ""; p; indent += "  ", p = p.parent);
			// 	console.log(indent + node.desc + "@" + node.id);
			// });
			positionNode(root, chartSpacingLeft, chartSpacingTop);
			drawNode(root);
			self.size = {
				width: (self.xMax + chartSpacingLeft) * self.scaleX,
				height: (self.yMax + chartSpacingTop) * self.scaleY
			};
			// width minus 1 because of scrollbar issue on firefox
			self.chart.setSize(Math.max(self.article.layoutSlot.clientWidth, self.size.width) - 1, self.size.height);
			self.chart.redraw();
		}

		function redraw() {
			traverse(root, function(node) {
				node.rect = undefined;
				node.slot.destroy();
				node.junction && node.junction.destroy();
			});
			drawTree();
		}

		function interact(args) {
			return self.article.externalCall(interactDesc, args);
		}

		function onClick(node, e) {
			initDrag = {
				x: 0,
				y: 0
			};;
			self.article._openMenu(node.i, e);
		}

		function onDoubleClick(node) {
			// X3 table are 1 base
			// Notify only if on a leaf
			if ($allowDoubleClick && node.children.length === 0) {
				// self.article.externalCall("MAJHIER", ["E", node.i + 1, node.parent && (node.parent.i + 1) || 0, 0, "", -1]);
				interact(["E", node.i + 1, 0, 0, "", -1]);
			}
		}

		function onReparent(node, parent, rank) {
			interact(["M", node.i + 1, parent.i + 1, rank, "", -1]);
		}

		// chart.redraw(); // kill animation (why was this again?)
		if ($allowMove) {
			addEvent(container, START, initStartDrag);
			addEvent(container, MOVE, move);
			addEvent(document, END, drop);
			addEvent(container, 'mouseleave', drop);
		}

		drawTree();
	},

	redraw: function() {
		// debug && console.log("OrgChart.chart.events.redraw");
	},

	_nodeSlot: function(str, x, y, img) {
		return this._nodeElement(str, x, y, img, null, null).attr({
			// r: 5,
			// y: 30,
			// height: 60,
			fill: orgOptions.node.backgroundColor,
			'stroke-width': orgOptions.node.borderWidth,
			stroke: orgOptions.node.borderColor
		}).css({
			color: orgOptions.node.textColor,
			fontSize: '10px',
			fontWeight: orgOptions.node.fontWeight,
			'text-align': 'center'
		});
	},

	_nodeElement: function(str, x, y, img) {
		var renderer = this.chart.renderer,
			wrapper = renderer.g("node"), // text = renderer.text('', 0, 0, true).attr({
			text = renderer.text('', 0, 0, this.useHtml).attr({
				zIndex: 1
			}),
			image, imgBox, box, bBox = {},
			alignFactor = 0,
			padding = 2,
			paddingLeft = 0,
			width, height, wrapperX, wrapperY, crispAdjust = 0,
			deferredAttr = {},
			baselineOffset, attrSetters = wrapper.attrSetters,
			needsBox;

		/**
		 * This function runs after this element is added to the DOM (when the bounding box is
		 * available), and after the text of the label is updated to detect the new bounding
		 * box and reflect it in the border box.
		 */
		function updateBoxSize() {
			var boxX, boxY, style = text.element.style,
				textBBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && text.getBBox();

			bBox.width = width || textBBox.width;
			bBox.height = height || textBBox.height;

			if (img) {
				imgBox = {
					x: padding,
					y: padding,
					width: Math.max(bBox.width, 32),
					height: 32
				};
				bBox.width = imgBox.width;
				bBox.height += imgBox.height + padding;
			}
			wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
			wrapper.height = (height || bBox.height || 0) + 2 * padding;

			// update the label-scoped y offset
			baselineOffset = padding + renderer.fontMetrics(style && style.fontSize).b;

			if (needsBox) {

				// create the border box if it is not already present
				if (!box) {
					// boxX = mathRound(-alignFactor * padding);
					boxX = 0;
					// boxY = baseline ? -baselineOffset : 0;
					boxY = 0;

					wrapper.box = box = renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
					box.add(wrapper);
				}

				// apply the box attributes
				box.attr(merge({
					width: wrapper.width,
					height: wrapper.height
				}, deferredAttr));
				deferredAttr = null;
			}
			if (img && !image && (img !== IMAGE_PLACEHOLER)) {
				image = renderer.image(img, imgBox.x, imgBox.y, bBox.width, imgBox.height).attr({
					preserveAspectRatio: 'xMidYMid'
				}).add(wrapper);
			}
		}

		/**
		 * This function runs after setting text or padding, but only if padding is changed
		 */
		function updateTextPadding() {
			var styles = wrapper.styles,
				textAlign = styles && styles.textAlign,
				x = paddingLeft + padding * (1 - alignFactor),
				y;

			// determin y based on the baseline
			// y = baseline ? 0 : baselineOffset;
			y = baselineOffset;

			// compensate for alignment
			if (defined(width) && (textAlign === 'center' || textAlign === 'right')) {
				x += {
					center: 0.5,
					right: 1
				}[textAlign] *
					(width - bBox.width);
			}

			if (img) {
				// x += padding;
				y += padding + imgBox.height;
			}

			// update if anything changed
			if (x !== text.x || y !== text.y) {
				text.attr({
					x: x,
					y: y
				});
			}

			// record current values
			text.x = x;
			text.y = y;
		}

		/**
		 * Set a box attribute, or defer it if the box is not yet created
		 * @param {Object} key
		 * @param {Object} value
		 */
		function boxAttr(key, value) {
			if (box) {
				box.attr(key, value);
			} else {
				deferredAttr[key] = value;
			}
		}

		function getSizeAfterAdd() {
			text.add(wrapper);
			wrapper.attr({
				text: str,
				// alignment is available now
				x: x,
				y: y
			});

			// if (box && defined(anchorX)) {
			//     wrapper.attr({j
			//         anchorX: anchorX,
			//         anchorY: anchorY
			//     });
			// }
		}

		/**
		 * After the text element is added, get the desired size of the border box
		 * and add it before the text in the DOM.
		 */
		addEvent(wrapper, 'add', getSizeAfterAdd);

		/*
		 * Add specific attribute setters.
		 */
		// only change local variables
		attrSetters.width = function(value) {
			width = value;
			return false;
		};
		attrSetters.height = function(value) {
			height = value;
			return false;
		};
		attrSetters.padding = function(value) {
			if (defined(value) && value !== padding) {
				padding = value;
				updateTextPadding();
			}
			return false;
		};
		attrSetters.paddingLeft = function(value) {
			if (defined(value) && value !== paddingLeft) {
				paddingLeft = value;
				updateTextPadding();
			}
			return false;
		};

		// change local variable and set attribue as well
		attrSetters.align = function(value) {
			alignFactor = {
				left: 0,
				center: 0.5,
				right: 1
			}[value];
			return false; // prevent setting text-anchor on the group
		};

		// apply these to the box and the text alike
		attrSetters.text = function(value, key) {
			text.attr(key, value);
			updateBoxSize();
			updateTextPadding();
			return false;
		};

		// apply these to the box but not to the text
		attrSetters[STROKE_WIDTH] = function(value, key) {
			needsBox = true;
			crispAdjust = value % 2 / 2;
			boxAttr(key, value);
			return false;
		};
		attrSetters.stroke = attrSetters.fill = attrSetters.r = function(value, key) {
			if (key === 'fill') {
				needsBox = true;
			}
			boxAttr(key, value);
			return false;
		};
		// attrSetters.anchorX = function(value, key) {
		//     anchorX = value;
		//     boxAttr(key, value + crispAdjust - wrapperX);
		//     return false;
		// };
		// attrSetters.anchorY = function(value, key) {
		//     anchorY = value;
		//     boxAttr(key, value - wrapperY);
		//     return false;
		// };
		// rename attributes
		attrSetters.x = function(value) {
			wrapper.x = value; // for animation getter
			value -= alignFactor * ((width || bBox.width) + padding);
			wrapperX = mathRound(value);

			wrapper.attr('translateX', wrapperX);
			return false;
		};
		attrSetters.y = function(value) {
			wrapperY = wrapper.y = mathRound(value);
			wrapper.attr('translateY', wrapperY);
			return false;
		};

		// Redirect certain methods to either the box or the text
		var baseCss = wrapper.css;
		return extend(wrapper, {
			/**
			 * Pick up some properties and apply them to the text instead of the wrapper
			 */
			css: function(styles) {
				if (styles) {
					var textStyles = {};
					styles = merge(styles); // create a copy to avoid altering the original object (#537)
					each(['fontSize', 'fontWeight', 'fontFamily', 'color', 'lineHeight', 'width'], function(prop) {
						if (styles[prop] !== UNDEFINED) {
							textStyles[prop] = styles[prop];
							delete styles[prop];
						}
					});
					text.css(textStyles);
				}
				return baseCss.call(wrapper, styles);
			},

			/**
			 * Return the bounding box of the box, not the group
			 */
			getBBox: function() {
				return {
					width: bBox.width + 2 * padding,
					height: bBox.height + 2 * padding,
					x: bBox.x - padding,
					y: bBox.y - padding
				};
			},

			/**
			 * Apply the shadow to the box
			 */
			shadow: function(b) {
				if (box) {
					box.shadow(b);
				}
				return wrapper;
			},

			/**
			 * Destroy and release memory.
			 */
			destroy: function() {
				removeEvent(wrapper, 'add', getSizeAfterAdd);

				// Added by button implementation
				removeEvent(wrapper.element, 'mouseenter');
				removeEvent(wrapper.element, 'mouseleave');

				if (text) {
					text = text.destroy();
				}
				if (box) {
					box = box.destroy();
				}
				// Call base implementation to destroy the rest
				HCElement.prototype.destroy.call(wrapper);

				// Release local pointers (#1298)
				wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = getSizeAfterAdd = null;
			}
		});
	}
};

function _normalizeNode(node, i) {
	var children = node.children || [],
		parent = node.parent,
		n;
	if (node.seen) {
		n = {
			children: [],
			id: node.id,
			i: node.i,
			desc: node.desc,
			tooltipDesc: node.tooltipDesc,
			image: node.image,
			values: node.values
		};
		if (parent) {
			parent = parent.seen && parent.seen.n || parent;
			parent.children[i] = n;
			n.parent = parent;
		}
		node.seen.n = n;
	} else {
		node.seen = {};
	}
	children && children.forEach(_normalizeNode);
	delete node.seen.n;
}

function traverse(node, visitor) {
	visitor(node);
	// visit children
	node.children.forEach(function(child) {
		traverse(child, visitor);
	});
}

function _clearNode(node) {
	if (!node) {
		return;
	}
	var children = node.children || [];
	children.forEach(_clearNode);

	delete node.rect;
	node.slot && node.slot.destroy && node.slot.destroy();
	delete node.slot;
	node.junction && node.junction.destroy && node.junction.destroy();
	if (node.children) {
		node.children.length = 0;
	}
	delete node.junction;
	delete node.children;
	delete node.parent;
	delete node.id;
	delete node.parentId;
}