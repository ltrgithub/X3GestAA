"use strict";
/*
 Copyright (c)2011 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Flash X3 components Wrapper
 */

var helpers = require('syracuse-core/lib/helpers');
var _formatApi = require('syracuse-ui/lib/field/formatApi');
var flash = require("./flashHelpers");
var datetime = require('syracuse-core/lib/types/datetime');
var int = require('syracuse-core/lib/types/integer');
var syraUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Syra;
// var clone = helpers.object.clone;
var stringify = helpers.object.stringify,
	forEachKey = helpers.object.forEachKey;
// Misc
var _fixture = false;
var _log = true;
var _debug = true;
var _transparent = false;
var _setEmbed = !$.browser.msie;

// case "fxgetinitialdata" :{this.isFlashOK=true;this.sendData();return true;break}
// case "fxsendctxaction"  :{this.execActionMenu(aArgs);this.busy=false;return true;break}
// case "fxgetctxmenu"     :{var wDom=Gr_setStringToDom(aArgs);this.getStringMenu(wDom);this.busy=false;return true;break}
// case "fxlinktox3"       :{this.ackCallLink(aArgs);this.busy=false;return true;break}
// case "fxspro"           :{this.buildAndSendAckCall(aArgs);this.busy=false;return true;break}
// case "fxhelp"           :{this.help(aArgs);this.busy=false;return true;break} //appel aide X3
// case "fxhelpflash"      :{this.helpInterne(aArgs);this.busy=false;return true;break} //appel  interne flash
// Static method : Flash to JavaScript communication initialization (AS2 technology)
var _initFlash2Js = function(elt, id, callBackFct) {
	if ($.browser.msie) {
		elt.attachEvent('fscommand', callBackFct);
	} else {
		// Warning : unlike IE, event handling doesn't work for others browsers ... so, we need to define an explicit function callback in windows's scope
		window[id + "_DoFSCommand"] = function(command, args) {
			callBackFct(command, args);
		};
	}
};

// Templates
// <param name="wmode" value="transparent"/> \
// wmode="transparent" \
var _templateFlashTag = _.template('<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" align="<%= align %>" \
height="<%= height %>" width="<%= width %>" id="<%= id %>" name="<%= name %>">\
<param name="allowScriptAccess" value="' + ($.browser.msie ? 'always' : 'sameDomain') + '"/>\
<param name="base" value="<%= base %>"/>\
<param name="movie" value="<%= swf %>"/>\
<param name="quality" value="high"/>\
<param name="scale" value="noscale"/>\
<param name="salign" value="lt"/>\
<param name="bgcolor" value="<%= bgcolor %>"/>' + //
	(_transparent ? '<param name="wmode" value="transparent"/>' : '<param name="wmode" value="opaque"/>') + //
	(!_setEmbed ? '' : ('<embed src="<%= swf %>" name="<%= name %>" quality="high" \
scale="noscale" salign="lt" bgcolor="<%= bgcolor %>" base="<%= base %>" \
width="<%= width %>" height="<%= height %>" swLiveConnect="true" id="<%= embedId %>" name="<%= embedId %>" \
align="<%= align %>" allowScriptAccess="sameDomain" type="application/x-shockwave-flash" ' + //
		(_transparent ? 'wmode="transparent"' : 'wmode="opaque"') + //
		' pluginspage="http://get.adobe.com/flashplayer/"/>')) + //
	'</object>');

var _templateTechTag = _.template('<HtcProvType><%= provType %></HtcProvType> \
                    <VisCmp Type="<%= type %>"> \
                        <FGGTYPE><%= measureStyle %></FGGTYPE>   \
                        <FGCVAL><%= measuresList %></FGCVAL>      \
                        <FGCLABEL><%= axis0Name %></FGCLABEL>\
                        <FGCSELC><%= hasMeasureSelector %></FGCSELC>   \
                        <FGCSELG><%= hasStyleSelector %></FGCSELG>   \
                        <FGCDEF><%= defaultMeasures %></FGCDEF>      \
                    </VisCmp> \
                    <UserLang><%= cdLang %></UserLang>');

/* Flash Wrapper class */

function _getComponentType(article) {
	var proto = article.$prototype,
		item = article.$item,
		$decoratorType = proto.$decorator && proto.$decorator.$stereotype;
	if (proto.$cube) return "graph";
	if ($decoratorType) {
		return $decoratorType;
	}
	return item && item.$renderer;
}

function Wrapper(componentType, properties, hosterData, options) {
	var $$layoutSlot;
	// Instance properties initialization
	this.typeInfo = flash.typeInfo(componentType || _getComponentType(hosterData.instance));
	this.props = _.clone(properties);
	this._initProps();
	this.setHostData(hosterData);

	// Options initialization
	this.opts = (options ? _.clone(options) : {});
	_.defaults(this.opts, this.typeInfo.defOpts || {}, {
		"legacyLinks": false,
		"legacyRequest": false,
		"xmlNative": false,
		"dataBinding": "$resources",
		"cdLang": "ENG",
		"iSvcDataSrcId": "@"
	});

	// Default values
	this.provType = "TABLEBLOC";
	this.curCmdCtx = {};
	this.replyPending = false;
	this.pendingData = null;
	this.firstDataDone = false;
	this.fxInitialDataPending = false;
	this.currentData = this.opts.xmlNative ? "" : {};

	// Bind asynchronous callback to "this"
	_.bindAll(this, "fxOnError", "fxOnDummy", "fxOnGetdataDone", "fxOnGetCtxMenuDone", "fxOnDrillDone", "fxOnStdSvcDone", "fxOnNamedSvcDone", "_dispatchFxCommand");

	// Build markup
	this.id = this.props.id;
	if (_setEmbed) {
		this.props.id = this.props.embedId + this.props.id;
		this.props.embedId = this.id;
	}
	this.props.name = this.id;
	this.$$elt = $(_templateFlashTag(this.props));
	this.elt = !_setEmbed ? this.$$elt.get(0) : this.$$elt.find("embed").get(0);

	// Perform Flash->Javascript communication initialization
	_initFlash2Js(this.elt, this.id, this._dispatchFxCommand);

	// Finally, append Flash element to the container
	this.$$elt.appendTo(this.$$cont);

	// Fix size
	if (this.opts._height && this.hosterData.instance && ($$layoutSlot = $(this.hosterData.instance.layoutSlot))) {
		$$layoutSlot.height(this.opts._height);
	}
}

/* Helpers methods */
Wrapper.prototype._getDimensions = function() {
	var dim = {};
	try {
		dim.width = this.elt.TGetProperty("/", 8);
		dim.height = this.elt.TGetProperty("/", 9);
	} catch (e) {
		dim = null;
	} finally {
		return dim;
	}
};

/* Core methods */
// Asynchronous interactions common stub (flash commands handler)
Wrapper.prototype._dispatchFxCommand = function(command, args) {
	// Busy... bye, bye! For the future : implement an interaction stack (asynchronous compliant)...
	if (this._isReplyPending(args)) {
		return false;
	}
	this.replyPending = true;

	// Parse arguments
	var wTokenInter = command.split("_");
	this.curCmdCtx = {
		"_cmd": command,
		"_id": wTokenInter[0],
		"_args": args,
		"_opt": (wTokenInter.length > 1 ? wTokenInter.slice(1).join("_") : null)
	};

	// Process command
	this._trace("inf", "Process command '" + command + "' with args [" + args + "]");

	var adapter = this.hosterData.instance && this.hosterData.instance.page && this.hosterData.instance.page.externalAdapter;
	var doIt = true;
	if (adapter && adapter.onFLashCommand) {
		doIt = adapter.onFLashCommand({
			field: this.hosterData.instance,
			context: this.curCmdCtx
		});
	}
	if (doIt) {
		this[this.curCmdCtx._id] ? this[this.curCmdCtx._id]() : this.fxnamedsvccall();
	}
};

// Answer to asynchronous flash command
Wrapper.prototype._answerFxCommand = function(answerObj, preserveNL) {
	this._populateFxData(answerObj, this.curCmdCtx._cmd, preserveNL);
	this.replyPending = false;
	this.curCmdCtx._cmd = null;
};

// Populate data to flash
Wrapper.prototype._populateFxData = function(dataObj, command, preserveNL) {
	var res = "xflashreqcode==" + command,
		excpt;
	_.each(dataObj, function(value, key) {
		if (value) {
			res += "&&" + key + "==" + (!preserveNL && _.isString(value) ? this._killNL(value) : value);
		}
	}, this);
	try {
		this.elt.SetVariable("/_root/xstatic1:ganswer", res);
		this.elt.TCallLabel("/_root/xstatic1", "lblrecall");
	} catch (ex) {
		if (this.hosterData.instance && this.hosterData.instance.showDiagnoses) {
			//excpt = this.hosterData.instance.showDiagnoses(ex);
		}
		if (!excpt) {
			//alert("Error during populate Flash data : " + ex.message);
		}
	}
};

// Wrap data reply in an object
Wrapper.prototype._wrapFxDataInObj = function(data) {
	return {
		"xdata": data
	};
};

// Is reply pending?
Wrapper.prototype._isReplyPending = function(data) {
	if (!this.replyPending) {
		return false;
	} else {
		this._trace("wrn", "Reply pending (request '" + this.curCmdCtx._id + "'" + (data ? (" - with args : '" + data + "'") : "") + "), can't accept Flash command!");
		return true;
	}
};

// Asynchronous interactions stub
Wrapper.prototype.trapallkeys = function() {
	/**
	 * Scope                        : All components
	 * Input (this.curCmdCtx._args) : Boolean
	 * Asynchronous reply           : dummy
	 */
	this._answerFxCommand(this._wrapFxDataInObj(""));
};

Wrapper.prototype.fxgetinitialdata = function() {
	/**
	 * Scope                        : All components
	 * Input (this.curCmdCtx._args) : -
	 * Asynchronous reply           : data...
	 * Remark                       : If data are pending, direct reply. Else, send request to host
	 */
	if (!this.hosterData.instance.fxgetinitialdata) {
		this.fxOnError({
			"$message": "TO TRANSLATE - Hoster interface is not implemented : '" + this.curCmdCtx._args + "'",
			"$severity": "error"
		});
		return;
	}
	this.fxInitialDataPending = true;
	if (this.pendingData) {
		if (!this.opts.xmlNative && !this.pendingData.meta && _.isArray(this.pendingData.data)) {
			this.hosterData.instance.fxgetinitialdata(this.fxOnGetdataDone, this.hosterData);
		} else {
			this.fxOnGetdataDone(null, null, null);
		}
	} else {
		this.hosterData.instance.fxgetinitialdata(this.fxOnGetdataDone, this.hosterData);
	}
};

Wrapper.prototype.fxgetctxmenu = function() {
	/**
	 * Scope                        : Graph with "Grid" datasource
	 * Input (this.curCmdCtx._args) : "<MNR C='1' L='2' UUID='d3e97372-21c1-40ac-e'/>" ==> C=Click number, L=Line, UUID ==> Unique Id
	 * Asynchronous reply           : Menus desc for the lineor
	 */
	var links, $$xmlArgs = $($.parseXML(this.curCmdCtx._args)),
		$$mmrNode, line, uuid;
	if ($$xmlArgs) {
		$$mmrNode = $$xmlArgs.find("MNR");
		line = parseInt($$mmrNode.attr("L"), 10);
		this.curCmdCtx.countAttr = $$mmrNode.attr("C");
		uuid = $$mmrNode.attr("UUID") || line.toString();
		links = this._getLinksFromCurrData();
		if (this.opts.legacyLinks || !links || this.currentData.$links.$lazyload) {
			if (this.hosterData.instance.fxgetctxmenu) {
				this.hosterData.instance.fxgetctxmenu(this.fxOnGetCtxMenuDone, this.hosterData, (this.opts.legacyLinks ? null : uuid), (this.opts.legacyLinks ? line : null));
			} else {
				this.fxOnError({
					"$message": "TO TRANSLATE - Hoster interface is not implemented : '" + this.curCmdCtx._args + "'",
					"$severity": "error"
				});
			}
		} else if (links) {
			// We use the links defined in the current prototype...
			var mnuDesc = [];
			_.each(links, function(link, idx) {
				mnuDesc[mnuDesc.length] = {
					"$title": link.title,
					"linkId": this._getCanonicalLink(line, idx)
				};
			}, this);
			this.fxOnGetCtxMenuDone(null, mnuDesc);
		}
	} else {
		this.fxOnError({
			"$message": "TO TRANSLATE - Malformed request : '" + this.curCmdCtx._args + "'",
			"$severity": "error"
		});
	}
};

Wrapper.prototype.fxsendctxaction = function(options) {
	/**
	 * Scope                        : All components
	 * Input (this.curCmdCtx._args) : "14214" ==> "actionId"
	 * Asynchronous reply           : Nothing - command without reply... so we swicth the "pending" flag here
	 */
	this.replyPending = false;
	var link = this._getLinkObjFromCanonical(this.curCmdCtx._args);
	if (this.hosterData.instance.fxexeclink) {
		this.hosterData.instance.fxexeclink(this.fxOnDummy, this.hosterData, this._getLinkObj(link), options);
	}
};

Wrapper.prototype.fxlinktox3 = function() {
	/**
	 * Scope                        : All components
	 * Input (this.curCmdCtx._args) : "12074,OBJ=TCY&CLES=IT" ==> "Link_Id,Ctx"
	 * Asynchronous reply           : Nothing - command without reply... so we swicth the "pending" flag here
	 */
	this.fxsendctxaction({
		legacy: true
	});
};

Wrapper.prototype.fxhelpflash = function() {
	/**
	 * Scope                        : All components
	 * Input (this.curCmdCtx._args) : Flash Help sub Path
	 * Asynchronous reply           : Nothing - command without reply... so we swicth the "pending" flag here
	 */
	if (this.hosterData.instance.fxhelpflash) {
		this.hosterData.instance.fxhelpflash(this.fxOnDummy, this.hosterData, {
			"key": this.curCmdCtx._args
		});
	}
	this.replyPending = false;
};

Wrapper.prototype.fxhelp = function() {
	/**
	 * Scope                        : All components
	 * Input (this.curCmdCtx._args) : "xhfield,ABATPAR" ==> "type,token" # type [xhfield,xhffunc,???,... ]
	 * Asynchronous reply           : Nothing - command without reply... so we swicth the "pending" flag here
	 */
	var tokens = this.curCmdCtx._args.split(",");
	if (tokens && tokens.length > 0) {
		if (this.hosterData.instance.fxhelp) {
			this.hosterData.instance.fxhelp(this.fxOnDummy, this.hosterData, {
				"type": tokens[0],
				"key": (tokens.length > 1 ? tokens[1] : "")
			});
		}
	}
	this.replyPending = false;
};

Wrapper.prototype.fxspro = function() {
	/**
	 * Scope                        : All components
	 * Input (this.curCmdCtx._args) : "<INTERFL><TYPFL>typeflash</TYPFL><TYPINTER>svcId</TYPINTER><CODE>LVTEST03</CODE></INTERFL>" ==> "flash_type", "svc_type", "ctx"
	 * Asynchronous reply           : Service reply
	 */
	var request = null;
	if (this.opts.legacyRequest) {
		request = this.curCmdCtx._args;
	} else {
		var $$fxDom = $($.parseXML(this.curCmdCtx._args));
		if ($$fxDom) {
			var $$svcId = $$fxDom.find("TYPINTER"),
				$$fxType = $$fxDom.find("TYPFL");
			request = {
				"svcId": $$svcId.text(),
				"fxType": $$fxType.text(),
				"svcData": {
					"id": "INTERFL",
					"attrs": {}
				}
			};
			$$svcId.remove();
			$$fxType.remove();
			$$fxDom.find("INTERFL").children().each(function() {
				var $$elt = $(this);
				request.svcData.attrs[$$elt.prop("nodeName")] = $$elt.text();
			});
		}
	}
	if (request && this.hosterData.instance.fxspro) {
		this.hosterData.instance.fxspro(this.fxOnStdSvcDone, this.hosterData, request);
	} else {
		this.fxOnError({
			"$message": request ? "TO TRANSLATE - Hoster interface is not implemented'" : "TO TRANSLATE - Malformed request : '" + this.curCmdCtx._args + "'",
			"$severity": "error"
		});
	}
};

Wrapper.prototype.fxgetprevstatlevel = function() {
	/**
	 * Scope                        : Graph
	 * Input (this.curCmdCtx._args) : XML string, like "<tagname attr_name='attr_value'  attr_name='attr_value'/>"
	 * Asynchronous reply           : Service reply
	 * Remark                       : For X3 legacy, service request has just a string parameter : "idData,attr_name=attr_value[,...]";
	 *                                "iData" is the datasource name (metadata of the component)
	 */
	this._fxprocessdrill(this.curCmdCtx._args, "out");
};

Wrapper.prototype.fxgetnextstatlevel = function() {
	/**
	 * Scope                        : Graph
	 * Input (this.curCmdCtx._args) : XML string, like "<tagname attr_name='attr_value'  attr_name='attr_value'/>"
	 * Asynchronous reply           : Service reply
	 * Remark                       : For X3 legacy, service request has just a string parameter : "idData,attr_name=attr_value[,...]";
	 *                                "iData" is the datasource name (metadata of the component)
	 */
	this._fxprocessdrill(this.curCmdCtx._args, "in");
};

Wrapper.prototype._fxprocessdrill = function(fxcmd, zoomWhat) {
	var drillParams = this._getfxDrillParams(fxcmd);
	var i = this.currentData._drillDef.currAxisHier;
	var hier = this.currentData.$axes[0].$hierarchies,
		idxHier;
	var mem = this.currentData.$axes[0].$members;
	if (zoomWhat == "out") {
		if (hier[i][2] > 0) {
			hier[i][2]--;
			idxHier = i;
		} else {
			hier[i][1] = 0;
			hier[i][2] = 0;
			hier[i - 1][1] = 1;
			hier[i - 1][2] = this.currentData.$cube.$hierarchies[hier[i - 1][0]].$properties.length - 1;
			idxHier = i - 1;
		}
		if (mem[idxHier].length > 1) {
			mem[idxHier].pop(mem[idxHier].length - 1);
		} else {
			mem.pop(idxHier);
		}
	} else {
		if (hier[i][2] == (this.currentData.$cube.$hierarchies[hier[i][0]].$properties.length - 1)) {
			hier[i][1] = 0;
			hier[i][2] = 0;
			hier[i + 1][1] = 1;
			hier[i + 1][2] = 0;
			idxHier = i;
		} else {
			hier[i][2]++;
			idxHier = i;
		}
		if (!mem) {
			mem = this.currentData.$axes[0].$members = [
				[]
			];
		}
		if (mem.length < idxHier + 1) {
			mem[idxHier] = [];
		}
		mem[idxHier].push(new Array(drillParams ? drillParams.drillData.memberValue : "???"));
	}

	if (this.hosterData.instance.fxexecdrill) {
		this.hosterData.instance.fxexecdrill(this.fxOnDrillDone, this.hosterData, this.currentData);
	} else {
		this.fxOnError({
			"$message": "TO TRANSLATE - Hoster interface is not implemented'" + this.curCmdCtx._args + "'",
			"$severity": "error"
		});
	}
	this.replyPending = false;

};

Wrapper.prototype._getfxDrillParams = function(fxcmd) {
	var $$fxDom = $.parseXML(fxcmd),
		drillParams = null,
		critMax = 0,
		kCrit = "criterion",
		test;
	if ($$fxDom) {
		if (!this.opts.legacyRequest) {
			drillParams = {
				"svcId": this.curCmdCtx._id,
				"drillData": {
					"id": $$fxDom.documentElement.nodeName,
					"attrs": {}
				}
			};
			_.each($$fxDom.documentElement.attributes, function(attr) {
				this.attrs[attr.name] = attr.value;
				if (attr.name.substr(0, kCrit.length).toLocaleLowerCase() === kCrit) {
					test = parseInt(attr.name.substr(kCrit.length), 10);
					if (test > critMax) {
						critMax = test;
						this.memberValue = attr.value;
					}
				}
			}, drillParams.drillData);
		} else {
			drillParams = this.opts.iSvcDataSrcId;
			_.each($$fxDom.documentElement.attributes, function(attr) {
				drillParams += "," + attr.name + "=" + attr.value;
			});
		}
	}

	return drillParams;
};

Wrapper.prototype.fxnamedsvccall = function() {
	/**
	 * Scope                        : All components
	 * Input (this.curCmdCtx._args) : XML string, like "<tagname attr_name='attr_value'  attr_name='attr_value'/>"
	 * Asynchronous reply           : Service reply
	 * Remark                       : For X3 legacy, service request has just a string parameter : "idData,attr_name=attr_value[,...]";
	 *                                "iData" is the datasource name (metadata of the component)
	 */
	var $$fxDom = $.parseXML(this.curCmdCtx._args),
		request = null;
	if ($$fxDom) {}
	if (request && this.hosterData.instance.fxnamedsvccall) {
		this.hosterData.instance.fxnamedsvccall(this.fxOnNamedSvcDone, this.hosterData, request);
	} else {
		this.fxOnError({
			"$message": $$fxDom ? "TO TRANSLATE - Hoster interface is not implemented'" : "TO TRANSLATE - Malformed request : '" + this.curCmdCtx._args + "'",
			"$severity": "error"
		});
	}
};

Wrapper.prototype.fxoverlap = function() {
	/**
	 * Scope                        : All components
	 * Remark                       : Obsolete
	 */
	this.replyPending = false;
};

// Asynchronous interactions Replies
Wrapper.prototype.fxOnGetdataDone = function(err, data, meta) {
	var realData;
	this.fxInitialDataPending = false;
	if (err) {
		this.fxOnError(err);
		this.pendingData = null;
		this.firstDataDone = true;
	} else {
		if (this.pendingData) {
			this._answerFxCommand(this._wrapFxDataInObj(this._processDataIn(this.pendingData.data || data || null, this.pendingData.meta || meta || null)));
			this.pendingData = null;
			this.firstDataDone = true;
		} else {
			if ((realData = this._processDataIn(data, meta))) {
				this._answerFxCommand(this._wrapFxDataInObj(realData));
				this.firstDataDone = true;
			} else {
				this.fxInitialDataPending = true;
			}
		}
		// Fix size
		/*var self = this;
		setTimeout(function() {
			var size = self._getDimensions();
			self.elt.width = size.width*0.066666666667;
			self.elt.height = size.height*0.066666666667;
		}, 2000);*/
	}
};

Wrapper.prototype.fxOnGetCtxMenuDone = function(err, mnuDesc) {
	/**
	 * Format : xdata="<MN><MI I="linkid"><![CDATA[label]]></MI><MI I="linkid"><![CDATA[label]]></MI></MN>"
	 *          xcounter=number (click counter )
	 */
	if (err) {
		this.fxOnError(err);
		return;
	}
	var reply = "<MN>",
		debug = (_fixture ? " from : " + this.id : "");
	if (mnuDesc) {
		var data = _.isArray(mnuDesc) ? mnuDesc : [mnuDesc];
		_.each(data, function(mnu) {
			if (mnu.$title && mnu.$title.length > 0 && mnu.linkId) reply += '<MI I="' + mnu.linkId + '"><![CDATA[' + mnu.$title + debug + ']]></MI>';
		}, this);
	}
	var objReply = this._wrapFxDataInObj(reply + "</MN>");
	objReply.xcounter = this.curCmdCtx.countAttr;
	this._answerFxCommand(objReply);
};

Wrapper.prototype.fxOnStdSvcDone = function(err, reply) {
	/**
	 * Format : xdata="<X3PORTAL><Data><Result><vv>www</vv><xx>yyy</xx></Result><Message><Mess>xxxx</Mess></Message></Data></X3PORTAL>"
	 *          or
	 *          xdata="<X3PORTAL>...full data flow...</X3PORTAL>"
	 */
	var preserveNL = false,
		xmlResult = [],
		xmlMess = [],
		i, len, diagnoses, severity, dataRes = false,
		arrayRes = true,
		ptlTag = "X3PORTAL>",
		messTag = "Messages>";
	if (err) {
		this.fxOnError(err);
	} else {
		if (reply.result) {
			if (!reply.result.data) {
				xmlResult = ["<", ptlTag, "</", ptlTag];
			} else {
				dataRes = true;
			}
			if ((diagnoses = reply.result.$diagnoses) && (len = diagnoses.$message.length) > 0) {
				for (i = 0; i < len; i++) {
					if (diagnoses.$message[i]) {
						severity = diagnoses.$severity[i] == 3 ? "Error" : "Warning";
						xmlMess.push("<", severity, ">", "<Mes>", diagnoses.$message[i], "</Mes>", "</", severity, ">");
					}
				}
				if (xmlMess.length > 0) {
					severity = "<" + ptlTag;
					if (!dataRes || (i = reply.result.data.indexOf(severity, 0)) < 0) {
						xmlResult = ["<", ptlTag, "<", messTag].concat(xmlMess, ["</", messTag, "</", ptlTag]);
						dataRes = false;
					} else if (i >= 0) {
						i += severity.length;
						reply.result.data = [reply.result.data.substr(0, i), (["<", messTag].concat(xmlMess, ["</", messTag])).join(""), reply.result.data.substr(i + 1)].join("");
					}
					preserveNL = true;
				}
			}
		} else if (reply.data) {
			arrayRes = false;
			xmlResult = this._processDataIn(reply.data, null);
		}
		if (xmlResult.length > 0 || dataRes) {
			this._answerFxCommand(this._wrapFxDataInObj(dataRes ? reply.result.data : (arrayRes ? xmlResult.join("") : xmlResult)), preserveNL);
		} else {
			this.fxOnError({
				"$message": "TO TRANSLATE : Bad response from server",
				"$severity": "error"
			});
		}
	}
};

Wrapper.prototype.fxOnDrillDone = function(err, reply) {
	(err ? this.fxOnError(err) : this._answerFxCommand(this._wrapFxDataInObj(this._processDataIn(reply, null))));
};

Wrapper.prototype.fxOnNamedSvcDone = function(err, reply) {
	(err ? this.fxOnError(err) : this._answerFxCommand(this._wrapFxDataInObj(this._processDataIn(reply, null))));
};

Wrapper.prototype.fxOnDummy = function(err, dummy) {
	if (err) this.fxOnError(err);
};

Wrapper.prototype.fxOnError = function(diagnoses) {
	var fxErr = new FlashError(diagnoses, this.id);
	this._answerFxCommand(this._wrapFxDataInObj('<X3PORTAL>' + fxErr.getXML() + '</X3PORTAL>'), true);
};

// Synchronous calls
Wrapper.prototype.cleanUp = function() {
	if (_.isFunction(this.elt.ERPClear)) this.elt.ERPClear();
};

Wrapper.prototype.isDirty = function() {
	return this._isReplyPending() ? null : (_.isFunction(this.elt.isDirty) ? this.elt.IsDirty() : true);
};

Wrapper.prototype.getData = function() {
	return !this._isReplyPending() && _.isFunction(this.elt.GetPadDocDataToSave) ? this.elt.GetPadDocDataToSave() : null;
};

Wrapper.prototype.setData = function(data, meta) {
	// We use the Asynchronous reply method to populate the data!!!
	if (data) {
		this.rawData = data;
		// if ((this.firstDataDone) && (this.rawData) && (this.rawData.length > 1)) this._populateFxData(this._wrapFxDataInObj(this._processDataIn(data, meta)), "fxdataupdated");
		if (this.firstDataDone) this._populateFxData(this._wrapFxDataInObj(this._processDataIn(data, meta)), "fxdataupdated");
		else if (!this.fxInitialDataPending) {
			// Data retention... waiting for "fxgetinitialDataFlash" command
			this.pendingData = {
				"data": data || null,
				"meta": null
			};
		} else {
			this.fxOnGetdataDone(null, data, meta);
		}
	}

	return true;
};

Wrapper.prototype.setFrameSize = function(width, heigth) {
	// We use the Asynchronous reply method to populate the size - Size in pixels.
	if (width || heigth) {
		var objReply = {
			"pwidth": width || null,
			"pheight": heigth || null
		};
		this._populateFxData(objReply, "fxgetframesize");
	}
};

// Wrapper public methods
Wrapper.prototype.setHostData = function(hosterData) {
	this.hosterData = hosterData || {};
};

// Dispose
Wrapper.prototype.dispose = function() {
	this.cleanUp();
	if (!$.browser.msie) {
		delete window[this.id + "_DoFSCommand"];
	}
	delete this.$$cont;
	delete this.hosterData.instance;
	delete this.hosterData;
};

// Helper methods
Wrapper.prototype._initProps = function() {
	// DHTML Flash container Object propertie
	this.$$cont = _.isString(this.props.cont) ? $("#" + this.props.cont) : this.props.cont;

	// DHTML Flash Object properties
	_.defaults(this.props, {
		"embedId": "voidid_",
		"align": "left",
		"width": "100%",
		"height": "100%",
		"base": ".",
		"bgcolor": "#ffffff"
	});

	// Main swf full name
	var len = this.props.swf.length;
	if (this.props.swf.charAt(len - 1) === "/" || this.props.swf.charAt(len - 1) === "\\") this.props.swf = this.props.swf.substr(0, len - 1);
	this.props.swf += "/xstart_portal.swf";
};

Wrapper.prototype._killNL = function(inStr) {
	// Remove \r (0D), \n (0A), \t (09) from xml string
	if (inStr && inStr.length > 0) {
		var re = new RegExp("\\r|\\n|\\t", "g");
		return inStr.replace(re, "");
	} else {
		return inStr;
	}
};

Wrapper.prototype._getCanonicalLink = function(uuid, linkId) {
	return linkId + "," + uuid;
};

Wrapper.prototype._getLinkObjFromCanonical = function(canonicalLink) {
	var link = {},
		tabLink = canonicalLink.split(",");
	if (tabLink.length < 2) {
		link.linkId = canonicalLink;
		link.linkCtx = "";
	} else {
		link.linkId = tabLink[0];
		link.linkCtx = tabLink[1];
	}

	return link;
};

Wrapper.prototype._trace = function(type, mess) {
	var logger, $fusionController = syraUtil.getFusionController(this.hosterData.instance);
	if ($fusionController && (logger = $fusionController.getLogger())) {
		logger.trace({
			"severety": type != "inf" ? "error" : "info"
		}, "FlashWrapper object \"" + this.id + "\" : \n" + mess);
	} else {
		_log && console.log("FlashWrapper: " + type + " - " + mess);
		if (!_debug) return;
		if (type != "inf") alert("Object \"" + this.id + "\" : \n" + mess);
		if (this.opts.messCont) $("#" + this.opts.messCont).text("Object \"" + this.id + "\" : \n" + mess);
	}
};

/* JSON Data Protocol to Flash XML document methods*/
// Deal with data sent by hoster
Wrapper.prototype._processDataIn = function(data, meta) {
	if (this.opts.xmlNative) {
		if (data) {
			this.currentData = data;
		}
		return this.currentData;
	} else {
		this.currentData = this.currentData || {};
		this.currentData.$diagnoses = (meta && meta.$diagnoses ? meta.$diagnoses : (data && data.$diagnoses ? data.$diagnoses : null));
		var transformer = this['_' + this.typeInfo.name + '_DataJson2Xml'],
			xml = transformer && transformer.call(this, data, meta);
		_log && console.log("FlashWrapper._processDataIn for '" + this.hosterData.instance.$item.$bind + "' : xml=" + xml);
		return xml;
	}
};

// Get graph definition object
Wrapper.prototype._getGraphDef = function(data, rawData) {
	// Init
	var graphDef = {
		"_metaData": {},
		"_drillDef": null
	},
		currAxisHier = 0;

	// Misc
	var axeTitle = null,
		measuresTitle = this.hosterData.instance.getFieldEvalTitle();
	var isOK = (data.$cube && data.$cube.$hierarchies && data.$axes && data.$axes.length > 0 && data.$axes[0].$hierarchies && data.$axes[0].$hierarchies.length > 0 ? true : false);
	graphDef._metaData.measuresDefinition = (data._metaData && data._metaData.measuresDefinition ? data._metaData.measuresDefinition : {});
	graphDef._metaData.isMetaOK = true;
	graphDef._metaData.provType = rawData.$provType || this.provType;

	// Get graph title
	if (measuresTitle && data.$axes[0].$hierarchies[0].length > 0) {
		axeTitle = measuresTitle[data.$axes[0].$hierarchies[0][0]];
	}
	if (!axeTitle && data.$axes && data.$axes.length > 0) {
		axeTitle = data.$axes[0].$title;
	}
	graphDef._metaData.title = (data.$cube && data.$cube.$title ? data.$cube.$title : "");
	if (axeTitle && graphDef._metaData.title != axeTitle) graphDef._metaData.title += ' / ' + axeTitle;

	// Get axis analysis
	if (isOK) {
		var mainHLevelsTab = null;
		_.each(data.$axes[0].$hierarchies, function(hierarchie, idx) {
			if (!mainHLevelsTab && hierarchie.length > 1 && hierarchie[1] == 1) {
				mainHLevelsTab = data.$cube.$hierarchies[hierarchie[0]].$properties;
				if (mainHLevelsTab) {
					graphDef._metaData.axis0FieldCode = mainHLevelsTab[hierarchie.length > 2 ? hierarchie[2] : 0];
					currAxisHier = idx;
				}
			}
		});
		if (!mainHLevelsTab && data.$axes[0].$hierarchies[0].length > 0) {
			mainHLevelsTab = data.$cube.$hierarchies[data.$axes[0].$hierarchies[0][0]].$properties;
			if (mainHLevelsTab && mainHLevelsTab.length > 0) graphDef._metaData.axis0FieldCode = mainHLevelsTab[0];
		}
	}

	// Is axis a "reference" field?
	if (graphDef._metaData.axis0FieldCode && data.$properties[graphDef._metaData.axis0FieldCode].$type == "application/x-reference" && data.$properties[graphDef._metaData.axis0FieldCode].$value) {
		graphDef._metaData.xRefAxis0FieldCode = data.$properties[graphDef._metaData.axis0FieldCode].$value.substr(1, match.length - 2);
	}

	// Get measures definition. If measures are not defined in the second axis members (Cf. specs), we used all the measures defined in the cube
	var measures, restraintMeasures;
	measures = (data.$cube && data.$cube.$measures ? data.$cube.$measures : null);
	if (measures) {
		restraintMeasures = measures;
		if (isOK && data.$axes.length > 1 && data.$axes[1].$members && data.$axes[1].$members[0][0].length > 0) {
			restraintMeasures = {};
			_.each(data.$axes[1].$members[0][0], function(measureCode) {
				restraintMeasures[measureCode] = measures[measureCode];
			});
		}
		_.each(restraintMeasures, function(measure, key) {
			// Because duplicate properties is possible for cube definition... we keep the last defined
			var code = (measure.$property || key);
			graphDef._metaData.measuresDefinition[code] = {
				"property": code,
				"title": measuresTitle && measuresTitle[code] || measure.$title || data.$properties[code].$title || "???",
				"definition": measure,
				"xRefCode": null
			};
			// Reference field?
			if (data.$properties[code].$type == "application/x-reference" && data.$properties[code].$value) {
				graphDef._metaData.measuresDefinition[code].xRefCode = data.$properties[code].$value.substr(1, match.length - 2);
			}
		});
	}

	// Get links...
	graphDef._metaData.links = [];
	if (data.$links) {
		_.each(data.$links, function(link, id) {
			if (id !== "$lazyload") {
				graphDef._metaData.links.push(this._getSyraLinkDesc("$links", id, link));
			}
		}, this);
	}
	if (data.$actions) {
		_.each(data.$actions, function(link, id) {
			graphDef._metaData.links.push(this._getSyraLinkDesc("$actions", id, link));
		}, this);
	}
	if (graphDef._metaData.axis0FieldCode && data.$properties[graphDef._metaData.axis0FieldCode].$thumb && data.$properties[graphDef._metaData.axis0FieldCode].$thumb.$links) {
		_.each(data.$properties[graphDef._metaData.axis0FieldCode].$thumb.$links, function(link, id) {
			graphDef._metaData.links.push(this._getSyraLinkDesc("$links", id, link));
		}, this);
	}
	if (graphDef._metaData.xRefAxis0FieldCode && data.$properties[graphDef._metaData.axis0FieldCode].$links) {
		_.each(data.$properties[graphDef._metaData.axis0FieldCode].$links, function(link, id) {
			graphDef._metaData.links.push(this._getSyraLinkDesc("$links", id, link));
		}, this);
	}

	// Get drill definition
	if (graphDef._metaData.provType == "PORTALSTA" && isOK) {
		var properties;
		graphDef._drillDef = {
			"minLevel": 1,
			"maxLevel": 0,
			"currLevel": 1,
			"currAxisHier": currAxisHier,
			"levelsProperties": [],
			"members": [],
			"code": rawData.$codeStat || "UNKNOWN",
			"axis0FieldCode": graphDef._metaData.axis0FieldCode || "",
			"xRefAxis0FieldCode": graphDef._metaData.xRefAxis0FieldCode || null
		};
		_.each(data.$axes[0].$hierarchies, function(hierarchie) {
			properties = data.$cube.$hierarchies[hierarchie[0]].$properties;
			_.each(properties, function(property) {
				this.levelsProperties[this.maxLevel++] = property;
			}, graphDef._drillDef);
		});
		graphDef._drillDef.maxLevel = (graphDef._drillDef.maxLevel > graphDef._drillDef.minLevel ? graphDef._drillDef.maxLevel : graphDef._drillDef.minLevel);
		if (data.$axes[0].$members) {
			_.each(data.$axes[0].$members, function(tuple) {
				_.each(tuple, function(value) {
					if (value.length > 0) {
						this.members[this.currLevel++-1] = value[0];
					}
				}, this);
			}, graphDef._drillDef);
		}
	}

	// All mandatory meta-data available?
	if (!graphDef._metaData.axis0FieldCode || !data.$properties || _.isEmpty(graphDef._metaData.measuresDefinition)) graphDef._metaData.isMetaOK = false;

	return graphDef;
};

// Get graph style properties
Wrapper.prototype._getGraphStyle = function(cubeDef, measuresDef) {
	// Init
	var graphStyle = {},
		trick = {},
		mStyle = "XPIE",
		mStyleEX = "",
		mStyleCode = "",
		mStyleEXCode = "",
		mDefault = null;
	var msCode = new Array(measuresDef.length),
		msCodeStyle = new Array(measuresDef.length),
		i = 0;

	// Go
	if (cubeDef.$style == "pie") {
		_.each(measuresDef, function(measure) {
			msCode[i++] = measure.property;
			if (measure.definition.$isDefault) mDefault = measure.property;
		});
	} else {
		_.each(measuresDef, function(measure) {
			// So, "xy" style
			switch (measure.definition.$style) {
				case "stick":
					mStyle = "XBAR";
					mStyleCode = "b";
					break;
				case "line":
					mStyle = "XLINE";
					mStyleCode = "l";
					break;
				case "area":
					mStyle = "XAREA";
					mStyleCode = "a";
					break;
			}
			if (measure.definition.$isStacked) {
				mStyleEX = "CU";
				mStyleEXCode = "cu";
			} else if (measure.definition.$isNormalized) {
				mStyleEX = "CO";
				mStyleEXCode = "co";
			}
			if (measure.definition.$isDefault) mDefault = measure.property;

			msCode[i] = measure.property;
			msCodeStyle[i++] = measure.property + "," + mStyleCode + mStyleEXCode;
			trick[mStyle + mStyleEX] = "";
		});
	}

	// Debrief...
	// What about type "FGRSD" ?
	if (_.size(trick) <= 1) {
		graphStyle.type = "FGRS";
		if (cubeDef.$displaysOneMeasure) graphStyle.measureStyle = mStyle;
		else if (mStyleEX.length === 0) graphStyle.measureStyle = mStyle + "M";
		else graphStyle.measureStyle = mStyle + mStyleEX;
		graphStyle.measuresList = msCode.join(";");
	} else {
		graphStyle.type = "FGRP";
		graphStyle.measureStyle = "XPERSO";
		graphStyle.measuresList = msCodeStyle.join(";");
	}

	// Misc properties
	graphStyle.defaultMeasures = (!cubeDef.$displaysOneMeasure ? msCode.join(";") : (mDefault ? mDefault : msCode[0]));
	graphStyle.hasMeasureSelector = (_.isUndefined(cubeDef.$hasMeasureSelector) ? "2" : (cubeDef.$hasMeasureSelector ? "2" : "1"));
	graphStyle.hasStyleSelector = (_.isUndefined(cubeDef.$hasStyleSelector) ? "2" : (cubeDef.$hasStyleSelector ? "2" : "1"));

	return graphStyle;
};

// Retrieve Syra link from link definition : {"$item":resource obj, "$links" or "$actions": {"$linkname":link obj}}
Wrapper.prototype._getLinkObj = function(link) {
	var links = this._getLinksFromCurrData();
	if (!this.opts.legacyLinks && link.linkId && links && links.length > 0) {
		var linkSyra = {},
			linkObj = {};
		linkSyra.$item = this.currentData.$resources[link.linkCtx];
		linkObj[links[link.linkId].id] = links[link.linkId].link;
		linkSyra[links[link.linkId].type] = linkObj;
		return linkSyra;
	} else {
		return link;
	}
};

// Build a syra link full description object (type : "$link", "$action"... id = "$edit", $delete, etc...)
Wrapper.prototype._getSyraLinkDesc = function(type, id, objLink) {
	return {
		"type": type,
		"id": id,
		"link": objLink,
		"title": objLink.$title
	};
};

// Retrieve a link idx in the link collection, by type and id
Wrapper.prototype._getLink = function(type, id) {
	var links = this._getLinksFromCurrData(),
		i = 0;
	if (!this.opts.legacyLinks && links) {
		for (i = 0; i < links.length; i++) {
			if (links[i].type === type && links[i].id === id) {
				break;
			}
		}
		return (i < links.length ? i : null);
	} else {
		return null;
	}
};

// Retrieve "$links" from prototype
Wrapper.prototype._getLinksFromCurrData = function() {
	if (this.currentData._metaData) return this.currentData._metaData.links;
	else return null;
};

// Build XML document expected by graph component, from JSON hyper-cube protocol (Syracuse specs)
Wrapper.prototype._graph_DataJson2Xml = function(rawData, meta) {
	// Data mapping
	var hasMetaChanged = false,
		realRawData = null;
	if (rawData && _.isArray(rawData)) {
		this.currentData.$resources = rawData;
		realRawData = meta || null;
	}
	realRawData = realRawData || rawData || meta;
	if (realRawData) {
		if (realRawData.$item && realRawData.$item.$properties) {
			this.currentData.$properties = realRawData.$item.$properties;
			hasMetaChanged = true;
		}
		if (realRawData.$cube) {
			this.currentData.$cube = realRawData.$cube;
			hasMetaChanged = true;
		}
		if (realRawData.$axes) {
			this.currentData.$axes = realRawData.$axes;
			hasMetaChanged = true;
		}
		if (realRawData.$slicer) {
			this.currentData.$slicer = realRawData.$slicer;
			hasMetaChanged = true;
		}
		if (realRawData.$item && realRawData.$item.$links) {
			this.currentData.$links = realRawData.$item.$links;
			hasMetaChanged = true;
		}
		if (realRawData[this.opts.dataBinding]) this.currentData.$resources = realRawData[this.opts.dataBinding];
	}

	// Get graph meta-data
	if (hasMetaChanged) _.extend(this.currentData, this._getGraphDef(this.currentData, realRawData));
	var graphDef = {
		"_metaData": this.currentData._metaData,
		"_drillDef": this.currentData._drillDef
	};

	// "Titles" Tag. Warning : first we check the resources collection; if no data, we build just a minimal "Titles" Tag
	var xmlTitlesTag = ["<Titles><Title>", graphDef._metaData.title, "</Title>"],
		nbMeasures = 0;
	if (!graphDef._metaData.isMetaOK) {
		graphDef._metaData.axis0FieldCode = "DEFLIB";
		xmlTitlesTag.push("<ColTitle Num='1' Nam='", graphDef._metaData.axis0FieldCode, "' X3Type='7'>Default</ColTitle>");
		xmlTitlesTag.push("<ColTitle Num='2' Nam='", graphDef._metaData.axis0FieldCode, "' X3Type='4'></ColTitle>");
		xmlTitlesTag.push("</Titles>");
	} else {
		xmlTitlesTag.push('<ColTitle Num="1" Nam="', graphDef._metaData.axis0FieldCode, '" X3Type="7">', (this.currentData.$properties[graphDef._metaData.axis0FieldCode].$title || "???"), '</ColTitle>');
		_.each(graphDef._metaData.measuresDefinition, function(measureDef) {
			xmlTitlesTag.push('<ColTitle Num="', (2 + nbMeasures++), '" Nam="', measureDef.property, '" X3Type="4">', measureDef.title, '</ColTitle>');
		});
		xmlTitlesTag.push("</Titles>");
	}

	// "Lines" Tag. Iterates over data collection and builds "Lines" Tag... some differences between Graph classes...
	var xmlLinesTag = new Array((this.currentData.$resources ? (this.currentData.$resources.length + 2) : 2)),
		xmlLineTag, colNum, value, detailLinkIdx = null,
		detailLink;
	xmlLinesTag[0] = "<Lines>";
	if (this.currentData.$resources && graphDef._metaData.isMetaOK) {
		if (graphDef._metaData.provType != "TABLEBLOC") {
			detailLinkIdx = this._getLink("$links", "$details");
		}
		_.each(this.currentData.$resources, function(occur, idx) {
			// "Dimension analys" data
			colNum = 1;
			value = (typeof(occur[graphDef._metaData.axis0FieldCode]) === 'object' ? (graphDef._metaData.xRefAxis0FieldCode ? occur[graphDef._metaData.axis0FieldCode][graphDef._metaData.xRefAxis0FieldCode] : occur[graphDef._metaData.axis0FieldCode].code) : occur[graphDef._metaData.axis0FieldCode]);
			xmlLineTag = new Array(nbMeasures + 3);
			if (graphDef._metaData.provType == "TABLEBLOC") xmlLineTag[0] = '<line Num="' + idx + '" Uuid="' + occur['$uuid'] + '"><col><v>' + value + '</v></col>';
			else {
				// Warning : Graph flash component for "PORTALSTA" & "PORTALREQ" data source supports just one link by occurence...
				detailLink = (detailLinkIdx !== null ? (' X3Link="' + this._getCanonicalLink(idx.toString(10), detailLinkIdx) + '"') : "");
				xmlLineTag.push('<line Num="', idx, '"><col X3Type="7" Num="', colNum++, '"', detailLink, '><v>', value, '</v></col>');
			}

			// "Measure" data
			_.each(graphDef._metaData.measuresDefinition, function(measureDef) {
				value = (typeof(occur[measureDef.property]) === 'object' ? (measureDef.xRefCode ? occur[measureDef.property][measureDef.xRefCode] : occur[measureDef.property].code) : occur[measureDef.property]);
				xmlLineTag.push('<col X3Type="4" Num="', colNum++, '"><v>', value, '</v></col>');
			});

			// Drill meta-data
			if (graphDef._drillDef && graphDef._drillDef.currLevel < graphDef._drillDef.maxLevel) {
				var criterionTab = new Array(graphDef._drillDef.currLevel);
				criterionTab[graphDef._drillDef.currLevel - 1] = "<Criterion" + graphDef._drillDef.currLevel + ">" + (graphDef._drillDef.xRefAxis0FieldCode ? occur[graphDef._drillDef.axis0FieldCode][graphDef._drillDef.xRefAxis0FieldCode] : occur[graphDef._drillDef.axis0FieldCode]) + "</Criterion" + graphDef._drillDef.currLevel + ">";
				for (var i = 1; i < graphDef._drillDef.currLevel; i++) {
					criterionTab[i - 1] = "<Criterion" + i + ">" + graphDef._drillDef.members[i - 1] + "</Criterion" + i + ">";
				}
				xmlLineTag.push('<Zoom><Level>', (graphDef._drillDef.currLevel + 1), '</Level><Criteria>', criterionTab.join(""), '</Criteria></Zoom>');
			}

			// Finished!
			xmlLineTag.push("</line>");
			xmlLinesTag.push(xmlLineTag.join(""));
		}, this);
	}
	xmlLinesTag.push("</Lines>");

	// "Technical" Tag
	var techTag = [""];
	if (hasMetaChanged) {
		var graphStyle = {};
		if (this.currentData.$cube && graphDef._metaData.measuresDefinition) graphStyle = this._getGraphStyle(this.currentData.$cube, graphDef._metaData.measuresDefinition);
		if (!graphDef._metaData.isMetaOK) {
			// Fixture
			graphStyle.measuresList = "2";
			graphStyle.defaultMeasures = "2";
		}
		graphStyle.provType = graphDef._metaData.provType;
		graphStyle.axis0Name = graphDef._metaData.axis0FieldCode;
		graphStyle.cdLang = this.opts.cdLang;

		// Technical template...
		techTag[0] = "<Technical>";
		techTag.push(_templateTechTag(graphStyle));

		// Add Drill meta-data
		if (graphDef._drillDef) {
			techTag.push('<DataSrc Type="STA" Code="', graphDef._drillDef.code, '" />');
			techTag.push("<MinLevel>", graphDef._drillDef.minLevel, "</MinLevel><CurrentLevel>", graphDef._drillDef.currLevel, "</CurrentLevel><MaxLevel>", (graphDef._drillDef.maxLevel + 1), "</MaxLevel>");
			techTag.push("<Criteria>");
			for (var i = 1; i < graphDef._drillDef.currLevel; i++) {
				techTag.push("<Criterion" + i + ">", graphDef._drillDef.members[i - 1], "</Criterion" + i + ">");
			}
			techTag.push("</Criteria>");
			if (graphDef._drillDef.currLevel > graphDef._drillDef.minLevel) techTag.push("<PrevDetailTitle>", (this.currentData.$properties[graphDef._drillDef.levelsProperties[graphDef._drillDef.currLevel - 2]].$title || "???"), "</PrevDetailTitle>");
			if (graphDef._drillDef.currLevel < graphDef._drillDef.maxLevel) techTag.push("<NextDetailTitle>", (this.currentData.$properties[graphDef._drillDef.levelsProperties[graphDef._drillDef.currLevel]].$title || "???"), "</NextDetailTitle>");
		}
		techTag.push("</Technical>");
	}

	// "Messages" Tag
	var messTag = new FlashError(this.currentData.$diagnoses, this.id);

	// Build the full document
	var xmlDocTag = ["<X3PORTAL><Data>", xmlLinesTag.join(""), xmlTitlesTag.join(""), "</Data>", techTag.join(""), messTag.getXML(), "</X3PORTAL>"];

	return xmlDocTag.join("");
};

// Build XML document expected by processus component "FPADT", from JSON protocol
Wrapper.prototype._padDesigner_DataJson2Xml = function(rawData, meta) {
	// Data mapping
	this.currentData.page = rawData.page || null;
	this.currentData.menuNavig = rawData.menuNavig || null;

	// Go
	var userLang = this.opts && this.opts.userLang || this.opts.cdLang || "BRI";
	// xb = flash.xmlBuilder($decorator.$stereotype, {
	//     uersLang: userLang
	// });
	// xb.addNode("Data.Page", null, null, this.currentData.page);
	// xb.addNode("Data.MainNavig", null, null, this.currentData.menuNavig);
	var xmlDocTag = ['<X3PORTAL><Data><Page><![CDATA[', this.currentData.page || "", ']]></Page>'];
	if (this.currentData.menuNavig) xmlDocTag.push('<MainNavig><![CDATA[', this.currentData.menuNavig, ']]></MainNavig>');
	xmlDocTag.push('</Data>');

	// "Technical" Tag
	xmlDocTag.push('<Technical><VisCmp Type="' + (this.typeInfo.visCmp) + '"></VisCmp><UserLang>' + userLang + '</UserLang></Technical>');

	// "Messages" Tag
	var messTag = new FlashError(this.currentData.$diagnoses, this.id);
	xmlDocTag.push(messTag.getXML(), '</X3PORTAL>');

	return xmlDocTag.join("");
};

// Build XML document expected by processus component "FPADP", from JSON protocol
Wrapper.prototype._padPlayer_DataJson2Xml = function(rawData, meta) {
	return this._padDesigner_DataJson2Xml(rawData, meta);
};

Wrapper.prototype._agenda_DataJson2Xml = function(rawData, meta) {
	var proto = null,
		hasMetaChanged = false,
		$$layoutSlot = $(this.hosterData.instance.layoutSlot);

	if (rawData && Array.isArray(rawData)) {
		this.currentData.$resources = rawData;
		proto = meta || null;
	}
	proto = proto || rawData || meta;
	if (proto) {
		if (proto.$item && proto.$item.$properties) {
			this.currentData.$properties = proto.$item.$properties;
			this.$decorator = proto.$decorator;
			hasMetaChanged = true;
		}
	}

	// TODO: How to set it without an hard coded value?
	$$layoutSlot.height("450px");

	var $resources = this.currentData.$resources,
		$properties = this.currentData.$properties,
		$decorator = this.$decorator,
		x3map = $decorator && $decorator.$bindings || {},
		userLang = this.opts && this.opts.userLang || "BRI",
		xb = flash.xmlBuilder($decorator.$stereotype, {
			uersLang: userLang
		});

	xb.addNode("Data.Lines");

	function value(k, r) {
		var key = x3map[k],
			p = key && $properties[key],
			val = key && r[key];
		return p && val && ("" + val);
	}

	function newCol(i, vi, vv, attrs) {
		var node = {
			Col: {
				$: {
					Num: "" + i
				},
				X3IntVal: {
					$value: vi
				},
				X3Value: {
					$value: vv
				}
			}
		};
		if (attrs) {
			forEachKey(attrs, function(k, v) {
				node.Col.$[k] = v;
			});
		}
		return node;
	}

	// Technical node: FCSELC boolean for caleandar selector 1 = false, 2 = true
	//  1 TYPACT    : FCTYPE ==> val                                (see Flash function: fgetAgdType)
	//  2 KEYACT    : FCCHRONO ==> val, att                         (see Flash function: fgetAgdChrono)
	//  3 DATDI     : FCDATEDEB ==> int (DATD ==> val not used)     (see Flash function: fgetSDate)
	//  4 HEUDI     : FCHEURDEB ==> int                             (see Flash function: fgetSTime)
	//  5 DATFI     : FCDATEFIN ==> int (DATF ==> val not used)     (see Flash function: fgetAgdEDate)
	//  6 HEUF      : FCHEURFIN ==> int                             (see Flash function: fgetETime)
	//  7 TIER      : FCTIERS ==> val                               (see Flash function: fgetAgdTiers)
	//  8 INT       : FCINTERLOC ==> val                            (see Flash function: fgetAgdInterloc)
	//  9 CAT       : FCCATEG ==> val                               (see Flash function: fgetAgdCateg)
	// 10 OBJ       : FCTEXTE ==> int                               (see Flash function: fgetDescrs)
	// 11 EXE       : FCSTATUS ==> int                              (see Flash function: fgetAgdStatus)
	var cols = ["TYPACT", "KEYACT", "DATDI", "HEUD", "DATFI", "HEUF", "TIER", "INT", "CAT", "OBJ", "EXE"];

	$resources.filter(function(r, i) {
		return value("TYPACT", r) !== "-1";
	}).forEach(function(r, i) {
		var actionCode = 0,
			line = xb.addNode("Data.Lines.Line", null, {
				Num: i + 1
			});
		cols.forEach(function(k, i) {
			var vi = value(k, r),
				v = "",
				att;

			// default is to fill the X3IntVal
			switch (k) {
				case "KEYACT":
					att = {
						X3Link: "x3://12074,OBJET=" + actionCode + "&amp;CLES=" + vi
					};
				case "TYPACT":
					actionCode = ["TSK", "CLL", "BAP"][parseInt(vi, 10) - 1];
				case "TIER":
				case "INT":
				case "CAT":
					v = vi;
					vi = "";
					break;
				case "HEUD":
				case "HEUF":
					v = vi;
					vi = vi.split(":").join("");
					break;
			}
			xb.addChild(line, newCol(i + 1, vi, v, att));
		});
	});

	xb.addNode("Data.Titles.Title", "");
	for (var i = 1; i < 12; i++) {

		xb.addNode("Data.Titles.ColTitle", "", {
			Num: "" + i,
			X3Type: "7"
		});
	}

	var typact = $properties[x3map["TYPACT"]],
		actionEnum = this.actionEnum || (typact && this.hosterData.instance.getEnumeration(typact.$mnu));
	var colors = ["0xFDE6D5", "0xDEF3DD", "0xF9FDD5"];

	// xb.addNode("Data.Categs");
	actionEnum && actionEnum.forEach(function(m, i) {
		xb.addNode("Data.Categs.Categ", m, {
			Id: "" + (i + 1),
			Color: (colors[i] || "")
		});
	});

	if (hasMetaChanged) { // HtcProvType value is 'CLOB' if the flash component is bound to a clob otherwise it's 'TABLEBLOC'
		// The next 2 values are not used by the agenda but only by the calendar
		xb.addNode("Technical.VisCmp.FCCTYPE", "XWEEK");
		xb.addNode("Technical.VisCmp.FCSELC", "2");

		xb.addNode("Technical.VisCmp.FCDATEDEB", "3");
		xb.addNode("Technical.VisCmp.FCDATEFIN", "5");
		xb.addNode("Technical.VisCmp.FCHEURDEB", "4");
		xb.addNode("Technical.VisCmp.FCHEURFIN", "6");
		xb.addNode("Technical.VisCmp.FCCHRONO", "2");
		xb.addNode("Technical.VisCmp.FCTEXTE", "10");
		xb.addNode("Technical.VisCmp.FCTYPE", "1");
		xb.addNode("Technical.VisCmp.FCCATEG", "9");
		xb.addNode("Technical.VisCmp.FCTIERS", "7");
		xb.addNode("Technical.VisCmp.FCINTERLOC", "8");
		xb.addNode("Technical.VisCmp.FCSTATUS", "11");

		xb.addNode("Technical.Action", "INIT");
		xb.addNode("Technical.UsedDataSrcPar.DAYBEF", "10");
		xb.addNode("Technical.UsedDataSrcPar.DAYAFT", "10");
	} else {
		delete xb.$.Technical;
	}
	return xb.xml();
};

Wrapper.prototype._gantt_DataJson2Xml = function(rawData, meta) {
	var proto = null,
		hasMetaChanged = false,
		$$layoutSlot = $(this.hosterData.instance.layoutSlot);

	if (rawData && Array.isArray(rawData)) {
		this.currentData.$resources = rawData;
		proto = meta || null;
	}
	proto = proto || rawData || meta;
	if (proto) {
		if (proto.$item && proto.$item.$properties) {
			this.currentData.$properties = proto.$item.$properties;
			this.$decorator = proto.$decorator;
			hasMetaChanged = true;
		}
	}

	// TODO: How to set it without an hard coded value?
	$$layoutSlot.height("450px");

	var $resources = this.currentData.$resources,
		$properties = this.currentData.$properties,
		$decorator = this.$decorator,
		xmlDocTag = [],
		x3map = $decorator && ($decorator.$bindings || $decorator.$mapping) || {};

	function value(k, r, checkRaw, mustRaw) {
		var val, rawV, key = x3map[k],
			p = key && $properties[key];
		if (mustRaw && r.$rawV && (rawV = r.$rawV[key]) && rawV.v !== undefined) {
			val = rawV.v;
		} else {
			val = key && r[key];
			if (!val && checkRaw && r.$rawV && (rawV = r.$rawV[key]) && rawV.v !== undefined) {
				val = rawV.v;
			}
		}
		return p && val && ("" + val);
	}

	function addColumn(num, label, typ, sdate, dur, elapse) {
		var xml;
		if (typ > 0) {
			// only positive values of a string-value
			if (dur.substring(0, 1) != "-") {
				xml = '<subi typ="' + typ + '" ccount="5" sdate="' + sdate + '" dur="' + dur + '" elapse="' + elapse + '"/>';
				xmlDocTag.push(xml);
				pos = dur;
			}
		}
	}

	// <GPH XD1="A" XID="33025" NCO="432" NLI="187" PCO="1" PLI="5" BOR="1" IDF="256" SID="256" GTD="1" GTY="1"> <CPH CAP="Type d'action" NAM="TYPACT" XD1="A2" TDO="1" FMT="LA2948:15X" TYP="7" TFL="TYPACT"/> <CPH CAP="Chrono action" NAM="KEYACT" XD1="A3" TDO="7" FMT="K:10X" TYP="6" TFL="KEYACT"/> <CPH CAP="Date dbut interne" NAM="DATDI" XD1="A5" TDO="7" FMT="KiP:8X" TYP="32" TFL="DATD"/> <CPH CAP="Date fin interne" NAM="DATFI" XD1="A7" TDO="7" FMT="KiP:8X" TYP="32" TFL="DATF"/> <CPH CAP="Heure dbut" NAM="HEUD" XD1="A8" TDO="7" FMT="Kz:##[:]##" TYP="6" TFL="HEUD"/> <CPH CAP="Heure de fin" NAM="HEUF" XD1="A9" TDO="7" FMT="Kz:##[:]##" TYP="6" TFL="HEUF"/> <CPH CAP="Tiers" NAM="TIER" XD1="A10" TDO="7" FMT="K:20X" TYP="6" TFL="TIER"/> <CPH CAP="Interlocuteur" NAM="INTERL" XD1="A11" TDO="7" FMT="K:30X" TYP="6" TFL="INT"/> <CPH CAP="Catgorie" NAM="CAT" XD1="A12" TDO="7" FMT="K:10X" TYP="6" TFL="CAT"/> <CPH CAP="Objet" NAM="OBJ" XD1="A13" TDO="7" FMT="K:20X>40X" TYP="6" TFL="OBJ"/> <CPH CAP="Excut" NAM="EXE" XD1="A14" TDO="1" FMT="LA1:10X" TYP="7" TFL="EXE"/> <TEC FCC="2" FCS="2" FCD="" FCL="" FCV="" FTY="XMONTH" Code="A" SWF="FAG" GTYP="AGD" VAL1="2948" PAR1="MENACT"/> <MENS COD="TYPACT" NO="2948"/> <ACTS> </ACTS> </GPH>
	var cols = ["KEY", "LIB", "DATDI", "DURI", "TYPDAY", "ELAP"];

	xmlDocTag.push('<X3PORTAL>');
	xmlDocTag.push('<Data>');

	var start = "999999999999";
	var end = "000000000000";

	// calulating new Enddate

	function newEnd(start, duri) {
		var year = start.substring(0, 4);
		var month = start.substring(4, 6);
		var day = start.substring(6, 8);
		var hour = start.substring(8, 10);
		var minut = start.substring(10, 12);
		year = year * 1;
		month = month * 1;
		day = day * 1;
		hour = hour * 1;
		minut = minut * 1;
		var duriInt = parseFloat(duri);
		var d = datetime.make(year, month, day, hour, minut);
		d = d.addDayFractions(duriInt);
		var endFormatted = d.toString('yyyyMMddHHmm');

		//var endFormatted = d._value + "1200";
		if (endFormatted > end) {
			end = endFormatted;
		}
	}

	$resources.forEach(function(r, i) {
		var val;
		val = value("DATDI", r);
		if (val) {
			if (val < start) {
				start = val;
			}

			var val2 = value("ELAP", r, false, true);
			if (val2) {
				newEnd(val, val2);
			}
		}
	});

	xmlDocTag.push('<items title="" start="' + start + '" end="' + end + '">');

	var row = 0,
		header = "",
		pos = "",
		header_once = false;

	$resources.forEach(function(r) {
		row++;
		var label = "",
			key, typ = "",
			sdate = "",
			dur = "",
			elapse = "";

		cols.forEach(function(k, i) {
			var vi = value(k, r, k == "KEY" || k == "LIB", k == "DURI" || k == "ELAP"),
				v = "",
				att;

			switch (k) {
				case "KEY":
					key = vi;
					break;
				case "LIB":
					label = vi;
					break;
				case "DATDI":
					sdate = vi;
					break;
				case "DURI":
					dur = vi;
					break;
				case "TYPDAY":
					typ = vi;
					break;
				case "ELAP":
					elapse = vi;
					break;
			}
		});
		if (key) {
			if (sdate != "") {
				if (dur.substring(0, 1) != "-") {
					addColumn(row, label, typ, sdate, dur, elapse);
				}
			} else {
				if (header_once) {
					xmlDocTag.push('</item>');
				}
				xmlDocTag.push('<item Num="' + row + '" tlabel="' + label + '">');
				header_once = true;
			}
		}
	});
	if (header_once) {
		xmlDocTag.push('</item>');
	}
	xmlDocTag.push('</items>');

	var typact = $properties[x3map["TYPDAY"]],
		actionEnum = this.actionEnum || (typact && this.hosterData.instance.getEnumeration(typact.$mnu));

	// review this to adapt it for itemproperties
	xmlDocTag.push('<itemproperties><iprop id="tlabel" label="Nom" type="7"/></itemproperties>');
	xmlDocTag.push('<subitypes>');

	actionEnum && actionEnum.forEach(function(m, i) {
		xmlDocTag.push('<sityp id="' + (i + 1) + '" label="' + m + '" type="4" color="" />');
	});
	xmlDocTag.push('</subitypes>');

	xmlDocTag.push('</Data>');
	if (hasMetaChanged) {
		xmlDocTag.push('<Technical>');
		// TABLEBLOC for flash component bound to a table and CLOB if it's bound to a clob
		xmlDocTag.push('<HtcProvType>TABLEBLOC</HtcProvType>');

		xmlDocTag.push('<DataSrc Type="GAT" Code=""/>');
		xmlDocTag.push('<VisCmp Type="FGA" Width="989">');

		xmlDocTag.push('<FTLISTCOLS>tlabel</FTLISTCOLS>');
		xmlDocTag.push('<FTLOOK>SAGE1</FTLOOK>');
		// xmlDocTag.push('<FCAMPM>1</FCAMPM>');
		xmlDocTag.push('</VisCmp>');
		xmlDocTag.push('<UsedDataSrcPar>');
		xmlDocTag.push('<DAYBEF>100</DAYBEF>');
		xmlDocTag.push('<DAYAFT>100</DAYAFT>');
		xmlDocTag.push('</UsedDataSrcPar>');

		var lang = this.hosterData.instance.page.$fusionPageMeta.controller._session.cdLang;
		lang = lang || "ENG";
		xmlDocTag.push('<UserLang>' + lang + '</UserLang>');
		xmlDocTag.push('</Technical>');
	}
	xmlDocTag.push('<Messages>');
	xmlDocTag.push('</Messages>');
	xmlDocTag.push('</X3PORTAL>');
	return xmlDocTag.join("");
};

/* Flash Error class */

function FlashError(diagnoses, callerId) {
	/**
	 * diagnoses    : Cf. "Diagnosis Schema" http://syracuse/w/index.php/Diagnosis_Schema
	 * getXML()     : "<X3PORTAL><Messages><Error><Code>x</Code><Img>zzzz</Img><Mes>wwwww</Mes></Error></Messages></X3PORTAL>"
	 */
	this.diagnoses = (diagnoses ? (_.isArray(diagnoses) ? diagnoses : [diagnoses]) : null);
	this.callerId = callerId || "unknown";
}

FlashError.prototype.getXML = function() {
	var xmlDiagnoses = ["<Messages>"],
		diagnosEx, severity;
	if (this.diagnoses) {
		_.each(this.diagnoses, function(diagnos) {
			var cr = "\n";
			diagnosEx = {};
			_.defaults(diagnosEx, diagnos, {
				"$severity": "error",
				"$message": "unknown error"
			});
			diagnosEx.$message += (_fixture ? " from : " + this.callerId : "") + (diagnosEx.appCode ? " (" + diagnosEx.appCode + "). " : "") + (diagnosEx.$stackTrace ? cr + diagnosEx.$stackTrace : "");
			if (diagnosEx.$origin) {
				diagnosEx.$message += (cr + "From : " + diagnosEx.$origin);
			}
			severity = (diagnosEx.$severity == "error" || diagnosEx.$severity == "fatal" ? "Error" : "Warning");
			xmlDiagnoses.push("<", severity, ">", "<Mes><![CDATA[", diagnosEx.$message, "]]></Mes></", severity, ">");
		}, this);
	}
	xmlDiagnoses.push("</Messages>");

	return xmlDiagnoses.join('');
};

exports.flashWrapper = Wrapper;