"use strict";
/*
 Copyright (c)2011 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Flash X3 components Wrapper
 */

var helpers = require('syracuse-core/lib/helpers');
var _formatApi = require('syracuse-ui/lib/field/formatApi');
var flash = require("./flashHelpers");
var date = require('syracuse-core/lib/types/date');
var int = require('syracuse-core/lib/types/integer');
// var clone = helpers.object.clone;
var stringify = helpers.object.stringify,
    forEachKey = helpers.object.forEachKey;
// Misc
var _fixture = false;
var _log = false;
var _debug = false;
var _transparent = false;

// case "fxgetinitialdata" :{this.isFlashOK=true;this.sendData();return true;break}
// case "fxsendctxaction"  :{this.execActionMenu(aArgs);this.busy=false;return true;break}
// case "fxgetctxmenu"     :{var wDom=Gr_setStringToDom(aArgs);this.getStringMenu(wDom);this.busy=false;return true;break}
// case "fxlinktox3"       :{this.ackCallLink(aArgs);this.busy=false;return true;break}
// case "fxspro"           :{this.buildAndSendAckCall(aArgs);this.busy=false;return true;break}
// case "fxhelp"           :{this.help(aArgs);this.busy=false;return true;break} //appel aide X3
// case "fxhelpflash"      :{this.helpInterne(aArgs);this.busy=false;return true;break} //appel  interne flash
// Static method : Flash to JavaScript communication initialization (AS2 technology)
var _initFlash2Js = function(elt, id, callBackFct) {
        if ($.browser.msie) {
            elt.attachEvent('fscommand', callBackFct);
        } else {
            // Warning : unlike IE, event handling doesn't work for others browsers ... so, we need to define an explicit function callback in windows's scope
            window[id + "_DoFSCommand"] = function(command, args) {
                callBackFct(command, args);
            };
        }
    };

// Templates
// <param name="wmode" value="transparent"/> \
// wmode="transparent" \
var _templateFlashTag = _.template('<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" align="<%= align %>" \
                    height="<%= height %>" width="<%= width %>" id="<%= id %>"> \
                    <param name="allowScriptAccess" value="sameDomain"/> \
                    <param name="base" value="<%= base %>"/> \
                    <param name="movie" value="<%= swf %>"/> \
                    <param name="quality" value="high"/> \
                    <param name="scale" value="noscale"/> \
                    <param name="salign" value="lt"/> \
                    <param name="bgcolor" value="<%= bgcolor %>"/>' //
+ (_transparent ? '<param name="wmode" value="transparent"/>' : '') //
+ '<embed src="<%= swf %>" quality="high" \
                        scale="noscale" salign="lt"  bgcolor="<%= bgcolor %>" base="<%= base %>"  \
                        width="<%= width %>" height="<%= height %>" swLiveConnect="true" id="<%= embedId %>" name="<%= embedId %>"  \
                        align="<%= align %>" allowScriptAccess="sameDomain" type="application/x-shockwave-flash" ' //
+ (_transparent ? 'wmode="transparent"' : '') //
+ 'pluginspage="http://get.adobe.com/flashplayer/"/> \
                    </object>');

var _templateTechTag = _.template('<HtcProvType><%= provType %></HtcProvType> \
                    <VisCmp Type="<%= type %>"> \
                        <FGGTYPE><%= measureStyle %></FGGTYPE>   \
                        <FGCVAL><%= measuresList %></FGCVAL>      \
                        <FGCLABEL><%= axis0Name %></FGCLABEL>\
                        <FGCSELC><%= hasMeasureSelector %></FGCSELC>   \
                        <FGCSELG><%= hasStyleSelector %></FGCSELG>   \
                        <FGCDEF><%= defaultMeasures %></FGCDEF>      \
                    </VisCmp> \
                    <UserLang><%= cdLang %></UserLang>');

/* Flash Wrapper class */

function _getComponentType(article) {
    var proto = article.$prototype,
        item = article.$item,
        $decoratorType = proto.$decorator && proto.$decorator.$stereotype;
    if (proto.$cube) return "graph";
    if ($decoratorType) {
        return $decoratorType;
    }
    return item && item.$renderer;
};

function Wrapper(componentType, properties, hosterData, options) {
    // Instance properties initialization
    this.typeInfo = flash.typeInfo(componentType || _getComponentType(hosterData.instance));
    this.props = _.clone(properties);
    this._initProps();
    this.setHostData(hosterData);

    // Options initialization
    this.opts = (options ? _.clone(options) : {});
    _.defaults(this.opts, {
        "legacyLinks": false,
        "legacyRequest": false,
        "xmlNative": false,
        "dataBinding": "$resources",
        "cdLang": "ENG",
        "iSvcDataSrcId": "@"
    });

    // Default values
    this.provType = "TABLEBLOC";
    this.curCmdCtx = {};
    this.replyPending = false;
    this.pendingData = null;
    this.firstDataDone = false;
    this.currentData = {};

    // Bind asynchronous callback to "this"
    _.bindAll(this, "fxOnError", "fxOnDummy", "fxOnGetdataDone", "fxOnGetCtxMenuDone", "fxOnDrillDone", "fxOnStdSvcDone", "fxOnNamedSvcDone", "_dispatchFxCommand");

    // Build markup
    this.id = this.props.id;
    if (!$.browser.msie) {
        this.props.id = this.props.embedId + this.props.id;
        this.props.embedId = this.id;
    }
    this.$$elt = $(_templateFlashTag(this.props));
    this.elt = $.browser.msie ? this.$$elt.get(0) : this.$$elt.find("embed").get(0);

    // Perform Flash->Javascript communication initialization
    _initFlash2Js(this.elt, this.id, this._dispatchFxCommand);

    // Finally, append Flash element to the container
    this.$$elt.appendTo(this.$$cont);
}

/* Core methods */
// Asynchronous interactions common stub (flash commands handler)
Wrapper.prototype._dispatchFxCommand = function(command, args) {
    // Busy... bye, bye! For the future : implement an interaction stack (asynchronous compliant)...
    if (this._isReplyPending()) {
        return;
    }
    this.replyPending = true;

    // Parse arguments
    var wTokenInter = command.split("_");
    this.curCmdCtx = {
        "_cmd": command,
        "_id": wTokenInter[0],
        "_args": args,
        "_opt": (wTokenInter.length > 1 ? wTokenInter.slice(1).join("_") : null)
    };

    // Process command
    this._trace("inf", "Process command '" + command + "' with args [" + args + "]");

    var adapter = this.hosterData.instance && this.hosterData.instance.page && this.hosterData.instance.page.externalAdapter;
    var doIt = true;
    if (adapter && adapter.onFLashCommand) {
        doIt = adapter.onFLashCommand({
            field: this.hosterData.instance,
            context: this.curCmdCtx
        });
    }
    if (doIt) {
        this[this.curCmdCtx._id] ? this[this.curCmdCtx._id]() : this.fxnamedsvccall();
    }
};

// Answer to asynchronous flash command
Wrapper.prototype._answerFxCommand = function(answerObj) {
    this._populateFxData(answerObj, this.curCmdCtx._cmd);
    this.replyPending = false;
    this.curCmdCtx._cmd = null;
};

// Populate data to flash 
Wrapper.prototype._populateFxData = function(dataObj, command) {
    var res = "xflashreqcode==" + command;
    _.each(dataObj, function(value, key) {
        if (value) {
            res += "&&" + key + "==" + (_.isString(value) ? this._killNL(value) : value);
        }
    }, this);
    try {
        this.elt.SetVariable("/_root/xstatic1:ganswer", res);
        this.elt.TCallLabel("/_root/xstatic1", "lblrecall");
    } catch (ex) {
        // TODO : improve
        alert("Error during populate Flash data : " + ex.message);
    }
};

// Wrap data reply in an object
Wrapper.prototype._wrapFxDataInObj = function(data) {
    return {
        "xdata": data
    };
};

// Is reply pending?
Wrapper.prototype._isReplyPending = function(data) {
    if (!this.replyPending) {
        return false;
    } else {
        this._trace("wrn", "Reply pending (request '" + this.curCmdCtx._id + "'), can't accept Flash command!");
        return true;
    }
};

// Asynchronous interactions stub
Wrapper.prototype.fxgetinitialdata = function() {
    /**
     * Scope                        : All components
     * Input (this.curCmdCtx._args) : -
     * Asynchronous reply           : data...
     * Remark                       : If data are pending, direct reply. Else, send request to host
     */
    if (!this.hosterData.instance.fxgetinitialdata) {
        this.fxOnError({
            "message": "TO TRANSLATE - Hoster interface is not implemented : '" + this.curCmdCtx._args + "'",
            "severity": "error"
        });
    }
    if (this.pendingData) {
        if (!this.opts.xmlNative && !this.pendingData.meta && _.isArray(this.pendingData.data)) {
            this.hosterData.instance.fxgetinitialdata(this.fxOnGetdataDone, this.hosterData);
        } else {
            this.fxOnGetdataDone(null, null, null);
        }
    } else {
        this.hosterData.instance.fxgetinitialdata(this.fxOnGetdataDone, this.hosterData);
    }
};

Wrapper.prototype.fxgetctxmenu = function() {
    /**
     * Scope                        : Graph with "Grid" datasource
     * Input (this.curCmdCtx._args) : "<MNR C='1' L='2' UUID='d3e97372-21c1-40ac-e'/>" ==> C=Click number, L=Line, UUID ==> Unique Id
     * Asynchronous reply           : Menus desc for the lineor
     */
    var links, $$xmlArgs = $($.parseXML(this.curCmdCtx._args)),
        $$mmrNode, line, uuid;
    if ($$xmlArgs) {
        $$mmrNode = $$xmlArgs.find("MNR");
        line = parseInt($$mmrNode.attr("L"), 10);
        this.curCmdCtx.countAttr = $$mmrNode.attr("C");
        uuid = $$mmrNode.attr("UUID") || line.toString();
        links = this._getLinksFromCurrData();
        if (this.opts.legacyLinks || !links || this.currentData.$links.$lazyload) {
            if (this.hosterData.instance.fxgetctxmenu) {
                this.hosterData.instance.fxgetctxmenu(this.fxOnGetCtxMenuDone, this.hosterData, (this.opts.legacyLinks ? line : uuid));
            } else {
                this.fxOnError({
                    "message": "TO TRANSLATE - Hoster interface is not implemented : '" + this.curCmdCtx._args + "'",
                    "severity": "error"
                });
            }
        } else if (links) {
            // We use the links defined in the current prototype...
            var mnuDesc = [];
            _.each(links, function(link, idx) {
                mnuDesc[mnuDesc.length] = {
                    "$title": link.title,
                    "linkId": this._getCanonicalLink(line, idx)
                };
            }, this);
            this.fxOnGetCtxMenuDone(null, mnuDesc);
        }
    } else {
        this.fxOnError({
            "message": "TO TRANSLATE - Malformed request : '" + this.curCmdCtx._args + "'",
            "severity": "error"
        });
    }
};

Wrapper.prototype.fxsendctxaction = function(options) {
    /**
     * Scope                        : All components
     * Input (this.curCmdCtx._args) : "14214" ==> "actionId"
     * Asynchronous reply           : Nothing - command without reply... so we swicth the "pending" flag here
     */
    this.replyPending = false;
    var link = this._getLinkObjFromCanonical(this.curCmdCtx._args);
    if (this.hosterData.instance.fxexeclink) {
        this.hosterData.instance.fxexeclink(this.fxOnDummy, this.hosterData, this._getLinkObj(link), options);
    }
};

Wrapper.prototype.fxlinktox3 = function() {
    /**
     * Scope                        : All components
     * Input (this.curCmdCtx._args) : "12074,OBJ=TCY&CLES=IT" ==> "Link_Id,Ctx"
     * Asynchronous reply           : Nothing - command without reply... so we swicth the "pending" flag here
     */
    this.fxsendctxaction({
        legacy: true
    });
};

Wrapper.prototype.fxhelpflash = function() {
    /**
     * Scope                        : All components
     * Input (this.curCmdCtx._args) : Flash Help sub Path
     * Asynchronous reply           : Nothing - command without reply... so we swicth the "pending" flag here
     */
    if (this.hosterData.instance.fxhelpflash) {
        this.hosterData.instance.fxhelpflash(this.fxOnDummy, this.hosterData, {
            "key": this.curCmdCtx._args
        });
    }
    this.replyPending = false;
};

Wrapper.prototype.fxhelp = function() {
    /**
     * Scope                        : All components
     * Input (this.curCmdCtx._args) : "xhfield,ABATPAR" ==> "type,token" # type [xhfield,xhffunc,???,... ]
     * Asynchronous reply           : Nothing - command without reply... so we swicth the "pending" flag here
     */
    var tokens = this.curCmdCtx._args.split(",");
    if (tokens && tokens.length > 0) {
        if (this.hosterData.instance.fxhelp) {
            this.hosterData.instance.fxhelp(this.fxOnDummy, this.hosterData, {
                "type": tokens[0],
                "key": (tokens.length > 1 ? tokens[1] : "")
            });
        }
    }
    this.replyPending = false;
};

Wrapper.prototype.fxspro = function() {
    /**
     * Scope                        : All components
     * Input (this.curCmdCtx._args) : "<INTERFL><TYPFL>typeflash</TYPFL><TYPINTER>svcId</TYPINTER><CODE>LVTEST03</CODE></INTERFL>" ==> "flash_type", "svc_type", "ctx"
     * Asynchronous reply           : Service reply
     */
    var request = null;
    if (this.opts.legacyRequest) {
        request = this.curCmdCtx._args;
    } else {
        var $$fxDom = $($.parseXML(this.curCmdCtx._args));
        if ($$fxDom) {
            var $$svcId = $$fxDom.find("TYPINTER"),
                $$fxType = $$fxDom.find("TYPFL");
            request = {
                "svcId": $$svcId.text(),
                "fxType": $$fxType.text(),
                "svcData": {
                    "id": "INTERFL",
                    "attrs": {}
                }
            };
            $$svcId.remove();
            $$fxType.remove();
            $$fxDom.find("INTERFL").children().each(function() {
                var $$elt = $(this);
                request.svcData.attrs[$$elt.prop("nodeName")] = $$elt.text();
            });
        }
    }
    if (request && this.hosterData.instance.fxspro) {
        this.hosterData.instance.fxspro(this.fxOnStdSvcDone, this.hosterData, request);
    } else {
        this.fxOnError({
            "message": request ? "TO TRANSLATE - Hoster interface is not implemented'" : "TO TRANSLATE - Malformed request : '" + this.curCmdCtx._args + "'",
            "severity": "error"
        });
    }
};

Wrapper.prototype.fxgetprevstatlevel = function() {
    /**
     * Scope                        : Graph
     * Input (this.curCmdCtx._args) : XML string, like "<tagname attr_name='attr_value'  attr_name='attr_value'/>"
     * Asynchronous reply           : Service reply
     * Remark                       : For X3 legacy, service request has just a string parameter : "idData,attr_name=attr_value[,...]";
     *                                "iData" is the datasource name (metadata of the component)
     */
    this._fxprocessdrill(this.curCmdCtx._args, "out");
};

Wrapper.prototype.fxgetnextstatlevel = function() {
    /**
     * Scope                        : Graph
     * Input (this.curCmdCtx._args) : XML string, like "<tagname attr_name='attr_value'  attr_name='attr_value'/>"
     * Asynchronous reply           : Service reply
     * Remark                       : For X3 legacy, service request has just a string parameter : "idData,attr_name=attr_value[,...]";
     *                                "iData" is the datasource name (metadata of the component)
     */
    this._fxprocessdrill(this.curCmdCtx._args, "in");
};

Wrapper.prototype._fxprocessdrill = function(fxcmd, zoomWhat) {
    var drillParams = this._getfxDrillParams(fxcmd);
    var i = this.currentData._drillDef.currAxisHier;
    var hier = this.currentData.$axes[0].$hierarchies,
        idxHier;
    var mem = this.currentData.$axes[0].$members;
    if (zoomWhat == "out") {
        if (hier[i][2] > 0) {
            hier[i][2]--;
            idxHier = i;
        } else {
            hier[i][1] = 0;
            hier[i][2] = 0;
            hier[i - 1][1] = 1;
            hier[i - 1][2] = this.currentData.$cube.$hierarchies[hier[i - 1][0]].$properties.length - 1;
            idxHier = i - 1;
        }
        if (mem[idxHier].length > 1) {
            mem[idxHier].pop(mem[idxHier].length - 1);
        } else {
            mem.pop(idxHier);
        }
    } else {
        if (hier[i][2] == (this.currentData.$cube.$hierarchies[hier[i][0]].$properties.length - 1)) {
            hier[i][1] = 0;
            hier[i][2] = 0;
            hier[i + 1][1] = 1;
            hier[i + 1][2] = 0;
            idxHier = i;
        } else {
            hier[i][2]++;
            idxHier = i;
        }
        if (!mem) {
            mem = this.currentData.$axes[0].$members = [
                []
            ];
        }
        if (mem.length < idxHier + 1) {
            mem[idxHier] = [];
        }
        mem[idxHier].push(new Array(drillParams ? drillParams.drillData.memberValue : "???"));
    }

    if (this.hosterData.instance.fxexecdrill) {
        this.hosterData.instance.fxexecdrill(this.fxOnDrillDone, this.hosterData, this.currentData);
    } else {
        this.fxOnError({
            "message": "TO TRANSLATE - Hoster interface is not implemented'" + this.curCmdCtx._args + "'",
            "severity": "error"
        });
    }
    this.replyPending = false;

};

Wrapper.prototype._getfxDrillParams = function(fxcmd) {
    var $$fxDom = $.parseXML(fxcmd),
        drillParams = null,
        critMax = 0,
        kCrit = "criterion",
        test;
    if ($$fxDom) {
        if (!this.opts.legacyRequest) {
            drillParams = {
                "svcId": this.curCmdCtx._id,
                "drillData": {
                    "id": $$fxDom.documentElement.nodeName,
                    "attrs": {}
                }
            };
            _.each($$fxDom.documentElement.attributes, function(attr) {
                this.attrs[attr.name] = attr.value;
                if (attr.name.substr(0, kCrit.length).toLocaleLowerCase() === kCrit) {
                    test = parseInt(attr.name.substr(kCrit.length), 10);
                    if (test > critMax) {
                        critMax = test;
                        this.memberValue = attr.value;
                    }
                }
            }, drillParams.drillData);
        } else {
            drillParams = this.opts.iSvcDataSrcId;
            _.each($$fxDom.documentElement.attributes, function(attr) {
                drillParams += "," + attr.name + "=" + attr.value;
            });
        }
    }

    return drillParams;
};

Wrapper.prototype.fxnamedsvccall = function() {
    /**
     * Scope                        : All components
     * Input (this.curCmdCtx._args) : XML string, like "<tagname attr_name='attr_value'  attr_name='attr_value'/>"
     * Asynchronous reply           : Service reply
     * Remark                       : For X3 legacy, service request has just a string parameter : "idData,attr_name=attr_value[,...]";
     *                                "iData" is the datasource name (metadata of the component)
     */
    var $$fxDom = $.parseXML(this.curCmdCtx._args),
        request = null;
    if ($$fxDom) {}
    if (request && this.hosterData.instance.fxnamedsvccall) {
        this.hosterData.instance.fxnamedsvccall(this.fxOnNamedSvcDone, this.hosterData, request);
    } else {
        this.fxOnError({
            "message": $$fxDom ? "TO TRANSLATE - Hoster interface is not implemented'" : "TO TRANSLATE - Malformed request : '" + this.curCmdCtx._args + "'",
            "severity": "error"
        });
    }
};

Wrapper.prototype.fxoverlap = function() {
    /**
     * Scope                        : All components
     * Remark                       : Obsolete
     */
    this.replyPending = false;
};


// Asynchronous interactions Replies
Wrapper.prototype.fxOnGetdataDone = function(err, data, meta) {
    if (err) this.fxOnError(err);
    else {
        if (this.pendingData) this._answerFxCommand(this._wrapFxDataInObj(this._processDataIn(this.pendingData.data || data || null, this.pendingData.meta || meta || null)));
        else this._answerFxCommand(this._wrapFxDataInObj(this._processDataIn(data, meta)));
        this.firstDataDone = true;
        this.pendingData = null;
    }
};

Wrapper.prototype.fxOnGetCtxMenuDone = function(err, mnuDesc) {
    /**
     * Format : xdata="<MN><MI I="linkid"><![CDATA[label]]></MI><MI I="linkid"><![CDATA[label]]></MI></MN>"
     *          xcounter=number (click counter )
     */
    if (err) {
        this.fxOnError(err);
        return;
    }
    var reply = "<MN>",
        debug = (_fixture ? " from : " + this.id : "");
    if (mnuDesc) {
        var data = _.isArray(mnuDesc) ? mnuDesc : [mnuDesc];
        _.each(data, function(mnu) {
            if (mnu.$title && mnu.$title.length > 0 && mnu.linkId) reply += '<MI I="' + mnu.linkId + '"><![CDATA[' + mnu.$title + debug + ']]></MI>';
        }, this);
    }
    var objReply = this._wrapFxDataInObj(reply + "</MN>");
    objReply.xcounter = this.curCmdCtx.countAttr;
    this._answerFxCommand(objReply);
};

Wrapper.prototype.fxOnStdSvcDone = function(err, reply) {
    /**
     * Format : xdata="<X3PORTAL><Data><Result><vv>www</vv><xx>yyy</xx></Result></Data></X3PORTAL>"
     *          or
     *          xdata="<X3PORTAL>...full data flow...</X3PORTAL>"
     */
    if (err) {
        this.fxOnError(err);
        return;
    }
    if (this.opts.xmlNative) {
        this._answerFxCommand(this._wrapFxDataInObj(reply));
    } else {
        var xmlResult = "";
        if (reply.result) {
            xmlResult = '<X3PORTAL><Data><Result>';
            _.each(reply.result, function(value, key) {
                xmlResult += "<" + key + ">" + value + "</" + key + ">";
            });
            xmlResult += '</Result></Data></X3PORTAL>';
        } else if (reply.data) {
            xmlResult = this._processDataIn(reply.data, null);
        }
        if (xmlResult.length > 0) this._answerFxCommand(this._wrapFxDataInObj(xmlResult));
        else this.fxOnError({
            "message": "TO TRANSLATE : Bad response from server",
            "severity": "error"
        });
    }
};

Wrapper.prototype.fxOnDrillDone = function(err, reply) {
    (err ? this.fxOnError(err) : this._answerFxCommand(this._wrapFxDataInObj(this._processDataIn(reply, null))));
};

Wrapper.prototype.fxOnNamedSvcDone = function(err, reply) {
    (err ? this.fxOnError(err) : this._answerFxCommand(this._wrapFxDataInObj(this._processDataIn(reply, null))));
};

Wrapper.prototype.fxOnDummy = function(err, dummy) {
    if (err) this.fxOnError(err);
};

Wrapper.prototype.fxOnError = function(diagnoses) {
    var fxErr = new FlashError(diagnoses, this.id);
    this._answerFxCommand(this._wrapFxDataInObj('<X3PORTAL>' + fxErr.getXML() + '</X3PORTAL>'));
    // this._answerFxCommand(this._wrapFxDataInObj({X3PORTAL: fxErr.getJS()}));
};

// Synchronous calls
Wrapper.prototype.cleanUp = function() {
    if (_.isFunction(this.elt.ERPClear)) this.elt.ERPClear();
};

Wrapper.prototype.isDirty = function() {
    if (this._isReplyPending()) return false;
    if (_.isFunction(this.elt.GetPadDocDataToSave)) {
        // Not yet implemented
    }

    return true;
};

Wrapper.prototype.getData = function() {
    if (this._isReplyPending()) return null;
    if (_.isFunction(this.elt.GetPadDocDataToSave)) {
        var data = this.elt.GetPadDocDataToSave();
        this._trace("inf", data.substring(0, 150) + "...");
        return data;
    } else return null;
};

Wrapper.prototype.setData = function(data, meta) {
    // We use the Asynchronous reply method to populate the data!!!
    if (data) {
        this.rawData = data;
        if ((this.firstDataDone) && (this.rawData) && (this.rawData.length > 1)) this._populateFxData(this._wrapFxDataInObj(this._processDataIn(data, meta)), this.curCmdCtx._cmd || "fxdataupdated");
        else {
            // Data retention... waiting for "fxgetinitialDataFlash" command
            this.pendingData = {
                "data": data || null,
                "meta": null
            };
        }
    }

    return true;
};

Wrapper.prototype.setFrameSize = function(width, heigth) {
    // We use the Asynchronous reply method to populate the size - Size in pixels.
    if (width || heigth) {
        var objReply = {
            "pwidth": width || null,
            "pheight": heigth || null
        };
        this._populateFxData(objReply, "fxgetframesize");
    }
};

// Wrapper public methods
Wrapper.prototype.setHostData = function(hosterData) {
    this.hosterData = hosterData || {};
};

// Dispose
Wrapper.prototype.dispose = function() {
    this.cleanUp();
    if (!$.browser.msie) {
        delete window[this.id + "_DoFSCommand"];
    }
    delete this.$$cont;
    delete this.hosterData.instance;
    delete this.hosterData;
};


// Helper methods
Wrapper.prototype._initProps = function() {
    // DHTML Flash container Object propertie
    this.$$cont = _.isString(this.props.cont) ? $("#" + this.props.cont) : this.props.cont;

    // DHTML Flash Object properties
    _.defaults(this.props, {
        "embedId": "voidid_",
        "align": "left",
        "width": "100%",
        "height": "100%",
        "base": ".",
        "bgcolor": "#ffffff"
    });

    // Main swf full name
    var len = this.props.swf.length;
    if (this.props.swf.charAt(len - 1) === "/" || this.props.swf.charAt(len - 1) === "\\") this.props.swf = this.props.swf.substr(0, len - 1);
    this.props.swf += "/xstart_portal.swf";
};

Wrapper.prototype._killNL = function(inStr) {
    // Remove \r (0D), \n (0A), \t (09) from xml string
    if (inStr && inStr.length > 0) {
        var re = new RegExp("\\r|\\n|\\t", "g");
        return inStr.replace(re, "");
    } else {
        return inStr;
    }
};

Wrapper.prototype._getCanonicalLink = function(uuid, linkId) {
    return linkId + "," + uuid;
};

Wrapper.prototype._getLinkObjFromCanonical = function(canonicalLink) {
    var link = {},
        tabLink = canonicalLink.split(",");
    if (tabLink.length < 2) {
        link.linkId = canonicalLink;
        link.linkCtx = "";
    } else {
        link.linkId = tabLink[0];
        link.linkCtx = tabLink[1];
    }

    return link;
};

Wrapper.prototype._trace = function(type, mess) {
    _log && console.log("FlashWrapper: " + type + " - " + mess)
    if (!_debug) return;
    if (type != "inf") alert("Object \"" + this.id + "\" : \n" + mess);
    if (this.opts.messCont) $("#" + this.opts.messCont).text("Object \"" + this.id + "\" : \n" + mess);
};

/* JSON Data Protocol to Flash XML document methods*/
// Deal with data sent by hoster
Wrapper.prototype._processDataIn = function(data, meta) {
    if (this.opts.xmlNative) {
        return this.currentData = data;
    } else {
        this.currentData = this.currentData || {};
        this.currentData.$diagnoses = (meta && meta.$diagnoses ? meta.$diagnoses : (data && data.$diagnoses ? data.$diagnoses : null));
        var transformer = this['_' + this.typeInfo.name + '_DataJson2Xml'],
            xml = transformer && transformer.call(this, data, meta);
        _log && console.log("FlashWrapper._processDataIn: xml=" + xml);
        return xml;
    }
};

// Get graph definition object
Wrapper.prototype._getGraphDef = function(data, rawData) {
    // Init
    var graphDef = {
        "_metaData": {},
        "_drillDef": null
    },
        currAxisHier = 0;

    // Misc
    var axeTitle = null,
        measuresTitle = this.hosterData.instance.getFieldEvalTitle();
    var isOK = (data.$cube && data.$cube.$hierarchies && data.$axes && data.$axes.length > 0 && data.$axes[0].$hierarchies && data.$axes[0].$hierarchies.length > 0 ? true : false);
    graphDef._metaData.measuresDefinition = (data._metaData && data._metaData.measuresDefinition ? data._metaData.measuresDefinition : {});
    graphDef._metaData.isMetaOK = true;
    graphDef._metaData.provType = rawData.$provType || this.provType;

    // Get graph title
    if (measuresTitle && data.$axes[0].$hierarchies[0].length > 0) {
        axeTitle = measuresTitle[data.$axes[0].$hierarchies[0][0]];
    }
    if (!axeTitle && data.$axes && data.$axes.length > 0) {
        axeTitle = data.$axes[0].$title;
    }
    graphDef._metaData.title = (data.$cube && data.$cube.$title ? data.$cube.$title : "");
    if (axeTitle && graphDef._metaData.title != axeTitle) graphDef._metaData.title += ' / ' + axeTitle;

    // Get axis analysis
    if (isOK) {
        var mainHLevelsTab = null;
        _.each(data.$axes[0].$hierarchies, function(hierarchie, idx) {
            if (!mainHLevelsTab && hierarchie.length > 1 && hierarchie[1] == 1) {
                mainHLevelsTab = data.$cube.$hierarchies[hierarchie[0]].$properties;
                if (mainHLevelsTab) {
                    graphDef._metaData.axis0FieldCode = mainHLevelsTab[hierarchie.length > 2 ? hierarchie[2] : 0];
                    currAxisHier = idx;
                }
            }
        });
        if (!mainHLevelsTab && data.$axes[0].$hierarchies[0].length > 0) {
            mainHLevelsTab = data.$cube.$hierarchies[data.$axes[0].$hierarchies[0][0]].$properties;
            if (mainHLevelsTab && mainHLevelsTab.length > 0) graphDef._metaData.axis0FieldCode = mainHLevelsTab[0];
        }
    }

    // Is axis a "reference" field?
    if (graphDef._metaData.axis0FieldCode && data.$properties[graphDef._metaData.axis0FieldCode].$type == "application/x-reference" && data.$properties[graphDef._metaData.axis0FieldCode].$value) {
        graphDef._metaData.xRefAxis0FieldCode = data.$properties[graphDef._metaData.axis0FieldCode].$value.substr(1, match.length - 2);
    }

    // Get measures definition. If measures are not defined in the second axis members (Cf. specs), we used all the measures defined in the cube
    var measures, restraintMeasures;
    measures = (data.$cube && data.$cube.$measures ? data.$cube.$measures : null);
    if (measures) {
        restraintMeasures = measures;
        if (isOK && data.$axes.length > 1 && data.$axes[1].$members && data.$axes[1].$members[0][0].length > 0) {
            restraintMeasures = {};
            _.each(data.$axes[1].$members[0][0], function(measureCode) {
                restraintMeasures[measureCode] = measures[measureCode];
            });
        }
        _.each(restraintMeasures, function(measure, key) {
            // Because duplicate properties is possible for cube definition... we keep the last defined
            var code = (measure.$property || key);
            graphDef._metaData.measuresDefinition[code] = {
                "property": code,
                "title": measuresTitle && measuresTitle[code] || measure.$title || data.$properties[code].$title || "???",
                "definition": measure,
                "xRefCode": null
            };
            // Reference field?
            if (data.$properties[code].$type == "application/x-reference" && data.$properties[code].$value) {
                graphDef._metaData.measuresDefinition[code].xRefCode = data.$properties[code].$value.substr(1, match.length - 2);
            }
        });
    }

    // Get links...
    graphDef._metaData.links = [];
    if (data.$links) {
        _.each(data.$links, function(link, id) {
            if (id !== "$lazyload") {
                graphDef._metaData.links.push(this._getSyraLinkDesc("$links", id, link));
            }
        }, this);
    }
    if (data.$actions) {
        _.each(data.$actions, function(link, id) {
            graphDef._metaData.links.push(this._getSyraLinkDesc("$actions", id, link));
        }, this);
    }
    if (graphDef._metaData.axis0FieldCode && data.$properties[graphDef._metaData.axis0FieldCode].$thumb && data.$properties[graphDef._metaData.axis0FieldCode].$thumb.$links) {
        _.each(data.$properties[graphDef._metaData.axis0FieldCode].$thumb.$links, function(link, id) {
            graphDef._metaData.links.push(this._getSyraLinkDesc("$links", id, link));
        }, this);
    }
    if (graphDef._metaData.xRefAxis0FieldCode && data.$properties[graphDef._metaData.axis0FieldCode].$links) {
        _.each(data.$properties[graphDef._metaData.axis0FieldCode].$links, function(link, id) {
            graphDef._metaData.links.push(this._getSyraLinkDesc("$links", id, link));
        }, this);
    }

    // Get drill definition
    if (graphDef._metaData.provType == "PORTALSTA" && isOK) {
        var properties;
        graphDef._drillDef = {
            "minLevel": 1,
            "maxLevel": 0,
            "currLevel": 1,
            "currAxisHier": currAxisHier,
            "levelsProperties": [],
            "members": [],
            "code": rawData.$codeStat || "UNKNOWN",
            "axis0FieldCode": graphDef._metaData.axis0FieldCode || "",
            "xRefAxis0FieldCode": graphDef._metaData.xRefAxis0FieldCode || null
        };
        _.each(data.$axes[0].$hierarchies, function(hierarchie) {
            properties = data.$cube.$hierarchies[hierarchie[0]].$properties;
            _.each(properties, function(property) {
                this.levelsProperties[this.maxLevel++] = property;
            }, graphDef._drillDef);
        });
        graphDef._drillDef.maxLevel = (graphDef._drillDef.maxLevel > graphDef._drillDef.minLevel ? graphDef._drillDef.maxLevel : graphDef._drillDef.minLevel);
        if (data.$axes[0].$members) {
            _.each(data.$axes[0].$members, function(tuple) {
                _.each(tuple, function(value) {
                    if (value.length > 0) {
                        this.members[this.currLevel++-1] = value[0];
                    }
                }, this);
            }, graphDef._drillDef);
        }
    }

    // All mandatory meta-data available? 
    if (!graphDef._metaData.axis0FieldCode || !data.$properties || _.isEmpty(graphDef._metaData.measuresDefinition)) graphDef._metaData.isMetaOK = false;

    return graphDef;
};

// Get graph style properties
Wrapper.prototype._getGraphStyle = function(cubeDef, measuresDef) {
    // Init
    var graphStyle = {},
        trick = {},
        mStyle = "XPIE",
        mStyleEX = "",
        mStyleCode = "",
        mStyleEXCode = "",
        mDefault = null;
    var msCode = new Array(measuresDef.length),
        msCodeStyle = new Array(measuresDef.length),
        i = 0;

    // Go
    if (cubeDef.$style == "pie") {
        _.each(measuresDef, function(measure) {
            msCode[i++] = measure.property;
            if (measure.definition.$isDefault) mDefault = measure.property;
        });
    } else {
        _.each(measuresDef, function(measure) {
            // So, "xy" style
            switch (measure.definition.$style) {
            case "stick":
                mStyle = "XBAR";
                mStyleCode = "b";
                break;
            case "line":
                mStyle = "XLINE";
                mStyleCode = "l";
                break;
            case "area":
                mStyle = "XAREA";
                mStyleCode = "a";
                break;
            }
            if (measure.definition.$isStacked) {
                mStyleEX = "CU";
                mStyleEXCode = "cu";
            } else if (measure.definition.$isNormalized) {
                mStyleEX = "CO";
                mStyleEXCode = "co";
            }
            if (measure.definition.$isDefault) mDefault = measure.property;

            msCode[i] = measure.property;
            msCodeStyle[i++] = measure.property + "," + mStyleCode + mStyleEXCode;
            trick[mStyle + mStyleEX] = "";
        });
    }

    // Debrief...
    // What about type "FGRSD" ?
    if (_.size(trick) <= 1) {
        graphStyle.type = "FGRS";
        if (cubeDef.$displaysOneMeasure) graphStyle.measureStyle = mStyle;
        else if (mStyleEX.length === 0) graphStyle.measureStyle = mStyle + "M";
        else graphStyle.measureStyle = mStyle + mStyleEX;
        graphStyle.measuresList = msCode.join(";");
    } else {
        graphStyle.type = "FGRP";
        graphStyle.measureStyle = "XPERSO";
        graphStyle.measuresList = msCodeStyle.join(";");
    }

    // Misc properties
    graphStyle.defaultMeasures = (!cubeDef.$displaysOneMeasure ? msCode.join(";") : (mDefault ? mDefault : msCode[0]));
    graphStyle.hasMeasureSelector = (_.isUndefined(cubeDef.$hasMeasureSelector) ? "2" : (cubeDef.$hasMeasureSelector ? "2" : "1"));
    graphStyle.hasStyleSelector = (_.isUndefined(cubeDef.$hasStyleSelector) ? "2" : (cubeDef.$hasStyleSelector ? "2" : "1"));

    return graphStyle;
};

// Retrieve Syra link from link definition : {"$item":resource obj, "$links" or "$actions": {"$linkname":link obj}}
Wrapper.prototype._getLinkObj = function(link) {
    var links = this._getLinksFromCurrData();
    if (!this.opts.legacyLinks && link.linkId && links && links.length > 0) {
        var linkSyra = {},
            linkObj = {};
        linkSyra.$item = this.currentData.$resources[link.linkCtx];
        linkObj[links[link.linkId].id] = links[link.linkId].link;
        linkSyra[links[link.linkId].type] = linkObj;
        return linkSyra;
    } else {
        return link;
    }
};

// Build a syra link full description object (type : "$link", "$action"... id = "$edit", $delete, etc...)
Wrapper.prototype._getSyraLinkDesc = function(type, id, objLink) {
    return {
        "type": type,
        "id": id,
        "link": objLink,
        "title": objLink.$title
    };
};

// Retrieve a link idx in the link collection, by type and id
Wrapper.prototype._getLink = function(type, id) {
    var links = this._getLinksFromCurrData(),
        i = 0;
    if (!this.opts.legacyLinks && links) {
        for (i = 0; i < links.length; i++) {
            if (links[i].type === type && links[i].id === id) {
                break;
            }
        }
        return (i < links.length ? i : null);
    } else {
        return null;
    }
};

// Retrieve "$links" from prototype
Wrapper.prototype._getLinksFromCurrData = function() {
    if (this.currentData._metaData) return this.currentData._metaData.links;
    else return null;
};

// Build XML document expected by graph component, from JSON hyper-cube protocol (Syracuse specs)
Wrapper.prototype._graph_DataJson2Xml = function(rawData, meta) {
    // Data mapping
    var hasMetaChanged = false,
        realRawData = null;
    if (rawData && _.isArray(rawData)) {
        this.currentData.$resources = rawData;
        realRawData = meta || null;
    }
    realRawData = realRawData || rawData || meta;
    if (realRawData) {
        if (realRawData.$item && realRawData.$item.$properties) {
            this.currentData.$properties = realRawData.$item.$properties;
            hasMetaChanged = true;
        }
        if (realRawData.$cube) {
            this.currentData.$cube = realRawData.$cube;
            hasMetaChanged = true;
        }
        if (realRawData.$axes) {
            this.currentData.$axes = realRawData.$axes;
            hasMetaChanged = true;
        }
        if (realRawData.$slicer) {
            this.currentData.$slicer = realRawData.$slicer;
            hasMetaChanged = true;
        }
        if (realRawData.$item && realRawData.$item.$links) {
            this.currentData.$links = realRawData.$item.$links;
            hasMetaChanged = true;
        }
        if (realRawData[this.opts.dataBinding]) this.currentData.$resources = realRawData[this.opts.dataBinding];
    }

    // Get graph meta-data
    if (hasMetaChanged) _.extend(this.currentData, this._getGraphDef(this.currentData, realRawData));
    var graphDef = {
        "_metaData": this.currentData._metaData,
        "_drillDef": this.currentData._drillDef
    };

    // "Titles" Tag. Warning : first we check the resources collection; if no data, we build just a minimal "Titles" Tag
    var xmlTitlesTag = ["<Titles><Title>", graphDef._metaData.title, "</Title>"],
        nbMeasures = 0;
    if (!graphDef._metaData.isMetaOK) {
        graphDef._metaData.axis0FieldCode = "DEFLIB";
        xmlTitlesTag.push("<ColTitle Num='1' Nam='", graphDef._metaData.axis0FieldCode, "' X3Type='7'>Default</ColTitle>");
        xmlTitlesTag.push("<ColTitle Num='2' Nam='", graphDef._metaData.axis0FieldCode, "' X3Type='4'></ColTitle>");
        xmlTitlesTag.push("</Titles>");
    } else {
        xmlTitlesTag.push('<ColTitle Num="1" Nam="', graphDef._metaData.axis0FieldCode, '" X3Type="7">', (this.currentData.$properties[graphDef._metaData.axis0FieldCode].$title || "???"), '</ColTitle>');
        _.each(graphDef._metaData.measuresDefinition, function(measureDef) {
            xmlTitlesTag.push('<ColTitle Num="', (2 + nbMeasures++), '" Nam="', measureDef.property, '" X3Type="4">', measureDef.title, '</ColTitle>');
        });
        xmlTitlesTag.push("</Titles>");
    }

    // "Lines" Tag. Iterates over data collection and builds "Lines" Tag... some differences between Graph classes...
    var xmlLinesTag = new Array((this.currentData.$resources ? (this.currentData.$resources.length + 2) : 2)),
        xmlLineTag, colNum, value, detailLinkIdx = null,
        detailLink;
    xmlLinesTag[0] = "<Lines>";
    if (this.currentData.$resources && graphDef._metaData.isMetaOK) {
        if (graphDef._metaData.provType != "TABLEBLOC") {
            detailLinkIdx = this._getLink("$links", "$details");
        }
        _.each(this.currentData.$resources, function(occur, idx) {
            // "Dimension analys" data
            colNum = 1;
            value = (typeof(occur[graphDef._metaData.axis0FieldCode]) === 'object' ? (graphDef._metaData.xRefAxis0FieldCode ? occur[graphDef._metaData.axis0FieldCode][graphDef._metaData.xRefAxis0FieldCode] : occur[graphDef._metaData.axis0FieldCode].code) : occur[graphDef._metaData.axis0FieldCode]);
            xmlLineTag = new Array(nbMeasures + 3);
            if (graphDef._metaData.provType == "TABLEBLOC") xmlLineTag[0] = '<line Num="' + idx + '" Uuid="' + occur['$uuid'] + '"><col><v>' + value + '</v></col>';
            else {
                // Warning : Graph flash component for "PORTALSTA" & "PORTALREQ" data source supports just one link by occurence... 
                detailLink = (detailLinkIdx !== null ? (' X3Link="' + this._getCanonicalLink(idx.toString(10), detailLinkIdx) + '"') : "");
                xmlLineTag.push('<line Num="', idx, '"><col X3Type="7" Num="', colNum++, '"', detailLink, '><v>', value, '</v></col>');
            }

            // "Measure" data
            _.each(graphDef._metaData.measuresDefinition, function(measureDef) {
                value = (typeof(occur[measureDef.property]) === 'object' ? (measureDef.xRefCode ? occur[measureDef.property][measureDef.xRefCode] : occur[measureDef.property].code) : occur[measureDef.property]);
                xmlLineTag.push('<col X3Type="4" Num="', colNum++, '"><v>', value, '</v></col>');
            });

            // Drill meta-data
            if (graphDef._drillDef && graphDef._drillDef.currLevel < graphDef._drillDef.maxLevel) {
                var criterionTab = new Array(graphDef._drillDef.currLevel);
                criterionTab[graphDef._drillDef.currLevel - 1] = "<Criterion" + graphDef._drillDef.currLevel + ">" + (graphDef._drillDef.xRefAxis0FieldCode ? occur[graphDef._drillDef.axis0FieldCode][graphDef._drillDef.xRefAxis0FieldCode] : occur[graphDef._drillDef.axis0FieldCode]) + "</Criterion" + graphDef._drillDef.currLevel + ">";
                for (var i = 1; i < graphDef._drillDef.currLevel; i++) {
                    criterionTab[i - 1] = "<Criterion" + i + ">" + graphDef._drillDef.members[i - 1] + "</Criterion" + i + ">";
                }
                xmlLineTag.push('<Zoom><Level>', (graphDef._drillDef.currLevel + 1), '</Level><Criteria>', criterionTab.join(""), '</Criteria></Zoom>');
            }

            // Finished!
            xmlLineTag.push("</line>");
            xmlLinesTag.push(xmlLineTag.join(""));
        }, this);
    }
    xmlLinesTag.push("</Lines>");

    // "Technical" Tag
    var techTag = [""];
    if (hasMetaChanged) {
        var graphStyle = {};
        if (this.currentData.$cube && graphDef._metaData.measuresDefinition) graphStyle = this._getGraphStyle(this.currentData.$cube, graphDef._metaData.measuresDefinition);
        if (!graphDef._metaData.isMetaOK) {
            // Fixture
            graphStyle.measuresList = "2";
            graphStyle.defaultMeasures = "2";
        }
        graphStyle.provType = graphDef._metaData.provType;
        graphStyle.axis0Name = graphDef._metaData.axis0FieldCode;
        graphStyle.cdLang = this.opts.cdLang;

        // Technical template...
        techTag[0] = "<Technical>";
        techTag.push(_templateTechTag(graphStyle));

        // Add Drill meta-data
        if (graphDef._drillDef) {
            techTag.push('<DataSrc Type="STA" Code="', graphDef._drillDef.code, '" />');
            techTag.push("<MinLevel>", graphDef._drillDef.minLevel, "</MinLevel><CurrentLevel>", graphDef._drillDef.currLevel, "</CurrentLevel><MaxLevel>", (graphDef._drillDef.maxLevel + 1), "</MaxLevel>");
            techTag.push("<Criteria>");
            for (var i = 1; i < graphDef._drillDef.currLevel; i++) {
                techTag.push("<Criterion" + i + ">", graphDef._drillDef.members[i - 1], "</Criterion" + i + ">");
            }
            techTag.push("</Criteria>");
            if (graphDef._drillDef.currLevel > graphDef._drillDef.minLevel) techTag.push("<PrevDetailTitle>", (this.currentData.$properties[graphDef._drillDef.levelsProperties[graphDef._drillDef.currLevel - 2]].$title || "???"), "</PrevDetailTitle>");
            if (graphDef._drillDef.currLevel < graphDef._drillDef.maxLevel) techTag.push("<NextDetailTitle>", (this.currentData.$properties[graphDef._drillDef.levelsProperties[graphDef._drillDef.currLevel]].$title || "???"), "</NextDetailTitle>");
        }
        techTag.push("</Technical>");
    }

    // "Messages" Tag
    var messTag = new FlashError(this.currentData.$diagnoses, this.id);

    // Build the full document
    var xmlDocTag = ["<X3PORTAL><Data>", xmlLinesTag.join(""), xmlTitlesTag.join(""), "</Data>", techTag.join(""), messTag.getXML(), "</X3PORTAL>"];

    return xmlDocTag.join("");
};

// Build XML document expected by processus component "FPADT", from JSON protocol
Wrapper.prototype._padDesigner_DataJson2Xml = function(rawData, meta) {
    // Data mapping
    this.currentData.page = rawData.page || null;
    this.currentData.menuNavig = rawData.menuNavig || null;

    // Go
    var userLang = this.opts && this.opts.userLang || this.opts.cdLang || "BRI";
    // xb = flash.xmlBuilder($decorator.$stereotype, {
    //     uersLang: userLang
    // });
    // xb.addNode("Data.Page", null, null, this.currentData.page);
    // xb.addNode("Data.MainNavig", null, null, this.currentData.menuNavig);
    var xmlDocTag = ['<X3PORTAL><Data><Page><![CDATA[', this.currentData.page || "", ']]></Page>'];
    if (this.currentData.menuNavig) xmlDocTag.push('<MainNavig><![CDATA[', this.currentData.menuNavig, ']]></MainNavig>');
    xmlDocTag.push('</Data>');

    // "Technical" Tag
    xmlDocTag.push('<Technical><VisCmp Type="' + (this.typeInfo.visCmp) + '"></VisCmp><UserLang>' + userLang + '</UserLang></Technical>');

    // "Messages" Tag
    var messTag = new FlashError(this.currentData.$diagnoses, this.id);
    // xb.$.Messages = messTag.getJS();
    xmlDocTag.push(messTag.getXML(), '</X3PORTAL>');

    return xmlDocTag.join("");
};

// Build XML document expected by processus component "FPADP", from JSON protocol
Wrapper.prototype._padPlayer_DataJson2Xml = function(rawData, meta) {
    return this._padDesigner_DataJson2Xml(rawData, meta);
};

Wrapper.prototype._agenda_DataJson2Xml = function(rawData, meta) {
    var proto = null,
        hasMetaChanged = false,
        $$layoutSlot = $(this.hosterData.instance.layoutSlot);


    if (rawData && Array.isArray(rawData)) {
        this.currentData.$resources = rawData;
        proto = meta || null;
    }
    proto = proto || rawData || meta;
    if (proto) {
        if (proto.$item && proto.$item.$properties) {
            this.currentData.$properties = proto.$item.$properties;
            this.$decorator = proto.$decorator;
            hasMetaChanged = true;
        }
    }

    // TODO: How to set it without an hard coded value?
    $$layoutSlot.height("450px");

    var $resources = this.currentData.$resources,
        $properties = this.currentData.$properties,
        $decorator = this.$decorator,
        x3map = $decorator && $decorator.$bindings || {},
        userLang = this.opts && this.opts.userLang || "BRI",
        xb = flash.xmlBuilder($decorator.$stereotype, {
            uersLang: userLang
        });

    xb.addNode("Data.Lines")

    function value(k, r) {
        var key = x3map[k],
            p = key && $properties[key],
            val = key && r[key];
        return p && val && ("" + val);
    };

    function newCol(i, vi, vv, attrs) {
        var node = {
            Col: {
                $: {
                    Num: "" + i
                },
                X3IntVal: {
                    $value: vi
                },
                X3Value: {
                    $value: vv
                }
            }
        }
        if (attrs) {
            forEachKey(attrs, function(k, v) {
                node.Col.$[k] = v;
            });
        }
        return node;
    };

    // Technical node: FCSELC boolean for caleandar selector 1 = false, 2 = true
    //  1 TYPACT    : FCTYPE ==> val                                (see Flash function: fgetAgdType)
    //  2 KEYACT    : FCCHRONO ==> val, att                         (see Flash function: fgetAgdChrono)
    //  3 DATDI     : FCDATEDEB ==> int (DATD ==> val not used)     (see Flash function: fgetSDate)
    //  4 HEUDI     : FCHEURDEB ==> int                             (see Flash function: fgetSTime)
    //  5 DATFI     : FCDATEFIN ==> int (DATF ==> val not used)     (see Flash function: fgetAgdEDate)
    //  6 HEUF      : FCHEURFIN ==> int                             (see Flash function: fgetETime)
    //  7 TIER      : FCTIERS ==> val                               (see Flash function: fgetAgdTiers)
    //  8 INT       : FCINTERLOC ==> val                            (see Flash function: fgetAgdInterloc)
    //  9 CAT       : FCCATEG ==> val                               (see Flash function: fgetAgdCateg)
    // 10 OBJ       : FCTEXTE ==> int                               (see Flash function: fgetDescrs)
    // 11 EXE       : FCSTATUS ==> int                              (see Flash function: fgetAgdStatus)
    var cols = ["TYPACT", "KEYACT", "DATDI", "HEUD", "DATFI", "HEUF", "TIER", "INT", "CAT", "OBJ", "EXE"];

    $resources.filter(function(r, i) {
        return value("TYPACT", r) !== "-1"
    }).forEach(function(r, i) {
        var actionCode = 0,
            line = xb.addNode("Data.Lines.Line", null, {
                Num: i + 1
            });
        cols.forEach(function(k, i) {
            var vi = value(k, r),
                v = "",
                att;

            // default is to fill the X3IntVal
            switch (k) {
            case "KEYACT":
                att = {
                    X3Link: "x3://12074,OBJET=" + actionCode + "&amp;CLES=" + vi
                };
            case "TYPACT":
                actionCode = ["TSK", "CLL", "BAP"][parseInt(vi, 10) - 1];
            case "TIER":
            case "INT":
            case "CAT":
                v = vi;
                vi = "";
                break;
            case "HEUD":
            case "HEUF":
                v = vi;
                vi = vi.split(":").join("");
                break;
            }
            xb.addChild(line, newCol(i + 1, vi, v, att));
        });
    });

    xb.addNode("Data.Titles.Title", "");
    for (var i = 1; i < 12; i++) {

        xb.addNode("Data.Titles.ColTitle", "", {
            Num: "" + i,
            X3Type: "7"
        });
    }

    var typact = $properties[x3map["TYPACT"]],
        actionEnum = this.actionEnum || (typact && this.hosterData.instance.getEnumeration(typact.$mnu));
    var colors = ["0xFDE6D5", "0xDEF3DD", "0xF9FDD5"];

    // xb.addNode("Data.Categs");
    actionEnum && actionEnum.forEach(function(m, i) {
        xb.addNode("Data.Categs.Categ", m, {
            Id: "" + (i + 1),
            Color: (colors[i] || "")
        });
    });


    if (hasMetaChanged) { // HtcProvType value is 'CLOB' if the flash component is bound to a clob otherwise it's 'TABLEBLOC'
        // The next 2 values are not used by the agenda but only by the calendar
        xb.addNode("Technical.VisCmp.FCCTYPE", "XWEEK");
        xb.addNode("Technical.VisCmp.FCSELC", "2");

        xb.addNode("Technical.VisCmp.FCDATEDEB", "3");
        xb.addNode("Technical.VisCmp.FCDATEFIN", "5");
        xb.addNode("Technical.VisCmp.FCHEURDEB", "4");
        xb.addNode("Technical.VisCmp.FCHEURFIN", "6");
        xb.addNode("Technical.VisCmp.FCCHRONO", "2");
        xb.addNode("Technical.VisCmp.FCTEXTE", "10");
        xb.addNode("Technical.VisCmp.FCTYPE", "1");
        xb.addNode("Technical.VisCmp.FCCATEG", "9");
        xb.addNode("Technical.VisCmp.FCTIERS", "7");
        xb.addNode("Technical.VisCmp.FCINTERLOC", "8");
        xb.addNode("Technical.VisCmp.FCSTATUS", "11");

        xb.addNode("Technical.Action", "INIT");
        xb.addNode("Technical.UsedDataSrcPar.DAYBEF", "10");
        xb.addNode("Technical.UsedDataSrcPar.DAYAFT", "10");
    } else {
        delete xb.$.Technical;
    }
    return xb.xml();
};

Wrapper.prototype._gantt_DataJson2Xml = function(rawData, meta) {
    var proto = null,
        hasMetaChanged = false,
        $$layoutSlot = $(this.hosterData.instance.layoutSlot);

    if (rawData && Array.isArray(rawData)) {
        this.currentData.$resources = rawData;
        proto = meta || null;
    }
    proto = proto || rawData || meta;
    if (proto) {
        if (proto.$item && proto.$item.$properties) {
            this.currentData.$properties = proto.$item.$properties;
            this.$decorator = proto.$decorator;
            hasMetaChanged = true;
        }
    }

    // TODO: How to set it without an hard coded value?
    $$layoutSlot.height("450px");

    var $resources = this.currentData.$resources,
        $properties = this.currentData.$properties,
        $decorator = this.$decorator,
        xmlDocTag = [],
        x3map = $decorator && ($decorator.$bindings || $decorator.$mapping) || {};

    function value(k, r) {
        var key = x3map[k],
            p = key && $properties[key],
            val = key && r[key];
        return p && val && ("" + val);
    };

    function addColumn(num, label, typ, sdate, dur, elapse) {
        var xml
        if (typ > 0) {
            // only positive values of a string-value
            if (dur.substring(0, 1) != "-") {
                xml = '<subi typ="' + typ + '" ccount="5" sdate="' + sdate + '" dur="' + dur + '" elapse="' + elapse + '"/>';
                xmlDocTag.push(xml);
            }
        } else {
            if (label && num > 1) {
                xmlDocTag.push('</item>');
            }
            xml = '<item Num="' + num + '" tlabel="' + label + '">';
            xmlDocTag.push(xml);
        }
    };

    // <GPH XD1="A" XID="33025" NCO="432" NLI="187" PCO="1" PLI="5" BOR="1" IDF="256" SID="256" GTD="1" GTY="1"> <CPH CAP="Type d'action" NAM="TYPACT" XD1="A2" TDO="1" FMT="LA2948:15X" TYP="7" TFL="TYPACT"/> <CPH CAP="Chrono action" NAM="KEYACT" XD1="A3" TDO="7" FMT="K:10X" TYP="6" TFL="KEYACT"/> <CPH CAP="Date début interne" NAM="DATDI" XD1="A5" TDO="7" FMT="KiP:8X" TYP="32" TFL="DATD"/> <CPH CAP="Date fin interne" NAM="DATFI" XD1="A7" TDO="7" FMT="KiP:8X" TYP="32" TFL="DATF"/> <CPH CAP="Heure début" NAM="HEUD" XD1="A8" TDO="7" FMT="Kz:##[:]##" TYP="6" TFL="HEUD"/> <CPH CAP="Heure de fin" NAM="HEUF" XD1="A9" TDO="7" FMT="Kz:##[:]##" TYP="6" TFL="HEUF"/> <CPH CAP="Tiers" NAM="TIER" XD1="A10" TDO="7" FMT="K:20X" TYP="6" TFL="TIER"/> <CPH CAP="Interlocuteur" NAM="INTERL" XD1="A11" TDO="7" FMT="K:30X" TYP="6" TFL="INT"/> <CPH CAP="Catégorie" NAM="CAT" XD1="A12" TDO="7" FMT="K:10X" TYP="6" TFL="CAT"/> <CPH CAP="Objet" NAM="OBJ" XD1="A13" TDO="7" FMT="K:20X>40X" TYP="6" TFL="OBJ"/> <CPH CAP="Exécuté" NAM="EXE" XD1="A14" TDO="1" FMT="LA1:10X" TYP="7" TFL="EXE"/> <TEC FCC="2" FCS="2" FCD="" FCL="" FCV="" FTY="XMONTH" Code="A" SWF="FAG" GTYP="AGD" VAL1="2948" PAR1="MENACT"/> <MENS COD="TYPACT" NO="2948"/> <ACTS> </ACTS> </GPH>
    var cols = ["KEY", "LIB", "DATDI", "DURI", "TYPDAY", "ELAP"];

    xmlDocTag.push('<X3PORTAL>');
    xmlDocTag.push('<Data>');

    var start = "999999999999";
    var end = "000000000000";

    // calulating new Enddate


    function newEnd(start, duri) {
        var year = start.substring(0, 4);
        var month = start.substring(4, 6);
        var day = start.substring(6, 8);
        year = year * 1;
        month = month * 1;
        day = day * 1;
        var duriInt = int.numberValue(duri);

        var d = date.make(year, month, day);
        d = d.addDays(duriInt);

        var endFormatted = d._value + "1200";
        if (endFormatted > end) {
            end = endFormatted;
        }
    }

    $resources.forEach(function(r, i) {
        var val;
        val = value("DATDI", r)
        if (val) {
            if (val < start) {
                start = val;
            }

            var val2 = value("DURI", r);
            if (val2) {
                newEnd(start, val2);
            }
        }
    });

    xmlDocTag.push('<items title="" start="' + start + '" end="' + end + '">');

    var row = 0;
    $resources.forEach(function(r) {
        row++;
        var label = "",
            key, typ = "",
            sdate = "",
            dur = "",
            elapse = "";

        cols.forEach(function(k, i) {
            var k = cols[i],
                vi = value(k, r),
                v = "",
                att;

            switch (k) {
            case "KEY":
                key = vi;
                break;
            case "LIB":
                label = vi;
                break;
            case "DATDI":
                sdate = vi;
                break;
            case "DURI":
                dur = vi;
                break;
            case "TYPDAY":
                typ = vi;
                break;
            case "ELAP":
                elapse = vi;
                if (key) {
                    addColumn(row, label, typ, sdate, dur, elapse);
                }
                break;
            }

        });
    });

    if (row > 1) {
        xmlDocTag.push('</item>');
    }
    xmlDocTag.push('</items>');

    var typact = x3map["TYPDAY"];
    var mnu = $properties[typact].$mnu;
    var actionEnum = this.actionEnum || (typact && mnu && this.hosterData.instance.getLocalMenu(mnu));
    //var actionEnum = this.actionEnum || (typact && this.hosterData.instance.getLocalMenu(typact.$mnu));
    // review this to adapt it for itemproperties
    xmlDocTag.push('<itemproperties><iprop id="tlabel" label="Nom" type="7"/></itemproperties>');
    xmlDocTag.push('<subitypes>');

    actionEnum && actionEnum.forEach(function(m, i) {
        xmlDocTag.push('<sityp id="' + (i + 1) + '" label="' + m + '" type="4" color="" />');
    });
    xmlDocTag.push('</subitypes>');

    xmlDocTag.push('</Data>');
    if (hasMetaChanged) {
        xmlDocTag.push('<Technical>');
        // TABLEBLOC for flash component bound to a table and CLOB if it's bound to a clob
        xmlDocTag.push('<HtcProvType>TABLEBLOC</HtcProvType>');

        xmlDocTag.push('<DataSrc Type="GAT" Code=""/>');
        xmlDocTag.push('<VisCmp Type="FGA" Width="989">');

        xmlDocTag.push('<FTLISTCOLS>tlabel</FTLISTCOLS>');
        xmlDocTag.push('<FTLOOK>SAGE1</FTLOOK>');
        // xmlDocTag.push('<FCAMPM>1</FCAMPM>');
        xmlDocTag.push('</VisCmp>');
        xmlDocTag.push('<UsedDataSrcPar>');
        xmlDocTag.push('<DAYBEF>100</DAYBEF>');
        xmlDocTag.push('<DAYAFT>100</DAYAFT>');
        xmlDocTag.push('</UsedDataSrcPar>');

        var lang = this.hosterData.instance.page.$fusionPageMeta.controller._session.cdLang;
        lang = lang || "ENG";
        xmlDocTag.push('<UserLang>' + lang + '</UserLang>');
        xmlDocTag.push('</Technical>');
    }
    xmlDocTag.push('<Messages>');
    xmlDocTag.push('</Messages>');
    xmlDocTag.push('</X3PORTAL>');
    return xmlDocTag.join("");
}


/* Flash Error class */

function FlashError(diagnoses, callerId) {
    /**
     * diagnoses    : Cf. "Diagnosis Schema" http://syracuse/w/index.php/Diagnosis_Schema
     * getXML()     : "<X3PORTAL><Messages><Error><Code>x</Code><Img>zzzz</Img><Mes>wwwww</Mes></Error></Messages></X3PORTAL>"
     */
    this.diagnoses = (diagnoses ? (_.isArray(diagnoses) ? diagnoses : [diagnoses]) : null);
    this.callerId = callerId || "unknown";
}

FlashError.prototype.getXML = function() {
    var xmlDiagnoses = ["<Messages>"],
        diagnosEx, severity;
    if (this.diagnoses) {
        _.each(this.diagnoses, function(diagnos) {
            diagnosEx = {};
            _.defaults(diagnosEx, diagnos, {
                "severity": "error",
                "message": "unknown error",
                "applicationCode": "3",
                "img": "Alert.jpg"
            });
            diagnosEx.message += (_fixture ? " from : " + this.callerId : "") + (diagnosEx.stackTrace ? "\n" + diagnosEx.stackTrace : "");
            severity = (diagnosEx.severity == "error" || diagnosEx.severity == "fatal" ? "Error" : "Information");
            xmlDiagnoses.push("<" + severity + "><Code>" + diagnosEx.applicationCode + "</Code>", "<Img>" + diagnosEx.img + "</Img>");
            xmlDiagnoses.push("<Mes><![CDATA[" + diagnosEx.message + "]]></Mes></" + severity + ">");
        }, this);
    }
    xmlDiagnoses.push("</Messages>");

    return xmlDiagnoses.join('');
};

FlashError.prototype.getJS = function() {
    var diagnoses = {
        Messages: {}
    };

    if (this.diagnoses) {
        _.each(this.diagnoses, function(d) {
            var messages = diagnoses.Messages.Mes = diagnoses.Messages.Mes || [],
                message = {},
                str = (d.message || "unknown error") + (_fixture ? " from : " + this.callerId : "") + (d.stackTrace ? "\n" + d.stackTrace : ""),
                severity = ["error", "fatal"].indexOf(d.severity || "error") > 0 ? "Error" : "Information";

            message[severity] = {};
            message[severity].Code = {
                $value: d.applicationCode || "3"
            };
            message[severity].Img = {
                $value: d.img || "Alert.jpg"
            };
            message[severity].Mes = {
                $cdata: d.message
            };

            messages.push(message);
        }, this);
    }
    return diagnoses;
};


exports.flashWrapper = Wrapper;