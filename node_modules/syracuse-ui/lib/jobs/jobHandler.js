"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Article = require('syracuse-ui/lib/article/article').Article;
var date = require('syracuse-core/lib/types/date');
var time = require('syracuse-core/lib/types/time');

var _severities = {
	fatal: 4,
	error: 3,
	warning: 2,
	info: 1,
	success: 0
};

function _addDiagnoses(jobHandler, record, $diagnoses) {
	record.$diagnoses = record.$diagnoses || [];
	for (var ii = 0, jj = record.$diagnoses.length; ii < jj; ii++) {
		jobHandler.severity = _severities[$diagnoses[ii].$severity] > jobHandler.severity ? _severities[$diagnoses[ii].$severity] : jobHandler.severity;
	}
}

function _addDateTimeData(data, record) {
	if (data.startDate) {
		var startDate = new Date(data.startDate);
		record.startDate = date.fromJsDate(startDate).toString();
		record.startTime = time.fromJsDate(startDate).toString();
		record.$properties.startDate = {
			$isHidden: false
		};
		record.$properties.startTime = {
			$isHidden: false
		};
	}
}

function _buildInitRecord(jobHandler) {
	var record;
	if (jobHandler.params) {
		record = {
			$properties: {
				jobTitle: {
					$isHidden: false
				}
			},
			$uuid: jobHandler.params.uuid,
			$index: syra_jobs.page.getRecords().length || 0,
			jobTitle: jobHandler.params.title,
			jobType: jobHandler.params.kind,
		};
		// handling date time data
		_addDateTimeData(jobHandler.params, record);
		// handle diagnoses
		jobHandler.params.$diagnoses && _addDiagnoses(jobHandler, record, jobHandler.params.$diagnoses);
		record.$links = {
			$progressOff: {
				$isHidden: false
			}
		};
		record.$links["$job" + jobHandler.capitalize(jobHandler.params.kind) + "Icon"] = {
			$isHidden: false
		};
		if (jobHandler.isFusion) {
			if (jobHandler.cancelSvcId) {
				record.$links.$cancel = {
					$title: syra_local.jobs_cancel_label
				};
			}
		} else {
			record.phase = jobHandler.params.$state;
			record.$properties.phase = {
				$isHidden: false
			};
		}
	} else {
		record = {
			$uuid: helpers.uuid.generate(),
			$diagnoses: [{
				$message: syra_local.jobs_no_params,
				$severity: "error"
			}]
		};
	}
	return record;
}

function _cancelAsynchRequest(jobHandler) {
	if (jobHandler.asynchReq && jobHandler.asynchReq.length > 0) {
		for (var ii = 0; ii < jobHandler.asynchReq.length; ii++) {
			clearTimeout(jobHandler.asynchReq[ii]);
		}
	}
}

function _hasErrDiag($diagnoses) {
	var errDiag = false;
	for (var ii = 0; ii < $diagnoses.length; ii++) {
		var $severity = $diagnoses[ii].severity || $diagnoses[ii].$severity;
		if ($severity == "error" || $severity == "fatal") {
			errDiag = true;
		}
	}
	return errDiag;
}

function _buildRecord(jobHandler, data, success, $url) {
	if (jobHandler.params) {
		var record = {
			$uuid: jobHandler.params.uuid,
			$index: syra_jobs.page.getRecord(jobHandler.params.uuid).getRecordIndex(),
			$properties: {},
			$links: {}
		};
		record.$progressValue = null;
		if (success) {
			if (jobHandler.severity != undefined) {
				var severities = Object.keys(_severities);
				for (var ii = 0, jj = severities.length; ii < jj; ii++) {
					record.$progressValue = _severities[severities[ii]] == jobHandler.severity ? severities[ii] : record.$progressValue;
				}
			}
			record.$progressValue = record.$progressValue || "success";
		}
		record.$progressValue = record.$progressValue || "on";

		var binds = ["jobTitle", "phase", "phaseDetail", "progress", "elapsedSeconds", "remainingSeconds"];
		// append data
		for (var ii = 0; ii < binds.length; ii++) {
			var bind = binds[ii];
			if (data[bind]) {
				record[bind] = data[bind];
				record.$properties[bind] = {
					$isHidden: false
				};
			}
		}
		// handling date time data
		_addDateTimeData(data, record);
		// handle diagnoses
		data.$diagnoses && _addDiagnoses(jobHandler, record, data.$diagnoses);

		record.$links["$job" + jobHandler.capitalize(jobHandler.params.kind) + "Icon"] = {
			$isHidden: false
		};
		if (jobHandler.isFusion) {
			// handling links in case of print job
			if (self.cancelSvcId && !success) {
				record.$links.$cancel = {
					$title: syra_local.jobs_cancel_label
				};
			} else {
				record.$links.$cancel = {
					$isHidden: true
				};
			}
			if (success && $url && $url.indexOf("/print/$report") != -1) {
				record.$links.$download = {
					$title: syra_local.jobs_download_label,
					$url: $url
				};
			}
		} else {
			if (data.$links) {
				var bindLinks = Object.keys(data.$links);
				var localize = syra_local;
				for (var ii = 0; ii < bindLinks.length; ii++) {
					record.$links[bindLinks[ii]] = {
						$title: bindLinks[ii].indexOf("$") != -1 ? localize["jobs_" + bindLinks[ii].slice(1) + "_label"] : localize["jobs_" + bindLinks[ii] + "_label"],
						$url: data.$links[bindLinks[ii]].$url,
						$method: data.$links[bindLinks[ii]].$method
					};
				}
			} else {
				record.$links.$details = record.$links.$abort = record.$links.$suspend = record.$links.$resume = {
					$isHidden: true
				};
			}
		}
		return record;
	}
}


function JobHandler() {}

exports.JobHandler = helpers.defineClass(JobHandler, null, {
	capitalize: function(s) {
		//capitalize first letter
		return s[0].toUpperCase() + s.slice(1);
	},
	callServer: function(reqOpt, cbck, onRelease) {
		var self = this;
		onRelease && _cancelAsynchRequest(self);
		syra_controller.callServer(null, reqOpt, function(data, response, $url) {
			self.onSuccess(data, response, $url, cbck);
		}, function(error, httpquery) {
			self.onError(error);
		});
	},
	buildReqOpt: function(method, $url, acceptType) {
		var reqOpt = {
			noDisplayErr: true,
			method: method || "GET",
			$location: {
				$url: $url
			}
		};
		if (acceptType) {
			reqOpt.$acceptType = acceptType;
		}
		return reqOpt;
	},
	register: function(params, currentState, nextStateSvcId, cancelSvcId, explicitReleaseCallback) {
		var self = this;
		if (self.isFusion && !params) {
			return {
				$diagnoses: [{
					$severity: 'error',
					$message: syra_local.jobs_err_noparams
				}]
			};
		}
		self.severity = 0;
		self.params = params;

		syra_jobs.addJob(self);

		// init record for jobs viewer (desktopList)
		var record = _buildInitRecord(self);
		var newData = {
			$jobType: syra_jobs.page.boundFields && syra_jobs.page.boundFields.$jobType[0].currentValue || 1,
			$jobDetails: [record],
			$properties: {
				$jobType: {
					$value: {
						$enum: syra_jobs.page.getJobsTypesEnum()
					}
				}
			}
		};

		// draw jobs viewer panel if necessary
		if (!syra_jobs.page.domItem) {
			syra_jobs.page.loadBox();
		}
		syra_jobs.page.toggle(true);
		// append job view (record)
		syra_jobs.page.isPageLoaded = true;
		syra_jobs.page.applyChange(newData, undefined, true);

		if (self.isFusion) {
			self.cancelSvcId = cancelSvcId;
			self.explicitReleaseCallback = explicitReleaseCallback;
			// send request if no err diagnose
			if (self.params) {
				// if no diagnoses or no err diagnoses, send request. else request is not sent    
				if (!self.params.$diagnoses || (self.params.$diagnoses && !_hasErrDiag(self.params.$diagnoses))) {
					self.callServer({
						noDisplayErr: true,
						method: "POST",
						$url: syra_site.expressionMaker.parse(new Article(), self.params.$location, self.params.services[nextStateSvcId])
					});
				}
			}
			// if $diagnoses in jobsParams, return true/false whether there is "error" diagnose
			if (self.params && self.params.$diagnoses) {
				return _hasErrDiag(self.params.$diagnoses) ? {
					$diagnoses: $diagnoses
				} : null;
			}
		} else {
			self.params && self.callServer(self.buildReqOpt("GET", params.$location));
		}
	},
	onClientRelease: function($url, $method, cbck) {
		if (this.isFusion) {
			if (this.cancelSvcId) {
				var article = new Article(); // used to parse location expression
				var $url = syra_site.expressionMaker.parse(article, this.params.$location, this.params.services[this.cancelSvcId]);
				this.callServer(this.buildReqOpt("GET", $url), cbck, true);
				this.explicitReleaseCallback && this.explicitReleaseCallback();
			}
		} else {
			$url && this.callServer(this.buildReqOpt($method, $url), cbck, true);
		}
	},

	onSuccess: function(data, response, $url, cbck) {
		var self = this;
		var reqOpt = self.buildReqOpt("GET", response.headers.location);
		var record = _buildRecord(self, data, response.status == 200, $url);
		var newData = {
			$jobDetails: [record]
		};
		if (self.isFusion) {
			syra_jobs.page.applyChange(newData, response.status == 200);
		} else {
			if (response.status != 204 && record != undefined) {
				var scrollTop = syra_jobs.page.boundFields.$jobDetails[0]._dataValue.scrollTop;
				// Cleaning diags records before filling them 
				syra_jobs.page.applyChange({
					$jobDetails: [{
						$uuid: record.$uuid,
						$index: record.$index,
						$diagnoses: []
					}]
				});
				syra_jobs.page.applyChange(newData, response.status == 200);
				syra_jobs.page.boundFields.$jobDetails[0]._dataValue.scrollTop = scrollTop;
			}
		}
		switch (response.status) {
			case 200:
				_cancelAsynchRequest(self);
				if (self.isFusion) {
					if ($url && $url.indexOf("/print/$report") != -1) {
						window.open($url, "_blank");
					}
					self.explicitReleaseCallback && self.explicitReleaseCallback();
				} else {
					// in case of asynch service operation, clean on success
					if ($url && $url.indexOf("/sdata/$trackers") != -1) {
						if (response.headers && response.headers['$do-not-delete']) {
							// Actually do not forward the final response to not erase async job data ($diagnoses...)
							// Do not DELETE tracker to be able to retrieve the final response throught $details link
							//self.callServer(this.buildReqOpt("GET", response.data.$links.$details.$url));
						} else {
							reqOpt.method = "DELETE";
							self.callServer(reqOpt);
						}
					}
				}
				break;
			case 201:
				if (self.isFusion) {
					if (response.headers.location.indexOf("/print/$report") != -1) {
						reqOpt.$acceptType = self.params.mime;
					}
				}
				self.callServer(reqOpt);
				break;
			case 202:
				// 202 => server processes request asynchronously
				// do not send further request if a suspend request has been sent
				if ($url.indexOf("suspend=true") < 0) {
					self.asynchReq = self.asynchReq || [];
					self.asynchReq.push(setTimeout(function() {
						self.callServer(reqOpt);
					}, data.pollingMillis));
				}
				break;
			case 424:
				// received after tracker abort
				if ($url && $url.indexOf("/sdata/$trackers") != -1) {
					reqOpt.method = "DELETE";
					self.callServer(reqOpt);
				}
				break;
			default:
				//console.info("status=" + response.status);
				//console.log("data=" + data);
				break;
		}
	},
	onError: function(error, ignoreOpComplete) {
		var $diagnoses;
		if (error.data.indexOf("$diagnoses") != -1) {
			$diagnoses = JSON.parse(error.data).$diagnoses;
			if ($diagnoses) {
				// setting prioritary severity
				for (var ii = 0, jj = $diagnoses.length; ii < jj; ii++) {
					this.severity = this.severity || 0;
					this.severity = _severities[$diagnoses[ii].$severity] > this.severity ? _severities[$diagnoses[ii].$severity] : this.severity;
				}
			} else {
				$diagnoses = [{
					$severity: "error",
					$message: syra_local.job_err_without_diag.replace("{status}", error.status)
				}];
			}
		} else {
			$diagnoses = [{
				$severity: "error",
				$message: error.data
			}];
			// setting prioritary severity
			this.severity = _severities["error"];
		}
		syra_jobs.page.applyChange({
			$jobDetails: [_buildRecord(this, {
				$diagnoses: $diagnoses
			}, true)]
		}, true);
		if (this.isFusion) {
			!ignoreOpComplete && this.explicitReleaseCallback && this.explicitReleaseCallback();
		}
	},
	dispose: function() {}
});