"use strict";
var helpers = require('syracuse-core/lib/helpers');
var JobHandler = require('./jobHandler').JobHandler;
var Article = require('syracuse-ui/lib/article/article').Article;

function JobHandlerSyra() {}

exports.JobHandlerSyra = helpers.defineClass(JobHandlerSyra, JobHandler, {
	register: function(params) {

		var self = this;

		if (!params) {
			return;
		}
		JobHandler.prototype.register.call(self, params);

		// send request if no err diagnose
		if (self.params) {
			// req
			var reqOpt = self.buildReqOpt("GET", params.$location);

			// send tracking request
			self.sendRequest(reqOpt);
		}
	},
	appendSpecificProperty: function(record) {
		// syra specific
		record.phase = this.params.$state;
		record.$properties.phase = {
			$isHidden: false
		};
	},
	buildRecord: function(data, success, $url) {
		var self = this;
		var record = JobHandler.prototype.buildRecord.call(this, data, success);
		if (record) {
			// handle links
			if (data.$links) {
				var bindLinks = Object.keys(data.$links);
				var localize = syra_local;
				for (var ii = 0; ii < bindLinks.length; ii++) {
					record.$links[bindLinks[ii]] = {
						$title: bindLinks[ii].indexOf("$") != -1 ? localize["jobs_" + bindLinks[ii].slice(1) + "_label"] : localize["jobs_" + bindLinks[ii] + "_label"],
						$url: data.$links[bindLinks[ii]].$url,
						$method: data.$links[bindLinks[ii]].$method
					};
				}
			} else {
				record.$links.$details = record.$links.$abort = record.$links.$suspend = record.$links.$resume = {
					$isHidden: true
				};
			}

			return record;
		}
	},
	onSuccess: function(data, response, $url, cbck) {
		//return;
		var self = this;

		// building request
		var reqOpt = self.buildReqOpt("GET", response.headers.location);

		var record = self.buildRecord(data, response.status == 200, $url);

		var newData = {
			$jobDetails: [record]
		};

		if (response.status != 204 && record != undefined) {

			var scrollTop = self.jobsViewer.boundFields.$jobDetails[0].domValueSlot.scrollTop;

			// Cleaning diags records before filling them 
			self.jobsViewer.applyChange({
				$jobDetails: [{
					$uuid: record.$uuid,
					$index: record.$index,
					jobDiagnoses: []
				}]
			});

			self.jobsViewer.applyChange(newData, response.status == 200);
			self.jobsViewer.boundFields.$jobDetails[0].domValueSlot.scrollTop = scrollTop;
		}

		switch (response.status) {
			case 200:
				// operation is complete

				self.cancelAsynchRequest();
				// in case of asynch service operation, clean on success
				if ($url && $url.indexOf("/sdata/$trackers") != -1) {
					if (response.data && response.data.$links && response.data.$links.$details) {
						// Actually do not forward the final response to not erase async job data ($diagnoses...)
						// Do not DELETE tracker to be able to retrieve the final response throught $details link
						//self.sendRequest(this.buildReqOpt("GET", response.data.$links.$details.$url));
					} else {
						reqOpt.method = "DELETE";
						self.sendRequest(reqOpt);
					}
				}
				break;
			case 201:
				// 201 => new GET request to send
				// send new request
				self.sendRequest(reqOpt);

				break;
			case 202:
				// 202 => server processes request asynchronously
				// do not send further request if a suspend request has been sent
				if ($url.indexOf("suspend=true") < 0) {
					self.asynchReq = self.asynchReq || [];
					self.asynchReq.push(setTimeout(function() {
						self.sendRequest(reqOpt);
					}, data.pollingMillis));
				}
				break;
			case 424:
				// received after tracker abort
				if ($url && $url.indexOf("/sdata/$trackers") != -1) {
					reqOpt.method = "DELETE";
					self.sendRequest(reqOpt);
				}
				break;
			case 204:
				//received after tracker DELETE request
				// remove job params from sessionStorage
			default:
				console.info("status=" + response.status);
				console.log("data=" + data);
		}
	},
	onClientRelease: function($url, $method, cbck) {
		var self = this;
		if ($url) {
			self.sendRequest(this.buildReqOpt($method, $url), cbck, true);
		}
	}
});