"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var JobHandler = require('./jobHandler').JobHandler;
var Article = require('syracuse-ui/lib/article/article').Article;

function JobHandlerSyra() {}

exports.JobHandlerSyra = helpers.defineClass(JobHandlerSyra, JobHandler, {
	register: function(params) {

		var self = this;

		JobHandler.prototype.register.call(self, params);

		// send request if no err diagnose
		if (self.params) {
			// req
			var reqOpt = self.buildReqOpt("GET", params.$location);

			// send tracking request
			self.sendRequest(reqOpt);
		} else {
			return;
		}
	},
	appendSpecificProperty: function(record) {
		// syra specific
		record.phase = this.params.$state;
		record.$properties.phase = {
			$isHidden: false
		};
	},
	buildRecord: function(data, success, $url) {
		var self = this;
		var record = JobHandler.prototype.buildRecord.call(this, data, success);
		if (record) {
			// handle links
			if (data.$links) {
				var bindLinks = Object.keys(data.$links);
				for (var ii = 0; ii < bindLinks.length; ii++) {
					record.$links[bindLinks[ii]] = {
						$title: bindLinks[ii].indexOf("$") != -1 ? self.jobsViewer.localize["jobs_" + bindLinks[ii].slice(1) + "_label"] : self.jobsViewer.localize["jobs_" + bindLinks[ii] + "_label"],
						$url: data.$links[bindLinks[ii]].$url,
						$method: data.$links[bindLinks[ii]].$method
					};
				}
			} else {
				record.$links.$abort = record.$links.$suspend = record.$links.$resume = {
					$isHidden: true
				};
			}

			return record;
		}
	},
	onSuccess: function(data, response, $url, cbck) {
		//return;
		var self = this;

		// building request
		var reqOpt = self.buildReqOpt("GET", response.headers.location);

		var record = self.buildRecord(data, response.status == 200, $url);

		var newData = {
			$jobDetails: [record]
		};

		if (response.status != 204) {
			self.jobsViewer.applyChange(newData, response.status == 200);
		}

		switch (response.status) {
			case 200:
				// operation is complete
				// cancel any asynch (timeout) request planned
				self.cancelAsynchRequest();

				// in case of asynch service operation, clean on success
				if ($url && $url.indexOf("/sdata/$trackers") != -1) {
					reqOpt.method = "DELETE";
					self.sendRequest(reqOpt);
				}
				self.alertUser();
				break;
			case 201:
				// 201 => new GET request to send
				// send new request
				self.sendRequest(reqOpt);

				break;
			case 202:
				// 202 => server processes request asynchronously
				// do not send further request if a suspend request has been sent
				if ($url.indexOf("suspend=true") < 0) {
					self.asynchReq = self.asynchReq || [];
					self.asynchReq.push(setTimeout(function() {
						self.sendRequest(reqOpt);
					}, data.pollingMillis));
				}
				break;
			case 424:
				// received after tracker abort
				if ($url && $url.indexOf("/sdata/$trackers") != -1) {
					reqOpt.method = "DELETE";
					self.sendRequest(reqOpt);
				}
				break;
			case 204:
				//received after tracker DELETE request
			default:
				console.info("status=" + response.status);
				console.log("data=" + data);
		}
	},
	onClientRelease: function($url, $method, cbck) {
		var self = this;
		if ($url) {
			self.sendRequest(this.buildReqOpt($method, $url), cbck, true);
		}
	}
});