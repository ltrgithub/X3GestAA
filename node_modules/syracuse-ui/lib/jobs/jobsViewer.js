"use strict";
var helpers = require('syracuse-core/lib/helpers');
var RawPage = require("syracuse-ui/lib/page/rawPage").RawPage;
var jobsViewerPrototype = require("./setting/jobsViewerPrototype");
var jobsViewerArticle = require("./setting/jobsViewerArticle");

function JobsViewer() {

}

exports.JobsViewer = helpers.defineClass(JobsViewer, RawPage, {
	addJob: function(jobHandler) {
		this.jobs = this.jobs || {};
		this.jobs[jobHandler.params.uuid] = jobHandler;
		this._updateJobsViewCount('add');
	},
	removeJob: function(uuid) {
		if (this.jobs) {
			this.jobs[uuid] && this.jobs[uuid].dispose && this.jobs[uuid].dispose();
			this._updateJobsViewCount('remove');
		}
	},
	updateJobsTypesList: function(jobType, add) {
		this.jobsTypes = this.jobsTypes || {};
		if (add) {
			var types = Object.keys(this.jobsTypes);
			if (types.length == 0) {
				this.jobsTypes[jobType] = {
					count: 1
				};
			} else {
				if (this.jobsTypes[jobType]) {
					this.jobsTypes[jobType].count++;
				} else {
					this.jobsTypes[jobType] = {
						count: 1
					};
				}
			}
		} else {
			this.jobsTypes[jobType].count--;
		}
	},
	getJobsTypesEnum: function() {
		if (this.jobsTypes) {
			var jobsTypesEnum = [];
			var keys = Object.keys(this.jobsTypes);
			for (var ii = 0; ii < keys.length; ii++) {
				if (this.jobsTypes[keys[ii]].count > 0) {
					jobsTypesEnum.push({
						$value: ii + 1,
						$title: keys[ii]
					});
				}
			}

			if (jobsTypesEnum.length > 1) {
				jobsTypesEnum.push({
					$value: ii + 1,
					$title: this.localize.jv_type_default
				});
			}
			return jobsTypesEnum;
		} else {
			return [{
				$value: "1",
				$title: this.localize.jv_type_default
			}];
		}
	},
	loadBox: function() {
		var $skin = "s-jobs-viewer";
		this.$autoFetch = false;
		this.$prototype = jobsViewerPrototype.getPrototype();
		this.$prototype.$properties.$jobType.$value.$enum = this.getJobsTypesEnum();

		//$choiceLayout: this.selectedTypeValue || "1",
		this.$item = jobsViewerArticle.getItem();

		this.layoutSlot = document.createElement("div");
		this.layoutSlot.className = $skin;
		document.site.layoutSlot.appendChild(this.layoutSlot);

		RawPage.prototype.loadBox.call(this);

		this._appendAutoClose(true);
	},
	isTargetInBoundary: function(event) {
		if (event && this._autoCloseBoundary) {
			if ($(event.target).closest(this._autoCloseBoundary).length > 0) {
				return true;
			}
		}
		return false;
	},
	_appendAutoClose: function(append) {
		var self = this;
		if (append) {
			self._autoCloseNamespace = self.id;
			self.$isAutoClose = true;
			self.$$item[0].setAttribute("id", self._autoCloseNamespace);
			self._autoCloseBoundary = "#" + self._autoCloseNamespace;
			$(document).bind("click." + self._autoCloseNamespace, function(event) {
				if (self.$$item) {
					if (self.$$item.is(":visible")) {
						if (!self.isTargetInBoundary(event)) {
							self.toggle(false);
						}
					}
				}
				return true;
			});

		} else {
			if (self._autoCloseNamespace) {
				self.$isAutoClose = false;
				$(document).unbind("click." + self._autoCloseNamespace);
			}
		}

	},
	onMenuClick: function(menuItem) {
		var self = this;
		switch (menuItem.$bind) {
			case "$clearJob":
				self._onJobViewRemove(menuItem, menuItem.$clearForced);
				break;
			case "$clearList":
				self._onClearList(menuItem);
				break;
			case "$download":
				window.open(menuItem.$url, "_blank");
				break;
			case "$cancel":
				var callback = function() {
					self.jobs[menuItem.articleParent.$uuid].onClientRelease();
				};
				self._showMessage(menuItem, callback);
				break;
			case "$abort":
			case "$suspend":
			case "$resume":
				var callback = function() {
					self.jobs[menuItem.articleParent.$uuid].onClientRelease(menuItem.$url, menuItem.$method);
				};
				self._showMessage(menuItem, callback);
				break;
		}

		// to prevent call to document.controller.executeMenu
		menuItem.onMenuClick = this.onMenuItemClick;

		return false;
	},
	onMenuItemClick: function(menuItem) {
		return false;
	},
	getRecordsList: function(type) {
		var self = this;
		if (type) {
			var records = self.boundFields.$jobDetails[0].records;
			var list = [];
			for (var mm = 0, pp = records.length; mm < pp; mm++) {
				if ((records[mm].dataset.jobType == type) || (type == self.localize.jv_type_default)) {
					list.push(records[mm]);
				}
			}
			return list;
		} else {
			return (self.boundFields && self.boundFields.$jobDetails[0].records) || [];
		}
	},
	_hasJobInProgress: function(list) {
		var self = this;
		for (var ii = 0, jj = list.length; ii < jj; ii++) {
			var record = list[ii];
			var keys = Object.keys(record.idMap);
			for (var mm = 0, kk = keys.length; mm < kk; mm++) {
				var item = record.idMap[keys[mm]];
				if (item.$item && item.$item.$bind == '$progressOn' && item.$$item.is(":visible")) {
					return true;
				}
			}
		}
	},
	getRecord: function(uuid) {
		return this.boundFields && this.boundFields.$jobDetails[0].recordsMap[uuid] || null;
	},
	_onClearList: function(menuItem) {
		var self = this;
		// get selected job type
		var selectedValue = self.boundFields.$jobType[0].currentValue;
		var $enum = self.boundFields.$jobType[0].$enum;
		var selectedTitle;
		for (var ii = 0, jj = $enum.length; ii < jj; ii++) {
			if ($enum[ii].$value == selectedValue) {
				selectedTitle = $enum[ii].$title;
				break;
			}
		}
		var list = self.getRecordsList(selectedTitle);
		if (self._hasJobInProgress(list)) {
			self._showMessage(menuItem, function() {
				self._clearList(list);
			});
		} else {
			self._clearList(list);
		}
	},
	_clearList: function(list) {
		for (var ii = 0, jj = list.length; ii < jj; ii++) {
			list[ii].menuItems.$clearJob[0].$clearForced = true;
			list[ii].menuItems.$clearJob[0].click();
		}
	},
	_updateJobsViewCount: function(operation) {
		switch (operation) {
			case 'add':
				document.site._jobsViewerOpener.style.display = "";
				this.$$item && this.$$item.show() && document.site.setZIndex(this.$$item[0]);
				document.site._jobsViewerOpener.textContent = ++this.jobsCount;
				break;
			case 'remove':
				document.site._jobsViewerOpener.textContent = --this.jobsCount;
				break;
		}
	},
	_onJobViewRemove: function(menuItem, forced) {
		var self = this;

		// clear forced (in case of list clear action)
		if (forced) {
			self._removeJobView(menuItem.articleParent);
			return;
		}

		// alert if job in progress
		if (self._hasJobInProgress([menuItem.articleParent])) {
			self._showMessage(menuItem, function() {
				self._removeJobView(menuItem.articleParent);
			});
		} else {
			self._removeJobView(menuItem.articleParent);
		}
	},
	_removeJobView: function(record) {
		this.updateJobsTypesList(this.jobs[record.dataset.$uuid].params.kind);
		this.removeJob(record.$uuid);
		var list = this.getRecordsList(this.localize.jv_type_default);

		var newData = {};
		var $enum = this.getJobsTypesEnum();
		if ($enum.length == 1) {
			var $jobType = $enum[0].$value;
		}

		newData = {
			$jobType: $jobType,
			$jobDetails: [{
				$uuid: record.$uuid,
				$index: record.getRecordIndex(),
				$isDeleted: true
			}],
			$properties: {
				$jobType: {
					$value: {
						$enum: $enum
					}
				}
			}
		};

		this.applyChange(newData);

		// if one type left, show previously hidden jobs views (useful in case of previous filtering)
		if ($enum.length == 1) {
			var records = this.getRecordsList();
			for (var ii = 0, jj = records.length; ii < jj; ii++) {
				records[ii].$$item.show();
			}
		}

		if (this.jobsCount == 0) {
			//this.domItem.style.display = "none";
			this.$$item.toggle(false);
			document.site._jobsViewerOpener.style.display = "none";
		}
	},
	_showMessage: function(menuItem, cbck) {
		var self = this;
		var options = {};
		options.$message = (self.localize['job_' + menuItem.$bind.slice(1) + '_msg'].replace("{jobTitle}", menuItem.articleParent.dataset.jobTitle)).replace("{jobKind}", menuItem.articleParent.dataset.jobType);
		options.$title = self.localize['job_' + menuItem.$bind.slice(1) + '_title'];
		options.$type = "warning";
		options.$buttons = "yesno";
		options.$isAutoClose = 25000;
		options.$default = "no";
		options.callback = function(response, closedBy) {
			var close = closedBy == "no" || closedBy == "auto";
			if (!close) {
				cbck();
			}
			return true;
		};
		document.site.showMessage(options);
		self.msgBoxId = document.site.messageBox.id;
	},
	notifyDataChange: function(field, value) {
		var self = this;
		// get title
		var title;
		for (var ii = 0, jj = field.$enum.length; ii < jj; ii++) {
			if (field.$enum[ii].$value == value) {
				title = field.$enum[ii].$title;
				break;
			}
		}
		// show or hide corresponding records
		if (title) {
			var records = self.getRecordsList();
			for (var mm = 0, pp = records.length; mm < pp; mm++) {
				if ((records[mm].dataset.jobType == title) || (title == self.localize.jv_type_default)) {
					records[mm].$$item.show();
				} else {
					records[mm].$$item.hide();
				}
			}
		}
	},
	applyChange: function(newData, closeMsgBox, newRecord) {
		var self = this;

		// handle jobs types list update in case of new record
		// assuming there is only one record change
		if (newRecord && newData.$jobDetails && newData.$jobDetails.length <= 1) {
			var $prevEnum = self.dataset && self.dataset.$properties && self.dataset.$properties.$jobType.$value.$enum;
			if ($prevEnum && $prevEnum.length > 0) {
				var recordToHide;
				// if there were only one job type in the jobs types list
				if ($prevEnum.length == 1) {
					// if new job type record, switch selected job type to "all types" value
					if (newData.$jobDetails[0].jobType != $prevEnum[0].$title) {
						newData.$jobType = self.getJobsTypesEnum().length;
					}
					// otherwise, there is nothing to do 
				}
				// if there were more than one job type in the jobs types list
				else {
					// if a specific job type selected (different from "all types")

					// if new job type is different from the selected job type, it has to be hidden
					if ($prevEnum[self.dataset.$jobType - 1].$title != newData.$jobDetails[0].jobType) {
						recordToHide = true;
					}
				}
			}
		}

		RawPage.prototype.applyChange.call(this, newData);

		// css hack in order for text-overflow:ellipsis, white-space:nowrap, overflow:hidden style properties to be effective
		var records = this.boundFields.$jobDetails[0].records;
		for (var ii = 0, jj = records.length; ii < jj; ii++) {
			var record = records[ii];
			var $fields = Object.keys(record.boundFields);
			for (var mm = 0, pp = $fields.length; mm < pp; mm++) {
				var field = record.boundFields[$fields[mm]];
				if (field[0].domValueSlot && field[0].domValueSlot.className.indexOf("s-job-view-info-field") != -1) {
					field[0].domValueSlot.style.display = "";
				}
			}
		}

		// show diagnose block in jobview if any diagnoses
		if (newData.$jobDetails && newData.$jobDetails.length > 0) {
			for (var pp = 0, hh = newData.$jobDetails.length; pp < hh; pp++) {
				if (newData.$jobDetails[pp].jobDiagnoses && newData.$jobDetails[pp].jobDiagnoses.length > 0) {
					var record = self.getRecord(newData.$jobDetails[pp].$uuid);
					var keys = Object.keys(record.idMap);
					for (var mm = 0, kk = keys.length; mm < kk; mm++) {
						var item = record.idMap[keys[mm]];
						if (item.$item && item.$item.$isDiagBox) {
							item.setState({
								$isHidden: false
							});
						}
					}
				}
			}
		}

		// if success, close any message box opened from jobsViewer
		if (closeMsgBox && document.site.messageBox && self.msgBoxId == document.site.messageBox.id && !document.site.messageBox.disposed) {
			document.site.messageBox.close("no");
		}

		// hide record if necessary (according to jobs types list filtering)
		if (recordToHide) {
			self.getRecord(newData.$jobDetails[0].$uuid).$$item.hide();
		}
		this.isContentUpdated = true;
		this.ensurePageVisibility();

	},
	close: function() {

	},
	toggle: function(show) {
		if (this.$$item) {
			if (show == undefined) {
				if (this.$$item.is(":visible")) {
					this._appendAutoClose(false);
					this._toggleViewer();
				} else {
					this._appendAutoClose(true);
					this._toggleViewer(true);
				}
			} else {
				if (show) {
					this._appendAutoClose(true);
					this._toggleViewer(true);
				} else {
					this._appendAutoClose(false);
					this._toggleViewer();
				}
			}
		}
	},
	_toggleViewer: function(show) {
		if (show) {
			this.$$item.show();
			document.site.setZIndex(this.$$item[0]);
		} else {
			this.$$item.hide();
		}
	},
	dispose: function() {
		if (document.site.autoCloseDialogs) {
			delete document.site.autoCloseDialogs[this.id];
		}
		RawPage.prototype.dispose.call(this);
	}
});