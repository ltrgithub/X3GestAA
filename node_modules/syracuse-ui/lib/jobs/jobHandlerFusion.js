"use strict";
var helpers = require('syracuse-core/lib/helpers');
var JobHandler = require('./jobHandler').JobHandler;
var Article = require('syracuse-ui/lib/article/article').Article;

function JobHandlerFusion() {}

exports.JobHandlerFusion = helpers.defineClass(JobHandlerFusion, JobHandler, {
	register: function(jobParams, currentState, nextStateSvcId, cancelSvcId, explicitReleaseCallback) {
		if (!jobParams) {
			return {
				$diagnoses: [{
					$severity: 'error',
					$message: syra_local.jobs_err_noparams
				}]
			};
		}
		var self = this;
		JobHandler.prototype.register.call(self, jobParams, currentState, nextStateSvcId, cancelSvcId, explicitReleaseCallback);

		self.cancelSvcId = cancelSvcId;
		self.explicitReleaseCallback = explicitReleaseCallback;

		// send request if no err diagnose
		if (self.params) {

			// prepare request
			var reqOpt = {};
			reqOpt.noDisplayErr = true;
			reqOpt.method = "POST";
			var article = new Article(); // to parse location expression
			reqOpt.$location = {
				$url: syra_site.expressionMaker.parse(article, self.params.$location, self.params.services[nextStateSvcId])
			};

			// if no diagnoses or no err diagnoses, send request. else request is not sent    
			if (!self.params.$diagnoses || (self.params.$diagnoses && !self._hasErrDiag(self.params.$diagnoses))) {
				self.callServer(reqOpt);
			}
		}

		// if $diagnoses in jobsParams, return true/false whether there is "error" diagnose
		if (self.params && self.params.$diagnoses) {
			return self._hasErrDiag(self.params.$diagnoses) ? {
				$diagnoses: $diagnoses
			} : null;
		}

	},
	_hasErrDiag: function($diagnoses) {
		var errDiag = false;
		for (var ii = 0; ii < $diagnoses.length; ii++) {
			var $severity = $diagnoses[ii].severity || $diagnoses[ii].$severity;
			if ($severity == "error" || $severity == "fatal") {
				errDiag = true;
			}
		}
		return errDiag;
	},
	appendSpecificProperty: function(record) {
		if (this.cancelSvcId) {
			record.$links.$cancel = {
				$title: syra_local.jobs_cancel_label
			};
		}
	},
	buildRecord: function(data, success, $url) {
		var self = this;
		var record = JobHandler.prototype.buildRecord.call(this, data, success);

		if (record) {

			// handling links in case of print job
			if (self.cancelSvcId && !success) {
				record.$links.$cancel = {
					$title: syra_local.jobs_cancel_label
				};
			} else {
				record.$links.$cancel = {
					$isHidden: true
				};
			}

			if (success && $url && $url.indexOf("/print/$report") != -1) {
				record.$links.$download = {
					$title: syra_local.jobs_download_label,
					$url: $url
				};
			}

			return record;
		}
	},
	onSuccess: function(data, response, $url, cbck) {
		//return;
		var self = this;

		// building request
		var reqOpt = self.buildReqOpt("GET", response.headers.location);

		var record = self.buildRecord(data, response.status == 200, $url);

		if (record) {
			var newData = {
				$jobDetails: [record]
			};

			syra_site.jobsPage.applyChange(newData, response.status == 200);

			switch (response.status) {
				case 200:
					// operation is complete
					// cancel any asynch (timeout) request planned
					self.cancelAsynchRequest();

					// open report in new tab (or download suggestion)

					if ($url && $url.indexOf("/print/$report") != -1) {
						window.open($url, "_blank");
					}
					self._onOperationComplete();
					break;
				case 201:
					// 201 => new GET request to send
					if (response.headers.location.indexOf("/print/$report") != -1) {
						// set request accept type value
						reqOpt.$acceptType = self.params.mime;
					}

					// send new request
					self.callServer(reqOpt);

					break;
				case 202:
					// 202 => server processes request asynchronously
					// do not send further request if a suspend request has been sent
					if ($url.indexOf("suspend=true") < 0) {
						self.asynchReq = self.asynchReq || [];
						self.asynchReq.push(setTimeout(function() {
							self.callServer(reqOpt);
						}, data.pollingMillis));
					}
					break;
				default:
					console.info("status = " + response.status);
					console.log("data=" + data);
			}
		}
	},
	onError: function(error, ignoreOpComplete) {
		JobHandler.prototype.onError.call(this, error);
		!ignoreOpComplete && this._onOperationComplete();
	},
	_onOperationComplete: function() {
		try {
			if (this.explicitReleaseCallback) {
				this.explicitReleaseCallback();
			}
		} catch (e) {
			console.log(syra_site.jobsPage.jobs_no_release_callback);
		}
	},
	onClientRelease: function(cbck) {
		if (this.cancelSvcId) {
			var article = new Article(); // used to parse location expression
			var $url = syra_site.expressionMaker.parse(article, this.params.$location, this.params.services[this.cancelSvcId]);
			this.callServer(this.buildReqOpt("GET", $url), cbck, true);
			this.explicitReleaseCallback && this.explicitReleaseCallback();
		}
	},
	dispose: function() {
		this.params = null;
		this.cancelSvcId = null;
		this.explicitReleaseCallback = null;
		this.$index = null;
	}
});