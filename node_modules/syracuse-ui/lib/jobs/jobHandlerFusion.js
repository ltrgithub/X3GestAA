"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var JobHandler = require('./jobHandler').JobHandler;
var Article = require('syracuse-ui/lib/article/article').Article;

function JobHandlerFusion() {}

exports.JobHandlerFusion = helpers.defineClass(JobHandlerFusion, JobHandler, {
	register: function(jobParams, currentState, nextStateSvcId, cancelSvcId, explicitReleaseCallback) {
		var self = this;

		JobHandler.prototype.register.call(self, jobParams, currentState, nextStateSvcId, cancelSvcId, explicitReleaseCallback);

		self.cancelSvcId = cancelSvcId;
		self.explicitReleaseCallback = explicitReleaseCallback;

		//TODO : localize
		if (!self.params) {
			return {
				$diagnoses: [{
					$severity: 'error',
					$message: 'no params'
				}]
			};
		}

		// send request if no err diagnose
		if (self.params) {

			// prepare request
			var reqOpt = {};
			reqOpt.noDisplayErr = true;
			reqOpt.method = "POST";
			var article = new Article(); // to parse location expression
			reqOpt.$location = {
				$url: article.parseExpression(self.params.$location, self.params.services[nextStateSvcId])
			};

			// if no diagnoses or no err diagnoses, send request. else request is not sent    
			if (!self.params.$diagnoses || (self.params.$diagnoses && !self._hasErrDiag(self.params.$diagnoses))) {
				self.sendRequest(reqOpt);
			}
		}

		return self._hasErrDiag(self.params.$diagnoses) ? {
			$diagnoses: $diagnoses
		} : null;
	},
	_hasErrDiag: function($diagnoses) {
		var errDiag = false;
		for (var ii = 0; ii < $diagnoses.length; ii++) {
			var $severity = $diagnoses[ii].severity || $diagnoses[ii].$severity;
			if ($severity == "error" || $severity == "fatal") {
				errDiag = true;
			}
		}
		return errDiag;
	},
	appendSpecificProperty: function(record) {
		var self = this;
		// fusion specific
		// append cancel link
		if (self.cancelSvcId) {
			record.$links.$cancel = {
				$title: "cancel" //TODO localize
			};
		}
	},
	buildRecord: function(data, success, $url) {
		var self = this;
		var record = JobHandler.prototype.buildRecord.call(this, data, success);

		// handling links in case of print job
		if (self.cancelSvcId && !success) {
			record.$links.$cancel = {
				$title: self.jobsViewer.localize.jv_link_cancel
			};
		} else {
			record.$links.$cancel = {
				$isHidden: true
			};
		}

		if (success && $url.indexOf("/print/$report") != -1) {
			record.$links.$download = {
				$title: self.jobsViewer.localize.jv_link_download,
				$url: $url
			};
		}

		return record;
	},
	onSuccess: function(data, response, $url, cbck) {
		//return;
		var self = this;

		// building request
		var reqOpt = self.buildReqOpt("GET", response.headers.location);

		var record = self.buildRecord(data, response.status == 200, $url);

		var newData = {
			$jobDetails: [record]
		};

		self.jobsViewer.applyChange(newData, response.status == 200);

		switch (response.status) {
			case 200:
				// operation is complete
				// cancel any asynch (timeout) request planned
				self.cancelAsynchRequest();

				// open report in new tab (or download suggestion)
				if ($url && $url.indexOf("/print/$report") != -1) {
					window.open($url, "_blank");
				}

				self._onOperationComplete();
				break;
			case 201:
				// 201 => new GET request to send
				if (response.headers.location.indexOf("/print/$report") != -1) {
					// set request accept type value
					reqOpt.$acceptType = self.params.mime;
				}

				// send new request
				self.sendRequest(reqOpt);

				break;
			case 202:
				// 202 => server processes request asynchronously
				// do not send further request if a suspend request has been sent
				if ($url.indexOf("suspend=true") < 0) {
					self.asynchReq = self.asynchReq || [];
					self.asynchReq.push(setTimeout(function() {
						self.sendRequest(reqOpt);
					}, data.pollingMillis));
				}
				break;
			default:
				console.info("status = " + response.status);
				console.log("data=" + data);
		}
	},
	onError: function(error, httpquery, cbck) {
		JobHandler.prototype.onError.call(this, error, httpquery, cbck);
		this._onOperationComplete();
	},
	_onOperationComplete: function() {
		try {
			if (this.explicitReleaseCallback) {
				this.explicitReleaseCallback();
			}
		} catch (e) {
			console.log("no convergence callback set for successful end of operation");
		}
	},
	onClientRelease: function(cbck) {
		var self = this;

		if (self.cancelSvcId) {
			var article = new Article(); // used to parse location expression
			var $url = article.parseExpression(self.params.$location, self.params.services[self.cancelSvcId]);
			self.sendRequest(this.buildReqOpt("GET", $url), cbck, true);
			if (self.explicitReleaseCallback) {
				self.explicitReleaseCallback();
			}
		}
	},
	dispose: function() {
		this.params = null;
		this.cancelSvcId = null;
		this.explicitReleaseCallback = null;
		this.$index = null;
	}
});