"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var Article = require('syracuse-ui/lib/article/article').Article;
var JobView = require('./jobView').JobView;

function JobsHandler(){
}

exports.JobsHandler = helpers.defineClass(JobsHandler, null, {
    register: function(jobParams, currentState, nextStateSvcId, cancelSvcId, explicitReleaseCallback){
    
        var self = this;
        
        self.localize = locale.resources(module)();
        self.params = jobParams;
        
		/*
        // for tests purposes
        var types = ["default", "print", "operation"];
        self.params.kind = types[Math.floor(Math.random() * 2) + 1];
        */
        
        self.cancelSvcId = cancelSvcId;
        self.explicitReleaseCallback = explicitReleaseCallback;
        self.jobView = new JobView();
        
        if (self.params.$diagnoses && self.params.$diagnoses.length > 0) {
            var $diagnoses = self.params.$diagnoses;
            var errDiag = false;
            for (var ii = 0; ii < $diagnoses.length; ii++) {
                if ($diagnoses[ii].severity == "error") {
                    errDiag = true;
                    console.error($diagnoses[ii].message);
                }
            }
            document.site.showDiagnoses({
                $diagnoses: $diagnoses,
                autoHide: {
                    autoHideTimeOut: 1000
                }
            });
        }
        
        // proceed if no error
        if (!errDiag) {
        
            var reqOpt = {};
            reqOpt.noDisplayErr = true;
            reqOpt.method = "POST";
            var article = new Article(); // to parse location expression
            reqOpt.$location = {
                $url: article.parseExpression(self.params.$location, self.params.services[nextStateSvcId])
            };
            self._sendRequest(reqOpt);
        }
        
        // return $diagnoses or null if not any
        return errDiag ? {
            $diagnoses: $diagnoses
        } : null;
        
    },
    _sendRequest: function(reqOpt, cbck, onRelease){
        var self = this;
        
        // cancel any asynch request (202) if on release
        if (onRelease && self.asynchReq && self.asynchReq.length > 0) {
            for (var ii = 0; ii < self.asynchReq.length; ii++) {
                clearTimeout(self.asynchReq[ii]);
            }
        }
        
        document.controller.sendRequest(null, reqOpt, function(data, response, $url){
            self._onSuccess(data, response, $url, cbck);
        }, function(error, httpquery){
            self._onError(error, httpquery, cbck);
        });
    },
    _fillInfo: function(binds, data){
        var info = {};
        var noInfo = true;
        for (var ii = 0; ii < binds.length; ii++) {
            if (data[binds[ii]]) {
                noInfo = false;
                info[binds[ii]] = data[binds[ii]];
            }
        }
        return noInfo ? '' : info;
    },
    _fillPhaseInfo: function(data){
        var binds = ["phase", "phaseDetail"];
        return this._fillInfo(binds, data);
    },
    _fillTimeInfo: function(data){
        var binds = ["progress", "elapsedSeconds", "remainingSeconds"];
        return this._fillInfo(binds, data);
    },
    _buildReqOpt: function(method, $url){
        var reqOpt = {};
        reqOpt.noDisplayErr = true;
        reqOpt.method = method || "GET";
        reqOpt.$location = {
            $url: $url
        }
        return reqOpt;
    },
    _onSuccess: function(data, response, $url, cbck){
        var self = this;
        
        // req
        var reqOpt = self._buildReqOpt("GET", response.headers.location);
        
        var phase = response.status == 200 ? "end" : phase;
        
        // job view
        if (!self.jobView.$$body) {
            self.jobView.create(self);
            phase = "begin";
        }
        
        // job view info
        var phaseInfo = self._fillPhaseInfo(data);
        var timeInfo = self._fillTimeInfo(data);
        
        
        // update job view info
        self.jobView.updateInfo(phaseInfo, timeInfo, phase);
        
        
        switch (response.status) {
            case 200: // operation is complete
                // set final url value in jobView instance
                self.jobView.setFinalUrl($url);
                
                // handle diagnoses if any                
                this._onDiagnoses(data, cbck);
                
                // open report in new tab (or download suggestion)
                if ($url && $url.indexOf("/print/$report") != -1) {
                    window.open($url, "_blank");
                }
                
                // in case of asynch service operation, clean on success 
                else 
                    if ($url && $url.indexOf("/sdata/$trackers") != -1) {
                        reqOpt.method = "DELETE";
                        self._sendRequest(reqOpt);
                    }
                
                self._onOperationComplete();
                break;
            case 201: // 201 => new GET request to send
                if (response.headers.location.indexOf("/print/$report") != -1) {
                    // set request accept type value
                    reqOpt.$acceptType = self.params.mime;
                    // set final url value in jobView instance
                    self.jobView.setFinalUrl(response.headers.location);
                }
                
                // handle diagnoses if any
                this._onDiagnoses(data, cbck);
                
                // send new request
                self._sendRequest(reqOpt);
                
                break;
            case 202: // 202 => server processes request asynchronously
                self.asynchReq = [];
                self.asynchReq.push(setTimeout(function(){
                    self._sendRequest(reqOpt);
                }, data.pollingMillis));
                
                break;
            case 204:
            //received after tracker DELETE request
            default:
                console.info("status = " + response.status);
                console.log("data=" + data);
        }
    },
    _onDiagnoses: function(data, cbck){
        if (data.$diagnoses) {
            // append diagnoses to jobView if any
            this.jobView.appendDiagnoses(data.$diagnoses);
            // Cvg diagnoses handler
            if (cbck) {
                cbck(data.$diagnoses);
            }
        }
    },
    _onError: function(error, httpquery, cbck){
        var self = this;
        var phaseInfo = {};
        phaseInfo[self.localize.jh_errInfo_title] = self.localize.jh_errInfo;
        self.jobView.updateInfo(phaseInfo, undefined, "error", error.data);
        self._onOperationComplete();
    },
    _updateProgressData: function(opt){
        // TODO
    },
    _onOperationComplete: function(){
        try {
            if (this.explicitReleaseCallback) {
                this.explicitReleaseCallback();
            }
        } 
        catch (e) {
            console.log("no convergence callback set for successful end of operation");
        }
    },
    onClientRelease: function(){
        var self = this;
        self.release(self.cancelSvcId);
        if (self.explicitReleaseCallback) {
            self.explicitReleaseCallback();
        }
    },
    release: function(releaseSvcId, cbck){
        var self = this;
        var article = new Article(); // used to parse location expression
        var reqOpt = self._buildReqOpt("GET", article.parseExpression(self.params.$location, self.params.services[releaseSvcId]));
        self._sendRequest(reqOpt, cbck, true);
    },
    dispose: function(){
        this.params = null;
        this.cancelSvcId = null;
        this.explicitReleaseCallback = null;
    }
    
});
