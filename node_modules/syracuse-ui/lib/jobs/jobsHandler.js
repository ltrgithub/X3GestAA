"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var Article = require('syracuse-ui/lib/article/article').Article;

function JobsHandler(){
}

exports.JobsHandler = helpers.defineClass(JobsHandler, null, {
    register: function(jobParams, currentState, nextStateSvcId, cancelSvcId, explicitReleaseCallback){
    
        var self = this;
        
        self.params = jobParams;
        self.cancelSvcId = cancelSvcId;
        self.explicitReleaseCallback = explicitReleaseCallback;
        
        if (self.params.$diagnoses && self.params.$diagnoses.length > 0) {
            var $diagnoses = self.params.$diagnoses;
            var errDiag = false;
            for (var ii = 0; ii < $diagnoses.length; ii++) {
                if ($diagnoses[ii].severity == "error") {
                    errDiag = true;
                    console.error($diagnoses[ii].message);
                }
            }
        }
        
        // proceed if no error
        if (!errDiag) {
        
            var reqOpt = {};
            reqOpt.noDisplayErr = true;
            reqOpt.method = "POST";
            var article = new Article(); // to parse location expression
            reqOpt.$location = {
                $url: article.parseExpression(self.params.$location, self.params.services[nextStateSvcId])
            };
            self._sendRequest(reqOpt);
        }
        
        // return $diagnoses or null if not any
        return errDiag ? {
            $diagnoses: $diagnoses
        } : null;
        
    },
    _sendRequest: function(reqOpt, cbck){
        var self = this;
        document.controller.sendRequest(null, reqOpt, function(data, response, $url){
            self._onSuccess(data, response, $url, cbck);
        }, function(error, httpquery){
            self._onError(error, httpquery, cbck);
        });
    },
    _onSuccess: function(data, response, $url, cbck){
        var self = this;
        var reqOpt = {};
        reqOpt.noDisplayErr = true;
        reqOpt.method = "GET";
        reqOpt.$location = {
            $url: response.headers.location
        }
        switch (response.status) {
            case 200: // operation is complete
                console.info("status : " + response.status);
                if (data.$diagnoses) {
                    var $diagnoses = data.$diagnoses;
                    for (var ii = 0; ii < $diagnoses.length; ii++) {
                        console.info($diagnoses[ii].message + "\n");
                    }
                    if (cbck) {
                        cbck($diagnoses);
                    }
                }
                self._onOperationComplete();
                break;
            case 201: // 201 => new GET request to send
                console.info(data.phase ? "Phase : " + data.phase + "\n" : "");
                console.info(data.phaseDetail ? "phaseDetail : " + data.phaseDetail + "\n" : "");
                console.info(data.progress ? "progress : " + data.progress + "\n" : "");
                console.info(data.elapsedSeconds ? "elapsedSeconds : " + data.elapsedSeconds + "\n" : "");
                console.info(data.remainingSeconds ? "remainingSeconds : " + data.remainingSeconds + "\n" : "");
                
                if (data.$diagnoses) {
                    var $diagnoses = data.$diagnoses;
                    for (var ii = 0; ii < $diagnoses.length; ii++) {
                        console.info($diagnoses[ii].message + "\n");
                    }
                    if (cbck) {
                        cbck($diagnoses);
                    }
                }
                
                //                if (self.jobType && self.jobType == "print") {
                //                    window.open(response.headers.location, "_blank");
                //                }
                if (response.headers.location.indexOf("/print/$report") != -1) {
                    reqOpt.$acceptType = self.params.mime;
                    window.open(response.headers.location, "_blank");
                }
                
                // send new request
                self._sendRequest(reqOpt);
                
                break;
            case 202: // 202 => server processes request asynchronously
                console.info(data.phase ? "Phase : " + data.phase + "\n" : "");
                console.info(data.phaseDetail ? "phaseDetail : " + data.phaseDetail + "\n" : "");
                console.info(data.progress ? "progress : " + data.progress + "\n" : "");
                console.info(data.elapsedSeconds ? "elapsedSeconds : " + data.elapsedSeconds + "\n" : "");
                console.info(data.remainingSeconds ? "remainingSeconds : " + data.remainingSeconds + "\n" : "");
                
                //	TODO updateProgressData(opt)
                setTimeout(function(){
                    self._sendRequest(reqOpt);
                }, data.pollingMillis);
                
                break;
            default:
                console.info("status = " + response.status);
                console.log("data=" + data);
        }
    },
    _onError: function(error, httpquery, cbck){
        var self = this;
        console.error("An error occured." + "\n");
    },
    _updateProgressData: function(opt){
        // TODO
    },
    _onOperationComplete: function(){
        try {
            if(this.explicitReleaseCallback) {
                this.explicitReleaseCallback();
            }
        } 
        catch (e) {
        
        }
    },
    _onClientRelease: function(){
        var self = this;
        self.release(self.cancelSvcId);
        if (self.explicitReleaseCallback) {
            self.explicitReleaseCallback();
        }
    },
    release: function(releaseSvcId, cbck){
        var self = this;
        var reqOpt = {};
        reqOpt.noDisplayErr = true;
        reqOpt.method = "GET";
        var article = new Article(); // to parse location expression
        reqOpt.$location = {
            $url: article.parseExpression(self.params.$location, self.params.services[releaseSvcId])
        };
        self._sendRequest(reqOpt, cbck);
    },
    dispose: function(){
        this.params = null;
        this.cancelSvcId = null;
        this.explicitReleaseCallback = null;
    }
    
});
