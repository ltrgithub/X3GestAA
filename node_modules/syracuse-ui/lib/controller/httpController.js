"use strict";
var helpers = require("syracuse-core/lib/helpers");
var jsurl = require('jsurl/lib/jsurl');
var forEachKey = helpers.object.forEachKey;
var _pendingRequests = 0;
var locale = require('syracuse-core/lib/locale');
var disconnectUtils = require('syracuse-ui/lib/site/disconnectUtils');

var BROWSER_VERBS_ALLOWED = {
	GET: 1,
	POST: 1,
	DELETE: 1,
	PUT: 1
};
// DELETE and PUT added for asynch operations support

function _parseResponse(jqXHR, data) {
	document.site.notifyRequestSurvey(--_pendingRequests);
	var headers = {};
	var httpHeader = jqXHR.getAllResponseHeaders();
	if ((httpHeader = httpHeader.trim())) {
		httpHeader.split("\n").forEach(function(header) {
			header = header.trim();
			if (header) {
				var separatorIndex = header.indexOf(":");
				headers[header.substr(0, separatorIndex).trim().toLowerCase()] = header.substr(separatorIndex + 1).trim();
			}
		});
	}
	return {
		status: jqXHR.status,
		headers: headers,
		data: data || jqXHR.responseText
	};
}

function _onReceiveError(error) {
	var localize = locale.resources(module)();
	if (document.site.mainPage && !document.site.mainPage.disposed) {
		document.site.showDiagnoses({
			$diagnoses: (error.data.indexOf("$diagnoses") >= 0) ? JSON.parse(error.data).$diagnoses : [{
				$message: error.data ? error.data : _onEmptyError(error)
			}]
		});
	} else {
		//debugger; //TODO
		// messagebox
		var options = {
			$message: localize["http_" + error.status] ? localize["http_" + error.status] : localize.http_default_error_msg,
			$title: localize["http_" + error.status + "_title"] ? localize["http_" + error.status + "_title"] : localize.http_default_error_title,
			$type: "fatal",
			$buttons: "ok",
			$diagnoses: error.data && error.data.length > 0 ? (error.data.indexOf("$diagnoses") >= 0 ? JSON.parse(error.data).$diagnoses : [{
				$message: error.data ? error.data : _onEmptyError(error)
			}]) : []
		};
		document.site.showMessage(options);
	}
}

function _onEmptyError(error) {
	var localize = locale.resources(module)();
	return localize.http_empty_error;
}

exports.upload = function(options, responseCallback, progressCallback) {
	// tweek, only Firefox implements binary transfer, see "http://javascript0.org/wiki/Portable_sendAsBinary"
	if (!XMLHttpRequest.prototype.sendAsBinary) XMLHttpRequest.prototype.sendAsBinary = function(datastr) {
		function byteValue(x) {
			return x.charCodeAt(0) & 0xff;
		}
		var buf;
		try {
			// check if Uint8Array is avalable (IE9 doesn't have it)
			buf = new Uint8Array(1);
			var ords = Array.prototype.map.call(datastr, byteValue);
			buf = (new Uint8Array(ords)).buffer;
		} catch (e) {
			buf = datastr;
		}
		this.send(buf);
	};
	//
	var xhr = new XMLHttpRequest();
	xhr.open("PUT", options.url);
	options.headers && forEachKey(options.headers, function(header, value) {
		xhr.setRequestHeader(header, value);
	});
	xhr.setRequestHeader("accept", "application/json;vnd.sage=syracuse");
	options.contentType && xhr.setRequestHeader("content-type", options.contentType);
	xhr.setRequestHeader("x-file-name", options.fileName || options.file.name);
	// response callback
	if (responseCallback) xhr.onreadystatechange = function() {
		if (xhr.readyState == 4) {
			// IE misinterpret 204 as 1223
			if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || xhr.status == 1223) {
				// expects a json; TODO: check Content-Type header
				var response = _parseResponse(xhr, (xhr.response && (typeof xhr.response !== "object")) ? JSON.parse(xhr.response) : xhr.response);
				responseCallback(response.data, response);
			} else {
				_onReceiveError(_parseResponse(xhr, null));
			}
		}
	};
	// progress callback
	if (progressCallback) {
		xhr.upload.addEventListener("progress", function(e) {
			if (e.lengthComputable) {
				progressCallback(Math.round((e.loaded * 100) / e.total));
			}
		}, false);

		xhr.upload.addEventListener("load", function(e) {
			progressCallback(100, true);
		}, false);
	}
	//
	if (options.file) {
		var reader = new FileReader();
		reader.onload = function(evt) {
			xhr.sendAsBinary(evt.target.result);
		};
		reader.readAsBinaryString(options.file);
	} else {
		xhr.sendAsBinary(options.buffer);
	}
};

function HttpQuery() {

}

helpers.defineClass(HttpQuery, null, {
	_getHost: function() {
		var reg = new RegExp('^(?:f|ht)tp(?:s)?\://([^/]+)', 'im');
		var $urlParts = this.$url.match(reg);
		return $urlParts ? $urlParts[1].toString() : null;
	},
	appendHost: function() {
		var host = this._getHost();
		if (!host) {
			var href = window.location.href;
			this.$url = href.slice(0, href.indexOf(window.location.host) + window.location.host.length) + this.$url;
		}
	},
	getEndpoint: function() {
		return (this.$urlParts.endpoint ? {
			"endpoint": this.$urlParts.endpoint,
			"sep": "."
		} : null);
	},
	getPageTemplateUrl: function() {
		return document.site.$item.$pageTemplateUrl;
	},
	isSyracuseURL: function() {
		var host = this._getHost();
		return host ? host == window.location.host : true;
	},
	parse: function($url) {
		var self = this;
		var limit = $url.indexOf('?');
		self.$url = $url;
		self.$urlParts = {
			uri: $url.slice(0, limit),
			params: {},
			target: "$page"
		};
		$url.slice(limit + 1).split('&').forEach(function(param) {
			var hash = param.split("=");
			self.$urlParts.params[hash[0]] = hash[1];
		});
		if (!(self.$urlParts.endpoint = self.$urlParts.params.endpoint)) {
			var sdataIndex = $url.search(/\/sdata\//i);
			if (sdataIndex >= 0) {
				self.$urlParts.endpoint = $url.slice(sdataIndex + ("/sdata/").length).split("/").slice(0, 3).join(".");
			} else {
				var x3Index = $url.search(/\/trans\//i);
				if (x3Index >= 0) {
					self.$urlParts.endpoint = $url.slice(x3Index + ("/trans/").length).split("/").slice(0, 3).join(".");
					self.$urlParts.target = "trans";
					self.$urlParts.isFusion = true;
				} else {
					self.$urlParts.endpoint = document.site.userProfile ? document.site.userProfile.getSelectedEndpointString() : null;
				}
			}
		}
		// crnit: don't put a default endpoint name, this will allow to detect if no endpoint was selected in user profile
		// but keep endpoint parts with default values (for now ?)
		// self.$urlParts.endpoint = self.$urlParts.endpoint || "syracuse.collaboration.syracuse";
		self.$urlParts.endpoint = self.$urlParts.endpoint;
		//var endpointParts = self.$urlParts.endpoint.split(".");
		var endpointParts = (self.$urlParts.endpoint || "syracuse.collaboration.syracuse").split(".");
		//
		if (endpointParts.length == 3) {
			self.$urlParts.endpointParts = {
				application: endpointParts[0],
				contract: endpointParts[1],
				dataset: endpointParts[2]
			};
		}

		if (self.$urlParts.params.representation) {
			var result = self.$urlParts.params.representation.split(".");
			self.$urlParts.representationRoot = result[0];
			self.$urlParts.$facet = result[1];
		}
	},
	applyParameters: function(params) {
		var self = this;
		var paramObj = {};
		var paramString, key, ii, jj;
		var paramsStart = self.$url.lastIndexOf("?");
		if (paramsStart >= 0) {
			var parts = self.$url.slice(paramsStart + 1).split("&");
			for (ii = 0, jj = parts.length; ii < jj; ii++) {
				var part = parts[ii];
				var valueStart = part.indexOf("=");
				paramObj[part.substring(0, valueStart)] = part.substring(valueStart + 1);
			}
			self.$url = self.$url.substring(0, paramsStart);
		}
		var $keys = Object.keys(params);
		for (ii = 0, jj = $keys.length; ii < jj; ii++) {
			key = $keys[ii];
			if (params[key] != null) {
				paramObj[key] = encodeURIComponent(params[key]);
			}
		}
		paramString = "";
		$keys = Object.keys(paramObj);
		for (ii = 0, jj = $keys.length; ii < jj; ii++) {
			key = $keys[ii];
			paramString += "&" + key + "=" + paramObj[key];
		}
		self.$url += "?" + paramString.slice(1);
	},
	_prepareRequest: function(options) {
		var self = this;
		self.headers = self.headers || {};
		if (options && options.headers) {
			for (var prop in options.headers) {
				self.headers[prop] = options.headers[prop];
			}
		}
		self.method = options.method || "GET";
		/*if (options.$acceptType) {
         self.headers.Accept = options.$acceptType || "application/json;vnd.sage=syracuse";
         }*/
		self.headers.Accept = options.$acceptType || "application/json;vnd.sage=syracuse; charset=utf-8";
		if (options.$contentType) {
			self.headers["content-type"] = options.$contentType;
		}
		self.dataType = self.dataType || function() {
			var dataType = self.headers["Accept"] || self.headers["content-type"] || "text/html";
			if (dataType.indexOf("application/json") != -1) {
				dataType = "json";
			} else {
				dataType = "text";
			}
			return dataType;
		}();
		// content type
		self.headers["content-type"] = self.headers["content-type"] || (self.dataType === "json" ? "application/json" : "");
		// should "accept" the user's profile language
		var l = document.site && document.site.userProfile && document.site.userProfile.getSelectedLocale();
		if (!(options && options.headers && options.headers["accept-language"])) {
			if (l && l.code) self.headers["accept-language"] = l.code;
		}
		//
		if (options.data) {
			self.sendData = self.dataType === "json" ? JSON.stringify(options.data) : options.data;
		}
		if (options.jsonParams) {
			options.params = options.params || {};
			Object.keys(options.jsonParams).forEach(function(key) {
				options.params[key] = jsurl.stringify(options.jsonParams[key]);
			});
		}
		if (options.params) {
			self.applyParameters(options.params);
		}
		if (options.$etag) {
			self.headers["If-Match"] = options.$etag;
		}
		if (!BROWSER_VERBS_ALLOWED[self.method]) {
			self.headers["X-HTTP-Method-Override"] = self.method;
			self.method = "POST";
		}
	},
	sendRequest: function(options, onSuccess, onError) {
		var self = this;
		var initialSid = document.site.getSessionId();
		self._prepareRequest(options || {});
		//manage proxy
		var parsedUrl = self.$url.toLowerCase();
		if (parsedUrl.indexOf(window.location.protocol) == 0 && parsedUrl.indexOf(window.location.protocol + "//" + window.location.host) != 0) {
			self.$url = "/proxy?url=" + encodeURIComponent(self.$url);
		}
		document.site.notifyRequestSurvey(++_pendingRequests);
		// FK : in order to resolve backslash trouble regarding Chrome vs Firefox behaviour
		if (self.$url.indexOf("\\") >= 0) {
			self.$url = encodeURI(self.$url);
		}
		$.ajax({
			url: self.$url,
			type: self.method,
			dataType: self.dataType,
			data: self.sendData,
			xhrFields: self.xhrFields,
			contentType: self.headers["content-type"],
			async: options && options.syncRqst ? false : true,
			beforeSend: function(jqXHR, settings) {
				//Should modify settings with jQuery 1.5 ?
				forEachKey(self.headers, function(key, value) {
					jqXHR.setRequestHeader(key, value);
				});

				// in order to handle cases in which many requests are sent with same $etag (because of late server response)
				// it is for working copy edit only !
				if (self.$url.indexOf("$workingCopies") != -1) {
					var $uuid = helpers.uuid.generate();
					document.site.wcReqArray = document.site.wcReqArray || [];
					if (document.site.wcReqArray.length != 0) {
						var data = JSON.parse(this.data);
						if (data.$etag) {
							data.$etag++;
						}
						this.data = JSON.stringify(data);
					}
					document.site.wcReqArray.push($uuid);
					jqXHR.uuid = $uuid;
					jqXHR.$isOnEditWC = true;
				}
			},
			success: function(data, textStatus, jqXHR) {
				if (!self._handleOnEditWC(jqXHR)) {
					var response = _parseResponse(jqXHR, data);
					if (initialSid && (document.site.getSessionId() !== initialSid) && document.site.userProfile && !document.site.userProfile.onLogonProcessing) {
						document.site.logon(function() {
							onSuccess(response.data, response, self.$url);
						});
					} else {
						onSuccess(response.data, response, self.$url);
					}
					// timer to handle convergence session disconnection in case of timeout
					disconnectUtils.updateTimer();
				}
			},
			error: function(jqXHR, textStatus, errorThrown) {
				console.log("error status = " + jqXHR.status);
				if (!self._handleOnEditWC(jqXHR)) {

					var localize = locale.resources(module)();
					var error = _parseResponse(jqXHR, null);
					var ajax = this;
					var reqOptions = {};
					switch (jqXHR.status) {
						case 0:
							//error.data = error.data ? error.data : localize.http_0;
							_onResponseError(self, error, options, onError);
							break;
						case 404:
							reqOptions = {
								"method": "POST",
								"$location": {}
							};
							//---------------------------------------
							// handling working copy expired 404 case
							//---------------------------------------
							// logout and user profile specific cases
							var dataObj = ajax.data ? JSON.parse(ajax.data) : dataObj;

							if (dataObj && dataObj.$actions) {
								// in case of logout
								if (dataObj.$actions.$logout && dataObj.$actions.$logout.$isRequested) {
									var $url = "/";
									setTimeout(function() {
										document.site.unload();
										window.open($url, "_self");
									}, 100);
								} else {
									// in case of some user profile property value change, or in case of regular WC save
									if (dataObj.$actions.$save && dataObj.$actions.$save.$isRequested) {

										// user profile
										if (dataObj.$url && dataObj.$url.indexOf("userProfile") != -1) {
											if (sessionStorage && document.site.userProfile) {
												var key = "userProfile";
												if (sessionStorage.getItem(key)) {
													var data = {};
													data = JSON.parse(sessionStorage.getItem(key));
													reqOptions.$location.$url = data.wcpreloadUrl;
													reqOptions.data = JSON.parse(ajax.data);
													reqOptions.$etag = reqOptions.data ? reqOptions.data.$etag : reqOptions.$etag;
													document.controller.sendRequest(document.site.userProfile, reqOptions);
												} else {
													_onResponseError(self, error, options, onError);
												}
											} else {
												_onResponseError(self, error, options, onError);
											}
										}

										// regular WC save action
										else {
											_onWCNotFound(self, error, options, onError, reqOptions, dataObj, true);
										}
									} else {
										_onWCNotFound(self, error, options, onError, reqOptions, dataObj);
									}
								}
							} else {
								// in case of 404 after a lookup query, display $diagnoses
								if (ajax.url.indexOf("$lookup") != -1 && error.data) {
									var errData = JSON.parse(error.data);
									if (errData.$diagnoses) {
										document.site.showDiagnoses({
											$diagnoses: errData.$diagnoses
										});
									}
								} else {
									// other cases
									_onWCNotFound(self, error, options, onError, reqOptions);
								}
							}
							break;
						case 412:
							reqOptions = {
								$message: localize.http_412,
								$title: localize.http_412_title,
								$type: "alert",
								$buttons: "yesno",
								callback: function(response) {
									if (response.$id === "yes") {
										ajax.success(JSON.parse(jqXHR.responseText), jqXHR.statusText, jqXHR);
									}
								}
							};
							document.site.showMessage(reqOptions);
							break;
						default:
							_onResponseError(this, error, options, onError);
					}
				}
			}
		});
	},
	_handleOnEditWC: function(jqXHR) {
		if (!jqXHR.$isOnEditWC) {
			return false;
		} else {
			var isPrevReqReplied = document.site.wcReqArray.length > 1;

			// remove corresponding element from wcReqArray
			// getting corresponding index
			var indexToRemove = document.site.wcReqArray.indexOf(jqXHR.uuid);
			document.site.wcReqArray.splice(indexToRemove, 1);

			// decrease requests count
			if (isPrevReqReplied) {
				document.site.notifyRequestSurvey(--_pendingRequests);
			}

			return isPrevReqReplied;
		}
	},
	sendCorsRequest: function(opts, onSuccess, onError) {
		var url = this.$url,
			options = opts || {}, method = this.method = options.method || "GET";

		var xhr = new XMLHttpRequest();
		if ("withCredentials" in xhr) {
			// Most browsers.
			xhr.open(method, url, true);
		} else if (typeof XDomainRequest != "undefined") {
			// IE8 and IE9
			xhr = new XDomainRequest();
			xhr.open(method, url);
		} else {
			// CORS not supported.
			xhr = null;
		}

		xhr.onreadystatechange = onSuccess || options.onreadystatechange;
		xhr.onloadstart = options.onloadstart;
		xhr.onprogress = options.onprogress;
		xhr.onabort = options.onabort;
		xhr.onerror = onError || options.onerror;
		xhr.onload = options.onload;
		xhr.ontimeout = options.ontimeout;
		xhr.onloadend = options.onloadend;
		xhr.send();
	}
});

function _onResponseError(httpquery, error, options, onError) {
	if (!options || !options.noDisplayErr || !onError) {
		_onReceiveError(error);
	}
	if (onError) {
		onError(error, httpquery);
	}
}

function _onWCNotFound(httpQuery, error, options, onError, reqOptions, dataObj, onSave) {
	if (document.site && document.site.mainPage && document.site.mainPage.openerHttpQuery) {

		if (document.site.mainPage.openerHttpQuery.workingCopyPreloadUrl) {
			reqOptions.$location.$url = document.site.mainPage.openerHttpQuery.workingCopyPreloadUrl;

			if (onSave && dataObj && dataObj.$actions && document.site.mainPage.dataset && document.site.mainPage.dataset.$actions) {
				var dataset = helpers.object.clone(document.site.mainPage.dataset);
				dataset.$actions = dataObj.$actions;
				reqOptions.data = dataset;
			} else {
				reqOptions.data = dataObj || document.site.mainPage.dataset;
			}

			reqOptions.$etag = document.site.mainPage.dataset.$etag;
		} else {
			if (sessionStorage) {
				var key = document.site.mainPage.openerHttpQuery.$url;
				if (sessionStorage.getItem(key)) {
					var data = {};
					data = JSON.parse(sessionStorage.getItem(key));
					reqOptions.$location.$url = data.wcpreloadUrl;
					reqOptions.data = dataObj || data.dataset;
					reqOptions.$etag = reqOptions.data ? reqOptions.data.$etag : reqOptions.$etag;
				} else {
					_onResponseError(httpQuery, error, options, onError);
				}
			} else {
				_onResponseError(httpQuery, error, options, onError);
			}
		}
		document.controller.sendRequest(document.site.mainPage, reqOptions);
	} else {
		_onResponseError(httpQuery, error, options, onError);
	}
}

exports.parseUrl = function($url) {
	var httpQuery = new HttpQuery();
	httpQuery.parse($url);
	return httpQuery;
};