var _formatApi = {
    "application/x-integer": require('syracuse-core/lib/types/integer'),
    "application/x-decimal": require('syracuse-core/lib/types/decimal'),
    "application/x-real": require('syracuse-core/lib/types/real'),
    "application/x-date": require('syracuse-core/lib/types/date'),
    "application/x-time": require('syracuse-core/lib/types/time'),
    "application/x-datetime": require('syracuse-core/lib/types/datetime')
};

exports.getApi = function($type){
    return _formatApi[$type];
};

function _getTwoDigitYearMax(){
    var locale = document.site.userProfile || _defaultLocale;
    return locale.getTwoDigitYearMax();
}

var _defaultLocale = {
    getDateFormat: function(displayFormat){
        return displayFormat == "DD" ? "dd MMMM yyyy" : "yyyy-MM-dd";
    },
    getTimeFormat: function(displayFormat){
        return displayFormat == "TT" ? "HH:mm:ss" : "HH:mm";
    },
    getDatetimeFormat: function(displayFormat){
        var format;
        switch (displayFormat) {
            case "F": // sortable datetime format
                format = "yyyy-MM-ddTHH:mm:ss";
                break;
            case "FF": // full datetime format
                format = "dd MMMM yyyy HH:mm:ss";
                break;
            case "U": // universal sortable datetime format 
                format = "yyyy-MM-dd HH:mm:ssZ";
                break;
            default: // datetime default format is dateformat + space + timeformat
                format = this.getDateFormat() + " " + this.getTimeFormat();
        }
        return format;
    },
    getNumberFormatObj: function(type){
        var formatObj = {};
        formatObj.numFormat = type == "application/x-integer" ? "#,###" : "#,###.##";
        formatObj.decimalSeparator = ".";
        formatObj.groupSeparator = "";
        formatObj.groupSize = 3;
        return formatObj;
    },
    getNumberFormat: function(type){
        return this.getNumberFormatObj(type).numFormat;
    },
    getTwoDigitYearMax: function(){
        return 2029;
    }
};

function _getLocale(){
    return document.site.userProfile || _defaultLocale;
}

exports.getLocale = _getLocale;

exports.getLocalFormat = function(type, $displayFormat){ // return the corresponding date format
    var format;
    var locale = _getLocale();
    switch (type) {
        case "application/x-date":
            format = locale.getDateFormat($displayFormat);
            break;
        case "application/x-time":
            format = locale.getTimeFormat($displayFormat);
            break;
        case "application/x-datetime":
            format = locale.getDatetimeFormat($displayFormat);
            break;
        default:
            format = $displayFormat || locale.getNumberFormat(type);
            break;
    }
    return format;
};

/**
 * Handles datetime input field formatting
 * @param {Object} field
 * @param {Object} $$input
 */
exports.formatInput = function(field, $$input){
    switch (field.$field.$type) {
        case "application/x-date":
            return _formatDateInput(field, $$input);
            break;
        case "application/x-time":
            return _formatTimeInput(field, $$input);
            break;
        case "application/x-datetime":
            break;
        case "application/x-integer":
        case "application/x-decimal":
        case "application/x-real":
            return _formatNumberInput(field, $$input);
            break;
        default:
            return "Invalid input. Unknown type or type undefined. Type = " + field.$type;
    }
}

/**
 * Format date input
 * @param {Object} field
 * @param {Object} $$input
 */
// TO IMPROVE
function _formatDateInput(field, $$input){
    var directives = ["dirOne", "dirTwo", "dirThree"];
    var val = $$input.val();
    var err = "invalid date : " + val + ". Format : " + field.localFormat;
    var fObj = field.formatObj;
    var s = fObj.separator;
    var splitted = val.split(/[^\d]+/); // split into numeric groups
    splitted = _clean(splitted);
    var splittedLen = splitted.length;
    var twoDigitYearMax = _getTwoDigitYearMax().toString();
    switch (splittedLen) {
        case 1: // assuming 2 digits min per directive (ex: ddMMyy)
            var date = splitted[0];
            var dateLen = date.length;
            switch (dateLen) {
                case 6: // ddMMyy
                    directives.forEach(function(dir){
                        var f = fObj[dir];
                        var max = f.max;
                        // if 'y' dir is encountered before the end, year.length is 2
                        var yBeforeEnd = dir != directives[directives.length - 1] && f.dir == 'y';
                        f.date = yBeforeEnd ? date.substring(0, 2) : date.substring(0, max);
                        //f.date = date.substring(0, max);
                        // dealing with y case
                        if (f.dir == "y") {
                            var len = f.date.length;
                            switch (len) {
                                case 2: // yy < yyyy ?
                                    f.date = len < max ? (f.date > twoDigitYearMax.substring(2) ? "19" + f.date : "20" + f.date) : f.date;
                                    break;
                                default:
                                    return err;
                            }
                        }
                        date = date.substring(yBeforeEnd ? 2 : max);
                    });
                    // if error, return same value
                    break;
                case 8: // ddMMyyyy
                    directives.forEach(function(dir){
                        var f = fObj[dir];
                        var max = f.max;
                        // If it is the last directive, the remaining of date value is considered --> substring(0)
                        f.date = dir == directives[directives.length - 1] ? date.substring(0) : date.substring(0, max);
                        // dealing with y case
                        if (f.dir == "y") {
                            var len = f.date.length;
                            switch (len) {
                                case 4: // yyyy > yy ?
                                    f.date = f.date.length > f.max ? f.date.substring(2) : f.date;
                                    break;
                                default:
                                    return err;
                            }
                        }
                        date = date.substring(max);
                    });
                    break;
                default:
                    return err;
            }
            break;
        case 3: // day, month and year
            var i = 0;
            splitted.forEach(function(spl){
                var f = fObj[directives[i]];
                var max = f.max;
                if (/[dM]/.test(f.dir) && spl.length > max) { // splitted number length cannot exceed directive maxLength for "d" and "M" directives
                    return err;
                }
                else {
                    f.date = spl;
                    // dealing with y case
                    if (f.dir == "y") {
                        var len = f.date.length;
                        switch (len) {
                            case 2: // yy < yyyy ?
                                f.date = f.date.length < max ? (f.date > twoDigitYearMax.substring(2) ? "19" + f.date : "20" + f.date) : f.date;
                                break;
                            case 4: // yyyy > yy ?
                                f.date = f.date.length > max ? f.date.substring(2) : f.date;
                                break;
                            default:
                                return err;
                        }
                    }
                }
                ++i;
            });
            break;
        default:
            return err;
    }
    // setting formatted input value
    var dateObj = field.formatApi.parse(fObj[directives[0]].date + s + fObj[directives[1]].date + s + fObj[directives[2]].date, field.localFormat);
    $$input.val(dateObj.toString(field.localFormat));
}

/**
 * Format time input
 * @param {Object} field
 * @param {Object} $$input
 */
function _formatTimeInput(field, $$input){
    var val = $$input.val();
    var err = "invalid time : " + val;
    var splitted = val.split(/[^\d]+/); // split into numeric groups
    splitted = _clean(splitted);
    var splittedLen = splitted.length;
    var hour = '00', minute = '00', second = '00';
    switch (splittedLen) {
        case 1: // assuming 2 digits min per directive (ex: hhmmss)
            var time = splitted[0];
            var timeLen = time.length;
            switch (timeLen) {
                case 4: // hhmm
                    hour = time.substring(0, 2);
                    minute = time.substring(2);
                    break;
                case 6: // hhmmss
                    hour = time.substring(0, 2);
                    minute = time.substring(2, 4);
                    second = time.substring(4);
                    break;
                default:
                    return err;
            }
            break;
        case 2: // hour and minute
            var hour = splitted[0];
            var minute = splitted[1];
            break;
        case 3: // hour, minute and second
            var hour = splitted[0];
            var minute = splitted[1];
            var second = splitted[2];
            break;
        default:
            return err;
    }
    var am = field.formatApi.amDesignator();
    var pm = field.formatApi.pmDesignator();
    var hasAM = val.indexOf(am.toUpperCase()) > -1 || val.indexOf(am.toLowerCase()) > -1;
    var hasPM = val.indexOf(pm.toUpperCase()) > -1 || val.indexOf(pm.toLowerCase()) > -1;
    if (hasAM || hasPM) {
        hour = parseInt(hour, 10);
        if (hour > 12) 
            return "invalid time. With AM/PM designator, hour value cannot be greater than 12";
        if (hasAM) 
            hour = hour == 12 ? 0 : hour;
        else {
            if (hour >= 1 && hour <= 11) {
                hour += 12;
            }
        }
    }
    
    hour = hour.toString().length < 2 ? '0' + hour : hour.toString();
    minute = minute.toString().length < 2 ? '0' + minute : minute.toString();
    second = second.toString().length < 2 ? '0' + second : second.toString();
    
    // formatting
    var timeObj = field.formatApi.parse(hour + ":" + minute + ":" + second);
    $$input.val(timeObj.toString(field.localFormat));
}

/**
 * Format datetime input
 * @param {Object} field
 * @param {Object} $$input
 */
function _formatDatetimeInput(field, $$input){

}

/**
 * Format number input
 * @param {Object} field
 * @param {Object} $$input
 */
function _formatNumberInput(field, $$input){
    var val = $$input.val();
    var err = "invalid number : " + val;
    var type = field.$field.$type;
    var numFormatObj = field.numFormatObj;
    var ds = numFormatObj.decimalSeparator;
    var gs = numFormatObj.groupSeparator;
    
    var chars_ok = "0-9-+";
    
    // for decimal values, removing invalid chars and setting '.' as decimal separator (javascript float)
    if (type == "application/x-decimal" || type == "application/x-real") {
    	
		chars_ok += ds;
		
        if (gs != ".") {
            var regexp = new RegExp("[^" + chars_ok + "." + "]", "g");
            val = val.replace(regexp, '');
        }
        else {
            var regexp = new RegExp("[^" + chars_ok + "]", "g");
            val = val.replace(regexp, '');
        }
        
        if (ds != ".") {
            var regexp = new RegExp(ds, "g");
            val = val.replace(regexp, '.');
        }
    }
    // for integer values, removing invalid chars
    else {
        var regexp = new RegExp("[^" + chars_ok + "]", "g");
        val = val.replace(regexp, '');
    }
    
    val = type == "application/x-decimal" ? parseFloat(val) : parseInt(val, 10);
    
    // control
    if (isNaN(val)) 
        return err;
    
    // formatting
    var formatApi = field.formatApi;
    var format = field.localFormat;
    var numObj = formatApi.parse(val);
    $$input.val(formatApi.format(numObj, format));
}

/**
 * Returns JSON formatObj with some properties :
 * - dirOne : first directive
 * - dirTwo : second ...
 * - dirThree : third ...
 * each directive has properties : *directive* (actual directive) and *count* (minimum digits)
 * - maxLenght : maximum possible date length according to the format
 * @param {String} format : date format
 * @return {Object} formatObj
 */
// TO IMPROVE
exports.processFormat = function(format){
    var i = 0, len = format.length;
    var formatObj = {};
    var directives = ["dirOne", "dirTwo", "dirThree"];
    
    function count(i){
        var ch = format[i], k = 1;
        while (format[i + k] === ch) 
            k++;
        return k;
    }
    
    function addSeparator(c){
        if (!formatObj.separator) {
            formatObj.separator = c;
        }
    }
    
    function addDirective(c, count){
        for (var i = 0; i < directives.length; i++) {
            var d = directives[i];
            if (!formatObj[d]) {
                formatObj[d] = {};
                formatObj[d].dir = c;
                formatObj[d].count = count;
                formatObj[d].max = count < 2 ? 2 : count;
                break;
            }
        }
    }
    
    function addMaxLength(){
        var maxLength = 0;
        directives.forEach(function(d){
            maxLength += formatObj[d].count > 2 ? formatObj[d].count : 2;
        });
        maxLength += 2;
        formatObj.maxLength = maxLength;
    }
    
    
    while (i < len) {
        var c = format[i];
        switch (c) {
            case "'":
                i++;
                var literal = '';
                // going to the end of the following litteral or to the format end
                for (; i < len; i++) {
                    if (format[i] === "'") {
                        i++;
                        // check wether the "'" is not doubled
                        if (format[i] === "'") {
                            literal += "'";
                        }
                        else 
                            break;
                    }
                    else {
                        literal += format[i];
                    }
                }
                addSeparator(literal);
                break;
            case "d":
            case "M":
            case "y":
                var repeat = count(i);
                addDirective(c, repeat);
                i += repeat;
                break;
            default:
                addSeparator(c);
                i++;
        }
    }
    
    addMaxLength();
    
    return formatObj;
}


/**
 * Remove empty elements
 */
function _clean(arr){
    return $.grep(arr, function(n){
        return (n);
    });
    
}
