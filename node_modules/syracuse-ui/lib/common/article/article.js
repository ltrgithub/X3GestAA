"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Box = require("./box").Box;
var _templatePattern = /(\{.*?\})/g;

function Article(){

}

exports.Article = helpers.defineClass(Article, Box, {
    loadBox: function(initData){
        document.controller.registerArticle(this);
        var articleParent = this.getArticleParent();
        
        //a revoir pas terrible
        if (articleParent) {
            this.$facet = this.$facet || articleParent.$facet;
            this.$isEditMode = this.$isEditMode === undefined ? articleParent.$isEditMode : this.$isEditMode;
            this.$prototype = this.$prototype || articleParent.$prototype.$[this.$item.$bind];
        }
        this.dataset = {};
        this.boundFields = {};
        this.idMap = {};
        this.menuItems = {};
        this.$menus = {};
        this.menuBoxes = [];
        this.drawBox();
        this.applyActionLinkChange(this.$prototype);
        if (initData) {
            this.applyChange(initData);
        }
        this._bindFieldEvents();
    },
    reloadArticle: function(){
        var dataset = this.dataset;
        document.controller.disposeObject(this._dispose());
        this.loadBox(dataset);
    },
    _bindFieldEvents: function(){
        var self = this;
        if (self.$$item) {
            self.$$item.delegate("input[data-s-field],select[data-s-field]", "click change keydown keypress keyup focusin focusout", function(event){
                var $$target = $(event.target);
                var field = self.idMap[$$target.attr("data-s-field")];
                if (field) {
                	console.log(field.$item.$bind + " " + event.type);
                    self.getPage().externalAdapter.onFieldEvent({
                        field: field,
                        event: event,
                        doEvent: function(){
                            //    onInputFocusin,onInputFocusout,onInputKeyup,onInputKeydown,onInputKeypress: function($$input, event){
                            var fnct = "onInput" + event.type.charAt(0).toUpperCase() + event.type.slice(1);
                            if (field[fnct]) {
                                field[fnct]($$target, event);
                            }
                        }
                    });
                }
                else {
                    //      debugger;
                }
                event.stopPropagation();
            });
            if (document.site.$isFieldEditOnflyEnabled || self.$item.$isFieldEditOnfly) {
                self.$$item.delegate("[data-s-field]", "click", function(event){
                    var $$target = $(event.currentTarget);
                    var field = self.idMap[$$target.attr("data-s-field")];
                    if (field && !field.$isEditMode) {
                        setTimeout(function(){
                            document.editFieldController.toggleEditMode(field);
                        }, 10);
                    }
                    event.stopPropagation();
                });
            }
        }
        else {
            //debugger;
        
        }
    },
    getArticleParent: function(){
        return this.boxParent ? this.boxParent.getArticle() : null;
    },
    getArticle: function(){
        return this;
    },
    getPage: function(){
        if (!this.page) {
            this.page = this.boxParent ? this.boxParent.getArticle().getPage() : null;
        }
        return this.page;
    },
    bindMenuBox: function(box){
        var self = this;
        self.menuBoxes.push(box);
        if (self.$menus) {
            Object.keys(self.$menus).forEach(function($bind){
                var item = self.menuItems[$bind];
                if (!item || (item.length == 0)) {
                    box.addMenuItem(self.$menus[$bind], self.dataset);
                }
            });
        }
    },
    bindMenuItem: function(item){
        var bounds = this.menuItems[item.$item.$bind];
        if (!bounds) {
            bounds = this.menuItems[item.$item.$bind] = [];
        }
        bounds.push(item);
        var $menu = this.$menus[item.$item.$bind];
        if ($menu) {
            item.setMenu($menu);
        }
    },
    unbindMenuItem: function(item){
        if (this.menuItems) {
            var bounds = this.menuItems[item.$item.$bind];
            if (bounds) {
                for (var ii = 0; ii < bounds.length; ii++) {
                    if (bounds[ii] == item) {
                        bounds.splice(ii, 1);
                        break;
                    }
                }
            }
        }
    },
    applyActionLinkChange: function(resources, record){
        var self = this;
        if (record) {
            Object.keys(self.menuItems).forEach(function($bind){
                self.menuItems[$bind].forEach(function(menu){
                    menu.setMenu(null, record);
                });
            });
        }
        if (resources) {
            if (resources.$links) {
                self._applyMenuChange(resources.$links, record);
            }
            if (resources.$actions) {
                self._applyMenuChange(resources.$actions, record, true);
            }
        }
    },
    _applyMenuChange: function($deltaMenu, record, $isAction){
        var self = this;
        Object.keys($deltaMenu).forEach(function($bind){
            var $menu = $deltaMenu[$bind];
            $menu.$isAction = $isAction;
            $menu.$bind = $bind;
            var $memMenu = self.$menus[$bind];
            if ($memMenu) {
                Object.keys($menu).forEach(function($property){
                    switch ($property) {
                        case "$links":
                        case "$actions":
                            var $delta = $menu[$property];
                            var $mem = $memMenu[$property] = $memMenu[$property] || {};
                            Object.keys($delta).forEach(function($bind){
                                var $source = $delta[$bind];
                                var $target = $mem[$bind] || {};
                                Object.keys($source).forEach(function($prop){
                                    $target[$prop] = $source[$prop];
                                });
                            });
                            break;
                        default:
                            $memMenu[$property] = $menu[$property];
                            break;
                    }
                });
            }
            else {
                self.$menus[$bind] = $menu;
            }
            var bounds = self.menuItems[$bind];
            if (bounds) {
                bounds.forEach(function(menu){
                    menu.setMenu($menu, record);
                });
            }
            else {
                self.menuBoxes.forEach(function(box){
                    box.addMenuItem($menu, record);
                });
            }
        });
    },
    _applyDelta: function(target, source){
        if (source) {
            var self = this;
            Object.keys(source).forEach(function(property){
                var targetValue = target[property];
                var sourceValue = source[property];
                if (targetValue == null || sourceValue === null) {
                    target[property] = sourceValue;
                }
                else {
                    target[property] = typeof(sourceValue) != "object" ? sourceValue : self._applyDelta(targetValue, sourceValue);
                }
            });
        }
        return target;
    },
    applyChange: function(newData){
        if (newData) {
            var self = this;
            var actionsLinks;
            if (newData.$links || newData.$actions) {
                actionsLinks = {
                    $links: newData.$links,
                    $actions: newData.$actions
                };
                delete newData.$links;
                delete newData.$actions; //avoid copy of action links
            }
            var metaDatas = newData.$ || {};
            delete newData.$;
            if (newData.$title) {
                self.renderTitle(newData.$title);
            }
            if (newData.$description) {
                self.renderDescription(newData.$description);
            }
            Object.keys(newData).forEach(function(property){
                var bounds = self.boundFields[property];
                var newValue = newData[property];
                if (bounds) {
                    var metaData = metaDatas[property];
                    bounds.forEach(function(item){
                        item.setDataBind(newValue, newData, metaData);
                    });
                    if (metaData) {
                        delete metaDatas[property];
                    }
                }
                if (typeof(newValue) == 'object') {
                    var recordValue = self.dataset[property];
                    newValue = ((recordValue == null || newValue == null) || Array.isArray(newValue)) ? newValue : self._applyDelta(recordValue, newValue);
                }
                self.dataset[property] = newValue;
            });
            //apply rest of metadata
            var data;
            Object.keys(metaDatas).forEach(function(property){
                var bounds = self.boundFields[property];
                if (bounds) {
                    var metaData = metaDatas[property];
                    bounds.forEach(function(item){
                        item.setDataBind(data, newData, metaData);
                    });
                }
            });
            
            self.applyActionLinkChange(actionsLinks, self.dataset);
            if (newData.$diagnoses) {
                document.site.showDiagnoses({
                    $diagnoses: newData.$diagnoses
                }, self);
            }
            self.dataset.$loaded = true;
        }
    },
    bind: function(item, $bind){
        (this.boundFields[$bind] = this.boundFields[$bind] || []).push(item);
        var store = this.dataset.$loaded ? this.dataset : this.$prototype; //set loaded value or default value
        item.setDataBind(store[$bind], store);
    },
    matchProperty: function(property, record){
        var value;
        if ((value = record[property]) === undefined) {
            if ((value = this.$prototype[property]) === undefined) {
                var articleParent = this.getArticleParent();
                if (articleParent) {
                    value = articleParent.matchProperty(property, articleParent.dataset);
                }
            }
        }
        return value;
    },
    parseExpression: function(expression, record){
        var result = expression;
        var self = this;
        var recordSource = record || self.dataset;
        if (result && result.indexOf("{") >= 0) {
            if (result[1] == "@") {
                var text = result.slice(1, result.length - 1);
                if (self.$prototype.$localization) {
                    return self.$prototype.$localization[text] || text;
                }
                return text;
            }
            else {
                var matches = result.match(_templatePattern);
                matches.forEach(function(match){
                    var property = match.substr(1, match.length - 2);
                    var value = self.matchProperty(property, recordSource);
                    if (value != null) {
                        if (value.indexOf && value.indexOf("{") >= 0) {
                            value = self.parseExpression(value, recordSource);
                        }
                        else {
                            if (typeof(value) == "object") {
                                value = value.$uuid || value.$key || null;
                                if (value == null) {
                                    console.log("can not match " + property + " in " + expression);
                                }
                            }
                        }
                        if (value != null) {
                            result = result.replace(match, value);
                        }
                    }
                });
            }
        }
        return result;
    },
    removeItem: function(item, removeDom){
        if (removeDom) {
            if (item.remove) {
                item.remove();
            }
            else {
                if (item.$$item) {
                    item.$$item.remove();
                }
            }
        }
        if (item.id) {
            delete this.idMap[item.id];
        }
        if (item.dispose) {
            document.controller.disposeObject(item);
        }
    },
    _dispose: function(){
        if (this.$$item) {
            this.$$item.undelegate();
        }
        delete this.menuItems;
        delete this.$menus;
        delete this.menuBoxes;
        if (this.idMap) {
            document.controller.disposeObject(this.idMap);
            delete this.idMap;
        }
        delete this.$layoutOptions;
    },
    dispose: function(){
        document.controller.removeArticle(this);
        this._dispose();
        Box.prototype.dispose.call(this);
    }
});
