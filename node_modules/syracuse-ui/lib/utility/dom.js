"use strict";
var _escaper = require('html-escape').escaper({
	warn: (function(msg) {
		// phantomjs compatible code
		if (console.warn && typeof console.warn === "function")
			console.warn(msg);
		else
		if (console.log && typeof console.log === "function")
			console.log(msg);
	})
});

var _zIndex = 110;


exports.toggleClass = function(node, css, show) {
	if (node) {
		var className = node.className;
		if (className !== undefined) {
			if (show) {
				if (className.indexOf(css) < 0) {
					node.className = className + (" " + css);
				}
			} else {
				node.className = className.replace(css, "");
			}
		}
	}
};

exports.disable = function(node, isDisabled, noCss) {
	if (isDisabled) {
		node.setAttribute("disabled", node.syraIsDisabled = isDisabled);
	} else {
		if (node.syraIsDisabled) {
			delete node.syraIsDisabled;
			node.removeAttribute("disabled");
		}
	}!noCss && exports.toggleClass(node, "s-disabled", isDisabled);
};
exports.toggle = function(node) {
	node.style.display = exports.isDisplay(node) ? "none" : "";
};

exports.hide = function(node, isHidden) {
	if (node) {
		var display = isHidden ? "none" : "";
		if (node.style.display != display) {
			node.syraIsHidden = isHidden;
			node.style.display = display;
		}
	}
};


exports.isVisible = function(node) {
	var top = syra_site && syra_site.layoutSlot;
	if (top) {
		while (node && node != top) {
			if (node.syraIsHidden || (node.style && node.style.display == "none")) {
				return false;
			}
			node = node.parentNode;
		}
		return node == top;
	}
	return false;
};

exports.isDisplay = function(node) {
	return node.style.display != "none";
};
exports.empty = function(node) {
	if (node) {
		while (node.firstChild) {
			node.removeChild(node.firstChild);
		}
	}
};
exports.isParent = function(parent, node) {
	while (node && node != document) {
		if (node == parent) {
			return true;
		}
		node = node.parentNode;
	}
	return false;
};
exports.remove = function(node) {
	if (node && node.parentNode) {
		node.parentNode.removeChild(node);
	}
};
exports.moveChildNodes = function(source, target) {
	while (source.childNodes.length) {
		target.appendChild(source.childNodes[0]);
	}
};

exports.getNodeIndex = function(node) {
	var parentNode = node && node.parentNode;
	if (parentNode) {
		var nodes = parentNode.childNodes;
		for (var ii = 0, jj = nodes.length; ii < jj; ii++) {
			if (nodes[ii] == node) {
				return ii;
			}
		}
	}
	return -1;
};
exports.getInnerSize = function(node) {
	var rect = node.getBoundingClientRect();
	var size = {
		height: rect.height, // node.clientHeight,
		width: rect.width //  node.clientWidth
	};
	var style = window.getComputedStyle(node, null);
	size.height -= parseFloat(style.getPropertyValue("padding-top"));
	size.height -= parseFloat(style.getPropertyValue("padding-bottom"));
	size.width -= parseFloat(style.getPropertyValue("padding-left"));
	size.width -= parseFloat(style.getPropertyValue("padding-right"));
	return size;
};

exports.getBoundingClientRect = function(node, area) {
	var rect = node.getBoundingClientRect();
	area = area || {};
	area.top = Math.round(rect.top);
	area.bottom = Math.round(rect.bottom);
	area.left = Math.round(rect.left);
	area.right = Math.round(rect.right);
	area.width = Math.round(rect.width);
	area.height = Math.round(rect.height);
	return area;
};


exports.setZIndex = function(node, check, zIndex) {
	if (zIndex) {
		if (node) {
			node.style.zIndex = zIndex;
		}
		return zIndex;
	}
	if (check && node && node.style.zIndex == _zIndex) {
		return _zIndex;
	}
	_zIndex++;
	if (node) {
		node.style.zIndex = _zIndex;
	}
	return _zIndex;
};
exports.getTopZIndex = function() {
	return _zIndex;
};



exports.addInput = function(css, parent, type) {
	var input = document.createElement("input");
	input.setAttribute("type", type || "text");
	input.setAttribute("spellcheck", false);
	input.setAttribute("autocorrect", "off");
	input.className = css;
	parent && parent.appendChild(input);
	return input;
};

exports.addEditable = function(css, parent) {
	var div = document.createElement("div");
	div.setAttribute("contenteditable", "true");
	div.className = css + " s-contenteditable";
	parent && parent.appendChild(div);
	return div;
};

exports.addTextArea = function(css, parent, rows) {
	var input = document.createElement("textarea");
	input.setAttribute("spellcheck", false);
	input.setAttribute("autocorrect", "off");
	input.setAttribute("rows", rows);
	input.className = css;
	parent && parent.appendChild(input);
	return input;
};

exports.addDiv = function(css, parent) {
	var div = document.createElement("div");
	div.className = css;
	parent && parent.appendChild(div);
	return div;
};

exports.addFontIcon = function(css, fontKey, parent) {
	var icon = exports.addDiv(css + " s-fonticon-btn", parent);
	icon.innerHTML = fontKey;
	return icon;
};

exports.addText = function(css, text, parent) {
	var div = document.createElement("div");
	div.className = css;
	div.textContent = text;
	parent && parent.appendChild(div);
	return div;
};

exports.addPreformatText = function(css, text, parent) {
	var pre = document.createElement("pre");
	pre.className = css;
	pre.innerHTML = _escaper(text);
	parent && parent.appendChild(pre);
	return pre;
};

exports.innerHTML = function(node, data) {
	node.innerHTML = _escaper(data);
};
exports.textToHTML = function(text) {
	return (text || "").replace(/\r\n/g, "<br/>").replace(/\n/g, "<br/>").replace(/\s/g, "&nbsp;");
};
exports.escape = function(data) {
	return _escaper(data);
};