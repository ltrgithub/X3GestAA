var $ = jQuery;
var controller = require('../../squeryController/controller').controller;
var helpers = require('syracuse-core/lib/helpers');
var GeoCode = require('./geoloc').GeoCode;
var Template = require('./simpleTemplate').Template;

$.fn.syraGmap = function(settings) {
	
	var self = this;
	
	var _settings = $.extend({
	}, settings);

	var _map = null;
	var _markers = [];
	var _currentLatitude = null;
	var _currentLongitude = null;
	var _optionsForShowBound = {top:30, right:10, left:50};
	var geocode = new GeoCode();
	
	function _init() {
		var canvas = $("<div/>").appendTo($(self));
		canvas.css({
			width : '500px',
			height : '300px'
		});

		_map = new GMap2(canvas[0]);
		_map.setCenter(new GLatLng(0, 0), 13);
		_map.setUIToDefault();
		
		$s({
	        connectorName: _settings.connectorName,
	        binding: _settings.binding
	    }).onChange(setValue);		
	}	
	
	function _addPoint(lat, lng, tooltip) {
		if (lat !== _currentLatitude || lng !== _currentLongitude) {
			_currentLatitude = lat;
			_currentLongitude = lng;
		}		
		var coords = new GLatLng(lat, lng);
		var marker = new GMarker(coords, {title : tooltip});
    	_map.addOverlay(marker);
		_markers.push(marker);
	}
	
	function _resizeViewport() {
		var markerBounds = new GLatLngBounds();
		for(var i = 0; i <_markers.length; i++){
			markerBounds.extend(_markers[i].getLatLng());
		}
		_map.showBounds(markerBounds, _optionsForShowBound);
		if (_markers.length === 1) {
			_map.panTo(_markers[0].getLatLng());
		}
	}

	function _geoCode(values){
		values.forEach(function(value, i) {
			geocode.geocode(value,
			function(result) {
				if (result == null) {
					alert('not found'); //TODO: Change this
				}
				var loc = result.geometry.location;
				var tooltip = _tooltips.length ? _tooltips[i] : '';
				_addPoint(loc.lat, loc.lng, tooltip);
				_resizeViewport();
			}, function(list) {
				_map.openInfoWindow(_map.getCenter(), list.toHTML());
			});
		});
	}
	
	function _reset() {
		_markers = [];
		_map.clearOverlays(); 
	}

	var _tooltips = [];
	function setValue(value)  {
		_reset();
		var values = null;
		if (typeof value == 'string') {
			values = value.split(';');
		}
		else {
			if (value instanceof Array) {
				values = value;
			} else {
				values = [value];
			}
			if (_settings.tooltipQuery != null) {
				var template = new Template(_settings.tooltipQuery);
				_tooltips = values.map(function(v) {
					return template.evaluate(v);
				});
			}			
			var template = new Template(_settings.bindingQuery);
			values = values.map(function(v) {
				return template.evaluate(v);
			});	
		}
		_geoCode(values);
		//TODO : Si Object, voir si on trouve latitude et longitude.
	}
	
	_init();
		
	return self;
};

/**
 * GMap2.showBounds() method
 * @ author Esa 2008
 * @ param bounds_ GLatLngBounds()
 * @ param opt_options Optional options object {top, right, bottom, left, instant, save}
 */
GMap2.prototype.showBounds = function(bounds_, opt_options){
  var opts = opt_options||{};
  opts.top = opt_options.top*1||0;
  opts.left = opt_options.left*1||0;
  opts.bottom = opt_options.bottom*1||0;
  opts.right = opt_options.right*1||0;
  opts.save = opt_options.save||true;
  opts.disableSetCenter = opt_options.disableSetCenter||false;
  var ty = this.getCurrentMapType();
  var port = this.getSize();
  if(!opts.disableSetCenter){
    var virtualPort = new GSize(port.width - opts.left - opts.right, 
                            port.height - opts.top - opts.bottom);
    this.setZoom(ty.getBoundsZoomLevel(bounds_, virtualPort));
    var xOffs = (opts.left - opts.right)/2;
    var yOffs = (opts.top - opts.bottom)/2;
    var bPxCenter = this.fromLatLngToDivPixel(bounds_.getCenter());
    var newCenter = this.fromDivPixelToLatLng(new GPoint(bPxCenter.x-xOffs, bPxCenter.y-yOffs));
    this.setCenter(newCenter);
    if(opts.save)this.savePosition();
  }
  var portBounds = new GLatLngBounds();
  portBounds.extend(this.fromContainerPixelToLatLng(new GPoint(opts.left, port.height-opts.bottom)));
  portBounds.extend(this.fromContainerPixelToLatLng(new GPoint(port.width-opts.right, opts.top)));
  return portBounds;
}

