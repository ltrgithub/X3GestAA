"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion "Window" Classes (Stack, model, etc...) and Utilities
 */
var helpers = require('syracuse-core/lib/helpers');
var util = require('syracuse-ui/lib/fusion/tools/util');
var syraUtil = require('./util').Syra;
var Action = require('./action');
var EntityStore = require('./entityStore').EntityStore;
var MenuManagement = require('./winMenu').MenuManagement;
var _sapUtil = require('syracuse-ui/lib/fusion/core/client/sap/util').Fusion;
var EventHandlingCore = require('../evtmanager');

var _customWinClassK = {};
var _metaScopesForDelayedBind = [{
	"excludeRow": true,
	"excludeCell": true,
	"excludeLine": true
}, {
	"excludeRow": true,
	"excludeCell": true,
	"excludeArray": true
}, {
	"excludeLine": true,
	"excludeCell": true,
	"excludeArray": true
}, {
	"excludeLine": true,
	"excludeRow": true,
	"excludeArray": true
}];
var _winK = {
	"stubWins": {
		"entities": "setEntitiesValue",
		"statBar": "_setStatusBar",
		"tit": "_setTitle"
	},
	"actsType": ["$links", "$actions"],
	"stackDeb": 1,
	"portalWin": "A"
};

var _instVtbl = {
	"default": {
		"_getDataInput": "getValue",
		"_setDataStore": "_setDataField",
		"_getDataStore": "_getDataField",
		"_getDataFmt": "_getFmtField",
		"getCtxProps": "_getFieldCtxProps",
		"isDatasetColl": false,
		"_getState": "_getStateField"
	}
};

_instVtbl[syraUtil.dataTypes.collectionType] = {
	"_getDataInput": "_getValueCel",
	"_setDataStore": "_setDataColl",
	"_getDataStore": "_getDataColl",
	"_getDataFmt": "_getFmtColl",
	"isDatasetColl": true,
	"removeFocus": "resetFocus",
	"setFocusStyle": "setFocusStyle",
	"_getState": "_getStateColl"
};
_instVtbl[syraUtil.dataTypes.rtfType] = {
	"_getDataInput": "getInputValue",
	"removeFocus": "resetFocus",
	"getCtxProps": "_getRtfFieldCtxProps"
};
_instVtbl[syraUtil.dataTypes.iconType] = {
	"_setDataStore": "_setDataIconField"
};
_instVtbl[syraUtil.dataTypes.booleanType] = {
	"_setDataStore": "_setDataBoolField"
};
_instVtbl[syraUtil.dataTypes.imageType] = {
	"_setDataStore": "_setDataImageField"
};
_instVtbl[syraUtil.dataTypes.reference] = {
	"_getDataInput": "_getValueFieldRef",
	"_setDataStore": "_setDataFieldRef",
	"_getDataStore": "_getDataFieldRef",
	"isDatasetColl": false
};
_instVtbl[syraUtil.dataTypes.choiceType] = {
	"_getDataInput": "_getValueChoiceField",
	"_setDataStore": "_setDataChoiceField"
};

/*_instVtbl[syraUtil.dataTypes.dateType] = {
 "_getDataInput": "getInputValue"
 };*/
/*_instVtbl[syraUtil.dataTypes.boWebiDoc] = {
	"setFocus": "setFocus"
};*/

_instVtbl[syraUtil.dataTypes.htmlVignette] = _instVtbl[syraUtil.dataTypes.boWebiDoc];
_instVtbl[syraUtil.dataTypes.htmlType] = _instVtbl[syraUtil.dataTypes.rtfType];

/* Misc utilities */

function _storeCommit(rule) {
	return rule && rule.hasOwnProperty("noStoreCommmit") ? !rule.noStoreCommmit : true;
}

function _getNextFieldDescObj(params, action) {
	return {
		"ok": true,
		"srvAct": true,
		"act": action,
		"params": util.duplicateObj(params)
	};
}

function _getArrayBoundCell($array, entity, idx) {
	return idx !== undefined && idx >= 0 ? $array.getField(entity, idx) : undefined;
}

function _getFocusFldForBounds($fieldBounds, $entityType, len) {
	var i, $bound = $fieldBounds[len - 1],
		meta;
	for (i = 0; i < len; i++) {
		if ((meta = syra_fusion.syraUtil.getMetaFromObject($fieldBounds[i]))) {
			if ($entityType == syra_fusion.syraUtil.dataTypes.collectionType && meta.$format && meta.$format == "grid") {
				// TODO : improve... cas du mode dual, etc, ...
				$bound = $fieldBounds[i];
				break;
			} else
			if ($entityType !== syra_fusion.syraUtil.dataTypes.collectionType) {
				// TODO : What about graphical bloc linked to other type?
			}
		}
	}
	return $bound;
}

function _getValueFldForBounds($fieldBounds, $entityType, len) {
	var i, $bound = $fieldBounds[len - 1],
		meta;
	for (i = 0; i < len; i++) {
		if ((meta = syra_fusion.syraUtil.getMetaFromObject($fieldBounds[i]))) {
			if ($entityType == syra_fusion.syraUtil.dataTypes.collectionType && meta.$format && meta.$format == "grid") {
				$bound = $fieldBounds[i];
				break;
			} else
			if ($entityType !== syra_fusion.syraUtil.dataTypes.collectionType) {
				// TODO : What about graphical bloc linked to other type?
			}
		}
	}
	return $bound;
}

/* Window Stack Management class */

function WinStack() {
	this._stack = [];
	for (var i = 0; i < _winK.stackDeb; i++) {
		this._stack[i] = null;
	}
	this._windows = {};
	this._actionsList = null;
}

exports.WinStack = helpers.defineClass(WinStack, null, {
	initialize: function(sapController) {
		// Misc
		(this._actionsList = new Action.ActionsList()).initialize(this);
		this._sapController = sapController;
		// Hard declaration of the "portal" Window...
		var idEx = this._getWinIdEx(_winK.portalWin);
		(this._windows[idEx.id] = new WinModel()).initialize(idEx, null, null);
		this._stack[idEx.rank] = idEx.id;
		// Menus management
		this.winMenus = new MenuManagement();

	},

	setGlobalMenu: function(session, cmnMenus) {
		this.winMenus.initialize(this, session, cmnMenus);
	},

	setWinMenu: function(winId, facet, menu, winProto, options) {
		this.winMenus.addMnuBarToProto(winId, facet, menu, winProto, options);
	},

	length: function() {
		return this._stack.length - _winK.stackDeb;
	},

	getTopWin: function(id, rank, model) {
		var idEx = this._getWinIdEx(this.length()),
			ret = null;
		return id ? idEx.id : (rank ? idEx.rank : this._windows[idEx.id]);
	},

	isActiveWindow: function(id) {
		return !!(this.length() == (this._getWinIdEx(id)).rank);
	},

	getBoundField: function(winId, xid, opts) {
		var win = this.getWindow(winId);
		return win ? win.getBoundField(xid, opts) : null;
	},

	getEntityType: function(winId, xid, opts) {
		var win = this.getWindow(winId),
			proto = win ? win.getProto() : null;
		return proto ? syra_fusion.syraUtil.getEntityType(xid, proto, opts && opts.keepRef ? true : false) : null;
	},

	setActionsState: function(actions) {
		var self = this;
		return this._actionsList.setState(actions, this.getTopWin(true), null, function(winId, syraPage, actId, enable) {
			// Show/hide registered menus, according action status
			self.winMenus.updateMnuItem(syraPage, actId, !enable);
		}, this.winMenus.hideAccordingActivation || {});
	},

	isActionEnabled: function(winId, action, categorie) {
		var win = this._getWinIdEx(winId);
		return win ? this._actionsList.getState(action, win.id, categorie) : false;
	},

	shouldDiscardCloseOpen: function(closeId, openWins) {
		// "close" and "open" clauses on the same Window ID...
		var ret = false,
			idExClose, closeWin, discardAllWinType = true;
		if (openWins && (idExClose = this._getWinIdEx(closeId))) {
			if (openWins[idExClose.id]) {
				if (!this._windows[idExClose.id]) {
					// Win ID is not already in the Window Stack, wich means open, then close on the same window ==> discard open/close
					ret = true;
				} else
				if ((closeWin = this.getWindow(idExClose.id)) && closeWin.isSameWin(openWins[idExClose.id]) && (discardAllWinType || syra_fusion.sapUtil.isSpecialWin(closeWin.getWinName()))) {
					// Avoid to close then reopen same win/function
					ret = true;
				}
			}
		}
		return ret;
	},

	razWinData: function(winId) {
		var win = this.getWindow(winId);
		if (win) {
			win._releaseDataEx();
			win._initDataEx({
				"keepDataset": true
			});
		}
	},

	stack: function(id, winDef, syraPageModel) {
		// Register Window
		var idEx = this._getWinIdEx(id),
			proto;
		this._windows[idEx.id] = _customWinClassK[winDef.name] ? new _customWinClassK[winDef.name]() : new WinModel();
		this._windows[idEx.id].initialize(idEx, winDef, syraPageModel, this._sapController.fmtWrapper, this.winMenus);
		if (this.length() < idEx.rank) {
			this._stack.push(idEx.id);
		} else {
			//Oups, server has opened a window with a lower rank than the stack length!
			this._stack[idEx.rank] = idEx.id;
		}
		// Register Window actions
		proto = syra_fusion.syraUtil.getProtoFromPage(syraPageModel);
		_.each(_winK.actsType, function(type) {
			this.registerWinActions(proto[type], idEx.id, type);
		}, this._actionsList);
		this._sapController.getSiteController().triggerAdx("sap.win.stacked", {
			"target": this._windows[idEx.id],
			"type": "opened",
			"data": {}
		});
	},

	unStack: function(id, rank, dispose, isPortal) { // does it make sense to keep rank and dispose as it never used
		var idEx = this._getWinIdEx(id),
			win = this._windows[idEx.id],
			syraPage = null,
			i;
		if (win) {
			this.winMenus.releaseWinMenu(id);
			this._actionsList.unregisterAllWinActions(idEx.id);
			this._sapController.getSiteController().triggerAdx("sap.win.unstack", {
				"target": this._windows[idEx.id],
				"type": "close",
				"data": {}
			}, dispose);
			syraPage = win.getSyraPage();
			win.dispose();
			delete this._windows[idEx.id];
			if (idEx.rank == this.length()) {
				this._stack.pop();
				i = this._stack.length;
				while (i > 0) {
					// Cleanup zombie occurrences
					if (this._stack[--i] == null) {
						this._stack.pop();
					} else {
						break;
					}
				}
			} else {
				// Oups, server has closed an other window than the last stacked!
				this._stack[idEx.rank] = null;
			}
			this._sapController.getSiteController().triggerAdx("sap.win.unstacked", {
				"target": null,
				"type": "closed",
				"data": {
					"sheet": syraPage
				}
			}, dispose);
		} else {
			//TODO : error?
		}
	},

	getWindow: function(winId) {
		var idEx = this._getWinIdEx(winId);
		return this._windows[idEx.id] || null;
	},

	getWindowProto: function(winId) {
		var win = this.getWindow(winId);
		return (win ? win.getProto() : null);
	},

	getSyraModel: function(winId) {
		var win = this.getWindow(winId);
		return (win ? win.syraModel : null);
	},

	applyChange: function(winId, change, options, fromSrv, srvReply) {
		var page, ret = null,
			applyChangeOpts = null,
			changeKeys, nbChanges, i, changeType, entitiesKeys = null,
			entityKeys, retEx = {}, idEx = this._getWinIdEx(winId);
		if (!options) {
			options = {};
		}
		changeKeys = Object.keys(change);
		nbChanges = changeKeys.length;
		options.currSrvTarget = fromSrv && srvReply && this._sapController.getTargetIstFromReply(srvReply);
		// Perf improvement start
		if (nbChanges == 1 && changeKeys[0] == "entities") {
			entitiesKeys = Object.keys(change[changeKeys[0]]);
			if (entitiesKeys.length == 0) {
				nbChanges = 0;
			} else
			if (entitiesKeys.length == 1) {
				entityKeys = Object.keys(change[changeKeys[0]][entitiesKeys[0]]);
				if (entityKeys.length == 1 && entityKeys[0] == "$mvt" && change[changeKeys[0]][entitiesKeys[0]][entityKeys[0]].length == 0) {
					nbChanges = 0;
				}
			}
		}
		// Perf imporvement end
		if (this._windows[idEx.id] && nbChanges > 0) {
			if (fromSrv) {
				if (this._sapController.isReplyFromTabulationAction(srvReply)) {
					applyChangeOpts = {
						"tabulation": true,
						"field": this._windows[idEx.id].getBoundField(options.currSrvTarget.xid, syra_fusion.sapUtil.isGridInst(options.currSrvTarget) ? {
							"arrayCell": options.currSrvTarget.nl
						} : null)
					};
				}
				(page = this._windows[idEx.id].getSyraPage()).startChange(applyChangeOpts);
			}
			for (i = 0; i < nbChanges; i++) {
				changeType = changeKeys[i];
				if (_winK.stubWins[changeType] && this._windows[idEx.id][_winK.stubWins[changeType]]) {
					retEx[changeType] = this._windows[idEx.id][_winK.stubWins[changeType]](change[changeType], options, fromSrv, entitiesKeys);
				}
			}
			if (fromSrv) {
				page.endChange();
			}
		} else {
			// TODO : exception, return code, etc...
		}
		/*_.each(retEx, function(diagnoses, task) {
         if (diagnoses) {
         // TODO : check return code ==> ret = ...
         }
         }, this);*/
		if (options.currSrvTarget) {
			delete options.currSrvTarget;
		}
		return ret;
	},

	postBuildInit: function(winId) {
		var win = this.getWindow(winId),
			secMap, pageFacet, syraModel, sectionMeta, xid, barLists, i, ii, jj, mm, nn, keysProto, propProto, fields, field, len, metaBar, metaObj = {}, listId, j = 0,
			lenj, $XID = syra_fusion.sapUtil.metaNameMap.xid;
		if (win && (syraModel = win.getSyraPage())) {
			pageFacet = win.getSyraPageFacet();
			// Get Ptr to Tab Folder. Folder are natively ordered in "childrenSection" array!
			if (pageFacet === syra_fusion.syraUtil.pageFacet.edit) {
				if ((barLists = syraModel.childrenSection)) {
					win.$folderTabs = [];
					for (i = 0, len = barLists.length; i < len; i++) {
						if (barLists[i].isSection) {
							if ((sectionMeta = syra_fusion.syraUtil.getMetaFromObject(barLists[i])) && (xid = sectionMeta[$XID])) {
								if (barLists[i].isTabLayout && !barLists[i].isInvisible) {
									win.$folderTabs.push(barLists[i]);
								}
							}
						}
					}
					if ((len = win.$folderTabs.length) && syraModel.$persistPrototype) {
						// Recompute tab section $XID value... to deal with transaction authoring stuff - Cf. SAM 93749!
						secMap = syra_fusion.syraUtil.getTopSectionsMap(syraModel.$persistPrototype.$article);
						if (secMap && (lenj = secMap.length)) {
							for (i = 0; i < len; i++) {
								if ((xid = win.$folderTabs[i].$item) && xid.$title) {
									for (j = 0; j < lenj; j++) {
										if (xid.$title == secMap[j].$title) {
											xid[$XID] = secMap[j][$XID];
											break;
										}
									}
								}
							}
						}
					}
				}
			}
			// Extra process for window preview
			if (win.isPreviewWin() && syraModel.fusionBar && (barLists = syraModel.fusionBar.blocks)) {
				metaBar = syra_fusion.sapUtil.setState({
					"$isDisabled": true,
					"$isHidden": true
				}, 0);
				for (i = 0, len = barLists.length; i < len; i++) {
					listId = syra_fusion.syraUtil.getMetaFromObject(barLists[i]);
					if ((listId = listId.$bind)) {
						metaObj[listId] = {
							"$meta": {
								"stt": [
									[listId, 0, metaBar]
								]
							}
						};
					}
				}
				win.setEntitiesValue(metaObj);
			}
			if (win.getWinName() === syra_fusion.sapUtil.specialWindow.selbox.id) {
				keysProto = Object.keys(syraModel.$prototype.$properties);
				for (ii = 0, jj = keysProto.length; ii < jj; ii++) {
					propProto = syraModel.$prototype.$properties[keysProto[ii]];
					if (propProto.$type == syra_fusion.syraUtil.dataTypes.collectionType) {
						fields = syraModel.boundFields[keysProto[ii]];
						for (mm = 0, nn = fields.length; mm < nn; mm++) {
							field = fields[mm];
							field.$item.$isSelBoxList = true;
						}
					}
				}
			}
		}
	},

	showWinTab: function(winId, tabNum) {
		var win = this.getWindow(winId),
			$tab = win && win.$folderTabs ? win.$folderTabs[tabNum - 1] : null;
		syra_fusion.syraUtil.showTab($tab, {
			"internal": true
		});
		return $tab ? true : false;
	},

	setFocus: function(winId, highlight, style, entity) {
		var ret = null,
			page, idEx = this._getWinIdEx(winId),
			$tab;
		if (this._windows[idEx.id]) {
			if (syra_fusion.sapUtil.isSpecialScrnId(entity)) {
				if (syra_fusion.sapUtil.isButtonScreen(entity)) {
					ret = _getNextFieldDescObj(syra_fusion.sapUtil.getButtonValue(), "SRV_CHAMP_SUIVANT");
				} else
				if (syra_fusion.sapUtil.isTabScreen(entity)) {
					$tab = _.find(this._windows[idEx.id].$folderTabs, function(tab) {
						var $tabMeta = syra_fusion.syraUtil.getMetaFromObject(tab);
						return $tabMeta && $tabMeta.$opened;
					});
					if ($tab) {
						syra_fusion.syraUtil.setTabFocus($tab);
					}
				} else
				if (syra_fusion.sapUtil.isListScreen(entity)) {
					ret = this._windows[idEx.id].setFocus.apply(this._windows[idEx.id], Array.prototype.slice.call(arguments, 1));
					if (ret) {
						// Perhpas list exists, but not yet built
						if ((page = this.getSyraModel(idEx.id)) && page.fusionBar && page.fusionBar.focus(highlight, entity)) {
							ret = null;
						}
					}
				}
			} else {
				ret = this._windows[idEx.id].setFocus.apply(this._windows[idEx.id], Array.prototype.slice.call(arguments, 1));
			}
		}
		return ret;
	},

	setDataStoreValue: function(winId) {
		var ret = false,
			winModel = this.getWindow(winId);
		if (winModel) {
			winModel.setDataStoreValue.apply(winModel, Array.prototype.slice.call(arguments, 1));
			ret = true;
		}
		return ret;
	},

	getDataFmt: function(winId, xid, line, opts) {
		var winModel = this.getWindow(winId);
		return winModel ? winModel.getDataFmt.call(winModel, xid, line, opts) : null;
	},

	setDirty: function(winId) {
		var winModel = this.getWindow(winId);
		if (winModel) {
			winModel.setDirty.apply(winModel, Array.prototype.slice.call(arguments, 1));
		}
	},

	getDataStoreValue: function(winId) {
		var winModel = this.getWindow(winId);
		return winModel ? winModel.getDataStoreValue.apply(winModel, Array.prototype.slice.call(arguments, 1)) : null;
	},

	getDataInputValue: function(winId, entity) {
		var ret = null,
			idEx = this._getWinIdEx(winId);
		if (this._windows[idEx.id]) {
			if (syra_fusion.sapUtil.isSpecialScrnId(entity)) {
				if (syra_fusion.sapUtil.isButtonScreen(entity) || syra_fusion.sapUtil.isListScreen(entity)) {
					ret = syra_fusion.sapUtil.getButtonValue();
				} else
				if (syra_fusion.sapUtil.isTabScreen(entity)) {
					ret = syra_fusion.sapUtil.getObjFieldValue(this._sapController.getCurrTabIdx(), syra_fusion.sapUtil.fieldModeType.rough);
				}
			} else
			if (!entity || entity.length === 0) {
				// We are on a window (preview screen, formula editor, Standard window, etc...)
				ret = null;
			} else {
				ret = this._windows[idEx.id].getDataInputValue.apply(this._windows[idEx.id], Array.prototype.slice.call(arguments, 1));
			}
		}
		return ret;
	},

	removeFocus: function(winId) {
		var idEx = this._getWinIdEx(winId);
		if (this._windows[idEx.id]) {
			this._windows[idEx.id].removeFocus.apply(this._windows[idEx.id], Array.prototype.slice.call(arguments, 1));
		}
	},

	_getWinIdEx: function(id) {
		var idEx = {
			"id": id,
			"rank": id
		};
		(_.isNumber(id) ? idEx.id = syra_fusion.sapUtil.getWinId(id) : idEx.rank = syra_fusion.sapUtil.getWinRank(id));
		return idEx;
	},

	enumStack: function(iterator, context) {
		var args = arguments;
		if (this._stack && this._stack.length > 0) {
			for (var i = this._stack.length - 1; i >= _winK.stackDeb; i--) {
				if (this._stack[i] != null) {
					iterator.apply(context, [this._stack[i], i].concat(Array.prototype.slice.call(args, 2)));
				}
			}
		}
	},

	findStack: function(iterator, context) {
		var win = null,
			args = arguments;
		if (this._stack && this._stack.length > 0) {
			for (var i = this._stack.length - 1; i >= _winK.stackDeb; i--) {
				if (this._stack[i] != null && iterator.apply(context, [this._stack[i], i].concat(Array.prototype.slice.call(args, 2)))) {
					win = this._stack[i];
					break;
				}
			}
		}
		return win;
	},

	delayedDataBinding: function(options) {
		var win, i, syraPage, logger = this._sapController.getlogger(),
			sess = this._sapController._session;
		if (this._stack) {
			for (i = this._stack.length - 1; i >= _winK.stackDeb; i--) {
				if (this._stack[i] && (win = this.getWindow(this._stack[i])) && win._delayedBinding) {
					if ((syraPage = win.getSyraPage())) {
						syraPage.startChange();
					}
					win.delayedDataBinding(logger, sess, options);
					if (syraPage) {
						syraPage.endChange();
					}
				}
			}
		}
	},

	dispose: function(force) {
		// Hard dispose for Portal Window
		var portalId = this._getWinIdEx(_winK.portalWin),
			winPortal = this._windows[portalId.id];
		winPortal.dispose();
		delete this._windows[portalId.id];
		// Dispose other windows ...
		this.enumStack(this.unStack, this, true);
		// Menus
		if (this.winMenus) {
			this.winMenus.dispose();
			delete this.winMenus;
		}
		delete this._stack;
		if (this._actionsList) {
			this._actionsList.dispose();
			delete this._actionsList;
		}
		delete this._windows;
		if (this._sapController) {
			delete this._sapController;
		}
	}
});

/* Window model class */

function WinModel() {}

WinModel = helpers.defineClass(WinModel, null, {
	initialize: function(idEx, winDef, syraModel, fmtWrapper, menuManager) {
		var $fusionPageMeta = syraModel ? syra_fusion.syraUtil.getFusionPageMeta(syraModel) : null,
			extd, specialWin;
		this._isOurMagicSgxWin_ = true;
		this._idEx = idEx;
		this._mdata = winDef ? util.duplicateObj(winDef) : null;
		this.syraModel = syraModel;
		this._fmtWrapper = fmtWrapper;
		this._menuManager = menuManager;
		this._initDataEx();
		this.initializeFieldsColl(syraModel);
		this._title = "";
		if ($fusionPageMeta) {
			$fusionPageMeta.winModel = this;
		}
		if (this.syraModel) {
			this._$$syraPageItem = $(this.syraModel.domItem);
			// If necessary to bind extra event handlers at window level, please put logic in _bindEvents method
			//this._bindEvents();
		}
		if (this._mdata && this._mdata.name && (specialWin = syra_fusion.sapUtil.isSpecialWin(this._mdata.name))) {
			extd = this._getExtendProps();
			if (extd && extd.title && !this._isFormulaWin) {
				this._setTitle(extd.title);
			}
		}
		this._isNodeWS = this._getSession() ? (this._getSession()).isNodeWS() : null;
	},

	initializeFieldsColl: function(syraModel) {
		this._fieldsColl = {
			"proto": syra_fusion.syraUtil.get$FromPage(syraModel),
			"bound": syra_fusion.syraUtil.getBoundFldsFromPage(syraModel)
		};
	},

	_initDataEx: function(opts) {
		var i, datasetArray = this._dataset ? Object.keys(this._dataset) : null,
			len = datasetArray ? datasetArray.length : 0;
		if (opts && opts.keepDataset && len > 0) {
			for (i = 0; i < len; i++) {
				this._dataset[datasetArray[i]].initStore(this._fmtWrapper.locales);
			}
		} else {
			this._dataset = {};
			this._entityRefTitleMap = {};
		}
		this._statusBar = {
			"ico": {},
			"txt": {}
		};
		this._pendingMeta = {};
		_.each(syra_fusion.sapUtil.screensArray, function(item) {
			this._pendingMeta[item] = {
				"fields": {},
				"conts": {}
			};
		}, this);
	},

	_releaseDataEx: function(opts) {
		this._statusBar = null; // TODO : notify hoster to remove status elements... improve...
		_.each(syra_fusion.sapUtil.screensArray, function(item) {
			delete this._pendingMeta[item].fields;
			delete this._pendingMeta[item].conts;
		}, this);
		_.each(this._dataset, function(entityStore) {
			entityStore[opts && opts.disposeStore ? "dispose" : "releaseStore"]();
		});
	},

	_bindEvents: function() {},

	onWinEvent: function(event, controller) {
		// Is it a fusion grid or one of these children?
		var $$target, $$cont, id, $cont, $contMeta, doEvt = true,
			isGrid = false,
			isField = false,
			caught = false;
		$$cont = ($$target = $(event.target)) ? $$target.closest("." + syra_fusion.syraUtil.gridFusionK.cont) : null;
		isGrid = $$cont && $$cont.length > 0 ? true : false;
		// So, we are on a grid article and at now we let the caller processed the event...
		if (isGrid && event.type == "click") {
			caught = true;
			doEvt = true;
		}
		// Is it a fusion field?
		if (!isGrid) {
			$cont = ($$target && (id = event.target.syra_field_id)) ? this.syraModel.idMap[id] : null;
			isField = ($cont && ($contMeta = syra_fusion.syraUtil.getMetaFromObject($cont))) ? (this.getProto())[$contMeta.$bind] : null;
		}
		// Field fusion events are caught by dedicated handler...
		if (!caught && !isField) {
			// General case
			doEvt = controller.triggerAdx("wdgt.win." + event.type, {
				"target": this,
				"type": event.type,
				"data": {
					"nativeEvt": event
				}
			});
		}
		return doEvt;
	},

	_unBindEvents: function() {
		this._$$syraPageItem.off();
	},

	isSameWin: function(winMeta2Cmp) {
		var ret = false;
		if (this._mdata && this._mdata.name && this._mdata.name === winMeta2Cmp.name) {
			ret = ((!winMeta2Cmp.func && !this._mdata.func) || (winMeta2Cmp.func === this._mdata.func)) && ((!winMeta2Cmp.extend && !this._mdata.extend) || (winMeta2Cmp.extend === this._mdata.extend));
		}
		return ret;
	},

	getFctName: function(onlyName) {
		var ret = null;
		if (this._mdata) {
			ret = onlyName ? this._mdata.func : {
				"title": this.getTitle(),
				"name": this._mdata.func
			};
		}
		return ret;
	},

	isPreviewWin: function() {
		var extendInfo;
		return this._mdata && (extendInfo = this._mdata.extend) && extendInfo.localeCompare("&WIN_PREVIEW") == 0;
	},

	getWinName: function() {
		return this._mdata && this._mdata.name ? this._mdata.name : null;
	},

	_getSession: function() {
		var fusionController = this.syraModel ? syra_fusion.syraUtil.getFusionController(this.syraModel) : null;
		return fusionController ? fusionController.getSession() : null;
	},

	getEntityEx: function(target) {
		var $entityEx, entityEx = null,
			$entities = this.getProto(),
			entity = typeof target == 'object' ? target.xid : target,
			$type = null;
		if ($entities) {
			$type = (($entityEx = $entities[(entityEx = syra_fusion.sapUtil.getBlockInst(entity))]) && $entityEx && $entityEx.$type == syra_fusion.syraUtil.dataTypes.collectionType) ? $entityEx.$type : ($entities[entity] ? $entities[entity].$type : null);
			$entityEx = $entityEx || $entities[(entityEx = entity)];
			return {
				"type": $type,
				"entity": $entityEx ? entityEx : null
			};
		} else {
			return null;
		}
	},

	_getExtendProps: function(raw) {
		return this._mdata ? (raw ? this._mdata.extend : syra_fusion.sapUtil.getWinExtProps(this._mdata.extend)) : null;
	},

	getBoundField: function(entityName, opts) {
		var boundFld = null,
			len, $entityEx = this.getEntityEx(entityName),
			$bounds = this._fieldsColl.bound;
		if ($bounds && $entityEx && $entityEx.entity && $bounds[$entityEx.entity] && ((len = $bounds[$entityEx.entity].length) > 0)) {
			if (len == 1) {
				boundFld = $bounds[$entityEx.entity][0];
			} else {
				// TODO
			}
			if (boundFld && opts && opts.arrayCell && $entityEx.type == syra_fusion.syraUtil.dataTypes.collectionType && entityName != $entityEx.entity) {
				boundFld = _getArrayBoundCell(boundFld, entityName, syra_fusion.sapUtil.getIdxFromNL(opts.arrayCell));
			}
		}
		if (!boundFld && syra_fusion.sapUtil.isSpecialScrnId(entityName)) {
			boundFld = this._getContainerObj(entityName);
		}
		return boundFld;
	},

	getWinId: function() {
		return this._idEx.id;
	},

	getSyraPage: function() {
		return this.syraModel;
	},

	getSyraPageFacet: function() {
		return this.syraModel.$facet;
	},

	getTitle: function() {
		return this._title.length > 0 ? this._title : (this.syraModel && this.syraModel.$prototype && this.syraModel.$prototype.$title ? this.syraModel.$prototype.$title : "No title...");
	},

	getProto: function() {
		return this._fieldsColl.proto;
	},

	getEntityMetaByCriteria: function(entity, type, target, level) {
		return this._dataset[entity] ? this._dataset[entity].getMetaByCriteria(type, target, level) : null;
	},

	setContainerPending: function(screenId) {
		_.each(this._pendingMeta[screenId].conts, function(data, containerName) {
			this._setDataContainer(containerName, data, {
				"options": "notifyChange"
			});
		}, this);
		delete this._pendingMeta[screenId].conts;
		this._pendingMeta[screenId].conts = {};
	},

	delayedDataBinding: function(logger, session, options) {
		var i, j, k, leni, lenj, lenk, storeKeys, delayedObj, delayedObjT, res, data, types = ["dataDyB", "metaDyB"];
		var elapse = (new Date()).getTime(),
			syraElapseEx = {
				"data": 0,
				"meta": 0
			};
		if (this._delayedBinding) {
			storeKeys = Object.keys(this._delayedBinding);
			for (i = 0, leni = storeKeys.length; i < leni; i++) {
				delayedObj = this._delayedBinding[storeKeys[i]];
				for (j = 0, lenj = types.length; j < lenj; j++) {
					if (!(delayedObjT = delayedObj[types[j]])) {
						continue;
					}
					if (delayedObjT.setDataOpts) {
						delete delayedObjT.setDataOpts.partialChange;
					} else {
						delayedObjT.setDataOpts = {};
					}
					delayedObjT.setDataOpts._perfomDelayedRebind = true;
					if (delayedObjT.rebind) {
						if (j == 1) {
							// So, meta...
							for (k = 0, lenk = _metaScopesForDelayedBind.length; k < lenk; k++) {
								// Have to process thus to preserve precedence
								data = {};
								this._dataset[storeKeys[i]].getMetaColl(data, this._dataset[storeKeys[i]].meta, session, _metaScopesForDelayedBind[k]);
								syraElapseEx.meta += delayedObjT.callback.call(this, storeKeys[i], delayedObjT.entityBound, data, delayedObjT.bindOpts, delayedObjT.setDataOpts, logger);
							}
						} else {
							data = {};
							data[storeKeys[i]] = this._dataset[storeKeys[i]].data;
							if (delayedObjT.bindOpts) {
								delete delayedObjT.bindOpts.$isPartialDelta;
							}
							syraElapseEx.data += delayedObjT.callback.call(this, storeKeys[i], delayedObjT.entityBound, data, delayedObjT.bindOpts, delayedObjT.setDataOpts, logger);
						}
					} else
					if (delayedObjT.$resources) {
						for (k = 0, lenk = delayedObjT.$resources.length; k < lenk; k++) {
							syraElapseEx[j == 1 ? "meta" : "data"] = delayedObjT.callback.call(this, storeKeys[i], delayedObjT.entityBound, delayedObjT.$resources[k], delayedObjT.bindOpts, delayedObjT.setDataOpts, logger);
						}
					}
					logger.trace({
						"severety": "warn",
						"toJson": true
					}, "     **** According partial bindind event, perform post-bind in mode '" + (delayedObjT.rebind ? "rebind" : "update") + "' on '" + types[j] + "' for '" + storeKeys[i] + "' of window id '" + this.getWinId() + " - Duration : " + ((new Date()).getTime() - elapse) + " with " + syraElapseEx.data + " for data in syra and " + syraElapseEx.meta + " for meta in syra.");
					delayedObjT.callback = null;
				}
			}
			this._delayedBinding = null;
		}
	},

	setDataStoreValue: function(entityName, line, value, options) {
		var data = {};
		syra_fusion.sapUtil.appendEntitiesValue(data, null, entityName, line, value);
		this.setEntitiesValue(data, options);
	},

	setDirty: function(entityName, line, dirty) {
		var fields = this._fieldsColl.bound ? this._fieldsColl.bound[entityName] : null;
		if (fields && this.getEntityEx(entityName)) {
			for (var ii = 0, jj = fields.length; ii < jj; ii++) {
				var field = fields[ii];
				field.setDirty && field.setDirty(dirty);
			}
		}
	},

	getDataFmt: function(entityName, line, opts) {
		var $type, $entityEx = this.getEntityEx(entityName);
		if ($entityEx) {
			$type = $entityEx.type || "default";
			return this[_instVtbl[$type] && _instVtbl[$type]._getDataFmt ? _instVtbl[$type]._getDataFmt : _instVtbl["default"]._getDataFmt].call(this, entityName, $entityEx.entity, line, opts);
		} else {
			return null;
		}
	},

	getDataStoreRecordsNumber: function(entityName, opts) {
		return this._dataset[entityName] ? this._dataset[entityName].getRecordsNumber(opts) : null;
	},

	getDataStoreValue: function(entityName) {
		var $type, $entityEx = this.getEntityEx(entityName);
		if ($entityEx) {
			$type = $entityEx.type || "default";
			return this[_instVtbl[$type] && _instVtbl[$type]._getDataStore ? _instVtbl[$type]._getDataStore : _instVtbl["default"]._getDataStore].apply(this, arguments);
		} else {
			return null;
		}
	},

	getDataInputValue: function(entity, nl, event) {
		var $entityEx, $bounds = this._fieldsColl.bound,
			ret = null,
			value = null,
			modeType = syra_fusion.sapUtil.fieldModeType.show,
			entityType = null,
			ctxProxy, ctxProps = null,
			notModified = undefined,
			isNotModified = false;
		var $boundField = null,
			len, index, getValueProxy, getStateProxy;
		// Get current field value & properties
		$entityEx = this.getEntityEx(entity);
		if ($entityEx.entity) {
			if ($bounds[$entityEx.entity] && ((len = $bounds[$entityEx.entity].length) > 0)) {
				$boundField = len == 1 ? $bounds[$entityEx.entity][0] : _getValueFldForBounds($bounds[$entityEx.entity], $entityEx.type, len);
				index = syra_fusion.sapUtil.getIdxFromNL(nl);
				entityType = syra_fusion.syraUtil.getEntityType(entity, this.getProto());
				isNotModified = $boundField.isDirty && !$boundField.isDirty();
				if (isNotModified || !$boundField.$isEditMode) {
					notModified = true;
					value = undefined;
				} else {
					getValueProxy = _instVtbl[$entityEx.type] && _instVtbl[$entityEx.type]._getDataInput ? _instVtbl[$entityEx.type]._getDataInput : _instVtbl["default"]._getDataInput;
					if ($boundField[getValueProxy]) {
						value = $boundField[getValueProxy].call($boundField, entity, index, event);
					} else {
						value = this[getValueProxy].apply(this, [$boundField, entity, index]);
					}
					// Check "null" value : we have to translate "null" value returned par Syracuse framework, according to our protocol.
					if (value === null) {
						value = syra_fusion.syraUtil.translateNullValue(entityType);
					}
				}
				//modeType = entityType && (entityType == syra_fusion.syraUtil.dataTypes.stringType || entityType == syra_fusion.syraUtil.dataTypes.dateType) ? syra_fusion.sapUtil.fieldModeType.edit : syra_fusion.sapUtil.fieldModeType.show;
				modeType = entityType ? syra_fusion.sapUtil.fieldModeType.edit : syra_fusion.sapUtil.fieldModeType.show;
				// Get current state
				getStateProxy = _instVtbl[$entityEx.type] && _instVtbl[$entityEx.type]._getState ? _instVtbl[$entityEx.type]._getState : _instVtbl["default"]._getState;
				if (this[getStateProxy].call(this, $boundField, entity, index, {
					"justRO": true
				})) {
					notModified = true;
				}
				// Get current field context properties
				if ((ctxProxy = _instVtbl[entityType] && _instVtbl[entityType].getCtxProps || _instVtbl["default"].getCtxProps)) {
					ctxProps = this[ctxProxy]($boundField, index);
				}
			}
		}
		// Embed current value mode type (show, edit, rough), contextual properties, etc...
		if ((value !== null && value !== undefined) || notModified) {
			ret = syra_fusion.sapUtil.getObjFieldValue(value, modeType, ctxProps, notModified);
		}
		return ret;
	},

	_getValueCel: function($boundField, entity, index) {
		return $boundField[_instVtbl["default"]._getDataInput].call($boundField, entity, index);
	},

	_getValueChoiceField: function($boundField, entity, index) {
		var value, $entity = $boundField.$field;
		if ($boundField.$field && $boundField.$field.$format != "$combo") {
			value = $boundField[_instVtbl["default"]._getDataInput].call($boundField, entity, index);
		} else {
			value = syra_dataset.setFieldValue($boundField);
		}
		return value;
	},

	_getValueFieldRef: function($boundField, entity) {
		// We never have reference field in collection (x-array)
		var value, $entity = $boundField.$field || (this.getProto())[entity],
			refProps = syra_fusion.syraUtil.getRefPropertyEntity($entity),
			property = null;
		value = $boundField.getValue();
		return value !== null && refProps ? value[refProps.property] : value;
	},

	setFocus: function(highlight, style, entity, nl) {
		var fusionController, self = this,
			$entityEx, $bounds = this._fieldsColl.bound,
			args, setFocusStyleProxy, $screenTab = null,
			screenTab, evtData, $boundField, len, index, sess;
		var retOk = null,
			proxyFocusable = true,
			ret = _getNextFieldDescObj(syra_fusion.sapUtil.getObjFieldValue(null, syra_fusion.sapUtil.fieldModeType.show, null, true), "SRV_CHAMP_INACTIF");
		if (!entity || syra_fusion.sapUtil.getScreenRank(entity) == 0) {
			// TODO : Preview screen? standard window?
			ret = retOk;
		} else {
			if (($entityEx = this.getEntityEx(entity)) && $entityEx.entity) {
				if ($bounds[$entityEx.entity] && ((len = $bounds[$entityEx.entity].length) > 0)) {
					// First, check if target is in a screen whose folder has not yet been opened...
					$boundField = len == 1 ? $bounds[$entityEx.entity][0] : _getFocusFldForBounds($bounds[$entityEx.entity], $entityEx.type, len);
					screenTab = $boundField.boxParent;
					while (screenTab && (!screenTab.isSection || !screenTab.isTabLayout)) {
						screenTab = screenTab.boxParent;
					}
					$screenTab = !screenTab || !screenTab.isSection || screenTab.$opened ? null : screenTab;
					if ($screenTab && $screenTab.isTabSection) {
						// So target is on a none displayed folder screen, we fire a "click" on the corresponding tab folder
						args = arguments;
						evtData = {
							"internal": true,
							"callback": function() {
								self.setFocus.apply(self, args);
							}
						};
						syra_fusion.syraUtil.showTab($screenTab, evtData);
						if (!evtData.ok) {
							// TODO : change folder failed... what we should do?
							return retOk;
						}
						return retOk;
					}
					// So, screen is online
					index = syra_fusion.sapUtil.getIdxFromNL(nl);
					args = arguments.length > 4 ? [highlight, entity, index].concat(Array.prototype.slice.call(arguments, 4)) : [highlight, entity, index];
					if ($boundField.focus) {
						if ($entityEx.type == syra_fusion.syraUtil.dataTypes.collectionType && $boundField.$orderBy && !$boundField.$field.$isFusionNavigationList) {
							if (args.length > 3 && args[3])
								$boundField.sorter.cancel($boundField);
						}
						proxyFocusable = $boundField.focus($boundField, args);
					}
					if (proxyFocusable || proxyFocusable === undefined) {
						setFocusStyleProxy = _instVtbl[$entityEx.type] && _instVtbl[$entityEx.type].setFocusStyle ? _instVtbl[$entityEx.type].setFocusStyle : _instVtbl["default"].setFocusStyle;
						if (style === undefined && (fusionController = syra_fusion.syraUtil.getFusionController(this.syraModel))) {
							style = fusionController._sapController.isCurrIstInputValidate() ? syra_fusion.sapUtil.focusStyle.std.code : syra_fusion.sapUtil.focusStyle.fmtErr.code;
						}
						if (setFocusStyleProxy && $boundField[setFocusStyleProxy]) {
							$boundField[setFocusStyleProxy].apply($boundField, [style].concat(args));
						} else {
							// ... call Fusion default stub...
							this._setFocusStyleDef.apply(this, [$boundField, $entityEx.entity, $entityEx.type, style].concat(args));
						}
						ret = retOk;
					} else
					if (proxyFocusable == null && $entityEx.type == syra_fusion.syraUtil.dataTypes.collectionType && syra_fusion.syraUtil.isEntityPopupCard(entity, this.getProto())) {
						// Perhaps mandatory field just set in cardview... or focus for second time
						if (!this._hackCardViewFocus) {
							this._hackCardViewFocus = {};
						}
						if ((syra_fusion.syraUtil.isEntityMandatory(entity, this.getProto()) || this._hackCardViewFocus[entity]) && syra_fusion.sapUtil.isEmptyData(syra_fusion.syraUtil.getEntityType(entity, this.getProto()), this.getDataStoreValue(entity)[index])) {
							this._focusFieldCardView($entityEx.entity, entity, index, $boundField);
							this._hackCardViewFocus = {};
						} else {
							this._hackCardViewFocus = {};
							this._hackCardViewFocus[entity] = true;
						}

					}
				}
			}
		}
		return ret;
	},
	_focusFieldCardView: function(entity, fieldName, index, list) {
		var uuid = this.getCollRcdUUID(entity, index, true);
		syra_menus.click.recordCard(list.recordsMap[uuid]);
	},
	_setFocusStyleDef: function($field, entityEx, entityExType, style, highlight, entity, idx, isEdit, params) {
		var sess, boundCell;
		if (entityExType == syra_fusion.syraUtil.dataTypes.collectionType) {
			boundCell = _getArrayBoundCell($field, entity, idx);
			$field = boundCell !== undefined ? boundCell : $field;
		}
		if (style && $field) {
			// Raz
			this.setFieldError($field, null, true);
			// Set
			if (style == syra_fusion.sapUtil.focusStyle.fmtErr.code && (sess = this._getSession())) {
				this.setFieldError($field, [sess.getlabel("error", "12", "Value does not respect format or type")]);
			}
		}
	},

	removeFocus: function(entity, nl) {
		var $entityEx, $bounds, proxy, $boundField, len, index;
		if (entity && entity.length > 0) {
			$entityEx = this.getEntityEx(entity);
			$bounds = this._fieldsColl.bound;
			if ($entityEx.entity && $bounds[$entityEx.entity] && ((len = $bounds[$entityEx.entity].length) > 0)) {
				index = syra_fusion.sapUtil.getIdxFromNL(nl);
				$boundField = len == 1 ? $bounds[$entityEx.entity][0] : _getFocusFldForBounds($bounds[$entityEx.entity], $entityEx.type, len);
				if ((proxy = _instVtbl[$entityEx.type] ? _instVtbl[$entityEx.type].removeFocus : _instVtbl["default"].removeFocus) && $boundField[proxy]) {
					$boundField[proxy].call($boundField, entity, index);
				} else {
					// ... call Fusion default stub...
					this._removeFocusDef.call(this, $boundField, $entityEx.entity, $entityEx.type, entity, index);
				}
			}
		}
	},

	_removeFocusDef: function($field, entityEx, entityExType, entity, idx) {
		var boundCell;
		if (entityExType == syra_fusion.syraUtil.dataTypes.collectionType) {
			boundCell = _getArrayBoundCell($field, entity, idx);
			$field = boundCell !== undefined ? boundCell : $field;
		}
		if ($field) {
			this.setFieldError($field, null, true);
		}
	},

	setEntitiesValue: function(entities, options, fromSrv, entitiesKey) {
		var $entities = this.getProto(),
			$bounds = this._fieldsColl.bound,
			screen, page, notifyChange = false,
			discardRedraw = false;
		var data, entityName, i, len, arrEntities, entityBounds, $type, features, store;
		if (options) {
			notifyChange = options.notifyChangeAndDiscardRedraw || options.notifyChange;
			discardRedraw = options.notifyChangeAndDiscardRedraw;
			if (notifyChange && (page = this.getSyraPage())) {
				page.startChange();
			} else {
				notifyChange = false;
			}
		}
		if (entitiesKey) {
			arrEntities = entitiesKey.sort();
		} else {
			arrEntities = entities ? (Object.keys(entities)).sort() : [];
		}
		for (i = 0, len = arrEntities.length; i < len; i++) {
			entityName = arrEntities[i];
			if ((data = entities[entityName]) === undefined) {
				continue;
			}
			$type = ($entities[entityName] ? ($entities[entityName].$type || "default") : null);
			if ($entities[entityName]) {
				// Add entity to dataset if necessary
				if (!this._dataset[entityName]) {
					store = this._dataset[entityName] = new EntityStore();
					features = store.initialize($type, _instVtbl[$type] ? _instVtbl[$type].isDatasetColl : _instVtbl["default"].isDatasetColl, entityName, $entities[entityName], this._fmtWrapper, {
						"isNodeWS": this._isNodeWS,
						"locales": this._fmtWrapper.locales
					});
					if (features && features.refTitle) {
						this._entityRefTitleMap[features.refTitle.name] = features.refTitle.refField;
					}
				}
				// Set data
				entityBounds = $bounds[entityName];
				this[_instVtbl[$type] && _instVtbl[$type]._setDataStore ? _instVtbl[$type]._setDataStore : _instVtbl["default"]._setDataStore](entityName, entityBounds, $entities, entities, data, options);
				if (!entityBounds) {
					this._pendingMeta[syra_fusion.sapUtil.getScreenId(entityName)].fields[entityName] = true;
				}
			} else {
				// Perhaps is it a container entity?
				if (!this._setDataContainer(entityName, data, null) && (screen = syra_fusion.sapUtil.getScreenId(entityName)) && this._pendingMeta[screen]) {
					(!this._pendingMeta[screen].conts[entityName] ? this._pendingMeta[screen].conts[entityName] = {} : void(0));
					_.extend(this._pendingMeta[screen].conts[entityName], data);
				}

			}
		}
		if (notifyChange) {
			page.endChange(discardRedraw);
		}
		return null;
	},

	_setStatusBar: function(status, options, fromSrv) {
		var len, i, winMns, ret, item, zone, page = syra_fusion.syraUtil.getPage(this.syraModel),
			autoHide;
		if (status.ico && (winMns = this._menuManager)) {
			for (i = 0, len = status.ico.length; i < len; i++) {
				item = status.ico[i];
				if (item[0] > 0) {
					ret = winMns.addStatusIco(this.getWinId(), page, item[1], item[0], this._statusBar.ico[item[1]] ? true : false);
					this._statusBar.ico[item[1]] = item[0];
				} else {
					ret = winMns.removeStatusIco(this.getWinId(), page, item[1], this._statusBar.ico[item[1]]);
				}
			}
		}
		if (status.t) {
			// TODO : Notify Hoster?
			for (i = 0, len = status.t.length; i < len; i++) {
				item = status.t[i];
				zone = i > 0 ? "zn1" : "zn2";
				//ret = item.length > 0 ? updateStatus(zone, item) : razStatus(zone);
			}
		}
		if (status.notify) {
			autoHide = 0; //4000
			for (i = 0, len = status.notify.length; i < len; i++) {
				if (util.isErrDiagnosis(status.notify[i].$severity, true)) {
					autoHide = 0;
					break;
				}
			}
			syra_fusion.syraUtil.showDiagnoses(status.notify, page, null, autoHide);
		}
		return null;
	},
	_setTitle: function(title, options, fromSrv) {
		this.syraModel.setTitle(this._title = title);
		return null;
	},
	_setDataField: function(entityName, entityBound, winProto, recordSet, data, options, refProps) {
		// Adjust "style" meta
		var newRawValue = false,
			newFmt = false,
			dataPtr = this._dataset[entityName].data,
			fmt, refTitle, refValue = {}, entities = {};
		var commit = _storeCommit(options),
			rawValueEx, rawValue, yetFormatted;
		syra_fusion.sapUtil.cureStyle(data, entityName, this._getSession());
		// Check Format
		if (dataPtr.fmt !== undefined) {
			yetFormatted = options && options.formatted;
			// If entity accept format "dataPtr.fmt" is not undefined... then check if there is a new format in meta
			fmt = dataPtr.fmt;
			if (data.fmt) {
				fmt = data.fmt;
				newFmt = true;
			}
			// Set new raw value... if necessary
			if (data.v !== undefined && data.v !== null && fmt) {
				if (!yetFormatted) {
					rawValue = data.v;
				} else
				if (commit) {
					rawValueEx = this._fmtWrapper.unformat(data.v, this._dataset[entityName].realType, fmt, true);
					rawValue = rawValueEx.succeeded ? rawValueEx.raw : data.v;
				}
				newRawValue = true;
			} else {
				rawValue = dataPtr.$rawV;
			}
			// Formatting data if necessary...
			if (!yetFormatted && fmt && (newFmt || newRawValue)) {
				try {
					data.v = (!rawValue && !dataPtr._fmtEmpty) ? rawValue : this._fmtWrapper.formatter.formatField({
						"format": fmt
					}, rawValue, true, false);
				} catch (e) {
					data.v = rawValue;
				}
			}
		}
		// Bind data & md
		if (entityBound && (!options || !options.noUI)) {
			// A pinch of fun...
			if (data.stt && (data.stt = syra_fusion.syraUtil.purgeStateMeta(winProto[entityName], data.stt)) == null) {
				delete data.stt;
			}
			// Go!
			_.each(entityBound, function(item) {
				if (!refProps) {
					item.setValue(data.v, data);
				} else {
					// So we are on a "reference field"!
					if (data.v !== null && data.v !== undefined && !data.v) {
						// RAZ
						refValue = null;
					} else {
						refValue[refProps.property] = data.v;
						if (refProps.propTitle) {
							// Retrieve reference title... it's a bit clumsy, but we have to be sure to initialize/set properly title data in store
							if (recordSet && recordSet[refProps.propTitle] !== undefined && recordSet[refProps.propTitle].v != undefined) {
								entities[refProps.propTitle] = recordSet[refProps.propTitle];
								this.setEntitiesValue(entities, {
									"noUI": true
								});
								delete recordSet[refProps.propTitle];
							}
							refValue[refProps.propTitle] = this.getDataStoreValue(refProps.propTitle, 0, false, true);
						}
					}
					item.setValue(refValue, data);
				}
			}, this);
		} else
		if (!entityBound && (!options || !options.noUI) && (refTitle = this._entityRefTitleMap[entityName]) && !recordSet[refTitle.entityName]) {
			// Reference title update without is code
			refProps = syra_fusion.syraUtil.getRefPropertyEntity(refTitle._proto);
			if (refProps && (entityBound = this._fieldsColl.bound[refTitle.entityName])) {
				refValue[refProps.propTitle] = data.v;
				refValue[refProps.property] = this.getDataStoreValue(refTitle.entityName, 0, false, true);
				_.each(entityBound, function(item) {
					item.setValue(refValue, data);
				});
			}
		}
		// Update dataset (data & md)
		if (commit) {
			if (dataPtr.fmt === undefined && data.fmt) {
				// Avoid to store an unexpected format
				delete data.fmt;
			}
			for (var prop in data) {
				dataPtr[prop] = data[prop];
			}
			if (newRawValue) {
				dataPtr.$rawV = rawValue;
			}
		}
		return null;
	},

	_setDataFieldRef: function(entityName, entityBounds, winProto, recordSet, data, options) {
		// We never have reference field in collection (x-array)
		var $entity = winProto[entityName],
			refProps = syra_fusion.syraUtil.getRefPropertyEntity($entity),
			type = refProps ? refProps.proto.$type : "";
		this[_instVtbl[type] && _instVtbl[type]._setDataStore ? _instVtbl[type]._setDataStore : _instVtbl["default"]._setDataStore](entityName, entityBounds, winProto, recordSet, data, options, refProps);
	},

	_setDataIconField: function(entityName, entityBound, winProto, recordSet, data, options, refProps) {
		data = syra_fusion.sapUtil.adjustIcoFieldData(data);
		return this._setDataField(entityName, entityBound, winProto, recordSet, data, options, refProps);
	},

	_setDataBoolField: function(entityName, entityBound, winProto, recordSet, data, options, refProps) {
		if (typeof data.v === 'boolean') {
			data.v = data.v ? syra_fusion.sapUtil.check.on : syra_fusion.sapUtil.check.off;
		}
		return this._setDataField(entityName, entityBound, winProto, recordSet, data, options, refProps);
	},

	_setDataChoiceField: function(entityName, entityBound, winProto, recordSet, data, options, refProps) {
		var meta = entityBound ? syra_fusion.syraUtil.getMetaFromObject(entityBound[0]) : null;
		if (meta && meta.$format == "$radios" && (data.v < 0 || (typeof data.v == 'string' && !data.v))) {
			data.v = null;
		}
		return this._setDataField(entityName, entityBound, winProto, recordSet, data, options, refProps);
	},

	_setDataImageField: function(entityName, entityBound, winProto, recordSet, data, options, refProps) {
		var fusionController = syra_fusion.syraUtil.getFusionController(this.syraModel),
			state;
		if (data.stt) {
			state = syra_fusion.sapUtil.getState(data.stt);
			for (var key in state) {
				data[key] = state[key];
			}
		}
		if (data.v && data.v != "") {
			data.v = {
				'$url': fusionController.getImageUrl(data.v)
			};
		}
		return this._setDataField(entityName, entityBound, winProto, recordSet, data, options, refProps);
	},

	_setDataColl: function(entityName, entityBound, winProto, recordSet, data, options) {
		var mvtCode, delta, rcd = {}, commit = _storeCommit(options),
			self = this,
			elapseUnsort = 0,
			elapse = (new Date()).getTime(),
			syraElapseEx = {
				"data": 0,
				"mvt": 0,
				"meta": 0
			}, syraElapse = 0,
			styObj, styEx, setUI = (!options || !options.noUI);
		var logger, fusionController = syra_fusion.syraUtil.getFusionController(this.syraModel),
			leftListColl = syra_fusion.sapUtil.isListScreen(entityName);
		// For authoring mode, it's necessary to store left list data... so now left list collection are processed like others collection.
		var forceLFdataStore = true;
		options = options || {};
		if (leftListColl && !forceLFdataStore) {
			// Optimization : no data store update for left list collection!
			commit = entityBound ? false : commit;
			options.lf = true;
		}
		// Apply delete/insert/update on data
		logger = fusionController ? fusionController.getLogger() : null;
		syraElapseEx = this._dataset[entityName].applyDataCollEx(data, commit, options, function(update, updateOpts) {
			var change = {}, tick;
			change[entityName] = update;
			options.bindType = "dataDyB";
			options.bindBatch = null;
			tick = setUI ? self._bindDataColl(entityName, entityBound, change, updateOpts, options, logger) : 0;
			delete change[entityName];
			return tick;
		}, function() {
			// Nothing special... all is managed by Syracuse UI Framework
			return;
		});
		// Apply meta-data
		if (data.$meta) {
			if (commit) {
				this._dataset[entityName].storeMetaColl(data.$meta);
			}
			if (setUI && entityBound) {
				var changeEx = [],
					iEx, lenEx;
				this._dataset[entityName].getMetaCollEx(changeEx, data.$meta, this._getSession(), options);
				options.bindBatch = helpers.uuid.generate("");
				options.bindType = "metaDyB";
				for (iEx = 0, lenEx = changeEx.length; iEx < lenEx; iEx++) {
					syraElapseEx.meta = this._bindDataColl(entityName, entityBound, changeEx[iEx], {
						"$isPartialDelta": true
					}, options, logger);
				}
			}
		}
		if (logger) {
			syraElapse += (syraElapseEx.data + syraElapseEx.mvt + elapseUnsort + (syraElapseEx.meta || 0));
			logger.trace({
				"severety": "info"
			}, "Binding Duration for '" + entityName + "' ==> Fusion : " + ((new Date()).getTime() - elapse - syraElapse) + " (including Format : " + (this._dataset[entityName]._tgFmt || "unavailable") + ") - Syra : " + syraElapse + " (including apply Mvt : " + syraElapseEx.mvt + ", update data : " + syraElapseEx.data + ", unsort : " + elapseUnsort + ", and meta : " + (syraElapseEx.meta || 0) + ")");
		}
		return null;
	},

	_bindDataColl: function(entityName, entityBound, $resources, bindOpts, setDataOpts, logger) {
		var delayedBinding, elapse = (new Date()).getTime(),
			i, len, item, discardUnsort = setDataOpts && setDataOpts.discardUnsort;
		if (setDataOpts && setDataOpts.partialChange && !this._dataset[entityName].isSupportPartialChange() || (this._delayedBinding && this._delayedBinding[entityName] && this._delayedBinding[entityName][setDataOpts.bindType] && (!setDataOpts || !setDataOpts._perfomDelayedRebind))) {
			// Deal with partial data change... and return
			if (!this._delayedBinding) {
				this._delayedBinding = {};
			}
			if (!this._delayedBinding[entityName]) {
				this._delayedBinding[entityName] = {};
			}
			if (!(delayedBinding = this._delayedBinding[entityName][setDataOpts.bindType])) {
				this._delayedBinding[entityName][setDataOpts.bindType] = {
					"callback": this._bindDataColl,
					"entityBound": entityBound,
					"$resources": [util.duplicateObj($resources)],
					"bindOpts": bindOpts,
					"setDataOpts": setDataOpts
				};
			} else {
				if (setDataOpts.bindBatch && setDataOpts.bindBatch == delayedBinding.bindBatch) {
					delayedBinding.$resources.push(util.duplicateObj($resources));
				} else {
					delayedBinding.rebind = true;
					delayedBinding.$resources = null;
				}
			}
			if (logger) {
				logger.trace({
					"severety": "warn",
					"toJson": true
				}, "     **** Parial bind on '" + setDataOpts.bindType + "' for '" + entityName + "' of window id '" + this.getWinId() + "' has been catched.");
			}
			return (new Date()).getTime() - elapse;
		}
		// Direct binding
		$resources.$isPartialDelta = bindOpts && bindOpts.$isPartialDelta;
		if (logger && entityName) {
			//logger.trace({"severety": "warn", "toJson": true}, "==> update for " + entityName + " (partial delta : " + ($resources.$isPartialDelta ? "true" : "false") + ")", $resources);
		}
		if (entityBound) {
			entityBound[0].page.applyChange($resources);
		}
		return (new Date()).getTime() - elapse;
	},
	_setDataContainer: function(containerName, data, options) {
		var obj, sty, proto, arrP, i, len, sc1, sc2, e, styCont = {};
		if ((obj = this._getContainerObj(containerName))) {
			if (data.tit != null) {
				obj.setTitle(data.tit, true);
			}
			if ((sty = data.sty) != null) {
				// Style on block is managed by web server, just need to process style on screen...
				if (syra_fusion.sapUtil.isScreenInst(containerName)) {
					proto = this.getProto();
					arrP = Object.keys(proto);
					sc1 = syra_fusion.sapUtil.getScreenId;
					sc2 = syra_fusion.syraUtil.dataTypes.collectionType;
					for (i = 0, len = arrP.length; i < len; i++) {
						if (sc1((e = arrP[i])) === containerName) {
							styCont[e] = proto[e].$type == sc2 ? {
								"$meta": {
									"sty": [
										[e, 0, sty]
									]
								}
							} : {
								"sty": sty
							};
						}
					}
					this.setEntitiesValue(styCont, options);
				}
			}
		}
		return obj ? true : false;
	},

	_getContainerObj: function(containerName) {
		var tabIdx, fusionController, firstField = syra_fusion.sapUtil.getFirstChild(containerName, this._fieldsColl.bound),
			$screenTab = null,
			contObj = null;
		if (firstField) {
			contObj = (syra_fusion.sapUtil.isBlockInst(containerName) ? firstField[0].boxParent : (firstField[0].boxParent ? firstField[0].boxParent.boxParent : null));
		} else
		if (syra_fusion.sapUtil.isScreenInst(containerName) && this.$folderTabs) {
			$screenTab = _.find(this.$folderTabs, function(tab) {
				var $tabMeta = syra_fusion.syraUtil.getMetaFromObject(tab);
				return $tabMeta && containerName == syra_fusion.sapUtil.isFolderTab($tabMeta[syra_fusion.sapUtil.metaNameMap.xid]);
			});
			if (!$screenTab && syra_fusion.sapUtil.isTabScreen(containerName)) {
				if ((fusionController = syra_fusion.syraUtil.getFusionController(this.syraModel)) && fusionController._sapController) {
					tabIdx = fusionController._sapController.getCurrTabIdx();
					$screenTab = tabIdx != null ? this.$folderTabs[tabIdx] : null;
				}
			}
		}
		return contObj || $screenTab;
	},

	_getDataField: function(entityName, line, isExternalWrap, onlyValue, opts) {
		var dataSet, data, getRawVal;
		if (!this._dataset[entityName]) {
			return isExternalWrap ? {} : (onlyValue ? null : {});
		}
		dataSet = this._dataset[entityName].data;
		getRawVal = !! (opts && opts.rawVal && dataSet.$rawV !== undefined);
		data = isExternalWrap ? {
			"val": getRawVal ? dataSet.$rawV : dataSet.v,
			"rcd": null,
			"meta": onlyValue ? null : dataSet
		} : (onlyValue ? (getRawVal ? dataSet.$rawV : dataSet.v) : dataSet);
		if (this._pendingMeta[syra_fusion.sapUtil.getScreenId(entityName)].fields[entityName] && isExternalWrap) {
			data.meta = dataSet;
			delete this._pendingMeta[syra_fusion.sapUtil.getScreenId(entityName)].fields[entityName];
		}
		return data;
	},

	_getDataFieldRef: function(entityName, line, isExternalWrap, onlyValue, opts) {
		// We never have reference field in collection (x-array)
		var dataValue, data, type = "",
			proto = this.getProto(),
			$entity = proto[entityName],
			refProps = syra_fusion.syraUtil.getRefPropertyEntity($entity),
			property = null;
		if (refProps) {
			type = refProps.proto.$type;
		}
		data = this[_instVtbl[type] && _instVtbl[type]._getDataStore ? _instVtbl[type]._getDataStore : _instVtbl["default"]._getDataStore].apply(this, arguments);
		if (isExternalWrap && data && type) {
			dataValue = data.val;
			data.val = {};
			data.val[refProps.property] = dataValue;
		}
		return data;
	},

	_getDataColl: function(entityName, line, isExternalWrap, onlyValue, opts) {
		var data, isLinesColl = syra_fusion.sapUtil.isBlockInst(entityName),
			dataSet, options, getRawVal, rawVal, i, len, parentEntity, dt;
		if (!this._dataset[entityName] && isLinesColl) {
			return {};
		}
		dataSet = isLinesColl ? this._dataset[entityName].data : this._dataset[(parentEntity = syra_fusion.sapUtil.getBlockInst(entityName))].data;
		if (line === undefined || line === null) {
			if (isLinesColl) {
				// Full collection
				if (opts && opts.sort) {
					data = this._dataset[entityName].sortDataColl(opts.sort.$orderBy, opts.rawVal, opts.sort);
				} else {
					if (isExternalWrap) {
						data = {
							"val": {
								"$isPartialDelta": false
							}
						};
						data.val[entityName] = dataSet;
						if (this._pendingMeta[syra_fusion.sapUtil.getScreenId(entityName)].fields[entityName]) {
							data["meta"] = {
								"$isPartialDelta": true
							};
							this._dataset[entityName].getMetaColl(data["meta"], this._dataset[entityName].meta, this._getSession(), options);
							delete this._pendingMeta[syra_fusion.sapUtil.getScreenId(entityName)].fields[entityName];
						}
					} else {
						data = dataSet;
					}
				}
			} else
			if ((len = dataSet.length)) {
				// Full Col...
				data = this._dataset[parentEntity].getColumnsDataColl(entityName, opts && opts.rawVal, opts && opts.sort);
				if (isExternalWrap) {
					data = {
						"val": data
					};
				}
			}
		} else {
			if (isLinesColl) {
				dt = this._dataset[entityName].getLineDataColl(line - 1, !! (opts && opts.rawVal));
				data = isExternalWrap ? {
					"val": dt
				} : dt;
			} else {
				getRawVal = !! (opts && opts.rawVal && (rawVal = dataSet[line - 1].$rawV[entityName]));
				data = isExternalWrap ? {
					"val": getRawVal ? rawVal.v : dataSet[line - 1][entityName]
				} : (getRawVal ? rawVal.v : dataSet[line - 1][entityName]);
			}
		}
		if (data && !data.rcd && isExternalWrap) {
			data.rcd = {};
		}
		return data;
	},
	_getFmtField: function(entityName, parentEntity, line, opts) {
		var dataset = this._dataset[entityName];
		return dataset ? dataset.data.fmt : null;
	},

	_getFmtColl: function(entityName, parentEntity, line, opts) {
		var dataset = this._dataset[parentEntity];
		return dataset ? dataset.getFmtColl(entityName, line - 1) : null;
	},
	_getStateField: function(boundFld, entityName, idx, opts) {
		var status = null;
		if (opts && opts.justRO) {
			status = boundFld.$isReadOnly !== null && boundFld.$isReadOnly !== undefined ? boundFld.$isReadOnly : false;
		} else {
			// TODO if necessary
			status = {};
		}
		return status;
	},

	_getStateColl: function(boundColl, entityName, idx, opts) {
		var cell, status = null,
			type, getStateProxy;
		if (idx !== undefined && (cell = boundColl.getField(entityName, idx))) {
			type = syra_fusion.syraUtil.getFieldType(cell);
			getStateProxy = _instVtbl[type] && _instVtbl[type]._getState ? _instVtbl[type]._getState : _instVtbl["default"]._getState;
			status = this[getStateProxy].call(this, cell, entityName, idx, opts);
		} else {
			if (opts && opts.justRO) {
				status = false;
			} else {
				status = {};
			}
		}
		return status;
	},
	_getFieldCtxProps: function(boundField, idx) {
		var ctx = {};
		var position = (boundField.getCaretPosition && boundField.getCaretPosition(idx)) || -1;
		if (position >= 0) {
			ctx.crsr = position + 1;
		}
		// Others properies???
		return ctx;
	},

	_getRtfFieldCtxProps: function(boundField, idx) {
		return this._getFieldCtxProps(boundField, idx);
	},

	setFieldError: function(field, errors, raz) {
		var len, err = !! (!raz && errors && errors.length > 0);
		var fusionController = syra_fusion.syraUtil.getFusionController(this.syraModel),
			fieldMeta;
		if (field.showErrors) {
			if (!err && field.$displayedDiagnoses && field.$displayedDiagnoses.length > 0) {
				field.showErrors([]);
			} else
			if (err) {
				field.showErrors(errors, {
					noViewer: true
				});
			}
		}
		if (fusionController && fusionController._sapController.isCurrIstInputValidate() != !err) {
			if ((fieldMeta = syra_fusion.syraUtil.getMetaFromObject(field)) && syra_fusion.sapUtil.cmpIstEx(syra_fusion.sapUtil.makeIst(this._idEx.id, fieldMeta.$bind), fusionController._sapController.getCurrInst(), true)) {
				fusionController._sapController.setCurrIstInputValidate(!err);
			}
		}
	},

	getCollRcdUUID: function(collName, nl, zeroBased) {
		return this._dataset && this._dataset[collName] ? this._dataset[collName].getCollRcdUUID(nl - (!zeroBased ? 1 : 0)) : null;
	},

	getCollRcdIdx: function(collName, uuid, zeroBased) {
		return this._dataset && this._dataset[collName] ? (this._dataset[collName].getCollRcdIdx(uuid) + (zeroBased ? 0 : 1)) : null;
	},

	isCollFull: function(collName) {
		return this._dataset[collName] ? this._dataset[collName].isCollFull() : false;
	},

	dispose: function() {
		var fusionController, i, len, arr;
		if (this.syraModel) {
			this._unBindEvents();
			if ((fusionController = syra_fusion.syraUtil.getFusionController(this.syraModel))) {
				fusionController.rmGlobalListeners(this);
			}
			delete this._$$syraPageItem;
			_.each(this.$folderTabs, function($tabs, idx) {
				delete this[idx];
			}, this.$folderTabs);
			delete this.syraModel;
			if (this._fieldsColl.proto) {
				delete this._fieldsColl.proto;
			}
			if (this._fieldsColl.bound) {
				delete this._fieldsColl.bound;
			}
			arr = Object.keys(this._entityRefTitleMap);
			for (i = 0, len = arr.length; i < len; i++) {
				delete this._entityRefTitleMap[arr[i]];
			}
		}
		delete this._fmtWrapper;
		delete this._menuManager;
		this._releaseDataEx({
			"disposeStore": true
		});
	}
});


/* Std Window class with private Event handling*/
var _PrivateEvtHandlingWin = helpers.defineClassEx(function() {}, WinModel, {
	initialize: function() {
		var $fusionPageMeta;
		WinModel.prototype.initialize.apply(this, arguments);
		if (this.registerEvtHandler) {
			this.registerEvtHandler();
		}
		$fusionPageMeta = syra_fusion.syraUtil.getFusionPageMeta(this.getSyraPage());
		$fusionPageMeta._privateEventManager = this;
		this.evtManagerComplete();
	},
	trigger: function(event) {
		var fusionController, processed = undefined,
			triggerProxy = EventHandlingCore.EventManagerMembers.trigger,
			stdHandler = true;
		if (this.isEventBound(event)) {
			stdHandler = false;
			processed = triggerProxy.apply(this, arguments);
		} else
		if (this.isInternalEvtManagerCat(event)) {
			processed = true;
		}
		if (stdHandler || processed == false) {
			fusionController = syra_fusion.syraUtil.getFusionController(this.getSyraPage());
			processed = triggerProxy.apply(fusionController, arguments);
		}
		return processed;
	},
	dispose: function() {
		WinModel.prototype.dispose.call(this);
		this.evtManagerDispose();
	}
}, EventHandlingCore.EventManagerMembers);


/* Formula Wizard window class */
var _formulaEvtHandlingModules = {
	"formula": require('../eventhandling/formula').FormulaEventHandling
};
var _formulaWin = helpers.defineClass(function() {
	this._initialF = "";
	this._formulaFldName = null;
	this._formulaFld = null;
	this._firstFocus = false;
	this._isFormulaWin = true;
}, _PrivateEvtHandlingWin, {
	registerEvtHandler: function() {
		// Init private event manager
		this.evtManagerInit(_formulaEvtHandlingModules, ["sap", "ui"], {
			"winModel": this,
			"siteUUID": "~_formulaWizard"
		});
	},
	setFocus: function(highlight, style, entity, nl, isEdit, params, opts) {
		var i, len, entities, proto, fusionController, currIst, prevFld, defLen = 249,
			helpField, hlpParams = {
				"tokens": []
			};
		if (!this._firstFocus) {
			// Need to bind initial value to predefined formula field...
			fusionController = syra_fusion.syraUtil.getFusionController(this.syraModel);
			this._initialF = this._getExtendProps(true);
			proto = this.getProto();
			entities = Object.keys(proto);
			for (i = 0, len = entities.length; i < len; i++) {
				// TODO : improve how to retrieve formula entity in proto
				if (proto[entities[i]].$type == syra_fusion.syraUtil.dataTypes.stringType) {
					this._formulaFldName = entities[i];
				} else
				if (proto[entities[i]].$type == syra_fusion.syraUtil.dataTypes.htmlVignette) {
					if ((helpField = this.getBoundField(entities[i])) && fusionController) {
						hlpParams.tokens[0] = syra_fusion.sapUtil.helpHandler["4gl"].cat;
						hlpParams.tokens[1] = "INDEX";
						fusionController.displayBusinessHelp(hlpParams, function(hepUrl) {
							helpField.setValue(hepUrl);
						});
					}
				}
			}
			if (this._formulaFldName) {
				if (this._initialF) {
					this.setDataStoreValue(this._formulaFldName, 0, this._initialF);
				}
				this._formulaFld = this.getBoundField(this._formulaFldName);
			}
			// Need to retrieve caller field max length
			if (fusionController && fusionController._sapController) {
				prevFld = fusionController._sapController.getBoundField(opts.prevIst, opts.prevIst.nl !== undefined ? {
					"arrayCell": opts.prevIst.nl
				} : null);
			}
			this._formulaFmt = "K:" + (prevFld ? (prevFld.$maxLength || defLen) : defLen) + "X";
			this._firstFocus = true;
		}
		if (this._formulaFldName) {
			WinModel.prototype.setFocus.call(this, true, style, this._formulaFldName, 0);
		}
		// Force format to deal with max lengh... a bit tricky, but...
		if (fusionController || (fusionController = syra_fusion.syraUtil.getFusionController(this.syraModel)) && fusionController._sapController) {
			if ((currIst = fusionController._sapController.getCurrInst())) {
				currIst.fmt = this._formulaFmt || ("K:" + defLen + "X");
			}
		}
		return null;
	}
});
_customWinClassK[_sapUtil.specialWindow.formula.id] = _formulaWin;


/* Private Evt Handling Window class - Template */

function _privateEvtHandlingWinT() {

}

_privateEvtHandlingWinT = helpers.defineClass(_privateEvtHandlingWinT, _PrivateEvtHandlingWin, {
	registerEvtHandler: function() {
		var _evtHandlingModules = { //"foo": require('../eventhandling/foo').FooEventHandling
		};
		// Init private event manager
		this.evtManagerInit(_evtHandlingModules, ["sap", "ui"], {
			"winModel": this,
			"siteUUID": "~_privateEvtHandlingWinT"
		});
	}
});