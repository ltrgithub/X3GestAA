"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Utilities for Fusion Edit Protocol
 */
var util = require('syracuse-ui/lib/fusion/tools/util');
var speckeys = require('syracuse-ui/lib/fusion/tools/constant').keybordSpecialKey;

/* Fusion Legacy Protocol */
function _getRank(inst, type){
    return inst.charCodeAt(type) - 64;
}

exports.Fusion = {
    _fNS: "syraTrans",
    specialScrnId: {
        "buttons": "a",
        "leftZone": "b",
        "gfolder": "c"
    },
    specialWindow: {
        "selbox": {
            "name": "AASELECT",
            "id": "_SELBOX"
        },
        "choose": {
            "name": "AACHOOSE",
            "id": "_CHOOSE"
        },
        "formula": {
            "name": "AAFORMULA",
            "id": "_FORMULA"
        }
    },
    metaNameMap: {
        "xid": "$XID"
    },
    check: {
        "off": 1,
        "on": 2
    },
    dataSetMvt: {
        "del": 0,
        "insrt": 1,
        "delAll": 1024
    },
    screensArray: ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "a", "b", "c"],
    statusFlag: {
        "state": 0x0001,
        "readOnly": 0x0002,
        "show": 0x0004,
        "selected": 0x0008
    },
    statusMask: {
        "state": 0x00010000,
        "readOnly": 0x00020000,
        "show": 0x00040000,
        "selected": 0x00080000
    },
    fieldModeType: {
        "show": "SHOW",
        "edit": "EDIT",
        "rough": "ROUGH"
    },
    focusStyle: {
        "fmtErr": {
            "css": "s-field-input-error",
            "code": "fmtErr"
        },
        "std": {
            "css": null,
            "code": "std"
        }
    },
    getState: function(stt){
        var state = {};
        state.$isHidden = stt & this.statusMask.show ? !(stt & this.statusFlag.show) : undefined;
        state.$isDisabled = stt & this.statusMask.state ? !(stt & this.statusFlag.state) : undefined;
        state.$isReadOnly = stt & this.statusMask.readOnly ? !!(stt & this.statusFlag.readOnly) : undefined;
        state.$isSelected = stt & this.statusMask.selected ? !!(stt & this.statusFlag.selected) : undefined;
        return state;
    },
    setState: function(state, stt){
        if (state.$isHidden != undefined) {
            stt += stt & this.statusMask.show ? 0 : this.statusMask.show;
            if (stt & this.statusFlag.show && state.$isHidden) {
                stt -= this.statusFlag.show;
            }
            else 
                if (!(stt & this.statusFlag.show) && !state.$isHidden) {
                    stt += this.statusFlag.show;
                }
        }
        if (state.$isDisabled != undefined) {
            stt += stt & this.statusMask.state ? 0 : this.statusMask.state;
            if (stt & this.statusFlag.state && state.$isDisabled) {
                stt -= this.statusFlag.state;
            }
            else 
                if (!(stt & this.statusFlag.state) && !state.$isDisabled) {
                    stt += this.statusFlag.state;
                }
        }
        if (state.$isReadOnly != undefined) {
            stt += stt & this.statusMask.readOnly ? 0 : this.statusMask.readOnly;
            if (stt & this.statusFlag.readOnly && !state.$isReadOnly) {
                stt -= this.statusFlag.readOnly;
            }
            else 
                if (!(stt & this.statusFlag.readOnly) && state.$isReadOnly) {
                    stt += this.statusFlag.readOnly;
                }
        }
        if (state.$isSelected != undefined) {
            stt += stt & this.statusMask.selected ? 0 : this.statusMask.selected;
            if (stt & this.statusFlag.selected && !state.$isSelected) {
                stt -= this.statusFlag.selected;
            }
            else 
                if (!(stt & this.statusFlag.selected) && state.$isSelected) {
                    stt += this.statusFlag.selected;
                }
        }
        return stt;
    },
    removeStateMask: function(state, stt){
        if (state.hasOwnProperty("$isHidden") && (stt & this.statusMask.show)) {
            stt -= this.statusMask.show;
        }
        if (state.hasOwnProperty("$isDisabled") && (stt & this.statusMask.state)) {
            stt -= this.statusMask.state;
        }
        if (state.hasOwnProperty("$isReadOnly") && (stt & this.statusMask.readOnly)) {
            stt -= this.statusMask.readOnly;
        }
        if (state.hasOwnProperty("$isSelected") && (stt & this.statusMask.selected)) {
            stt -= this.statusMask.selected;
        }
        return stt;
    },
    getNumStatus: function(){
        var res = 0, m, f, propName;
        _.each(arguments, function(prop){
            propName = (_.keys(prop))[0];
            m = this.statusMask[propName];
            f = prop[propName] ? this.statusFlag[propName] : 0;
            res = (m != null && f != null) ? (res + m + f) : res;
        }, this);
        return res;
    },
    adjustIcoFieldData: function(data){
        var state, num = data.v === undefined ? 0 : (data.v === null || data.v.length == 0 ? -1 : parseInt(data.v, 10)), disable = null;
        // Deal with disable & readonly (disable overrides, readonly is rerouted)
        state = data.stt ? this.getState(data.stt) : {};
        if (state.$isReadOnly != undefined) {
            disable = state.$isDisabled != undefined ? state.$isDisabled : state.$isReadOnly;
            data.stt = this.setState({
                "$isDisabled": disable
            }, data.stt || 0);
            data.stt = this.removeStateMask({
                "$isReadOnly": ""
            }, data.stt);
        }
        // Hidden?
        if (num < 0) {
            data.v = null;
        }
        // Note : Negative value, empy value or NULL value mean "hidden", but "$isHidden" meta is priority
        if (state.$isHidden === undefined) {
            data.stt = this.setState({
                "$isHidden": num < 0 ? true : false
            }, data.stt || 0);
        }
        return data;
    },
    getWinRank: function(inst){
        return _getRank(inst, 0) - 1;
    },
    isSpecialScrnId: function(instAlpha){
        return _.include(this.specialScrnId, instAlpha.charAt(0));
    },
    isButtonScreen: function(instAlpha){
        return (instAlpha && instAlpha.charAt(0) === exports.Fusion.specialScrnId.buttons ? true : false);
    },
    getButtonValue: function(){
        return this.getObjFieldValue("", this.fieldModeType.show);
    },
    isTabScreen: function(instAlpha){
        return (instAlpha && instAlpha.charAt(0) === exports.Fusion.specialScrnId.gfolder ? true : false);
    },
    isListScreen: function(instAlpha){
        return (instAlpha && instAlpha.charAt(0) === exports.Fusion.specialScrnId.leftZone ? true : false);
    },
    isListTab: function(instAlpha){
        return (this.isListScreen(instAlpha) && instAlpha.length == 2 ? instAlpha : null);
    },
    isFolderTab: function(instAlpha){
        return (this.isTabScreen(instAlpha) && instAlpha.length == 2 ? instAlpha.charAt(1) : null);
    },
    isSpecialWin: function(name){
        return _.find(this.specialWindow, function(winDef){
            return winDef.id == name;
        });
    },
    getWinId: function(rank){
        return String.fromCharCode(rank + 64);
    },
    getBlockInst: function(instAlpha){
        return instAlpha.substr(0, 2);
    },
    isBlockInst: function(instAlpha){
        return (instAlpha.length == 2);
    },
    isLineGridInst: function(ist){
		if(!ist || !ist.xid || !ist.nl) return false
		var ret=(parseInt(ist.xid.substr(2),10)===1)
        return (ret && ist.nl >0);
    },
    isScreenInst: function(instAlpha){
        return (instAlpha.length == 1);
    },
    isFieldInst: function(instAlpha){
        return (instAlpha && instAlpha.length > 2);
    },
    getScreenId: function(instAlpha){
        return instAlpha.charAt(0);
    },
    getFirstChild: function(entityName, coll){
        return _.find(coll, function(child, childName){
            var len = entityName.length;
            return (childName.length > len && childName.substring(0, len) == entityName);
        });
    },
    needToControlField: function(fldT){
        var srT = exports.Syra.dataTypes;
        return fldT == srT.stringType || fldT == srT.dateType || fldT == srT.integerType || fldT == srT.decType || fldT == srT.realType || fldT == srT.timeType || fldT == srT.passwdType ? true : false;
    },
    appendMnus2Syra: function(representation, menus, isActions){
        if (menus) {
            var links = exports.Syra.mapMnus2Links(menus, "txt", "act", "id", "typ", "rnk", "idf");
            exports.Syra.appendLinks2Proto((exports.Syra.getProtoFromPage(representation) || representation), links, isActions);
        }
    },
    cmpIst: function(a, b, strict){
        var ret = false;
        if (a && b && a.win === b.win && a.xid === b.xid) {
            ret = a.nl === b.nl || a.nl == 0 && b.nl == undefined || b.nl == 0 && a.nl == undefined ? true : false;
            if (!ret && !strict && (b.nl == undefined || a.nl == undefined)) {
                // If "nl" is not defined, we assume it is not significant in the comparaison (lax way...)
                ret = true;
            }
        }
        return ret;
    },
    cmpIstEx: function(a, b, discardLine) {
        var save, ret, aBlock = this.isBlockInst(a.xid), bBlock = this.isBlockInst(b.xid);
        if((aBlock && !bBlock) || (!aBlock && bBlock)) {
            return this.cmpIstGrid(a, b, discardLine);
        }
        else {
            if(discardLine) {
                save = a.nl;
                a.nl = b.nl;
                ret = this.cmpIst(a, b);
                a.nl = save;
            }
            else {
                ret = this.cmpIst(a, b);
            }
            return ret;
        }
    },
    cmpIstBlock: function(a, b){
        return (a && b && a.win === b.win && a.xid.charAt(0) === b.xid.charAt(0) && a.xid.charAt(1) === b.xid.charAt(1));
    },
    cmpIstGrid: function(a, b, discardLine){
        var ret = this.cmpIstBlock(a, b);
        if (!discardLine && ret && a.nl && b.nl) {
            ret = (a.nl == b.nl);
        }
        return ret;
    },
    makeIst: function(win, xid, nl, nlUndef){
        return {
            "win": win,
            "xid": xid,
            "nl": nl || (nlUndef ? undefined : 0)
        };
    },
    getObjFieldValue: function(value, modeType, ctxProps, notModified){
        return {
            "v": value,
            "xFmt": modeType,
            "ctx": ctxProps,
            "notModified": notModified ? true : false
        };
    },
    cureStyle: function(meta, fieldName, session){
        var sty = meta.sty, sess, ret = false;
        if (sty === undefined || sty === null || sty.length == 0 || (sty.length == 1 && sty.charAt(0) === ";")) {
            if (sty != undefined) {
                meta.sty = "";
            }
            ret = true;
        }
        else 
            if (session) {
                meta.sty = session.getStyleClass(sty);
                if (meta.sty === null) {
                    session.logger.trace({
                        "severety": "warn"
                    }, "Style '" + sty + "' is not defined. Can't apply style for field '" + fieldName + "'");
                    delete meta.sty;
                }
                else {
                    ret = true;
                }
            }
        return ret;
    },
    getEntityType: function(entity, syraProto){
        var coll, $entity = null;
        if (entity && syraProto) {
            if (!($entity = syraProto[entity])) {
                coll = this.getBlockInst(entity);
                if (syraProto[coll] && syraProto[coll].$type == exports.Syra.dataTypes.collectionType) {
                    $entity = (exports.Syra.getCollFieldsFromProto(syraProto, coll))[entity];
                }
            }
        }
        return $entity ? $entity.$type : null;
    },
    isFixtureMode: function(object){
        return exports.Syra.getFusionController(object).isFixtureMode();
    },
    isSpecialKey: function(keycode){
        var k;
        for (k in speckeys) {
            if (speckeys[k] == keycode) 
                return true;
        }
        return false;
    },
	getIdxFromNL:function(nl){
		return nl !== undefined && nl > 0 ? nl - 1 : undefined;
	},
};

/* Syracuse Protocol */
exports.Syra = {
    dataTypes: {
        defaultType: "application/x-string",
        stringType: "application/x-string",
        collectionType: "application/x-array",
        treeType: "application/x-tree",
        booleanType: "application/x-boolean",
        rtfType: "text/rtf",
        dateType: "application/x-date",
        choiceType: "application/x-choice",
        integerType: "application/x-integer",
        iconType: "application/x-icon",
        decType: "application/x-decimal",
        realType: "application/x-real",
        timeType: "application/x-time",
        passwdType: "application/x-password",
        htmlType: "text/html",
		imageType:"image"
    },
    wdgtTypes: {
        radio: "$radios",
        combo: "$combo"
    },
    pageSectionK: {
        body: "s-page-data",
        menu: "s-page-menus-slot",
        bar: "s-fusion-bar-slot"
    },
    gridFusionK: {
        cont: "s-list"
    },
    pageFacet: {
        lookup: "$lookup",
        edit: "$edit"
    },
    getUserLocalPref: function(){
        return document.site && document.site.userProfile && document.site.userProfile.dataset && document.site.userProfile.dataset.selectedLocale;
    },
    getUserName: function(){
        var user = document.site;
        return (user && (user = document.site.userProfile) && (user = user.dataset) && (user = user.user) && (user = user.login)) ? user : null;
    },
    getPopupCtxFromField: function(field){
		if(field && field.arrayLevel && field.arrayLevel=="record"){
			return field.menuPicker && field.menuPicker._popupMenus;
		}
        else{
       		return field &&  field.menuPicker && field.menuPicker._popupMenus;
		}
    },
    getPopupDateFromField: function(field){
        return field && field.popupPicker;
    },
    isDialogFacet: function($facet){
        return ($facet == this.pageFacet.lookup);
    },
    getProtoFromPage: function(page){
        return (page ? page.$prototype : null);
    },
    getCollFieldsFromProto: function(proto, coll){
        return (proto[coll] && proto[coll].$item ? proto[coll].$item.$properties : null);
    },
    get$FromPage: function(page){
        var $proto = this.getProtoFromPage(page);
        return ($proto ? $proto.$properties : null);
    },
    geChooseLstPropFromProperties: function(properties){
        var ret = exports.Fusion.specialScrnId.leftZone + exports.Fusion.screensArray[0];
        return (ret = properties[ret]) && (ret = ret.$item) && (ret = ret.$properties);
    },
    getBoundFldsFromPage: function(page){
        return (page ? page.boundFields : null);
    },
    getBoundMnusFromPage: function(page){
        return (page ? page.menuItems : null);
    },
    getPage: function(syraObject){
        var obj = syraObject, page = syraObject;
        while ((!page || !page.$fusionPageMeta) && obj.boxParent) {
            page = obj.boxParent.getArticle();
            obj = obj.boxParent;
        }
        if (!page || !page.$fusionPageMeta) {
            page = syraObject.page;
        }
        return page;
    },
    getFieldType: function(fieldObj){
        return fieldObj.$field ? fieldObj.$field.$type : null;
    },
    getMetaFromObject: function(syraObject){
        return syraObject.$item;
    },
    getFusionPageMeta: function(syraObject){
        var page = this.getPage(syraObject);
        return (page ? page.$fusionPageMeta : null);
    },
    getFusionController: function(syraObject){
        var page = this.getPage(syraObject);
        return (page ? (page.$fusionPageMeta ? page.$fusionPageMeta.controller : null) : null);
    },
    deleteFusionPageMeta: function(page){
        if (page.$fusionPageMeta) {
            delete page.$fusionPageMeta.winModel;
            delete page.$fusionPageMeta.controller;
            delete page.$fusionPageMeta;
        }
    },
    mapMnus2Links: function(mapIn, title, action, id, type, rank, father){
        // TODO : improve with hierarchy!
        var map2;
        return _.map(mapIn, function(mapFrom, idx){
            map2 = null;
            if (mapFrom[action] && mapFrom[action] > 0) { // TODO + HACK... waiting hierarchy spec.
                map2 = {};
                map2[mapFrom[id]] = {
                    "$title": mapFrom[title],
                    "$act": mapFrom[action]
                };
                return map2;
            }
        });
    },
    appendLinks2Proto: function(proto, links, isActions){
        var node = isActions ? "$actions" : "$links";
        if (proto[node] === undefined) {
            proto[node] = {};
        }
        _.each(links, function(link){
            if (link) {
                _.extend(proto[node], link);
            }
        });
    },
    msgBox: function(options){
        document.site.showMessage(options);
    },
    isMsgBoxOpened: function() {
        return document.site._msgBox && !document.site._msgBox.disposed;
    },
    setTabFocus: function($tab){
        $($tab._tabTitle).focus();
    },
    showTab: function($tab, data){
        if ($tab && $tab._tabTitle) {
            $($tab._tabTitle).trigger("click", data);
        }
    },
    isFieldModelReadOnly: function($model, $field, fieldName){
        if (!$model && $field) {
            var $fusionPageMeta = exports.Syra.getFusionPageMeta($field);
            var $fieldMeta = exports.Syra.getMetaFromObject($field);
            if ($fusionPageMeta && $fieldMeta) {
                $model = $fusionPageMeta.winModel.getProto();
                fieldName = $fieldMeta.$bind;
            }
        }
        return $model && fieldName && $model[fieldName] && $model[fieldName].$isReadOnly ? true : false;
    },
    razStyleOnInput: function(input, styleColl, excludeStyle){
        _.each(styleColl, function(stl, name){
            if (name != excludeStyle && stl.css) {
                document.site.toggleClass(input, stl.css, false);
            }
        });
    },
    appendProto: function(proto, append, appendCallback){
        function appendInner(from, to){
            _.each(from, function(node, name){
                if (Array.isArray(node) || _.isObject(node)) {
                    if (this.hasOwnProperty(name)) {
                        appendInner(node, this[name]);
                    }
                    else {
                        this[name] = util.duplicateObj(node, appendCallback);
                    }
                }
            }, to);
        }
        if (proto) {
            appendInner(append, proto);
        }
    },
    getLocalization: function(key, localization){
        return key && key.replace(/\{(@[\w-]+)\}/g, function(match, p1) {
            return (localization && localization[p1]) || match;
        })
    }
};
