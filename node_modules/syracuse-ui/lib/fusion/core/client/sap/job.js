"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview  Asynchronous job registration/management
 */
var helpers = require('syracuse-core').helpers;
var util = require('syracuse-ui/lib/fusion/tools/util');

var _KStatementsStub = {
	"submitted": "register",
	"pending": "progress",
	"done": "finished"
};
var _KuuidProp = "uuid";

function AsyncJobsManagement() {}

exports.AsyncJobsManagement = helpers.defineClass(AsyncJobsManagement, null, {
	initialize: function(siteController) {
		this._siteController = siteController;
		this._jobTypesClass = {
			"report": {
				"cla": exports.ReportJob,
				"labelId": "101"
			}
		};
		this._jobList = {};
		this._jobsPending = 0;
		this._jobsCount = 0;
	},

	processStatements: function(jobType, statements) {
		var result = {
			"status": null,
			"$diagnoses": {}
		}, i, j, leni, lenj, jobStatements = Object.keys(statements),
			jobStatement;
		for (i = 0, leni = jobStatements.length; i < leni; i++) {
			jobStatement = jobStatements[i];
			if (_KStatementsStub[jobStatement]) {
				result.$diagnoses[jobStatement] = [];
				for (j = 0, lenj = statements[jobStatement].length; j < lenj; j++) {
					result.$diagnoses[jobStatement][j] = this[_KStatementsStub[jobStatement]].call(this, jobType, statements[jobStatement][j]);
				}
			}
		}
		return result;
	},

	register: function(jobType, params) {
		var id, job = this._jobTypesClass[jobType] ? new this._jobTypesClass[jobType].cla() : null,
			result, $diag = null,
			self = this,
			j, lenj, severity;
		if (job) {
			job._typeId = jobType;
			job._phase = "registered";
			id = job.initialize(params, this._getErrMessLabel(this._jobTypesClass[jobType].labelId, "Edition", true));
			this._jobList[id] = job;
			this._jobsPending++;
			this._jobsCount++;
			try {
				// Hoster must check "registered" diagnoses!
				var params = job.getProperties();
				if (!params) {
					result = {
						$diagnoses: [{
							$severity: 'error',
							$message: syra_local.trackers_err_noparams
						}]
					};
				} else {
					syra_trackers.addTracker(params, {
						onLoaded: function(jobItem, page) {
							job._hosterJobHandler = jobItem;
							jobItem.fusionContext.cancelSvcId = job.getDeleteScvId();
							var nextStateSvcId = job.getProgressScvId();
							var hasError;
							var $diagnoses = jobItem.dataset.$diagnoses;
							if ($diagnoses) {
								for (var ii = 0; ii < $diagnoses.length; ii++) {
									var $severity = $diagnoses[ii].severity || $diagnoses[ii].$severity;
									if ($severity == "error" || $severity == "fatal") {
										hasError = true;
										break;
									}
								}
							}
							// if no diagnoses or no err diagnoses, send request. else request is not sent    
							if (!$diagnoses || ($diagnoses && !hasError)) {
								jobItem.callServer({
									noDisplayErr: true,
									method: "POST",
									$location: {
										$url: syra_expression.parse(page, jobItem.dataset.$location, jobItem.dataset.services[nextStateSvcId])
									}
								});
							}
							if ($diagnoses) {
								// if $diagnoses in jobsParams, return true/false whether there is "error" diagnose
								result = hasError ? {
									$diagnoses: $diagnoses
								} : null;
							}
						},
						release: function() {
							try {
								self._releaseAsyncJob(id, {
									"noHosterRelease": true
								});
							} catch (e) {

							}
						}
					});
					// result = .register();
				}
				$diag = result && result.$diagnoses && result.$diagnoses.length > 0 ? result.$diagnoses : $diag;
			} catch (e) {
				var errNum = "66",
					mess = [this._getErrMessLabel(errNum, "An unexpected javascript error has been detected while registering an asynchronous job")];
				mess.splice(1, 0, " (", job._typeId, ")", " : ", e.message);
				$diag = [util.makeDiagnosis(mess.join(""), "error", e.stack, errNum)];
			}
		}
		// Check register error
		if ($diag) {
			for (j = 0, lenj = $diag.length; j < lenj; j++) {
				severity = $diag[j].severity || $diag[j].$severity;
				if (util.isErrDiagnosis(severity)) {
					try {
						this._releaseAsyncJob(id, {
							"noHosterRelease": true
						});
					} catch (e) {

					} finally {
						break;
					}
				}
			}
		}
		return $diag;
	},

	isJobsPending: function(params) {
		return this._jobsPending > 0 ? true : false;
	},

	progress: function(params) {
		// Not implemented. Job progress and polling is managed by hoster controller
		var job = this._jobList[params[_KuuidProp]];
		if (job) {
			// TODO : check $diagnoses
			job._phase = "pending";
		}
		// TODO : notify site hoster!!!
	},

	finished: function(jobType, params) {
		// Not implemented : Job return/result is managed by hoster controller
		var job = this._jobList[params[_KuuidProp]],
			ret = true;
		if (job) {
			// TODO : check $diagnoses
			job._phase = "done";
			this._jobsPending--;
		}
		// TODO : release/dispose job + notify site hoster + etc...!!!
		return ret;
	},

	_releaseAsyncJob: function(jobId, opts) {
		var status = false,
			hosterJH;
		if (this._jobList[jobId] && !this._jobList[jobId]._released && this._jobList[jobId].release) {
			status = this._jobList[jobId].release(opts);
			if ((hosterJH = this._jobList[jobId]._hosterJobHandler) && (!opts || !opts.noHosterRelease) && hosterJH.release) {
				hosterJH.release(this._jobList[jobId].getDeleteScvId());
			}
		}
		if (status) {
			this._jobList[jobId]._released = true;
			this._jobsPending--;
			delete this._jobList[jobId];
		}
		return status;
	},

	releaseAllAsyncJobs: function(opts, doDispose) {
		var status = true,
			st, i, len, jobsArray = Object.keys(this._jobList),
			hosterJH, job;
		for (i = 0, len = jobsArray.length; i < len; i++) {
			job = this._jobList[jobsArray[i]];
			st = this._releaseAsyncJob(jobsArray[i], opts);
			if (doDispose) {
				if ((hosterJH = job._hosterJobHandler) && hosterJH.dispose) {
					hosterJH.dispose();
				}
				job.dispose();
			}
			status = !st ? false : status;
		}
		this._jobsCount = 0;
		return status;
	},

	_getErrMessLabel: function(cdMess, def, isLabel) {
		return this._siteController.getMessLabel ? this._siteController.getMessLabel(cdMess, isLabel ? "text" : "error", def || "...") : def || "...";
	},

	dispose: function() {
		this.releaseAllAsyncJobs({
			"noHosterRelease": true
		}, false);
		delete this._siteController;
	}
});

function AsyncJob() {}

exports.AsyncJob = helpers.defineClass(AsyncJob, null, {
	initialize: function(props) {
		this._props = props ? util.duplicateObj(props) : {};
		this.trackId = this._props[_KuuidProp] || helpers.uuid.generate();
		return this.trackId;
	},

	release: function(opts) {
		return true;
	},

	getDeleteScvId: function() {
		return "delete";
	},

	getProgressScvId: function() {
		return "progress";
	},

	dispose: function() {},

	getTrackId: function() {
		return this.trackId;
	},

	getProperties: function() {
		return this._props;
	}
});

function ReportJob() {}

exports.ReportJob = helpers.defineClass(ReportJob, AsyncJob, {
	initialize: function(props, catLabel) {
		var trackId = AsyncJob.prototype.initialize.call(this, props);
		this._props.kind = "Print";
		this._props.kindLabel = catLabel;
		return trackId;
	},

	getProgressScvId: function() {
		return "getState";
	},

	getDeleteScvId: function() {
		return "cancel";
	}
});