"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Edit Protocol controller
 */
var helpers = require('syracuse-core/lib/helpers');
var util = require('syracuse-ui/lib/fusion/tools/util');
var srvAct = require('./srvactions');
var msgBox = require('./msgbox');
var Askui = require('./askui');
var Printer = require('./selimp');
var Rpc = require('./rpc');
var Ackcall = require('./ackcall');
var Window = require('./window');
var sapUtil = require('./util').Fusion;
var syraUtil = require('./util').Syra;
var requestActions = require('./srvactions');
var LCSFldFormatter = require('./format').LegacyCSFieldFormatter;
var FormulaRes = require('syracuse-ui/lib/site/tools/formula');
var Plugin = require('./plugin');

var _debugProto = {
	"debugMode": false,
	"trace": false,
	"$itemPage": require('syracuse-ui/lib/fusion/tools/debugProto').proto,
	"$facet": "fullscreen",
	"ist": {
		"xid": "AA1",
		"win": "B",
		"edit": true
	}
};
var _sapK = {
	"stubMisc": {
		"help": "stubSapMisc_help",
		"openf": "_stubSapMisc_openf"
	},
	"pNodes": {
		"sess": "session",
		"srvOps": "srvop",
		"sap": "sap"
	},
	"pSubNodes": {
		"wins": "wins",
		"entities": "entities",
		"target": "target",
		"ist": "ist",
		"box": "box",
		"acts": "acts"
	},
	"stubTarget": {
		"rpc": "_stubSapTarget_rpc",
		"askui": "_stubSapTarget_askui",
		"selpr": "_stubSapTarget_selpr",
		"portal": "_stubSapTarget_portal",
		"plugin": "_stubSapTarget_plugin"
	}
};
_sapK.stubTarget[_sapK.pSubNodes.ist] = "stubSapTarget_ist";
_sapK.stubTarget[_sapK.pSubNodes.box] = "_stubSapTarget_box";
var _sapAuto = [{
	"root": _sapK.pNodes.sap,
	"catg": "$4glDiagnoses",
	"id": null,
	"subid": null,
	"exec": "_stub4glDiagnoses",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": "func",
	"id": "close",
	"subid": null,
	"exec": "stubWinClose",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sess,
	"catg": "close",
	"id": null,
	"subid": null,
	"exec": "_stubSessClose",
	"end": true,
	"next": false
}, {
	"root": _sapK.pNodes.sess,
	"catg": "reboot",
	"id": null,
	"subid": null,
	"exec": "_stubSessReboot",
	"end": true,
	"next": false
}, {
	"root": _sapK.pNodes.sess,
	"catg": "settings",
	"id": null,
	"subid": null,
	"exec": "_stubSessSets",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sess,
	"catg": "open",
	"id": null,
	"subid": null,
	"exec": "_stubSessOpen",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.srvOps,
	"catg": "request",
	"id": null,
	"subid": null,
	"exec": "_stubSrvopRequest",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": "func",
	"id": "open",
	"subid": null,
	"exec": "_stubWinOpen",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": _sapK.pSubNodes.acts,
	"id": null,
	"subid": null,
	"exec": "_stubActs",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": "previous",
	"id": null,
	"subid": null,
	"exec": "_stubSetPrevValue",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": _sapK.pSubNodes.wins,
	"id": null,
	"subid": null,
	"exec": "_stubSetWins",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": "misc",
	"id": null,
	"subid": null,
	"exec": "_stubSapMisc",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": "rpc",
	"id": null,
	"subid": null,
	"exec": "_stubSapCallReply",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": "jobs",
	"id": null,
	"subid": null,
	"exec": "_stubSapJobs",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": _sapK.pSubNodes.target,
	"id": null,
	"subid": null,
	"exec": "_stubSapTarget",
	"end": false,
	"next": false
}];
var _sapAbort = [{
	"root": _sapK.pNodes.sap,
	"catg": "target",
	"id": "box",
	"subid": null,
	"exec": "_replyAbortBoxEnd",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sap,
	"catg": "target",
	"id": "box",
	"subid": null,
	"exec": "_replyAbortBoxInf",
	"end": false,
	"next": true
}, {
	"root": _sapK.pNodes.sess,
	"catg": "close",
	"id": null,
	"subid": null,
	"exec": "_replyAbortClose",
	"end": true,
	"next": true
}, {
	"root": _sapK.pNodes.sess,
	"catg": "reboot",
	"id": null,
	"subid": null,
	"exec": "_replyAbortReboot",
	"end": true,
	"next": true
}];
var _sessSetRequiredK = {
	"mandatory": ["ADXLangIso", "datePivot", "cdLang", "DefaultDateFormat", "fmtExt", "dateOrder", "dateSep", "thousandSep", "decimalSep"],
	"strict": ["mnu", "ADXStyleFile"]
};

// Misc utilities
exports.isSapReply = function(reply) {
	return _.find(_sapAuto, function(rule) {
		return this.hasOwnProperty(rule.root);
	}, reply) !=
		undefined ? true : false;
};
exports.getSessSetsFromReply = function(reply) {
	return (reply[_sapK.pNodes.sess] ? reply[_sapK.pNodes.sess].settings : null);
};
exports.getsrvOptsFromReply = function(reply) {
	return reply ? reply[_sapK.pNodes.srvOps] : null;
};
exports.isSessStatementsOk = function(reply, strict, extra) {
	var settings = exports.getSessSetsFromReply(reply),
		i = 0,
		l = _sessSetRequiredK.mandatory.length,
		ok = false,
		srvOpts, missing = null;
	if (settings) {
		while (i < l && settings[_sessSetRequiredK.mandatory[i]] !== undefined) {
			i++;
		}
		if (i === l && strict) {
			i = 0;
			l = _sessSetRequiredK.strict.length;
			while (i < l && settings[_sessSetRequiredK.strict[i]] !== undefined) {
				i++;
			}
			if (i < l) {
				missing = _sessSetRequiredK.strict[i];
			}
		} else
		if (i < l) {
			missing = _sessSetRequiredK.mandatory[i];
		}
	} else {
		missing = _sessSetRequiredK.mandatory[0];
	}
	if (i === l) {
		srvOpts = exports.getsrvOptsFromReply(reply);
		ok = !! (srvOpts && srvOpts.sessionInfo);
		if (!ok) {
			missing = srvOpts ? "srvOpts.sessionInfo" : "srvOpts";
		}
	}
	if (!ok && missing && extra) {
		extra.missingStatement = missing;
	}
	return ok;
};
exports.purgeCnxPollingReply = function(partialReply, consolidatedReply) {
	var closeIn, openIn, openReg, closeInSorted, winPurged = false,
		ptr, purged;
	if (partialReply && consolidatedReply) {
		// Purge open/close window while polling during connection
		if (partialReply.sap && partialReply.sap.func) {
			openIn = partialReply.sap.func.open;
			closeIn = partialReply.sap.func.close;
		}
		openReg = consolidatedReply.sap && consolidatedReply.sap.func && consolidatedReply.sap.func.open;
		if (closeIn && closeIn.length > 0) {
			closeInSorted = closeIn.sort(function(a, b) {
				return (b.charCodeAt(0) - a.charCodeAt(0));
			});
			_.each(closeInSorted, function(winId) {
				purged = false;
				if (openReg && openReg[winId]) {
					delete openReg[winId];
					purged = true;
					ptr = consolidatedReply;
				} else
				if (openIn && openIn[winId]) {
					purged = true;
					delete openIn[winId];
					ptr = partialReply;
				}
				if (purged) {
					if (ptr.sap.wins[winId]) {
						delete ptr.sap.wins[winId];
					}
					closeIn.splice(closeIn.indexOf(winId), 1);
					winPurged = true;
				}
			});
			if (winPurged) {
				if (openReg && (Object.keys(openReg)).length == 0) {
					delete consolidatedReply.sap.func.open;
				}
				if (openIn && (Object.keys(openIn)).length == 0) {
					delete partialReply.sap.func.open;
				}
				if (closeIn.length == 0) {
					delete partialReply.sap.func.close;
				}
			}
		}
	}
};

function _dispFmtErrBox(params, ctrlObj, replyCompleteCallback) {
	var boxParams, boxOpts;
	params.$diagnoses = params.$diagnoses || [util.makeDiagnosis(ctrlObj._session.getlabel("error", "12", "Incorrect value, it does not respect field format or field type"), 3, "stubSapTarget_ist()", "12", util.cltFusionNice)];
	boxParams = util.diagnosesToOurErrEx(params.$diagnoses);
	msgBox.setMsgBoxDefaultProp(boxParams, 4, 60, ctrlObj._session.getlabel("error", "13", "Input Error"));
	boxOpts = msgBox.getMsgBoxOpts.call(ctrlObj, boxParams);
	boxOpts.callback = function(resp, closureMode) {
		ctrlObj._wndwsStack.setFocus(params.win, true, sapUtil.focusStyle.fmtErr.code, params.xid, params.nl || 1, (params.edit === null || params.edit === undefined ? true : params.edit), params);
		if (replyCompleteCallback) {
			replyCompleteCallback();
		}
		msgBox.releaseMsgBoxParams(boxOpts);
		msgBox.releaseBoxParams(boxParams);
	};
	setTimeout(function() {
		syra_diagnose.box.show(boxOpts);
	}, 10);
	return {
		"notifyCalled": true
	};
}

function _getSrvopRqst(reply) {
	var srvop = exports.getsrvOptsFromReply(reply);
	return srvop && srvop.request;
}

function _shouldHighlightTarget(reply, target) {
	var srvops = _getSrvopRqst(reply),
		highlight = true;
	if (srvops) {
		highlight = srvops.v && (requestActions.isActFocusSelected(srvops.v) || (requestActions.isActFldFocus(srvops.v) && !sapUtil.cmpIst(srvops.rqtdist, target, true)));
	}
	return highlight;
}


// Adx page input controller class

function SapController() {}

exports.Controller = helpers.defineClass(SapController, null, {
	initialize: function(siteController) {
		var i, len;
		this._siteController = siteController;
		if (this._siteController) {
			this._session = this._siteController.getSession();
			this.fmtWrapper = this._siteController.getFormatWrapper();
		}
		(this._wndwsStack = new Window.WinStack()).initialize(this);
		this._currCtx = {
			"ist": sapUtil.makeIst("A", "", 0),
			"localIst": null,
			"ctxMenu": [],
			"v": null,
			"screenTab": {}
		};
		this._sapActivity = {
			"lastRqst": null
		};
		this.replyOnPollingMode = false;
		this._printerAccess = null;
		this._askuiAccess = null;
		this._initBlockingNodesArray();
		this._magnetoActions = {};
		this._pluginManager = new Plugin.PluginManager(this);
		for (i = 0, len = requestActions.kActionsMagneto.length; i < len; i++) {
			this._magnetoActions[requestActions.getSrvAction(requestActions.kActionsMagneto[i])] = true;
		}
	},

	initSurvivalMode: function(cdLang) {
		var self = this;
		this._session = {
			"cdIsoLang": cdLang || syra_fusion.defLang
		};
		this._session.getlabel = function(catg, code, dflt) {
			// Just one category supported : "error"
			var messId = parseInt(code, 10) + 1000;
			return syra_fusion.getMessage(messId) || dflt;
		};
	},

	_initBlockingNodesArray: function() {
		this._blockingNodesArray = [{
			"id": "NDGTIM_selimp",
			"instance": "_printerAccess",
			"checkMethod": "isOnGoing",
			"release": "abort",
			"action": requestActions.getProxyAction("PRINTER_SEL_CANCEL"),
			"params": {}
		}, {
			"id": "ND_ASKUI_askui",
			"instance": "_askuiAccess",
			"checkMethod": "isProcessing",
			"release": "abort",
			"action": requestActions.getSrvAction("SRV_ASKUI"),
			"params": Askui.makeAskuiParam(Askui.returnStatus.cancel)
		}];
	},

	isReplyFromTabulationAction: function(reply) {
		// Warning : used only for very special stuff
		var srvop = _getSrvopRqst(reply);
		return srvop && srvop.v == requestActions.getSrvAction("SRV_CHAMP_SUIVANT") && this.getTargetIstFromReply(reply) && !this._boxDisplayedInPreviousReply ? true : false;
	},

	getSiteController: function() {
		return this._siteController;
	},

	getBaseUrl: function() {
		return (this.getSiteController()).getSapPostBaseUrl();
	},

	getLang: function(iso) {
		return (this.getSiteController()).getLang(iso);
	},

	getMessLabel: function(code, catg, dflt) {
		return this._session.getlabel(catg, code, dflt);
	},

	getlogger: function() {
		return this._siteController.getLogger();
	},

	onSharedResReady: function() {
		(this._ackcallStack = new Ackcall.AckCallStack()).initialize(this, this._session.isNodeWS());
		this._wndwsStack.setGlobalMenu(this._session, this._session ? this._session.getWinSessMnus() : null);
		this._sapActivity.start = (new Date()).getTime();
	},

	cleanInitialReply: function(reply) {
		var sessMnus, sessSetN;
		if (reply[_sapK.pNodes.sess] && (sessSetN = reply[_sapK.pNodes.sess].settings)) {
			// Clean settings... but we have to keep session menus definition if necessary
			if ((!this._session || !(sessMnus = this._session.getWinSessMnus()) || !sessMnus.length) && sessSetN.mnu && sessSetN.mnu.length) {
				sessSetN = util.duplicateObj(sessSetN.mnu);
				delete reply[_sapK.pNodes.sess].settings;
				reply[_sapK.pNodes.sess].settings = {
					"mnu": sessSetN
				};
			} else {
				delete reply[_sapK.pNodes.sess].settings;
			}
		}
		if (reply[_sapK.pNodes.srvOps]) {
			delete reply[_sapK.pNodes.srvOps];
		}
	},

	getRequestData: function(inst, action, params) {
		// Init
		var valueEx = null,
			data = {
				"act": action,
				"fld": {
					"ist": sapUtil.makeIst("", "", 0)
				},
				"param": params,
				"tech": {},
				ctrlResult: {
					"succeeded": true
				}
			}, extraProps;
		// Retrieve current instance and data
		if (!this._siteController._localOpts.fixture || !this._siteController._localOpts.fixture.on) {
			data.fld.ist = params && params.hasOwnProperty("ist") ? params.ist : sapUtil.makeIst(this._currCtx.ist.win, this._currCtx.ist.xid, this._currCtx.ist.nl);
			valueEx = this._wndwsStack.getDataInputValue(this._currCtx.ist.win, this._currCtx.ist.xid, this._currCtx.ist.nl || 1);
			data.fld.fmtKind = params && params.hasOwnProperty("xFmt") ? params.xFmt : (valueEx ? valueEx.xFmt : sapUtil.fieldModeType.show);
			data.fld.ctx = valueEx ? valueEx.ctx || {} : {};
			data.fld.notModified = params && params.hasOwnProperty("notModified") ? params.notModified : (valueEx ? valueEx.notModified : undefined);
			if (!data.fld.notModified) {
				data.fld.v = params && params.hasOwnProperty("v") ? params.v : (valueEx ? valueEx.v : null);
			}
			extraProps = data.fld.extra = {};
			extraProps.type = params && params.hasOwnProperty("xType") ? params.xType : this._wndwsStack.getEntityType(this._currCtx.ist.win, this._currCtx.ist.xid);
			extraProps.fmt = this._currCtx.ist.fmt;
			extraProps.raw = this._currCtx.ist.raw;
			// Check data value...
			data.ctrlResult = this._checkCurrFieldData(data.fld, params);
			delete data.fld.extra;
		}
		// Tech data
		this.getRequestTech(data.tech);
		// Cleanup
		if (params) {
			delete params.v;
			delete params.ist;
			delete params.xFmt;
			delete params.notModified;
			delete params.discardCtrl;
		}
		return data;
	},

	_checkCurrFieldData: function(fieldData, params) {
		var extraProps, ctrlResult = {
				"succeeded": true
			}, ist;
		if (fieldData && (ist = fieldData.ist)) {
			// Local control & cie...
			if ((!params || !params.discardCtrl) && !fieldData.notModified) {
				extraProps = fieldData.extra;
				ctrlResult = this.fmtWrapper.checkOnFocusOut(fieldData.v, extraProps.type, extraProps.fmt, fieldData.fmtKind, extraProps.raw);
				if (ctrlResult.succeeded && !ctrlResult.withoutFmt) {
					fieldData.v = ctrlResult.raw;
				}
			}
			// Update sent data
			if (ctrlResult.succeeded && !fieldData.notModified && sapUtil.isFieldInst(ist.xid)) {
				this._wndwsStack.setDataStoreValue(ist.win, ist.xid, ist.nl, fieldData.v, {
					"noUI": true
				});
			}
		}
		return ctrlResult;
	},

	getRequestTech: function(tech) {
		var trcSwitch = "srvTrc";
		if (document[sapUtil._fNS] && document[sapUtil._fNS].hasOwnProperty(trcSwitch)) {
			tech.trace = tech.trace || {};
			tech.trace.on = document[sapUtil._fNS][trcSwitch];
			tech.trace.server = document[sapUtil._fNS]["srvTrcSrv"] || null;
			tech.trace.port = document[sapUtil._fNS]["srvTrcPort"] || null;
			tech.trace.level = document[sapUtil._fNS]["srvTrcLevel"] || null;
			delete document[sapUtil._fNS][trcSwitch];
		}
	},

	getEntityValueInReply: function(reply, entityIst) {
		var value = null,
			ref, entity = null,
			coll, uuid;
		if ((ref = reply[_sapK.pNodes.sap]) && (ref = ref[_sapK.pSubNodes.wins]) && (ref = ref[entityIst.win]) && (ref = ref[_sapK.pSubNodes.entities])) {
			entity = ref[entityIst.xid];
			if (!entity && entityIst.nl) {
				coll = sapUtil.getBlockInst(entityIst.xid);
				ref = ref[coll] ? ref[coll]["$rcd"] : null;
				if (ref) {
					entity = _.find(ref, function(record) {
						// SAM 98586
						uuid = (record.$serverIndex != undefined) ? record.$serverIndex : record.$uuid;
						return uuid === (entityIst.nl - 1) && record.hasOwnProperty(entityIst.xid);
					});
					value = entity ? entity[entityIst.xid] : null;
				}
			} else {
				value = entity ? entity.v : null;
			}
		}
		return value;
	},

	isControlFailedInReply: function(reply, ist) {
		var ref, instance = ist || (reply && (ref = reply[_sapK.pNodes.sap]) && (ref = ref[_sapK.pSubNodes.target]) ? ref[_sapK.pSubNodes.ist] : null);
		return instance && instance.ctrlFailed;
	},

	getTargetIstFromReply: function(reply) {
		return this._getTargetFromReply(reply, _sapK.pSubNodes.ist);
	},

	getTargetBoxFromReply: function(reply) {
		return this._getTargetFromReply(reply, _sapK.pSubNodes.box);
	},

	_getTargetFromReply: function(reply, targetId) {
		var ref;
		return reply && (ref = reply[_sapK.pNodes.sap]) && (ref = ref[_sapK.pSubNodes.target]) && (ref = ref[targetId]) ? ref : null;
	},

	getTargetCtxMenuFromReply: function(reply) {
		var targetIst = this.getTargetIstFromReply(reply);
		return targetIst ? targetIst.acts : null;
	},

	setLocalIst: function(ist) {
		return this._currCtx.localIst = ist;
	},

	getCurrInst: function(wide) {
		return wide ? (this._currCtx.localIst || this._currCtx.ist) : this._currCtx.ist;
	},

	_initNewCurrIst: function(params) {
		var isSameIst, editVal, currIst, oldRaw, oldFmt, oldIst, field, showVal, oldShow, newEdit, updateData = {}, updateOpts, win;
		// Check border line cases...
		if (this._checkEvilInstance(params)) {
			return true;
		}
		// Check old field context
		oldIst = util.duplicateObj(this._currCtx.ist);
		isSameIst = sapUtil.cmpIst(params, oldIst, true);
		if (!params.ctrlFailed) {
			this._wndwsStack.setDirty(oldIst.win, oldIst.xid, oldIst.nl, false);
		}
		if (sapUtil.isFieldInst(oldIst.xid) && oldIst.edit && (!isSameIst || (!sapUtil.isGridInst(oldIst) && !params.ctrlFailed))) {
			// Set "show" value in prev field, if ctrl OK (little trick to avoid erase field if same ist in  cell array...)
			oldFmt = this._wndwsStack.getDataFmt(oldIst.win, oldIst.xid, oldIst.nl);
			if (oldFmt) {
				oldRaw = this._wndwsStack.getDataStoreValue(oldIst.win, oldIst.xid, oldIst.nl, false, true, {
					"rawVal": true
				});
				showVal = this.fmtWrapper.rawToDisplay(oldRaw, oldFmt, true);
			}
		}
		// Init new context
		_.each(this._currCtx, function(value, key) {
			delete this[key];
		}, this._currCtx);
		this._currCtx = {
			"ist": {}
		};
		_.each(params, function(value, name) {
			if (name != "acts") {
				this[name] = value;
			}
		}, this._currCtx.ist);
		this._currCtx.localIst = null;
		currIst = this._currCtx.ist;
		if (sapUtil.isFieldInst(currIst.xid)) {
			// Set raw and format in current field ctx
			currIst.fmt = this._wndwsStack.getDataFmt(params.win, params.xid, params.nl);
			currIst.raw = this._wndwsStack.getDataStoreValue(params.win, params.xid, params.nl, false, true, {
				"rawVal": true
			});
			if (!isSameIst && currIst.fmt && currIst.raw != undefined && (currIst.edit || currIst.edit === undefined)) {
				// Put edit value in field
				editVal = this.fmtWrapper.rawToEdit(currIst.raw, currIst.fmt);
			}
		}
		// Update previous and current value
		updateOpts = {
			"formatted": true,
			"noStoreCommmit": true,
			"discardUnsort": true,
			"notifyChangeAndDiscardRedraw": true
		};
		if (showVal && showVal.succeeded) {
			sapUtil.appendEntitiesValue(updateData, oldIst.win, oldIst.xid, oldIst.nl, showVal.show);
		}
		if (editVal && editVal.succeeded) {
			sapUtil.appendEntitiesValue(updateData, currIst.win, currIst.xid, currIst.nl, editVal.edit);
		}
		if (currIst.win == oldIst.win && currIst.win) {
			win = this._wndwsStack.getWindow(oldIst.win);
			win.setEntitiesValue(updateData[currIst.win], updateOpts, true);
		} else {
			if (updateData[oldIst.win]) {
				win = this._wndwsStack.getWindow(oldIst.win);
				win.setEntitiesValue(updateData[oldIst.win], updateOpts, true);
			}
			if (updateData[currIst.win]) {
				win = this._wndwsStack.getWindow(currIst.win);
				win.setEntitiesValue(updateData[currIst.win], updateOpts, true);
			}
		}
		// Misc controls...
		sapUtil.setFieldMod(this._wndwsStack.getBoundField(currIst.win, currIst.xid), currIst);
		if (!isSameIst) {
			if (sapUtil.isGridInst(oldIst)) {
				// Check grid cardview status...
				sapUtil.checkPopupCard(oldIst, params, this._wndwsStack.getBoundField(oldIst.win, sapUtil.getBlockInst(oldIst.xid)));
			}
		}
		return false;
	},
	getBoundField: function(fieldIst, opts) {
		return this._wndwsStack.getBoundField(fieldIst.win, fieldIst.xid, opts);
	},
	setCurrCtxMenu: function(ctxMenus) {
		delete this._currCtx.ctxMenu;
		this._currCtx.ctxMenu = util.duplicateObj(ctxMenus);
	},

	setCurrIstInputValidate: function(valid) {
		this._currCtx.istInputInvalid = !valid;
	},

	isCurrIstInputValidate: function(valid) {
		return !!(!this._currCtx.istInputInvalid);
	},

	setCurrTab: function(tabXid, tabIdx) {
		if (!this._currCtx.screenTab) {
			this._currCtx.screenTab = {};
		}
		this._currCtx.screenTab.tabXid = tabXid;
		this._currCtx.screenTab.tabIdx = tabIdx;
	},

	getCurrTab: function() {
		return this._currCtx.screenTab;
	},

	getCurrTabIdx: function() {
		return this._currCtx.screenTab ? this._currCtx.screenTab.tabIdx : null;
	},

	getCurrTabXid: function() {
		return this._currCtx.screenTab ? this._currCtx.screenTab.tabXid : null;
	},

	isActiveWindow: function(winId) {
		return this._wndwsStack.isActiveWindow(winId);
	},

	getWindow: function(target) {
		return this._wndwsStack.getWindow(typeof target == 'object' ? target.win : target);
	},

	isActionEnabled: function(winId, action, categorie) {
		return this._wndwsStack.isActionEnabled(winId, action, categorie);
	},

	removeFocus: function() {
		var ist = this.getCurrInst();
		this._wndwsStack.removeFocus(ist.win, ist.xid, ist.nl);
	},

	hasFocus: function(field, winId, nl, extra, discardLine) {
		var meta, method = extra ? "cmpIstEx" : "cmpIst";
		if (field.hasOwnProperty("xid")) {
			return sapUtil[method](this.getCurrInst(), field, discardLine);
		} else {
			meta = syraUtil.getMetaFromObject(field);
			return (meta = syraUtil.getMetaFromObject(field)) ? sapUtil[method](this.getCurrInst(), sapUtil.makeIst(winId, meta.$bind, nl), discardLine) : false;
		}
	},

	forceValue: function(params, noStoreCommmit, hardForce) {
		var num, istType;
		if (params.xid && params.hasOwnProperty("v") && params.v != null) {
			istType = params.win ? this._wndwsStack.getEntityType(params.win, params.xid) : null;
			// Check data type (by design, forcing value is restricted, except hard force )...
			if (!hardForce && (!istType || istType == syraUtil.dataTypes.rtfType || sapUtil.isSpecialScrnId(params.xid))) {
				return null;
			} else
			if (!hardForce && istType == syraUtil.dataTypes.choiceType && !_.isNumber(params.v)) {
				num = parseInt(params.v, 10);
				if (isNaN(num)) {
					return null;
				} else {
					params.v = num;
				}
			}
			// Set value
			this._wndwsStack.setDataStoreValue(params.win, params.xid, params.nl, params.v, {
				"noStoreCommmit": noStoreCommmit,
				"discardUnsort": true
			});
		}
		return null;
	},

	_processEndStatement: function(exec, context) {
		var siteController = this.getSiteController(),
			_postCallback;
		this._sapActivity.stop = (new Date()).getTime();
		if (context._techReply.isPostCallback) {
			_postCallback = context._techReply.postMortem.callback;
			context._techReply.postMortem.callback = function() {
				var args = arguments;
				setTimeout(function() {
					siteController[exec](function() {
						_postCallback.apply(null, args);
					});
				}, 20);
			};
		} else {
			setTimeout(function() {
				siteController[exec]();
			}, 20);
		}
	},

	_getLoadRepParams: function(winParams) {
		var params = {}, specialWin = sapUtil.isSpecialWin(winParams.name),
			winType = winParams.type,
			extProps = sapUtil.getWinExtProps(winParams.extend);
		if (specialWin) {
			params = {
				"name": specialWin.name
			};
			if (specialWin.id == sapUtil.specialWindow.selbox.id || specialWin.id == sapUtil.specialWindow.choose.id) {
				params.$facet = syraUtil.pageFacet.lookup;
			} else
			if (specialWin.id == sapUtil.specialWindow.formula.id) {
				params.$itemPage = FormulaRes.getFormulaPage();
			}
		}
		if (extProps && extProps.transaction) {
			params.$variant = extProps.transaction;
		}
		return params;
	},

	_shoulDispWinMagneto: function(winFacet, reply) {
		var i, len, ret = false,
			facetCd = syraUtil.pageFacet,
			actsList, act;
		// Cf. SAM 98635.
		if (winFacet == facetCd.edit) {
			ret = true;
		} else
		if (winFacet == facetCd.modal2) {
			actsList = reply[_sapK.pNodes.sap][_sapK.pSubNodes.acts];
			for (i = 0, len = actsList ? actsList.length : 0; i < len; i++) {
				act = actsList[i];
				if (this._magnetoActions[act.id] && act.st) {
					ret = true;
					break;
				}
			}
		}
		return ret;
	},

	_checkEvilInstance: function(instance) {
		if (sapUtil.isButtonScreen(instance.xid) && sapUtil.cmpIst(instance, this.getCurrInst())) {
			// Loop on "Button" pseudo screen : break (Cf. method "setFocus" of "WinStack" Class).
			return true;
		}
	},

	_isValueChanged: function(params) {
		var winModel, fval = (params.v === undefined ? false : true);
		if (fval && params.nl && params.nl > 0 && (winModel = this._wndwsStack.getWindow(params.win))) {
			fval = !(winModel.getDataStoreValue(params.xid, params.nl) === params.v);
		}
		return fval;
	},

	_getCloseReason: function(reasonCode, reboot) {
		// TODO : improve
		return (reboot ? "Server sent reboot statement." : ("" + reasonCode || "unknown..."));
	},

	processReply: function(reply, workingCtx) {
		try {
			var callNotify, ret = (workingCtx && workingCtx.failed) ? null : this._parseReply(reply, workingCtx || (workingCtx = this.initReplyParseCtx()), _sapAuto),
				st = true;
			if (ret && !ret.ok) {
				st = false;
			} else
			if (workingCtx.failed) {
				// SAP parsing case. Should be recovered... : TODO
				if ((callNotify = workingCtx && workingCtx._techReply && workingCtx._techReply.replyComplete)) {
					callNotify();
					delete workingCtx._techReply.replyComplete;
				}
				st = false;
			}
		} catch (ex) {
			ret = {
				"ok": false
			};
			ret.diagnoses = util.makeDiagnosis(this._session.getlabel("error", "18", syra_fusion.getMessage("13")), 4, ex.message + "\n" + ex.stack, "18", util.cltFusionNice);
			st = false;
		} finally {
			if (ret && !ret.ok) {
				// Parsing fatal error or unexpected behaviour : unrecovered case!
				if (!workingCtx.throwError) {
					this._sapException(reply, ret.diagnoses, {
						"typ": "RqstSrv",
						"act": requestActions.getSrvAction("SRV_FIN_APPLI"),
						"param": {
							"ist": null,
							"v": ""
						}
					}, null, null, workingCtx && workingCtx._techReply && workingCtx._techReply.replyComplete);
				} else {
					if (!workingCtx.diagnoses) {
						workingCtx.diagnoses = util.duplicateObj(ret.diagnoses);
					} else {
						workingCtx.diagnoses.push(util.duplicateObj(ret.diagnoses));
					}
					workingCtx.failed = true;
				}
			}
			if (workingCtx.pollingMode && workingCtx._techReply.pollingReplyComplete && !workingCtx.wndwPending) {
				workingCtx._techReply.pollingReplyComplete(true);
				delete workingCtx._techReply.pollingReplyComplete;
			}
			return st;
		}
	},

	initReplyParseCtx: function() {
		return {
			"syraPageModel": null,
			"failed": false,
			"diagnoses": []
		};
	},

	setPollingParseCtxOpts: function(parseCtx, on) {
		parseCtx.ignoreTargetLess = on;
		parseCtx.throwError = on;
		parseCtx.pollingMode = on;
	},

	isAbortReply: function(reply) {
		var _abort = {
			"abort": false,
			"diagnoses": []
		}, logger;
		this._parseReply(reply, _abort, _sapAbort);
		if (_abort.abort && (logger = this.getlogger())) {
			logger.debug({
				"severety": "error"
			}, "Connexion aborted. Reason : " + _abort.reason);
			logger.debug({
				"toJson": true
			}, _abort.diagnoses);
		}
		return _abort.abort ? _abort.diagnoses : null;
	},

	_replyAbortBoxEnd: function(params, ctx) {
		var status = null,
			defMess, srvMess;
		if (params.type == 4) {
			ctx.reason = this._getCloseReason(4);
			defMess = syra_fusion.getMessage("12");
			srvMess = params.li ? params.li.join("\n") : "";
			ctx.diagnoses.push(util.makeDiagnosis(srvMess || this._session.getlabel("error", "3", defMess), 3, "sap.Controller._replyAbortBoxEnd()", "04", util.backOfficeNice, ctx.reason));
		}
		return status;
	},

	_replyAbortBoxInf: function(params, ctx) {
		if (params.li && params.type != 4) {
			ctx.diagnoses.push(util.makeDiagnosis(params.li.join("\n"), params.type));
		}
		return null;
	},

	_replyAbortClose: function(params, ctx, categorie, reply, reboot) {
		var defMess, reason;
		if (ctx.abort) {
			// Avoid to accumulate "close", "reboot", etc...
			return null;
		}
		ctx.abort = true;
		reason = this._getCloseReason(params.reason, reboot);
		if (ctx.diagnoses.length === 0) {
			defMess = syra_fusion.getMessage("12");
			ctx.reason = reason;
			ctx.diagnoses.push(util.makeDiagnosis(this._session.getlabel("error", "3", defMess), 3, "sap.Controller._replyAbortClose()", "3", util.backOfficeNice, ctx.reason));
		} else {
			ctx.diagnoses[0].$details = reason;
		}
		return null;
	},

	_replyAbortReboot: function(params, ctx, categorie, reply) {
		return this._replyAbortClose(params, ctx, categorie, reply, true);
	},

	_parseReply: function(reply, workingCtx, rules) {
		var next = true,
			i = 0,
			params, status = null,
			len = rules.length;
		while (next && i < len) {
			if (reply[rules[i].root] && (params = (rules[i].catg ? reply[rules[i].root][rules[i].catg] : reply[rules[i].root]))) {
				params = (rules[i].id ? (rules[i].subid ? (params[rules[i].id] ? params[rules[i].id][rules[i].subid] : null) : params[rules[i].id]) : params);
				if (params) {
					status = this[rules[i].exec](params, workingCtx, reply[rules[i].root][rules[i].catg], reply);
					next = rules[i].end ? false : rules[i].next;
					// Check execution status
					if (status && (!status.ok || status.brk)) {
						next = false;
					}
				}
			}
			if (next && (!status || status.ok)) {
				i++;
			}
		}
		if (i >= len) {
			next = true;
			_.each(rules, function(item) {
				next = next ? item.next : false;
			});
			if (!next && !workingCtx.ignoreTargetLess) {
				// At least one rule doesn't have a "next" rule! So, we register a parsing error.
				if (!status) {
					status = {
						"diagnoses": []
					};
				} else
				if (!status.diagnoses) {
					status.diagnoses = [];
				}
				status.ok = false;
				status.diagnoses.push(util.makeDiagnosis(this._session.getlabel("error", "5", "Last message sent by server does not contain\"end\" rule."), 3, "sap.Controller._parseReply().\n Reply received :\n" + reply, "5", util.cltFusionNice));
			}
		}
		return status;
	},

	_stubSessClose: function(params, parseCtx, categorie, reply, reboot) {
		var callNotify = parseCtx && parseCtx._techReply && parseCtx._techReply.replyComplete;
		/*this.getSiteController().triggerAdx("sap.sess." + reboot ? "reboot" : "close", {"target": this,
         "type": reboot ? "reboot" : "close", "data": params});*/
		var siteController = this.getSiteController(),
			logger = this.getlogger();
		if (callNotify) {
			callNotify();
			delete parseCtx._techReply.replyComplete;
		}
		if (logger) {
			logger.debug({
				"severety": "info"
			}, "Connexion closed. Reason : " + this._getCloseReason(params.reason, reboot));
		}
		this._processEndStatement("onSapCompleted", parseCtx);
		return null;
	},

	_stubSessReboot: function(params, parseCtx, categorie, reply) {
		return this._stubSessClose(params, parseCtx, categorie, reply, true);
	},

	_stubSessSets: function(params, parseCtx) {
		if (parseCtx.syraPageModel || !this._session) {
			return null;
		}
		this._session.updateSettings(params);
		if (params.mnu && this._wndwsStack && this._session.setWinSessMnus(params.mnu)) {
			this._wndwsStack.setGlobalMenu(this._session, this._session.getWinSessMnus());
		}
		return null;
	},

	_stubSessOpen: function(params, parseCtx) {
		var tab;
		if (parseCtx.syraPageModel) {
			return null;
		}
		if (params && params.ctx) {
			tab = window.open(this._session.getWorkFlowUrl(params.ctx), "_blank");
			// TODO: Register secondary session, to force close on primary closing
		}
		return null;
	},

	_stubSrvopRequest: function(params, parseCtx) {
		if (parseCtx.syraPageModel) {
			return null;
		}
		// TODO
		return null;
	},

	stubWinClose: function(params, parseCtx, func, reply) {
		/*function isForceBackUrl(url) {
			return url && syra_site.firstUrl && syra_site.lastHref !== syra_site.firstUrl && url.indexOf("/auth/") === -1;
		}*/
		var self = this,
			closeArray = params.slice(0),
			closeArraySorted;
		if (params.length == 0) {
			return null;
		}
		// Sort "close" clause in order to process the top stack windows first
		closeArraySorted = closeArray.sort(function(a, b) {
			return (b.charCodeAt(0) - a.charCodeAt(0));
		});
		_.each(closeArraySorted, function(winId) {
			var id;
			if (!this._wndwsStack.shouldDiscardCloseOpen(winId, func.open)) {
				this._wndwsStack.unStack(winId);
				// TODO : control "unStack" return code ?!?
			} else {
				// So, remove "open" clause in reply, and cleanup win data!!
				id = (self._wndwsStack._getWinIdEx(winId)).id;
				delete func.open[id];
				self._wndwsStack.razWinData(id);
				if ((Object.keys(func.open)).length == 0) {
					delete func.open;
				}
			}
			params.splice(params.indexOf(winId), 1);
		}, this);
		return null;
	},

	_stubWinOpen: function(params, parseCtx, func, reply) {
		var winId = null,
			ret = null,
			nextWin = null,
			self = this,
			loadParams, i;

		function _onWinOpenErr(dgns, errCtx) {
			if (!parseCtx.pollingMode) {
				self._sapException(reply, dgns, {
					"typ": "RqstSrv",
					"act": requestActions.getSrvAction("SRV_ABANDON"),
					"param": {
						"ist": null,
						"notModified": true
					}
				}, errCtx, null, parseCtx && parseCtx._techReply ? parseCtx._techReply.replyComplete : null);
			} else {
				_.each(dgns, function(diag) {
					parseCtx.diagnoses.push(diag);
				});
				delete parseCtx.wndwPending;
				parseCtx.failed = true;
				self.processReply(reply, parseCtx);
			}
		}
		if (!parseCtx.syraPageModel) {
			// Init : sort "open" clause in order to process low stack windows first
			parseCtx.wndwsId = _.keys(params).sort(function(a, b) {
				return (a.charCodeAt(0) - b.charCodeAt(0));
			});
			for (i = parseCtx.wndwsId.length - 1; i >= 0; i--) {
				// Have to protect against an "open" statement on same windows ID - Cf. SAM 98860. This test may be removed once server side bug (#4007) will be fixed).
				if (this._wndwsStack.getWindow(parseCtx.wndwsId[i])) {
					delete params[parseCtx.wndwsId[i]];
					parseCtx.wndwsId.splice(i, 1);
				}
			}
			if (!parseCtx.wndwsId.length) {
				delete parseCtx.wndwsId;
				return null;
			} else {
				parseCtx.syraPageModel = {};
				parseCtx.win2Process = {
					"id": 0
				};
			}
		}
		if (parseCtx.wndwPending) {
			// If built window pending, register this window
			winId = parseCtx.wndwsId[parseCtx.wndwPending.id];
			this._wndwsStack.stack(winId, params[winId], parseCtx.syraPageModel);
			this._wndwsStack.postBuildInit(winId);
			// Release
			delete parseCtx.wndwPending;
			delete parseCtx.syraPageModel;
			if (parseCtx.win2Process) {
				parseCtx.syraPageModel = {};
			}
		}
		if (parseCtx.win2Process) {
			nextWin = parseCtx.wndwsId.length > (parseCtx.win2Process.id + 1) ? (parseCtx.win2Process.id + 1) : null;
			parseCtx.wndwPending = {
				"id": parseCtx.win2Process.id
			};
			winId = params[parseCtx.wndwsId[parseCtx.win2Process.id]];
			(nextWin ? parseCtx.win2Process.id = nextWin : delete parseCtx.win2Process);
			loadParams = _.defaults(this._getLoadRepParams(winId), {
				"id": parseCtx.wndwsId[parseCtx.wndwPending.id],
				"name": winId.name,
				"mainPage": !! (this._wndwsStack.length() === 0)
			});
			if (_debugProto && _debugProto.debugMode) {
				loadParams.$itemPage = _debugProto.$itemPage;
				loadParams.$itemPage.$x3Facet = _debugProto.$facet;
				if (_debugProto.trace) {
					this._siteController.toggleLog();
				}
			}
			this._siteController.loadRepresentation(loadParams, null, function(page) {
				// Apply reply
				parseCtx.syraPageModel = page;
				if (_debugProto && _debugProto.debugMode) {
					reply = {
						"sap": {
							"target": {
								"type": "ist",
								"ist": _debugProto.ist
							}
						}
					};
					delete winId.appendModel;
					delete winId.mnu;
				}
				self.processReply(reply, parseCtx);
				// Need to display an other tab than the default one?
				if (winId.scrnNum && winId.scrnNum > 1) {
					self._wndwsStack.showWinTab(loadParams.id, winId.scrnNum);
				}
			}, function(error) {
				_onWinOpenErr(util.getLoadPageErrFromAjax(error, winId.name, self._session), error);
			}, function(representation) {
				// Extend prototype with dynamic model and layout
				var specialWin = sapUtil.isSpecialWin(winId.name),
					winFacet, menuOpts = null;
				if (specialWin && specialWin.id == sapUtil.specialWindow.choose.id && winId.appendModel) {
					// Need to extend choose proto to set choose window list items sent by server... and before must sort list items! 
					self._appendChooseModel(representation, winId.appendModel);
				} else
				if (winId.appendModel) {
					syraUtil.appendProto(syraUtil.get$FromPage(representation), winId.appendModel);
				}
				if (!specialWin || specialWin.id == sapUtil.specialWindow.formula.id) {
					winFacet = loadParams.$facet || syraUtil.mapWinTypeToFacet(representation.$prototype.$x3Facet);
					if (!self._shoulDispWinMagneto(winFacet, reply)) {
						menuOpts = {
							"hideMagneto": true
						};
					}
					self._wndwsStack.setWinMenu(loadParams.id, winFacet, winId["mnu"], (syraUtil.getProtoFromPage(representation) || representation), menuOpts);
				}
			}, winId.stamp.replace(/[:\/\-\s]/g, ""), _onWinOpenErr);
			ret = {
				"brk": true,
				"ok": true
			};
		}
		return ret;
	},

	_stubSetPrevValue: function(params, parseCtx, prev, reply) {
		// Obsolete
		return null;
	},

	_stubActs: function(actions) {
		// Action activation : http://syracuse/w/index.php/Request_Reply_Fusion#sap.acts
		return this._wndwsStack.setActionsState(actions);
	},

	_stubSetWins: function(params, parseCtx, dummy, reply) {
		var ret = null,
			retEx = {}, oldFmtStgBFmt, fmtStg = this.fmtWrapper.formatter.settings;
		if (fmtStg) {
			// Must turn off "skipBadFormat" formatter opt while receiving server datas (Cf.#1110)
			oldFmtStgBFmt = fmtStg.skipBadFormat;
			fmtStg.skipBadFormat = true;
		}
		_.each(params, function(data, winId) {
			retEx[winId] = this._wndwsStack.applyChange(winId, data, this.replyOnPollingMode ? {
				"partialChange": true
			} : null, true, reply);
		}, this);
		_.each(retEx, function(diagnoses, winId) {
			if (diagnoses) {
				// TODO : check return code ==> ret = ...
			}
		}, this);
		if (fmtStg) {
			fmtStg.skipBadFormat = oldFmtStgBFmt;
		}
		return ret;
	},

	_stubSapMisc: function(params) {
		var ret = null,
			retEx = {};
		_.each(params, function(data, typ) {
			if (_sapK.stubMisc[typ]) {
				retEx[typ] = this[_sapK.stubMisc[typ]](data);
			}
		}, this);
		_.each(retEx, function(diagnoses, task) {
			if (diagnoses) {
				// TODO : check return code ==> ret = ...
			}
		}, this);
		return ret;
	},

	_stub4glDiagnoses: function(params) {
		if (params) {
			syraUtil.showDiagnoses(params);
		}
		return null;
	},

	_stubSapCallReply: function(params) {
		return this._ackcallStack.dispatchReply(params);
	},

	_stubSapTarget: function(params, parseCtx, dummy, reply) {
		var status = null,
			callNotify = parseCtx && parseCtx._techReply ? parseCtx._techReply.replyComplete : null;
		this._boxDisplayedInPreviousReply = false;
		if (params.type && _sapK.stubTarget[params.type] && this[_sapK.stubTarget[params.type]]) {
			// First check delayed data binding
			if (this.replyOnPollingMode) {
				this._wndwsStack.delayedDataBinding();
			}
			this.replyOnPollingMode = false;
			// Set target
			status = this[_sapK.stubTarget[params.type]](params[params.type], callNotify, reply, parseCtx);
			if ((!status || !status.notifyCalled) && callNotify) {
				callNotify();
			}
			if (status) {
				delete status.notifyCalled;
				if (!status.hasOwnProperty("ok")) {
					status.ok = true;
				}
			}
			if (callNotify) {
				delete parseCtx._techReply.replyComplete;
			}
		} else {
			status = {
				"ok": false,
				"diagnoses": [util.makeDiagnosis(this._session.getlabel("error", "6", "Unable to set the focus because the target type is not defined in the message server response."), 3, "sap.Controller._stubSapTarget()", "6", util.cltFusionNice)]
			};
		}
		return status;
	},

	stubSapMisc_help: function(params, callback) {
		var topWin = this._wndwsStack.getTopWin(),
			help = [null, null];
		if (params && params.tokens) {
			help[0] = params.tokens.shift();
			help[1] = params.tokens.shift();
		}
		(this.getSiteController()).postHelpRqst("", help[0] || sapUtil.helpHandler.obj.cat, help[1], topWin && topWin.getSyraPage(), null, callback);
		return null;
	},

	_stubSapMisc_openf: function(params) {
		var target = Array.isArray(params.target[0]) ? params.target : [params.target],
			i, len, warn = null,
			self = this,
			appSrv, opts;

		function _openf(protocol, uri, appSrv, delay, options) {
			setTimeout(function() {
				var win, fullUrl;
				if (appSrv !== null) {
					fullUrl = self._session.getAppServerHttpQuery(appSrv, uri, {
						"url": true
					});
				} else {
					if (protocol !== "app") {
						fullUrl = protocol + "://" + uri;
					} else {
						fullUrl = uri;
					}
				}
				win = window.open(fullUrl, "_blank", (options && options.windowFeatures) || undefined);
				if (!win && !warn) {
					warn = self._session.getlabel("error", "70") + "\n" + self._session.getlabel("error", "71");
					syraUtil.showDiagnoses([util.makeDiagnosis(warn, "warning")]);
				} else if (options && options.windowTimeOut && win && win.close) {
					setTimeout(function() {
						win.close();
					}, options.windowTimeOut);
				}
			}, delay);
		}
		for (i = 0, len = target.length; i < len; i++) {
			appSrv = target[i].length > 2 && target[i][2] !== null ? target[i][2] : null;
			opts = target[i].length > 3 && target[i][3];
			_openf(target[i][0], target[i][1], appSrv, !i ? 1 : (i * 400 + 500), opts);
		}
		return null;
	},

	stubSapTarget_ist: function(params, replyCompleteCallback, reply) {
		var ret = null,
			self = this,
			oldIst = util.duplicateObj(this._currCtx.ist),
			dispfmtErrMess = false,
			isEvilInst, field, highlight, unSelRcd;
		if (sapUtil.isGridInst(this._currCtx.ist) && !sapUtil.cmpIstGrid(this._currCtx.ist, params, true)) {
			unSelRcd = !sapUtil.isListScreen(this._currCtx.ist.xid) || sapUtil.isListScreen(params.xid);
		}
		if ((isEvilInst = this._initNewCurrIst(params))) {
			return ret;
		}
		// Check control/format status
		if (params.ctrlFailed && dispfmtErrMess) {
			// Display message
			ret = _dispFmtErrBox(params, self, replyCompleteCallback);
		} else {
			// Set focus on new instance
			if (!params.ctrlFailed && this._isValueChanged(params)) {
				this.forceValue(params, true);
			}
			highlight = _shouldHighlightTarget(reply, params);
			ret = this._wndwsStack.setFocus(params.win, highlight, params.ctrlFailed ? sapUtil.focusStyle.fmtErr.code : sapUtil.focusStyle.std.code, params.xid, params.nl || 1, (params.edit === null || params.edit === undefined ? true : params.edit), params, {
				"prevIst": oldIst
			});
			if (ret && ret.ok && ret.srvAct) {
				if (replyCompleteCallback) {
					replyCompleteCallback();
				}
				setTimeout(function() {
					(self.getSiteController()).postSapRqst(requestActions.getSrvAction(ret.act), ret.params);
				}, 50);
				ret.notifyCalled = true;
			} else
			if (ret && !ret.ok) {
				// TODO....
				ret = {
					"???": "TODO"
				};
			}
			// Traité cas de bouclage sur même instance  : close!
			// + Cas de bouclage dans MF tableau (Cf. code client ligne 2301 de messages.cpp)
		}
		return ret;
	},

	_stubSapTarget_box: function(params, replyCompleteCallback) {
		// Open messageBox : http://syracuse/w/index.php/Request_Reply_Fusion#sap.target.box
		var boxOpts = msgBox.getMsgBoxOpts(params),
			self = this;
		(this.getSiteController()).forceUnlockUI();
		boxOpts.callback = function(resp, closureMode) {
			var data = sapUtil.getObjFieldValue(msgBox.getMsgBoxRet(resp, closureMode, params), sapUtil.fieldModeType.show);
			data.ist = null;
			data.discardCtrl = true;
			if (replyCompleteCallback) {
				replyCompleteCallback();
			}
			self._boxDisplayedInPreviousReply = true;
			(self.getSiteController()).postSapRqst(requestActions.getSrvAction("SRV_CHAMP_SUIVANT"), data);
		};
		setTimeout(function() {
			syra_diagnose.box.show(boxOpts);
		}, 50);
		return {
			"notifyCalled": true
		};
	},

	_stubSapTarget_rpc: function(params, replyCompleteCallback) {
		var self = this,
			nullIst = sapUtil.isNullIst(params.ist),
			errReply, isEvilIst = !nullIst ? this._initNewCurrIst(params.ist) : false,
			obj = null;

		function _ackRpc(result) {
			if (replyCompleteCallback) {
				replyCompleteCallback();
			}
			(self.getSiteController()).postSapRqst(requestActions.getSrvAction("SRV_RESI"), {
				"notModified": true,
				"reply": result
			});
		}

		function _disposeRpc() {
			if (self._rpcCall) {
				self._rpcCall.dispose();
				self._rpcCall = null;
			}
		}
		if (isEvilIst) {
			// Nothing... bypass!
			return null;
		}
		_disposeRpc();
		this._rpcCall = new Rpc.RemoteCall();
		obj = nullIst ? undefined : this._wndwsStack.getBoundField(params.ist.win, params.ist.xid);
		errReply = this._rpcCall.initialize(this, params, obj, _ackRpc);
		if (!errReply) {
			setTimeout(function() {
				var asynCall = self._rpcCall.exec();
				if (!asynCall) {
					_disposeRpc();
				}
			}, 5);
		} else {
			setTimeout(function() {
				_ackRpc(errReply);
				_disposeRpc();
			}, 5);
		}
		return {
			"notifyCalled": true
		};
	},

	_stubSapTarget_askui: function(params, replyCompleteCallback) {
		var self = this,
			winId = this._wndwsStack.getTopWin(false, true),
			ret = {
				"notifyCalled": true
			};
		(this.getSiteController()).forceUnlockUI();

		function ackAskui(status, data) {
			var data = Askui.makeAskuiParam(status, data);
			if (replyCompleteCallback) {
				replyCompleteCallback();
			}
			(self.getSiteController()).postSapRqst(requestActions.getSrvAction("SRV_ASKUI"), data);
		}
		if (this._askuiAccess) {
			this._askuiAccess.dispose();
		}
		this._askuiAccess = new Askui.AskuiStub();
		setTimeout(function() {
			self._askuiAccess.initialize(params.$statement, params.$parameters, ackAskui, self, ++winId);
		}, 10);
		return {
			"notifyCalled": true
		};
	},

	_stubSapTarget_selpr: function(params, replyCompleteCallback) {
		var self = this,
			completeCalled = false,
			winId = this._wndwsStack.getTopWin(false, true),
			ret = {
				"notifyCalled": true
			};
		(this.getSiteController()).forceUnlockUI();

		function ackSelpr(action, result) {
			if (replyCompleteCallback && !completeCalled) {
				completeCalled = true;
				replyCompleteCallback();
			}
			if (action) {
				(self.getSiteController()).postSapRqst(requestActions.getProxyAction(action), {
					"notModified": true,
					"selpr": result
				});
			}
		}
		if (params && params.$diagnoses) {
			this._sapException(null, params.$diagnoses, {
				"typ": "RqstSrv",
				"act": requestActions.getProxyAction(params.$facet == "configPrinter" ? "PRINTER_SEL_CANCEL" : "PRINTER_OPTS_CANCEL"),
				"param": {
					"notModified": true
				}
			}, null, null, replyCompleteCallback);
		} else
		if (params && params.$facet == "configPrinter") {
			if (this._printerAccess && !this._printerAccess.isOnGoing()) {
				this._printerAccess.dispose();
				this._printerAccess = null;
			}
			if (!this._printerAccess) {
				this._printerAccess = new Printer.PrinterAccess();
				setTimeout(function() {
					self._printerAccess.initialize(params, ackSelpr, self, ++winId);
				}, 80);
			} else {
				self._printerAccess.displaySetup(params);
				ret = null;
			}
		} else
		if (params && params.$facet == "morePrinter" && this._printerAccess) {
			setTimeout(function() {
				self._printerAccess.openProperties(params, ackSelpr);
			}, 80);
		} else {
			ret = null;
		}
		return ret;
	},

	_stubSapTarget_plugin: function(params, replyCompleteCallback) {
		var self = this;

		function _ackPlugin(action, response, options) {
			if (replyCompleteCallback) {
				replyCompleteCallback();
			}
			if (options && options.autoRelease) {
				options.autoReleaseParams.method = "delete";
				self._pluginManager.dispatchCommand(options.autoReleaseParams);
			}
			(self.getSiteController()).postSapRqst(requestActions.getProxyAction(action), {
				"notModified": true,
				"plugin": response
			});
		}
		setTimeout(function() {
			self._pluginManager.dispatchCommand(params, _ackPlugin);
		}, 50);
		return {
			"notifyCalled": true
		};
	},

	_stubSapTarget_portal: function(params, replyCompleteCallback, reply, context) {
		var self = this,
			ret = null,
			boxParams, boxOpts;

		function _exec() {
			self._processEndStatement("onSapUIHidden", context);
		}
		if (!params || !params.$diagnoses) {
			_exec();
		} else {
			boxParams = util.diagnosesToOurErrEx(params.$diagnoses);
			msgBox.setMsgBoxDefaultProp(boxParams, 4, 100);
			boxOpts = msgBox.getMsgBoxOpts.call(this, boxParams);
			(this.getSiteController()).forceUnlockUI();
			boxOpts.callback = function(resp, closureMode) {
				msgBox.releaseMsgBoxParams(boxOpts);
				msgBox.releaseBoxParams(boxParams);
				_exec();
				replyCompleteCallback();
			};
			setTimeout(function() {
				syra_diagnose.box.show(boxOpts);
			}, 50);
			ret = {
				"notifyCalled": true
			};
		}
		return ret;
	},

	_stubSapJobs: function(params, parseCtx) {
		var result, i, j, k, ii, len, lenj, lenk, lenii, jobsArray = Object.keys(params),
			jobType, $diag, diagArray, $diagnoses = [],
			status = null,
			severity;
		for (i = 0, len = jobsArray.length; i < len; i++) {
			jobType = jobsArray[i];
			result = (this.getSiteController()).asynchronousJobs.processStatements(jobType, params[jobType]);
			if (result && result.$diagnoses) {
				// Check diagnoses...
				diagArray = Object.keys(result.$diagnoses);
				for (j = 0, lenj = diagArray.length; j < lenj; j++) {
					if (($diag = result.$diagnoses[diagArray[j]]) && $diag.length > 0) {
						// Filter on error
						for (ii = 0, lenii = $diag.length; ii < lenii; ii++) {
							if ($diag[ii] && $diag[ii].length > 0) {
								for (k = 0, lenk = $diag[ii].length; k < lenk; k++) {
									severity = $diag[ii][k].severity || $diag[ii][k].$severity;
									if (util.isErrDiagnosis(severity, true)) {
										$diag[ii][k].$details = "Job : '" + jobType + "', statements :'" + diagArray[j] + "'";
										$diagnoses.push($diag[ii][k]);
									}
								}
							}
						}
					}
				}
			}
		}
		if ($diagnoses.length > 0) {
			// TODO : diplay internal error/warn??? + set 'status'???
		}
		return status;
	},

	_sapException: function(reply, diagnoses, recovery, localContext, messCallback, replyCompleteCallback) {
		var self = this,
			boxOpts, boxParams, logger = this.getlogger(),
			siteCtrl;
		var err7 = syra_fusion.getMessage("9"),
			err8 = syra_fusion.getMessage("10");
		if (this._session) {
			err7 = this._session.getlabel("error", "7", err7);
			err8 = this._session.getlabel("error", "8", err8);
		}
		diagnoses = diagnoses || util.makeDiagnosis(err7, 4, "sap.Controller._sapException()", "7");
		boxParams = util.diagnosesToOurErrEx(diagnoses);
		msgBox.setMsgBoxDefaultProp(boxParams, 4, 180, err8, err7);
		boxOpts = msgBox.getMsgBoxOpts.call(this, boxParams);
		boxOpts.callback = function(resp, closureMode) {
			if (replyCompleteCallback) {
				replyCompleteCallback();
			}
			msgBox.releaseMsgBoxParams(boxOpts);
			msgBox.releaseBoxParams(boxParams);
			if (recovery && recovery.typ) {
				if (messCallback) {
					messCallback();
				}
				self["_sapRecovery" + recovery.typ](reply, recovery);
				return true;
			} else {
				// TODO : Unrecovered error?... how to know if session is always available?         
				return messCallback ? messCallback() : true;
			}
		};
		if (logger) {
			logger.debug({
				"severety": "error"
			}, "Error notification from 'sapController._sapException()'. Stack and diagnoses below :");
			logger.debug({
				"toJson": true
			}, diagnoses);
		}
		if ((siteCtrl = this.getSiteController())) {
			siteCtrl.forceUnlockUI();
		}
		setTimeout(function() {
			syra_diagnose.box.show(boxOpts);
		}, 50);
	},

	_sapRecoveryRqstSrv: function(reply, recovery) {
		if (!recovery.param) {
			recovery.param = {};
		}
		recovery.param.discardCtrl = true;
		(this.getSiteController()).postSapRqst(recovery.act, recovery.param);
	},

	_sapRecoveryDelSess: function(reply, recovery) {
		(this.getSiteController())[recovery.panic ? "onSapCloseEmergency" : "onSapCompleted"]();
	},

	_appendChooseModel: function(winProto, chooseModel) {
		var j, i = 0,
			listProps, listPropsSorted = [],
			listPropsSorted2, listPropsSortedEx = {}, self = this;
		if ((listProps = syraUtil.geChooseLstPropFromProperties(chooseModel))) {
			listPropsSorted = Object.keys(listProps);
			for (j = 0, i = listPropsSorted.length; j < i; j++) {
				listPropsSortedEx[listPropsSorted[j]] = listProps[listPropsSorted[j]];
				delete listProps[listPropsSorted[j]];
			}
			listPropsSorted2 = listPropsSorted.sort(function(left, right) {
				var colIdL = parseInt(sapUtil.getFieldId(left), 10),
					colIdR = parseInt(sapUtil.getFieldId(right), 10);
				return colIdL - colIdR;
			});
			for (j = 0; j < i; j++) {
				listProps[listPropsSorted2[j]] = listPropsSortedEx[listPropsSorted2[j]];
			}
			syraUtil.appendProto(syraUtil.get$FromPage(winProto), chooseModel, function(obj, key, value) {
				self._addChooseProperty(obj, key, value);
			});
		}
	},

	_addChooseProperty: function(obj, key, value) {
		var fmt = null;
		if (key == "tit") {
			obj.$title = value;
		} else
		if (key == "fmt") {
			fmt = new LCSFldFormatter();
			obj.$type = fmt.getSyraTypeFromFormat(value);
			obj.$maxLength = fmt.getMaxLengthFromFormat(value, obj.$type);
			obj.$capabilities = "sort,filter";
		}
	},

	buildAckCallRqst: function(rqst, target, callParams, isFunc) {
		return this._ackcallStack.buildRequest(rqst, target, callParams, isFunc);
	},

	registerLoadedWindow: function(winId, winDef, syraPageModel, initialData) {
		this._wndwsStack.stack(winId, winDef, syraPageModel);
		this._wndwsStack.postBuildInit(winId);
		this._wndwsStack.applyChange(winId, {
			"entities": initialData
		}, null, true);
	},

	isBlockingNodePending: function() {
		// Some protocole nodes (like SELIMP, NDGTDT, ND_ASKUI, etc...) could open special windows, outside standard windows stack/interaction. Then it's necessary to release
		// properly these windows, before to close automatically a session (i.e. on Time-out, logout, etc...), sending proper action/request expected by runtime for these nodes
		var len, i, occur, actRqst = null;
		for (i = 0, len = this._blockingNodesArray.length; i < len; i++) {
			occur = this._blockingNodesArray[i];
			if (this[occur.instance] && this[occur.instance][occur.checkMethod].call(this[occur.instance])) {
				actRqst = {
					"act": occur.action,
					"params": occur.params
				};
				if (this[occur.instance][occur.release]) {
					this[occur.instance][occur.release].call(this[occur.instance]);
				}
				break;
			}
		}
		if (actRqst) {
			if (!actRqst.params) {
				actRqst.params = {};
			}
			actRqst.params.notModified = true;
			actRqst.options = {
				"discardCtrl": true,
				"forceChain": true
			};
		}
		return actRqst;
	},

	stubOfficeExternalCall: function(method) {
		var ret = false;
		if (this["_office" + method]) {
			ret = this["_office" + method].apply(this, Array.prototype.slice.call(arguments, 1));
		} else {
			throw new Error(this._session.getlabel("error", "57", "Unknown method") + " : '" + method + "'.");
		}
		return ret;
	},

	_officeSETLINK: function(id, definition, status, slot) {
		var ret = false,
			winId, page, change = {
				"$links": {}
			}, idEx = "cvgOffice-" + id;
		if (winId = this._wndwsStack.getTopWin(true)) {
			if (page = syraUtil.getPage(this._wndwsStack.getSyraModel(winId))) {
				if (definition) {
					change.$links[idEx] = JSON.parse(definition);
					change.$links[idEx].$confirm = syra_local.installOfficeAddin;
					change.$links[idEx].$officeAddinSetup = require('syracuse-ui/lib/site/tools/officeHelper').officeAddinSetupInstallation;

					page.applyChange(change);
				}
				if (status) {
					change.$links[idEx] = JSON.parse(status);
					page.applyChange(change);
				}
				ret = true;
			}
		}
		return ret;
	},

	dispose: function() {
		if (this._printerAccess) {
			this._printerAccess.dispose();
			this._printerAccess = null;
		}
		if (this._askuiAccess) {
			this._askuiAccess.dispose();
			this._askuiAccess = null;
		}
		if (this._rpcCall) {
			this._rpcCall.dispose();
		}
		if (this._pluginManager) {
			this._pluginManager.dispose();
			this._pluginManager = null;
		}
		if (this._wndwsStack) {
			this._wndwsStack.dispose();
			delete this._wndwsStack;
		}
		if (this._ackcallStack) {
			this._ackcallStack.dispose();
			delete this._ackcallStack;
		}
		if (this._siteController) {
			delete this._siteController;
		}
		if (this._session) {
			delete this._session;
		}
		if (this.fmtWrapper) {
			delete this.fmtWrapper;
		}
		if (!this._sapActivity.stop) {
			this._sapActivity.stop = (new Date()).getTime();
		}
	}
});