"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview X3-Fusion Format and control proxy
 */


var helpers = require('syracuse-core/lib/helpers');
var Formatter = require('syracuse-ui/lib/fusion/core/tools/format').Formatter;
var sapUtil = require('./util').Fusion;
var syraUtil = require('./util').Syra;


function FieldFormatter(){
	this.initialize();
}
exports.FieldFormatter = helpers.defineClass(FieldFormatter, Formatter, {
	getSyraTypeFromFormat: function (format) {
		format = format || this.szFormat;
		var fType = this.getFmtDataType(format), sType = syraUtil.dataTypes.defaultType;
		switch(fType) {
			case this.pTypesC.S_STRG :
				sType = syraUtil.dataTypes.stringType;
				break;
			case this.pTypesC.S_NUM :
				sType = syraUtil.dataTypes.integerType;
				break;
			case this.pTypesC.S_DATE :
				sType = syraUtil.dataTypes.dateType;
				break;
			case this.pTypesC.S_MNL :
				sType = syraUtil.dataTypes.choiceType;
				break;
		}
		return sType;
	},
	setFormat: function (format) {
		var bFormatDisabled = false, bSuccess = false, cutObj = null;
		// Si le nouveau format envoyé est identique à l'existant, ce n'est pas la peine d'aller plus loin.
		if(this.szFormat && this.szFormat === format) {
			return true;
		}
		// Est ce que l'objet dans l'état N-1 était en "disabled"
		if (this.szGlobalCtrl.indexOf(generalOpts.F_DISABLED) >= 0) {
			bFormatDisabled = true;
		}
		// On commence par séparer la chaine en deux parties: les infos générales et les infos sur l'affichage & la saisie
		if (!(cutObj = this._cutFmt (format))) {
			return false;
		}
		// On initialise les champs de type "Format" de la structure de contrôle
		this._initFmt();
		// On enregistre dans la structure le control global	
		this.szGlobalCtrl = cutObj.left;
		this.szAfficCtrl = cutObj.right;
		// On renseigne le type de donnée (chaine, libelle, num...) et les attributs de mise en forme (...)
		bSuccess = this.setTypeAndAttrib(this.szGlobalCtrl);
		// On applique le nouveau format à l'objet
		if (bSuccess) {
			// On enregistre dans la structure le format de contôle reçu
			this.szFormat = format;
			// On étend la chaine de droite si besoin est, comme ceci on est sûr du format étendu (3# ou ###)
			if ((bSuccess = this._expandFmt (cutObj.right))) {
				// On regarde d'abord si il faut rendre le champ visible/invisible
				if(cutObj.isVisible && !this.bIsVisible){
					// TODO
					/*
					ShowWindow(hObjet, SW_SHOW);
					if(psAdxidTarget)
						Label_Show (psAdxidTarget->nAdxid, SW_SHOW);
					*/
				}
				else if(!cutObj.isVisible){
					// TODO
					/*
					ShowWindow(hObjet, SW_HIDE);
					ShowWindow(GetParent(hObjet), SW_HIDE);	// Pas terrible.... // TODO cf Bug 19251
					ShowWindow(GetParent(hObjet), SW_SHOW);
					if(psAdxidTarget)
						Label_Show (psAdxidTarget->nAdxid, SW_HIDE);
					*/
				}
				this.bIsVisible	 = cutObj.isVisible;

				// On contrôle pour la première fois si l'objet contient déjà un élément
				/*if ((GetWindowTextLength (hObjet) > 0)	&& (pStruct->szRealString[0] == (TCHAR)'\0'))
				{
					// On garde alors cette info comme valeure saisie... // il faudrait passer dans le stockage formats internes ...?
					GetWindowText (hObjet, &pStruct->szRealString[0], sizeof(pStruct->szRealString)/TCHARSize);
				}*/
				// Change le style de l'objet (Ils ont été enregistrés dans la structure de contrôle suite à l'appel de "Control_setTypeAndAttrib")
				this._changeAttrib();

				// Control & affichage de la valeur connue (càd ce qu'il y a dans "szRealString")
				if(this.szRealString.length > 0 && !this.bIsNull){
					/*Control_ControlThis (hObjet, FALSE);
					if (hCurrentObject != hObjet)
						Control_PutLongValueBis(hObjet, pStruct);
					*/
				}

				// Si on est multilignes, on vire l'action "Enter"
				/*if (Edit_IsMultiligne(hObjet) || RichEdit_IsMultiligne(hObjet))
				{
					pObjet = Structure_GivePHwndByHwndAndType (hObjet, nType);
					Structure_putAction (pObjet, RETURN, 0, NULL);
				}
				*/

				// Si c'est un format KP : on disabled l'objet
				if (_this.szGlobalCtrl.indexOf(generalOpts.F_DISABLED) >= 0) {
					//Activation_putState (hObjet, nType, DISZO);
				}
				else {
					// Si l'objet avait auparavant un format de type KP : on enable sinon on ne fait rien
					if (bFormatDisabled) {
						//Activation_putState (hObjet, nType, ACTZO);
					}
				}
			}
		}
		return bSuccess;
	},
	_changeAttrib: function(format) {
		var bSuccess = true;
		// On plafonne la longueure de saisie à MAXSTR par défaut, elle sera contrôlée lors du contrôle de saisie
		// Mais si c'est un multiligne, on plafonnera  pour l'instant à 100 lignes de 255 chars
		/*if (Edit_IsMultiligne(hObjet) || RichEdit_IsMultiligne(hObjet))
			SendMessage(hObjet, EM_SETLIMITTEXT, (WPARAM)65000, 0);
		else
			SendMessage(hObjet, EM_SETLIMITTEXT, (WPARAM)MAXSTR, 0);

		// S'il sagit d'un éditeur de RTF, d'un éditeur d'aide ou d'une ligne executable
		if (this._isEditor(){
			// On lui demande de reconnaitre les urls
			SendMessage(hObjet,EM_AUTOURLDETECT,(WPARAM)TRUE,0L);
		}*/
		return bSuccess;
	},
	setNoControlFlag: function (flagVal) {
		this.bNoInputCtrl = bFlagValue;
	}
});