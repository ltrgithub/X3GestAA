"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview X3-Fusion Format and control proxy
 */


var helpers = require('syracuse-core/lib/helpers');
var LegacyCSFormatter = require('syracuse-ui/lib/fusion/core/tools/format').LegacyCSFormatter;
var CvgFormatter = require('syracuse-x3/lib/convergence/types/CvgFormatter').CvgFormatter;
var syraUtil = require('./util').Syra;

var _KdateOrderFlags = 	{"FTM_X3DATE_MDY": 0, "FTM_X3DATE_DMY": 1, "FTM_X3DATE_YMD": 2};


function FormatterWrapper(){
	this._locales = {"datePivot": 1963, "dateSep": "/", "thousandSep": " ", "decimalSep": ".", "timeSep": ":", "dateOrder": "MDY"};
	this._locales.vOn = true;
	this._locales.zOn = false;
	this.settings = {"localCtrl": false, "localFormat": false};
}

exports.FormatterWrapper = helpers.defineClass(FormatterWrapper, null, {
	initialize: function (extendFmt, locales, fmtType) {
		var localeDO, extendFmtArray, j, len, extFmt;
		// Set locales
		if (locales){
			for (var p in locales){
				this._locales[p] = locales[p];
			}
		}
		if ((localeDO = this._locales.dateOrder)) {
			switch (localeDO) {
				case "DMY":
					localeDO = _KdateOrderFlags.FTM_X3DATE_DMY
					break;
				case "YMD":
					localeDO = _KdateOrderFlags.FTM_X3DATE_YMD
					break;
				case "MDY":
				default:
					localeDO = _KdateOrderFlags.FTM_X3DATE_MDY
					break;
			}
		}
		// Create THE formatter
		this._cvgFormatter = new CvgFormatter(this._locales);
		// Extended rules
		if(extendFmt) {
			extendFmtArray = Object.keys(extendFmt);
            for (j = 0, len = extendFmtArray.length; j < len; j++) {
            	extFmt = {"type" : extendFmtArray[j], "subType": extendFmt[extendFmtArray[j]].chars.join(""), "complement": extendFmt[extendFmtArray[j]].stdType.join("")};
				this._cvgFormatter.addDynamicFormat(extFmt);
            }
		}
		return this._cvgFormatter;
	}
});


function LegacyCSFieldFormatter(){
	this.initialize();
}

exports.LegacyCSFieldFormatter = helpers.defineClass(LegacyCSFieldFormatter, LegacyCSFormatter, {
	getSyraTypeFromFormat: function (format) {
		format = format || this.szFormat;
		var fType = this.getFmtDataType(format), sType = syraUtil.dataTypes.defaultType;
		switch(fType) {
			case this.pTypesC.S_STRG :
				sType = syraUtil.dataTypes.stringType;
				break;
			case this.pTypesC.S_NUM :
				sType = syraUtil.dataTypes.integerType;
				break;
			case this.pTypesC.S_DATE :
				sType = syraUtil.dataTypes.dateType;
				break;
			case this.pTypesC.S_MNL :
				sType = syraUtil.dataTypes.choiceType;
				break;
		}
		return sType;
	},
	setFormat: function (format) {
		var bFormatDisabled = false, bSuccess = false, cutObj = null;
		// Si le nouveau format envoyé est identique à l'existant, ce n'est pas la peine d'aller plus loin.
		if(this.szFormat && this.szFormat === format) {
			return true;
		}
		// Est ce que l'objet dans l'état N-1 était en "disabled"
		if (this.szGlobalCtrl.indexOf(generalOpts.F_DISABLED) >= 0) {
			bFormatDisabled = true;
		}
		// On commence par séparer la chaine en deux parties: les infos générales et les infos sur l'affichage & la saisie
		if (!(cutObj = this._cutFmt (format))) {
			return false;
		}
		// On initialise les champs de type "Format" de la structure de contrôle
		this._initFmt();
		// On enregistre dans la structure le control global	
		this.szGlobalCtrl = cutObj.left;
		this.szAfficCtrl = cutObj.right;
		// On renseigne le type de donnée (chaine, libelle, num...) et les attributs de mise en forme (...)
		bSuccess = this.setTypeAndAttrib(this.szGlobalCtrl);
		// On applique le nouveau format à l'objet
		if (bSuccess) {
			// On enregistre dans la structure le format de contôle reçu
			this.szFormat = format;
			// On étend la chaine de droite si besoin est, comme ceci on est sûr du format étendu (3# ou ###)
			if ((bSuccess = this._expandFmt (cutObj.right))) {
				// On regarde d'abord si il faut rendre le champ visible/invisible
				if(cutObj.isVisible && !this.bIsVisible){
					// TODO
					/*
					ShowWindow(hObjet, SW_SHOW);
					if(psAdxidTarget)
						Label_Show (psAdxidTarget->nAdxid, SW_SHOW);
					*/
				}
				else if(!cutObj.isVisible){
					// TODO
					/*
					ShowWindow(hObjet, SW_HIDE);
					ShowWindow(GetParent(hObjet), SW_HIDE);	// Pas terrible.... // TODO cf Bug 19251
					ShowWindow(GetParent(hObjet), SW_SHOW);
					if(psAdxidTarget)
						Label_Show (psAdxidTarget->nAdxid, SW_HIDE);
					*/
				}
				this.bIsVisible	 = cutObj.isVisible;

				// On contrôle pour la première fois si l'objet contient déjà un élément
				/*if ((GetWindowTextLength (hObjet) > 0)	&& (pStruct->szRealString[0] == (TCHAR)'\0'))
				{
					// On garde alors cette info comme valeure saisie... // il faudrait passer dans le stockage formats internes ...?
					GetWindowText (hObjet, &pStruct->szRealString[0], sizeof(pStruct->szRealString)/TCHARSize);
				}*/
				// Change le style de l'objet (Ils ont été enregistrés dans la structure de contrôle suite à l'appel de "Control_setTypeAndAttrib")
				this._changeAttrib();

				// Control & affichage de la valeur connue (càd ce qu'il y a dans "szRealString")
				if(this.szRealString.length > 0 && !this.bIsNull){
					/*Control_ControlThis (hObjet, FALSE);
					if (hCurrentObject != hObjet)
						Control_PutLongValueBis(hObjet, pStruct);
					*/
				}

				// Si on est multilignes, on vire l'action "Enter"
				/*if (Edit_IsMultiligne(hObjet) || RichEdit_IsMultiligne(hObjet))
				{
					pObjet = Structure_GivePHwndByHwndAndType (hObjet, nType);
					Structure_putAction (pObjet, RETURN, 0, NULL);
				}
				*/

				// Si c'est un format KP : on disabled l'objet
				if (_this.szGlobalCtrl.indexOf(generalOpts.F_DISABLED) >= 0) {
					//Activation_putState (hObjet, nType, DISZO);
				}
				else {
					// Si l'objet avait auparavant un format de type KP : on enable sinon on ne fait rien
					if (bFormatDisabled) {
						//Activation_putState (hObjet, nType, ACTZO);
					}
				}
			}
		}
		return bSuccess;
	},
	_changeAttrib: function(format) {
		var bSuccess = true;
		// On plafonne la longueure de saisie à MAXSTR par défaut, elle sera contrôlée lors du contrôle de saisie
		// Mais si c'est un multiligne, on plafonnera  pour l'instant à 100 lignes de 255 chars
		/*if (Edit_IsMultiligne(hObjet) || RichEdit_IsMultiligne(hObjet))
			SendMessage(hObjet, EM_SETLIMITTEXT, (WPARAM)65000, 0);
		else
			SendMessage(hObjet, EM_SETLIMITTEXT, (WPARAM)MAXSTR, 0);

		// S'il sagit d'un éditeur de RTF, d'un éditeur d'aide ou d'une ligne executable
		if (this._isEditor(){
			// On lui demande de reconnaitre les urls
			SendMessage(hObjet,EM_AUTOURLDETECT,(WPARAM)TRUE,0L);
		}*/
		return bSuccess;
	},
	setNoControlFlag: function (flagVal) {
		this.bNoInputCtrl = bFlagValue;
	}
});