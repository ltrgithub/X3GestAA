"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview X3-Fusion Format and control proxy
 */

var helpers = require('syracuse-core/lib/helpers');
var CvgFormatter = require('syracuse-x3/lib/convergence/types/CvgFormatter').CvgFormatter;
var syraUtil = require('./util').Syra;
var sapUtil = require('./util').Fusion;
var util = require('syracuse-ui/lib/fusion/tools/util');

// Misc X3 format constants
var _kDateZero = "15991231";
var _fmtFrame = {
	"F_SEPARATOR": ":",
	"F_ATTRIBBEGIN": "{",
	"F_ATTRIBEND": "}",
	"F_MASKBEGIN": "[",
	"F_MASKEND": "]"
};
var _pTypes = {
	"F_STRG": "K",
	"F_NUM": "N",
	"F_DATE": "D",
	"F_LBL": "L",
	"F_PGBR": "p",
	"F_MNL": "LA"
};
var _dateOrderK = {
	"DMY": 1,
	"YMD": 2,
	"MDY": 0
};
var pSubTypesC = {}, pTypesC = {
		"S_STRG": 1,
		"S_NUM": 2,
		"S_DATE": 3,
		"S_MNL": 4
	};
pSubTypesC[pTypesC.S_NUM] = {
	"X_INT": 0,
	"X_DCB": 1,
	"X_FLOAT": 2
};

// Constants for data type & format control
var _KtypeAcceptFmt = {};
_KtypeAcceptFmt[syraUtil.dataTypes.stringType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.dateType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.integerType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.timeType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.realType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.decType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.passwdType] = false;
var _KtypeAcceptFmtED = {};
_KtypeAcceptFmtED[syraUtil.dataTypes.integerType] = true;
_KtypeAcceptFmtED[syraUtil.dataTypes.realType] = true;
_KtypeAcceptFmtED[syraUtil.dataTypes.decType] = true;
var _KtypeIgnoreFmt2DispIfEmpty = {};
_KtypeIgnoreFmt2DispIfEmpty[syraUtil.dataTypes.dateType] = true;
_KtypeIgnoreFmt2DispIfEmpty[syraUtil.dataTypes.timeType] = true;
_KtypeIgnoreFmt2DispIfEmpty[syraUtil.dataTypes.stringType] = true;


// Formatter Wrapper class
function FormatterWrapper() {
	this.locales = {
		"datePivot": 1963,
		"dateSep": "/",
		"thousandSep": " ",
		"decimalSep": ".",
		"timeSep": ":",
		"dateOrder": _dateOrderK.MDY
	};
	this.locales.vOn = true;
	this.locales.zOn = false;
	this.settings = {};
}

exports.FormatterWrapper = helpers.defineClass(FormatterWrapper, null, {
	svcMapping: {},
	svcFormatterID: {
		"toRaw": "toRaw",
		"toEdit": "toEdit",
		"toDisplay": "toDisp",
		"rawToEdit": "rawToEdit",
		"rawToDisp": "rawToDisp"
	},
	initialize: function(extendFmt, locales, hoster, fmtType, opts) {
		var extendFmtArray, j, len, extFmt, svcId = this.svcFormatterID;
		var defErrMess = "Formatter service error";
		this._hoster = hoster;
		// Set SvcMapping
		this.svcMapping[svcId.toRaw] = {
			"method": "_svcFormatRaw",
			"raw": undefined,
			"errorCode": "63",
			"erroDefLabel": defErrMess
		};
		this.svcMapping[svcId.toDisplay] = {
			"method": "_svcFormatDisp",
			"raw": false,
			"errorCode": "63",
			"erroDefLabel": defErrMess
		};
		this.svcMapping[svcId.toEdit] = {
			"method": "_svcFormatEdit",
			"raw": false,
			"errorCode": "63",
			"erroDefLabel": defErrMess
		};
		this.svcMapping[svcId.rawToEdit] = {
			"method": "_svcFormatEdit",
			"raw": true,
			"errorCode": "63",
			"erroDefLabel": defErrMess
		};
		this.svcMapping[svcId.rawToDisp] = {
			"method": "_svcFormatDisp",
			"raw": true,
			"errorCode": "63",
			"erroDefLabel": defErrMess
		};
		// Set locales
		if (locales) {
			for (var p in locales) {
				this.locales[p] = locales[p];
			}
		}
		// Create THE formatter
		this.formatter = new CvgFormatter(this.locales);
		// Extended rules
		if (extendFmt) {
			extendFmtArray = Object.keys(extendFmt);
			for (j = 0, len = extendFmtArray.length; j < len; j++) {
				extFmt = {
					"type": extendFmtArray[j],
					"subType": extendFmt[extendFmtArray[j]].chars.join(""),
					"complement": extendFmt[extendFmtArray[j]].stdType.join("")
				};
				this.formatter.addDynamicFormat(extFmt);
			}
		}
		// More options settings
		if (opts) {
			if (opts.tracer) {
				this.formatter.settings.tracer = opts.tracer;
			}
		}
		return this.formatter;
	},

	_getMess: function(cat, code, def) {
		return this._hoster && this._hoster.getlabel ? this._hoster.getlabel(cat, code, def) : def || (cat + " message number '" + code + "' not found");
	},

	_makeDiagnosis: function(errCode, defMess, exception) {
		var error = this._getMess("error", errCode, defMess) + (exception && exception.message ? (" : '" + exception.message + "'") : "");
		return util.makeDiagnosis(error, "error", exception ? exception.stack : "", errCode, util.cltFormatterNice);
	},

	dispose: function() {
		delete this._hoster;
		// Should dispose Formatter?
	},

	isTypeAcceptEmptyData: function(type) {
		return _KtypeAcceptFmtED[type];
	},

	isTypeAcceptFmt: function(type) {
		return _KtypeAcceptFmt[type];
	},

	isThickFormat: function(fmt) {
		return fmt && fmt.length > 2;
	},

	rawToDisplay: function(raw, fmt, strict) {
		var output = {
			"succeeded": true,
			"show": raw
		}, oFormatter, type, process = true;
		if (raw != undefined && raw.length == 0) {
			// Empty value management
			oFormatter = new LegacyCSFieldFormatter();
			if (oFormatter && (type = oFormatter.getSyraTypeFromFormat(fmt)) && _KtypeIgnoreFmt2DispIfEmpty[type]) {
				process = false;
			}
		}
		if (process && this.isThickFormat(fmt)) {
			try {
				output.show = this.formatter.formatField(fmt, raw, true, strict);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("63", "Error while formatting value", e)];
			}
		}
		return output;
	},

	rawToEdit: function(raw, fmt) {
		var output = {
			"succeeded": true,
			"edit": raw
		};
		if (this.isThickFormat(fmt) && raw) {
			try {
				output.edit = this.formatter.formatEdit(fmt, raw, true);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("63", "Error while formatting value", e)];
			}
		}
		return output;
	},
	displayToEdit: function(fmt, val) {
		var output = {
			"succeeded": true,
			"edit": val
		};
		if (this.isThickFormat(fmt) && val) {
			try {
				output.edit = this.formatter.formatEdit(fmt, val, false);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("63", "Error while formatting value", e)];
			}
		}
		return output;
	},
	editToDisplay: function(fmt, inputValue, rawValue) {
		var output = {
			"succeeded": true,
			"show": inputValue
		};
		if (this.isThickFormat(fmt)) {
			try {
				output.show = this.formatter.formatEditToDisplay(fmt, inputValue, rawValue);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("64", "Value does not respect format controls", e)];
			}
		}
		return output;
	},

	checkOnFocusOut: function(inputValue, type, fmt, fmtKind, lastRawValue) {
		var output = {
			"raw": inputValue,
			"show": undefined,
			"$diagnoses": null,
			"succeeded": true
		};
		if (_KtypeAcceptFmt[type] && this.isThickFormat(fmt) && inputValue !== null && inputValue.length > 0) {
			// Get "show" value. Should throw a control/format error
			if (fmtKind == sapUtil.fieldModeType.edit) {
				try {
					output.show = this.formatter.formatEditToDisplay(fmt, inputValue, lastRawValue);
				} catch (e) {
					output.succeeded = false;
					output.$diagnoses = [this._makeDiagnosis("64", "Value does not respect format controls", e)];
				}
			} else {
				output.show = inputValue;
			}
			// Get "raw" value
			if (!output.$diagnoses) {
				try {
					output.raw = this.formatter.unformatField(fmt, output.show, true);
					if (type === syraUtil.dateType && output.raw == _kDateZero) {
						output.raw = "";
					}
				} catch (e) {
					output.succeeded = false;
					output.$diagnoses = [this._makeDiagnosis("65", "Error while deformatting value", e)];
				}
			}
		} else {
			output.withoutFmt = true;
		}
		return output;
	},

	unformat: function(inputValue, type, fmt, check) {
		var output = {
			"succeeded": true,
			"raw": inputValue
		};
		if (_KtypeAcceptFmt[type] && this.isThickFormat(fmt) && inputValue !== null && inputValue.length > 0) {
			try {
				output.raw = this.formatter.unformatField(fmt, inputValue, check);
				if (type === syraUtil.dateType && output.raw == _kDateZero) {
					output.raw = "";
				}
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("65", "Error while deformatting value", e)];
			}
		}
		return output;
	},

	formatSvc: function(svcId, value, fmt, type, options) {
		var output = {
			"succeeded": true
		}, error, errCode = "63";
		svcId = svcId || "";
		if (value == null || value == undefined || !this.isThickFormat(fmt)) {
			svcId = "";
		}
		try {
			output.result = this.svcMapping[svcId] ? this[this.svcMapping[svcId].method].call(this, value, fmt, type, this.svcMapping[svcId].raw) : value;
		} catch (e) {
			output.result = null;
			output.succeeded = false;
			output.$diagnoses = [this._makeDiagnosis(this.svcMapping[svcId].errorCode, this.svcMapping[svcId].erroDefLabel, e)];
		}
		return output;
	},

	_svcFormatRaw: function(value, format, type) {
		var checkFlag = type == syraUtil.dataTypes.dateType ? true : false;
		try {
			return this.formatter.unformatField(format, value, checkFlag);
		} catch (e) {}
		// Obviously is not a value compliant with format x3... perhaps a value free typed by user : format/unformat
		var val = this.formatter.formatField(format, value, false);
		return this.formatter.unformatField(format, val, checkFlag);
	},

	_svcFormatDisp: function(val, fmt, type, raw) {
		var strict = true;
		if (!raw) {
			// TODO - Serveur value missing - Must be sent by client
			return this.formatter.formatEditToDisplay(fmt, val);
		} else {
			return this.formatter.formatField(fmt, val, true, strict);
		}
	},

	_svcFormatEdit: function(value, format, type, raw) {
		return this.formatter.formatEdit(format, value, raw);
	}
});


// Legacy Formatter Helper class
function LegacyCSFieldFormatter() {}

exports.LegacyCSFieldFormatter = helpers.defineClass(LegacyCSFieldFormatter, null, {
	getSyraTypeFromFormat: function(format) {
		var fType = this._getFmtDataType(format || this.szFormat),
			sType = syraUtil.dataTypes.defaultType,
			type = fType.t;
		switch (type) {
			case pTypesC.S_STRG:
				sType = syraUtil.dataTypes.stringType;
				break;
			case pTypesC.S_NUM:
				if (fType.st == pSubTypesC[type].X_FLOAT) {
					sType = syraUtil.dataTypes.realType;
				} else if (fType.st == pSubTypesC[type].X_DCB) {
					sType = syraUtil.dataTypes.decType;
				} else {
					sType = syraUtil.dataTypes.integerType;
				}
				break;
			case pTypesC.S_DATE:
				sType = syraUtil.dataTypes.dateType;
				break;
			case pTypesC.S_MNL:
				sType = syraUtil.dataTypes.choiceType;
				break;
		}
		return sType;
	},
	getMaxLengthFromFormat: function(fmt, syraType) {
		var def = 20,
			maxLength, sType = syraType || this.getSyraTypeFromFormat(fmt),
			cut = this._cutFmt(fmt),
			thsdopt = "3",
			splt, matches;

		function _ts(fl) {
			return fl.indexOf(thsdopt) >= 0 ? 4 : 0;
		}
		if (!fmt) {
			return def;
		}
		// Length computed is not accurate... just an aproximation to size the IU control container.
		try {
			switch (sType) {
				case syraUtil.dataTypes.decType:
					// "N3:9.2#"
					maxLength = parseFloat(cut.right, 10);
					if (isNaN(maxLength)) {
						maxLength = 3;
					} else {
						splt = (maxLength.toString()).split(".");
						maxLength = parseInt(splt[0], 10) + (splt.length > 1 ? (parseInt(splt[1], 10) + 1) : 0);
					}
					maxLength += _ts(cut.left);
					break;
				case syraUtil.dataTypes.integerType:
				case syraUtil.dataTypes.realType:
					// "N3:4#" - "N:10F"
					maxLength = parseInt(cut.right, 10) + 1;
					if (isNaN(maxLength)) {
						maxLength = 1;
					}
					maxLength += _ts(cut.left);
					if (syraUtil.dataTypes.realType == sType) {
						maxLength += 6;
					}
					break;
				case syraUtil.dataTypes.stringType:
					// "K:10X", "K:4X[-]4X[-]4X[-]4X[-]" Warning : need to improve masked pattern...
					if (cut.right.indexOf("[") >= 0 && cut.right.indexOf("]") >= 0) {
						maxLength = 0;
						matches = cut.right.match(/(\[.*?\])/g);
						matches.forEach(function(match) {
							maxLength += match.length - 2;
						});
						matches = cut.right.split("]");
						matches.forEach(function(match) {
							var len = match ? parseInt(match, 10) : 0;
							maxLength += (isNaN(len) ? 1 : len);
						});
					} else {
						maxLength = parseInt(cut.right, 10);
						if (isNaN(maxLength)) {
							maxLength = 1;
						}
					}
					break;
				case syraUtil.dataTypes.dateType:
					// "D:DD[/]MM[/]YY"
					maxLength = 11;
					break;
				case syraUtil.dataTypes.choiceType:
					// Arbitrary...
					maxLength = 30;
					break;
				default:
					maxLength = def;
					break;
			}
		} catch (e) {
			maxLength = def;
		}
		return maxLength;
	},
	_getFmtDataType: function(format) {
		var cutFmt, def = {
				"t": pTypesC.S_STRG
			}, st, t;
		if (format && format.length > 0 && (cutFmt = this._cutFmt(format))) {
			if (cutFmt.left.indexOf(_pTypes.F_STRG) >= 0) {
				return {
					"t": pTypesC.S_STRG
				};
			} else if (cutFmt.left.indexOf(_pTypes.F_NUM) >= 0) {
				t = pTypesC.S_NUM;
				st = pSubTypesC[t].X_INT;
				if (cutFmt.right.indexOf('F') >= 0) {
					st = pSubTypesC[t].X_FLOAT;
				} else if (cutFmt.right.indexOf('.') >= 0) {
					st = pSubTypesC[t].X_DCB;
				};
				return {
					"t": t,
					"st": st
				};
			} else if (cutFmt.left.indexOf(_pTypes.F_DATE) >= 0) {
				return {
					"t": pTypesC.S_DATE
				};
			} else if (cutFmt.left.indexOf(_pTypes.F_MNL) >= 0) {
				return {
					"t": pTypesC.S_MNL
				};
			}
		}
		return def;
	},
	_cutFmt: function(format) {
		var i, j = 0,
			ret = {
				"isVisible": true
			}, split;
		split = format.split(_fmtFrame.F_SEPARATOR);
		if (split.length == 0 || split.length < 2) {
			// TODO : throw error
			return null;
		}
		// Check if the separator would be in a comment block
		i = format.indexOf(_fmtFrame.F_SEPARATOR) + 1;
		// Location of the mask separator start
		if (format.indexOf(_fmtFrame.F_MASKBEGIN) >= 0) {
			j = format.indexOf(_fmtFrame.F_MASKBEGIN) + 1;
		}
		// If we find a block separator, it's ko; mask are located after this separator
		if (j > 0 && j < i) {
			// TODO : throw error
			return null;
		}
		// Check if the hidden flag is set
		if (split[0][0] == "-") {
			ret.isVisible = false;
		}
		// Now we delete all the characters before the field notion (included hidden flag)
		i = 0;
		j = split[0].length;
		while (i < j && split[0][i] != _pTypes.F_STRG && split[0][i] != _pTypes.F_NUM && split[0][i] != _pTypes.F_DATE && split[0][i] != _pTypes.F_LBL && split[0][i] != _pTypes.F_PGBR) {
			i++;
		}
		ret.left = split[0].substr(i);
		ret.right = split[1];
		return ret;
	}
});