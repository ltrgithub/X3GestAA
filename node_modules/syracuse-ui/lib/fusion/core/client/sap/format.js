"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview X3-Fusion Format and control proxy
 */

var helpers = require('syracuse-core').helpers;
var CvgFormatter = require('syracuse-x3/lib/convergence/types/CvgFormatter').CvgFormatter;
var syraUtil = require('./util').Syra;

// Misc X3 format constants
var _kDateZero = "15991231";
var _fmtFrame = {
	"F_SEPARATOR": ":",
	"F_ATTRIBBEGIN": "{",
	"F_ATTRIBEND": "}",
	"F_MASKBEGIN": "[",
	"F_MASKEND": "]"
};
var _pTypes = {
	"F_STRG": "K",
	"F_NUM": "N",
	"F_DATE": "D",
	"F_LBL": "L",
	"F_PGBR": "p",
	"F_MNL": "LA"
};
var _dateOrderK = {
	"DMY": 1,
	"YMD": 2,
	"MDY": 0
};
var pSubTypesC = {}, pTypesC = {
		"S_STRG": 1,
		"S_NUM": 2,
		"S_DATE": 3,
		"S_MNL": 4
	};
pSubTypesC[pTypesC.S_NUM] = {
	"X_INT": 0,
	"X_DCB": 1,
	"X_FLOAT": 2
};

// Constants for data type & format control
var _cltFormatterNice = "Format module";
var _KtypeAcceptFmt = {};
var _syraDataTypes = syraUtil.dataTypes;
_KtypeAcceptFmt[_syraDataTypes.stringType] = true;
_KtypeAcceptFmt[_syraDataTypes.dateType] = true;
_KtypeAcceptFmt[_syraDataTypes.integerType] = true;
_KtypeAcceptFmt[_syraDataTypes.timeType] = true;
_KtypeAcceptFmt[_syraDataTypes.realType] = true;
_KtypeAcceptFmt[_syraDataTypes.decType] = true;
_KtypeAcceptFmt[_syraDataTypes.passwdType] = false;
var _KtypeAcceptFmtED = {};
_KtypeAcceptFmtED[_syraDataTypes.integerType] = true;
_KtypeAcceptFmtED[_syraDataTypes.realType] = true;
_KtypeAcceptFmtED[_syraDataTypes.decType] = true;
var _KtypeIgnoreFmt2DispIfEmpty = {};
_KtypeIgnoreFmt2DispIfEmpty[_syraDataTypes.dateType] = true;
_KtypeIgnoreFmt2DispIfEmpty[_syraDataTypes.timeType] = true;
_KtypeIgnoreFmt2DispIfEmpty[_syraDataTypes.stringType] = true;


// Formatter Wrapper class
function FormatterWrapper() {
	this.locales = {
		"datePivot": 1963,
		"dateSep": "/",
		"thousandSep": " ",
		"decimalSep": ".",
		"timeSep": ":",
		"dateOrder": _dateOrderK.MDY
	};
	this.locales.vOn = true;
	this.locales.zOn = false;
	this.settings = {};
}

exports.FormatterWrapper = helpers.defineClass(FormatterWrapper, null, {
	svcMapping: {},
	initialize: function(extendFmt, locales, hoster, fmtType, opts) {
		var extendFmtArray, j, len, extFmt, svcId = this.svcFormatterID;
		var defErrMess = "Formatter service error";
		this._hoster = hoster;
		// Set locales
		if (locales) {
			for (var p in locales) {
				this.locales[p] = locales[p];
			}
		}
		// Create THE formatter
		this.formatter = new CvgFormatter(this.locales);
		// Extended rules
		if (extendFmt) {
			extendFmtArray = Object.keys(extendFmt);
			for (j = 0, len = extendFmtArray.length; j < len; j++) {
				extFmt = {
					"type": extendFmtArray[j],
					"subType": extendFmt[extendFmtArray[j]].chars.join(""),
					"complement": extendFmt[extendFmtArray[j]].stdType.join("")
				};
				this.formatter.addDynamicFormat(extFmt);
			}
		}
		// More options settings
		if (opts) {
			if (opts.tracer) {
				this.formatter.settings.tracer = opts.tracer;
			}
			this.fieldModeTypesK = opts.fieldModeTypesK;
		}
		return this.formatter;
	},

	_getMess: function(cat, code, def) {
		return this._hoster && this._hoster.getlabel ? this._hoster.getlabel(cat, code, def) : def || (cat + " message number '" + code + "' not found");
	},

	_makeDiagnosis: function(errCode, defMess, exception) {
		var error = this._getMess("error", errCode, defMess) + (exception && exception.message ? (" : '" + exception.message + "'") : "");
		if (this._hoster && this._hoster.makeDiagnosis)
			return this._hoster.makeDiagnosis(error, "error", exception ? exception.stack : "", errCode, _cltFormatterNice);
		else {
			return {
				"$message": error,
				"$severity": "error",
				"$stackTrace": exception ? exception.stack : ""
			};
		}
	},

	dispose: function() {
		delete this._hoster;
		// Should dispose Formatter?
	},

	isTypeAcceptEmptyData: function(type) {
		return _KtypeAcceptFmtED[type];
	},

	isTypeAcceptFmt: function(type) {
		return _KtypeAcceptFmt[type];
	},

	isThickFormat: function(fmt) {
		return fmt && fmt.length > 2;
	},
	getSyraTypeFromFormat: function(format) {
		var fType = _getFmtDataType(format),
			sType = _syraDataTypes.defaultType,
			type = fType.t;
		switch (type) {
			case pTypesC.S_STRG:
				sType = _syraDataTypes.stringType;
				break;
			case pTypesC.S_NUM:
				if (fType.st == pSubTypesC[type].X_FLOAT) {
					sType = _syraDataTypes.realType;
				} else if (fType.st == pSubTypesC[type].X_DCB) {
					sType = _syraDataTypes.decType;
				} else {
					sType = _syraDataTypes.integerType;
				}
				break;
			case pTypesC.S_DATE:
				sType = _syraDataTypes.dateType;
				break;
			case pTypesC.S_MNL:
				sType = _syraDataTypes.choiceType;
				break;
		}
		return sType;
	},
	getMaxLengthFromFormat: function(fmt, syraType) {
		var def = 20,
			maxLength, sType = syraType || this.getSyraTypeFromFormat(fmt),
			cut = _cutFmt(fmt),
			thsdopt = "3",
			splt, matches;

		function _ts(fl) {
			return fl.indexOf(thsdopt) >= 0 ? 4 : 0;
		}
		if (!fmt) {
			return def;
		}
		// Length computed is not accurate... just an aproximation to size the IU control container.
		try {
			switch (sType) {
				case _syraDataTypes.decType:
					// "N3:9.2#"
					maxLength = parseFloat(cut.right, 10);
					if (isNaN(maxLength)) {
						maxLength = 3;
					} else {
						splt = (maxLength.toString()).split(".");
						maxLength = parseInt(splt[0], 10) + (splt.length > 1 ? (parseInt(splt[1], 10) + 1) : 0);
					}
					maxLength += _ts(cut.left);
					break;
				case _syraDataTypes.integerType:
				case _syraDataTypes.realType:
					// "N3:4#" - "N:10F"
					maxLength = parseInt(cut.right, 10) + 1;
					if (isNaN(maxLength)) {
						maxLength = 1;
					}
					maxLength += _ts(cut.left);
					if (_syraDataTypes.realType == sType) {
						maxLength += 6;
					}
					break;
				case _syraDataTypes.stringType:
					// "K:10X", "K:4X[-]4X[-]4X[-]4X[-]" Warning : need to improve masked pattern...
					if (cut.right.indexOf("[") >= 0 && cut.right.indexOf("]") >= 0) {
						maxLength = 0;
						matches = cut.right.match(/(\[.*?\])/g);
						matches.forEach(function(match) {
							maxLength += match.length - 2;
						});
						matches = cut.right.split("]");
						matches.forEach(function(match) {
							var len = match ? parseInt(match, 10) : 0;
							maxLength += (isNaN(len) ? 1 : len);
						});
					} else {
						maxLength = parseInt(cut.right, 10);
						if (isNaN(maxLength)) {
							maxLength = 1;
						}
					}
					break;
				case _syraDataTypes.dateType:
					// "D:DD[/]MM[/]YY"
					maxLength = 11;
					break;
				case _syraDataTypes.choiceType:
					// Arbitrary...
					maxLength = 30;
					break;
				default:
					maxLength = def;
					break;
			}
		} catch (e) {
			maxLength = def;
		}
		return maxLength;
	},
	rawToDisplay: function(raw, fmt, strict) {
		var output = {
			"succeeded": true,
			"show": raw
		}, type, process = true;
		if (raw != undefined && raw.length == 0) {
			// Empty value management
			if ((type = this.getSyraTypeFromFormat(fmt)) && _KtypeIgnoreFmt2DispIfEmpty[type]) {
				process = false;
			}
		}
		if (process && this.isThickFormat(fmt)) {
			try {
				output.show = this.formatter.formatField(fmt, raw, true, strict);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("63", "Error while formatting value", e)];
			}
		}
		return output;
	},
	rawToEdit: function(raw, fmt) {
		var output = {
			"succeeded": true,
			"edit": raw
		};
		if (this.isThickFormat(fmt) && raw) {
			try {
				output.edit = this.formatter.formatEdit(fmt, raw, true);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("63", "Error while formatting value", e)];
			}
		}
		return output;
	},
	displayToEdit: function(fmt, val) {
		var output = {
			"succeeded": true,
			"edit": val
		};
		if (this.isThickFormat(fmt) && val) {
			try {
				output.edit = this.formatter.formatEdit(fmt, val, false);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("63", "Error while formatting value", e)];
			}
		}
		return output;
	},
	editToDisplay: function(fmt, inputValue, rawValue) {
		var output = {
			"succeeded": true,
			"show": inputValue
		};
		if (this.isThickFormat(fmt)) {
			try {
				output.show = this.formatter.formatEditToDisplay(fmt, inputValue, rawValue);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this._makeDiagnosis("64", "Value does not respect format controls", e)];
			}
		}
		return output;
	},
	checkOnFocusOut: function(inputValue, type, fmt, fmtKind, lastRawValue) {
		var output = {
			"raw": inputValue,
			"show": undefined,
			"$diagnoses": null,
			"succeeded": true
		};
		if (_KtypeAcceptFmt[type] && this.isThickFormat(fmt) && inputValue !== null && inputValue.length > 0) {
			// Get "show" value. Should throw a control/format error
			if ((this.fieldModeTypesK && fmtKind == this.fieldModeTypesK.edit) || fmtKind == "EDIT") {
				try {
					output.show = this.formatter.formatEditToDisplay(fmt, inputValue, lastRawValue);
				} catch (e) {
					output.succeeded = false;
					output.$diagnoses = [this._makeDiagnosis("64", "Value does not respect format controls", e)];
				}
			} else {
				output.show = inputValue;
			}
			// Get "raw" value
			if (!output.$diagnoses) {
				try {
					output.raw = this.formatter.unformatField(fmt, output.show, true);
					if (type === _syraDataTypes.dateType && output.raw == _kDateZero) {
						output.raw = "";
					}
				} catch (e) {
					output.succeeded = false;
					output.$diagnoses = [this._makeDiagnosis("65", "Error while deformatting value", e)];
				}
			}
		} else {
			output.withoutFmt = true;
		}
		return output;
	},
	unformat: function(inputValue, type, fmt, check) {
		var output = {
			"succeeded": true,
			"raw": inputValue
		};
		var val, formatted = false;
		if (_KtypeAcceptFmt[type] && this.isThickFormat(fmt) && inputValue !== null && inputValue.length > 0) {
			try {
				output.raw = this.formatter.unformatField(fmt, inputValue, check);
				formatted = true;
			} catch (e) {
				// Obviously is not a value compliant with format x3... perhaps a value free typed by user : format/unformat
				try {
					val = this.formatter.formatField(fmt, inputValue, false);
					output.raw = this.formatter.unformatField(fmt, val, check);
					formatted = true;
				} catch (e) {
					output.succeeded = false;
					output.$diagnoses = [this._makeDiagnosis("65", "Error while deformatting value", e)];
				}
			}
		}
		if (formatted && type === _syraDataTypes.dateType && output.raw == _kDateZero) {
			output.raw = "";
		}
		return output;
	},
	format: function(fmt, value, raw, strict) {
		return this.formatter.formatField(fmt, value, raw, strict);
	}
});


// Utilities
function _getFmtDataType(format) {
	var cutFmt, def = {
			"t": pTypesC.S_STRG
		}, st, t;
	if (format && format.length > 0 && (cutFmt = _cutFmt(format))) {
		if (cutFmt.left.indexOf(_pTypes.F_STRG) >= 0) {
			return {
				"t": pTypesC.S_STRG
			};
		} else if (cutFmt.left.indexOf(_pTypes.F_NUM) >= 0) {
			t = pTypesC.S_NUM;
			st = pSubTypesC[t].X_INT;
			if (cutFmt.right.indexOf('F') >= 0) {
				st = pSubTypesC[t].X_FLOAT;
			} else if (cutFmt.right.indexOf('.') >= 0) {
				st = pSubTypesC[t].X_DCB;
			};
			return {
				"t": t,
				"st": st
			};
		} else if (cutFmt.left.indexOf(_pTypes.F_DATE) >= 0) {
			return {
				"t": pTypesC.S_DATE
			};
		} else if (cutFmt.left.indexOf(_pTypes.F_MNL) >= 0) {
			return {
				"t": pTypesC.S_MNL
			};
		}
	}

	return def;
}

function _cutFmt(format) {
	var i, j = 0,
		ret = {
			"isVisible": true
		}, split;
	split = format.split(_fmtFrame.F_SEPARATOR);
	if (split.length == 0 || split.length < 2) {
		// TODO : throw error
		return null;
	}
	// Check if the separator would be in a comment block
	i = format.indexOf(_fmtFrame.F_SEPARATOR) + 1;
	// Location of the mask separator start
	if (format.indexOf(_fmtFrame.F_MASKBEGIN) >= 0) {
		j = format.indexOf(_fmtFrame.F_MASKBEGIN) + 1;
	}
	// If we find a block separator, it's ko; mask are located after this separator
	if (j > 0 && j < i) {
		// TODO : throw error
		return null;
	}
	// Check if the hidden flag is set
	if (split[0][0] == "-") {
		ret.isVisible = false;
	}
	// Now we delete all the characters before the field notion (included hidden flag)
	i = 0;
	j = split[0].length;
	while (i < j && split[0][i] != _pTypes.F_STRG && split[0][i] != _pTypes.F_NUM && split[0][i] != _pTypes.F_DATE && split[0][i] != _pTypes.F_LBL && split[0][i] != _pTypes.F_PGBR) {
		i++;
	}
	ret.left = split[0].substr(i);
	ret.right = split[1];

	return ret;
}