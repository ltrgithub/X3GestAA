"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview X3-Fusion Format and control proxy
 */


var helpers = require('syracuse-core/lib/helpers');
var LegacyCSFormat = require('syracuse-ui/lib/fusion/core/tools/format');
var CvgFormatter = require('syracuse-x3/lib/convergence/types/CvgFormatter').CvgFormatter;
var syraUtil = require('./util').Syra;
var util = require('syracuse-ui/lib/fusion/tools/util');

var _kDateZero = "15991231";
var _KdateOrderFlags = {"DMY": 0, "YMD": 1, "MDY": 2};
var _KtypeAcceptFmt = {};
_KtypeAcceptFmt[syraUtil.dataTypes.stringType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.dateType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.integerType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.timeType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.realType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.decType] = true;


function FormatterWrapper(){
	this._locales = {"datePivot": 1963, "dateSep": "/", "thousandSep": " ", "decimalSep": ".", "timeSep": ":", "dateOrder": "MDY"};
	this._locales.vOn = true;
	this._locales.zOn = false;
	this.settings = {"localCtrl": false, "localFormat": false};
}

exports.FormatterWrapper = helpers.defineClass(FormatterWrapper, null, {
	svcMapping: {},

	initialize: function (extendFmt, locales, hoster, fmtType) {
		var localeDO, extendFmtArray, j, len, extFmt, svcId = LegacyCSFormat.svcFormatter.fmtSvc;
		this._hoster = hoster;
		// Set SvcMapping
		this.svcMapping[svcId.toRaw] = {"method": "formatRaw", "raw": undefined};
		this.svcMapping[svcId.toDisplay] = {"method": "formatDisp", "raw": false};
		this.svcMapping[svcId.toEdit] = {"method": "formatEdit", "raw": false};
		this.svcMapping[svcId.rawToEdit] = {"method": "formatEdit", "raw": true};
		this.svcMapping[svcId.rawToDisp] = {"method": "formatDisp", "raw": true};
		// Set locales
		if (locales){
			for (var p in locales){
				this._locales[p] = locales[p];
			}
		}
		if ((localeDO = this._locales.dateOrder)) {
			localeDO = _KdateOrderFlags.hasOwnProperty(localeDO) ? _KdateOrderFlags[localeDO] : _KdateOrderFlags.MDY;
		}
		// Create THE formatter
		this._formatter = new CvgFormatter(this._locales);
		// Extended rules
		if(extendFmt) {
			extendFmtArray = Object.keys(extendFmt);
            for (j = 0, len = extendFmtArray.length; j < len; j++) {
            	extFmt = {"type" : extendFmtArray[j], "subType": extendFmt[extendFmtArray[j]].chars.join(""), "complement": extendFmt[extendFmtArray[j]].stdType.join("")};
				this._formatter.addDynamicFormat(extFmt);
            }
		}
		return this._formatter;
	},

	getMess: function(cat, code, def) {
		return this._hoster && this._hoster.getlabel ? this._hoster.getlabel(cat, code, def) : def || (cat + " message number '" + code + "' not found");
	},

	makeDiagnosis: function(errCode, defMess, exception) {
		var error = this.getMess("error", errCode, defMess) + (exception && exception.message ? (" : '" + exception.message + "'") : "");
        return util.makeDiagnosis(error, "error", exception ? exception.stack : "", errCode, util.cltFormatterNice);
	},

	dispose: function() {
		delete this._hoster;
		// Should dispose Formatter?
	},

	_isThickFormat: function(fmt) {
		return fmt && fmt.length > 2;
	},

	checkOnFocusOut: function(inputValue, type, fmt, fmtKind, lastRawValue) {
		var output = {"raw": inputValue, "show": undefined, "$diagnoses": null, "succeeded": true}, format = {"format": fmt};
		if (_KtypeAcceptFmt[type] && this._isThickFormat(fmt) && inputValue !== null && inputValue.length > 0) {
			// Get "show" value. Should throw a control/format error
			if (fmtKind == 'EDIT') {
				try {
					output.show = this._formatter.formatEditToDisplay(format, inputValue, lastRawValue);
				}
				catch(e) {
					output.succeeded = false;
					output.$diagnoses = [this.makeDiagnosis("64", "Value does not respect format controls", e)];
				}
			}
			// Get "raw" value
			if(!output.$diagnoses) {
				try {
					output.raw = this._formatter.unformatField(format, output.show, true);
					if(type === syraUtil.dateType && output.raw == _kDateZero) {
					  output.raw = "";
					}
				}
				catch(e) {
					output.succeeded = false;
					output.$diagnoses = [this.makeDiagnosis("65", "Error while deformatting value", e)];
				}
			}
		}
		else {
			output.withoutFmt = true;
		}
		return output;
	},

	formatSvc: function (svcId, input, options) {
        var output = {"succeeded": true}, fmt, error, errCode = "63";
        if(!input) {
            input = {"svc": ""};
        }
        svcId = svcId || "";
        if(input.value == null || input.value == undefined || !this._isThickFormat(input.fmt)) {
            svcId = "";
        }
        fmt = {"format": input.fmt};
        try {
        	output.result = this.svcMapping[svcId] ? this[this.svcMapping[svcId].method].call(this, input.value, fmt, input.typ, this.svcMapping[svcId].raw) : input.value;
        }
        catch (e) {
            output.result = null;
            output.succeeded = false;
            output.$diagnoses = [this.makeDiagnosis("63", "Formatter service error", e)];
        }
        return output;
	},

	formatRaw: function(value, format, type) {
		try {
			return this._formatter.unformatField(format, value);
		}
		catch (e) {
		}
		// Obviously is not a value compliant with format x3... perhaps a value free typed by user : format/unformat
		var val = this._formatter.formatField(format, value, false);
		return this._formatter.unformatField(format, val);
	},

	formatDisp: function(val, fmt, type, raw) {
		var strict = true;
		if (!raw) {
			try {
				// If it's a formatted value, then "unformat" and return raw value
				var r = this._formatter.unformatField(fmt, val);
				return this._formatter.formatField(fmt, r, true, strict);
			}
			catch (e) {
			}
			// It's not a formatted value... perhaps a typed free value
			return this._formatter.formatField(fmt, val, false, strict);
		}
		else {
			return this._formatter.formatField(fmt, val, true, strict);
		}
	},

	formatEdit: function(value, format, type, raw) {
		return this._formatter.formatEdit(format, value, raw);
	}
});


function LegacyCSFieldFormatter(){
	this.initialize();
}

exports.LegacyCSFieldFormatter = helpers.defineClass(LegacyCSFieldFormatter, LegacyCSFormat.LegacyCSFormatter, {
	getSyraTypeFromFormat: function (format) {
		format = format || this.szFormat;
		var fType = this.getFmtDataType(format), sType = syraUtil.dataTypes.defaultType;
		switch(fType) {
			case this.pTypesC.S_STRG :
				sType = syraUtil.dataTypes.stringType;
				break;
			case this.pTypesC.S_NUM :
				sType = syraUtil.dataTypes.integerType;
				break;
			case this.pTypesC.S_DATE :
				sType = syraUtil.dataTypes.dateType;
				break;
			case this.pTypesC.S_MNL :
				sType = syraUtil.dataTypes.choiceType;
				break;
		}
		return sType;
	},
	setFormat: function (format) {
		var bFormatDisabled = false, bSuccess = false, cutObj = null;
		// Si le nouveau format envoyé est identique à l'existant, ce n'est pas la peine d'aller plus loin.
		if(this.szFormat && this.szFormat === format) {
			return true;
		}
		// Est ce que l'objet dans l'état N-1 était en "disabled"
		if (this.szGlobalCtrl.indexOf(generalOpts.F_DISABLED) >= 0) {
			bFormatDisabled = true;
		}
		// On commence par séparer la chaine en deux parties: les infos générales et les infos sur l'affichage & la saisie
		if (!(cutObj = this._cutFmt (format))) {
			return false;
		}
		// On initialise les champs de type "Format" de la structure de contrôle
		this._initFmt();
		// On enregistre dans la structure le control global	
		this.szGlobalCtrl = cutObj.left;
		this.szAfficCtrl = cutObj.right;
		// On renseigne le type de donnée (chaine, libelle, num...) et les attributs de mise en forme (...)
		bSuccess = this.setTypeAndAttrib(this.szGlobalCtrl);
		// On applique le nouveau format à l'objet
		if (bSuccess) {
			// On enregistre dans la structure le format de contôle reçu
			this.szFormat = format;
			// On étend la chaine de droite si besoin est, comme ceci on est sûr du format étendu (3# ou ###)
			if ((bSuccess = this._expandFmt (cutObj.right))) {
				// On regarde d'abord si il faut rendre le champ visible/invisible
				if(cutObj.isVisible && !this.bIsVisible){
					// TODO
					/*
					ShowWindow(hObjet, SW_SHOW);
					if(psAdxidTarget)
						Label_Show (psAdxidTarget->nAdxid, SW_SHOW);
					*/
				}
				else if(!cutObj.isVisible){
					// TODO
					/*
					ShowWindow(hObjet, SW_HIDE);
					ShowWindow(GetParent(hObjet), SW_HIDE);	// Pas terrible.... // TODO cf Bug 19251
					ShowWindow(GetParent(hObjet), SW_SHOW);
					if(psAdxidTarget)
						Label_Show (psAdxidTarget->nAdxid, SW_HIDE);
					*/
				}
				this.bIsVisible	 = cutObj.isVisible;

				// On contrôle pour la première fois si l'objet contient déjà un élément
				/*if ((GetWindowTextLength (hObjet) > 0)	&& (pStruct->szRealString[0] == (TCHAR)'\0'))
				{
					// On garde alors cette info comme valeure saisie... // il faudrait passer dans le stockage formats internes ...?
					GetWindowText (hObjet, &pStruct->szRealString[0], sizeof(pStruct->szRealString)/TCHARSize);
				}*/
				// Change le style de l'objet (Ils ont été enregistrés dans la structure de contrôle suite à l'appel de "Control_setTypeAndAttrib")
				this._changeAttrib();

				// Control & affichage de la valeur connue (càd ce qu'il y a dans "szRealString")
				if(this.szRealString.length > 0 && !this.bIsNull){
					/*Control_ControlThis (hObjet, FALSE);
					if (hCurrentObject != hObjet)
						Control_PutLongValueBis(hObjet, pStruct);
					*/
				}

				// Si on est multilignes, on vire l'action "Enter"
				/*if (Edit_IsMultiligne(hObjet) || RichEdit_IsMultiligne(hObjet))
				{
					pObjet = Structure_GivePHwndByHwndAndType (hObjet, nType);
					Structure_putAction (pObjet, RETURN, 0, NULL);
				}
				*/

				// Si c'est un format KP : on disabled l'objet
				if (_this.szGlobalCtrl.indexOf(generalOpts.F_DISABLED) >= 0) {
					//Activation_putState (hObjet, nType, DISZO);
				}
				else {
					// Si l'objet avait auparavant un format de type KP : on enable sinon on ne fait rien
					if (bFormatDisabled) {
						//Activation_putState (hObjet, nType, ACTZO);
					}
				}
			}
		}
		return bSuccess;
	},
	_changeAttrib: function(format) {
		var bSuccess = true;
		// On plafonne la longueure de saisie à MAXSTR par défaut, elle sera contrôlée lors du contrôle de saisie
		// Mais si c'est un multiligne, on plafonnera  pour l'instant à 100 lignes de 255 chars
		/*if (Edit_IsMultiligne(hObjet) || RichEdit_IsMultiligne(hObjet))
			SendMessage(hObjet, EM_SETLIMITTEXT, (WPARAM)65000, 0);
		else
			SendMessage(hObjet, EM_SETLIMITTEXT, (WPARAM)MAXSTR, 0);

		// S'il sagit d'un éditeur de RTF, d'un éditeur d'aide ou d'une ligne executable
		if (this._isEditor(){
			// On lui demande de reconnaitre les urls
			SendMessage(hObjet,EM_AUTOURLDETECT,(WPARAM)TRUE,0L);
		}*/
		return bSuccess;
	},
	setNoControlFlag: function (flagVal) {
		this.bNoInputCtrl = bFlagValue;
	}
});