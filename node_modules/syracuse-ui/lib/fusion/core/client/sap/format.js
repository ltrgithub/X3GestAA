"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview X3-Fusion Format and control proxy
 */

var helpers = require('syracuse-core/lib/helpers');
var LegacyCSFormat = require('syracuse-ui/lib/fusion/core/tools/format');
var CvgFormatter = require('syracuse-x3/lib/convergence/types/CvgFormatter').CvgFormatter;
var syraUtil = require('./util').Syra;
var util = require('syracuse-ui/lib/fusion/tools/util');

var _kDateZero = "15991231";
var _KdateOrderFlags = {
	"DMY": 1,
	"YMD": 2,
	"MDY": 0
};
var _KtypeAcceptFmt = {};
_KtypeAcceptFmt[syraUtil.dataTypes.stringType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.dateType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.integerType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.timeType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.realType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.decType] = true;
_KtypeAcceptFmt[syraUtil.dataTypes.passwdType] = false;
exports.isTypeAcceptFmt = _KtypeAcceptFmt;
var _KtypeAcceptFmtED = {};
_KtypeAcceptFmtED[syraUtil.dataTypes.integerType] = true;
_KtypeAcceptFmtED[syraUtil.dataTypes.realType] = true;
_KtypeAcceptFmtED[syraUtil.dataTypes.decType] = true;
exports.isTypeAcceptFmtED = _KtypeAcceptFmtED;
exports.dateOrderK = _KdateOrderFlags;

function FormatterWrapper() {
	this.locales = {
		"datePivot": 1963,
		"dateSep": "/",
		"thousandSep": " ",
		"decimalSep": ".",
		"timeSep": ":",
		"dateOrder": _KdateOrderFlags.MDY
	};
	this.locales.vOn = true;
	this.locales.zOn = false;
	this.settings = {};
}

exports.FormatterWrapper = helpers.defineClass(FormatterWrapper, null, {
	svcMapping: {},

	initialize: function(extendFmt, locales, hoster, fmtType, opts) {
		var extendFmtArray, j, len, extFmt, svcId = LegacyCSFormat.svcFormatter.fmtSvc;
		this._hoster = hoster;
		// Set SvcMapping
		this.svcMapping[svcId.toRaw] = {
			"method": "_svcFormatRaw",
			"raw": undefined
		};
		this.svcMapping[svcId.toDisplay] = {
			"method": "_svcFormatDisp",
			"raw": false
		};
		this.svcMapping[svcId.toEdit] = {
			"method": "_svcFormatEdit",
			"raw": false
		};
		this.svcMapping[svcId.rawToEdit] = {
			"method": "_svcFormatEdit",
			"raw": true
		};
		this.svcMapping[svcId.rawToDisp] = {
			"method": "_svcFormatDisp",
			"raw": true
		};
		// Set locales
		if (locales) {
			for (var p in locales) {
				this.locales[p] = locales[p];
			}
		}
		// Create THE formatter
		this.formatter = new CvgFormatter(this.locales);
		// Extended rules
		if (extendFmt) {
			extendFmtArray = Object.keys(extendFmt);
			for (j = 0, len = extendFmtArray.length; j < len; j++) {
				extFmt = {
					"type": extendFmtArray[j],
					"subType": extendFmt[extendFmtArray[j]].chars.join(""),
					"complement": extendFmt[extendFmtArray[j]].stdType.join("")
				};
				this.formatter.addDynamicFormat(extFmt);
			}
		}
		// More options settings
		if (opts) {
			if (opts.tracer) {
				this.formatter.settings.tracer = opts.tracer;
			}
		}
		return this.formatter;
	},

	getMess: function(cat, code, def) {
		return this._hoster && this._hoster.getlabel ? this._hoster.getlabel(cat, code, def) : def || (cat + " message number '" + code + "' not found");
	},

	makeDiagnosis: function(errCode, defMess, exception) {
		var error = this.getMess("error", errCode, defMess) + (exception && exception.message ? (" : '" + exception.message + "'") : "");
		return util.makeDiagnosis(error, "error", exception ? exception.stack : "", errCode, util.cltFormatterNice);
	},

	dispose: function() {
		delete this._hoster;
		// Should dispose Formatter?
	},

	isThickFormat: function(fmt) {
		return fmt && fmt.length > 2;
	},

	rawToDisplay: function(raw, fmt, strict) {
		var output = {
			"succeeded": true,
			"show": raw
		};
		if (this.isThickFormat(fmt)) {
			try {
				output.show = this.formatter.formatField({
					"format": fmt
				}, raw, true, strict);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this.makeDiagnosis("63", "Error while formatting value", e)];
			}
		}
		return output;
	},

	rawToEdit: function(raw, fmt) {
		var output = {
			"succeeded": true,
			"edit": raw
		};
		if (this.isThickFormat(fmt) && raw) {
			try {
				output.edit = this.formatter.formatEdit({
					"format": fmt
				}, raw, true);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this.makeDiagnosis("63", "Error while formatting value", e)];
			}
		}
		return output;
	},

	editToDisplay: function(fmt, inputValue, rawValue) {
		var output = {
			"succeeded": true,
			"show": inputValue
		};
		if (this.isThickFormat(fmt)) {
			try {
				output.show = this.formatter.formatEditToDisplay({
					"format": fmt
				}, inputValue, rawValue);
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this.makeDiagnosis("64", "Value does not respect format controls", e)];
			}
		}
		return output;
	},

	checkOnFocusOut: function(inputValue, type, fmt, fmtKind, lastRawValue) {
		var output = {
			"raw": inputValue,
			"show": undefined,
			"$diagnoses": null,
			"succeeded": true
		}, format;
		if (_KtypeAcceptFmt[type] && this.isThickFormat(fmt) && inputValue !== null && inputValue.length > 0) {
			// Get "show" value. Should throw a control/format error
			format = {
				"format": fmt
			};
			if (fmtKind == 'EDIT') {
				try {
					output.show = this.formatter.formatEditToDisplay(format, inputValue, lastRawValue);
				} catch (e) {
					output.succeeded = false;
					output.$diagnoses = [this.makeDiagnosis("64", "Value does not respect format controls", e)];
				}
			}
			// Get "raw" value
			if (!output.$diagnoses) {
				try {
					output.raw = this.formatter.unformatField(format, output.show, true);
					if (type === syraUtil.dateType && output.raw == _kDateZero) {
						output.raw = "";
					}
				} catch (e) {
					output.succeeded = false;
					output.$diagnoses = [this.makeDiagnosis("65", "Error while deformatting value", e)];
				}
			}
		} else {
			output.withoutFmt = true;
		}
		return output;
	},

	unformat: function(inputValue, type, fmt, check) {
		var output = {
			"succeeded": true,
			"raw": inputValue
		}, format;
		if (_KtypeAcceptFmt[type] && this.isThickFormat(fmt) && inputValue !== null && inputValue.length > 0) {
			format = {
				"format": fmt
			};
			try {
				output.raw = this.formatter.unformatField(format, inputValue, check);
				if (type === syraUtil.dateType && output.raw == _kDateZero) {
					output.raw = "";
				}
			} catch (e) {
				output.succeeded = false;
				output.$diagnoses = [this.makeDiagnosis("65", "Error while deformatting value", e)];
			}
		}
		return output;
	},

	formatSvc: function(svcId, input, options) {
		var output = {
			"succeeded": true
		}, fmt, error, errCode = "63";
		if (!input) {
			input = {
				"svc": ""
			};
		}
		svcId = svcId || "";
		if (input.value == null || input.value == undefined || !this.isThickFormat(input.fmt)) {
			svcId = "";
		}
		fmt = {
			"format": input.fmt
		};
		try {
			output.result = this.svcMapping[svcId] ? this[this.svcMapping[svcId].method].call(this, input.value, fmt, input.typ, this.svcMapping[svcId].raw) : input.value;
		} catch (e) {
			output.result = null;
			output.succeeded = false;
			output.$diagnoses = [this.makeDiagnosis("63", "Formatter service error", e)];
		}
		return output;
	},

	_svcFormatRaw: function(value, format, type) {
		try {
			return this.formatter.unformatField(format, value);
		} catch (e) {}
		// Obviously is not a value compliant with format x3... perhaps a value free typed by user : format/unformat
		var val = this.formatter.formatField(format, value, false);
		return this.formatter.unformatField(format, val);
	},

	_svcFormatDisp: function(val, fmt, type, raw) {
		var strict = true;
		if (!raw) {
			// TODO - Serveur value missing - Must be sent by client
			return this.formatter.formatEditToDisplay(fmt, val);
		} else {
			return this.formatter.formatField(fmt, val, true, strict);
		}
	},

	_svcFormatEdit: function(value, format, type, raw) {
		return this.formatter.formatEdit(format, value, raw);
	}
});

function LegacyCSFieldFormatter() {
	this.initialize();
}

exports.LegacyCSFieldFormatter = helpers.defineClass(LegacyCSFieldFormatter, LegacyCSFormat.LegacyCSFormatter, {
	getSyraTypeFromFormat: function(format) {
		var fType = this.getFmtDataType(format || this.szFormat),
			sType = syraUtil.dataTypes.defaultType,
			type = fType.t;
		switch (type) {
			case this.pTypesC.S_STRG:
				sType = syraUtil.dataTypes.stringType;
				break;
			case this.pTypesC.S_NUM:
				if (fType.st == this.pSubTypesC[type].X_FLOAT) {
					sType = syraUtil.dataTypes.realType;
				} else if (fType.st == this.pSubTypesC[type].X_DCB) {
					sType = syraUtil.dataTypes.decType;
				} else {
					sType = syraUtil.dataTypes.integerType;
				}
				break;
			case this.pTypesC.S_DATE:
				sType = syraUtil.dataTypes.dateType;
				break;
			case this.pTypesC.S_MNL:
				sType = syraUtil.dataTypes.choiceType;
				break;
		}
		return sType;
	},
	getMaxLengthFromFormat: function(fmt, syraType) {
		var def = 20,
			maxLength, sType = syraType || this.getSyraTypeFromFormat(fmt),
			cut = this._cutFmt(fmt),
			thsdopt = "3",
			splt, matches;

		function _ts(fl) {
			return fl.indexOf(thsdopt) >= 0 ? 4 : 0;
		}
		if (!fmt) {
			return def;
		}
		// Length computed is not accurate... just an aproximation to size the IU control container.
		try {
			switch (sType) {
				case syraUtil.dataTypes.decType:
					// "N3:9.2#"
					maxLength = parseFloat(cut.right, 10);
					if (isNaN(maxLength)) {
						maxLength = 3;
					} else {
						splt = (maxLength.toString()).split(".");
						maxLength = parseInt(splt[0], 10) + (splt.length > 1 ? (parseInt(splt[1], 10) + 1) : 0);
					}
					maxLength += _ts(cut.left);
					break;
				case syraUtil.dataTypes.integerType:
				case syraUtil.dataTypes.realType:
					// "N3:4#" - "N:10F"
					maxLength = parseInt(cut.right, 10) + 1;
					if (isNaN(maxLength)) {
						maxLength = 1;
					}
					maxLength += _ts(cut.left);
					if (syraUtil.dataTypes.realType == sType) {
						maxLength += 6;
					}
					break;
				case syraUtil.dataTypes.stringType:
					// "K:10X", "K:4X[-]4X[-]4X[-]4X[-]" Warning : need to improve masked pattern...
					if (cut.right.indexOf("[") >= 0 && cut.right.indexOf("]") >= 0) {
						maxLength = 0;
						matches = cut.right.match(/(\[.*?\])/g);
						matches.forEach(function(match) {
							maxLength += match.length - 2;
						});
						matches = cut.right.split("]");
						matches.forEach(function(match) {
							var len = match ? parseInt(match, 10) : 0;
							maxLength += (isNaN(len) ? 1 : len);
						});
					} else {
						maxLength = parseInt(cut.right, 10);
						if (isNaN(maxLength)) {
							maxLength = 1;
						}
					}
					break;
				case syraUtil.dataTypes.dateType:
					// "D:DD[/]MM/"YY"
					maxLength = 11;
					break;
				case syraUtil.dataTypes.choiceType:
					// Arbitrary...
					maxLength = 30;
					break;
				default:
					maxLength = def;
					break;
			}
		} catch (e) {
			maxLength = def;
		}
		return maxLength;
	},
	setFormat: function(format) {
		var bFormatDisabled = false,
			bSuccess = false,
			cutObj = null;
		// Si le nouveau format envoyé est identique à l'existant, ce n'est pas la peine d'aller plus loin.
		if (this.szFormat && this.szFormat === format) {
			return true;
		}
		// Est ce que l'objet dans l'état N-1 était en "disabled"
		if (this.szGlobalCtrl.indexOf(generalOpts.F_DISABLED) >= 0) {
			bFormatDisabled = true;
		}
		// On commence par séparer la chaine en deux parties: les infos générales et les infos sur l'affichage & la saisie
		if (!(cutObj = this._cutFmt(format))) {
			return false;
		}
		// On initialise les champs de type "Format" de la structure de contrôle
		this._initFmt();
		// On enregistre dans la structure le control global	
		this.szGlobalCtrl = cutObj.left;
		this.szAfficCtrl = cutObj.right;
		// On renseigne le type de donnée (chaine, libelle, num...) et les attributs de mise en forme (...)
		bSuccess = this.setTypeAndAttrib(this.szGlobalCtrl);
		// On applique le nouveau format à l'objet
		if (bSuccess) {
			// On enregistre dans la structure le format de contôle reçu
			this.szFormat = format;
			// On étend la chaine de droite si besoin est, comme ceci on est sûr du format étendu (3# ou ###)
			if ((bSuccess = this._expandFmt(cutObj.right))) {
				// On regarde d'abord si il faut rendre le champ visible/invisible
				if (cutObj.isVisible && !this.bIsVisible) {
					// TODO
					/*
					ShowWindow(hObjet, SW_SHOW);
					if(psAdxidTarget)
						Label_Show (psAdxidTarget->nAdxid, SW_SHOW);
					*/
				} else if (!cutObj.isVisible) {
					// TODO
					/*
					ShowWindow(hObjet, SW_HIDE);
					ShowWindow(GetParent(hObjet), SW_HIDE);	// Pas terrible.... // TODO cf Bug 19251
					ShowWindow(GetParent(hObjet), SW_SHOW);
					if(psAdxidTarget)
						Label_Show (psAdxidTarget->nAdxid, SW_HIDE);
					*/
				}
				this.bIsVisible = cutObj.isVisible;

				// On contrôle pour la première fois si l'objet contient déjà un élément
				/*if ((GetWindowTextLength (hObjet) > 0)	&& (pStruct->szRealString[0] == (TCHAR)'\0'))
				{
					// On garde alors cette info comme valeure saisie... // il faudrait passer dans le stockage formats internes ...?
					GetWindowText (hObjet, &pStruct->szRealString[0], sizeof(pStruct->szRealString)/TCHARSize);
				}*/
				// Change le style de l'objet (Ils ont été enregistrés dans la structure de contrôle suite à l'appel de "Control_setTypeAndAttrib")
				this._changeAttrib();

				// Control & affichage de la valeur connue (càd ce qu'il y a dans "szRealString")
				if (this.szRealString.length > 0 && !this.bIsNull) {
					/*Control_ControlThis (hObjet, FALSE);
					if (hCurrentObject != hObjet)
						Control_PutLongValueBis(hObjet, pStruct);
					*/
				}

				// Si on est multilignes, on vire l'action "Enter"
				/*if (Edit_IsMultiligne(hObjet) || RichEdit_IsMultiligne(hObjet))
				{
					pObjet = Structure_GivePHwndByHwndAndType (hObjet, nType);
					Structure_putAction (pObjet, RETURN, 0, NULL);
				}
				*/

				// Si c'est un format KP : on disabled l'objet
				if (_this.szGlobalCtrl.indexOf(generalOpts.F_DISABLED) >= 0) {
					//Activation_putState (hObjet, nType, DISZO);
				} else {
					// Si l'objet avait auparavant un format de type KP : on enable sinon on ne fait rien
					if (bFormatDisabled) {
						//Activation_putState (hObjet, nType, ACTZO);
					}
				}
			}
		}
		return bSuccess;
	},
	_changeAttrib: function(format) {
		var bSuccess = true;
		// On plafonne la longueure de saisie à MAXSTR par défaut, elle sera contrôlée lors du contrôle de saisie
		// Mais si c'est un multiligne, on plafonnera  pour l'instant à 100 lignes de 255 chars
		/*if (Edit_IsMultiligne(hObjet) || RichEdit_IsMultiligne(hObjet))
			SendMessage(hObjet, EM_SETLIMITTEXT, (WPARAM)65000, 0);
		else
			SendMessage(hObjet, EM_SETLIMITTEXT, (WPARAM)MAXSTR, 0);

		// S'il sagit d'un éditeur de RTF, d'un éditeur d'aide ou d'une ligne executable
		if (this._isEditor(){
			// On lui demande de reconnaitre les urls
			SendMessage(hObjet,EM_AUTOURLDETECT,(WPARAM)TRUE,0L);
		}*/
		return bSuccess;
	},
	setNoControlFlag: function(flagVal) {
		this.bNoInputCtrl = bFlagValue;
	}
});