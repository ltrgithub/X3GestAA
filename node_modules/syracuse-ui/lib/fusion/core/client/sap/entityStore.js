"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Entity dataset store Class
 */

 
var helpers = require('syracuse-core/lib/helpers');
var util = require('syracuse-ui/lib/fusion/tools/util');
var sapUtil = require('./util').Fusion;
var syraUtil = require('./util').Syra;


var _datasetK = {
    "metaGridRules" : {
        "sty": {"gridScope": true, "lineScope": true, "purge": true},
        "tit": {"gridScope": false, "lineScope": false, "purge": true},
        "stt": {"gridScope": true, "lineScope": true, "purge": true},
        "fmt": {"gridScope": false, "lineScope": false, "purge": true},
        "dch": {"gridScope": false, "lineScope": false, "purge": true}
    }
};


/* Entity Store class */
function EntityStore(){
}

exports.EntityStore = helpers.defineClass(EntityStore, null, {
    initialize: function(internalType, isCollection){
        this._isColl = isCollection;
        this.$type = internalType;
        if(isCollection) {
            this.data = [];
            this.meta = {};
            _.each(_datasetK.metaGridRules, function(rule, metaType) {
                this[metaType] = [];
            }, this.meta);
            this._$empty = true;
            this._$frag = false;
        }
        else {
            this.data = {};            
        }
    },

    applyMvt: function(mvt, start, count){
        var result = {"mvtData": [], "isDelta": true}, i, bAtEnd, len = this.data.length;
        // Update data
        if(mvt == sapUtil.dataSetMvt.delAll) {
            // TODO : Optimisation => raz des donnÃ©es doit marcher; refaire le map si ne marche pas (Cf. "setDataBind" de list.js)
            result.mvtData = []; //_.map(this.data, function(rcd){return {"$uuid": rcd.$uuid};});
            result.isDelta = false;
            result.delAll = true;
            this._$frag = false;
            this._$empty = true;
            delete this.data;
            this.data = [];
        }
        else if (mvt == sapUtil.dataSetMvt.del) {
            bAtEnd = (start - 1) + count >= len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1; i < start - 1 + count; i++) {
                if(len > i) {
                    result.mvtData.push({"$uuid": this.data[i].$uuid, "$isDeleted": true});
                }
            }
            this.data.splice (start - 1, count);
            result.mvtMeta = bAtEnd ? null : [mvt, start - 1, count];
        }
        else if (!this._$empty){
            // So, insert in a filled collection
            bAtEnd = start > len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1; i < start - 1 + count; i++) {
                this.data.splice (i, 0, {"$uuid": this._$frag ? helpers.uuid.generate() : this.data.length});
            }
            result.mvtData = this.data.slice(start - 1, start - 1 + count);
            result.mvtMeta = [mvt, start - 1, count];
        }
        // Cleanup meta data
        this._cleanupMetaColl(mvt, start, count, this._$empty || start >= this.data.length);

        return result;
    },

    storeDataColl: function(newData, commit){
        var isDelta = false, i;
        if(!commit) {
            return this._$empty ? false : true;
        }
        if(this._$empty) {
            this.data = util.duplicateObj(newData);
        }
        else {
            isDelta = true;
            _.each(newData, function(rcd, idx){
                i = rcd.$uuid;
                if(this._$frag) {
                    delete rcd.$uuid;
                }
                _.extend(this.data[i], rcd);
                rcd.$index = rcd.$uuid;
                rcd.$uuid = this.data[i].$uuid;
            }, this);
        }
        this._$empty = false;

        return isDelta;
    },

    storeMetaColl: function(newMeta){
        var found, gridInst, i, len;
        _.each(newMeta, function(newMetaColl, type){
            if(this.meta[type].length > 0) {
                _.each(newMetaColl, function(newMeta){
                    // Clean-up old metas
                    gridInst = sapUtil.isBlockInst(newMeta[0]);
                    if(_datasetK.metaGridRules[type].gridScope && (gridInst && newMeta[1] == 0)) {
                        // If grid Scope : purge All
                        delete this.meta[type];
                        this.meta[type] = [];
                    }
                    else if(_datasetK.metaGridRules[type].purge) {
                        // Avoid to apply same meta twice!
                        found = util.arrayFind(this.meta[type], function(metaStored) {
                            return metaStored[0] == newMeta[0] && metaStored[1] == newMeta[1] && metaStored[2] == newMeta[2] ? true : false;
                        });
                        if(found >= 0) {
                           this.meta[type].splice(found, 1);
                        }
                    }
                    if(this.meta[type].length > 0 && !gridInst && newMeta[1] == 0) {
                        // If column scope : purge all cells impacted for this column
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                           if(this.meta[type][i][0] == newMeta[0]) {
                               this.meta[type].splice(i, 1);
                           }
                        }
                   }
                   else if(this.meta[type].length > 0 && gridInst && _datasetK.metaGridRules[type].lineScope && newMeta[1] > 0) {
                        // If line scope : purge all cells impacted
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                           if(this.meta[type][i][1] == newMeta[1]) {
                               this.meta[type].splice(i, 1);
                           }
                        }  
                   }
                   // Store new meta
                   this.meta[type].push(newMeta);
                }, this);
            }
            else {
                this.meta[type] = util.duplicateObj(newMetaColl);
            }
        }, this);       
    },

    _cleanupMetaColl: function(mvt, start, count, insertAtEnd){
        var i, len;
        _.each(this.meta, function(metaColl, type){
            if((len = metaColl.length) > 0) {
                for (i = len - 1; i >= 0; i--) {
                    if(mvt == sapUtil.dataSetMvt.delAll && metaColl[i][1] > 0 ) {
                        // Remove all none "grid" or "column" scope meta on raz
                        metaColl.splice(i, 1);    
                    }
                    else if (mvt == sapUtil.dataSetMvt.del && metaColl[i][1] > 0) {
                        // Modify or delete old "line/cell" scope metas, according to delete range
                        if(metaColl[i][1] >= start && metaColl[i][1] < start + count) {
                            metaColl.splice(i, 1);
                        }
                        else if( metaColl[i][1] >= start + count) {
                            metaColl[i][1] -= count;
                        }
                    }
                    else if(mvt == sapUtil.dataSetMvt.insrt && metaColl[i][1] > start && !insertAtEnd) {
                        // Modify old "line/cell" scope metas, according to insert range
                        metaColl[i][1] += count;
                    }
                }
            }
        }, this);
    },

    dispose: function(){
        delete this.data;
        delete this.meta;
    }
});