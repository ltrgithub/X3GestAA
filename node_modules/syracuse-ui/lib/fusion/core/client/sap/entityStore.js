"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Entity dataset store Class
 */

 
var helpers = require('syracuse-core/lib/helpers');
var util = require('syracuse-ui/lib/fusion/tools/util');
var sapUtil = require('./util').Fusion;
var syraUtil = require('./util').Syra;


var _datasetK = {
    "metaGridRules" : {
        "sty": {"gridScope": true, "lineScope": true, "purge": true},
        "tit": {"gridScope": false, "lineScope": false, "purge": true},
        "stt": {"gridScope": true, "lineScope": true, "purge": true},
        "fmt": {"gridScope": false, "lineScope": false, "purge": true},
        "dch": {"gridScope": false, "lineScope": false, "purge": true}
    }
};


function _updateCollOneByOne (nLenColl, nbMvt) {
    var ratio = 10, threshold = 15;
    //With "$isFullDelta" mode, is not longer necessary to apply change record by record ==> TODO : remove
    //return !!(nbMvt <= Math.ceil(nLenColl/ratio) && nbMvt <= threshold);
    return false;
}
function _getMvtCollCode (mvt) {
    return mvt[0] == sapUtil.dataSetMvt.del ? (mvt.length == 1 ? sapUtil.dataSetMvt.delAll : sapUtil.dataSetMvt.del) : sapUtil.dataSetMvt.insrt;
}

function _razIndexPropr (data) {
    // To remove... but for now how the Syra framework add "$index" while processing records... it's nessasry to clean-up
    if(data.length > 0 && data[0].hasOwnProperty("$index")) {
        _.each(data, function(value) {
            delete value.$index;
        });
    }
}


/* Entity Store class */
function EntityStore(){
}

exports.EntityStore = helpers.defineClass(EntityStore, null, {
    initialize: function(internalType, isCollection){
        this._isColl = isCollection;
        this.$type = internalType;
        if(isCollection) {
            this.data = [];
            this.meta = {};
            _.each(_datasetK.metaGridRules, function(rule, metaType) {
                this[metaType] = [];
            }, this.meta);
            this._$empty = true;
            this._$frag = false;
        }
        else {
            this.data = {};            
        }
    },

    _fillTemplateColl: function(options) {
        var coll = [];
        for (var i = 0, ii = this.data.length; i < ii; i++){
            coll[i] = {"$uuid": this.data[i].$uuid};
        }
        return coll;
    },

    applyDataCollEx: function(entityName, data, commit, options, callback){
        var isEmpty, ruptInsrt = null, nbMvt = data.$mvt ? data.$mvt.length : 0, i = nbMvt - 1, j, nbInsrt = 0, delta, updated = false, oneByOne;
        var leftListColl = options && options.lf, collMvt = null, fullUpdate, syraElapse = {"data": 0, "mvt": 0};
        if(i >= 0 && data.$mvt[i][0] == sapUtil.dataSetMvt.insrt) {
            ruptInsrt = i;
            nbInsrt = data.$mvt[i][2];
        }
        ruptInsrt = ruptInsrt !== null ? ruptInsrt : nbMvt;
        if(ruptInsrt > 0) {
            // First, apply batch movements if any (del, insert or del all)
            for (j = 0; j < ruptInsrt; j++){
                oneByOne = data.$mvt[j].length > 2 ? _updateCollOneByOne(this.data.length, data.$mvt[j][2]) : false;
                syraElapse.mvt += this.applyCollMvt(entityName, data.$mvt[j], oneByOne, options, callback);
            }
        }
        if(nbInsrt > 0) {
            // Second, process last batch insert if any
            if (!(isEmpty = this._$empty) &&_updateCollOneByOne(this.data.length, nbInsrt)){
                // Optimized mode for the insert movements
                syraElapse.mvt += this.applyCollMvt(entityName, data.$mvt[ruptInsrt], true, options, callback);
            }
            else {
                // Full update : insert movements + data (with optimization for left list)
                delta = leftListColl ? {} : this.applyMvt(_getMvtCollCode(data.$mvt[ruptInsrt]), data.$mvt[ruptInsrt][1], data.$mvt[ruptInsrt][2]);
                if(data.$rcd && !leftListColl) {
                    this.storeDataColl(data.$rcd, commit);
                    collMvt = this.data;
                    if(this.data.length != data.$rcd.length) {
                        _.each(data.$rcd, function(rcd, idx){
                            if(delta.uuidInserted.hasOwnProperty(rcd.$uuid)) {
                                delete delta.uuidInserted[rcd.$uuid];
                            }
                        });
                        _.each(delta.uuidInserted, function(value, key) {
                            data.$rcd.push(delta.mvtData[value]);
                        });
                        collMvt = this.data.length === data.$rcd.length ? this.data : data.$rcd;
                    }
                }
                collMvt = !collMvt ? (data.$rcd || delta.mvtData) : collMvt;
                fullUpdate = leftListColl || collMvt.length == this.data.length || collMvt.length == 1 ? false : true;
                syraElapse.data += callback(collMvt, {"$isFullDelta": fullUpdate});
                _razIndexPropr(this.data);
                updated = true;
            }
        }
        if (data.$rcd && !updated)  {
            // Finally updata data if necessary
            if(this.storeDataColl(data.$rcd, commit) && !leftListColl && data.$rcd.length !== this.data.length) {
                // By delta
                syraElapse.data += callback(data.$rcd, {"$isFullDelta": data.$rcd.length > 1 ? true : false});
            }
            else {
                // Full
                syraElapse.data += callback(leftListColl ? data.$rcd : this.data, {"$isFullDelta": false});
            }
            _razIndexPropr(this.data);
        }
        return syraElapse;
    },

    applyCollMvt: function(entityName, mvt, oneByOne, options, callback){
        var mvtCode = _getMvtCollCode(mvt), delta, lenCollBefore = this.data.length, lenCollAfter, collMvt, isDelta, syraElapse = 0, fullDelta = true;
        // Init
        if(mvtCode == sapUtil.dataSetMvt.del && !oneByOne && lenCollBefore -  mvt[2] > 1) {
            //Obsolete
            //collMvt = this._fillTemplateColl();
        }
        // Apply dataset mvt
        delta = this.applyMvt(mvtCode, mvt[1], mvt[2]);
        lenCollAfter = this.data.length;
        // Bind
        if(mvtCode === sapUtil.dataSetMvt.delAll || (lenCollAfter === 0 && mvtCode === sapUtil.dataSetMvt.del)) {
            syraElapse += callback([], {"$isFullDelta": false});
        }
        else if(lenCollAfter == 1 && mvtCode == sapUtil.dataSetMvt.del) {
            // Optimisation in Syracuse protocole...
            delete this.data[0].$index;
            syraElapse += callback([this.data[0]], {"$isFullDelta": false});
        }
        else {
            if(oneByOne) {
                _.each(delta.mvtData, function (rcd) {
                    syraElapse += callback([rcd], {"$isFullDelta": false});
                });
            }
            else {
                collMvt = delta.mvtData;
                if (mvtCode == sapUtil.dataSetMvt.insrt) {
                    // Obsolete
                    /*collMvt = this._fillTemplateColl();
                    _.each(delta.mvtData, function (rcd) {
                        collMvt[rcd.$index] = rcd;
                        //delete collMvt[rcd.$index].$index;
                    });*/
                    if(delta.isEmpty) {
                        collMvt = this.data;
                        fullDelta = false;
                    }
                }
                syraElapse += callback(collMvt, {"$isFullDelta": fullDelta});
                if(!fullDelta) {
                    _razIndexPropr(this.data);
                }
           }
        }
        return syraElapse; 
    },

    applyMvt: function(mvt, start, count){
        var result = {"mvtData": [], "isDelta": true, "isEmpty": false, "uuidInserted": {}}, i, j, bAtEnd, len = this.data.length, _uuid;
        // Update data
        if(mvt == sapUtil.dataSetMvt.delAll) {
            result.mvtData = [];
            result.isDelta = false;
            result.delAll = true;
            this._$frag = false;
            this._$empty = true;
            delete this.data;
            this.data = [];
        }
        else if (mvt == sapUtil.dataSetMvt.del) {
            bAtEnd = (start - 1) + count >= len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1; i < start - 1 + count; i++) {
                if(len > i) {
                    this.data[i].$isDeleted = true;
                }
            }
            result.mvtData = this.data.splice (start - 1, count);
            result.mvtMeta = bAtEnd ? null : [mvt, start - 1, count];
        }
        else {
            // So, insert ...
            this._$empty = false;
            bAtEnd = start > len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1, j = 0; i < start - 1 + count; i++) {
                _uuid = this._$frag ? helpers.uuid.generate() : this.data.length;
                this.data.splice (i, 0, {"$uuid": _uuid});
                result.mvtData.push({"$uuid": _uuid, "$index": i});
                result.uuidInserted[_uuid] = j++;
            }
            result.mvtMeta = [mvt, start - 1, count];
        }
        result.isEmpty = this._$empty;
        // Cleanup meta data
        this._cleanupMetaColl(mvt, start, count, this._$empty || start >= this.data.length);

        return result;
    },

    storeDataColl: function(newData, commit){
        var isDelta = false, i;
        if(!commit) {
            return !this._$empty;
        }
        if(this._$empty) {
            this.data = util.duplicateObj(newData);
        }
        else {
            isDelta = true;
            _.each(newData, function(rcd, idx){
                i = rcd.$uuid;
                delete rcd.$uuid;
                for (var prop in rcd) {
                     this.data[i][prop] = rcd[prop];
                }
                rcd.$index = i;
                rcd.$uuid = this.data[i].$uuid;
            }, this);
        }
        this._$empty = false;
        return isDelta;
    },

    storeMetaColl: function(newMeta){
        var found, gridInst, i, len;
        _.each(newMeta, function(newMetaColl, type){
            if(this.meta[type].length > 0) {
                _.each(newMetaColl, function(newMeta){
                    // Clean-up old metas
                    gridInst = sapUtil.isBlockInst(newMeta[0]);
                    if(_datasetK.metaGridRules[type].gridScope && (gridInst && newMeta[1] == 0)) {
                        // If grid Scope : purge All
                        delete this.meta[type];
                        this.meta[type] = [];
                    }
                    else if(_datasetK.metaGridRules[type].purge) {
                        // Avoid to apply same meta twice!
                        found = util.arrayFind(this.meta[type], function(metaStored) {
                            return metaStored[0] == newMeta[0] && metaStored[1] == newMeta[1] && metaStored[2] == newMeta[2] ? true : false;
                        });
                        if(found >= 0) {
                           this.meta[type].splice(found, 1);
                        }
                    }
                    if(this.meta[type].length > 0 && !gridInst && newMeta[1] == 0) {
                        // If column scope : purge all cells impacted for this column
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                           if(this.meta[type][i][0] == newMeta[0]) {
                               this.meta[type].splice(i, 1);
                           }
                        }
                   }
                   else if(this.meta[type].length > 0 && gridInst && _datasetK.metaGridRules[type].lineScope && newMeta[1] > 0) {
                        // If line scope : purge all cells impacted
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                           if(this.meta[type][i][1] == newMeta[1]) {
                               this.meta[type].splice(i, 1);
                           }
                        }  
                   }
                   // Store new meta
                   this.meta[type].push(newMeta);
                }, this);
            }
            else {
                this.meta[type] = util.duplicateObj(newMetaColl);
            }
        }, this);       
    },

    _cleanupMetaColl: function(mvt, start, count, insertAtEnd){
        var i, len;
        _.each(this.meta, function(metaColl, type){
            if((len = metaColl.length) > 0) {
                for (i = len - 1; i >= 0; i--) {
                    if(mvt == sapUtil.dataSetMvt.delAll && metaColl[i][1] > 0 ) {
                        // Remove all none "grid" or "column" scope meta on raz
                        metaColl.splice(i, 1);    
                    }
                    else if (mvt == sapUtil.dataSetMvt.del && metaColl[i][1] > 0) {
                        // Modify or delete old "line/cell" scope metas, according to delete range
                        if(metaColl[i][1] >= start && metaColl[i][1] < start + count) {
                            metaColl.splice(i, 1);
                        }
                        else if( metaColl[i][1] >= start + count) {
                            metaColl[i][1] -= count;
                        }
                    }
                    else if(mvt == sapUtil.dataSetMvt.insrt && metaColl[i][1] > start && !insertAtEnd) {
                        // Modify old "line/cell" scope metas, according to insert range
                        metaColl[i][1] += count;
                    }
                }
            }
        }, this);
    },

    dispose: function(){
        delete this.data;
        delete this.meta;
    }
});