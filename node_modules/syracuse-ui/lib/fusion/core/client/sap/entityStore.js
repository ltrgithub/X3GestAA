"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Entity dataset store Class
 */
var helpers = require('syracuse-core/lib/helpers');
var util = require('syracuse-ui/lib/fusion/tools/util');
var sapUtil = require('./util').Fusion;
var syraUtil = require('./util').Syra;
var formatter = require('syracuse-ui/lib/fusion/core/client/sap/format');
var KisTypeAcceptFmt = formatter.isTypeAcceptFmt;
var KisTypeAcceptFmtED = formatter.isTypeAcceptFmtED;

var _datasetK = {
	"metaType": {
		"style": "sty",
		"title": "tit",
		"state": "stt",
		"format": "fmt",
		"dchoise": "dch"
	},
	"metaGridRules": {}
};
_datasetK.metaGridRules[_datasetK.metaType.style] = {
	"gridScope": true,
	"lineScope": true,
	"purge": true
};
_datasetK.metaGridRules[_datasetK.metaType.title] = {
	"gridScope": false,
	"lineScope": false,
	"purge": true
};
_datasetK.metaGridRules[_datasetK.metaType.state] = {
	"gridScope": true,
	"lineScope": true,
	"purge": true
};
_datasetK.metaGridRules[_datasetK.metaType.format] = {
	"gridScope": false,
	"lineScope": false,
	"purge": true
};
_datasetK.metaGridRules[_datasetK.metaType.dchoise] = {
	"gridScope": false,
	"lineScope": false,
	"purge": true
};

function _updateCollOneByOne(nLenColl, nbMvt) {
	var ratio = 10,
		threshold = 15;
	//With "$isPartialDelta" mode, is not longer necessary to apply change record by record ==> TODO : remove
	//return !!(nbMvt <= Math.ceil(nLenColl/ratio) && nbMvt <= threshold);
	return false;
}

function _getMvtCollCode(mvt) {
	return mvt[0] == sapUtil.dataSetMvt.del ? (mvt.length == 1 ? sapUtil.dataSetMvt.delAll : sapUtil.dataSetMvt.del) : sapUtil.dataSetMvt.insrt;
}

function _razIndexPropr(data) {
	// To remove... but for now how the Syra framework add "$index" while processing records... it's nessasry to clean-up
	if (data.length > 0 && data[0].hasOwnProperty("$index")) {
		_.each(data, function(value) {
			delete value.$index;
		});
	}
}

function _hackBugWebSrv(meta, entityName) {
	_.each(meta, function(metaCat, name) {
		_.each(metaCat, function(value) {
			if (name != "dch") {
				value[0] = value[0].substring(1);
			} else {
				value[0] = entityName.substring(0, 1) + value[0];
				value[2] = value[2] != null ? value[2].toString(10) : null;
			}
		});
	});
}

/* Entity Store class */

function EntityStore() {}

exports.EntityStore = helpers.defineClass(EntityStore, null, {
	initialize: function(internalType, isCollection, name, proto, formatterW, opts) {
		this._isColl = isCollection;
		this.$type = internalType;
		this.realType = internalType;
		this.entityName = name;
		this._isNodeWS = opts && opts.isNodeWS;
		this._fmtWrapper = formatterW;
		this._proto = proto;
		return this.initStore(opts ? opts.locales : null);
	},

	initStore: function(regOpts) {
		var KfmtMeta = _datasetK.metaType.format,
			occur, ro, itemsProps, i, len, itemsPropsArray, entityType, protoFmt, refProp, ret = null;
		var defFmt, KdefFmt = ":",
			KdefDateFmt = "D:" + ((regOpts ? regOpts.dateFormat : null) || "MM[/]DD[/]YY"),
			ignoreFmt = false;
		if (this._isColl) {
			this.data = [];
			this.meta = {};
			this.metaFmt = {};
			_.each(_datasetK.metaGridRules, function(rule, metaType) {
				this[metaType] = [];
			}, this.meta);
			this.$isReadOnly = this._proto.$isReadOnly || false;
			this._$empty = true;
			this._$frag = false;
			// Set default format for each properties
			if (this._fmtWrapper && this._proto.$item && (itemsProps = this._proto.$item.$properties)) {
				ro = true;
				itemsPropsArray = Object.keys(itemsProps);
				for (i = 0, len = itemsPropsArray.length; i < len; i++) {
					occur = itemsProps[itemsPropsArray[i]];
					entityType = occur.$type;
					protoFmt = occur.$X3Fmt;
					ro = !occur.$isReadOnly ? false : ro;
					if (entityType == syraUtil.dataTypes.reference && (refProp = syraUtil.getRefPropertyEntity(occur))) {
						entityType = refProp.proto.$type;
						protoFmt = refProp.proto.$X3Fmt;
					}
					if (KisTypeAcceptFmt[entityType]) {
						defFmt = !protoFmt && entityType == syraUtil.dataTypes.dateType ? KdefDateFmt : KdefFmt;
						if (protoFmt || defFmt) {
							this.metaFmt[itemsPropsArray[i]] = {
								"fmt": protoFmt || defFmt,
								"cellsSet": false,
								"_fmtEmpty": !! KisTypeAcceptFmtED[entityType],
								"realType": entityType
							};
						}
					}
				}
				this.$isReadOnly = ro || this.$isReadOnly;
			}
		} else {
			this.data = {};
			entityType = this.$type;
			protoFmt = this._proto.$X3Fmt;
			if (entityType == syraUtil.dataTypes.reference && (refProp = syraUtil.getRefPropertyEntity(this._proto))) {
				// Reference, then...
				entityType = refProp.proto.$type;
				this.realType = entityType;
				protoFmt = refProp.proto.$X3Fmt;
				if (refProp.propTitle) {
					ret = {
						"refTitle": {
							"name": refProp.propTitle,
							"refField": this
						}
					};
				}
			}
			ignoreFmt = !KisTypeAcceptFmt[entityType] || !! (protoFmt && protoFmt.substring(0, 2) === "KR"); // Ignores format for RTF or raw text (ie. "KR:..."
			if (this._fmtWrapper && !ignoreFmt) {
				defFmt = !protoFmt && entityType == syraUtil.dataTypes.dateType ? KdefDateFmt : KdefFmt;
				this.data[KfmtMeta] = protoFmt || defFmt;
				this.data._fmtEmpty = !! KisTypeAcceptFmtED[entityType];
			}
		}
		return ret;
	},

	isSupportPartialChange: function() {
		var ret = true;
		if (this._isColl) {
			if (this._proto.$treeview) {
				ret = false;
			} else if (this._proto.$cube) {
				ret = false;
			} else if (this._proto.$decorator && this._proto.$decorator.$stereotype) {
				ret = false;
			}
		}
		return ret;
	},

	releaseStore: function() {
		delete this.data;
		delete this.meta;
		delete this.metaFmt;
	},

	_fillTemplateColl: function(options) {
		var coll = [],
			i, ii;
		for (i = 0, ii = this.data.length; i < ii; i++) {
			coll[i] = {
				"$uuid": this.data[i].$uuid,
				"$serverIndex": i
			};
		}
		return coll;
	},

	_renumberColl: function(nNumOffset, nStartIdx, nStopIdx) {
		var nIdxProcessed = nStartIdx;
		while (nIdxProcessed < nStopIdx) {
			this.data[nIdxProcessed++].$serverIndex += nNumOffset;
		}
	},

	applyDataCollEx: function(data, commit, options, callbackBind, callbackUnsort) {
		var isEmpty, ruptInsrt = null,
			nbMvt = data.$mvt ? data.$mvt.length : 0,
			i = nbMvt - 1,
			j, nbInsrt = 0,
			delta, updated = false,
			oneByOne;
		var leftListColl = options && options.lf,
			collMvt = null,
			partialUpdate, syraElapse = {
				"data": 0,
				"mvt": 0
			};
		var meta = data.$meta,
			metaFmtObj = this._fmtWrapper && meta && meta[_datasetK.metaType.format] ? meta[_datasetK.metaType.format] : null;
		this._tgFmt = 0;
		if (i >= 0 && data.$mvt[i][0] == sapUtil.dataSetMvt.insrt) {
			ruptInsrt = i;
			nbInsrt = data.$mvt[i][2];
		}
		ruptInsrt = ruptInsrt !== null ? ruptInsrt : nbMvt;
		if (ruptInsrt > 0) {
			// First, apply batch movements if any (del, insert or del all)
			for (j = 0; j < ruptInsrt; j++) {
				oneByOne = data.$mvt[j].length > 2 ? _updateCollOneByOne(this.data.length, data.$mvt[j][2]) : false;
				syraElapse.mvt += this.applyCollMvt(data.$mvt[j], oneByOne, options, callbackBind, callbackUnsort);
			}
		}
		if (nbInsrt > 0) {
			// Second, process last batch insert if any
			if (!(isEmpty = this._$empty) && _updateCollOneByOne(this.data.length, nbInsrt)) {
				// Optimized mode for the insert movements
				syraElapse.mvt += this.applyCollMvt(data.$mvt[ruptInsrt], true, options, callbackBind, callbackUnsort);
			} else {
				// Full update : insert movements + data (with optimization for left list)
				callbackUnsort();
				delta = leftListColl ? {} : this.applyMvt(_getMvtCollCode(data.$mvt[ruptInsrt]), data.$mvt[ruptInsrt][1], data.$mvt[ruptInsrt][2]);
				if (data.$rcd) {
					if (metaFmtObj) {
						// Need to update meta "format" before!
						this.storeMetaFmtColl(metaFmtObj);
						delete meta[_datasetK.metaType.format];
						metaFmtObj = null;
					}
					this._storeDataColl(data.$rcd, commit, options);
					if (!leftListColl) {
						collMvt = this.data;
						if (this.data.length != data.$rcd.length) {
							// Need to push inserted record without correspondence in object $rcd.data
							_.each(data.$rcd, function(rcd, idx) {
								if (delta.uuidInserted.hasOwnProperty(rcd.$uuid)) {
									delete delta.uuidInserted[rcd.$uuid];
								}
							});
							_.each(delta.uuidInserted, function(value, key) {
								data.$rcd.push(delta.mvtData[value]);
							});
							collMvt = this.data.length === data.$rcd.length ? this.data : data.$rcd;
						}
					}
				}
				collMvt = !collMvt ? (data.$rcd || delta.mvtData) : collMvt;
				partialUpdate = leftListColl || collMvt.length == this.data.length || collMvt.length == 1 ? false : true;
				syraElapse.data += callbackBind(collMvt, {
					"$isPartialDelta": partialUpdate
				});
				_razIndexPropr(this.data);
				updated = true;
			}
		}
		// Be sure to store meta "format"... if not already done!
		if (metaFmtObj) {
			this.storeMetaFmtColl(metaFmtObj);
			delete meta[_datasetK.metaType.format];
		}
		// Finally updata data if necessary
		if (data.$rcd && !updated) {
			if (this._storeDataColl(data.$rcd, commit, options) && !leftListColl && (data.$rcd.length !== this.data.length || !commit)) {
				// By delta
				syraElapse.data += callbackBind(data.$rcd, {
					"$isPartialDelta": data.$rcd.length > 1 ? true : false,
					"unsortBefore": false
				});
			} else {
				// Full
				syraElapse.data += callbackBind(leftListColl ? data.$rcd : this.data, {
					"$isPartialDelta": false,
					"unsortBefore": false
				});
			}
			_razIndexPropr(this.data);
		}
		return syraElapse;
	},

	applyCollMvt: function(mvt, oneByOne, options, callbackBind, callbackUnsort) {
		var mvtCode = _getMvtCollCode(mvt),
			delta, lenCollBefore = this.data.length,
			lenCollAfter, collMvt, isDelta, syraElapse = 0,
			partialDelta = true;
		// Apply dataset mvt
		if (mvtCode === sapUtil.dataSetMvt.insrt) {
			callbackUnsort();
		}
		delta = this.applyMvt(mvtCode, mvt[1], mvt[2]);
		lenCollAfter = this.data.length;
		// Bind
		if (mvtCode === sapUtil.dataSetMvt.delAll || (lenCollAfter === 0 && mvtCode === sapUtil.dataSetMvt.del)) {
			syraElapse += callbackBind([], {
				"$isPartialDelta": false,
				"unsortAfter": true
			});
		} else
		if (lenCollAfter == 1 && mvtCode == sapUtil.dataSetMvt.del) {
			// Optimisation in Syracuse protocole...
			delete this.data[0].$index;
			syraElapse += callbackBind([this.data[0]], {
				"$isPartialDelta": false
			});
		} else {
			if (oneByOne) {
				_.each(delta.mvtData, function(rcd) {
					syraElapse += callbackBind([rcd], {
						"$isPartialDelta": false
					});
				});
			} else {
				collMvt = delta.mvtData;
				if (mvtCode == sapUtil.dataSetMvt.insrt) {
					if (delta.isEmpty) {
						collMvt = this.data;
						partialDelta = false;
					}
				}
				syraElapse += callbackBind(collMvt, {
					"$isPartialDelta": partialDelta
				});
				if (!partialDelta) {
					_razIndexPropr(this.data);
				}
			}
		}
		return syraElapse;
	},

	applyMvt: function(mvt, start, count) {
		var result = {
			"mvtData": [],
			"isDelta": true,
			"isEmpty": false,
			"uuidInserted": {}
		}, i, j, bAtEnd, len = this.data.length,
			_uuid;
		var ii, lenii, propsWithFmt, _$raw, renumber = 0;
		// Update data
		if (mvt == sapUtil.dataSetMvt.delAll) {
			result.mvtData = [];
			result.isDelta = false;
			result.delAll = true;
			this._$frag = false;
			this._$empty = true;
			delete this.data;
			this.data = [];
		} else
		if (mvt == sapUtil.dataSetMvt.del) {
			bAtEnd = (start - 1) + count >= len;
			this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
			for (i = start - 1; i < start - 1 + count; i++) {
				if (len > i) {
					this.data[i].$isDeleted = true;
				}
			}
			result.mvtData = this.data.splice(start - 1, count);
			renumber = bAtEnd ? 0 : -1;
			result.mvtMeta = bAtEnd ? null : [mvt, start - 1, count];
		} else {
			// So, insert ...
			this._$empty = false;
			bAtEnd = start > len;
			this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
			for (i = start - 1, j = 0; i < start - 1 + count; i++) {
				_uuid = this._$frag ? helpers.uuid.generate() : this.data.length;
				this.data.splice(i, 0, {
					"$uuid": _uuid,
					"$serverIndex": i
				});
				renumber = bAtEnd ? 0 : 1;
				if (this._fmtWrapper) {
					// Init raw data management object
					_$raw = this.data[i].$rawV = {};
					propsWithFmt = Object.keys(this.metaFmt);
					for (ii = 0, lenii = propsWithFmt.length; ii < lenii; ii++) {
						_$raw[propsWithFmt[ii]] = {};
					}
				}
				result.mvtData.push({
					"$uuid": _uuid,
					"$index": i
				});
				result.uuidInserted[_uuid] = j++;
			}
			result.mvtMeta = [mvt, start - 1, count];
		}
		if (renumber !== 0) {
			this._renumberColl(renumber * count, renumber > 0 ? start : start - 1, this.data.length);
		}
		result.isEmpty = this._$empty;
		// Cleanup meta data
		this._cleanupMetaColl(mvt, start, count, this._$empty || start >= this.data.length);

		return result;
	},

	_storeDataColl: function(newData, commit, options) {
		var isDelta = false,
			nbRcds = this.data.length - 1,
			jd, lend, len, rcdArray, i, j, dataFmt, niemeDataPtr, skip, yetFormatted, rawValueEx, _tgInter;
		if (!commit) {
			isDelta = !this._$empty;
		}
		if (this._$empty && !this._fmtWrapper) {
			if (commit) {
				this.data = util.duplicateObj(newData);
				this._isLastLineEmpty = this._isLineEmpty(nbRcds);
			}
		} else {
			isDelta = commit && !this._$empty ? true : isDelta;
			try {
				for (jd = 0, lend = newData.length; jd < lend; jd++) {
					i = newData[jd].$uuid;
					delete newData[jd].$uuid;
					niemeDataPtr = this.data[i];
					if (commit || this._fmtWrapper) {
						rcdArray = Object.keys(newData[jd]);
						for (j = 0, len = rcdArray.length; j < len; j++) {
							if (!this._fmtWrapper || !(dataFmt = this._getMetaFmtColl(rcdArray[j], i, this.metaFmt[rcdArray[j]]))) {
								if (commit) {
									niemeDataPtr[rcdArray[j]] = newData[jd][rcdArray[j]];
								}
							} else {
								skip = !newData[jd][rcdArray[j]] && !this.metaFmt[rcdArray[j]]._fmtEmpty;
								if ((yetFormatted = (options && options.formatted)) && commit) {
									rawValueEx = this._fmtWrapper.unformat(newData[jd][rcdArray[j]], this.metaFmt[rcdArray[j]].realType, dataFmt, true);
								}
								try {
									if (commit) {
										_tgInter = (new Date()).getTime();
										niemeDataPtr[rcdArray[j]] = skip || yetFormatted ? newData[jd][rcdArray[j]] : this._fmtWrapper.formatter.formatField({
											"format": dataFmt
										}, newData[jd][rcdArray[j]], true, false);
										this._tgFmt += ((new Date()).getTime() - _tgInter);
										niemeDataPtr.$rawV[rcdArray[j]].v = yetFormatted && rawValueEx.succeeded ? rawValueEx.raw : newData[jd][rcdArray[j]];
										if (!skip && !yetFormatted) {
											newData[jd][rcdArray[j]] = niemeDataPtr[rcdArray[j]];
										}
									} else {
										if (!skip && !yetFormatted) {
											newData[jd][rcdArray[j]] = this._fmtWrapper.formatter.formatField({
												"format": dataFmt
											}, newData[jd][rcdArray[j]], true, false);
										}
									}
								} catch (e) {

									if (commit) {
										niemeDataPtr[rcdArray[j]] = newData[jd][rcdArray[j]];
										niemeDataPtr.$rawV[rcdArray[j]].v = newData[jd][rcdArray[j]];
									}
								}
							}
						}
						if (commit && i == nbRcds && (this._isLastLineEmpty = this._isLineEmpty(i)) && this._fmtWrapper) {
							// Need to rectify in order to force "empty like" values
							for (j = 0, len = rcdArray.length; j < len; j++) {
								if (niemeDataPtr.$rawV[rcdArray[j]] && niemeDataPtr.$rawV[rcdArray[j]].v !== undefined) {
									niemeDataPtr[rcdArray[j]] = niemeDataPtr.$rawV[rcdArray[j]].v;
								}
							}
						}
					}
					newData[jd].$index = i;
					newData[jd].$serverIndex = i;
					newData[jd].$uuid = niemeDataPtr.$uuid;
				}
			} catch (ex) {
				// TODO : remove this try/catch once server issue will be fixed. 
				alert("Server issue : array index out of bound for entity " + this.entityName);
			}
		}
		this._$empty = false;
		return isDelta;
	},

	_cureMetaStateOnArrayScope: function(metaState) {
		var newMetaState = null,
			len, i, itemsProps = this._proto.$item.$properties,
			newS, state, roCount = 0;
		var itemsPropsArray = itemsProps ? Object.keys(itemsProps) : null;
		// To avoid to set a stated "$isReadonly" or "$isDisabled" state on a "$isReadonly" col by model, while receiveing a 'state' meta on a full grid,
		// we could have to split the 'grid' scope meta in a collection of 'col' scope meta
		state = sapUtil.getState(metaState);
		if ((state.$isDisabled != undefined || state.$isReadOnly != undefined) && itemsPropsArray) {
			newMetaState = [];
			for (i = 0, len = itemsPropsArray.length; i < len; i++) {
				if ((newS = syraUtil.purgeStateMeta(itemsProps[itemsPropsArray[i]], metaState)) !== null) {
					newMetaState.push([itemsPropsArray[i], 0, newS]);
				}
				if (itemsProps[itemsPropsArray[i]].$isReadOnly) {
					roCount++;
				}
			}
			if (roCount == itemsPropsArray.length) {
				this.meta._fullyDisabled = true;
			} else {
				this.meta._fullyDisabled = (state.$isDisabled || state.$isReadOnly) ? true : false;
				if (roCount == 0) {
					newMetaState = null;
				}
			}
		}
		return newMetaState;
	},

	storeMetaColl: function(newMeta) {
		if (this._isNodeWS !== true) {
			_hackBugWebSrv(newMeta, this.entityName);
		}
		var found, gridInst, i, len;
		_.each(newMeta, function(newMetaColl, type) {
			var occur, state, discard, splited, j, lenj, entityProto;
			// Init, purge, controls...
			if (type === _datasetK.metaType.state) {
				len = newMetaColl.length;
				for (i = len - 1; i >= 0; i--) {
					discard = false;
					splited = null;
					occur = newMetaColl[i];
					gridInst = sapUtil.isBlockInst(occur[0]);
					if (!gridInst && occur[1] == 0) {
						// 'col' scope, a pinch of fun...
						if (!(entityProto = this._proto.$item.$properties[occur[0]])) {
							// Oups, we don't know this column!
							discard = true;
						} else {
							occur[2] = syraUtil.purgeStateMeta(entityProto, occur[2]);
							if (occur[2] == null) {
								discard = true;
							} else
							if (sapUtil.isStateStatedBis(occur[2])) {
								// Same rule as CS : cancel "_fullyDisabled" flag when line or cell scope...
								this.meta._fullyDisabled = false;
							}
						}
					} else
					if (gridInst && occur[1] == 0) {
						// 'grid' scope, an other pinch of fun...
						if ((occur[2] = syraUtil.purgeStateMeta(this, occur[2])) == null) {
							discard = true;
						} else {
							// Last but not least, we have to check, col by col, if it would not a 'read only' col by model, to discard it!
							splited = this._cureMetaStateOnArrayScope(occur[2]);
						}
					} else
					if (occur[1] > 0 && sapUtil.isStateStatedBis(occur[2])) {
						// Same rule as CS : cancel "_fullyDisabled" flag when line or cell scope...
						this.meta._fullyDisabled = false;
					}
					if (discard || splited) {
						newMetaColl.splice(i, 1);
						if (splited) {
							for (j = 0, lenj = splited.length; j < lenj; j++) {
								newMetaColl.splice(i, 0, splited[j]);
							}
						}
					}
				}
			}
			if (this.meta[type].length > 0) {
				_.each(newMetaColl, function(newMeta) {
					// Clean-up old metas
					gridInst = sapUtil.isBlockInst(newMeta[0]);
					// Warning... have to discard unknown entities
					if (!gridInst && !this._proto.$item.$properties[newMeta[0]]) {
						return;
					}
					if (_datasetK.metaGridRules[type].gridScope && (gridInst && newMeta[1] == 0)) {
						// If grid Scope : purge All
						delete this.meta[type];
						this.meta[type] = [];
					} else
					if (_datasetK.metaGridRules[type].purge) {
						// Avoid to apply same meta twice!
						found = util.arrayFind(this.meta[type], function(metaStored) {
							return metaStored[0] == newMeta[0] && metaStored[1] == newMeta[1] && metaStored[2] == newMeta[2] ? true : false;
						});
						if (found >= 0) {
							this.meta[type].splice(found, 1);
						}
					}
					if (this.meta[type].length > 0 && !gridInst && newMeta[1] == 0) {
						// If column scope : purge all cells impacted for this column
						len = this.meta[type];
						for (i = len - 1; i >= 0; i--) {
							if (this.meta[type][i][0] == newMeta[0]) {
								this.meta[type].splice(i, 1);
							}
						}
					} else
					if (this.meta[type].length > 0 && gridInst && _datasetK.metaGridRules[type].lineScope && newMeta[1] > 0) {
						// If line scope : purge all cells impacted
						len = this.meta[type];
						for (i = len - 1; i >= 0; i--) {
							if (this.meta[type][i][1] == newMeta[1]) {
								this.meta[type].splice(i, 1);
							}
						}
					}
					// Store new meta
					this.meta[type].push(newMeta);
				}, this);
			} else
			if (newMetaColl.length > 0) {
				// Warning : too annoying and slow to control id each meta is bound with a known entity...
				this.meta[type] = util.duplicateObj(newMetaColl);
			}
		}, this);
	},

	_cleanupMetaColl: function(mvt, start, count, insertAtEnd) {
		var i, len;
		_.each(this.meta, function(metaColl, type) {
			if ((len = metaColl.length) > 0) {
				for (i = len - 1; i >= 0; i--) {
					if (mvt == sapUtil.dataSetMvt.delAll && metaColl[i][1] > 0) {
						// Remove all none "grid" or "column" scope meta on raz
						metaColl.splice(i, 1);
					} else
					if (mvt == sapUtil.dataSetMvt.del && metaColl[i][1] > 0) {
						// Modify or delete old "line/cell" scope meta, according to delete range
						if (metaColl[i][1] >= start && metaColl[i][1] < start + count) {
							metaColl.splice(i, 1);
						} else
						if (metaColl[i][1] >= start + count) {
							metaColl[i][1] -= count;
						}
					} else
					if (mvt == sapUtil.dataSetMvt.insrt && metaColl[i][1] > start && !insertAtEnd) {
						// Modify old "line/cell" scope metas, according to insert range
						metaColl[i][1] += count;
					}
				}
			}
		}, this);
	},

	getMetaByCriteria: function(type, target, level) {
		var ret = null,
			isRow = false,
			isCell = false,
			isLine = false,
			isGrid = false,
			isHeader = false,
			len, i, isFieldMeta, meta, found = false;
		if (this._isColl) {
			if (type == "_fullyDisabled") {
				ret = !! (this.meta._fullyDisabled) || this.$isReadOnly;
			} else
			if (this.meta[type] && this.meta[type].length > 0) {
				// Target?
				isRow = target && !sapUtil.isBlockInst(target);
				if (isRow) {
					isCell = level > 0 ? true : false;
					isRow = !isCell;
				} else
				if (target) {
					isLine = level > 0 ? true : false;
					isGrid = !isLine && level == 0 ? true : false;
					isHeader = !isLine && level == -1 ? true : false;
				}
				// Compute
				ret = isHeader ? {} : null;
				for (i = 0, len = this.meta[type].length; i < len; i++) {
					meta = this.meta[type][i];
					isFieldMeta = !sapUtil.isBlockInst(meta[0]);
					if (!isFieldMeta && meta[1] == 0 && isGrid) {
						found = true;
					} else
					if (!isFieldMeta && meta[1] > 0 && isLine) {
						found = true;
					} else
					if (isFieldMeta && meta[1] == 0 && isRow) {
						found = true;
					} else
					if (isFieldMeta && meta[1] > 0 && isCell) {
						found = true;
					} else
					if (isFieldMeta && meta[1] == 0 && isHeader) {
						ret[meta[0]] = meta[2];
					}
					if (found) {
						ret = meta[2];
						break;
					}
				}
			}
		} else {
			ret = this[type];
		}
		return ret;
	},

	getMetaCollEx: function(updateEx, meta, session, options) {
		function _purge(metaArray) {
			var i, j, k, lenI, scope, toPurge = {}, purged = [],
				splited = [],
				idx, line = false,
				grid = false,
				cell = false,
				col = false;
			var doublon = {}, dblKey, nbCells = 0,
				nbLines = 0;
			if (!metaArray || metaArray.length == 0) {
				return [];
			}
			for (i = 0, lenI = metaArray.length; i < lenI; i++) {
				// Scan for purge
				idx = metaArray[i][1];
				if (sapUtil.isBlockInst(metaArray[i][0])) {
					if (idx > 0) {
						line = true;
						nbLines++;
						scope = "ln";
					} else {
						grid = true;
						scope = "gr";
					}
				} else {
					if (idx > 0) {
						cell = true;
						scope = "ce";
						nbCells++;
					} else {
						col = true;
						scope = "cl";
					}
				}
				k = purged.length;
				purged.push({
					"uuid": i,
					"scope": scope,
					"ln": line,
					"gr": grid,
					"ce": cell,
					"cl": col,
					"nl": idx,
					"idx": --idx,
					"id": metaArray[i][0],
					"val": metaArray[i][2]
				});
				dblKey = metaArray[i][0] + "_" + idx;
				if (grid && k > 0) {
					nbCells = 0;
					nbLines = 0;
					purged.splice(0, k);
					doublon = {};
				} else
				if (line && nbCells) {
					for (j = k - 1; j >= 0; j--) {
						if (purged[j].nl > 0 && purged[j].idx == idx) {
							if (purged[j].ln) {
								nbLines--;
							} else {
								nbCells--;
							}
							delete doublon[purged[j].id + "_" + purged[j].idx];
							delete toPurge[purged[j].uuid];
							purged.splice(j, 1);
						}
					}
				} else
				if (col && nbCells) {
					for (j = k - 1; j >= 0; j--) {
						if (purged[j].nl > 0 && purged[j].cell && metaArray[i][0] == purged[j].id) {
							delete doublon[purged[j].id + "_" + purged[j].idx];
							delete toPurge[purged[j].uuid];
							purged.splice(j, 1);
							nbCells--;
						}
					}
				}
				// Scan Doublon
				if (doublon[dblKey] != undefined) {
					toPurge[doublon[dblKey]] = true;
				}
				doublon[dblKey] = i;
				line = false;
				grid = false;
				cell = false;
				col = false;
			}
			// Purge doublon
			if ((k = (Object.keys(toPurge)).length) > 0) {
				for (i = purged.length - 1; i >= 0 && k > 0; i--) {
					if (toPurge[purged[i].uuid] != undefined) {
						purged.splice(i, 1);
						k--;
					}
				}
			}
			// Split according scope break
			splited[0] = [purged[0]];
			if ((lenI = purged.length) > 1) {
				j = 0;
				for (i = 1; i < lenI; i++) {
					if (purged[i - 1].scope != purged[i].scope) {
						splited[++j] = [];
					}
					splited[j].push(purged[i]);
				}
			}
			return splited;
		}
		// Now we can reconstruct/consolidate and tranform meta to Syracuse protocol
		var splitedStatus = _purge(meta[_datasetK.metaType.state]),
			lenStatus = splitedStatus.length;
		var splitedStyle = _purge(meta[_datasetK.metaType.style]),
			lenStyle = splitedStyle.length;
		var metaEx = [{}],
			len, i;
		metaEx[0][_datasetK.metaType.title] = meta[_datasetK.metaType.title];
		metaEx[0][_datasetK.metaType.dchoise] = meta[_datasetK.metaType.dchoise];
		if (lenStyle > 0) {
			metaEx[0][_datasetK.metaType.style] = splitedStyle[0];
			lenStyle--;
		}
		if (lenStatus > 0) {
			metaEx[0][_datasetK.metaType.state] = splitedStatus[0];
			lenStatus--;
		}
		if (lenStyle > 0 || lenStatus > 0) {
			len = Math.max(lenStyle, lenStatus);
			for (i = 0; i < len; i++) {
				metaEx[i + 1] = {};
				if (lenStyle > 0) {
					metaEx[i + 1][_datasetK.metaType.style] = splitedStyle[i + 1];
					lenStyle--;
				}
				if (lenStatus > 0) {
					metaEx[i + 1][_datasetK.metaType.state] = splitedStatus[i + 1];
					lenStatus--;
				}
			}
		}
		if (!options) {
			options = {};
		}
		options.styDescObj = true;
		options.sttDescObj = true;
		for (i = 0, len = metaEx.length; i < len; i++) {
			updateEx[i] = {};
			this.getMetaColl(updateEx[i], metaEx[i], session, options);
		}
	},

	getMetaColl: function(update, meta, session, options) {
		// Get meta-data object (except format) according to Syracuse protocol 
		var arrayMeta, colMeta, rowMeta, propMember = "$properties",
			styDescObj = options && options.styDescObj,
			sttDescObj = options && options.sttDescObj,
			rowMetaMap = {}, ptr, hackDch = true;
		var setCol = true,
			setCell = true,
			setLine = true,
			setArray = true;
		// Helper

		function helper(id, property, metaName, metaValue, obj, cellMeta) {
			if (!rowMetaMap[id]) {
				rowMetaMap[id] = {};
			}
			ptr = rowMetaMap[id];
			if (cellMeta) {
				if (!rowMetaMap[id][propMember]) {
					rowMetaMap[id][propMember] = {};
				}
				if (!rowMetaMap[id][propMember][property]) {
					rowMetaMap[id][propMember][property] = {};
				}
				ptr = rowMetaMap[id][propMember][property];
			}
			if (obj) {
				for (var prop in metaName) {
					ptr[prop] = metaName[prop];
				}
			} else {
				ptr[metaName] = metaValue;
			}
		}
		// Init
		if (options) {
			setCol = !options.excludeRow;
			setCell = !options.excludeCell;
			setLine = !options.excludeLine;
			setArray = !options.excludeArray;
		}
		if (!update[propMember]) {
			update[propMember] = {};
		}
		if (!update[propMember][this.entityName]) {
			update[propMember][this.entityName] = {};
		}
		if (!update[propMember][this.entityName].$item) {
			update[propMember][this.entityName].$item = {};
		}
		if (!update[propMember][this.entityName].$item[propMember]) {
			update[propMember][this.entityName].$item[propMember] = {};
		}
		if (!update[this.entityName]) {
			update[this.entityName] = [];
		}
		arrayMeta = update[propMember][this.entityName];
		colMeta = update[propMember][this.entityName].$item[propMember];
		rowMeta = update[this.entityName];
		// Set meta Title     
		_.each(meta[_datasetK.metaType.title], function(tit) {
			// Array or col level?
			if (sapUtil.isBlockInst(tit[0])) {
				if (setArray) {
					arrayMeta.$title = tit[2];
				}
			} else {
				if (setCol) {
					if (!colMeta[tit[0]]) {
						colMeta[tit[0]] = {};
					}
					colMeta[tit[0]].$title = tit[2];
				}
			}
		});
		// Set meta Status
		_.each(meta[_datasetK.metaType.state], function(stt) {
			var line, id, st, ptr = null;
			if (sttDescObj) {
				line = stt.idx;
				id = stt.id;
				st = sapUtil.getState(stt.val);
			} else {
				line = stt[1] - 1;
				id = stt[0];
				st = sapUtil.getState(stt[2]);
			}
			if (sapUtil.isBlockInst(id)) {
				if (line >= 0) {
					if (setLine) {
						helper(line, null, st, null, true);
					}
				} else {
					if (setArray) {
						ptr = arrayMeta;
					}
				}
			} else {
				if (line >= 0) {
					if (setCell) {
						helper(line, id, st, null, true, true);
					}
				} else {
					if (setCol) {
						if (!colMeta[id]) {
							colMeta[id] = {};
						}
						ptr = colMeta[id];
					}
				}
			}
			if (ptr) {
				for (var prop in st) {
					ptr[prop] = st[prop];
				}
			}
		});
		// Set meta Style     
		_.each(meta[_datasetK.metaType.style], function(sty) {
			var line, id, val, styEx = {}, metaName = "$valueStyle",
				ptr = null,
				styPropr = _datasetK.metaType.style;
			if (styDescObj) {
				line = sty.idx;
				id = sty.id;
				val = sty.val;
			} else {
				line = sty[1] - 1;
				id = sty[0];
				val = sty[2];
			}
			styEx[styPropr] = val;
			if (sapUtil.cureStyle(styEx, this.entityName, session)) {
				if (sapUtil.isBlockInst(id)) {
					if (line >= 0) {
						if (setLine) {
							helper(line, null, metaName, styEx[styPropr]);
						}
					} else {
						if (setArray) {
							ptr = arrayMeta;
						}
					}
				} else {
					if (line >= 0) {
						if (setCell) {
							helper(line, id, metaName, styEx[styPropr], false, true);
						}
					} else {
						if (setCol) {
							if (!colMeta[id]) {
								colMeta[id] = {};
							}
							ptr = colMeta[id];
						}
					}
				}
				if (ptr) {
					ptr[metaName] = styEx[styPropr];
				}
			}
		}, this);
		// Set meta Disable combo     
		_.each(meta[_datasetK.metaType.dchoise], function(dch) {
			// Disable combo only available for cell scope
			var line = dch[1] - 1;
			if (!sapUtil.isBlockInst(dch[0]) && line >= 0 && setCell) {
				if (hackDch && options && options.currSrvTarget && options.currSrvTarget.nl) {
					// Hack cause #1719 : by design just one dch is supported, and is bound with current target...
					line = options.currSrvTarget.nl - 1;
				}
				helper(line, dch[0], _datasetK.metaType.dchoise, dch[2], false, true);
			}
		});
		// Compute row meta
		_.each(rowMetaMap, function(value, key) {
			value.$index = parseInt(key, 10);
			if (this.data[key]) {
				value.$uuid = this.data.length > 0 ? this.data[key].$uuid : key;
				rowMeta.push(value);
			}
		}, this);
		if (rowMeta.length == 0) {
			delete update[this.entityName];
		}
	},

	storeMetaFmtColl: function(metaFmtArray) {
		var i, j, len = metaFmtArray ? metaFmtArray.length : 0,
			meta, lenj, _$raw, metaFmtProp;
		for (i = 0; i < len; i++) {
			meta = metaFmtArray[i];
			metaFmtProp = this.metaFmt[meta[0]];
			if (meta[1] == 0 && metaFmtProp) {
				// Col scope
				metaFmtProp.fmt = meta[2];
				// Raz cell scope
				if (metaFmtProp.cellsSet) {
					for (j = 0, lenj = this.data.length; j < lenj; j++) {
						if ((_$raw = this.data[j].$rawV[[meta[0]]])) {
							_$raw.fmt = null;
							_$raw._fmtBySrv = null;
						}
					}
				}
				metaFmtProp.cellsSet = false;
			} else
			if (metaFmtProp && this.data.length > meta[1] - 1 && (_$raw = this.data[meta[1] - 1].$rawV[meta[0]])) {
				// Cell scope
				_$raw.fmt = meta[2];
				_$raw._fmtBySrv = true;
				metaFmtProp.cellsSet = true;
			}
		}
	},

	_getMetaFmtColl: function(property, idx, propCurrFmt) {
		var _$raw, fmt = null,
			metaFmtProp;
		if (this.data.length > idx && (metaFmtProp = this.metaFmt[property])) {
			// Warning 1 : like others meta, "format" could be set at "property" level (default) or "property/line" level.
			// Warning 2 : "propCurrFmt" object & "_fmtBySrv" property are a stuff to manage current col format while processing dataset update traversing in server sequence order....
			if (metaFmtProp.cellsSet && (_$raw = this.data[idx].$rawV[property]) && _$raw.fmt && _$raw._fmtBySrv) {
				fmt = _$raw.fmt;
				_$raw._fmtBySrv = null;
				if (propCurrFmt) {
					propCurrFmt.fmt = fmt;
				}
			} else {
				if (propCurrFmt && propCurrFmt.fmt) {
					fmt = propCurrFmt.fmt;
					// Force cell fmt if it's wise
					if (metaFmtProp.cellsSet && _$raw) {
						_$raw.fmt = fmt;
					}
				} else {
					fmt = metaFmtProp.fmt;
				}
			}
		}
		return this._fmtWrapper.isThickFormat(fmt) ? fmt : null;
	},

	getFmtColl: function(property, idx) {
		var _$raw, fmt = null,
			metaFmtProp;
		if (this.data.length > idx && (metaFmtProp = this.metaFmt[property])) {
			fmt = metaFmtProp.cellsSet && (_$raw = this.data[idx].$rawV[property]) && _$raw.fmt || metaFmtProp.fmt;
			return this._fmtWrapper.isThickFormat(fmt) ? fmt : null;
		} else {
			return null;
		}
	},

	getColumnsDataColl: function(property, raw, sort) {
		var i, len, dataCol = [],
			rawEx = !! (raw && this.metaFmt[property] && this._fmtWrapper.isThickFormat(this.metaFmt[property].fmt));
		if (!sort) {
			if (rawEx) {
				for (i = 0, len = this.data.length; i < len; i++) {
					dataCol[i] = this.data[i].$rawV[property].v;
				}
			} else {
				for (i = 0, len = this.data.length; i < len; i++) {
					dataCol[i] = this.data[i][property];
				}
			}
		} else {
			sort.onlyColumn = true;
			dataCol = this.sortDataColl([{
				"binding": property,
				"asc": sort.asc
			}], raw, sort);
		}
		return dataCol;
	},

	getLineDataColl: function(idx, raw) {
		var itemsProps = this._proto.$item.$properties,
			itemsPropsArray, i, len, record = null,
			rawEx, property;
		if (idx < this.data.length) {
			record = {};
			itemsPropsArray = Object.keys(itemsProps);
			for (i = 0, len = itemsPropsArray.length; i < len; i++) {
				property = itemsPropsArray[i];
				rawEx = !! (raw && this.metaFmt[property] && this._fmtWrapper.isThickFormat(this.metaFmt[property].fmt));
				record[property] = rawEx ? this.data[idx].$rawV[property].v : this.data[idx][property];
			}
		}
		return record;
	},

	sortDataColl: function(orderBy, raw, opts) {
		if (!orderBy || !orderBy.length)
			orderBy = [{
				binding: "$serverIndex",
				descending: true
			}];
		var sortCol, desc, self = this,
			sortProps, lenk = orderBy.length,
			dLength = this.data.length,
			slice = null,
			collProps = this._proto.$item.$properties;
		var zero = "0",
			i, k, nieme, len, dataCol = [];
		// No significatif dataset test
		if (dLength < 2) {
			return this.data;
		}
		this._tgSort = (new Date()).getTime();
		// Need to exclude last line?
		if (this._isLastLineEmpty) {
			dLength--;
			slice = -1;
		}

		function getSortType(binding) {
			var metaFmt = self.metaFmt[binding],
				intg = false,
				flt = false,
				rawEx = !! (raw && metaFmt && self._fmtWrapper.isThickFormat(metaFmt.fmt));
			if (binding == "$serverIndex") {
				return {
					"intg": true,
					"flt": false,
					"rawEx": false
				};
			} else
			if (!rawEx) {
				if (collProps[binding] && collProps[binding].$type == syraUtil.dataTypes.booleanType || collProps[binding].$type == syraUtil.dataTypes.choiceType || collProps[binding].$type == syraUtil.dataTypes.integerType) {
					intg = true;
					flt = false;
				} else if (collProps[binding].$type == syraUtil.dataTypes.decType || collProps[binding].$type == syraUtil.dataTypes.realType) {
					intg = false;
					flt = true;
				}
				return {
					"intg": intg,
					"flt": flt,
					"rawEx": false
				};
			} else {
				intg = !(metaFmt.realType == syraUtil.dataTypes.stringType || metaFmt.realType == syraUtil.dataTypes.passwdType);
				if (intg && (metaFmt.realType == syraUtil.dataTypes.realType || metaFmt.realType == syraUtil.dataTypes.decType)) {
					intg = false;
					flt = true;
				}
				return {
					"intg": intg,
					"flt": flt,
					"rawEx": true
				};
			}
		}
		// It's a quite clumsy... but decidedly better for perf.
		if (opts && opts.onlyColumn) {
			// Just one Column
			sortCol = orderBy[0].binding;
			desc = !orderBy[0].asc;
			sortProps = getSortType(sortCol);
			if (opts.onlyData) {
				if (sortProps.rawEx) {
					for (i = 0; i < dLength; i++) {
						dataCol[i] = this.data[i].$rawV[sortCol].v;
					}
				} else {
					for (i = 0; i < dLength; i++) {
						dataCol[i] = this.data[i][sortCol];
					}
				}
				dataCol.sort(function(a, b) {
					return sortProps.intg ? parseInt(a || zero, 10) - parseInt(b || zero, 10) : (sortProps.flt ? parseFloat(a || zero) - parseFloat(b || zero) : a.localeCompare(b));
				});
			} else {
				if (sortProps.rawEx) {
					for (i = 0; i < dLength; i++) {
						nieme = this.data[i];
						dataCol[i] = {
							"v": nieme.$rawV[sortCol].v,
							"$value": nieme[sortCol],
							"$serverIndex": nieme.$serverIndex,
							"$uuid": nieme.$uuid
						};
					}
				} else {
					for (i = 0; i < dLength; i++) {
						nieme = this.data[i];
						dataCol[i] = {
							"v": nieme[sortCol],
							"$value": nieme[sortCol],
							"$serverIndex": nieme.$serverIndex,
							"$uuid": nieme.$uuid
						};
					}
				}
				dataCol.sort(function(a, b) {
					return sortProps.intg ? parseInt(a.v || zero, 10) - parseInt(b.v || zero, 10) : (sortProps.flt ? parseFloat(a.v || zero) - parseFloat(b.v || zero) : a.v.localeCompare(b.v));
				});
			}
			if (desc) {
				dataCol.reverse();
			}
			if (slice != null) {
				// The "blank" lien is reinjected
				nieme = this.data[dLength];
				dataCol.push(opts.onlyData ? nieme[sortCol] : {
					"v": nieme[sortCol],
					"$value": nieme[sortCol],
					"$serverIndex": dLength,
					"$uuid": nieme.$uuid
				});
			}
		} else
		if (lenk == 1 && orderBy[0].binding === "$serverIndex") {
			// Server sequence
			dataCol = this.data;
		} else {
			// General case
			dataCol = slice == null ? this.data.slice(0) : this.data.slice(0, slice);
			sortProps = [];
			for (k = 0; k < lenk; k++) {
				sortProps[k] = getSortType(orderBy[k].binding);
				sortProps[k].desc = !orderBy[k].asc ? -1 : 1;
			}
			if (lenk > 1) {
				dataCol.sort(function(a, b) {
					var cmp, l, sortCol;
					for (l = 0; l < lenk; l++) {
						sortCol = orderBy[l].binding;
						if (!sortProps[l].rawEx) {
							cmp = sortProps[l].intg ? parseInt(a[sortCol] || zero, 10) - parseInt(b[sortCol] || zero, 10) : (sortProps[l].flt ? parseFloat(a[sortCol] || zero) - parseFloat(b[sortCol] || zero) : a[sortCol].localeCompare(b[sortCol]));
						} else {
							cmp = sortProps[l].intg ? parseInt(a.$rawV[sortCol].v || zero, 10) - parseInt(b.$rawV[sortCol].v || zero, 10) : (sortProps[l].flt ? parseFloat(a.$rawV[sortCol].v || zero) - parseFloat(b.$rawV[sortCol].v || zero) : a.$rawV[sortCol].v.localeCompare(b.$rawV[sortCol].v));
						}
						if (cmp != 0) {
							cmp = cmp * sortProps[l].desc;
							break;
						}
					}
					return cmp;
				});
			} else {
				if (!sortProps[0].rawEx) {
					dataCol.sort(function(a, b) {
						var sortCol = orderBy[0].binding;
						return sortProps[0].intg ? parseInt(a[sortCol] || zero, 10) - parseInt(b[sortCol] || zero, 10) : (sortProps[0].flt ? parseFloat(a[sortCol] || zero) - parseFloat(b[sortCol] || zero) : a[sortCol].localeCompare(b[sortCol]));
					});
				} else {
					dataCol.sort(function(a, b) {
						var sortCol = orderBy[0].binding;
						return sortProps[0].intg ? parseInt(a.$rawV[sortCol].v || zero, 10) - parseInt(b.$rawV[sortCol].v || zero, 10) : (sortProps[0].flt ? parseFloat(a.$rawV[sortCol].v || zero) - parseFloat(b.$rawV[sortCol].v || zero) : a.$rawV[sortCol].v.localeCompare(b.$rawV[sortCol].v));
					});
				}
				if (sortProps[0].desc == -1) {
					dataCol.reverse();
				}
			}
			if (slice != null) {
				// The "blank" lien is reinjected
				dataCol.push(this.data[dLength]);
			}
		}
		this._tgSort = (new Date()).getTime() - this._tgSort;
		return dataCol;
	},

	getRecordsNumber: function(opts) {
		return this._isColl ? (this.data.length - (this._isLastLineEmpty ? 1 : 0)) : 1;
	},

	isCollFull: function() {
		return !this._isLastLineEmpty;
	},

	getCollRcdUUID: function(idx) {
		return this.data[idx].$uuid;
	},

	getCollRcdIdx: function(uuid) {
		var i, len = this.data.length,
			idx = null;
		for (i = 0; i < len; i++) {
			if (this.data[i].$uuid == uuid) {
				idx = i;
				break;
			}
		}
		return idx;
	},

	_isLineEmpty: function(lineIdx) {
		return sapUtil.isEmptyGridDataRecordEx(this._proto.$item.$properties, this.getLineDataColl(lineIdx, true));
	},

	dispose: function() {
		this.releaseStore();
		delete this._fmtWrapper;
		delete this._proto;
	}
});