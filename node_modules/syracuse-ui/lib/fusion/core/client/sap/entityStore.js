"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Entity dataset store Class
 */


var helpers = require('syracuse-core/lib/helpers');
var util = require('syracuse-ui/lib/fusion/tools/util');
var sapUtil = require('./util').Fusion;
var syraUtil = require('./util').Syra;

var _datasetK = {
    "metaType": {"style": "sty", "title": "tit", "state": "stt", "format": "fmt", "dchoise": "dch"},
    "metaGridRules": {}
};
_datasetK.metaGridRules[_datasetK.metaType.style] = {"gridScope": true, "lineScope": true, "purge": true};
_datasetK.metaGridRules[_datasetK.metaType.title] = {"gridScope": false, "lineScope": false, "purge": true};
_datasetK.metaGridRules[_datasetK.metaType.state] = {"gridScope": true, "lineScope": true, "purge": true};
_datasetK.metaGridRules[_datasetK.metaType.format] = {"gridScope": false, "lineScope": false, "purge": true};
_datasetK.metaGridRules[_datasetK.metaType.dchoise] = {"gridScope": false, "lineScope": false, "purge": true};


function _updateCollOneByOne(nLenColl, nbMvt){
    var ratio = 10, threshold = 15;
    //With "$isPartialDelta" mode, is not longer necessary to apply change record by record ==> TODO : remove
    //return !!(nbMvt <= Math.ceil(nLenColl/ratio) && nbMvt <= threshold);
    return false;
}
function _getMvtCollCode(mvt){
    return mvt[0] == sapUtil.dataSetMvt.del ? (mvt.length == 1 ? sapUtil.dataSetMvt.delAll : sapUtil.dataSetMvt.del) : sapUtil.dataSetMvt.insrt;
}
function _razIndexPropr(data){
    // To remove... but for now how the Syra framework add "$index" while processing records... it's nessasry to clean-up
    if (data.length > 0 && data[0].hasOwnProperty("$index")) {
        _.each(data, function(value){
            delete value.$index;
        });
    }
}
function _hackBugWebSrv(meta, entityName){
    _.each(meta, function (metaCat, name) {
        _.each(metaCat, function (value) {
            if(name != "dch") {
                value[0] = value[0].substring(1);
            }
            else {
                value[0] = entityName.substring(0, 1) + value[0];
            }
        });
    });
}


/* Entity Store class */
function EntityStore(){
}

exports.EntityStore = helpers.defineClass(EntityStore, null, {
    initialize: function(internalType, isCollection, name){
        this._isColl = isCollection;
        this.$type = internalType;
        this.entityName = name;
        if (isCollection) {
            this.data = [];
            this.meta = {};
            _.each(_datasetK.metaGridRules, function(rule, metaType){
                this[metaType] = [];
            }, this.meta);
            this._$empty = true;
            this._$frag = false;
        }
        else {
            this.data = {};
        }
    },
    
    _fillTemplateColl: function(options){
        var coll = [];
        for (var i = 0, ii = this.data.length; i < ii; i++) {
            coll[i] = {"$uuid": this.data[i].$uuid};
        }
        return coll;
    },
    
    applyDataCollEx: function(data, commit, options, callback){
        var isEmpty, ruptInsrt = null, nbMvt = data.$mvt ? data.$mvt.length : 0, i = nbMvt - 1, j, nbInsrt = 0, delta, updated = false, oneByOne;
        var leftListColl = options && options.lf, collMvt = null, fullUpdate, syraElapse = {"data": 0, "mvt": 0};
        if (i >= 0 && data.$mvt[i][0] == sapUtil.dataSetMvt.insrt) {
            ruptInsrt = i;
            nbInsrt = data.$mvt[i][2];
        }
        ruptInsrt = ruptInsrt !== null ? ruptInsrt : nbMvt;
        if (ruptInsrt > 0) {
            // First, apply batch movements if any (del, insert or del all)
            for (j = 0; j < ruptInsrt; j++) {
                oneByOne = data.$mvt[j].length > 2 ? _updateCollOneByOne(this.data.length, data.$mvt[j][2]) : false;
                syraElapse.mvt += this.applyCollMvt(data.$mvt[j], oneByOne, options, callback);
            }
        }
        if (nbInsrt > 0) {
            // Second, process last batch insert if any
            if (!(isEmpty = this._$empty) && _updateCollOneByOne(this.data.length, nbInsrt)) {
                // Optimized mode for the insert movements
                syraElapse.mvt += this.applyCollMvt(data.$mvt[ruptInsrt], true, options, callback);
            }
            else {
                // Full update : insert movements + data (with optimization for left list)
                delta = leftListColl ? {} : this.applyMvt(_getMvtCollCode(data.$mvt[ruptInsrt]), data.$mvt[ruptInsrt][1], data.$mvt[ruptInsrt][2]);
                if (data.$rcd && !leftListColl) {
                    this.storeDataColl(data.$rcd, commit);
                    collMvt = this.data;
                    if (this.data.length != data.$rcd.length) {
                        _.each(data.$rcd, function(rcd, idx){
                            if (delta.uuidInserted.hasOwnProperty(rcd.$uuid)) {
                                delete delta.uuidInserted[rcd.$uuid];
                            }
                        });
                        _.each(delta.uuidInserted, function(value, key){
                            data.$rcd.push(delta.mvtData[value]);
                        });
                        collMvt = this.data.length === data.$rcd.length ? this.data : data.$rcd;
                    }
                }
                collMvt = !collMvt ? (data.$rcd || delta.mvtData) : collMvt;
                fullUpdate = leftListColl || collMvt.length == this.data.length || collMvt.length == 1 ? false : true;
                syraElapse.data += callback(collMvt, {"$isPartialDelta": fullUpdate});
                _razIndexPropr(this.data);
                updated = true;
            }
        }
        if (data.$rcd && !updated) {
            // Finally updata data if necessary
            if (this.storeDataColl(data.$rcd, commit) && !leftListColl && data.$rcd.length !== this.data.length) {
                // By delta
                syraElapse.data += callback(data.$rcd, {"$isPartialDelta": data.$rcd.length > 1 ? true : false});
            }
            else {
                // Full
                syraElapse.data += callback(leftListColl ? data.$rcd : this.data, {"$isPartialDelta": false});
            }
            _razIndexPropr(this.data);
        }
        return syraElapse;
    },
    
    applyCollMvt: function(mvt, oneByOne, options, callback){
        var mvtCode = _getMvtCollCode(mvt), delta, lenCollBefore = this.data.length, lenCollAfter, collMvt, isDelta, syraElapse = 0, partialDelta = true;
        // Init
        if (mvtCode == sapUtil.dataSetMvt.del && !oneByOne && lenCollBefore - mvt[2] > 1) {
            //Obsolete
            //collMvt = this._fillTemplateColl();
        }
        // Apply dataset mvt
        delta = this.applyMvt(mvtCode, mvt[1], mvt[2]);
        lenCollAfter = this.data.length;
        // Bind
        if (mvtCode === sapUtil.dataSetMvt.delAll || (lenCollAfter === 0 && mvtCode === sapUtil.dataSetMvt.del)) {
            syraElapse += callback([], {"$isPartialDelta": false});
        }
        else if (lenCollAfter == 1 && mvtCode == sapUtil.dataSetMvt.del) {
                // Optimisation in Syracuse protocole...
                delete this.data[0].$index;
                syraElapse += callback([this.data[0]], {"$isPartialDelta": false});
        }
        else {
            if (oneByOne) {
                _.each(delta.mvtData, function(rcd){
                    syraElapse += callback([rcd], {"$isPartialDelta": false});
                });
            }
            else {
                collMvt = delta.mvtData;
                if (mvtCode == sapUtil.dataSetMvt.insrt) {
                    if (delta.isEmpty) {
                        collMvt = this.data;
                        partialDelta = false;
                    }
                }
                syraElapse += callback(collMvt, {"$isPartialDelta": partialDelta});
                if (!partialDelta) {
                    _razIndexPropr(this.data);
                }
            }
        }
        return syraElapse;
    },
    
    applyMvt: function(mvt, start, count){
        var result = {"mvtData": [], "isDelta": true, "isEmpty": false, "uuidInserted": {}}, i, j, bAtEnd, len = this.data.length, _uuid;
        // Update data
        if (mvt == sapUtil.dataSetMvt.delAll) {
            result.mvtData = [];
            result.isDelta = false;
            result.delAll = true;
            this._$frag = false;
            this._$empty = true;
            delete this.data;
            this.data = [];
        }
        else if (mvt == sapUtil.dataSetMvt.del) {
            bAtEnd = (start - 1) + count >= len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1; i < start - 1 + count; i++) {
                if (len > i) {
                    this.data[i].$isDeleted = true;
                }
            }
            result.mvtData = this.data.splice(start - 1, count);
            result.mvtMeta = bAtEnd ? null : [mvt, start - 1, count];
        }
        else {
            // So, insert ...
            this._$empty = false;
            bAtEnd = start > len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1, j = 0; i < start - 1 + count; i++) {
                _uuid = this._$frag ? helpers.uuid.generate() : this.data.length;
                this.data.splice(i, 0, {"$uuid": _uuid});
                result.mvtData.push({"$uuid": _uuid, "$index": i});
                result.uuidInserted[_uuid] = j++;
            }
            result.mvtMeta = [mvt, start - 1, count];
        }
        result.isEmpty = this._$empty;
        // Cleanup meta data
        this._cleanupMetaColl(mvt, start, count, this._$empty || start >= this.data.length);
        
        return result;
    },
    
    storeDataColl: function(newData, commit){
        var isDelta = false, i;
        if (!commit) {
            isDelta = !this._$empty;
        }
        if (this._$empty) {
            if (commit) {
                this.data = util.duplicateObj(newData);
            }
        }
        else {
            isDelta = commit ? true : isDelta;
            try {
            _.each(newData, function(rcd, idx){
                i = rcd.$uuid;
                delete rcd.$uuid;
                if (commit) {
                    for (var prop in rcd) {
                        this.data[i][prop] = rcd[prop];
                    }
                }
                rcd.$index = i;
                rcd.$uuid = this.data[i].$uuid;
            }, this);
            }
            catch (ex) {
                // TODO : remove this try/catch once server issue will be fixed. 
                alert ("Server issue : array index out of bound for entity " + this.entityName);
            }
        }
        this._$empty = false;
        return isDelta;
    },
    
    storeMetaColl: function(newMeta){
        _hackBugWebSrv(newMeta, this.entityName);
        var found, gridInst, i, len;
        _.each(newMeta, function(newMetaColl, type){
            if (this.meta[type].length > 0) {
                _.each(newMetaColl, function(newMeta){
                    // Clean-up old metas
                    gridInst = sapUtil.isBlockInst(newMeta[0]);
                    if (_datasetK.metaGridRules[type].gridScope && (gridInst && newMeta[1] == 0)) {
                        // If grid Scope : purge All
                        delete this.meta[type];
                        this.meta[type] = [];
                    }
                    else if (_datasetK.metaGridRules[type].purge) {
                        // Avoid to apply same meta twice!
                        found = util.arrayFind(this.meta[type], function(metaStored){
                            return metaStored[0] == newMeta[0] && metaStored[1] == newMeta[1] && metaStored[2] == newMeta[2] ? true : false;
                        });
                        if (found >= 0) {
                            this.meta[type].splice(found, 1);
                        }
                    }
                    if (this.meta[type].length > 0 && !gridInst && newMeta[1] == 0) {
                        // If column scope : purge all cells impacted for this column
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                            if (this.meta[type][i][0] == newMeta[0]) {
                                this.meta[type].splice(i, 1);
                            }
                        }
                    }
                    else if (this.meta[type].length > 0 && gridInst && _datasetK.metaGridRules[type].lineScope && newMeta[1] > 0) {
                        // If line scope : purge all cells impacted
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                            if (this.meta[type][i][1] == newMeta[1]) {
                                this.meta[type].splice(i, 1);
                            }
                        }
                    }
                    // Store new meta
                    this.meta[type].push(newMeta);
                }, this);
            }
            else {
                this.meta[type] = util.duplicateObj(newMetaColl);
            }
        }, this);
    },
    
    _cleanupMetaColl: function(mvt, start, count, insertAtEnd){
        var i, len;
        _.each(this.meta, function(metaColl, type){
            if ((len = metaColl.length) > 0) {
                for (i = len - 1; i >= 0; i--) {
                    if (mvt == sapUtil.dataSetMvt.delAll && metaColl[i][1] > 0) {
                        // Remove all none "grid" or "column" scope meta on raz
                        metaColl.splice(i, 1);
                    }
                    else if (mvt == sapUtil.dataSetMvt.del && metaColl[i][1] > 0) {
                        // Modify or delete old "line/cell" scope meta, according to delete range
                        if (metaColl[i][1] >= start && metaColl[i][1] < start + count) {
                            metaColl.splice(i, 1);
                        }
                        else if (metaColl[i][1] >= start + count) {
                            metaColl[i][1] -= count;
                        }
                    }
                    else if (mvt == sapUtil.dataSetMvt.insrt && metaColl[i][1] > start && !insertAtEnd) {
                        // Modify old "line/cell" scope metas, according to insert range
                        metaColl[i][1] += count;
                    }
                }
            }
        }, this);
    },
    
    getMetaColl: function (update, meta, session, options){
        // Get meta-data object according to Syracuse protocol
        var arrayMeta, colMeta, rowMeta, propMember = "$properties", rowMetaMap = {}, ptr;
        // Helper
        function helper(id, property, metaName, metaValue, obj, cellMeta){
            if (!rowMetaMap[id]) {
                rowMetaMap[id] = {};
            }
            ptr = rowMetaMap[id];
            if (cellMeta) {
                if (!rowMetaMap[id][propMember]) {
                    rowMetaMap[id][propMember] = {};
                }
                if (!rowMetaMap[id][propMember][property]) {
                    rowMetaMap[id][propMember][property] = {};
                }
                ptr = rowMetaMap[id][propMember][property];
            }
            if (obj) {
                for (var prop in metaName) {
                    ptr[prop] = metaName[prop];
                }
            }
            else {
                ptr[metaName] = metaValue;
            }
        }
        // Init
        if (!update[propMember]) {
            update[propMember] = {};
        }
        if (!update[propMember][this.entityName]) {
            update[propMember][this.entityName] = {};
        }
        if (!update[propMember][this.entityName].$item) {
            update[propMember][this.entityName].$item = {};
        }
        if (!update[propMember][this.entityName].$item[propMember]) {
            update[propMember][this.entityName].$item[propMember] = {};
        }
        if (!update[this.entityName]) {
            update[this.entityName] = [];
        }
        arrayMeta = update[propMember][this.entityName];
        colMeta = update[propMember][this.entityName].$item[propMember];
        rowMeta = update[this.entityName];
        // Set meta Title     
        _.each(meta[_datasetK.metaType.title], function(tit){
            // Array or col level?
            if (sapUtil.isBlockInst(tit[0])) {
                arrayMeta.$title = tit[2];
            }
            else {
                if (!colMeta[tit[0]]) {
                    colMeta[tit[0]] = {};
                }
                colMeta[tit[0]].$title = tit[2];
            }
        });
        // Set meta Status     
        _.each(meta[_datasetK.metaType.state], function(stt){
            var line = stt[1] - 1, st = sapUtil.getState(stt[2]), ptr = null;
            if (sapUtil.isBlockInst(stt[0])) {
                if (line >= 0) {
                    helper(line, null, st, null, true);
                }
                else {
                    ptr = arrayMeta;
                }
            }
            else {
                if (line >= 0) {
                    helper(line, stt[0], st, null, true, true);
                }
                else {
                    if (!colMeta[stt[0]]) {
                        colMeta[stt[0]] = {};
                    }
                    ptr = colMeta[stt[0]];
                }
            }
            if (ptr) {
                for (var prop in st) {
                    ptr[prop] = st[prop];
                }
            }
        });
        // Set meta Style     
        _.each(meta[_datasetK.metaType.style], function(sty){
            var line = sty[1] - 1, styEx = {}, metaName = "$fieldStyle", ptr = null, styPropr = _datasetK.metaType.style;
            styEx[styPropr] = sty[2];
            if (sapUtil.cureStyle(styEx, this.entityName, session)) {
                if (sapUtil.isBlockInst(sty[0])) {
                    if (line >= 0) {
                        helper(line, null, metaName, styEx[styPropr]);
                    }
                    else {
                        ptr = arrayMeta;
                    }
                }
                else {
                    if (line >= 0) {
                        helper(line, sty[0], metaName, styEx[styPropr], false, true);
                    }
                    else {
                        metaName = "$valueStyle";
                        if (!colMeta[sty[0]]) {
                            colMeta[sty[0]] = {};
                        }
                        ptr = colMeta[sty[0]];
                    }
                }
                if (ptr) {
                    ptr[metaName] = styEx[styPropr];
                }
            }
        }, this);
        // Set meta Disable combo     
        _.each(meta[_datasetK.metaType.dchoise], function(dch){
            // Disable combo only available for cell scope
            var line = dch[1] - 1;
            if(!sapUtil.isBlockInst(dch[0]) && line >= 0) {
               helper(line, dch[0], _datasetK.metaType.dchoise, dch[2], false, true); 
            }
        });
        // Set meta Format
        _.each(meta[_datasetK.metaType.format], function(fmt){
            // For the future...
         }, this);
        // Compute row meta
        _.each(rowMetaMap, function(value, key){
            value.$index = key;
            value.$uuid = this.data.length > 0 ? this.data[key].$uuid : key;
            rowMeta.push(value);
        }, this);
        if(rowMeta.length == 0){
            delete update[this.entityName];
        }
    },

    getCollRcdUUID: function(idx){
        return this.data[idx].$uuid;
    },

    dispose: function(){
        delete this.data;
        delete this.meta;
    }
});