"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Entity dataset store Class
 */

 
var helpers = require('syracuse-core/lib/helpers');
var util = require('syracuse-ui/lib/fusion/tools/util');
var sapUtil = require('./util').Fusion;
var syraUtil = require('./util').Syra;


var _datasetK = {
    "metaGridRules" : {
        "sty": {"gridScope": true, "lineScope": true, "purge": true},
        "tit": {"gridScope": false, "lineScope": false, "purge": true},
        "stt": {"gridScope": true, "lineScope": true, "purge": true},
        "fmt": {"gridScope": false, "lineScope": false, "purge": true},
        "dch": {"gridScope": false, "lineScope": false, "purge": true}
    }
};


/* Entity Store class */
function EntityStore(){
}

exports.EntityStore = helpers.defineClass(EntityStore, null, {
    initialize: function(internalType, isCollection){
        this._isColl = isCollection;
        this.$type = internalType;
        if(isCollection) {
            this.data = [];
            this.meta = {};
            _.each(_datasetK.metaGridRules, function(rule, metaType) {
                this[metaType] = [];
            }, this.meta);
            this._$empty = true;
            this._$frag = false;
        }
        else {
            this.data = {};            
        }
    },

    _fillTemplateColl: function(options) {
        var coll = [];
        for (var i = 0, ii = this.data.length; i < ii; i++){
            coll[i] = {"$uuid": this.data[i].$uuid};
        }
        return coll;
    },

    applyDataColl: function(entityName, data, commit, options, callback){
        var mvtCode, delta, lenCollBefore, lenCollAfter, collMvt, isDelta, syraElapse = {"data": 0, "mvt": 0}, ratio = 200 ;
        if(data.$mvt) {
            // First, apply delete/insert
            _.each(data.$mvt, function(mvt){
                mvtCode = mvt[0] == sapUtil.dataSetMvt.del ? (mvt.length == 1 ? sapUtil.dataSetMvt.delAll : sapUtil.dataSetMvt.del) : sapUtil.dataSetMvt.insrt;
                if(mvtCode == sapUtil.dataSetMvt.del) {
                    collMvt = this._fillTemplateColl();
                }
                lenCollBefore = this.data.length;
                delta = this.applyMvt(mvtCode, mvt[1], mvt[2]);
                lenCollAfter = this.data.length;
                if(mvtCode == sapUtil.dataSetMvt.delAll) {
                    syraElapse.mvt += callback(delta.mvtData);
                }
                else if(lenCollAfter == 1 && mvtCode == sapUtil.dataSetMvt.del) {
                    // Optimisation in Syracuse protocole...
                    syraElapse.mvt += callback([this.data[0]]);
                }
                else if(!delta.isEmpty){
                    if(delta.mvtData.length <= Math.ceil(lenCollBefore/ratio)) {
                        _.each(delta.mvtData, function (rcd) {
                            syraElapse.mvt += callback([rcd]);
                        });
                    }
                    else {
                        if (mvtCode == sapUtil.dataSetMvt.insrt) {
                            collMvt = [];
                            collMvt = this._fillTemplateColl();
                        }
                        _.each(delta.mvtData, function (rcd) {
                            collMvt[rcd.$index] = rcd;
                            delete collMvt[rcd.$index].$index;
                        });
                        syraElapse.mvt += callback(collMvt);
                        collMvt = [];
                   }
                }
            }, this);
        }
        // Update data in dataset
        if(data.$rcd) {
            isDelta = this.storeDataColl(data.$rcd, commit);
            if(!isDelta) {
                syraElapse.data += callback(data.$rcd);
            }
            else {
                lenCollBefore = this.data.length;
                if(data.$rcd.length <= Math.ceil(lenCollBefore/ratio)) {
                    _.each(data.$rcd, function (rcd) {
                        syraElapse.data += callback([rcd]);
                    });
                }
                else {
                    collMvt = this._fillTemplateColl();
                    _.each(data.$rcd, function (rcd, idx) {
                        collMvt[rcd.$index] = rcd;
                        delete collMvt[rcd.$index].$index;
                    });
                    syraElapse.data += callback(collMvt);
                    collMvt = [];
               }
           }
        }
        return syraElapse; 
    },

    applyMvt: function(mvt, start, count){
        var result = {"mvtData": [], "isDelta": true, "isEmpty": false}, i, bAtEnd, len = this.data.length, _uuid;
        // Update data
        if(mvt == sapUtil.dataSetMvt.delAll) {
            result.mvtData = [];
            result.isDelta = false;
            result.delAll = true;
            this._$frag = false;
            this._$empty = true;
            delete this.data;
            this.data = [];
        }
        else if (mvt == sapUtil.dataSetMvt.del) {
            bAtEnd = (start - 1) + count >= len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1; i < start - 1 + count; i++) {
                if(len > i) {
                    this.data[i].$isDeleted = true;
                    this.data[i].$index = i;
                }
            }
            result.mvtData = this.data.splice (start - 1, count);
            result.mvtMeta = bAtEnd ? null : [mvt, start - 1, count];
        }
        else if (!this._$empty){
            // So, insert in a filled collection
            bAtEnd = start > len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1; i < start - 1 + count; i++) {
                _uuid = this._$frag ? helpers.uuid.generate() : this.data.length;
                this.data.splice (i, 0, {"$uuid": _uuid});
                result.mvtData.push({"$uuid": _uuid, "$index": i});
            }
            result.mvtMeta = [mvt, start - 1, count];
        }
        result.isEmpty = this._$empty;
        // Cleanup meta data
        this._cleanupMetaColl(mvt, start, count, this._$empty || start >= this.data.length);

        return result;
    },

    storeDataColl: function(newData, commit){
        var isDelta = false, i;
        if(!commit) {
            return !this._$empty;
        }
        if(this._$empty) {
            this.data = util.duplicateObj(newData);
        }
        else {
            isDelta = true;
            _.each(newData, function(rcd, idx){
                i = rcd.$uuid;
                delete rcd.$uuid;
                for (var prop in rcd) {
                     this.data[i][prop] = rcd[prop];
                }
                rcd.$index = i;
                rcd.$uuid = this.data[i].$uuid;
            }, this);
        }
        this._$empty = false;
        return isDelta;
    },

    storeMetaColl: function(newMeta){
        var found, gridInst, i, len;
        _.each(newMeta, function(newMetaColl, type){
            if(this.meta[type].length > 0) {
                _.each(newMetaColl, function(newMeta){
                    // Clean-up old metas
                    gridInst = sapUtil.isBlockInst(newMeta[0]);
                    if(_datasetK.metaGridRules[type].gridScope && (gridInst && newMeta[1] == 0)) {
                        // If grid Scope : purge All
                        delete this.meta[type];
                        this.meta[type] = [];
                    }
                    else if(_datasetK.metaGridRules[type].purge) {
                        // Avoid to apply same meta twice!
                        found = util.arrayFind(this.meta[type], function(metaStored) {
                            return metaStored[0] == newMeta[0] && metaStored[1] == newMeta[1] && metaStored[2] == newMeta[2] ? true : false;
                        });
                        if(found >= 0) {
                           this.meta[type].splice(found, 1);
                        }
                    }
                    if(this.meta[type].length > 0 && !gridInst && newMeta[1] == 0) {
                        // If column scope : purge all cells impacted for this column
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                           if(this.meta[type][i][0] == newMeta[0]) {
                               this.meta[type].splice(i, 1);
                           }
                        }
                   }
                   else if(this.meta[type].length > 0 && gridInst && _datasetK.metaGridRules[type].lineScope && newMeta[1] > 0) {
                        // If line scope : purge all cells impacted
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                           if(this.meta[type][i][1] == newMeta[1]) {
                               this.meta[type].splice(i, 1);
                           }
                        }  
                   }
                   // Store new meta
                   this.meta[type].push(newMeta);
                }, this);
            }
            else {
                this.meta[type] = util.duplicateObj(newMetaColl);
            }
        }, this);       
    },

    _cleanupMetaColl: function(mvt, start, count, insertAtEnd){
        var i, len;
        _.each(this.meta, function(metaColl, type){
            if((len = metaColl.length) > 0) {
                for (i = len - 1; i >= 0; i--) {
                    if(mvt == sapUtil.dataSetMvt.delAll && metaColl[i][1] > 0 ) {
                        // Remove all none "grid" or "column" scope meta on raz
                        metaColl.splice(i, 1);    
                    }
                    else if (mvt == sapUtil.dataSetMvt.del && metaColl[i][1] > 0) {
                        // Modify or delete old "line/cell" scope metas, according to delete range
                        if(metaColl[i][1] >= start && metaColl[i][1] < start + count) {
                            metaColl.splice(i, 1);
                        }
                        else if( metaColl[i][1] >= start + count) {
                            metaColl[i][1] -= count;
                        }
                    }
                    else if(mvt == sapUtil.dataSetMvt.insrt && metaColl[i][1] > start && !insertAtEnd) {
                        // Modify old "line/cell" scope metas, according to insert range
                        metaColl[i][1] += count;
                    }
                }
            }
        }, this);
    },

    dispose: function(){
        delete this.data;
        delete this.meta;
    }
});