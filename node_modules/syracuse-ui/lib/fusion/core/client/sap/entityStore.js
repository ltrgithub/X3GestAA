"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Entity dataset store Class
 */


var helpers = require('syracuse-core/lib/helpers');
var util = require('syracuse-ui/lib/fusion/tools/util');
var sapUtil = require('./util').Fusion;
var syraUtil = require('./util').Syra;
var formatter = require('syracuse-ui/lib/fusion/core/client/sap/format');
var KisTypeAcceptFmt = formatter.isTypeAcceptFmt;
var KisTypeAcceptFmtED = formatter.isTypeAcceptFmtED;

var _datasetK = {
    "metaType": {"style": "sty", "title": "tit", "state": "stt", "format": "fmt", "dchoise": "dch"},
    "metaGridRules": {}
};
_datasetK.metaGridRules[_datasetK.metaType.style] = {"gridScope": true, "lineScope": true, "purge": true};
_datasetK.metaGridRules[_datasetK.metaType.title] = {"gridScope": false, "lineScope": false, "purge": true};
_datasetK.metaGridRules[_datasetK.metaType.state] = {"gridScope": true, "lineScope": true, "purge": true};
_datasetK.metaGridRules[_datasetK.metaType.format] = {"gridScope": false, "lineScope": false, "purge": true};
_datasetK.metaGridRules[_datasetK.metaType.dchoise] = {"gridScope": false, "lineScope": false, "purge": true};


function _updateCollOneByOne(nLenColl, nbMvt){
    var ratio = 10, threshold = 15;
    //With "$isPartialDelta" mode, is not longer necessary to apply change record by record ==> TODO : remove
    //return !!(nbMvt <= Math.ceil(nLenColl/ratio) && nbMvt <= threshold);
    return false;
}
function _getMvtCollCode(mvt){
    return mvt[0] == sapUtil.dataSetMvt.del ? (mvt.length == 1 ? sapUtil.dataSetMvt.delAll : sapUtil.dataSetMvt.del) : sapUtil.dataSetMvt.insrt;
}
function _razIndexPropr(data){
    // To remove... but for now how the Syra framework add "$index" while processing records... it's nessasry to clean-up
    if (data.length > 0 && data[0].hasOwnProperty("$index")) {
        _.each(data, function(value){
            delete value.$index;
        });
    }
}
function _hackBugWebSrv(meta, entityName){
    _.each(meta, function (metaCat, name) {
        _.each(metaCat, function (value) {
            if(name != "dch") {
                value[0] = value[0].substring(1);
            }
            else {
                value[0] = entityName.substring(0, 1) + value[0];
                value[2] = value[2] != null ? value[2].toString(10) : null;
            }
        });
    });
}


/* Entity Store class */
function EntityStore(){
}

exports.EntityStore = helpers.defineClass(EntityStore, null, {
    initialize: function(internalType, isCollection, name, proto, formatterW, opts){
        this._isColl = isCollection;
        this.$type = internalType;
        this.realType = internalType;
        this.entityName = name;
        this._isNodeWS = opts && opts.isNodeWS;
        this._fmtWrapper = formatterW;
        this._proto = proto;
        return this.initStore(opts ? opts.locales : null);
    },

    initStore: function(regOpts){
        var KfmtMeta = _datasetK.metaType.format, itemsProps, i, len, itemsPropsArray, entityType, protoFmt, refProp, ret = null;
        var defFmt, KdefFmt = "", KdefDateFmt = "D:" + ((regOpts ? regOpts.dateFormat : null) || "MM[/]DD[/]YY");
        if (this._isColl) {
            this.data = [];
            this.meta = {};
            this.metaFmt = {};
            _.each(_datasetK.metaGridRules, function(rule, metaType){
                this[metaType] = [];
            }, this.meta);
            this._$empty = true;
            this._$frag = false;
            // Set default format for each properties
            if(this._fmtWrapper && this._proto.$item && (itemsProps = this._proto.$item.$properties)) {
                itemsPropsArray = Object.keys(itemsProps);
                for (i = 0, len = itemsPropsArray.length; i < len; i++) {
                    entityType = itemsProps[itemsPropsArray[i]].$type;
                    protoFmt = itemsProps[itemsPropsArray[i]].$X3Fmt;
                    if(entityType == syraUtil.dataTypes.reference && (refProp = syraUtil.getRefPropertyEntity(itemsProps[itemsPropsArray[i]]))) {
                        entityType = refProp.proto.$type;
                        protoFmt = refProp.proto.$X3Fmt;
                    }
                    if(KisTypeAcceptFmt[entityType]) {
                        defFmt = !protoFmt && entityType == syraUtil.dataTypes.dateType ? KdefDateFmt : KdefFmt;
                        if(protoFmt || defFmt) {
                            this.metaFmt[itemsPropsArray[i]] = {"fmt": protoFmt || defFmt, "cellsSet": false, "_fmtEmpty": !!KisTypeAcceptFmtED[entityType], "realType": entityType};
                        }
                    }
                }
            }
        }
        else {
            this.data = {};
            entityType = this.$type;
            protoFmt = this._proto.$X3Fmt;
            if(entityType == syraUtil.dataTypes.reference && (refProp = syraUtil.getRefPropertyEntity(this._proto))) {
                entityType = refProp.proto.$type;
                this.realType = entityType;
                protoFmt = refProp.proto.$X3Fmt;
                if(refProp.propTitle) {
                    ret = {"refTitle": {"name": refProp.propTitle, "refField": this}};
                }
            }
            if(this._fmtWrapper && KisTypeAcceptFmt[entityType]) {
                defFmt = !protoFmt && entityType == syraUtil.dataTypes.dateType ? KdefDateFmt : defFmt;
                this.data[KfmtMeta] = protoFmt || defFmt;
                this.data._fmtEmpty = !!KisTypeAcceptFmtED[entityType];
            }
        }
        return ret;
    },

    releaseStore: function(){
        delete this.data;
        delete this.meta;
        delete this.metaFmt;
    },

    _fillTemplateColl: function(options){
        var coll = [];
        for (var i = 0, ii = this.data.length; i < ii; i++) {
            coll[i] = {"$uuid": this.data[i].$uuid};
        }
        return coll;
    },
    
    applyDataCollEx: function(data, commit, options, callback){
        var isEmpty, ruptInsrt = null, nbMvt = data.$mvt ? data.$mvt.length : 0, i = nbMvt - 1, j, nbInsrt = 0, delta, updated = false, oneByOne;
        var leftListColl = options && options.lf, collMvt = null, partialUpdate, syraElapse = {"data": 0, "mvt": 0};
        var meta = data.$meta, metaFmtObj = this._fmtWrapper && meta && meta[_datasetK.metaType.format] ? meta[_datasetK.metaType.format] : null;
        if (i >= 0 && data.$mvt[i][0] == sapUtil.dataSetMvt.insrt) {
            ruptInsrt = i;
            nbInsrt = data.$mvt[i][2];
        }
        ruptInsrt = ruptInsrt !== null ? ruptInsrt : nbMvt;
        if (ruptInsrt > 0) {
            // First, apply batch movements if any (del, insert or del all)
            for (j = 0; j < ruptInsrt; j++) {
                oneByOne = data.$mvt[j].length > 2 ? _updateCollOneByOne(this.data.length, data.$mvt[j][2]) : false;
                syraElapse.mvt += this.applyCollMvt(data.$mvt[j], oneByOne, options, callback);
            }
        }
        if (nbInsrt > 0) {
            // Second, process last batch insert if any
            if (!(isEmpty = this._$empty) && _updateCollOneByOne(this.data.length, nbInsrt)) {
                // Optimized mode for the insert movements
                syraElapse.mvt += this.applyCollMvt(data.$mvt[ruptInsrt], true, options, callback);
            }
            else {
                // Full update : insert movements + data (with optimization for left list)
                delta = leftListColl ? {} : this.applyMvt(_getMvtCollCode(data.$mvt[ruptInsrt]), data.$mvt[ruptInsrt][1], data.$mvt[ruptInsrt][2]);
                if (data.$rcd) {
                    if(metaFmtObj) {
                        // Need to update meta "format" before!
                        this.storeMetaFmtColl(metaFmtObj);
                        metaFmtObj = null;
                    }
                    this._storeDataColl(data.$rcd, commit, options);
                    if(!leftListColl) {
                        collMvt = this.data;
                        if (this.data.length != data.$rcd.length) {
                            // Need to push inserted record without correspondence in object $rcd.data
                            _.each(data.$rcd, function(rcd, idx){
                                if (delta.uuidInserted.hasOwnProperty(rcd.$uuid)) {
                                    delete delta.uuidInserted[rcd.$uuid];
                                }
                            });
                            _.each(delta.uuidInserted, function(value, key){
                                data.$rcd.push(delta.mvtData[value]);
                            });
                            collMvt = this.data.length === data.$rcd.length ? this.data : data.$rcd;
                        }
                    }
                }
                collMvt = !collMvt ? (data.$rcd || delta.mvtData) : collMvt;
                partialUpdate = leftListColl || collMvt.length == this.data.length || collMvt.length == 1 ? false : true;
                syraElapse.data += callback(collMvt, {"$isPartialDelta": partialUpdate});
                _razIndexPropr(this.data);
                updated = true;
            }
        }
        // Be sure to store meta "format"... if not already done!
        if(metaFmtObj) {
            this.storeMetaFmtColl(metaFmtObj);
        }
        // Finally updata data if necessary
        if (data.$rcd && !updated) {
            if (this._storeDataColl(data.$rcd, commit, options) && !leftListColl && data.$rcd.length !== this.data.length) {
                // By delta
                syraElapse.data += callback(data.$rcd, {"$isPartialDelta": data.$rcd.length > 1 ? true : false});
            }
            else {
                // Full
                syraElapse.data += callback(leftListColl ? data.$rcd : this.data, {"$isPartialDelta": false});
            }
            _razIndexPropr(this.data);
        }
        return syraElapse;
    },
    
    applyCollMvt: function(mvt, oneByOne, options, callback){
        var mvtCode = _getMvtCollCode(mvt), delta, lenCollBefore = this.data.length, lenCollAfter, collMvt, isDelta, syraElapse = 0, partialDelta = true;
        // Apply dataset mvt
        delta = this.applyMvt(mvtCode, mvt[1], mvt[2]);
        lenCollAfter = this.data.length;
        // Bind
        if (mvtCode === sapUtil.dataSetMvt.delAll || (lenCollAfter === 0 && mvtCode === sapUtil.dataSetMvt.del)) {
            syraElapse += callback([], {"$isPartialDelta": false});
        }
        else if (lenCollAfter == 1 && mvtCode == sapUtil.dataSetMvt.del) {
                // Optimisation in Syracuse protocole...
                delete this.data[0].$index;
                syraElapse += callback([this.data[0]], {"$isPartialDelta": false});
        }
        else {
            if (oneByOne) {
                _.each(delta.mvtData, function(rcd){
                    syraElapse += callback([rcd], {"$isPartialDelta": false});
                });
            }
            else {
                collMvt = delta.mvtData;
                if (mvtCode == sapUtil.dataSetMvt.insrt) {
                    if (delta.isEmpty) {
                        collMvt = this.data;
                        partialDelta = false;
                    }
                }
                syraElapse += callback(collMvt, {"$isPartialDelta": partialDelta});
                if (!partialDelta) {
                    _razIndexPropr(this.data);
                }
            }
        }
        return syraElapse;
    },
    
    applyMvt: function(mvt, start, count){
        var result = {"mvtData": [], "isDelta": true, "isEmpty": false, "uuidInserted": {}}, i, j, bAtEnd, len = this.data.length, _uuid;
        var ii, lenii, propsWithFmt, _$raw;
        // Update data
        if (mvt == sapUtil.dataSetMvt.delAll) {
            result.mvtData = [];
            result.isDelta = false;
            result.delAll = true;
            this._$frag = false;
            this._$empty = true;
            delete this.data;
            this.data = [];
        }
        else if (mvt == sapUtil.dataSetMvt.del) {
            bAtEnd = (start - 1) + count >= len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1; i < start - 1 + count; i++) {
                if (len > i) {
                    this.data[i].$isDeleted = true;
                }
            }
            result.mvtData = this.data.splice(start - 1, count);
            result.mvtMeta = bAtEnd ? null : [mvt, start - 1, count];
        }
        else {
            // So, insert ...
            this._$empty = false;
            bAtEnd = start > len;
            this._$frag = (this._$frag || !bAtEnd) ? true : this._$frag;
            for (i = start - 1, j = 0; i < start - 1 + count; i++) {
                _uuid = this._$frag ? helpers.uuid.generate() : this.data.length;
                this.data.splice(i, 0, {"$uuid": _uuid});
                if(this._fmtWrapper) {
                    // Init raw data management object
                    _$raw = this.data[i].$rawV = {};
                    propsWithFmt = Object.keys(this.metaFmt);
                    for (ii = 0, lenii = propsWithFmt.length; ii < lenii; ii++) {
                        _$raw[propsWithFmt[ii]] = {};
                    }
                }
                result.mvtData.push({"$uuid": _uuid, "$index": i});
                result.uuidInserted[_uuid] = j++;
            }
            result.mvtMeta = [mvt, start - 1, count];
        }
        result.isEmpty = this._$empty;
        // Cleanup meta data
        this._cleanupMetaColl(mvt, start, count, this._$empty || start >= this.data.length);
        
        return result;
    },
    
    _storeDataColl: function(newData, commit, options){
        var isDelta = false, jd, lend, len, rcdArray, i, j, dataFmt, niemeDataPtr, skip, yetFormatted, rawValueEx;
        if (!commit) {
            isDelta = !this._$empty;
        }
        if (this._$empty && !this._fmtWrapper) {
            if (commit) {
                this.data = util.duplicateObj(newData);
            }
        }
        else {
            isDelta = commit && !this._$empty ? true : isDelta;
            try {
            for (jd = 0, lend = newData.length; jd < lend; jd++) {
                i = newData[jd].$uuid;
                delete newData[jd].$uuid;
                niemeDataPtr = this.data[i];
                if (commit || this._fmtWrapper) {
                    rcdArray = Object.keys(newData[jd]);
                    for (j = 0, len = rcdArray.length; j < len; j++) {
                        if(!this._fmtWrapper || !(dataFmt = this.getMetaFmtColl(rcdArray[j], i))) {
                            if(commit) {
                                niemeDataPtr[rcdArray[j]] = newData[jd][rcdArray[j]];
                            }
                        }
                        else {
                            skip = !newData[jd][rcdArray[j]] && !this.metaFmt[rcdArray[j]]._fmtEmpty;
                            if((yetFormatted = (options && options.formatted)) && commit) {
                                rawValueEx = this._fmtWrapper.unformat(newData[jd][rcdArray[j]], this.metaFmt[rcdArray[j]].realType, dataFmt, true);
                            }
                            try {
                                if(commit) {
                                    niemeDataPtr[rcdArray[j]] = skip || yetFormatted ? newData[jd][rcdArray[j]] : this._fmtWrapper.formatter.formatField({"format": dataFmt}, newData[jd][rcdArray[j]], true, false);
                                    niemeDataPtr.$rawV[rcdArray[j]].v = yetFormatted && rawValueEx.succeeded ? rawValueEx.raw : newData[jd][rcdArray[j]];
                                    if(!skip && !yetFormatted) {
                                        newData[jd][rcdArray[j]] = niemeDataPtr[rcdArray[j]];
                                    }
                                }
                                else {
                                    if (!skip && !yetFormatted){
                                        newData[jd][rcdArray[j]] = this._fmtWrapper.formatter.formatField({"format": dataFmt}, newData[jd][rcdArray[j]], true, false);
                                    }
                                }
                            }
                            catch (e){
                                if(commit) {
                                    niemeDataPtr[rcdArray[j]] = newData[jd][rcdArray[j]];
                                    niemeDataPtr.$rawV[rcdArray[j]].v = newData[jd][rcdArray[j]];
                                }
                            }
                        }
                    }
                }
                newData[jd].$index = i;
                newData[jd].$uuid = niemeDataPtr.$uuid;
            }
            }
            catch (ex) {
                // TODO : remove this try/catch once server issue will be fixed. 
                alert ("Server issue : array index out of bound for entity " + this.entityName);
            }
        }
        this._$empty = false;
        return isDelta;
    },
    
    storeMetaColl: function(newMeta){
        if(this._isNodeWS !== true) {
            _hackBugWebSrv(newMeta, this.entityName);
        }
        var found, gridInst, i, len;
        _.each(newMeta, function(newMetaColl, type){
            if (this.meta[type].length > 0) {
                _.each(newMetaColl, function(newMeta){
                    // Clean-up old metas
                    gridInst = sapUtil.isBlockInst(newMeta[0]);
                    if (_datasetK.metaGridRules[type].gridScope && (gridInst && newMeta[1] == 0)) {
                        // If grid Scope : purge All
                        delete this.meta[type];
                        this.meta[type] = [];
                    }
                    else if (_datasetK.metaGridRules[type].purge) {
                        // Avoid to apply same meta twice!
                        found = util.arrayFind(this.meta[type], function(metaStored){
                            return metaStored[0] == newMeta[0] && metaStored[1] == newMeta[1] && metaStored[2] == newMeta[2] ? true : false;
                        });
                        if (found >= 0) {
                            this.meta[type].splice(found, 1);
                        }
                    }
                    if (this.meta[type].length > 0 && !gridInst && newMeta[1] == 0) {
                        // If column scope : purge all cells impacted for this column
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                            if (this.meta[type][i][0] == newMeta[0]) {
                                this.meta[type].splice(i, 1);
                            }
                        }
                    }
                    else if (this.meta[type].length > 0 && gridInst && _datasetK.metaGridRules[type].lineScope && newMeta[1] > 0) {
                        // If line scope : purge all cells impacted
                        len = this.meta[type];
                        for (i = len - 1; i >= 0; i--) {
                            if (this.meta[type][i][1] == newMeta[1]) {
                                this.meta[type].splice(i, 1);
                            }
                        }
                    }
                    // Store new meta
                    this.meta[type].push(newMeta);
                }, this);
            }
            else {
                this.meta[type] = util.duplicateObj(newMetaColl);
            }
        }, this);
    },
    
    _cleanupMetaColl: function(mvt, start, count, insertAtEnd){
        var i, len;
        _.each(this.meta, function(metaColl, type){
            if ((len = metaColl.length) > 0) {
                for (i = len - 1; i >= 0; i--) {
                    if (mvt == sapUtil.dataSetMvt.delAll && metaColl[i][1] > 0) {
                        // Remove all none "grid" or "column" scope meta on raz
                        metaColl.splice(i, 1);
                    }
                    else if (mvt == sapUtil.dataSetMvt.del && metaColl[i][1] > 0) {
                        // Modify or delete old "line/cell" scope meta, according to delete range
                        if (metaColl[i][1] >= start && metaColl[i][1] < start + count) {
                            metaColl.splice(i, 1);
                        }
                        else if (metaColl[i][1] >= start + count) {
                            metaColl[i][1] -= count;
                        }
                    }
                    else if (mvt == sapUtil.dataSetMvt.insrt && metaColl[i][1] > start && !insertAtEnd) {
                        // Modify old "line/cell" scope metas, according to insert range
                        metaColl[i][1] += count;
                    }
                }
            }
        }, this);
    },

    getMetaByCriteria: function(type, target, level) {
        var ret = null, isRow = false, isCell = false, isLine = false, isGrid = false, isHeader = false, len, i, isFieldMeta, meta, found = false;
        if(this._isColl) {
            if(this.meta[type] && this.meta[type].length > 0) {
                // Target?
                isRow = target && !sapUtil.isBlockInst(target);
                if(isRow) {
                    isCell = level > 0 ? true : false;
                    isRow = !isCell;
                }
                else if (target) {
                    isLine = level > 0 ? true : false;
                    isGrid = !isLine && level == 0 ? true : false;
                    isHeader = !isLine && level == -1 ? true : false;
                }
                // Compute
                ret = isHeader ? {} : null;
                for (i = 0, len = this.meta[type].length; i < len; i++) {
                    meta = this.meta[type][i];
                    isFieldMeta = !sapUtil.isBlockInst(meta[0]);
                    if(!isFieldMeta && meta[1] == 0 && isGrid){
                        found = true;
                    }
                    else if(!isFieldMeta && meta[1] > 0 && isLine){
                        found = true;
                    }
                    else if(isFieldMeta && meta[1] == 0 && isRow) {
                        found = true;
                    }
                    else if(isFieldMeta && meta[1] > 0 && isCell) {
                        found = true;
                    }
                    else if(isFieldMeta && meta[1] == 0 && isHeader) {
                        ret[meta[0]] = meta[2];
                    }
                    if(found) {
                        ret = meta[2];
                        break;
                    }
                }
            }
        }
        else {
            ret = this[type];
        }
        return ret;
    },
    
    getMetaColl: function (update, meta, session, options){
        // Get meta-data object (except format) according to Syracuse protocol 
        var arrayMeta, colMeta, rowMeta, propMember = "$properties", rowMetaMap = {}, ptr;
        // Helper
        function helper(id, property, metaName, metaValue, obj, cellMeta){
            if (!rowMetaMap[id]) {
                rowMetaMap[id] = {};
            }
            ptr = rowMetaMap[id];
            if (cellMeta) {
                if (!rowMetaMap[id][propMember]) {
                    rowMetaMap[id][propMember] = {};
                }
                if (!rowMetaMap[id][propMember][property]) {
                    rowMetaMap[id][propMember][property] = {};
                }
                ptr = rowMetaMap[id][propMember][property];
            }
            if (obj) {
                for (var prop in metaName) {
                    ptr[prop] = metaName[prop];
                }
            }
            else {
                ptr[metaName] = metaValue;
            }
        }
        // Init
        if (!update[propMember]) {
            update[propMember] = {};
        }
        if (!update[propMember][this.entityName]) {
            update[propMember][this.entityName] = {};
        }
        if (!update[propMember][this.entityName].$item) {
            update[propMember][this.entityName].$item = {};
        }
        if (!update[propMember][this.entityName].$item[propMember]) {
            update[propMember][this.entityName].$item[propMember] = {};
        }
        if (!update[this.entityName]) {
            update[this.entityName] = [];
        }
        arrayMeta = update[propMember][this.entityName];
        colMeta = update[propMember][this.entityName].$item[propMember];
        rowMeta = update[this.entityName];
        // Set meta Title     
        _.each(meta[_datasetK.metaType.title], function(tit){
            // Array or col level?
            if (sapUtil.isBlockInst(tit[0])) {
                arrayMeta.$title = tit[2];
            }
            else {
                if (!colMeta[tit[0]]) {
                    colMeta[tit[0]] = {};
                }
                colMeta[tit[0]].$title = tit[2];
            }
        });
        // Set meta Status     
        _.each(meta[_datasetK.metaType.state], function(stt){
            var line = stt[1] - 1, st = sapUtil.getState(stt[2]), ptr = null;
            if (sapUtil.isBlockInst(stt[0])) {
                if (line >= 0) {
                    helper(line, null, st, null, true);
                }
                else {
                    ptr = arrayMeta;
                }
            }
            else {
                if (line >= 0) {
                    helper(line, stt[0], st, null, true, true);
                }
                else {
                    if (!colMeta[stt[0]]) {
                        colMeta[stt[0]] = {};
                    }
                    ptr = colMeta[stt[0]];
                }
            }
            if (ptr) {
                for (var prop in st) {
                    ptr[prop] = st[prop];
                }
            }
        });
        // Set meta Style     
        _.each(meta[_datasetK.metaType.style], function(sty){
            var line = sty[1] - 1, styEx = {}, metaName = "$valueStyle", ptr = null, styPropr = _datasetK.metaType.style;
            styEx[styPropr] = sty[2];
            if (sapUtil.cureStyle(styEx, this.entityName, session)) {
                if (sapUtil.isBlockInst(sty[0])) {
                    if (line >= 0) {
                        helper(line, null, metaName, styEx[styPropr]);
                    }
                    else {
                        ptr = arrayMeta;
                    }
                }
                else {
                    if (line >= 0) {
                        helper(line, sty[0], metaName, styEx[styPropr], false, true);
                    }
                    else {
                         if (!colMeta[sty[0]]) {
                            colMeta[sty[0]] = {};
                        }
                        ptr = colMeta[sty[0]];
                    }
                }
                if (ptr) {
                    ptr[metaName] = styEx[styPropr];
                }
            }
        }, this);
        // Set meta Disable combo     
        _.each(meta[_datasetK.metaType.dchoise], function(dch){
            // Disable combo only available for cell scope
            var line = dch[1] - 1;
            if(!sapUtil.isBlockInst(dch[0]) && line >= 0) {
               helper(line, dch[0], _datasetK.metaType.dchoise, dch[2], false, true); 
            }
        });
        // Compute row meta
        _.each(rowMetaMap, function(value, key){
            value.$index = key;
            value.$uuid = this.data.length > 0 ? this.data[key].$uuid : key;
            rowMeta.push(value);
        }, this);
        if(rowMeta.length == 0){
            delete update[this.entityName];
        }
    },

    storeMetaFmtColl: function(metaFmtArray){
        var i, j, len = metaFmtArray ? metaFmtArray.length : 0, meta, lenj, _$raw, metaFmtProp;
        for (i = 0; i < len; i++) {
            meta = metaFmtArray[i];
            metaFmtProp = this.metaFmt[meta[0]];
            if(meta[1] == 0 && metaFmtProp) {
                // Col scope
                metaFmtProp.fmt = meta[2];
                // Raz cell scope
                if(metaFmtProp.cellsSet) {
                    for (j = 0, lenj = this.data.length; j < lenj; j++) {
                        if((_$raw =  this.data[j].$rawV[[meta[0]]])) {
                            _$raw.fmt = null;
                        }
                    }
                }
                metaFmtProp.cellsSet = false;
            }
            else if (metaFmtProp && this.data.length > meta[1] - 1 && (_$raw = this.data[meta[1] - 1].$rawV[meta[0]])){
                // Cell scope
                _$raw.fmt = meta[2];
                metaFmtProp.cellsSet = true;
            }
        }
    },

    getMetaFmtColl: function(property, idx){
        var _$raw, fmt = null, metaFmtProp;
        if(this.data.length > idx && (metaFmtProp = this.metaFmt[property])) {
            // Warning : like others meta, "format" could be set at "property" level (default) or "property/line" level.
            if(metaFmtProp.cellsSet && (_$raw = this.data[idx].$rawV[property]) && _$raw.fmt) {
                fmt = _$raw.fmt;
            }
            else {
                fmt = metaFmtProp.fmt;
            }
        }
        return fmt;
    },

    getCollRcdUUID: function(idx){
        return this.data[idx].$uuid;
    },
    
    getCollRcdIdx: function(uuid){
        var i, len = this.data.length, idx = null;
        for (i = 0; i < len; i++) {
            if(this.data[i].$uuid == uuid) {
                idx = i;
                break;
            }
        }
        return idx;
    },
    
    dispose: function(){
        this.releaseStore();
        delete this._fmtWrapper;
        delete this._proto;
    }
});