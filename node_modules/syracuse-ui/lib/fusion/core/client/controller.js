"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Site controller
 */
var helpers = require('syracuse-core/lib/helpers');
var SapModule = require('syracuse-ui/lib/fusion/core/client/sap/controller');
var SapController = SapModule.Controller;
var util = require('syracuse-ui/lib/fusion/tools/util');
var utilBis = require('syracuse-ui/lib/fusion/tools/utilFdb');
var syraUtil = require('./sap/util').Syra;
var sapUtil = require('./sap/util').Fusion;
var EventManager = require('./evtmanager').EventManager;
var requestActions = require('./sap/srvactions');
var localize = require('syracuse-ui/lib/fusion/tools/localize').localize;
var AsyncJobs = require('syracuse-ui/lib/fusion/core/client/sap/job').AsyncJobsManagement;
var keys = require('syracuse-ui/lib/fusion/tools/constant').keybordKey;
var msgBox = require('syracuse-ui/lib/fusion/core/client/sap/msgbox');

var _evtHandlingModules = {
	"tabs": require('./eventhandling/tabs').TabsEventHandling,
	"list": require('./eventhandling/list').ListEventHandling,
	"link": require('./eventhandling/link').LinkEventHandling,
	"grid": require('./eventhandling/grid').GridEventHandling,
	"win": require('./eventhandling/windowEx').WindowEventHandling,
	"blckex": require('./eventhandling/blockex').BlockExEventHandling
};
var _rqstSvc = {
	"sapPost": {
		"name": "Native protocol",
		"act": null,
		"proxy": "sapHttpSvc",
		"method": "PUT",
		"subUrl": "requestSvc",
		"contentType": "application/json",
		"tracking": true,
		"lockUI": true
	},
	"sapDel": {
		"name": "Shutdown session",
		"act": null,
		"proxy": "sapHttpSess",
		"method": "DELETE",
		"subUrl": null,
		"contentType": "application/json"
	},
	"format": {
		"name": "Format service",
		"act": [requestActions.svcFormat, "_basicSvcRqst"],
		"proxy": "fmtHttpSvc",
		"method": "PUT",
		"subUrl": "formatSvc",
		"contentType": "application/json"
	},
	"onLineHelp": {
		"name": "One line help service",
		"act": [requestActions.svcHelp, "_oneLineHelpRqst"],
		"proxy": "helpHttpSvc",
		"method": "GET",
		"subUrl": "",
		"contentType": "text/html"
	},
	"imageBlob": {
		"name": "Image Blob",
		"act": null,
		"proxy": "imageHttpSvc",
		"method": null,
		"subUrl": "blobSvc",
		"contentType": "image/"
	},
	"exportXls": {
		"name": "Excel export",
		"act": null,
		"proxy": "exportXlsHttpSvc",
		"method": null,
		"subUrl": "blobSvc",
		"contentType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
	}
};
var _cnxSvc = {
	"sapCnx": {
		"name": "Session connection",
		"act": null,
		"proxy": "sapHttpCnx",
		"method": "POST",
		"subUrl": "",
		"contentType": "application/json",
		"tracking": true,
		"lockUI": true
	}
};
var _kPanicQr = "panic=true";

// Convergence client main controller class

function Controller() {}

exports.Controller = helpers.defineClass(Controller, EventManager, {
	_initRqstSvcs: function(rqstHttpLoc) {
		this._initSvcs(_rqstSvc, rqstHttpLoc);
		this._svcIdsArray = Object.keys(_rqstSvc);
	},

	_initSvcs: function(svcsDesc, svcHttpLoc) {
		_.each(svcsDesc, function(value, key) {
			this[value.proxy] = {};
			this[value.proxy].noDisplayErr = true;
			this[value.proxy]._uiLocking = value.lockUI ? this._uiLocking : new _uiLockDefault(true);
			this[value.proxy]._tracking = !! (value.tracking);
			this[value.proxy].method = value.method || "POST";
			this[value.proxy].$location = util.duplicateObj(svcHttpLoc);
			this[value.proxy].$location.$method = this[value.proxy].method;
			this[value.proxy].$location.$url = svcHttpLoc.$url + (value.subUrl && value.subUrl.length > 0 ? ("/" + value.subUrl) : "");
			this[value.proxy].$location.$type = value.type || svcHttpLoc.$type || "application/json";
			this[value.proxy].$location.$contentType = value.contentType || svcHttpLoc.$contentType || "application/json";
			this[value.proxy]._tech = {};
			this[value.proxy]._tech.pending = false;
			this[value.proxy]._tech.count = {
				"s": 0,
				"r": 0,
				"ex": 0
			};
			this[value.proxy]._tech.elapse = utilBis.getTimer();
			if (value.act) {
				this._svcActMapping[value.act[0].toString()] = {
					"dispatch": value.act[1],
					"rqstSvc": value
				};
			}
		}, this);
	},

	isFixtureMode: function() {
		return this._localOpts.fixture;
	},

	_sendRequest: function(svc, data, queryString, onSuccess, onPolling, onError, delegatePending, options, pollingManifest) {
		var qs = null,
			qsEx = null,
			self = this,
			rqstPlg = null;
		// Fixture mode
		if (this._localOpts.fixture) {
			if (this._localOpts.fixture.on && this._localOpts.fixture.reply[this._localOpts.fixture.hash + this._localOpts.fixture.next]) {
				onSuccess(this._localOpts.fixture.reply[this._localOpts.fixture.hash + this._localOpts.fixture.next++]);
			}
			return;
		}
		// Check pending state...
		if (this[svc.proxy]._tech.pending && !pollingManifest) {
			this._log.debug({
				"severety": "warn"
			}, "Request " + svc.name + " is pending...");
			if (options && options.onSvcPendingCallback) {
				options.onSvcPendingCallback();
				delete options.onSvcPendingCallback;
			}
			return;
		}
		this[svc.proxy]._uiLocking.lock(svc.proxy);
		if (!pollingManifest) {
			this[svc.proxy]._tech.pending = true;
			this[svc.proxy]._tech.elapse.start();
			// Check options...
			if (options) {
				if (options.preProcElapse) {
					this[svc.proxy]._tech.preProcElapse = (new Date()).getTime() - options.preProcElapse;
				}
				delete options.onSvcPendingCallback;
			}
			// Buil request
			this[svc.proxy]._tech.count.s++;
			qs = this[svc.proxy].$location.$url.indexOf("?");
			(qs >= 0 ? this[svc.proxy].$location.$url = this[svc.proxy].$location.$url.substr(0, qs) : void(0));
			if (queryString && queryString.length > 0) {
				qsEx = queryString + (this[svc.proxy]._tracking ? ("&trackngId=" + this[svc.proxy]._tech.count.s) : "");
			} else
			if (this[svc.proxy]._tracking) {
				qsEx = "trackngId=" + this[svc.proxy]._tech.count.s;
			}
			(qsEx ? this[svc.proxy].$location.$url += ("?" + qsEx) : void(0));
			if (this[svc.proxy].data) {
				delete this[svc.proxy].data;
			}
			this[svc.proxy].data = data || null;
		} else {
			rqstPlg = {
				"noDisplayErr": this[svc.proxy].noDisplayErr,
				"method": pollingManifest.method || "GET",
				"$location": {
					"$url": pollingManifest.$location
				}
			};
		}
		// Send request
		this._hosterController.sendRequest(null, rqstPlg || this[svc.proxy], function(dataResp, response) {
			var plgManifest, plgType, headers;

			function doPolling(pollingMillis) {
				if (self._log) {
					self._log.trace({
						"severety": "warn"
					}, "Request '" + svc.name + "' is in polling mode... waiting " + pollingMillis + " ms.");
				}
				setTimeout(function() {
					self._sendRequest(svc, null, null, onSuccess, onPolling, onError, delegatePending, options, plgManifest);
				}, pollingMillis);
			}
			if (response.status == 202 && self[svc.proxy]._tracking) {
				// Polling!
				self[svc.proxy]._uiLocking.lock(svc.proxy, true);
				plgType = dataResp && dataResp.type || "default";
				headers = response.headers;
				plgManifest = {
					"$location": headers.location,
					"method": "GET",
					"type": plgType
				};
				if (!onPolling) {
					doPolling(dataResp && dataResp.pollingMillis || 1000);
				} else {
					onPolling(plgType, dataResp, function(again) {
						if (again) {
							doPolling(dataResp && dataResp.pollingMillis || 1000);
						}
					}, headers);
				}
				return;
			}
			self[svc.proxy]._tech.count.r++;
			self[svc.proxy]._tech.elapseAjax = self[svc.proxy]._tech.elapse.inter();
			if (!delegatePending) {
				self[svc.proxy]._tech.pending = false;
				onSuccess(dataResp, response);
				self[svc.proxy]._uiLocking.unLock(svc.proxy);
			} else {
				onSuccess(dataResp, response, function() {
					self[svc.proxy]._uiLocking.unLock(svc.proxy);
					self[svc.proxy]._tech.pending = false;
				});
			}
			if (self._log) {
				self._log.timer(null, "Request duration for '" + svc.name + "' : total [" + self[svc.proxy]._tech.elapse.elapsedMs() + "], with ajax [" + self[svc.proxy]._tech.elapseAjax + "] and local [" + (self[svc.proxy]._tech.elapse.elapsedMs() - self[svc.proxy]._tech.elapseAjax) + "]" + (!self[svc.proxy]._tech.preProcElapse ? "" : ". Extra local pre-process duration [" + self[svc.proxy]._tech.preProcElapse + "]"));
			}
		}, function(error) {
			self[svc.proxy]._tech.count.r++;
			self[svc.proxy]._tech.count.ex++;
			self[svc.proxy]._tech.elapseAjax = self[svc.proxy]._tech.elapse.inter();
			self[svc.proxy]._uiLocking.unLock(svc.proxy);
			if (!delegatePending) {
				self[svc.proxy]._tech.pending = false;
				onError(error);
			} else {
				onError(error, function() {
					self[svc.proxy]._tech.pending = false;
				});
			}
			if (self._log) {
				self._log.timer(null, "Request '" + svc.name + "' FAILED! Duration : total [" + self[svc.proxy]._tech.elapse.elapsedMs() + "], with ajax [" + self[svc.proxy]._tech.elapseAjax + "] and local [" + (self[svc.proxy]._tech.elapse.elapsedMs() - self[svc.proxy]._tech.elapseAjax) + "]");
			}
		});
	},

	_appendCnxReply: function(partialReply, consolidatedReply, extra) {
		SapModule.purgeCnxPollingReply(partialReply, consolidatedReply);
		util.appendObj(partialReply, consolidatedReply);
		return SapModule.isSessStatementsOk(consolidatedReply, true, extra);
	},

	postCnxpRqst: function(cnxData, onSuccess, onError, options) {
		var proxy = this[_cnxSvc.sapCnx.proxy],
			qs = proxy.$location.$url.split("?");
		var self = this,
			extraErr = {}, replyParseCtx = null,
			pngBoot = null,
			pollingErr = null,
			sharedResErr = null;

		function _getDiagnosis(stdErrNum, defErrNum, messEx, stack) {
			var errMess, defErrMess = localize.getMessage(self._site.cdIsoLang, defErrNum);
			errMess = self._session ? self._session.getlabel("error", stdErrNum, defErrMess) : defErrMess;
			return util.makeDiagnosis(errMess, 4, stack || "sap.Controller.postCnxpRqst()", stdErrNum, util.cltFusionNice, messEx || undefined);
		}
		if (qs.length > 1) {
			proxy.$location.$url = qs[0];
			proxy._tech.cnxQs = qs[1];
		}
		proxy.params = {
			"trackingId": helpers.uuid.generate()
		};
		this._sendRequest(_cnxSvc.sapCnx, cnxData, qs[1], function(data, response, notifyComplete) {
			var tempSapCtrl, headers = response.headers,
				errRaised = null,
				$location = {
					"$url": headers.location,
					"type": headers["content-type"]
				};
			try {
				if (!pngBoot) {
					onSuccess($location, data, null, false, notifyComplete);
				} else {
					if (pollingErr || (replyParseCtx && replyParseCtx.failed)) {
						// An error occured while processing a full or partial reply in polling mode
						if (pollingErr) {
							pollingErr.splice(0, 0, _getDiagnosis("67", "20"));
						} else
						if (!replyParseCtx.diagnoses || replyParseCtx.diagnoses.length == 0) {
							replyParseCtx.diagnoses = [_getDiagnosis("69", "21")];
						}
						errRaised = {
							"typ": "DelSess"
						};
					} else
					if (!pngBoot.isSttmntsPending) {
						if (pngBoot.done) {
							if ((pollingErr = self.onStart(data, sharedResErr, notifyComplete))) {
								errRaised = {};
							}
						} else {
							self._appendCnxReply(data, pngBoot.statements);
							onSuccess($location, pngBoot.statements, null, false, notifyComplete);
						}
					} else {
						if ((pngBoot.isSttmntsPending = !self._appendCnxReply(data, pngBoot.statements, extraErr))) {
							// Check if we would not on an abort session...
							(tempSapCtrl = new SapController()).initSurvivalMode(self.getLang());
							if (pngBoot.statements && (pollingErr = tempSapCtrl.isAbortReply(pngBoot.statements))) {
								errRaised = {
									"reason": "abortReply",
									"typ": "DelSess"
								};
							} else
							if (tempSapCtrl.getTargetBoxFromReply(pngBoot.statements) && SapModule.isSessStatementsOk(pngBoot.statements, false, extraErr)) {
								// Box target...
								onSuccess($location, pngBoot.statements, null, false, notifyComplete);
							} else {
								// Real sap error!
								pollingErr = [_getDiagnosis("2", "19", null, extraErr ? (localize.getMessage(self._site.cdIsoLang, "missCnxStmt") + " : '" + extraErr.missingStatement + "'") : null)];
								errRaised = {
									"typ": "DelSess"
								};
							}
						} else {
							onSuccess($location, pngBoot.statements, null, false, notifyComplete);
						}
					}
				}
			} catch (e) {
				pollingErr = [_getDiagnosis("18", "16", e.message, e.stack)];
				errRaised = {
					"typ": "DelSess"
				};
			} finally {
				if (errRaised) {
					if (self._sapController && errRaised.typ) {
						self._sapController._sapException(null, pollingErr || replyParseCtx.diagnoses, errRaised, null, null, notifyComplete);
					} else {
						onError(pollingErr || replyParseCtx.diagnoses, true, notifyComplete);
					}
				}
			}
		}, function(pngType, pngData, pngCbk, pngHeaders) {
			var ack = true,
				realLoc;

			function _parseStatements(statements) {
				self._sapController.cleanInitialReply(statements);
				replyParseCtx._techReply = {
					"pollingReplyComplete": pngCbk
				};
				self._sapController.replyOnPollingMode = true;
				if (!self._sapController.processReply(statements, replyParseCtx) || replyParseCtx.failed) {
					pollingErr = replyParseCtx.diagnoses && replyParseCtx.diagnoses.length > 0 ? util.duplicateObj(replyParseCtx.diagnoses) : [_getDiagnosis("7", "21")];
				}
			}
			try {
				self._site.updtCnxStatus(sapUtil.cnxStatus.polling);
				if (pngData && pngData.reply && !pollingErr && !sharedResErr) {
					if (!pngBoot) {
						pngBoot = {
							"isSttmntsPending": true,
							"statements": {},
							"done": false
						};
					}
					if (pngBoot.done || !(pngBoot.isSttmntsPending = !self._appendCnxReply(pngData.reply, pngBoot.statements))) {
						ack = false;
						if (!pngBoot.done) {
							pngBoot.done = true;
							realLoc = pngHeaders.location.split("?");
							onSuccess({
								"$url": realLoc[0],
								"type": pngHeaders["content-type"]
							}, pngBoot.statements, function(isSharedResErr, fatalErr) {
								replyParseCtx = self._sapController.initReplyParseCtx();
								self._sapController.setPollingParseCtxOpts(replyParseCtx, true);
								if (fatalErr) {
									pollingErr = util.duplicateObj(fatalErr);
									pngCbk(true);
								} else
								if (isSharedResErr) {
									sharedResErr = util.duplicateObj(isSharedResErr);
									pngCbk(true);
								} else {
									_parseStatements(pngBoot.statements);
								}
							}, true);
						} else {
							_parseStatements(pngData.reply);
						}
					}
				}
			} catch (e) {
				ack = true;
				pollingErr = [_getDiagnosis("18", "16", e.message, e.stack)];
			} finally {
				if (ack) {
					pngCbk(true);
				}
			}
		}, function(error, notifyComplete) {
			onError(error, false, notifyComplete);
		}, true, options);
	},

	postHelpRqst: function(title, category, keyword, currentTarget, params, postcallback) {
		var data = {};
		data[syraUtil.helpToken.ttl] = title;
		data[syraUtil.helpToken.kw] = keyword;
		data[syraUtil.helpToken.cat] = category;
		this[_rqstSvc.onLineHelp.act[1]](_rqstSvc.onLineHelp, params, postcallback ? {
			"callback": postcallback
		} : null, data, currentTarget);
	},

	postSapRqst: function(action, params, post, options) {
		var self = this,
			rqstData, currIst, pollingErr = null,
			blockingNode = null,
			replyParseCtx = this._sapController.initReplyParseCtx();
		// Init
		if (!options) {
			options = {};
		}
		if (this._site.checkCnxStatus(sapUtil.cnxStatus.established, true)) {
			// TODO : bloquer!
		}
		this._sapController.removeFocus();
		this._sapController.replyOnPollingMode = false;
		// Get request data
		rqstData = self._sapController.getRequestData("", action, params);
		// Value control...
		if (rqstData.ctrlResult && !rqstData.ctrlResult.succeeded) {
			currIst = util.duplicateObj(this._sapController.getCurrInst());
			currIst.v = rqstData.fld.v;
			currIst.ctrlFailed = true;
			setTimeout(function() {
				self._sapController.stubSapTarget_ist(currIst);
			}, 5);
			if (post) {
				if (post.onErrCallBack) {
					setTimeout(function() {
						post.onErrCallBack.apply(self, (post.exposeReply ? (post.args ? ([true, null].concat(post.args)) : [true, null]) : (post.args ? [true].concat(post.args) : [true])));
						delete post.onErrCallBack;
					}, 5);
				}
				delete post.callback;
				delete post.onSvcPendingCallback;
			}
			return false;
		}
		delete rqstData.ctrlResult;
		// Check special options...
		if (post && post.onSvcPendingCallback) {
			options.onSvcPendingCallback = post.onSvcPendingCallback;
		}
		// Check current state on "ending application" actions
		if (action == requestActions.getSrvAction("SRV_FIN_APPLI") || action == requestActions.getSrvAction("SRV_TIMEOUTSESS")) {
			if ((blockingNode = this._sapController.isBlockingNodePending())) {
				this.postSapRqst(blockingNode.act, blockingNode.params, {
					"callback": function() {
						self.postSapRqst(action, params, post, options);
					},
					"onErrCallBack": function() {
						self.postSapRqst(action, params, post, options);
					}
				}, blockingNode.options);
				return false;
			} else {
				this._site.updtCnxStatus(sapUtil.cnxStatus.closing);
			}
		}
		// Send request
		this._sendRequest(_rqstSvc.sapPost, rqstData, "act=" + action, function(data, response, notifyComplete) {
			var ret, chain = null,
				ist, ctrlFailed, isEndSessReply = false;
			if (pollingErr) {
				// A local error occured while processing a partial reply in polling mode. It's fatal!
				pollingErr.splice(0, 0, util.makeDiagnosis(self._session.getlabel("error", "67", "Error while processing last server response (polling mode)."), 4, null, "67", util.cltFusionNice));
				self._sapController._sapException(null, pollingErr, {
					"typ": "DelSess"
				});
				return;
			} else
			if (replyParseCtx.failed) {
				// A local error occured
				if (!replyParseCtx.diagnoses || replyParseCtx.diagnoses.length == 0) {
					replyParseCtx.diagnoses = [util.makeDiagnosis(self._session.getlabel("error", "69", "Error while processing last server response."), 4, "sap.Controller.postSapRqst()", "69", util.cltFusionNice)];
				}
				self._sapController._sapException(null, replyParseCtx.diagnoses, {
					"typ": "DelSess"
				});
				return;
			}
			if (post && post.callback) {
				replyParseCtx._techReply = {
					"replyComplete": null,
					"isPostCallback": true,
					"postMortem": post
				};
			} else {
				replyParseCtx._techReply = {
					"replyComplete": notifyComplete
				};
			}
			self._sapController.setPollingParseCtxOpts(replyParseCtx, false);
			ret = self._sapController.processReply(data, replyParseCtx);
			try {
				if (ret && post && post.callback) {
					if (!(ist = self._sapController.getTargetIstFromReply(data))) {
						isEndSessReply = sapUtil.isEndSessReply(data);
						isEndSessReply = !! (isEndSessReply && params.target == isEndSessReply);
					} else {
						ctrlFailed = self._sapController.isControlFailedInReply(null, ist);
					}
					if (options.forceChain || isEndSessReply || (!ctrlFailed && ist && (sapUtil.cmpIst(params.target, ist) || ((sapUtil.isBlockInst(params.target.xid) || sapUtil.isLineGridInst(params.target)) && sapUtil.cmpIstGrid(params.target, ist)) || sapUtil.cmpIstList(params.target, ist, true)))) {
						chain = post.callback.apply(self, (post.exposeReply ? (post.args ? ([data].concat(post.args)) : [data]) : post.args));
					} else
					if (post.onErrCallBack) {
						post.onErrCallBack.apply(self, (post.exposeReply ? (post.args ? ([ctrlFailed, data].concat(post.args)) : [ctrlFailed, data]) : (post.args ? [ctrlFailed].concat(post.args) : [ctrlFailed])));
					}
				}
				if (post) {
					delete post.onErrCallBack;
					delete post.exposeReply;
					if (post.callback && notifyComplete) {
						notifyComplete();
					}
					delete post.callback;
					if (ret && chain) {
						// All conditions are met to chain server action
						setTimeout(function() {
							self.postSapRqst(chain.$act, chain.params, chain.post);
						}, 1);
					}
				}
				// TODO : check error...
			} catch (ex) {
				// Lack of better... we close the session, how it was an ajax error...
				var ourAjaxErr = util.makeOurAjaxErrEx("CLOSESESS", [util.makeDiagnosis("stack trace...", 4, ex.stack, 18)], 18, localize.getMessage(self._site.cdIsoLang, "13"), "Script error catched in 'controller.postSapRqst/Onsuccess() : " + ex.message);
				self._ourSapRqstError(ourAjaxErr, false, notifyComplete);
			}
		}, function(pngType, pngData, pngCbk) {
			var ack = true;
			try {
				if (pngData && pngData.reply && !pollingErr && !replyParseCtx.failed) {
					self._sapController.setPollingParseCtxOpts(replyParseCtx, true);
					replyParseCtx._techReply = {
						"pollingReplyComplete": pngCbk
					};
					self._sapController.replyOnPollingMode = true;
					ack = false;
					if (!self._sapController.processReply(pngData.reply, replyParseCtx) || replyParseCtx.failed) {
						if (replyParseCtx.diagnoses && replyParseCtx.diagnoses.length > 0) {
							pollingErr = util.duplicateObj(replyParseCtx.diagnoses);
						} else {
							pollingErr = [util.makeDiagnosis(self._session.getlabel("error", "7", "unexpected error while parsing reply."), 4, "postSapRqst", "7", util.cltFusionNice)];
						}
					}
				}
			} catch (ex) {
				pollingErr = [util.makeDiagnosis(self._session.getlabel("error", "18", localize.getMessage(self._session.cdIsoLang, "13")), 4, ex.message + "\n" + ex.stack, "18", util.cltFusionNice)];
			} finally {
				if (ack) {
					pngCbk(true);
				}
			}
		}, function(error, notifyComplete) {
			var ourAjaxErr;
			if (!(ourAjaxErr = util.isOurAjaxErrEx(error))) {
				// Close the client without notifying the server because we don't have any information about the issue!
				ourAjaxErr = util.makeOurAjaxErrEx("KILL", util.getDiagnosesFromAjax(error, self._session), 23, localize.getMessage(self._site.cdIsoLang, "14"));
			}
			self._ourSapRqstError(ourAjaxErr, true, notifyComplete);
		}, true, options);
		return true;
	},

	_ourSapRqstError: function(ourAjaxErr, setDefMess, notifyComplete) {
		var diagnoses = util.makeDiagnosesFromOurAjaxErrEx(ourAjaxErr, this._session),
			recovery = null,
			dftMainMess = "Web server encountered following error during last request processing";
		var messErr = !this._session ? (dftMainMess + ", ") : this._session.getlabel("error", "19", dftMainMess) + ", ";
		var messCallback = null,
			self = this,
			boxOpts, boxParams;
		switch (ourAjaxErr.$recoveryCode) {
			case "CLOSESESS":
				messErr += (!this._session ? "session will be closed" : this._session.getlabel("error", "21", "Session will be closed"));
				messCallback = function() {
					util.releaseOurAjaxErrEx(ourAjaxErr);
					self.onSapCompleted();
				};
				break;
			case "DISCONNECT":
				recovery = {
					"typ": "RqstSrv",
					"act": requestActions.getSrvAction("SRV_FIN_APPLI")
				};
				messErr += (!this._session ? "session will be closed" : this._session.getlabel("error", "21", "Session will be closed"));
				messCallback = function() {
					util.releaseOurAjaxErrEx(ourAjaxErr);
				};
				break;
			case "KILL":
				messErr += (!this._session ? "session will be killed" : this._session.getlabel("error", "24", "Session will be killed"));
				messCallback = function() {
					util.releaseOurAjaxErrEx(ourAjaxErr);
					self.onSapCloseEmergency();
				};
				break;
			case "ABORT":
				messErr += (!this._session ? "session will be aborted" : this._session.getlabel("error", "25", "Session will be aborted"));
				messCallback = function() {
					util.releaseOurAjaxErrEx(ourAjaxErr);
					if (self._site) {
						self._site.free("closed");
					}
				};
				break;
			case "BUSY":
			default:
				break;
		}
		if (setDefMess) {
			diagnoses.message = (diagnoses.message || diagnoses.$message) ? messErr + " : " + (diagnoses.message || diagnoses.$message) : messErr + " : ...";
		}
		if (this._sapController) {
			this._sapController._sapException(null, diagnoses, recovery, null, messCallback, notifyComplete);
		} else {
			this.forceUnlockUI();
			boxParams = util.diagnosesToOurErrEx(diagnoses);
			msgBox.setMsgBoxDefaultProp(boxParams, 4, 180);
			boxOpts = msgBox.getMsgBoxOpts.call(this, boxParams);
			boxOpts.callback = function(resp, closureMode) {
				self.dispose();
			};
			setTimeout(function() {
				syraUtil.msgBox(boxOpts);
			}, 5);
		}
	},

	delSapSessExPanic: function(additionalSess, notifyCallback) {
		var self = this,
			proxy = _rqstSvc.sapDel.proxy,
			qr = _kPanicQr + (additionalSess ? additionalSess : "");
		// Check viability
		if (!this[proxy]) {
			return;
		}
		// We have to send synchronous ajax request while panic (means F5, close browser, close tab, navigate) for all browsers, except IE. 
		this[proxy].syncRqst = !syra_site.browser.isExpected("msie");
		// Go!
		this.forceUnlockUI();
		this._sendRequest(_rqstSvc.sapDel, null, qr, function() {
			if (self._site) {
				self._site.updtCnxStatus(sapUtil.cnxStatus.deleted);
			}
			return;
		}, null, function() {
			if (self._site) {
				self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed);
			}
			return;
		}, false);
		setTimeout(function() {
			if (self._site) {
				self._site.free();
			}
			if (notifyCallback) {
				notifyCallback();
			}
		}, 10);
		return;
	},

	_delSapSess: function(reuse, panic, additionalSess, notifyCallback) {
		var self = this,
			qr = undefined,
			i, lenx;

		function onComplete(mode, ack) {
			setTimeout(function() {
				if (self._site) {
					self._site.free(mode);
				}
				if (notifyCallback) {
					notifyCallback();
				}
			}, 20);
			if (ack) {
				ack();
			}
		}
		if (this._site) {
			this._site.updtCnxStatus(sapUtil.cnxStatus.deleting);
		}
		if (panic) {
			qr = _kPanicQr;
			if (additionalSess && (lenx = additionalSess.length) > 0) {
				for (i = 0; i < lenx; i++) {
					qr += ("&sid_" + i + "=" + additionalSess[i]);
				}
			}
			this._sendRequest(_rqstSvc.sapDel, null, qr, function() {
				if (self._site) {
					self._site.updtCnxStatus(sapUtil.cnxStatus.deleted);
				}
				return;
			}, null, function() {
				if (self._site) {
					self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed);
				}
				return;
			}, false);
			setTimeout(function() {
				onComplete("closed");
			}, 1500);
			return;
		}
		this._sendRequest(_rqstSvc.sapDel, null, reuse ? "reuse=true" : null, function(data, response, ackComplete) {
			if (self._site) {
				self._site.updtCnxStatus(sapUtil.cnxStatus.deleted);
			}
			onComplete(reuse ? "hidden" : "closed", ackComplete);
		}, null, function(error, ackComplete) {
			// Force close...
			var ourAjaxErr, diagnoses;
			if (self._site) {
				self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed);
			}
			if (!self.delSessRetry) {
				self.delSessRetry = true;
				if ((ourAjaxErr = util.isOurAjaxErrEx(error))) {
					diagnoses = util.makeDiagnosesFromOurAjaxErrEx(ourAjaxErr, self._session);
				} else {
					diagnoses = util.getDiagnosesFromAjax(error, self._session);
				}
				self._sapController._sapException(null, diagnoses, null, error, function() {
					self._delSapSess(false, panic, additionalSess, notifyCallback);
					return true;
				}, ackComplete);
			} else {
				onComplete("closed", ackComplete);
			}
		}, true);
	},

	_basicSvcRqst: function(rqstSvc, params, post, options) {
		// Generic REST service : params.svc contains service ID
		var self = this;

		function onComplete(reply, succeeded, notify) {
			if (post) {
				post.callback.apply(self, post.args ? [succeeded, reply].concat(post.args) : [succeeded, reply]);
			}
			if (notify) {
				notify();
			}
		}
		this._sendRequest(rqstSvc, params, params.svc ? "svc=" + params.svc : "", function(data, response, notifyComplete) {
			onComplete(data, true, notifyComplete);
		}, null, function(error, notifyComplete) {
			onComplete(error, false, notifyComplete);
		}, false, options);
	},

	_oneLineHelpRqst: function(rqstSvc, params, post, data, currentTarget) {
		var hCategory, fctId, hKeyWord, currField, noHelp = "ANONE",
			proto, page, helpSC = syraUtil.helpToken,
			self = this;
		if ((page = syraUtil.getPage(currentTarget))) {
			if (!data[helpSC.cat] && data.$link) {
				hCategory = _.find(sapUtil.helpHandler, function(value, key) {
					return value.linkId == data.$link;
				});
				data[helpSC.cat] = hCategory && hCategory.cat;
			}
			if (data[helpSC.cat]) {
				// Legacy help
				if (!data[helpSC.kw]) {
					data[helpSC.kw] = noHelp;
					if (data[helpSC.cat] == sapUtil.helpHandler.fld.cat && (currField = this._sapController.getCurrInst(true))) {
						proto = syraUtil.getEntityProto(currField.xid, syraUtil.get$FromPage(page));
						if (proto) {
							data[helpSC.kw] = proto.$keyword || noHelp;
							data[helpSC.ttl] = proto.$keyword ? currentTarget.getTitle() : "";
						}
					} else
					if (data[helpSC.cat] == sapUtil.helpHandler.fct.cat && (currField = syraUtil.getFusionPageMeta(page))) {
						if ((fctId = currField.winModel.getFctName())) {
							data[helpSC.kw] = fctId.name;
							data[helpSC.ttl] = fctId.title;
						}
					}
				}
				if (post && post.callback) {
					var url = syra_site.expressionMaker.parse(page, "{" + helpSC.bUrl + "}", null, data);
					post.callback.apply(self, (post.args ? ([url].concat(post.args)) : [url]));
				} else {
					page.openHelp(null, syra_site.expressionMaker.parse(page, "{" + helpSC.bUrl + "}", null, data));
				}
			} else {
				// Other help topic...
			}
		}
	},

	initialize: function(site, cnxHttpLoc) {
		this._log = document[sapUtil._fNS].log;
		this._site = site;
		this._session = null;
		this.openerUrlSegments = null;
		this._localOpts = {};
		this._svcActMapping = {};
		this._hosterController = this._site.getHosterController();
		this._uiLocking = new _uiLockDefault();
		this._initSvcs(_cnxSvc, cnxHttpLoc);
	},

	forceUnlockUI: function() {
		try {
			if (this._uiLocking) {
				this._uiLocking.unLock(null, true);
			}
		} catch (e) {}
	},

	completeInit: function(rqstLocation, openerUrlSegments, session, localOpts) {
		// More init...
		this._log = session.logger || this._log;
		this._localOpts = localOpts || this._localOpts;
		this._session = session;
		this.openerUrlSegments = openerUrlSegments;
		this.protoQueryOpts = {
			"headers": {
				"accept-language": this._session ? this._session.cdIsoLang : localize.defLang
			},
			"noDisplayErr": true
		};
		// Formatter policies
		if (session && session.format.wrapper) {
			this._formatAdx = session.format;
			_rqstSvc["format"].act[1] = "_localFormatSvcRqst";
		}
		// Services initialization
		if (rqstLocation) {
			this._initRqstSvcs(rqstLocation);
		}
		// Init sap controller and internal event handling
		(this._sapController = new SapController()).initialize(this);
		this.evtManagerInit(_evtHandlingModules, ["sap", "ui"], {
			"controller": this,
			"sapController": this._sapController,
			"siteUUID": this._site.uuid
		});
		this.evtManagerComplete();
		this._bindListeners();
		// Asynchronous Jobs list
		(this.asynchronousJobs = new AsyncJobs()).initialize(this);
	},

	_bindListeners: function() {
		this.bind("sap.win.unstacked", (this._site.getHosterInstance()).closeSheet, false, true, this._site.getHosterInstance());
	},

	_unbindListeners: function() {
		this.unbind("sap.win.unstacked", this._site.getHosterInstance());
	},

	onSharedResReady: function() {
		this._sapController.onSharedResReady();
	},

	onStart: function(statements, sharedResErr, notifyComplete) {
		var self = this,
			isAbortReply = null,
			_elapse, recovery, err, replyParseCtx = null;
		var sttmntsErr = !statements || !SapModule.isSapReply(statements) ? [util.makeDiagnosis(localize.getMessage(this._site.cdIsoLang, "4") + "\n" + localize.getMessage(this._site.cdIsoLang, "2"), 4, "client.Controller.onStart()", "04", util.cltFusionNice)] : null;
		if (sharedResErr) {
			recovery = {
				"typ": "RqstSrv",
				"act": requestActions.getSrvAction("SRV_FIN_APPLI"),
				"param": {
					"ist": null,
					"v": ""
				}
			};
		}
		if (!sttmntsErr) {
			this._sapController.cleanInitialReply(statements);
			isAbortReply = this._sapController.isAbortReply(statements);
		} else {
			recovery = {
				"typ": "DelSess",
				"panic": true
			};
		}
		if (!isAbortReply) {
			this._site.updtCnxStatus(sapUtil.cnxStatus.established);
			if (sharedResErr || sttmntsErr) {
				try {
					this._sapController._sapException(null, sttmntsErr || sharedResErr, recovery, null, null, notifyComplete);
				} catch (ex) {
					isAbortReply = sttmntsErr || sharedResErr;
				}
			} else {
				// All is ok, we can parse first sap reply
				_elapse = (new Date()).getTime();
				replyParseCtx = self._sapController.initReplyParseCtx();
				replyParseCtx._techReply = {
					"replyComplete": notifyComplete
				};
				this._sapController.processReply(statements, replyParseCtx);
				this._log.timer(null, "First reply internal processing duration : [" + ((new Date()).getTime() - _elapse) + "]");
			}
		} else {
			try {
				this._sapController._sapException(null, util.duplicateObj(isAbortReply), {
					"typ": "DelSess"
				}, null, null, notifyComplete);
				isAbortReply = null;
			} catch (ex) {}
		}
		return isAbortReply;
	},

	onSapUIHidden: function(notify) {
		// Sap client is now attached to the "portal" Window (i.e level 0)
		this._site.updtCnxStatus(sapUtil.cnxStatus.closedByPortal);
		this._delSapSess(true, false, null, notify);
	},

	onSapCloseEmergency: function(additionalSess, notify) {
		// Panic close
		if (this._site) {
			this._site.updtCnxStatus(sapUtil.cnxStatus.closedPanic);
		}
		this._delSapSess(false, true, additionalSess, notify);
	},

	onSapCompleted: function(notify) {
		// Sap client has been closed by the back-office.
		this._site.updtCnxStatus(this._site.checkCnxStatus(sapUtil.cnxStatus.closing, null, true) ? sapUtil.cnxStatus.closedByClt : sapUtil.cnxStatus.closedBySrv);
		this._delSapSess(false, false, null, notify);
	},

	loadRepresentation: function(representation, article, success, error, customProto, stamp, onErr) {
		function _onProtoComplete($itemPage) {
			var $proto = $itemPage.$representation.$prototype;
			var $facet = representation.$facet || syraUtil.mapWinTypeToFacet($proto.$x3Facet) || syraUtil.pageFacet.edit;
			_srvDuration = _elapse.inter();
			$itemPage.$autoFetch = false;
			$itemPage.$category = "fusion";
			$itemPage.$fusionPageMeta = {
				"controller": self,
				"winId": representation.id
			};
			$itemPage.openerUrlSegments = self.openerUrlSegments;
			$itemPage.openerUrlSegments.fullUrl = document.location.href;
			$itemPage.openerUrlSegments.$facet = "$fusion_" + $facet;
			$itemPage.externalAdapter = hosterInstance;
			if (!$proto[syraUtil.helpToken.bUrl]) {
				$proto[syraUtil.helpToken.bUrl] = (self.getSession()).getHelpBaseUrl();
			}
			try {
				success(hosterInstance.loadSheet($itemPage, $facet, sapUtil.optDialog(representation.name)));
				syra_site.uiLocker.ensureLock();
				self._log.timer(null, "Load page duration for '" + representation.name + "': total [" + _elapse.elapsedMs() + "], with ajax [" + _srvDuration + "] and local [" + (_elapse.elapsedMs() - _srvDuration) + "]");
			} catch (ex) {
				diag = util.makeDiagnosis(self._session.getlabel("error", "68", "Unexpected error loading window : ") + " '" + representation.name + "'.\n" + self._session.getlabel("error", "26", "The expected function could not be opened. Please, contact your system administrator if the issue persists."), 3, ex.stack, "68", util.cltFusionNice, ex.message);
				onErr([diag], ex);
			}
		}
		var diag, self = this,
			hosterSite = this._site.getHosterSite(),
			hosterInstance = this._site.getHosterInstance(),
			_elapse = utilBis.getTimer(true),
			_srvDuration;
		this.openerUrlSegments.params.representation = representation.name + ".$fusion";
		if (representation.$variant) {
			this.protoQueryOpts.params = {
				"modelRepresentation": representation.$variant
			};
		} else {
			delete this.protoQueryOpts.params;
		}
		if (!representation.$itemPage) {
			this._hosterController.loadRepresentation({
				article: article,
				segments: this.openerUrlSegments,
				success: _onProtoComplete,
				onError: error,
				onBeforeOpen: customProto,
				sendRqtOpts: this.protoQueryOpts
			});
		} else {
			_onProtoComplete({
				openerUrlSegments: {},
				$representation: representation.$itemPage.$prototype ? representation.$itemPage : {
					$prototype: representation.$itemPage
				}
			});
		}
	},

	getImageUrl: function(xid) {
		return this.imageHttpSvc.$location.$url + "?type=" + syraUtil.dataTypes.imageType + (xid ? "&id=" + xid : "");
	},

	getDocumentUrl: function(xid) {
		return this.exportXlsHttpSvc.$location.$url + (xid ? "?id=" + xid : "");
	},

	getSession: function() {
		return this._session;
	},

	getFormatWrapper: function() {
		return this._formatAdx.wrapper;
	},

	getLogger: function() {
		return this._log;
	},

	toggleLog: function() {
		var turOn = this._log.toggleLog(),
			swtch = document[sapUtil._fNS];
		if (swtch) {
			if (!swtch.logSwitches) {
				swtch.logSwitches = {};
			}
			swtch.logSwitches.all = turOn;
		}
	},

	getLang: function(iso) {
		return this._session ? this._session[iso ? "cdIsoLang" : "cdLang"] : null;
	},

	displayBusinessHelp: function(helpTokens, callback) {
		this._sapController.stubSapMisc_help(helpTokens, callback);
	},

	getMessLabel: function(code, catg, dflt) {
		return this._session.getlabel(catg, code, dflt);
	},

	isSapActiveWindow: function(winId) {
		return this._sapController.isActiveWindow(winId);
	},

	isRqstPending: function() {
		var j, len, pendingRqst = false;
		for (j = 0, len = this._svcIdsArray.length; j < len; j++) {
			if (this[_rqstSvc[this._svcIdsArray[j]].proxy]._tech.pending) {
				pendingRqst = true;
				break;
			}
		}
		return pendingRqst;
	},

	triggerAdx: function(event, object) {
		try {
			// Note : trigger return 'false' if at least one handler has explicitly processed the event.
			var winEvt = null,
				privateEvtManager = null,
				targetMeta = null,
				nativeEvt, evtTimelapse = (new Date()).getTime(),
				succeeded = true,
				intercepted = false,
				evtDomain, evtProps = (this.getEvtName(event)).split("."),
				actId, mapping;
			evtDomain = evtProps[0];
			// Standard control : only for "local" and "widget" event domain.
			if (evtDomain == "lcl" || evtDomain == "wdgt") {
				if (object) {
					winEvt = syraUtil.getFusionPageMeta(object.target);
					targetMeta = syraUtil.getMetaFromObject(object.target);
					if (!(privateEvtManager = winEvt ? winEvt._privateEventManager : privateEvtManager)) {
						if (object.target._isOurMagicSgxWin_ && (nativeEvt = syraUtil.getFusionPageMeta(object.target.getSyraPage()))) {
							privateEvtManager = nativeEvt._privateEventManager;
						}
					}
				}
				if (winEvt && (winEvt = winEvt.winModel) && winEvt.isPreviewWin() && evtProps[1] != "link" && evtProps[1] != "tabs") {
					// Neutralize events when window preview
					succeeded = evtProps[1] == "win" && evtProps[2] == "close" ? true : false;
				} else
				if ((evtProps[1] == "field" || evtProps[1] == "cell") && targetMeta && targetMeta.$bind && targetMeta.$bind[0] === "$") {
					// Bypass events form ui framework field (except TAB)
					nativeEvt = object.data && object.data.nativeEvt;
					if (evtProps[2] == "keydown" && nativeEvt && nativeEvt.keyCode == keys["VK_TAB"]) {
						succeeded = true;
					} else {
						return true;
					}
				}
			}
			// Call handler
			if (succeeded) {
				// If event object implement "target', we notify target that an event occurred... and give it the opportunity to interrupt event process
				if (object && object.target && object.target.beforeTrigger && !object.target.beforeTrigger(event, object)) {
					// So, we must stop trigger event process. "retrun true" mean caller could continue to process/bubble this event.
					return true;
				}
				intercepted = !intercepted && (!privateEvtManager ? this.trigger.apply(this, arguments) : privateEvtManager.trigger.apply(privateEvtManager, arguments));
				// Process result
				if (intercepted !== undefined) {
					if (object.result && object.result.diagnoses) {
						// TODO : Display diagnoses
					} else
					if (object.result && object.result.$act) {
						if (object.result.$act > requestActions.srvActionStart) {
							if (this[_rqstSvc.sapPost.proxy]._tech.pending || this._site.checkCnxStatus(sapUtil.cnxStatus.established, true)) {
								this._log.debug({
									"severety": "warn"
								}, "Native protocol request is pending...");
								succeeded = false;
							} else {
								succeeded = this.postSapRqst(object.result.$act, object.result.params, object.result.post, {
									"preProcElapse": evtTimelapse
								});
							}
						} else
						if (this._svcActMapping[(actId = object.result.$act.toString())]) {
							mapping = this._svcActMapping[actId];
							if (object.opts) {
								object.opts.preProcElapse = evtTimelapse;
							} else {
								object.opts = {
									"preProcElapse": evtTimelapse
								};
							}
							this[mapping.dispatch](mapping.rqstSvc, object.result.params, object.result.post, object.opts, object.target);
						} else
						if (object.result.$act > requestActions.srvActionStart) {
							// Local action... todo if necessary
							succeeded = true;
						}
					}
				}
			}
			// Remark : "return true" mean caller could continue to process/bubble this event. "false" mean event was processed by our event manager, caller must stop to deal with this event.
			return (!succeeded || (intercepted !== undefined && intercepted)) ? false : true;
		} catch (ex) {
			var mess = this._session.getlabel("error", "29", "An unexpected javascript error occured. Please, try again");
			this._sapController._sapException(null, [util.makeDiagnosis(mess, 3, ex.stack, "29", util.cltFusionNice, "Script error catched in 'controller.triggerAdx()' : " + ex.message)]);
			return false;
		}
	},

	_localFormatSvcRqst: function(rqstSvc, input, post, options) {
		var output = this._formatAdx.wrapper.formatSvc(input.svc, input, options),
			self = this;
		if (post) {
			setTimeout(function() {
				post.callback.apply(self, post.args ? [output.succeeded, output].concat(post.args) : [output.succeeded, output]);
			}, 5);
		}
	},
	dispose: function() {
		this.forceUnlockUI();
		if (this.asynchronousJobs) {
			this.asynchronousJobs.dispose();
		}
		if (this._svcActMapping) {
			_.each(this._svcActMapping, function(value, key) {
				delete value.rqstSvc;
			}, this);
		}
		delete this.openerUrlSegments;
		if (this._sapController) {
			this._sapController.dispose();
			delete this._sapController;
		}
		this._formatAdx = this._session = null;
		_.each(_rqstSvc, function(value, key) {
			if (this[value.proxy] && this[value.proxy].data) {
				delete this[value.proxy].data;
			}
		}, this);
		if (this._evtMngrComplete) {
			this._unbindListeners();
			this.evtManagerDispose();
		}
		this._site = this._log = null;
	}
});

// Lock UI class
var _uiLockDefault = helpers.defineClass(function(dummy, opts) {
	this._locked = false;
	this._longProcessing = false;
	this._lockerId = null;
	this._dummy = !! (dummy);
}, null, {
	lock: function(lockerId, longProcess) {
		if (this._dummy) {
			return;
		} else
		if (!this._locked) {
			this._lockerId = lockerId;
			this._locked = true;
			this._longProcessing = false;
			syra_site.uiLocker.lock(0, false, true);
			//document[sapUtil._fNS].log.trace({"severety": "warn"}, "**** UI locked by '" + (this._lockerId || "") + "' ***");
		} else
		if (longProcess != this._longProcessing && (!this._lockerId || lockerId === this._lockerId)) {
			syra_site.uiLocker.lock(1, (this._longProcessing = longProcess), true);
			//document[sapUtil._fNS].log.trace({"severety": "warn"}, "**** UI locked 'long' by '" + (this._lockerId || "") + "' ***");
		}
	},
	unLock: function(lockerId, force) {
		if (this._dummy) {
			return;
		} else
		if (this._locked && (force || !this._lockerId || lockerId === this._lockerId)) {
			this._locked = false;
			this._longProcessing = false;
			syra_site.uiLocker.unlock();
			//document[sapUtil._fNS].log.trace({"severety": "warn"}, "**** UI UNLocked by '" + (this._lockerId || "") + (force ? "' in forced mode " : "'") + " ***");
			this._lockerId = null;
		}
	}
});