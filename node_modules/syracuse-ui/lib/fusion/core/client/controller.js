"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Site controller
 */

var helpers = require('syracuse-core/lib/helpers');
var SapModule = require('syracuse-ui/lib/fusion/core/client/sap/controller');
var SapController = SapModule.Controller;
var util = require('syracuse-ui/lib/fusion/tools/util');
var utilBis = require('syracuse-ui/lib/fusion/tools/utilFdb');
var syraUtil = require('./sap/util').Syra;
var sapUtil = require('./sap/util').Fusion;
var EventManager = require('./evtmanager').EventManager;
var requestActions = require('./sap/srvactions');
var localize = require('syracuse-ui/lib/fusion/tools/localize').localize;
var AsyncJobs = require('syracuse-ui/lib/fusion/core/client/sap/job').AsyncJobsManagement;
var keys = require('syracuse-ui/lib/fusion/tools/constant').keybordKey;
var msgBox = require('syracuse-ui/lib/fusion/core/client/sap/msgbox');
var siteUILocking = require('syracuse-ui/lib/site/uiLocker');

var _evtHandlingModules = {
	"tabs": require('./eventhandling/tabs').TabsEventHandling,
	"list": require('./eventhandling/list').ListEventHandling,
	"link": require('./eventhandling/link').LinkEventHandling,
	"grid": require('./eventhandling/grid').GridEventHandling,
	"win": require('./eventhandling/windowEx').WindowEventHandling,
	"blckex": require('./eventhandling/blockex').BlockExEventHandling
};
var _rqstSvc = {
	"sapPost": {
		"name": "Native protocol",
		"act": null,
		"proxy": "sapHttpSvc",
		"method": "PUT",
		"subUrl": "requestSvc",
		"contentType": "application/json",
		"tracking": true,
		"lockUI": true
	},
	"sapDel": {
		"name": "Shutdown session",
		"act": null,
		"proxy": "sapHttpSess",
		"method": "DELETE",
		"subUrl": null,
		"contentType": "application/json"
	},
	"format": {
		"name": "Format service",
		"act": [requestActions.svcFormat, "_basicSvcRqst"],
		"proxy": "fmtHttpSvc",
		"method": "PUT",
		"subUrl": "formatSvc",
		"contentType": "application/json"
	},
	"onLineHelp": {
		"name": "One line help service",
		"act": [requestActions.svcHelp, "_oneLineHelpRqst"],
		"proxy": "helpHttpSvc",
		"method": "GET",
		"subUrl": "",
		"contentType": "text/html"
	},
	"imageBlob": {
		"name": "Image Blob",
		"act": null,
		"proxy": "imageHttpSvc",
		"method": null,
		"subUrl": "blobSvc",
		"contentType": "image/"
	},
	"exportXls": {
		"name": "Excel export",
		"act": null,
		"proxy": "exportXlsHttpSvc",
		"method": null,
		"subUrl": "blobSvc",
		"contentType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
	}
};
var _cnxSvc = {
	"sapCnx": {
		"name": "Session connection",
		"act": null,
		"proxy": "sapHttpCnx",
		"method": "POST",
		"subUrl": "",
		"contentType": "application/json",
		"tracking": true,
		"lockUI": true
	}
};
var _kPanicQr = "panic=true";

// Convergence client main controller class

function Controller() {}

exports.Controller = helpers.defineClass(Controller, EventManager, {
	_initRqstSvcs: function(rqstHttpLoc) {
		this._initSvcs(_rqstSvc, rqstHttpLoc);
		this._svcIdsArray = Object.keys(_rqstSvc);
	},

	_initSvcs: function(svcsDesc, svcHttpLoc) {
		_.each(svcsDesc, function(value, key) {
			this[value.proxy] = {};
			this[value.proxy].noDisplayErr = true;
			this[value.proxy]._uiLocking = value.lockUI ? this._uiLocking : new _uiLockDefault(true);
			this[value.proxy]._tracking = !! (value.tracking);
			this[value.proxy].method = value.method || "POST";
			this[value.proxy].$location = util.duplicateObj(svcHttpLoc);
			this[value.proxy].$location.$method = this[value.proxy].method;
			this[value.proxy].$location.$url = svcHttpLoc.$url + (value.subUrl && value.subUrl.length > 0 ? ("/" + value.subUrl) : "");
			this[value.proxy].$location.$type = value.type || svcHttpLoc.$type || "application/json";
			this[value.proxy].$location.$contentType = value.contentType || svcHttpLoc.$contentType || "application/json";
			this[value.proxy]._tech = {};
			this[value.proxy]._tech.pending = false;
			this[value.proxy]._tech.count = {
				"s": 0,
				"r": 0,
				"ex": 0
			};
			this[value.proxy]._tech.elapse = utilBis.getTimer();
			if (value.act) {
				this._svcActMapping[value.act[0].toString()] = {
					"dispatch": value.act[1],
					"rqstSvc": value
				};
			}
		}, this);
	},

	isFixtureMode: function() {
		return this._localOpts.fixture;
	},

	_sendRequest: function(svc, data, queryString, onSuccess, onPolling, onError, delegatePending, options, pollingManifest) {
		var qs = null,
			qsEx = null,
			self = this,
			rqstPlg = null;
		// Fixture mode
		if (this._localOpts.fixture) {
			if (this._localOpts.fixture.on && this._localOpts.fixture.reply[this._localOpts.fixture.hash + this._localOpts.fixture.next]) {
				onSuccess(this._localOpts.fixture.reply[this._localOpts.fixture.hash + this._localOpts.fixture.next++]);
			}
			return;
		}
		// Check pending state...
		if (this[svc.proxy]._tech.pending && !pollingManifest) {
			this._log.debug({
				"severety": "warn"
			}, "Request " + svc.name + " is pending...");
			if (options && options.onSvcPendingCallback) {
				options.onSvcPendingCallback();
				delete options.onSvcPendingCallback;
			}
			return;
		}
		if (!pollingManifest) {
			this[svc.proxy]._tech.pending = true;
			this[svc.proxy]._tech.elapse.start();
			// Check options...
			if (options) {
				if (options.preProcElapse) {
					this[svc.proxy]._tech.preProcElapse = (new Date()).getTime() - options.preProcElapse;
				}
				delete options.onSvcPendingCallback;
			}
			// Buil request
			this[svc.proxy]._tech.count.s++;
			qs = this[svc.proxy].$location.$url.indexOf("?");
			(qs >= 0 ? this[svc.proxy].$location.$url = this[svc.proxy].$location.$url.substr(0, qs) : void(0));
			if (queryString && queryString.length > 0) {
				qsEx = queryString + (this[svc.proxy]._tracking ? ("&trackngId=" + this[svc.proxy]._tech.count.s) : "");
			} else if (this[svc.proxy]._tracking) {
				qsEx = "trackngId=" + this[svc.proxy]._tech.count.s;
			}
			(qsEx ? this[svc.proxy].$location.$url += ("?" + qsEx) : void(0));
			if (this[svc.proxy].data) {
				delete this[svc.proxy].data;
			}
			this[svc.proxy].data = data || null;
		} else {
			rqstPlg = {
				"noDisplayErr": this[svc.proxy].noDisplayErr,
				"method": pollingManifest.method || "GET",
				"$location": {
					"$url": pollingManifest.$location
				}
			};
		}
		// Send request
		this[svc.proxy]._uiLocking.lock(svc.proxy);
		this._hosterController.sendRequest(null, rqstPlg || this[svc.proxy],

			function(dataResp, response) {
				var plgManifest, plgType, headers;

				function doPolling(pollingMillis) {
					if (self._log) {
						self._log.trace({
							"severety": "warn"
						}, "Request '" + svc.name + "' is in polling mode... waiting " + pollingMillis + " ms.");
					}
					setTimeout(function() {
						self._sendRequest(svc, null, null, onSuccess, onPolling, onError, delegatePending, options, plgManifest);
					}, pollingMillis);
				}
				if (response.status == 202 && self[svc.proxy]._tracking) {
					// Polling!
					self[svc.proxy]._uiLocking.lock(svc.proxy, true);
					plgType = dataResp && dataResp.type || "default";
					headers = response.headers;
					plgManifest = {
						"$location": headers.location,
						"method": "GET",
						"type": plgType
					};
					if (!onPolling) {
						doPolling(dataResp && dataResp.pollingMillis || 1000);
					} else {
						onPolling(plgType, dataResp, function(again) {
							if (again) {
								doPolling(dataResp && dataResp.pollingMillis || 1000);
							}
						}, headers);
					}
					return;
				}
				self[svc.proxy]._tech.count.r++;
				self[svc.proxy]._tech.elapseAjax = self[svc.proxy]._tech.elapse.inter();
				if (!delegatePending) {
					self[svc.proxy]._tech.pending = false;
					onSuccess(dataResp, response);
					self[svc.proxy]._uiLocking.unLock(svc.proxy);
				} else {
					onSuccess(dataResp, response, function() {
						self[svc.proxy]._uiLocking.unLock(svc.proxy);
						self[svc.proxy]._tech.pending = false;
					});
				}
				if (self._log) {
					self._log.timer(null, "Request duration for '" + svc.name + "' : total [" + self[svc.proxy]._tech.elapse.elapsedMs() + "], with ajax [" + self[svc.proxy]._tech.elapseAjax + "] and local [" + (self[svc.proxy]._tech.elapse.elapsedMs() - self[svc.proxy]._tech.elapseAjax) + "]" + (!self[svc.proxy]._tech.preProcElapse ? "" : ". Extra local pre-process duration [" + self[svc.proxy]._tech.preProcElapse + "]"));
				}
			},

			function(error) {
				self[svc.proxy]._tech.count.r++;
				self[svc.proxy]._tech.count.ex++;
				self[svc.proxy]._tech.elapseAjax = self[svc.proxy]._tech.elapse.inter();
				self[svc.proxy]._uiLocking.unLock(svc.proxy);
				if (!delegatePending) {
					self[svc.proxy]._tech.pending = false;
					onError(error);
				} else {
					onError(error, function() {
						self[svc.proxy]._tech.pending = false;
					});
				}
				if (self._log) {
					self._log.timer(null, "Request '" + svc.name + "' FAILED! Duration : total [" + self[svc.proxy]._tech.elapse.elapsedMs() + "], with ajax [" + self[svc.proxy]._tech.elapseAjax + "] and local [" + (self[svc.proxy]._tech.elapse.elapsedMs() - self[svc.proxy]._tech.elapseAjax) + "]");
				}
			});
	},

	_appendCnxReply: function(partialReply, consolidatedReply) {
		util.appendObj(partialReply, consolidatedReply);
		return SapModule.isSessStatementsOk(consolidatedReply, true);
	},

	postCnxpRqst: function(cnxData, onSuccess, onError, options) {
		var proxy = this[_cnxSvc.sapCnx.proxy],
			qs = proxy.$location.$url.split("?");
		var self = this,
			replyParseCtx = null,
			pngBoot = null,
			pollingErr = null,
			sharedResErr = null;

		function _getDiagnosis(stdErrNum, defErrNum, messEx, stack) {
			var errMess, defErrMess = localize.getMessage(self._site.cdIsoLang, defErrNum);
			errMess = self._session ? self._session.getlabel("error", stdErrNum, defErrMess) : defErrMess;
			return util.makeDiagnosis(errMess, 4, stack || "sap.Controller.postCnxpRqst()", stdErrNum, util.cltFusionNice, messEx || undefined);
		}
		if (qs.length > 1) {
			proxy.$location.$url = qs[0];
			proxy._tech.cnxQs = qs[1];
		}
		proxy.params = {
			"trackingId": helpers.uuid.generate()
		};
		this._sendRequest(_cnxSvc.sapCnx, cnxData, qs[1],

			function(data, response) {
				var tempSapCtrl, headers = response.headers,
					errRaised = null,
					$location = {
						"$url": headers.location,
						"type": headers["content-type"]
					};
				try {
					if (!pngBoot) {
						onSuccess($location, data);
					} else {
						if (pollingErr || (replyParseCtx && replyParseCtx.failed)) {
							// An error occured while processing a full or partial reply in polling mode
							if (pollingErr) {
								pollingErr.splice(0, 0, _getDiagnosis("67", "20"));
							} else if (!replyParseCtx.diagnoses || replyParseCtx.diagnoses.length == 0) {
								replyParseCtx.diagnoses = [_getDiagnosis("69", "21")];
							}
							errRaised = {
								"typ": "DelSess"
							};
						} else if (!pngBoot.isSttmntsPending) {
							if (pngBoot.done) {
								if ((pollingErr = self.onStart(data, sharedResErr))) {
									errRaised = {};
								}
							} else {
								self._appendCnxReply(data, pngBoot.statements);
								onSuccess($location, pngBoot.statements);
							}
						} else {
							if ((pngBoot.isSttmntsPending = !self._appendCnxReply(data, pngBoot.statements))) {
								// Check if we would not on an abort session...
								(tempSapCtrl = new SapController()).initSurvivalMode(self.getLang());
								if (pngBoot.statements && (pollingErr = tempSapCtrl.isAbortReply(pngBoot.statements))) {
									errRaised = {
										"reason": "abortReply"
									};
								} else if (tempSapCtrl.getTargetBoxFromReply(pngBoot.statements) && SapModule.isSessStatementsOk(pngBoot.statements)) {
									// Box target...
									onSuccess($location, pngBoot.statements);
								} else {
									// Real sad error!
									pollingErr = [_getDiagnosis("2", "19")];
									errRaised = {
										"typ": "DelSess"
									};
								}
							} else {
								onSuccess($location, pngBoot.statements);
							}
						}
					}
				} catch (e) {
					pollingErr = [_getDiagnosis("18", "16", e.message, e.stack)];
					errRaised = {
						"typ": "DelSess"
					};
				} finally {
					if (errRaised) {
						if (self._sapController && errRaised.typ) {
							self._sapController._sapException(null, pollingErr || replyParseCtx.diagnoses, errRaised);
						} else {
							onError(pollingErr || replyParseCtx.diagnoses, true);
						}
					}
				}
			},

			function(pngType, pngData, pngCbk, pngHeaders) {
				var ack = true,
					realLoc;

				function _parseStatements(statements) {
					SapModule.cleanInitialReply(statements);
					replyParseCtx._techReply = {
						"pollingReplyComplete": pngCbk
					};
					if (!self._sapController.processReply(statements, replyParseCtx) || replyParseCtx.failed) {
						pollingErr = replyParseCtx.diagnoses && replyParseCtx.diagnoses.length > 0 ? util.duplicateObj(replyParseCtx.diagnoses) : [_getDiagnosis("7", "21")];
					}
				}
				try {
					self._site.updtCnxStatus(sapUtil.cnxStatus.polling);
					if (pngData && pngData.reply && !pollingErr && !sharedResErr) {
						if (!pngBoot) {
							pngBoot = {
								"isSttmntsPending": true,
								"statements": {},
								"done": false
							};
						}
						if (!(pngBoot.isSttmntsPending = !self._appendCnxReply(pngData.reply, pngBoot.statements))) {
							ack = false;
							if (!pngBoot.done) {
								pngBoot.done = true;
								realLoc = pngHeaders.location.split("?");
								onSuccess({
									"$url": realLoc[0],
									"type": pngHeaders["content-type"]
								}, pngBoot.statements, function(isSharedResErr, fatalErr) {
									replyParseCtx = self._sapController.initReplyParseCtx();
									self._sapController.setPollingParseCtxOpts(replyParseCtx, true);
									if (fatalErr) {
										pollingErr = util.duplicateObj(fatalErr);
										pngCbk(true);
									} else if (isSharedResErr) {
										sharedResErr = util.duplicateObj(isSharedResErr);
										pngCbk(true);
									} else {
										_parseStatements(pngBoot.statements);
									}
								}, true);
							} else {
								_parseStatements(pngData.reply);
							}
						}
					}
				} catch (e) {
					ack = true;
					pollingErr = [_getDiagnosis("18", "16", e.message, e.stack)];
				} finally {
					if (ack) {
						pngCbk(true);
					}
				}
			},

			function(error) {
				onError(error, false);
			},
			false, options);
	},

	postHelpRqst: function(title, category, keyword, currentTarget, params) {
		var data = {};
		data[syraUtil.helpToken.ttl] = title;
		data[syraUtil.helpToken.kw] = keyword;
		data[syraUtil.helpToken.cat] = category;
		this[_rqstSvc.onLineHelp.act[1]](_rqstSvc.onLineHelp, params, null, data, currentTarget);
	},

	postSapRqst: function(action, params, post, options) {
		var self = this,
			rqstData, currIst, pollingErr = null,
			blockingNode = null,
			replyParseCtx = this._sapController.initReplyParseCtx();
		// Init
		if (!options) {
			options = {};
		}
		if (this._site.checkCnxStatus(sapUtil.cnxStatus.established, true)) {
			// TODO : bloquer!
		}
		this._sapController.removeFocus();
		// Get request data
		rqstData = self._sapController.getRequestData("", action, params);
		// Value control...
		if (rqstData.ctrlResult && !rqstData.ctrlResult.succeeded) {
			currIst = util.duplicateObj(this._sapController.getCurrInst());
			currIst.v = rqstData.fld.v;
			currIst.ctrlFailed = true;
			setTimeout(function() {
				self._sapController.stubSapTarget_ist(currIst);
			}, 5);
			if (post) {
				if (post.onErrCallBack) {
					setTimeout(function() {
						post.onErrCallBack.apply(self, (post.exposeReply ? (post.args ? ([true, null].concat(post.args)) : [true, null]) : (post.args ? [true].concat(post.args) : [true])));
						delete post.onErrCallBack;
					}, 5);
				}
				delete post.callback;
				delete post.onSvcPendingCallback;
			}
			return false;
		}
		delete rqstData.ctrlResult;
		// Check special options...
		if (post && post.onSvcPendingCallback) {
			options.onSvcPendingCallback = post.onSvcPendingCallback;
		}
		// Check current state on "ending application" actions
		if (action == requestActions.getSrvAction("SRV_FIN_APPLI") || action == requestActions.getSrvAction("SRV_TIMEOUTSESS")) {
			if ((blockingNode = this._sapController.isBlockingNodePending())) {
				this.postSapRqst(blockingNode.act, blockingNode.params, {
						"callback": function() {
							self.postSapRqst(action, params, post, options);
						},
						"onErrCallBack": function() {
							self.postSapRqst(action, params, post, options);
						}
					},
					blockingNode.options);
				return false;
			} else {
				this._site.updtCnxStatus(sapUtil.cnxStatus.closing);
			}
		}
		// Send request
		this._sendRequest(_rqstSvc.sapPost, rqstData, "act=" + action,

			function(data, response, notifyComplete) {
				var ret, chain = null,
					ist, ctrlFailed;
				if (pollingErr) {
					// A local error occured while processing a partial reply in polling mode. It's fatal!
					pollingErr.splice(0, 0, util.makeDiagnosis(self._session.getlabel("error", "67", "Error while processing last server response (polling mode)."), 4, null, "67", util.cltFusionNice));
					self._sapController._sapException(null, pollingErr, {
						"typ": "DelSess"
					});
					return;
				} else if (replyParseCtx.failed) {
					// A local error occured
					if (!replyParseCtx.diagnoses || replyParseCtx.diagnoses.length == 0) {
						replyParseCtx.diagnoses = [util.makeDiagnosis(self._session.getlabel("error", "69", "Error while processing last server response."), 4, "sap.Controller.postSapRqst()", "69", util.cltFusionNice)];
					}
					self._sapController._sapException(null, replyParseCtx.diagnoses, {
						"typ": "DelSess"
					});
					return;
				}
				replyParseCtx._techReply = {
					"replyComplete": notifyComplete
				};
				self._sapController.setPollingParseCtxOpts(replyParseCtx, false);
				ret = self._sapController.processReply(data, replyParseCtx);
				try {
					if (ret && post && post.callback) {
						ist = self._sapController.getTargetIstFromReply(data);
						ctrlFailed = self._sapController.isControlFailedInReply(null, ist);
						if (options.forceChain || (!ctrlFailed && (sapUtil.cmpIst(params.target, ist) || ((sapUtil.isBlockInst(params.target.xid) || sapUtil.isLineGridInst(params.target)) && sapUtil.cmpIstGrid(params.target, ist))))) {
							chain = post.callback.apply(self, (post.exposeReply ? (post.args ? ([data].concat(post.args)) : [data]) : post.args));
						} else if (post.onErrCallBack) {
							post.onErrCallBack.apply(self, (post.exposeReply ? (post.args ? ([ctrlFailed, data].concat(post.args)) : [ctrlFailed, data]) : (post.args ? [ctrlFailed].concat(post.args) : [ctrlFailed])));
						}
					}
					if (post) {
						delete post.callback;
						delete post.onErrCallBack;
						delete post.exposeReply;
						if (ret && chain) {
							// All conditions are met to chain server action
							setTimeout(function() {
								self.postSapRqst(chain.$act, chain.params, chain.post);
							}, 2);
						}
					}
					// TODO : check error...
				} catch (ex) {
					// Lack of better... we close the session, how it was an ajax error...
					var ourAjaxErr = util.makeOurAjaxErrEx("CLOSESESS", [util.makeDiagnosis("stack trace...", 4, ex.stack, 18)], 18, localize.getMessage(self._site.cdIsoLang, "13"), "Script error catched in 'controller.postSapRqst/Onsuccess() : " + ex.message);
					self._ourSapRqstError(ourAjaxErr, false, notifyComplete);
				}
			},

			function(pngType, pngData, pngCbk) {
				var ack = true;
				try {
					if (pngData && pngData.reply && !pollingErr && !replyParseCtx.failed) {
						self._sapController.setPollingParseCtxOpts(replyParseCtx, true);
						replyParseCtx._techReply = {
							"pollingReplyComplete": pngCbk
						};
						ack = false;
						if (!self._sapController.processReply(pngData.reply, replyParseCtx) || replyParseCtx.failed) {
							if (replyParseCtx.diagnoses && replyParseCtx.diagnoses.length > 0) {
								pollingErr = util.duplicateObj(replyParseCtx.diagnoses);
							} else {
								pollingErr = [util.makeDiagnosis(self._session.getlabel("error", "7", "unexpected error while parsing reply."), 4, "postSapRqst", "7", util.cltFusionNice)];
							}
						}
					}
				} catch (ex) {
					pollingErr = [util.makeDiagnosis(self._session.getlabel("error", "18", localize.getMessage(self._session.cdIsoLang, "13")), 4, ex.message + "\n" + ex.stack, "18", util.cltFusionNice)];
				} finally {
					if (ack) {
						pngCbk(true);
					}
				}
			},

			function(error, notifyComplete) {
				var ourAjaxErr;
				if (!(ourAjaxErr = util.isOurAjaxErrEx(error))) {
					// Close the client without notifying the server because we don't have any information about the issue!
					ourAjaxErr = util.makeOurAjaxErrEx("KILL", util.getDiagnosesFromAjax(error, self._session), 23, localize.getMessage(self._site.cdIsoLang, "14"));
				}
				self._ourSapRqstError(ourAjaxErr, true, notifyComplete);
			}, true, options);
		return true;
	},

	_ourSapRqstError: function(ourAjaxErr, setDefMess, notifyComplete) {
		var diagnoses = util.makeDiagnosesFromOurAjaxErrEx(ourAjaxErr, this._session),
			recovery = null,
			dftMainMess = "Web server encountered following error during last request processing";
		var messErr = !this._session ? (dftMainMess + ", ") : this._session.getlabel("error", "19", dftMainMess) + ", ";
		var messCallback = null,
			self = this,
			boxOpts, boxParams;
		switch (ourAjaxErr.$recoveryCode) {
			case "CLOSESESS":
				messErr += (!this._session ? "session will be closed" : this._session.getlabel("error", "21", "Session will be closed"));
				messCallback = function() {
					util.releaseOurAjaxErrEx(ourAjaxErr);
					self.onSapCompleted();
				};
				break;
			case "DISCONNECT":
				recovery = {
					"typ": "RqstSrv",
					"act": requestActions.getSrvAction("SRV_FIN_APPLI")
				};
				messErr += (!this._session ? "session will be closed" : this._session.getlabel("error", "21", "Session will be closed"));
				messCallback = function() {
					util.releaseOurAjaxErrEx(ourAjaxErr);
				};
				break;
			case "KILL":
				messErr += (!this._session ? "session will be killed" : this._session.getlabel("error", "24", "Session will be killed"));
				messCallback = function() {
					util.releaseOurAjaxErrEx(ourAjaxErr);
					self.onSapCloseEmergency();
				};
				break;
			case "ABORT":
				messErr += (!this._session ? "session will be aborted" : this._session.getlabel("error", "25", "Session will be aborted"));
				messCallback = function() {
					util.releaseOurAjaxErrEx(ourAjaxErr);
					if (self._site) {
						self._site.free("closed");
					}
				};
				break;
			case "BUSY":
			default:
				break;
		}
		if (setDefMess) {
			diagnoses.message = (diagnoses.message || diagnoses.$message) ? messErr + " : \n" + (diagnoses.message || diagnoses.$message) : messErr + " : ...";
		}
		if (this._sapController) {
			this._sapController._sapException(null, diagnoses, recovery, null, messCallback, notifyComplete);
		} else {
			this.forceUnlockUI();
			boxParams = util.diagnosesToOurErrEx(diagnoses);
			msgBox.setMsgBoxDefaultProp(boxParams, 4, 180);
			boxOpts = msgBox.getMsgBoxOpts.call(this, boxParams);
			boxOpts.callback = function(resp, closureMode) {
				self.dispose();
			};
			setTimeout(function() {
				syraUtil.msgBox(boxOpts);
			}, 5);
		}
	},

	delSapSessExPanic: function(additionalSess) {
		var self = this,
			proxy = _rqstSvc.sapDel.proxy,
			qr = _kPanicQr + (additionalSess ? additionalSess : "");
		// Check viability
		if (!this[proxy]) {
			return;
		}
		// We have to send synchronous ajax request while panic (means F5, close browser, close tab, navigate) for all browsers, except IE. 
		this[proxy].syncRqst = !util.isExpectedBrowser("msie");
		// Go!
		this.forceUnlockUI();
		this._sendRequest(_rqstSvc.sapDel, null, qr, function() {
			if (self._site) {
				self._site.updtCnxStatus(sapUtil.cnxStatus.deleted);
			}
			return;
		}, null, function() {
			if (self._site) {
				self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed);
			}
			return;
		}, false);
		setTimeout(function() {
			if (self._site) {
				self._site.free;
			}
		}, 10);
		return;
	},

	_delSapSess: function(reuse, panic, additionalSess) {
		var self = this,
			qr = undefined,
			i, lenx;

		function onComplete(mode, notify) {
			setTimeout(function() {
				if (self._site) {
					self._site.free(mode);
				}
			}, 20);
			if (notify) {
				notify();
			}
		}
		if (this._site) {
			this._site.updtCnxStatus(sapUtil.cnxStatus.deleting);
		}
		if (panic) {
			qr = _kPanicQr;
			if (additionalSess && (lenx = additionalSess.length) > 0) {
				for (i = 0; i < lenx; i++) {
					qr += ("&sid_" + i + "=" + additionalSess[i]);
				}
			}
			this._sendRequest(_rqstSvc.sapDel, null, qr, function() {
				if (self._site) {
					self._site.updtCnxStatus(sapUtil.cnxStatus.deleted);
				}
				return;
			}, null, function() {
				if (self._site) {
					self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed);
				}
				return;
			}, false);
			setTimeout(function() {
				onComplete("closed");
			}, 1500);
			return;
		}
		this._sendRequest(_rqstSvc.sapDel, null, reuse ? "reuse=true" : null,

			function(data, response, notifyComplete) {
				if (self._site) {
					self._site.updtCnxStatus(sapUtil.cnxStatus.deleted);
				}
				onComplete(reuse ? "hidden" : "closed", notifyComplete);
			},
			null,

			function(error, notifyComplete) {
				// Force close...
				var ourAjaxErr, diagnoses;
				if (self._site) {
					self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed);
				}
				if (!self.delSessRetry) {
					self.delSessRetry = true;
					if ((ourAjaxErr = util.isOurAjaxErrEx(error))) {
						diagnoses = util.makeDiagnosesFromOurAjaxErrEx(ourAjaxErr, self._session);
					} else {
						diagnoses = util.getDiagnosesFromAjax(error, self._session);
					}
					self._sapController._sapException(null, diagnoses, null, error, function() {
						self._delSapSess(false, panic, additionalSess);
						return true;
					}, notifyComplete);
				} else {
					onComplete("closed", notifyComplete);
				}
			}, true);
	},

	_basicSvcRqst: function(rqstSvc, params, post, options) {
		// Generic REST service : params.svc contains service ID
		var self = this;

		function onComplete(reply, succeeded, notify) {
			if (post) {
				post.callback.apply(self, post.args ? [succeeded, reply].concat(post.args) : [succeeded, reply]);
			}
			if (notify) {
				notify();
			}
		}
		this._sendRequest(rqstSvc, params, params.svc ? "svc=" + params.svc : "",

			function(data, response, notifyComplete) {
				onComplete(data, true, notifyComplete);
			},
			null,

			function(error, notifyComplete) {
				onComplete(error, false, notifyComplete);
			}, false, options);
	},

	_oneLineHelpRqst: function(rqstSvc, params, post, data, currentTarget) {
		var hCategory, fctId, hKeyWord, currField, noHelp = "ANONE",
			proto, page, helpSC = syraUtil.helpToken;
		if ((page = syraUtil.getPage(currentTarget))) {
			if (!data[helpSC.cat] && data.$link) {
				hCategory = _.find(sapUtil.helpHandler, function(value, key) {
					return value.linkId == data.$link;
				});
				data[helpSC.cat] = hCategory && hCategory.cat;
			}
			if (data[helpSC.cat]) {
				// Legacy help
				if (!data[helpSC.kw]) {
					data[helpSC.kw] = noHelp;
					if (data[helpSC.cat] == sapUtil.helpHandler.fld.cat && (currField = this._sapController.getCurrInst(true))) {
						proto = syraUtil.getEntityProto(currField.xid, syraUtil.get$FromPage(page));
						if (proto) {
							data[helpSC.kw] = proto.$keyword || noHelp;
							data[helpSC.ttl] = proto.$keyword ? currentTarget.getTitle() : "";
						}
					} else if (data[helpSC.cat] == sapUtil.helpHandler.fct.cat && (currField = syraUtil.getFusionPageMeta(page))) {
						if ((fctId = currField.winModel.getFctName())) {
							data[helpSC.kw] = fctId.name;
							data[helpSC.ttl] = fctId.title;
						}
					}
				}
				page.openHelp(null, page.parseExpression("{" + helpSC.bUrl + "}", null, data));
			} else {
				// Other help topic...
			}
		}
	},

	initialize: function(site, cnxHttpLoc) {
		this._log = document[sapUtil._fNS].log;
		this._site = site;
		this._session = null;
		this.httpQuery = null;
		this._localOpts = {};
		this._svcActMapping = {};
		this._hosterController = this._site.getHosterController();
		this._uiLocking = new _uiLockDefault();
		this._initSvcs(_cnxSvc, cnxHttpLoc);
	},

	forceUnlockUI: function() {
		try {
			if (this._uiLocking) {
				this._uiLocking.unLock(null, true);
			}
		} catch (e) {}
	},

	completeInit: function(rqstLocation, httpQuery, session, localOpts) {
		// More init...
		this._log = session.logger || this._log;
		this._localOpts = localOpts || this._localOpts;
		this._session = session;
		this.httpQuery = httpQuery;
		this.protoQueryOpts = {
			"headers": {
				"accept-language": this._session ? this._session.cdIsoLang : localize.defLang
			},
			"noDisplayErr": true
		};
		// Formatter policies
		if (session && session.format.wrapper) {
			this._formatAdx = session.format;
			_rqstSvc["format"].act[1] = "_localFormatSvcRqst";
		}
		// Services initialization
		if (rqstLocation) {
			this._initRqstSvcs(rqstLocation);
		}
		// Init sap controller and internal event handling
		(this._sapController = new SapController()).initialize(this);
		this.evtManagerInit(_evtHandlingModules, ["sap", "ui"], {
			"controller": this,
			"sapController": this._sapController,
			"siteUUID": this._site.uuid
		});
		this.evtManagerComplete();
		this._bindListeners();
		// Asynchronous Jobs list
		(this.asynchronousJobs = new AsyncJobs()).initialize(this);
	},

	_bindListeners: function() {
		this.bind("sap.win.unstacked", (this._site.getHosterInstance()).closeSheet, false, true, this._site.getHosterInstance());
	},

	_unbindListeners: function() {
		this.unbind("sap.win.unstacked", this._site.getHosterInstance());
	},

	onSharedResReady: function() {
		this._sapController.onSharedResReady();
	},

	onStart: function(statements, sharedResErr, notifyError) {
		var self = this,
			isAbortReply = null,
			_elapse, recovery, err;
		var sttmntsErr = !statements || !SapModule.isSapReply(statements) ? [util.makeDiagnosis(localize.getMessage(this._site.cdIsoLang, "4") + "\n" + localize.getMessage(this._site.cdIsoLang, "2"), 4, "client.Controller.onStart()", "04", util.cltFusionNice)] : null;
		if (sharedResErr) {
			recovery = {
				"typ": "RqstSrv",
				"act": requestActions.getSrvAction("SRV_FIN_APPLI"),
				"param": {
					"ist": null,
					"v": ""
				}
			};
		}
		if (!sttmntsErr) {
			SapModule.cleanInitialReply(statements);
			isAbortReply = this._sapController.isAbortReply(statements);
		} else {
			recovery = {
				"typ": "DelSess",
				"panic": true
			};
		}
		if (!isAbortReply) {
			this._site.updtCnxStatus(sapUtil.cnxStatus.established);
			if (sharedResErr || sttmntsErr) {
				try {
					this._sapController._sapException(null, sttmntsErr || sharedResErr, recovery);
				} catch (ex) {
					isAbortReply = sttmntsErr || sharedResErr;
				}
			} else {
				// All is ok, we can parse first sap reply
				_elapse = (new Date()).getTime();
				this._sapController.processReply(statements);
				this._log.timer(null, "First reply internal processing duration : [" + ((new Date()).getTime() - _elapse) + "]");
			}
		}
		return isAbortReply;
	},

	onSapUIHidden: function() {
		// Sap client is now attached to the "portal" Window (i.e level 0)
		this._site.updtCnxStatus(sapUtil.cnxStatus.closedByPortal);
		this._delSapSess(true);
	},

	onSapCloseEmergency: function(additionalSess) {
		// Panic close
		if (this._site) {
			this._site.updtCnxStatus(sapUtil.cnxStatus.closedPanic);
		}
		this._delSapSess(false, true, additionalSess);
	},

	onSapCompleted: function() {
		// Sap client has been closed by the back-office.
		this._site.updtCnxStatus(this._site.checkCnxStatus(sapUtil.cnxStatus.closing, null, true) ? sapUtil.cnxStatus.closedByClt : sapUtil.cnxStatus.closedBySrv);
		this._delSapSess(false);
	},

	loadRepresentation: function(representation, article, success, error, customProto, stamp, onErr) {
		function _onProtoComplete($itemPage) {
			var $proto = $itemPage.$representation.$prototype;
			var $facet = representation.$facet || syraUtil.mapWinTypeToFacet($proto.$x3Facet) || syraUtil.pageFacet.edit;
			_srvDuration = _elapse.inter();
			$itemPage.$autoFetch = false;
			$itemPage.$category = "fusion";
			$itemPage.$fusionPageMeta = {
				"controller": self,
				"winId": representation.id
			};
			$itemPage.$urlParts.$facet = "$fusion_" + $facet;
			$itemPage.externalAdapter = hosterInstance;
			if (!$proto[syraUtil.helpToken.bUrl]) {
				$proto[syraUtil.helpToken.bUrl] = (self.getSession()).getHelpBaseUrl();
			}
			try {
				success(hosterInstance.loadSheet($itemPage, $facet));
				self._uiLocking.ensureOverlay();
				self._log.timer(null, "Load page duration for '" + representation.name + "': total [" + _elapse.elapsedMs() + "], with ajax [" + _srvDuration + "] and local [" + (_elapse.elapsedMs() - _srvDuration) + "]");
			} catch (ex) {
				diag = util.makeDiagnosis(self._session.getlabel("error", "68", "Unexpected error loading window : ") + " '" + representation.name + "'.\n" + self._session.getlabel("error", "26", "The expected function could not be opened. Please, contact your system administrator if the issue persists."), 3, ex.stack, "68", util.cltFusionNice, ex.message);
				onErr([diag], ex);
			}
		}
		var diag, self = this,
			hosterSite = this._site.getHosterSite(),
			hosterInstance = this._site.getHosterInstance(),
			_elapse = utilBis.getTimer(true),
			_srvDuration;
		this.httpQuery.$urlParts.params.representation = representation.name + ".$fusion";
		if (representation.$variant) {
			this.protoQueryOpts.params = {
				"modelRepresentation": representation.$variant
			};
		} else {
			delete this.protoQueryOpts.params;
		}
		if (!representation.$itemPage) {
			this._hosterController.loadRepresentation(article, this.httpQuery, _onProtoComplete, error, customProto, this.protoQueryOpts);
		} else {
			_onProtoComplete({
				"$urlParts": {},
				"$representation": {
					"$prototype": representation.$itemPage
				}
			});
		}
	},

	getImageUrl: function(xid) {
		return this.imageHttpSvc.$location.$url + "?type=" + syraUtil.dataTypes.imageType + (xid ? "&id=" + xid : "");
	},

	getDocumentUrl: function(xid) {
		return this.exportXlsHttpSvc.$location.$url + (xid ? "?id=" + xid : "");
	},

	getSession: function() {
		return this._session;
	},

	getFormatWrapper: function() {
		return this._formatAdx.wrapper;
	},

	getLogger: function() {
		return this._log;
	},

	getLang: function(iso) {
		return this._session ? this._session[iso ? "cdIsoLang" : "cdLang"] : null;
	},

	getMessLabel: function(code, catg, dflt) {
		return this._session.getlabel(catg, code, dflt);
	},

	isSapActiveWindow: function(winId) {
		return this._sapController.isActiveWindow(winId);
	},

	isRqstPending: function() {
		var j, len, pendingRqst = false;
		for (j = 0, len = this._svcIdsArray.length; j < len; j++) {
			if (this[_rqstSvc[this._svcIdsArray[j]].proxy]._tech.pending) {
				pendingRqst = true;
				break;
			}
		}
		return pendingRqst;
	},

	triggerAdx: function(event, object) {
		try {
			// Note : trigger return 'false' if at least one handler has explicitly processed the event.
			var winEvt = null,
				privateEvtManager = null,
				targetMeta = null,
				nativeEvt, evtTimelapse = (new Date()).getTime(),
				succeeded = true,
				intercepted = false,
				evtDomain, evtProps = (this.getEvtName(event)).split("."),
				actId, mapping;
			evtDomain = evtProps[0];
			// Standard control : only for "local" and "widget" event domain.
			if (evtDomain == "lcl" || evtDomain == "wdgt") {
				if (object) {
					winEvt = syraUtil.getFusionPageMeta(object.target);
					targetMeta = syraUtil.getMetaFromObject(object.target);
					if (!(privateEvtManager = winEvt ? winEvt._privateEventManager : privateEvtManager)) {
						if (object.target._isOurMagicSgxWin_ && (nativeEvt = syraUtil.getFusionPageMeta(object.target.getSyraPage()))) {
							privateEvtManager = nativeEvt._privateEventManager;
						}
					}
				}
				if (winEvt && (winEvt = winEvt.winModel) && winEvt.isPreviewWin() && evtProps[1] != "link" && evtProps[1] != "tabs") {
					// Neutralize events when window preview
					succeeded = false;
				} else if ((evtProps[1] == "field" || evtProps[1] == "cell") && targetMeta && targetMeta.$bind && targetMeta.$bind[0] === "$") {
					// Bypass events form ui framework field (except TAB)
					nativeEvt = object.data && object.data.nativeEvt;
					if (evtProps[2] == "keydown" && nativeEvt && nativeEvt.keyCode == keys["VK_TAB"]) {
						succeeded = true;
					} else {
						return true;
					}
				}
			}
			// Call handler
			if (succeeded) {
				// If event object implement "target', we notify target that an event occurred... and give it the opportunity to interrupt event process
				if (object && object.target && object.target.beforeTrigger && !object.target.beforeTrigger(event, object)) {
					// So, we must stop trigger event process. "retrun true" mean caller could continue to process/bubble this event.
					return true;
				}
				intercepted = !intercepted && (!privateEvtManager ? this.trigger.apply(this, arguments) : privateEvtManager.trigger.apply(privateEvtManager, arguments));
				// Process result
				if (intercepted !== undefined) {
					if (object.result && object.result.diagnoses) {
						// TODO : Display diagnoses
					} else if (object.result && object.result.$act) {
						if (object.result.$act > requestActions.srvActionStart) {
							if (this[_rqstSvc.sapPost.proxy]._tech.pending || this._site.checkCnxStatus(sapUtil.cnxStatus.established, true)) {
								this._log.debug({
									"severety": "warn"
								}, "Native protocol request is pending...");
								succeeded = false;
							} else {
								succeeded = this.postSapRqst(object.result.$act, object.result.params, object.result.post, {
									"preProcElapse": evtTimelapse
								});
							}
						} else if (this._svcActMapping[(actId = object.result.$act.toString())]) {
							mapping = this._svcActMapping[actId];
							if (object.opts) {
								object.opts.preProcElapse = evtTimelapse;
							} else {
								object.opts = {
									"preProcElapse": evtTimelapse
								};
							}
							this[mapping.dispatch](mapping.rqstSvc, object.result.params, object.result.post, object.opts, object.target);
						} else if (object.result.$act > requestActions.srvActionStart) {
							// Local action... todo if necessary
							succeeded = true;
						}
					}
				}
			}
			// Remark : "return true" mean caller could continue to process/bubble this event. "false" mean event was processed by our event manager, caller must stop to deal with this event.
			return (!succeeded || (intercepted !== undefined && intercepted)) ? false : true;
		} catch (ex) {
			var mess = this._session.getlabel("error", "29", "An unexpected javascript error occured. Please, try again");
			this._sapController._sapException(null, [util.makeDiagnosis(mess, 3, ex.stack, "29", util.cltFusionNice, "Script error catched in 'controller.triggerAdx()' : " + ex.message)]);
			return false;
		}
	},

	_localFormatSvcRqst: function(rqstSvc, input, post, options) {
		var output = this._formatAdx.wrapper.formatSvc(input.svc, input, options),
			self = this;
		if (post) {
			setTimeout(function() {
				post.callback.apply(self, post.args ? [output.succeeded, output].concat(post.args) : [output.succeeded, output]);
			}, 5);
		}
	},

	dispose: function() {
		this.forceUnlockUI();
		if (this.asynchronousJobs) {
			this.asynchronousJobs.dispose();
		}
		if (this._svcActMapping) {
			_.each(this._svcActMapping, function(value, key) {
				delete value.rqstSvc;
			}, this);
		}
		if (this.httpQuery) {
			delete this.httpQuery;
		}
		if (this._sapController) {
			this._sapController.dispose();
			delete this._sapController;
		}
		delete this._formatAdx;
		if (this._session) {
			delete this._session;
		}
		_.each(_rqstSvc, function(value, key) {
			if (this[value.proxy] && this[value.proxy].data) {
				delete this[value.proxy].data;
			}
		}, this);
		if (this._evtMngrComplete) {
			this._unbindListeners();
			this.evtManagerDispose();
		}
		if (this._site) {
			delete this._site;
		}
		if (this._log) {
			delete this._log;
		}
	}
});

// Lock UI class
var _uiLockDefault = helpers.defineClass(

	function(dummy, opts) {
		this._locked = false;
		this._longProcessing = false;
		this._lockerId = null;
		this._dummy = !! (dummy);
	}, null, {
		lock: function(lockerId, longProcess) {
			if (this._dummy) {
				return;
			} else if (!this._locked) {
				this._lockerId = lockerId;
				this._locked = true;
				this._longProcessing = false;
				siteUILocking.lock(900);
				//document[sapUtil._fNS].log.trace({"severety": "warn"}, "**** UI locked by '" + (this._lockerId || "") + "' ***");
			} else if (longProcess != this._longProcessing && (!this._lockerId || lockerId === this._lockerId)) {
				siteUILocking.lock(1, (this._longProcessing = longProcess));
				//document[sapUtil._fNS].log.trace({"severety": "warn"}, "**** UI locked 'long' by '" + (this._lockerId || "") + "' ***");
			}
		},
		unLock: function(lockerId, force) {
			if (this._dummy) {
				return;
			} else if (this._locked && (force || !this._lockerId || lockerId === this._lockerId)) {
				this._locked = false;
				this._longProcessing = false;
				siteUILocking.unlock();
				//document[sapUtil._fNS].log.trace({"severety": "warn"}, "**** UI UNLocked by '" + (this._lockerId || "") + (force ? "' in forced mode " : "'") + " ***");
				this._lockerId = null;
			}
		},
		ensureOverlay: function(lockerId) {
			if (!this._dummy && this._locked) {
				siteUILocking.ensureOverlay();
			}
		}
	});