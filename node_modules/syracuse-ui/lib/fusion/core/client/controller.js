"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Site controller
 */


var helpers = require('syracuse-core/lib/helpers');
var SapController = require('syracuse-ui/lib/fusion/core/client/sap/controller').Controller;
var util = require('syracuse-ui/lib/fusion/tools/util');
var utilBis = require('syracuse-ui/lib/fusion/tools/utilFdb');
var syraUtil = require('./sap/util').Syra;
var sapUtil = require('./sap/util').Fusion;
var EventManager = require('./evtmanager').EventManager;
var requestActions = require('./sap/srvactions');
var localize = require('syracuse-ui/lib/fusion/tools/localize').localize;
var AsyncJobs = require('syracuse-ui/lib/fusion/core/client/sap/job').AsyncJobsManagement;
var keys = require('syracuse-ui/lib/fusion/tools/constant').keybordKey;
var msgBox = require('syracuse-ui/lib/fusion/core/client/sap/msgbox');

var _evtHandlingModules = {
    "tabs": require('./eventhandling/tabs').TabsEventHandling,
    "list": require('./eventhandling/list').ListEventHandling,
    "link": require('./eventhandling/link').LinkEventHandling,
    "grid": require('./eventhandling/grid').GridEventHandling,
    "win": require('./eventhandling/windowEx').WindowEventHandling,
    "blckex": require('./eventhandling/blockex').BlockExEventHandling,
    "tree": require('./eventhandling/tree').TreeEventHandling
};
var _rqstSvc = {
    "sapPost": {"name": "Native protocol", "act": null, "proxy": "sapHttpSvc", "method": "PUT", "subUrl": "requestSvc", "contentType": "application/json", "tracking": true},
    "sapDel": {"name": "Shutdown session", "act": null, "proxy": "sapHttpSess", "method": "DELETE", "subUrl": null, "contentType": "application/json"},
    "format": {"name": "Format service", "act": [requestActions.svcFormat, "_basicSvcRqst"], "proxy": "fmtHttpSvc", "method": "PUT", "subUrl": "formatSvc", "contentType": "application/json"},
	"imageBlob": {"name": "Image Blob", "act": null, "proxy": "imageHttpSvc", "method": null, "subUrl": "blobSvc", "contentType": "image/"},
	"exportXls": {"name": "Excel export", "act": null, "proxy": "exportXlsHttpSvc", "method": null, "subUrl": "blobSvc", "contentType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}
};
var _cnxSvc = {
    "sapCnx": {"name": "Session connection", "act": null, "proxy": "sapHttpCnx", "method": "POST", "subUrl": "", "contentType": "application/json", "tracking": false}
};
var _kPanicQr = "panic=true";

function Controller(){
}

exports.Controller = helpers.defineClass(Controller, EventManager, {
    _initRqstSvcs: function(rqstHttpLoc){
        this._initSvcs(_rqstSvc, rqstHttpLoc);
        this._svcIdsArray = Object.keys(_rqstSvc);
    },

    _initSvcs: function(svcsDesc, svcHttpLoc){
        _.each(svcsDesc, function(value, key){
            this[value.proxy] = {};
            this[value.proxy].noDisplayErr = true;
            this[value.proxy]._tracking = !!(value.tracking);
            this[value.proxy].method = value.method || "POST";
            this[value.proxy].$location = util.duplicateObj(svcHttpLoc);
            this[value.proxy].$location.$method = this[value.proxy].method;
            this[value.proxy].$location.$url = svcHttpLoc.$url + (value.subUrl && value.subUrl.length > 0 ? ("/" + value.subUrl) : "");
            this[value.proxy].$location.$type = value.type || svcHttpLoc.$type || "application/json";
            this[value.proxy].$location.$contentType = value.contentType || svcHttpLoc.$contentType || "application/json";
            this[value.proxy]._tech = {};
            this[value.proxy]._tech.pending = false;
            this[value.proxy]._tech.count = {"s": 0, "r": 0, "ex": 0};
            this[value.proxy]._tech.elapse = utilBis.getTimer();
            if(value.act) {
                this._svcActMapping[value.act[0].toString()] = {"dispatch": value.act[1], "rqstSvc": value};
            }
        }, this);
    },

    isFixtureMode:function(){
        return this._localOpts.fixture;
    },
    
    _sendRequest: function(svc, data, queryString, onSuccess, onPolling, onError, delegatePending, options, pollingManifest){
        var qs = null, qsEx = null, self = this, rqstPlg = null;
        // Fixture mode
        if(this._localOpts.fixture) {
            if(this._localOpts.fixture.on && this._localOpts.fixture.reply[this._localOpts.fixture.hash + this._localOpts.fixture.next]) {
                onSuccess(this._localOpts.fixture.reply[this._localOpts.fixture.hash + this._localOpts.fixture.next++]);
            }
            return;
        }
        // Check pending state...
        if(this[svc.proxy]._tech.pending && !pollingManifest) {
            this._log.debug({"severety": "warn"}, "Request " + svc.name + " is pending...");
            if(options && options.onSvcPendingCallback) {
                options.onSvcPendingCallback();
                delete options.onSvcPendingCallback;
            }
            //alert("'controller._sendRequest()' : request '" + svc.name + "'' is pending... try again!!"); // TODO : improve
            return;
        }
        if(!pollingManifest) {
            this[svc.proxy]._tech.pending = true;
            this[svc.proxy]._tech.elapse.start();
            // Check options...
            if(options) {
                if (options.preProcElapse) {
                    this[svc.proxy]._tech.preProcElapse = (new Date()).getTime() - options.preProcElapse;
                }
                delete options.onSvcPendingCallback;
            }
            // Buil request
            this[svc.proxy]._tech.count.s++;
            qs = this[svc.proxy].$location.$url.indexOf("?");
            (qs >=0 ? this[svc.proxy].$location.$url = this[svc.proxy].$location.$url.substr(0, qs) : void(0));
            if(queryString && queryString.length > 0) {
                qsEx = queryString + (this[svc.proxy]._tracking ? ("&trackngId=" + this[svc.proxy]._tech.count.s) : "");
            }
            else if (this[svc.proxy]._tracking) {
                qsEx = "trackngId=" + this[svc.proxy]._tech.count.s;
            }
            (qsEx ? this[svc.proxy].$location.$url += ("?" + qsEx) : void(0));
            if(this[svc.proxy].data) {
                delete this[svc.proxy].data;
            }
            this[svc.proxy].data = data || null;
        }
        else {
            rqstPlg = {"noDisplayErr": this[svc.proxy].noDisplayErr, "method": pollingManifest.method || "GET", "$location": {"$url": pollingManifest.$location}};
        }
        // Send request
        this._hosterController.sendRequest(null, rqstPlg || this[svc.proxy],
            function (dataResp, response) {
                var plgManifest, plgType;
                function doPolling (pollingMillis) {
                    if(self._log) {
                        self._log.trace({"severety": "warn"}, "Request '" + svc.name + "' is in polling mode... waiting " + pollingMillis + " ms.");
                    }
                    setTimeout(function() {
                        self._sendRequest(svc, null, null, onSuccess, onPolling, onError, delegatePending, options, plgManifest);
                    }, pollingMillis);
                }
                if(response.status == 202 && self[svc.proxy]._tracking) {
                    // Polling!
                    plgType = dataResp && dataResp.type || "default";
                    plgManifest = {"$location" : response.headers.location, "method": "GET", "type": plgType};
                    if(!onPolling) {
                        doPolling(dataResp && dataResp.pollingMillis || 1000);
                    }
                    else {
                        onPolling(plgType, dataResp, function(success) {
                            if (success) {
                                // TODO : how to notify srv that an error occur?
                                doPolling(dataResp && dataResp.pollingMillis || 1000);
                            }
                        });
                    }
                    return;
                }
                self[svc.proxy]._tech.count.r++;
                self[svc.proxy]._tech.elapseAjax = self[svc.proxy]._tech.elapse.inter();
                if(!delegatePending) {
                    self[svc.proxy]._tech.pending = false;
                    onSuccess(dataResp, response);
                }
                else {
                    onSuccess(dataResp, response, function () {
                        self[svc.proxy]._tech.pending = false;
                    });                    
                }
                if(self._log) {
                    self._log.timer(null, "Request duration for '" + svc.name + "' : total [" + self[svc.proxy]._tech.elapse.elapsedMs() + "], with ajax [" + self[svc.proxy]._tech.elapseAjax + "] and local [" + (self[svc.proxy]._tech.elapse.elapsedMs() - self[svc.proxy]._tech.elapseAjax) + "]" + (!self[svc.proxy]._tech.preProcElapse ? "" : ". Extra local pre-process duration [" + self[svc.proxy]._tech.preProcElapse + "]"));
                }
            },
            function (error) {
                self[svc.proxy]._tech.count.r++;
                self[svc.proxy]._tech.count.ex++;
                self[svc.proxy]._tech.elapseAjax = self[svc.proxy]._tech.elapse.inter();
                if(!delegatePending) {
                    self[svc.proxy]._tech.pending = false;
                    onError(error);
                }
                else {
                   onError(error, function () {
                        self[svc.proxy]._tech.pending = false;
                    });
                }
                if(self._log) {
                    self._log.timer(null, "Request '" + svc.name + "' FAILED! Duration : total [" + self[svc.proxy]._tech.elapse.elapsedMs() + "], with ajax [" + self[svc.proxy]._tech.elapseAjax + "] and local [" + (self[svc.proxy]._tech.elapse.elapsedMs() - self[svc.proxy]._tech.elapseAjax) + "]");
                }
            }
        );
    },
 
    postCnxpRqst: function(cnxData, onSuccess, onError, options){
        var proxy = this[_cnxSvc.sapCnx.proxy], qs = proxy.$location.$url.split("?"), pngFullReply;
        if(qs.length > 1) {
            proxy.$location.$url = qs[0];
            proxy._tech.cnxQs = qs[1];
        }
        proxy.params = {"trackingId": helpers.uuid.generate()};
        this._sendRequest(_cnxSvc.sapCnx, cnxData, qs[1], 
            function(data, response) {
                var respH = response.headers;
                onSuccess({"$url": respH.location, "type": respH["content-type"]}, data);
            },
            function(pngType, pngData, pngCbk) {
                try {
                    if(pngData && pngData.reply) {
                        // Tant que pas de noeud target, close, reboot, func... on consolide
                        // Si ok, on bootstrap (quid des shrared res)
                        // ensuite on parse le reply...
                        // Quid du session "established"
                        // Quid du location définitif : sur le 200
                     }
                }
                catch(ex) {
                    pollingErr = [util.makeDiagnosis(self._session.getlabel("error", "18", localize.getMessage(self._session.cdIsoLang, "13")), 4, ex.message + "\n" + ex.stack, "18", util.cltFusionNice)];
                }
                pngCbk(true);
            },
            function(error) {
                onError(error);
            },
            false, options);
     },

    postSapRqst: function(action, params, post, options){
        var self = this, rqstData, currIst, pollingErr = null;
        // Init
        if(!options) {
            options = {};
        }
        if(this._site.checkCnxStatus(sapUtil.cnxStatus.established, true)) {
            // TODO : bloquer!
        }
        this._sapController.removeFocus();
        // Get request data
        rqstData = self._sapController.getRequestData("", action, params);
        // Value control...
        if(rqstData.ctrlResult && !rqstData.ctrlResult.succeeded) {
            currIst = util.duplicateObj(this._sapController.getCurrInst());
            currIst.v = rqstData.fld.v;
            currIst.ctrlFailed = true;
            setTimeout(function(){self._sapController.stubSapTarget_ist(currIst);}, 5);
            if(post) {
                if (post.onErrCallBack) {
                    setTimeout(function() {
                        post.onErrCallBack.apply(self, (post.exposeReply ? (post.args ? ([true, null].concat(post.args)) : [true, null]) : (post.args ? [true].concat(post.args) : [true])));
                        delete post.onErrCallBack;}, 5);
                }
                delete post.callback;
                delete post.onSvcPendingCallback;
            }
            return false;
        }
        delete rqstData.ctrlResult;
        // Check special options...
        if(post && post.onSvcPendingCallback) {
            options.onSvcPendingCallback = post.onSvcPendingCallback;
        }
        // Send request
        if(action == requestActions.getSrvAction("SRV_FIN_APPLI") || action == requestActions.getSrvAction("SRV_TIMEOUTSESS")) {
            this._site.updtCnxStatus(sapUtil.cnxStatus.closing);
        }
        this._sendRequest(_rqstSvc.sapPost, rqstData, "act=" + action,
            function(data, response, notifyComplete) {
                var ret, chain = null, ist, ctrlFailed;
                if(pollingErr) {
                    // A local error occured while processing a partial reply in polling mode. It's fatal!
                    pollingErr.splice(0, 0, util.makeDiagnosis(self._session.getlabel("error", "67", "Error while processing last server response (polling mode)."), 4, "sap.Controller.postSapRqst()", "67", util.cltFusionNice));
                    self._sapController._sapException(null, pollingErr, {"typ": "DelSess"});
                    return;
                }
                ret = self._sapController.processReply(data, {"_techReply": {"replyComplete": notifyComplete}});
                try {
                    if(ret && post && post.callback) {
                        ist = self._sapController.getTargetIstFromReply(data);
                        ctrlFailed = self._sapController.isControlFailedInReply(null, ist);
                        if(options.forceChain || (!ctrlFailed && (sapUtil.cmpIst(params.target, ist) || ((sapUtil.isBlockInst(params.target.xid) || sapUtil.isLineGridInst(params.target)) && sapUtil.cmpIstGrid(params.target, ist))))){
                            chain = post.callback.apply(self, (post.exposeReply ? (post.args ? ([data].concat(post.args)) : [data]) : post.args));
                        }
                        else if(post.onErrCallBack) {
                           post.onErrCallBack.apply(self, (post.exposeReply ? (post.args ? ([ctrlFailed, data].concat(post.args)) : [ctrlFailed, data]) : (post.args ? [ctrlFailed].concat(post.args) : [ctrlFailed])));
                        }
                    }
                    if(post) {
                        delete post.callback;
                        delete post.onErrCallBack;
                        delete post.exposeReply;
                        if(ret && chain) {
                            // All conditions are met to chain server action
                            setTimeout(function(){
                                self.postSapRqst(chain.$act, chain.params, chain.post);
                            }, 2);
                        }
                    }
                    // TODO : check error...
                }
                catch (ex) {
                    // Lack of better... we close the session, how it was an ajax error...
                    var ourAjaxErr = util.makeOurAjaxErrEx("CLOSESESS", [util.makeDiagnosis("stack trace...", 4, ex.stack, 18)], 18, localize.getMessage(self._site.cdIsoLang, "13"), "Script error catched in 'controller.postSapRqst/Onsuccess() : " + ex.message);
                    self._ourSapRqstError(ourAjaxErr, false, notifyComplete);
                 }
            },
            function(pngType, pngData, pngCbk) {
                var pngParseCtx = {"ignoreTargetLess": true, "throwError": true, "pollingMode": true};
                try {
                    if(pngData && pngData.reply && !pollingErr) {
                        if(!self._sapController.processReply(pngData.reply, pngParseCtx)) {
                            if(pngParseCtx.diagnoses && pngParseCtx.diagnoses.length > 0) {
                                pollingErr = util.duplicateObj(pngParseCtx.diagnoses);
                            }
                            else {
                                pollingErr = [util.makeDiagnosis(self._session.getlabel("error", "7", "unexpected error while parsing reply."), 4, "postSapRqst", "7", util.cltFusionNice)];
                            }
                        }
                    }
                }
                catch(ex) {
                    pollingErr = [util.makeDiagnosis(self._session.getlabel("error", "18", localize.getMessage(self._session.cdIsoLang, "13")), 4, ex.message + "\n" + ex.stack, "18", util.cltFusionNice)];
                }
                pngCbk(true);
            },
            function(error, notifyComplete) {
                var ourAjaxErr;
                if(!(ourAjaxErr = util.isOurAjaxErrEx(error))) {
                    // Close the client without notifying the server because we don't have any information about the issue!
                    ourAjaxErr = util.makeOurAjaxErrEx("KILL", util.getDiagnosesFromAjax(error, self._session), 23, localize.getMessage(self._site.cdIsoLang, "14"));
                }
                self._ourSapRqstError(ourAjaxErr, true, notifyComplete);
            }, true, options);
            return true;
    },

    _ourSapRqstError: function(ourAjaxErr, setDefMess, notifyComplete) {
        var diagnoses = util.makeDiagnosesFromOurAjaxErrEx(ourAjaxErr, this._session), recovery = null;
        var messErr = !this._session ? ("Web server encountered following error during last request processing" + ", ") : this._session.getlabel("error", "19", "Web server encountered following error during last request processing") + ", ";
        var messCallback = null, self = this, boxOpts, boxParams;
        switch (ourAjaxErr.$recoveryCode) {
            case "CLOSESESS" : 
                messErr += (!this._session ? "Session will be closed" : this._session.getlabel("error", "21", "Session will be closed"));
                messCallback = function () {
                    util.releaseOurAjaxErrEx(ourAjaxErr);
                    self.onSapCompleted();
                };
                break;
            case "DISCONNECT" : 
                recovery = {"typ": "RqstSrv", "act": requestActions.getSrvAction("SRV_FIN_APPLI")};
                messErr += (!this._session ? "Session will be closed" : this._session.getlabel("error", "21", "Session will be closed"));
                messCallback = function () {
                    util.releaseOurAjaxErrEx(ourAjaxErr);
                };
                break;
            case "KILL" : 
                messErr += (!this._session ? "Session will be killed" : this._session.getlabel("error", "24", "Session will be killed"));
                messCallback = function () {
                    util.releaseOurAjaxErrEx(ourAjaxErr);
                    self.onSapCloseEmergency();
                };
                break;
            case "ABORT" : 
                 messErr += (!this._session ? "Session will be aborted" : this._session.getlabel("error", "25", "Session will be aborted"));
                 messCallback = function () {
                    util.releaseOurAjaxErrEx(ourAjaxErr);
                    if(self._site) {
                        self._site.free("closed");
                    }
                };
                break;
            case "BUSY" : 
            default:
                break;
        }
        if(setDefMess) {
            diagnoses.message = diagnoses.message ? messErr + " : \n" + diagnoses.message : messErr + " : ...";
        }
        if(this._sapController) {
            this._sapController._sapException(null, diagnoses, recovery, null, messCallback, notifyComplete);
        }
        else {
            boxParams = util.diagnosesToOurErrEx(diagnoses);
            msgBox.setMsgBoxDefaultProp(boxParams, 4, 180);
            boxOpts = msgBox.getMsgBoxOpts.call(this, boxParams);
            boxOpts.callback = function(resp, closureMode){
                self.dispose();
            };
            setTimeout(function(){syraUtil.msgBox(boxOpts);}, 5);
        }
    },

    delSapSessExPanic: function(additionalSess){
        var self = this, qr = _kPanicQr + (additionalSess ? additionalSess : ""); 
        this._sendRequest(_rqstSvc.sapDel, null, qr, function() {if(self._site){self._site.updtCnxStatus(sapUtil.cnxStatus.deleted)};return;}, null, function() {if(self._site){self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed)}; return;}, false);
        setTimeout(function () {if(self._site) {self._site.free;}}, 10);
        return;
    },

    _delSapSess: function(reuse, panic, additionalSess){
        var self = this, qr = undefined, i, lenx;
        function onComplete(mode, notify) {
            setTimeout(function () {if(self._site) {self._site.free(mode);}}, 20);
            if(notify) {
                notify();
            }
        }
        if (this._site) {
            this._site.updtCnxStatus(sapUtil.cnxStatus.deleting);
        }
        if(panic) {
            qr = _kPanicQr;
            if(additionalSess && (lenx = additionalSess.length) > 0) {
                for (i = 0; i < lenx; i++) {
                      qr += ("&sid_" + i + "=" + additionalSess[i]);
                 }
            }
            this._sendRequest(_rqstSvc.sapDel, null, qr, function() {if(self._site){self._site.updtCnxStatus(sapUtil.cnxStatus.deleted)};return;}, null, function() {if(self._site){self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed)}; return;}, false);
            setTimeout(function () {onComplete("closed");}, 1500);
            return;
        }
        this._sendRequest(_rqstSvc.sapDel, null, reuse ? "reuse=true" : null, 
            function(data, response, notifyComplete) {
                if (self._site) {
                    self._site.updtCnxStatus(sapUtil.cnxStatus.deleted);
                }
                onComplete(reuse ? "hidden" : "closed", notifyComplete);
            },
            null,
            function(error, notifyComplete) {
                // Force close...
                var ourAjaxErr, diagnoses;
                if (self._site) {
                    self._site.updtCnxStatus(sapUtil.cnxStatus.deletedFailed);
                }
                if(!self.delSessRetry) {
                    self.delSessRetry = true;
                    if ((ourAjaxErr = util.isOurAjaxErrEx(error))) {
                        diagnoses = util.makeDiagnosesFromOurAjaxErrEx(ourAjaxErr, self._session);
                    }
                    else {
                        diagnoses = util.getDiagnosesFromAjax(error, self._session);
                    }
                    self._sapController._sapException(null, diagnoses, null, error, function() {
                        self._delSapSess(false, panic, additionalSess);    
                        return true;
                    }, notifyComplete);
                }
                else {
                    onComplete("closed", notifyComplete);
               }
            }, true);
    },
    
    _basicSvcRqst: function(rqstSvc, params, post, options){
        // Generic REST service : params.svc contains service ID
        var self = this;
        function onComplete(reply, succeeded, notify) {
            if(post) {
                post.callback.apply(self, post.args ? [succeeded, reply].concat(post.args) : [succeeded, reply]);
            }
            if(notify) {
                notify();
            }
        }
        this._sendRequest(rqstSvc, params, params.svc ? "svc=" + params.svc : "",
            function(data, response, notifyComplete) {
                onComplete(data, true, notifyComplete);
            },
            null,
            function(error, notifyComplete) {
                onComplete(error, false, notifyComplete);
            }, false, options);
    },

    initialize: function(site, cnxHttpLoc){
        this._log = document[sapUtil._fNS].log;
        this._site = site;
        this._session = null;
        this.httpQuery = null;
        this._localOpts = {};
        this._svcActMapping = {};
        this._hosterController = this._site.getHosterController();
        this._initSvcs(_cnxSvc, cnxHttpLoc);
    },

    postInit: function(srvOpts, localOpts){
        // More init...
        this._localOpts = localOpts || this._localOpts;
        (this._sapController = new SapController()).initialize(this, srvOpts);
        // Asynchronous Jobs list
        (this.asynchronousJobs = new AsyncJobs()).initialize(this, this._hosterController);
        // Init internal event handling
        EventManager.prototype.initialize.call(this, _evtHandlingModules, ["sap", "ui"], {"controller": this, "sapController": this._sapController, "siteUUID": this._site.uuid});
        this.evtManagerComplete();
        // Bind controller listeners
        this._bindListeners();
    },

    _bindListeners: function(){
        this.bind("sap.win.unstacked", (this._site.getHosterInstance()).closeSheet, false, true, this._site.getHosterInstance());
    },

    _unbindListeners: function(){
        this.unbind("sap.win.unstacked", this._site.getHosterInstance());
    },

    onStart: function(httpQuery, rqstLocation, session, statements, notifyError){
        var err, self = this, _elapse;
        this._session = session;
        this._log = session.logger || this._log;
        // Formatter policies
        if(session && session.format.wrapper) {
            this._formatAdx = session.format;
            _rqstSvc["format"].act[1] = "_localFormatSvcRqst";
        }
        if (rqstLocation) {
            this._initRqstSvcs(rqstLocation);
        }
        if(!statements) {
            err = [util.makeDiagnosis(localize.getMessage(this._site.cdIsoLang, "3"), 4, "client.Controller.onStart()", "03", util.cltFusionNice)];
            try {
                this._sapController._sapException(null, err, {"typ": "RqstSrv", "act": requestActions.getSrvAction("SRV_FIN_APPLI")});
            }
            catch (ex) {
                notifyError(err);
            }
        }
        else if(this._sapController.isSapReply(statements)){
            this.httpQuery = httpQuery;
            this.protoQueryOpts = {"headers": {"accept-language": this._session.cdIsoLang}, "noDisplayErr": this.httpQuery.noDisplayErr ? true : undefined};
            this._sapController.onConnected(statements, function(cnxErr, postCnxErr, data) {
                if(cnxErr) {
                    notifyError(cnxErr);
                }
                else if (postCnxErr) {
                    self._site.updtCnxStatus(sapUtil.cnxStatus.established);
                    self._sapController._sapException(null, postCnxErr, {"typ": "RqstSrv", "act": requestActions.getSrvAction("SRV_FIN_APPLI"), "param": {"ist": null, "v": ""}});
                }
                else {
                    // All is ok, we can parse first sap reply
                    self._site.updtCnxStatus(sapUtil.cnxStatus.established);
                    _elapse = (new Date()).getTime();
                    self._sapController.processReply(statements);
                    self._log.timer(null, "First reply internal processing duration : [" + ((new Date()).getTime() - _elapse) + "]");
                }
            });
        }
        else {
            // Who is talking to me ?
            notifyError([util.makeDiagnosis(localize.getMessage(this._site.cdIsoLang, "4") + "\n" + localize.getMessage(this._site.cdIsoLang, "2"), 4, "client.Controller.onStart()", "04", util.cltFusionNice)]);
        }
    },

    onSapUIHidden: function(){
        // Sap client is now attached to the "portal" Window (i.e level 0)
        this._site.updtCnxStatus(sapUtil.cnxStatus.closedByPortal);
        this._delSapSess(true);
    },

    onSapCloseEmergency: function(additionalSess){
        // Panic close
        if(this._site) {
            this._site.updtCnxStatus(sapUtil.cnxStatus.closedPanic);
        }
        this._delSapSess(false, true, additionalSess);
    },

    onSapCompleted: function(){
        // Sap client has been closed by the back-office.
        this._site.updtCnxStatus(this._site.checkCnxStatus(sapUtil.cnxStatus.closing, null, true) ? sapUtil.cnxStatus.closedByClt : sapUtil.cnxStatus.closedBySrv);
        this._delSapSess(false);
    },

    loadRepresentation: function(representation, article, success, error, customProto, stamp){
        var self = this, hosterSite = this._site.getHosterSite(), hosterInstance = this._site.getHosterInstance(), _elapse = utilBis.getTimer(true), _srvDuration;
        this.httpQuery.$urlParts.params.representation = representation.name + ".$fusion";
        this._hosterController.loadRepresentation(article, this.httpQuery, function($itemPage){
            _srvDuration = _elapse.inter();
            var $facet = representation.$facet || syraUtil.mapWinTypeToFacet($itemPage.$representation.$prototype.$x3Facet) || syraUtil.pageFacet.edit;
            $itemPage.$autoFetch = false;
            $itemPage.onPageLoaded = success;
            $itemPage.$category = "fusion";
            $itemPage.$fusionPageMeta = {"controller": self, "winId": representation.id};
            $itemPage.$urlParts.$facet = "$fusion_" + $facet;
            $itemPage.externalAdapter = hosterInstance;
            success(hosterInstance.loadSheet($itemPage, $facet));
            self._log.timer(null, "Load page duration for '" + representation.name + "': total [" + _elapse.elapsedMs() + "], with ajax [" + _srvDuration + "] and local [" + (_elapse.elapsedMs() - _srvDuration) + "]");
        }, error, customProto, this.protoQueryOpts);
    },

	getImageUrl: function(xid){
		return this.imageHttpSvc.$location.$url+"?type="+syraUtil.dataTypes.imageType+(xid?"&id="+xid:"");
	},

	getDocumentUrl: function(xid){
		return this.exportXlsHttpSvc.$location.$url+(xid?"?id="+xid:"");
	},
	
    getSession: function(){
        return this._session;
    },

    getFormatWrapper: function(){
        return this._formatAdx.wrapper;
    },

    getLogger: function(){
        return this._log;
    },

    getLang: function(iso) {
        return this._session[iso ? "cdIsoLang" : "cdLang"];
    },

    getMessLabel: function(code, catg, dflt) {
        return this._session.getlabel(catg, code, dflt);
    },
    
    isSapActiveWindow: function(winId){
        return this._sapController.isActiveWindow(winId);
    },

    isRqstPending: function(){
        var j, len, pendingRqst = false;
        for (j = 0, len = this._svcIdsArray.length; j < len; j++) {
             if(this[_rqstSvc[this._svcIdsArray[j]].proxy]._tech.pending) {
                pendingRqst = true;
                break;
            }
        }
        // TODO : be sure in the future to consider "long polling" (tempon, progress, etc..)
        return pendingRqst;
    },

    triggerAdx: function(event, object){
        try {
            // Note : trigger return 'false' if at least one handler has explicitly processed the event.
            var winEvt = null, targetMeta = null, nativeEvt, evtTimelapse = (new Date()).getTime(), succeeded = true, intercepted = false, evtDomain, evtProps = (this.getEvtName(event)).split("."), actId, mapping;
            evtDomain = evtProps[0]; 
            // Standard control : only for "local" and "widget" event domain.
            if(evtDomain == "lcl" || evtDomain == "wdgt") {
                if(object) {
                    winEvt = syraUtil.getFusionPageMeta(object.target);
                    targetMeta = syraUtil.getMetaFromObject(object.target);
                }
                if(winEvt && ( winEvt = winEvt.winModel) && winEvt.isPreviewWin() && evtProps[1] != "link" && evtProps[1] != "tabs") {
                    // Neutralize events when window preview
                    succeeded = false;
                }
                else if((evtProps[1] == "field" || evtProps[1] == "cell") && targetMeta && targetMeta.$bind[0] === "$") {
                    // Bypass events form ui framework field (except TAB)
                    nativeEvt = object.data && object.data.nativeEvt;
                    if(evtProps[2] == "keydown" && nativeEvt && nativeEvt.keyCode == keys["VK_TAB"]) {
                        succeeded = true;
                    }
                    else {
                        return true;
                    }
                 }
            }
            // Call handler
            if(succeeded) {
                // If event object implement "target', we notify target that an event occurred... and give it the opportunity to interrupt event process
                if (object && object.target && object.target.beforeTrigger && !object.target.beforeTrigger(event, object)){
                    // So, we must stop trigger event process. "retrun true" mean caller could continue to process/bubble this event.
                    return true;
                }
                intercepted = !intercepted && EventManager.prototype.trigger.apply(this, arguments);
                // Process result
                if(intercepted !== undefined)
                {
                    if(object.result && object.result.diagnoses)
                    {
                        // TODO : Display diagnoses
                    }
                    else if (object.result && object.result.$act) {
                        if (object.result.$act > requestActions.srvActionStart) {
                            if(this[_rqstSvc.sapPost.proxy]._tech.pending || this._site.checkCnxStatus(sapUtil.cnxStatus.established, true)) {
                                this._log.debug({"severety": "warn"}, "Native protocol request is pending...");
                                succeeded = false;
                            }
                            else {
                                succeeded = this.postSapRqst(object.result.$act, object.result.params, object.result.post, {"preProcElapse": evtTimelapse});
                            }
                        }
                        else if (this._svcActMapping[(actId = object.result.$act.toString())]) {                            
                            mapping = this._svcActMapping[actId];
                            if (object.opts) {
                                object.opts.preProcElapse = evtTimelapse;
                            }
                            else {
                                object.opts = {"preProcElapse": evtTimelapse};
                            }
                            this[mapping.dispatch](mapping.rqstSvc, object.result.params, object.result.post, object.opts);                         
                        }
                    }
                }
            }       
            // Remark : "retrun true" mean caller could continue to process/bubble this event. "false" mean event was processed by our event manager, caller must stop to deal with this event.
            return (!succeeded || (intercepted !== undefined && intercepted)) ? false : true;
        }
        catch (ex) {
            var mess = this._session.getlabel("error", "29", "An unexpected javascript error occured. Please, try again");
            this._sapController._sapException(null, [util.makeDiagnosis(mess, 3, ex.stack, "29", util.cltFusionNice, "Script error catched in 'controller.triggerAdx()' : " + ex.message)]);
            return false;
        }
    },

    _localFormatSvcRqst: function(rqstSvc, input, post, options){
        var output = this._formatAdx.wrapper.formatSvc(input.svc, input, options), self = this;
        if(post) {
            setTimeout(function() {
                post.callback.apply(self, post.args ? [output.succeeded, output].concat(post.args) : [output.succeeded, output]);
            }, 5);
        }
    },

    dispose: function(){
        if(this.asynchronousJobs) {
            this.asynchronousJobs.dispose();
        }
        if (this._svcActMapping){
             _.each(this._svcActMapping, function (value, key){
                delete value.rqstSvc;
             }, this);
        }
        if (this.httpQuery){
             delete this.httpQuery;
        }
        if (this._sapController){
            this._sapController.dispose();
            delete this._sapController;
        }
        delete this._formatAdx;
        if (this._session){
             delete this._session;
        }
        _.each(_rqstSvc, function(value, key){
            if (this[value.proxy] && this[value.proxy].data) {
                delete this[value.proxy].data;
            }
        }, this);
        if(this._evtMngrComplete) {
            this._unbindListeners();      
            EventManager.prototype.dispose.call(this);
        }
        if (this._site){
             delete this._site;
        }
        if (this._log){
             delete this._log;
        }
    }
});
