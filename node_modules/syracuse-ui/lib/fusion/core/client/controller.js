"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Fusion Site controller
 */


var helpers = require('syracuse-core/lib/helpers');
var SapController = require('syracuse-ui/lib/fusion/core/client/sap/controller').Controller;
var util = require('syracuse-ui/lib/fusion/tools/util');
var utilBis = require('syracuse-ui/lib/fusion/tools/utilFdb');
var syraUtil = require('./sap/util').Syra;
var sapUtil = require('./sap/util').Fusion;
var EventManager = require('./evtmanager').EventManager;
var requestActions = require('./sap/srvactions');
var localize = require('syracuse-ui/lib/fusion/tools/localize').localize;

var _evtHandlingModules = {
    "tabs": require('./eventhandling/tabs').TabsEventHandling,
    "list": require('./eventhandling/list').ListEventHandling,
    "link": require('./eventhandling/link').LinkEventHandling,
    "grid": require('./eventhandling/grid').GridEventHandling,
    "win": require('./eventhandling/windowEx').WindowEventHandling
};
var _rqstSvc = {
    "sapPost": {"name": "Native protocol", "act": null, "proxy": "sapHttpSvc", "method": "PUT", "subUrl": "requestSvc", "contentType": "application/json"},
    "sapDel": {"name": "Shutdown session", "act": null, "proxy": "sapHttpSess", "method": "DELETE", "subUrl": null, "contentType": "application/json"},
    "print": {"name": "Print services", "act": [requestActions.svcPrint, "_printRqst"], "proxy": "printHttpSvc", "method": "PUT", "subUrl": "print", "contentType": "application/json"},
	"format": {"name": "Format service", "act": [requestActions.svcFormat, "_basicSvcRqst"], "proxy": "fmtHttpSvc", "method": "PUT", "subUrl": "formatSvc", "contentType": "application/json"},
    "gridSortData": {"name": "Sort data grid service", "act": [requestActions.svcGridSort, "_basicSvcRqst"], "proxy": "miscHttpSvc", "method": "PUT", "subUrl": "miscSvc", "contentType": "application/json"}
};

function Controller(){
}

exports.Controller = helpers.defineClass(Controller, EventManager, {
    _initRqstSvcs: function(rqstHttpLoc){
        _.each(_rqstSvc, function(value, key){
            this[value.proxy] = {};
            this[value.proxy].noDisplayErr = true;
            this[value.proxy].method = value.method || "POST";
            this[value.proxy].$location = util.duplicateObj(rqstHttpLoc);
            this[value.proxy].$location.$method = this[value.proxy].method;
            this[value.proxy].$location.$url = rqstHttpLoc.$url + (value.subUrl && value.subUrl.length > 0 ? ("/" + value.subUrl) : "");
            this[value.proxy].$location.$type = value.type || rqstHttpLoc.$type || "application/json";
            this[value.proxy].$location.$contentType = value.contentType || rqstHttpLoc.$contentType || "application/json";
            this[value.proxy]._tech = {};
            this[value.proxy]._tech.pending = false;
            this[value.proxy]._tech.elapse = utilBis.getTimer();
            if(value.act) {
                this._svcActMapping[value.act[0].toString()] = {"dispatch": value.act[1], "rqstSvc": value};
            }
        }, this);      
    },

	isFixtureMode:function(){
		return this._localOpts.fixture;
	},
	
    _sendRequest: function(svc, data, queryString, onSuccess, onError, delegatePending){
        var qs = null, self = this;
        // Fixture mode
        if(this._localOpts.fixture) {
            if(this._localOpts.fixture.on && this._localOpts.fixture.reply[this._localOpts.fixture.hash + this._localOpts.fixture.next]) {
                onSuccess(this._localOpts.fixture.reply[this._localOpts.fixture.hash + this._localOpts.fixture.next++]);
            }
            return;
        }
        // Check pending state...
        if(this[svc.proxy]._tech.pending) {
            this._log.debug({"severety": "warn"}, "Request " + svc.name + " is pending...");
            alert("'controller._sendRequest()' : request '" + svc.name + "'' is pending... try again!!"); // TODO : improve
            return;
        }
        this[svc.proxy]._tech.pending = true;
        this[svc.proxy]._tech.elapse.start();
        // Buil request
        qs = this[svc.proxy].$location.$url.indexOf("?");
        (qs >=0 ? this[svc.proxy].$location.$url = this[svc.proxy].$location.$url.substr(0, qs) : void(0));
        (queryString && queryString.length > 0 ? this[svc.proxy].$location.$url += ("?" + queryString) : void(0));
        if(this[svc.proxy].data) {
            delete this[svc.proxy].data;
        }
        this[svc.proxy].data = data || null;
        // Send request
        this._hosterController.sendRequest(null, this[svc.proxy],
            function (data, response) {
                self[svc.proxy]._tech.elapseAjax = self[svc.proxy]._tech.elapse.inter();
                if(!delegatePending) {
                    self[svc.proxy]._tech.pending = false;
                    onSuccess(data, response);
                }
                else {
                    onSuccess(data, response, function () {
                        self[svc.proxy]._tech.pending = false;
                    });                    
                }
                if(self._log) {
                    self._log.timer(null, "Request duration for '" + svc.name + "' : total [" + self[svc.proxy]._tech.elapse.elapsedMs() + "], with ajax [" + self[svc.proxy]._tech.elapseAjax + "] and local [" + (self[svc.proxy]._tech.elapse.elapsedMs() - self[svc.proxy]._tech.elapseAjax) + "]");
                }
            },
            function (error) {
                self[svc.proxy]._tech.elapseAjax = self[svc.proxy]._tech.elapse.inter();
                if(!delegatePending) {
                    self[svc.proxy]._tech.pending = false;
                    onError(error);
                }
                else {
                   onError(error, function () {
                        self[svc.proxy]._tech.pending = false;
                    });
                }
                if(self._log) {
                    self._log.timer(null, "Request '" + svc.name + "' FAILED! Duration : total [" + self[svc.proxy]._tech.elapse.elapsedMs() + "], with ajax [" + self[svc.proxy]._tech.elapseAjax + "] and local [" + (self[svc.proxy]._tech.elapse.elapsedMs() - self[svc.proxy]._tech.elapseAjax) + "]");
                }
            }
        );
    },
    
    postSapRqst: function(action, params, post){
        var self = this, data = self._sapController.getRequestData("", action, params);
        if(this._closePending) {
            // TODO : bloquer!
        }
        this._sapController.removeFocus();
        if(data.fld && data.fld.ist) {
            this._sapController.updateSentData(data.fld.ist, data.fld.v);
        }
        // Send request
        this._sendRequest(_rqstSvc.sapPost, data, "act=" + action, 
            function(data, response, notifyComplete) {
                var ret = self._sapController.processReply(data, {"_techReply": {"replyComplete": notifyComplete}}), chain = null, ist;
                try {
                    if(ret && post && post.callback) {
                        ist = self._sapController.getTargetIstFromReply(data);
                        if(!self._sapController.isControlFailedInReply(null, ist) && sapUtil.cmpIst(params.target, ist)){
                            chain = post.callback.apply(self, (post.exposeReply ? (post.args ? ([data].concat(post.args)) : [data]) : post.args));
                        }
                    }
                    if(post) {
                        delete post.callback;
                        if(ret && chain) {
                            // All conditions are met to chain server action
                            setTimeout(function(){self.postSapRqst(chain.$act, chain.params, chain.post);}, 5);
                        }
                    }
                    // TODO : check error...
                }
                catch (ex) {
                    self._log.exception({"severety": "error", "ex": ex, "messObj": self._session}, "Script error catched in 'controller.postSapRqst/Onsuccess()' : " + ex.message);
                }
            },
            function(error, notifyComplete) {
                var ourAjaxErr;
                if(!(ourAjaxErr = util.isOurAjaxErrEx(error))) {
                    // Close the client without notifying the server because we don't have any information about the issue!
                    ourAjaxErr = util.makeOurAjaxErrEx("KILL", util.getDiagnosesFromAjax(error, self._session), 23, localize.getMessage(self._site.cdIsoLang, "14"));
                }
                self._ourSapRqstError(ourAjaxErr, notifyComplete);
            }, true);
    },

    _ourSapRqstError: function(ourAjaxErr, notifyComplete) {
        var diagnoses = util.makeDiagnosesFromOurAjaxErrEx(ourAjaxErr, this._session), recovery = null;
        var messErr = this._session.getlabel("error", "19", "Web server encountered following error during last request processing") + ", ";
        var messCallback = null, self = this;
        switch (ourAjaxErr.$recoveryCode) {
            case "CLOSESESS" : 
                messErr += this._session.getlabel("error", "21", "Session will be closed");
                messCallback = function () {
                    util.releaseOurAjaxErrEx(ourAjaxErr);
                    self.onSapCompleted();
                }
                break;
            case "DISCONNECT" : 
                recovery = {"typ": "RqstSrv", "act": requestActions.getSrvAction("SRV_FIN_APPLI")};
                messErr += this._session.getlabel("error", "21", "Session will be closed");
                messCallback = function () {
                    util.releaseOurAjaxErrEx(ourAjaxErr);
                }
                break;
            case "KILL" : 
                messErr += this._session.getlabel("error", "24", "Session will be killed");
                messCallback = function () {
                    util.releaseOurAjaxErrEx(ourAjaxErr);
                    self.onSapCloseEmergency();
                }
                break;
            case "ABORT" : 
                 messErr += this._session.getlabel("error", "25", "Session will be aborted");
                 messCallback = function () {
                    util.releaseOurAjaxErrEx(ourAjaxErr);
                    self._site.free("closed");
                };
                break;
            case "BUSY" : 
            default:
                break;
        }
        diagnoses.message = diagnoses.message ? messErr + " : " + diagnoses.message : messErr + " : ...";
        this._sapController._sapException(null, diagnoses, recovery, null, messCallback, notifyComplete);
    },

    _delSapSess: function(reuse, panic){
        var self = this;
        function onComplete(mode, notify) {
           setTimeout(function () {self._site.free(mode);}, 20);
            if(notify) {
                notify();
            }
        }
        if(panic) {
            this._sendRequest(_rqstSvc.sapDel, null, null, function() {return;}, function() {return;}, false);
            setTimeout(function () {onComplete("closed");}, 1500);
            return;
        }
        this._sendRequest(_rqstSvc.sapDel, null, reuse ? "reuse=true" : null, 
            function(data, response, notifyComplete) {
                onComplete(reuse ? "hidden" : "closed", notifyComplete);
            },
            function(error, notifyComplete) {
                // Force close...
                var ourAjaxErr, diagnoses;
                if(!self.delSessRetry) {
                    self.delSessRetry = true;
                    if ((ourAjaxErr = util.isOurAjaxErrEx(error))) {
                        diagnoses = util.makeDiagnosesFromOurAjaxErrEx(ourAjaxErr, self._session);
                    }
                    else {
                        diagnoses = util.getDiagnosesFromAjax(error, self._session);
                    }
                    self._sapController._sapException(null, diagnoses, null, error, function() {
                        self._delSapSess(false);    
                        return true;
                    }, notifyComplete);
                }
                else {
                    onComplete("closed", notifyComplete);
               }
            }, true);
    },
    
    _basicSvcRqst: function(rqstSvc, params, post){
        // Generic REST service : params.svc contains service ID
        var self = this;
        function onComplete(reply, succeded, notify) {
            if(post) {
                post.callback.apply(self, post.args ? [succeded, reply].concat(post.args) : [succeded, reply]);
            }
            if(notify) {
                notify();
            }
        }
        this._sendRequest(rqstSvc, params, params.svc ? "svc=" + params.svc : "",
            function(data, response, notifyComplete) {
                onComplete(data, true, notifyComplete);
            },
            function(error, notifyComplete) {
                onComplete(error, false, notifyComplete);
            }, false);
    },

    _printRqst: function(rqstSvc, params, post){
         this._sendRequest(rqstSvc, params, null, 
            function(data, response, notifyComplete) {
                if(notifyComplete) {
                    notifyComplete();
                }
            },
            function(error, notifyComplete) {
                if(notifyComplete) {
                    notifyComplete();
                }
           }, true);
    },

    initialize: function(site, srvOpts, localOpts){
        // Misc init
        this._log = document[sapUtil._fNS].log;
        this._closePending = false;
        this._site = site;
        this._session = null;
        this.httpQuery = null;
        this._localOpts = localOpts || {};
        this._svcActMapping = {};
        this._hosterController = this._site.getHosterController();
        (this._sapController = new SapController()).initialize(this, srvOpts);
        // Init internal event handling
        EventManager.prototype.initialize.call(this, _evtHandlingModules, ["sap", "ui"], {"controller": this, "sapController": this._sapController, "siteUUID": this._site.uuid});
        this.evtManagerComplete();
        // Bind controller listeners
        this._bindListeners();
    },

    _bindListeners: function(){
        this.bind("sap.win.unstacked", (this._site.getHosterInstance()).closeSheet, false, true, this._site.getHosterInstance());
    },

    _unbindListeners: function(){
        this.unbind("sap.win.unstacked", this._site.getHosterInstance());
    },

    onStart: function(httpQuery, rqstLocation, session, statements, notifyCallBack){
        var err;
        this._session = session;
        this._log = session.logger || this._log;
        if (rqstLocation) {
            this._initRqstSvcs(rqstLocation);
        }
       	if(!statements) {
            err = [util.makeDiagnosis(localize.getMessage(this._site.cdIsoLang, "3"), 4, "client.Controller.onStart()", "03", util.cltFusionNice)];
            try {
                this._sapController._sapException(null, err, {"typ": "RqstSrv", "act": requestActions.getSrvAction("SRV_FIN_APPLI")});
            }
            catch (ex) {
                notifyCallBack(err);
            }
    	}
    	else if(this._sapController.isSapReply(statements)){
            this.httpQuery = httpQuery;
            this.protoQueryOpts = {"headers": {"accept-language": this._session.cdIsoLang}, "noDisplayErr": this.httpQuery.noDisplayErr ? true : undefined};
    		this._sapController.onInitialReply(statements, notifyCallBack);
    	}
    	else {
    		// Who is talking to me ?
            notifyCallBack([util.makeDiagnosis(localize.getMessage(this._site.cdIsoLang, "4") + "\n" + localize.getMessage(this._site.cdIsoLang, "2"), 4, "client.Controller.onStart()", "04", util.cltFusionNice)]);
    	}
    },

    onSapUIHidden: function(){
        // Sap client is now attached to the "portal" Window (i.e level 0)
        this._delSapSess(true);
    },

    onSapCloseEmergency: function(){
        // Panic close
        this._delSapSess(false, true);
    },

    onSapCompleted: function(){
        // Sap client has been closed by the back-office.
        this._delSapSess(false);
    },

    loadRepresentation: function(representation, article, success, error, customProto){
        var self = this, hosterSite = this._site.getHosterSite(), hosterInstance = this._site.getHosterInstance(), _elapse = utilBis.getTimer(true), _srvDuration;
        this.httpQuery.$urlParts.params.representation = representation.name + ".$fusion";
        this._hosterController.loadRepresentation(article, this.httpQuery, function($itemPage){
            _srvDuration = _elapse.inter();
            var $facet = representation.$facet || $itemPage.$representation.$prototype.$x3facet || syraUtil.pageFacet.edit;
            $itemPage.$autoFetch = false;
            $itemPage.onPageLoaded = success;
            $itemPage.$category = "fusion";
            $itemPage.$fusionPageMeta = {"controller": self, "winId": representation.id};
            $itemPage.$urlParts.$facet = "$fusion_" + $facet;
			$itemPage.externalAdapter = hosterInstance;
			success(hosterInstance.loadSheet($itemPage, $facet));
            self._log.timer(null, "Load page duration : total [" + _elapse.elapsedMs() + "], with ajax [" + _srvDuration + "] and local [" + (_elapse.elapsedMs() - _srvDuration) + "]");
        }, error, customProto, this.protoQueryOpts);
    },

    getSession: function(){
        return this._session;
    },

    getLogger: function(){
        return this._log;
    },

    isSapActiveWindow: function(winId){
        return this._sapController.isActiveWindow(winId);
    },

    triggerAdx: function(event, object){
        try {
            // Note : trigger return 'false' if at least one handler has explicitly processed the event.
            var succeded = true, intercepted = false, evtDomain = this.getEvtName(event), actId;
            evtDomain = evtDomain.substring(0, evtDomain.indexOf(".")); 
            // Standard control : only for "local" and "widget" event domain.
            if(evtDomain == "lcl" || evtDomain == "wdgt") {
                // TODO
                succeded = true;      
            }
            // Call handler
            if(succeded) {
    			// notify widget that an event occured - Widget can interrupt event process
    			if (object && object.target && object.target.beforeTrigger && !object.target.beforeTrigger(event, object)){
				    // Stop process - it's the widget's responsability to invoke doEvent if needed  
					return false;
    			}
                intercepted = !intercepted && EventManager.prototype.trigger.apply(this, arguments);
                // Process result
                if(intercepted !== undefined)
                {
                    if(object.result && object.result.diagnoses)
                    {
                        // Display diagnoses
                    }
                    else if (object.result && object.result.$act) {
                        if (object.result.$act > requestActions.srvActionStart) {
                            this.postSapRqst(object.result.$act, object.result.params, object.result.post);
                        }
                        else if (this._svcActMapping[(actId = object.result.$act.toString())]) {                            
	           				var mapping = this._svcActMapping[actId];
                            this[mapping.dispatch](mapping.rqstSvc, object.result.params, object.result.post, object.opts);							
                        }
                    }
                }
            }       
    		// True -> Execute doEvent - False byPass object.data.doEvent 
            return (!succeded || (intercepted !== undefined && intercepted)) ? false : true;
        }
        catch (ex) {
            this._log.exception({"severety": "error", "ex": ex, "messObj": this._session}, "Script error catched in 'controller.triggerAdx()' : " + ex.message);
            return false;
        }
    },

    dispose: function(){
        if (this._svcActMapping){
             _.each(this._svcActMapping, function (value, key){
                delete value.rqstSvc;
             }, this);
        }
        if (this.httpQuery){
             delete this.httpQuery;
        }
        if (this._sapController){
            this._sapController.dispose();
            delete this._sapController;
        }
        if (this._session){
             delete this._session;
        }
        _.each(_rqstSvc, function(value, key){
            if (this[value.proxy] && this[value.proxy].data) {
                delete this[value.proxy].data;
            }
        }, this);
        this._unbindListeners();      
        EventManager.prototype.dispose.call(this);
        if (this._site){
             delete this._site;
        }
        if (this._log){
             delete this._log;
        }
    }
});