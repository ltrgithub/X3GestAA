"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Event manager class
 */

var helpers = require('syracuse-core').helpers;

function EventManager() {}

exports.EventManagerMembers = {
	evtManagerInit: function(evtHandlingModules, evtHandlingTypes, extHandlingClass) {
		// Init instance properties
		this._evtsListeners = {};
		this._evtHandlerInstancesMap = {};
		this._globalListeners = [];
		this._listenerCategories = ["preemptive", "normal"];
		// Init events handling classes
		_.each(evtHandlingModules, function(module, moduleName) {
			_.each(evtHandlingTypes, function(type) {
				if (module[type]) {
					this.registerEvtHandlingClass(module[type], moduleName, type, extHandlingClass);
				}
			}, this);
		}, this);
	},

	// When the child class finshed to initialized the event manager...
	evtManagerComplete: function() {
		this._evtMngrComplete = true;
		this.trigger(new this._ready(this));
	},

	_evtManagerInternalEvtCat: "evtmgr",

	isInternalEvtManagerCat: function(event) {
		var evtName = this.getEvtName(event),
			evtArray = evtName.split(".");
		return evtArray[1] == this._evtManagerInternalEvtCat;
	},

	_ready: function(self) {
		this._name = "sys." + self._evtManagerInternalEvtCat + ".ready";
		this.data = {};
	},

	// Add/Remove global listener
	addGlobalListeners: function(handler, ref, name) {
		this._globalListeners.push({
			"name": name,
			"handler": handler,
			"object": ref
		});
	},

	rmGlobalListeners: function(ref, name, handler) {
		// We handle just five combinations...
		var listener, del, allObj = ref && !name && !handler,
			allName = name && !ref && !handler,
			allHandler = !name && !ref && handler;
		for (var i = this._globalListeners.length - 1; i >= 0; i--) {
			listener = this._globalListeners[i];
			del = false;
			if (allObj && ref == listener.object || allName && name == listener.name || allHandler && handler == listener.handler) {
				del = true;
			} else if ((ref && ref == listener.object || !ref) && name && name == listener.name) {
				del = true;
			}
			if (del) {
				this._delGlobalListener(listener);
				this._globalListeners.splice(i, 1);
			}
		}
	},

	_delGlobalListener: function(listener) {
		delete listener.handler;
		delete listener.object;
	},

	// Get all listeners for an event
	_getListeners: function(event) {
		var evtName = this.getEvtName(event);
		if (!this._evtsListeners[evtName]) {
			this._evtsListeners[evtName] = {};
			_.each(this._listenerCategories, function(category) {
				this[category] = [];
			}, this._evtsListeners[evtName]);
		}
		return this._evtsListeners[evtName];
	},

	_getObject: function(type, name) {
		return this._evtHandlerInstancesMap[type + "_" + name];
	},

	// Check if an event is handled by a specific handler
	hasListenerWithHandler: function(event, handler) {
		var hasListener = false,
			evtListeners = this._getListeners(event);
		_.each(this._listenerCategories, function(category) {
			if (!hasListener) {
				for (var i = 0, ii = this[category].length; i < ii; i++) {
					if (this[category][i].handler == handler) {
						hasListener = true;
						break;
					}
				}
			}
		}, evtListeners);
		return hasListener;
	},


	isEventBound: function(event) {
		var evtName = this.getEvtName(event);
		return this._evtsListeners[evtName];
	},

	// Retrieve event name (because "event" should be an instance)
	getEvtName: function(event) {
		return typeof event == "string" ? event : event._name;
	},

	// Factory for registering new event handling (i.e listening) instance
	registerEvtHandlingClass: function(classRef, name, type, extend) {
		// Create a new instance
		var instance = new classRef(),
			stdMethods = ["trigger", "bind", "unbind"],
			predefinedListeners = null,
			t0, t1, t2;
		// Add standard event usage methods
		instance.extended = [];
		_.each(stdMethods, function(method) {
			instance[method] = this[method];
			instance[method] = _.bind(instance[method], this);
			instance.extended.push(method);
		}, this);
		// Add extended properties
		_.each(extend, function(property, name) {
			instance[name] = property;
			instance.extended.push(name);
		});
		// Register this instance
		instance._type = type || instance._type;
		instance._name = instance._type + "_" + name;
		this._evtHandlerInstancesMap[instance._name] = instance;
		// Set the predefined listeners
		if (typeof instance.eventListeners == "function") {
			predefinedListeners = instance.eventListeners();
			if (predefinedListeners) {
				for (var i = 0, ii = predefinedListeners.length; i < ii; i++) {
					t0 = predefinedListeners[i].length;
					t1 = t0 > 2 ? predefinedListeners[i][2] : false;
					t2 = t0 > 3 ? predefinedListeners[i][3] : false;
					this.bind(predefinedListeners[i][0], predefinedListeners[i][1], t1, t2, instance);
				}
			}
		}
	},

	// Unregister an event handling instance
	_unregisterEvtHandlingInstance: function(instance, name, doUnbind) {
		_.each(instance.extended, function(name) {
			delete instance[name];
		});
		if (doUnbind && typeof instance.eventListeners == "function") {
			_.each(instance.eventListeners(), function(evtDesc) {
				this.unbind(evtDesc[0], instance);
			}, this);
		}
		delete this._evtHandlerInstancesMap[name];
	},

	// Add listener
	bind: function(event, handler, trappable, preemptive, listeningObject) {
		var evtListeners = this._getListeners(event);
		if (!listeningObject) {
			// Get the instance that asks to listen, if non provided, we get the from the caller....
			listeningObject = arguments.callee.caller;
		}
		evtListeners[preemptive ? this._listenerCategories[0] : this._listenerCategories[1]].push({
			"handler": handler,
			"trappable": trappable,
			"listeningObject": listeningObject
		});
	},

	// Remove all listeners for an event or for an event/listening object
	unbind: function(event, listeningObject) {
		var evtName = this.getEvtName(event),
			i;
		if (this._evtsListeners[evtName]) {
			_.each(this._listenerCategories, function(category) {
				i = this[category].length - 1;
				if (i >= 0) {
					for (i; i >= 0; i--) {
						if (!listeningObject || listeningObject == this[category][i].listeningObject) {
							delete this[category][i].handler;
							delete this[category][i].listeningObject;
							if (listeningObject) {
								this[category].splice(i, 1);
							}
						}
					}
				}
			}, this._evtsListeners[evtName]);
			if (!listeningObject) {
				delete this._evtsListeners[evtName];
			}
		}
	},

	// Fire an event
	trigger: function(event, object) {
		var intercepted = false,
			ret = undefined,
			evtName = this.getEvtName(event),
			args = arguments,
			evtIsString = false;
		if (typeof event == 'string') {
			object = object || {};
			object._name = evtName;
			object.timeStamp = (new Date()).getTime();
			//event = object;
			evtIsString = true;
		}
		if (this._evtsListeners[evtName]) {
			_.each(this._listenerCategories, function(category) {
				if (!intercepted) {
					for (var i = 0, ii = this[category].length; i < ii; i++) {
						//ret = this[category][i].handler.call(this[category][i].listeningObject, event);
						ret = this[category][i].handler.apply(this[category][i].listeningObject, evtIsString ? Array.prototype.slice.call(args, 1) : args);
						if (this[category][i].trappable && ret != undefined) {
							intercepted = true;
							break;
						}
					}
				}
			}, this._evtsListeners[evtName]);
		}
		_.each(this._globalListeners, function(listener) {
			//listener.handler.call(this, event);
			listener.handler.apply(this, evtIsString ? Array.prototype.slice.call(args, 1) : args);
		}, this);
		return intercepted ? ret : undefined;
	},

	evtManagerDispose: function() {
		_.each(this._globalListeners, function(listener) {
			this._delGlobalListener(listener);
		}, this);
		_.each(this._evtsListeners, function(evtListeners, evtName) {
			this.unbind(evtName);
		}, this);
		_.each(this._evtHandlerInstancesMap, function(instance, name) {
			this._unregisterEvtHandlingInstance(instance, name, false);
		}, this);
		this._evtMngrComplete = false;
	}
};

exports.EventManager = helpers.defineClass(EventManager, null, exports.EventManagerMembers);