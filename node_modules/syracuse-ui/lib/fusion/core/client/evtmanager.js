"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview Event manager class
 */

 
var helpers = require('syracuse-core/lib/helpers');

   
function EventManager()
{
}

exports.EventManager = helpers.defineClass(EventManager, null, {
	initialize : function (evtHandlingModules, evtHandlingTypes, extHandlingClass){
		// Init instance properties
		this._evtsListeners = {};
		this._evtHandlerInstancesMap = {};
		this._globalListeners = [];
		this._listenerCategories = ["preemptive", "normal"];
		// Init events handling classes
        _.each(evtHandlingModules, function(module, moduleName){
            _.each(evtHandlingTypes, function(type){
                if(module[type]) {
                    this.registerEvtHandlingClass(module[type], moduleName, type, extHandlingClass);
                }
            }, this);
        }, this);
	},

    // When the child class finshed to initialized the event manager...
	evtManagerComplete : function (){
		this.trigger(new this._ready());
 	},

   	_ready: function() {
        this._name = "sys.evtmgr.ready";
		this.data = {};
    },
	
	// Add/Remove global listener
    addGlobalListeners: function(handler, ref, name) {
        this._globalListeners.push({"name": name, "handler": handler, "object": ref});
    },

    rmGlobalListeners: function(ref, name, handler) {
    	// We handle just five combinations...
		var listener, del, allObj = ref && !name && !handler, allName = name && !ref && !handler, allHandler = !name && !ref && handler;
  		for(var i = this._globalListeners.length - 1; i >= 0; i--) {
  			listener = this._globalListeners[i];
  			del = false;
   			if(allObj &&  ref == listener.object || allName && name == listener.name || allHandler &&  handler == listener.handler) {
  				del = true;
			}
			else if((ref && ref == listener.object || !ref) && name && name == listener.name) {
				del = true;
			}
			if(del) {
				this._delGlobalListener(listener);
				this._globalListeners.splice(i, 1);
			}
		}
    },
 	
    _delGlobalListener: function(listener) {
		delete listener.handler;
		delete listener.object;
    },

     // Get all listeners for an event
    _getListeners: function(event){
        var evtName = this.getEvtName(event);
        if (!this._evtsListeners[evtName]) {
			this._evtsListeners[evtName] = {};
			_.each(this._listenerCategories, function (category) {this[category] = [];}, this._evtsListeners[evtName]);
        }       
        return this._evtsListeners[evtName];
    },

   	_getObject: function(type, name){
        return this._evtHandlerInstancesMap[type + "_" + name];
    },
 
    // Check if an event is handled by a specific handler
    hasListenerWithHandler: function(event, handler) {
        var hasListener = false, evtListeners = this._getListeners(event);
		_.each(this._listenerCategories, function(category) {
			if(!hasListener) {
				for (var i = 0, ii = this[category].length; i < ii; i++){
					if (this[category][i].handler == handler){
						hasListener = true;
						break;
					}
				}
			}
		}, evtListeners);
        return hasListener;
    },
	   
	// Retrieve event name (because "event" should be an instance)
	getEvtName: function(event){
		return typeof event == "string" ? event : event._name;
	},
	
    // Factory for registering new event handling (i.e listening) instance
    registerEvtHandlingClass: function(classRef, name, type, extend) {
		// Create a new instance
        var instance = new classRef(), stdMethods = ["trigger", "bind", "unbind"], predefinedListeners = null, t0, t1, t2;
		// Add standard event usage methods
		instance.extended = [];
		_.each(stdMethods, function(method) {
			instance[method] = this[method];
			instance[method] = _.bind(instance[method], this);
			instance.extended.push(method);
		}, this);
		// Add extended properties
		_.each(extend, function(property, name) {
			instance[name] = property;
			instance.extended.push(name);
		});
		// Register this instance
		instance._type = type || instance._type;
		instance._name = instance._type + "_" + name;               
		this._evtHandlerInstancesMap[instance._name] = instance;    
		// Set the predefined listeners
		if (typeof instance.eventListeners == "function"){  
			predefinedListeners = instance.eventListeners();
			if (predefinedListeners){
				for (var i = 0, ii = predefinedListeners.length; i < ii; i++){
					t0 = predefinedListeners[i].length;
					t1 = t0 > 2 ? predefinedListeners[i][2] : false;
					t2 = t0 > 3 ? predefinedListeners[i][3] : false;
					this.bind(predefinedListeners[i][0], predefinedListeners[i][1], t1,  t2, instance);
				}
			}
		}
    },
	
    // Unregister an event handling instance
    _unregisterEvtHandlingInstance: function(instance, name, doUnbind) {
		_.each(instance.extended, function(name) {
			delete instance[name];
		});
		if(doUnbind && typeof instance.eventListeners == "function") {
			_.each(instance.eventListeners(), function(evtDesc) {
				this.unbind(evtDesc[0], instance);
			}, this);
		}
		delete this._evtHandlerInstancesMap[name];
	},
	
    // Add listener
    bind: function(event, handler, trappable, preemptive, listeningObject) {       
        var evtListeners = this._getListeners(event);
        if (!listeningObject) {
			// Get the instance that asks to listen, if non provided, we get the from the caller....
			listeningObject = arguments.callee.caller;
        }        
        evtListeners[preemptive ? this._listenerCategories[0] : this._listenerCategories[1]].push({"handler": handler, "trappable": trappable, "listeningObject": listeningObject});
    },
    
	// Remove all listeners for an event or for an event/listening object
    unbind: function(event, listeningObject){    
        var evtName = this.getEvtName(event), i;
        if (this._evtsListeners[evtName]) {
			_.each(this._listenerCategories, function(category) {
				i = this[category].length - 1;
				if (i >= 0) {
					for (i; i >= 0; i--){
						if (!listeningObject || listeningObject == this[category][i].listeningObject){
							delete this[category][i].handler;
							delete this[category][i].listeningObject;
							if(listeningObject) {
								this[category].splice(i, 1);
							}
						}
					}
				}
			}, this._evtsListeners[evtName]);
			if(!listeningObject) {
				delete this._evtsListeners[evtName];
			}
        }
    },   

	// Fire an event
	trigger: function(event, object) {
        var intercepted = false, ret = undefined, evtName = this.getEvtName(event), args = arguments, evtIsString = false;
		if (typeof event == 'string'){
			object = object || {};
			object._name = evtName;
			object.timeStamp = (new Date()).getTime();
            //event = object;
			evtIsString = true;
	    }
        if (this._evtsListeners[evtName]) {
			_.each(this._listenerCategories, function(category) {
				if(!intercepted) {
					for(var i = 0, ii = this[category].length; i < ii; i++) {
						//ret = this[category][i].handler.call(this[category][i].listeningObject, event);
						ret = this[category][i].handler.apply(this[category][i].listeningObject, evtIsString ? Array.prototype.slice.call(args, 1) : args);
						if(this[category][i].trappable && ret != undefined) {
							intercepted = true;
							break;
						}
					}
				}
			}, this._evtsListeners[evtName]);
        }
		_.each(this._globalListeners, function(listener) {
			//listener.handler.call(this, event);
			listener.handler.apply(this, evtIsString ? Array.prototype.slice.call(args, 1) : args);
		}, this);
		return intercepted ? ret : undefined;
    },
	
    dispose: function() {
		_.each(this._globalListeners, function(listener) {this._delGlobalListener(listener);}, this);
		_.each(this._evtsListeners, function(evtListeners, evtName) {
			this.unbind(evtName);
		}, this);
		_.each(this._evtHandlerInstancesMap, function(instance, name) {
			this._unregisterEvtHandlingInstance(instance, name, false);
		}, this);
    }
});