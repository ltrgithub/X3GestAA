"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview X3-Fusion Format and control utilitie
 */


var helpers = require('syracuse-core/lib/helpers');

/* Formatter constants */
var fmtFrame = {"F_SEPARATOR": ":", "F_ATTRIBBEGIN": "{", "F_ATTRIBEND": "}", "F_MASKBEGIN": "[", "F_MASKEND": "]"};
var pTypes = {"F_STRG":"K", "F_NUM": "N", "F_DATE": "D", "F_LBL": "L", "F_PGBR": "p", "F_MNL": "LA"};
var pTypesC = {"S_STRG": 1, "S_NUM": 2, "S_DATE": 3, "S_MNL": 4};
var displayOpts = {"F_NOSPACEPREFIX": "v", "F_NOSPACEBEGIN": "0", "F_NOSPACEEND": "1", "F_NOSPACEBEGINEND": "2", "F_NOSPACE1WORD": "3", "F_NOSPACE": "4",
	"F_NOSPACEDOUBLE": "5", "F_SPACEEND": "b", "F_NOSTARS_CASSE": "A", "F_L4G": "T", "F_RESTRICTL4G": "t", "F_DATENULL": "Z", "F_NOTOKADX": "TD", "F_NOTOKEN": "¤"
};
var generalOpts = {"F_DISABLED": "P", "F_PASSWORD": "X", "F_ALL": "C", "F_BEEP": "G", "F_EMPTY": "z"};
var gridOpts = {"F_COLOR": "c", "F_NOVISIBLE": "-", "F_RIGHT": ">", "F_LEFT": "<", "F_CENTER": "="};

var dataSubTypes = {"F_EDITORHLP": "H", "F_EDITORRTF": "R", "F_EDITORL4G": "@", "F_EXECUTABLE": "U", "F_DLG_STYLE_EDT": "V", "F_LABEL": "W", 
	"F_IMAGE": "I", "F_RICHEDITOR": "1", "F_TXTEDITOR": "2", "F_RTFNOOBJEDITOR": "3"
};
/* Misc constants */
var fmtK = {"MAX_CTRLSPEC": 26, "MAX_STDTYPE": 60, "MAX_CHARSUP": 32, "MAX_ENT": 24, "MAX_DECI": 24, "DATE_PIVOT": 63};


/* Web serveur Format services helper */
exports.svcFormatter = {
	"fmtSvc" : {"toRaw": "toRaw", "toEdit": "toEdit", "toDisplay": "toDisp", "rawToEdit": "rawToEdit", "rawToDisp": "rawToDisp"},
	"buildRqst": function (svc, value, fmt, type, ist, opts) {
		return {"svc": svc, "typ": type, "fmt": fmt, "target": ist, "value": value};
	},
	"formReply": function (value, fmt, ist) {
		return {"result": value, "fmt": fmt, "target": ist};
	},
	"getReplyResult": function (fmtReply) {
		return fmtReply.result;
	}
}


/* Classes */
function FormatterEnv(){
}
exports.FormatterEnv = helpers.defineClass(FormatterEnv, null, {
	initialize: function() {
		for (var i = 0; i < fmtK.MAX_CTRLSPEC; i++){
			this.sCtrlSpec[i] = {"szStandardsTypes": null, "szMoreChar": null};
		}
		this.nDatePivot = fmtK.DATE_PIVOT;
		this.bDatePivotBySrv = false;
		// TODO : continuer avec masques date par défaut, séparateurs divers et variés...
	},
	defineType: function(cType, pszStds, pszChars) {
		// On range ce type à l'emplacement cType - (int)'a'
		var cTypeDec = cType.charCodeAt(0), uType = cTypeDec - 97;
		// Si on tente de définir un type différent d'une minuscule (< a ou > z)
		if (cTypeDec < 97 || cTypeDec > 122) {
			// TODO : throw error...
			return false;
		}
		// On initialise l'emplacement si l'on désire le renseigner
		if (pszStds.length > 0){
			this.sCtrlSpec[uType].szStandardsTypes = pszStds;
		}
		if (pszChars.length > 0){
			this.sCtrlSpec[uType].szMoreChar = pszChars;
		}
		return true;
	},
	isDefineTypeExist: function(cType) {
		// On l'a rangé à l'emplacement cType - (int)'a'
		var cTypeDec = cType.charCodeAt(0), uType = cTypeDec - 97, bFound = false;
		// Si on tente de définir un type différent d'une minuscule (< a ou > z)
		if (cTypeDec >= 97 && cTypeDec <= 122) {
			// Si une des deux chaine n'est pas vide, il existe.
			bFound = (this.sCtrlSpec[uType].szStandardsTypes || this.sCtrlSpec[uType].szMoreChar);
		}
		return bFound;
	},
	setDatePivotBySrv: function(nDatePivot) {
		// Si la date pivot n'est pas dans la tranche [1901-2000], on laisse la valeur par défaut!
		if (nDatePivot > 1900 && nDatePivot <= 2000)
		{
			this.nDatePivot = nDatePivot - 1900;
			// See L4G doc "adxdcs" for the next line
			this.nDatePivot -= 1;
			this.bDatePivotBySrv = true;
		}
	}
});

function Formatter(){
}
exports.Formatter = helpers.defineClass(Formatter, null, {
	initialize: function () {
		this._razFmt();
		this.pTypesC = pTypesC;
	},
	_razFmt: function () {
		this.szFormat = null;
		this.bIsNull = false ;
		this.nType = 0 ;
		this.nStringLen = 0 ;	
		this.nStringTotalLen = 0 ;	
		this.nEnt = 0 ;	
		this.nDeci = 0 ;	
		this.cAlign = 0 ;	
		this.bIsVisible = true ;	
		this.bWithColor = false;	
		this.bSuccess = true;
		this.bNoInputCtrl = false;
		this.sNumValue = {};
		this.sStringValue = {};
		this.sDatreValue = {};
		this.szRealString = "";
		this.szOriginalString = "";
	},
	_initFmt: function () {
		this.nType = 0;
		this.nStringLen = 0;	
		this.nStringTotalLen = 0;
		this.nEnt = 0;	
		this.nDeci = 0;
		this.cAlign = 0;	
		this.bWithColor = FALSE;	
		this.szDispTime = "";
		this.szDispDate = "";
		this.szGlobalCtrl = "";	
		this.szAfficCtrl = "";
		this.nDispString = [];	
	},
	getFmtDataType: function (format) {
		var cutFmt;
		format = format || this.szFormat;
		if (format && format.length > 0 && (cutFmt = this._cutFmt (format))){
			if (cutFmt.left.indexOf(pTypes.F_STRG) >= 0) {
				return pTypesC.S_STRG;
			}
			else if (cutFmt.left.left.indexOf(pTypes.F_NUM) >= 0) {
				return pTypesC.S_NUM;
			}
			else if (cutFmt.left.left.indexOf(pTypes.F_DATE) >= 0) {
				return pTypesC.S_DATE;
			}
			else if (cutFmt.left.left.indexOf(pTypes.F_MNL) >= 0) {
				return pTypesC.S_MNL;
			}
		}
		return pTypesC.S_STRG;	
	},
	setTypeAndAttrib: function(format) {
		var i = 0, flagNum = false, len = format.length;
		while (i < len)
		{
			switch (format[i])
			{
				case pTypes.F_STRG:
					this.nType = pTypesC.S_STRG;
					break;
				case pTypes.F_NUM:
					this.nType = pTypesC.S_NUM;
					flagNum = true;
					break;
				case pTypes.F_DATE:
					if(!flagNum) {
						// Attention, on peut avoir un numérique (N) avec une option = 'D' .. donc Cuidado
						this.nType = pTypesC.S_DATE;
					}
					break;
				case displayOpts.F_L4G:
					//  On regarde s'il existe le 'D' juste après
					if (format[i+1] === displayOpts.F_NOTOKADX[1])
					{
						// Dans ce cas, c'est TD qu'il faut analyser, on garde donc l'info dans le format global
						this.szGlobalCtrl[i] = displayOpts.F_NOTOKEN;
						this.szGlobalCtrl[i+1] = displayOpts.F_NOTOKEN;
						// ... et on se décale de 1 pour éviter le 'D'
						i++;
					}
					break;			
				case fmtFrame.F_ATTRIBBEGIN:
					i += this._updateStructStyle(format);
					break;
				case gridOpts.F_RIGHT:
				case gridOpts.F_CENTER:
				case gridOpts.F_LEFT:
					this.cAlign = format[i];
					break;
				case gridOpts.F_COLOR:
					this.bWithColor =true;
					break;
			}
			i++;
		}
		return true;
	},
	_isEditor: function() {
		return this.szGlobalCtrl.indexOf(dataSubTypes.F_EDITORRTF) >= 0 || this.szGlobalCtrl.indexOf(dataSubTypes.F_EDITORHLP) >= 0 || this.szGlobalCtrl.indexOf(dataSubTypes.F_EXECUTABLE) >= 0 ? true : false;
	},
	_expandFmt: function(format) {
	},
	_cutFmt: function(format) {
		var i, j = 0, ret = {"isVisible": true}, split;
		split = format.split(fmtFrame.F_SEPARATOR);
		if (split.length == 0 || split.length < 2) {
			// TODO : throw error
			return null;			
		}
		// Contrôle tout de même si le separateur ne serait pas dans un bloc de commentaire
		i = format.indexOf(fmtFrame.F_SEPARATOR) + 1; 
		// Position du debut de masque
		if (format.indexOf(fmtFrame.F_MASKBEGIN) >= 0) {
			j = format.indexOf(fmtFrame.F_MASKBEGIN) + 1;
		}
		// Si on a trouvé le separateur dans un bloc, c'est pas bon; les Mask sont situés après le séparateur
		if (j > 0 && j < i) {
			// TODO : throw error
			return null;			
		}
		// On regarde si le témoin de champ invisible est présent
		if(split[0][0] == gridOpts.F_NOVISIBLE) {
			ret.isVisible = false;
		}
		// Maintenant on supprime tous les caractères avant la notion du champ (donc témoin de champ invisible inclu)
		i = 0;
		j = split[0].length;
		while (i < j && split[0][i] != pTypes.F_STRG && split[0][i] != pTypes.F_NUM && split[0][i] != pTypes.F_DATE &&
				split[0][i] != pTypes.F_LBL && split[0][i] != pTypes.F_PGBR) {
					i++;
		}	
		ret.left = split[0].substr(i);
		ret.right = split[1];
		return ret;
	},
	_updateStructStyle: function(format) {
		// Juste là pour calculer la taille des attributs... le style est n'est plus géré dans cette classe
		var j = 0, start, stop;
		if ((start = _format.indexOf(fmtFrame.F_ATTRIBBEGIN)) >= 0 && (stop = _format.indexOf(fmtFrame.F_ATTRIBEND, start)) >= 0) {
			j = stop - start;	
		}			
		return j;
	}
});