"use strict";

/*
 Copyright (c)2012 Sage.
 http://wwww.sage.com
 */
/**
 * @fileoverview X3-Fusion Format and control utilitie
 */

var helpers = require('syracuse-core/lib/helpers');

/* Formatter constants */
var _dateOrderK = {
	"DMY": 1,
	"YMD": 2,
	"MDY": 0
};
exports.dateOrderK = _dateOrderK;
var fmtFrame = {
	"F_SEPARATOR": ":",
	"F_ATTRIBBEGIN": "{",
	"F_ATTRIBEND": "}",
	"F_MASKBEGIN": "[",
	"F_MASKEND": "]"
};
var pTypes = {
	"F_STRG": "K",
	"F_NUM": "N",
	"F_DATE": "D",
	"F_LBL": "L",
	"F_PGBR": "p",
	"F_MNL": "LA"
};
var pSubTypesC = {}, pTypesC = {
		"S_STRG": 1,
		"S_NUM": 2,
		"S_DATE": 3,
		"S_MNL": 4
	};
pSubTypesC[pTypesC.S_NUM] = {
	"X_INT": 0,
	"X_DCB": 1,
	"X_FLOAT": 2
};
var displayOpts = {
	"F_NOSPACEPREFIX": "v",
	"F_NOSPACEBEGIN": "0",
	"F_NOSPACEEND": "1",
	"F_NOSPACEBEGINEND": "2",
	"F_NOSPACE1WORD": "3",
	"F_NOSPACE": "4",
	"F_NOSPACEDOUBLE": "5",
	"F_SPACEEND": "b",
	"F_NOSTARS_CASSE": "A",
	"F_L4G": "T",
	"F_RESTRICTL4G": "t",
	"F_DATENULL": "Z",
	"F_NOTOKADX": "TD",
	"F_NOTOKEN": "�"
};
var generalOpts = {
	"F_DISABLED": "P",
	"F_PASSWORD": "X",
	"F_ALL": "C",
	"F_BEEP": "G",
	"F_EMPTY": "z"
};
var gridOpts = {
	"F_COLOR": "c",
	"F_NOVISIBLE": "-",
	"F_RIGHT": ">",
	"F_LEFT": "<",
	"F_CENTER": "="
};

var dataSubTypes = {
	"F_EDITORHLP": "H",
	"F_EDITORRTF": "R",
	"F_EDITORL4G": "@",
	"F_EXECUTABLE": "U",
	"F_DLG_STYLE_EDT": "V",
	"F_LABEL": "W",
	"F_IMAGE": "I",
	"F_RICHEDITOR": "1",
	"F_TXTEDITOR": "2",
	"F_RTFNOOBJEDITOR": "3"
};
/* Misc constants */
var fmtK = {
	"MAX_CTRLSPEC": 26,
	"MAX_STDTYPE": 60,
	"MAX_CHARSUP": 32,
	"MAX_ENT": 24,
	"MAX_DECI": 24
};

/* Classes */
function LegacyCSFormatterEnv() {}
exports.LegacyCSFormatterEnv = helpers.defineClass(LegacyCSFormatterEnv, null, {
	initialize: function() {
		this.sCtrlSpec = [];
		for (var i = 0; i <= fmtK.MAX_CTRLSPEC; i++) {
			this.sCtrlSpec[i] = {
				"szStandardsTypes": null,
				"szMoreChar": null
			};
		}
		this.preferences = {
			"nDatePivot": 63,
			"cSepDate": "/",
			"cSepGroupNum": " ",
			"cSepDecimal": ".",
			"cSepTime": ":",
			"dateOrder": _dateOrderK.MDY
		};
		this.bDatePivotBySrv = false;
		// TODO : continuer avec masques date par d�faut, s�parateurs divers et vari�s...
	},
	defineTypes: function(cType, pszStds, pszChars) {
		// On range ce type � l'emplacement cType - (int)'a'
		var cTypeDec = cType.charCodeAt(0),
			uType = cTypeDec - 97;
		// Si on tente de d�finir un type diff�rent d'une minuscule (< a ou > z)
		if (cTypeDec < 97 || cTypeDec > 122) {
			// TODO : throw error...
			return false;
		}
		// On initialise l'emplacement si l'on d�sire le renseigner
		if (pszStds.length > 0) {
			this.sCtrlSpec[uType].szStandardsTypes = pszStds;
		}
		if (pszChars.length > 0) {
			this.sCtrlSpec[uType].szMoreChar = pszChars;
		}
		return true;
	},
	isDefineTypeExist: function(cType) {
		// On l'a rang� � l'emplacement cType - (int)'a'
		var cTypeDec = cType.charCodeAt(0),
			uType = cTypeDec - 97,
			bFound = false;
		// Si on tente de d�finir un type diff�rent d'une minuscule (< a ou > z)
		if (cTypeDec >= 97 && cTypeDec <= 122) {
			// Si une des deux chaine n'est pas vide, il existe.
			bFound = (this.sCtrlSpec[uType].szStandardsTypes || this.sCtrlSpec[uType].szMoreChar);
		}
		return bFound;
	},
	setPreferences: function(nDatePivot, dateOrder, dateSep, thsndSep, decSep, hourSep) {
		// Si la date pivot n'est pas dans la tranche [1901-2000], on laisse la valeur par d�faut!
		if (nDatePivot > 1900 && nDatePivot <= 2000) {
			this.preferences.nDatePivot = nDatePivot - 1900;
			// See L4G doc "adxdcs" for the next line
			this.preferences.nDatePivot -= 1;
			this.preferences.bDatePivotBySrv = true;
		}
		this.preferences.dateOrder = dateOrder || this.preferences.dateOrder;
		this.preferences.cSepDate = dateSep || this.preferences.cSepDate;
		this.preferences.cSepGroupNum = thsndSep || this.preferences.cSepGroupNum;
		this.preferences.cSepDecimal = decSep || this.preferences.cSepDecimal;
		this.preferences.cSepTime = hourSep || this.preferences.cSepTime;
		this.preferences.szMasqueDate = ""; //TODO + nTypeOfDate + this.preferences.dateOrder...
	}
});

function LegacyCSFormatter() {}
exports.LegacyCSFormatter = helpers.defineClass(LegacyCSFormatter, null, {
	pTypesC: pTypesC,
	pSubTypesC: pSubTypesC,
	initialize: function() {
		this._razFmt();
	},
	_razFmt: function() {
		this.szFormat = null;
		this.bIsNull = false;
		this.nType = 0;
		this.nStringLen = 0;
		this.nStringTotalLen = 0;
		this.nEnt = 0;
		this.nDeci = 0;
		this.cAlign = 0;
		this.bIsVisible = true;
		this.bWithColor = false;
		this.bSuccess = true;
		this.bNoInputCtrl = false;
		this.sNumValue = {};
		this.sStringValue = {};
		this.sDatreValue = {};
		this.szRealString = "";
		this.szOriginalString = "";
	},
	_initFmt: function() {
		this.nType = 0;
		this.nStringLen = 0;
		this.nStringTotalLen = 0;
		this.nEnt = 0;
		this.nDeci = 0;
		this.cAlign = 0;
		this.bWithColor = FALSE;
		this.szDispTime = "";
		this.szDispDate = "";
		this.szGlobalCtrl = "";
		this.szAfficCtrl = "";
		this.nDispString = [];
	},
	getFmtDataType: function(format) {
		var cutFmt, def = {
				"t": pTypesC.S_STRG
			}, st, t;
		format = format || this.szFormat;
		if (format && format.length > 0 && (cutFmt = this._cutFmt(format))) {
			if (cutFmt.left.indexOf(pTypes.F_STRG) >= 0) {
				return {
					"t": pTypesC.S_STRG
				};
			} else if (cutFmt.left.indexOf(pTypes.F_NUM) >= 0) {
				t = pTypesC.S_NUM;
				st = pSubTypesC[t].X_INT;
				if (cutFmt.right.indexOf('F') >= 0) {
					st = pSubTypesC[t].X_FLOAT;
				} else if (cutFmt.right.indexOf('.') >= 0) {
					st = pSubTypesC[t].X_DCB;
				};
				return {
					"t": t,
					"st": st
				};
			} else if (cutFmt.left.indexOf(pTypes.F_DATE) >= 0) {
				return {
					"t": pTypesC.S_DATE
				};
			} else if (cutFmt.left.indexOf(pTypes.F_MNL) >= 0) {
				return {
					"t": pTypesC.S_MNL
				};
			}
		}
		return def;
	},
	setTypeAndAttrib: function(format) {
		var i = 0,
			flagNum = false,
			len = format.length;
		while (i < len) {
			switch (format[i]) {
				case pTypes.F_STRG:
					this.nType = pTypesC.S_STRG;
					break;
				case pTypes.F_NUM:
					this.nType = pTypesC.S_NUM;
					flagNum = true;
					break;
				case pTypes.F_DATE:
					if (!flagNum) {
						// Attention, on peut avoir un num�rique (N) avec une option = 'D' .. donc Cuidado
						this.nType = pTypesC.S_DATE;
					}
					break;
				case displayOpts.F_L4G:
					//  On regarde s'il existe le 'D' juste apr�s
					if (format[i + 1] === displayOpts.F_NOTOKADX[1]) {
						// Dans ce cas, c'est TD qu'il faut analyser, on garde donc l'info dans le format global
						this.szGlobalCtrl[i] = displayOpts.F_NOTOKEN;
						this.szGlobalCtrl[i + 1] = displayOpts.F_NOTOKEN;
						// ... et on se d�cale de 1 pour �viter le 'D'
						i++;
					}
					break;
				case fmtFrame.F_ATTRIBBEGIN:
					i += this._updateStructStyle(format);
					break;
				case gridOpts.F_RIGHT:
				case gridOpts.F_CENTER:
				case gridOpts.F_LEFT:
					this.cAlign = format[i];
					break;
				case gridOpts.F_COLOR:
					this.bWithColor = true;
					break;
			}
			i++;
		}
		return true;
	},
	_isEditor: function() {
		return this.szGlobalCtrl.indexOf(dataSubTypes.F_EDITORRTF) >= 0 || this.szGlobalCtrl.indexOf(dataSubTypes.F_EDITORHLP) >= 0 || this.szGlobalCtrl.indexOf(dataSubTypes.F_EXECUTABLE) >= 0 ? true : false;
	},
	_expandFmt: function(format) {},
	_cutFmt: function(format) {
		var i, j = 0,
			ret = {
				"isVisible": true
			}, split;
		split = format.split(fmtFrame.F_SEPARATOR);
		if (split.length == 0 || split.length < 2) {
			// TODO : throw error
			return null;
		}
		// Contr�le tout de m�me si le separateur ne serait pas dans un bloc de commentaire
		i = format.indexOf(fmtFrame.F_SEPARATOR) + 1;
		// Position du debut de masque
		if (format.indexOf(fmtFrame.F_MASKBEGIN) >= 0) {
			j = format.indexOf(fmtFrame.F_MASKBEGIN) + 1;
		}
		// Si on a trouv� le separateur dans un bloc, c'est pas bon; les Mask sont situ�s apr�s le s�parateur
		if (j > 0 && j < i) {
			// TODO : throw error
			return null;
		}
		// On regarde si le t�moin de champ invisible est pr�sent
		if (split[0][0] == gridOpts.F_NOVISIBLE) {
			ret.isVisible = false;
		}
		// Maintenant on supprime tous les caract�res avant la notion du champ (donc t�moin de champ invisible inclu)
		i = 0;
		j = split[0].length;
		while (i < j && split[0][i] != pTypes.F_STRG && split[0][i] != pTypes.F_NUM && split[0][i] != pTypes.F_DATE && split[0][i] != pTypes.F_LBL && split[0][i] != pTypes.F_PGBR) {
			i++;
		}
		ret.left = split[0].substr(i);
		ret.right = split[1];
		return ret;
	},
	_updateStructStyle: function(format) {
		// Juste l� pour calculer la taille des attributs... le style est n'est plus g�r� dans cette classe
		var j = 0,
			start, stop;
		if ((start = _format.indexOf(fmtFrame.F_ATTRIBBEGIN)) >= 0 && (stop = _format.indexOf(fmtFrame.F_ATTRIBEND, start)) >= 0) {
			j = stop - start;
		}
		return j;
	}
});