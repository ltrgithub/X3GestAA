"use strict";
var helpers = require('syracuse-core/lib/helpers');
var RawListBuilder = require("syracuse-ui/lib/common/field/collection/rawListBuilder").RawListBuilder;
var X3SortData = require('./x3SortData').X3SortData;
var X3GuiMod = require('./x3GuiMod').X3GuiMod;
var GridRecord = require('./gridRecord').GridRecord;
var sapUtil = require('../../core/client/sap/util').Fusion;

function GridBuilder(){
}

exports.Builder = helpers.defineClass(GridBuilder, RawListBuilder, {
    initialize: function(RecordClass){
        this.list.RecordClass = RecordClass || GridRecord;
        this.$fusionSkinSuffix = "-fusion";
        this.$frozenLength = 0;
        this.$scrollLength = 0;
        this.guimod = new X3GuiMod();
        this.guimodCol = {};
        this.recordDataCount = 0;
		this.recordIndexFocus=null;
        this.rowsOrder = [];
        this.rows = {};
        this.state = {
            'fBuild': 0,
            'cBuild': 0,
            'fVisible': 0,
            'down': true
        };
    },
    getGridXid: function(){
        return this.list.$item.$bind;
    },
    emptyDataBody: function(){
        this.$$rowsFrozen.empty();
        this.$$rowsScroll.empty();
        this.rowsOrder = [];
        this.rows = {};
        this.guimod = new X3GuiMod();
        this.guimodCol = {};
		this.recordDataCount=0
    },
    makeSkinFusion: function(css, suffix){
        if (!suffix) {
            var suffix = "";
        }
        return (css + suffix + this.$fusionSkinSuffix);
    },
    appendSkinFusion: function(css, suffix){
        return (css + " " + this.makeSkinFusion(css, suffix));
    },
    drawBuilder: function(){
        var list = this.list;
        var isNew = true, self = this;
        list.$skin = list.$item.$skin || "s-grid";
        list.$$item.bind('mouseover', function(event){
            self._mouseOver(event);
        });
        list.$$item.bind('mouseout', function(event){
            self._mouseOut(event);
        });
        
        //FBD - LISTE GAUCHE NON UTILISE
        list.$$list = $("<div/>").addClass("s-list").appendTo(list.$$value);
        /*list.$$topbar = $("<div/>").addClass("s-list-topbar").appendTo(list.$$list);
         
         list.appendArticleMenus(list.$$value);
         */
        if (!list.$item.$hidePager) {
            list.appendPager(list.$$value);
        }
        list._appendCore();
		if (list.$prototype.$cube) {
            list.appendGraph(self.getGridXid());
        }
        list._appendAuthoringOpener();
        
        var $$list = $("<div/>").addClass(self.appendSkinFusion(list.$skin)).hide();
        list._$$header = $("<div/>").appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-header")); //header
        if (list._$$body) {
            isNew = false
        }
        if (isNew) {
            list._$$body = $("<div/>").appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-content")); //container
            self.$$rowsFrozen = $("<div/>").appendTo(list._$$body).addClass(self.makeSkinFusion(list.$skin, "-frozen"));
            self.$$rowsScroll = $("<div/>").appendTo(list._$$body).addClass(self.makeSkinFusion(list.$skin, "-scroll"));
            self._$$scroller = $("<div/>").appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-hScroll")); //scroller h
            self._$$innerScroller = $("<div/>").appendTo(self._$$scroller).addClass(self.makeSkinFusion(list.$skin, "-innerScroll"))
            self._$$innerScroller.html("&nbsp;")
            list._$$body.bind('scroll', function(event){
                self.scrollTop(event);
            });
            
            self._$$scroller.bind('scroll', function(event){
                self.scrollLeft(event);
            });
        }
        list.$$value.append($$list);
        if (!list.$item.$layout) {
            list.$item.$layout = {}
        };
        if (!list.$item.$layout.$items) {
            list.$item.$layout.$items = list.$binds.map(function($bind){
                return {
                    $bind: $bind
                };
            });
        }
        list.applyDesignMetaData(list.$item, false);
        self.drawOrientation();
        list.appendSelector();
        
        if (!list.$item.$isTitleRowHidden) {
            self.makeTitleRow();
        }
        self.$$rowsFrozen.width(self.$frozenLength);
        self.$$rowsScroll.width(self.$scrollLength);
        self.resizeLeftScroll();
        self.list.appendQuickFilter();
        self._bindSort();
        list.boxParent.getArticle().bind(list, self.getGridXid());
        list._$$body.height(self.$lineCount * self.size("lineHight"))
        self.$$rowsScroll.css("left", self.$frozenLength + "px")
        $$list.show();
    },
    
    _bindSort: function(){
        var self = this;
        self.list.$$item.delegate("a[data-s-sort]", "click", function(){
            var $bind = $(this).attr("data-s-sort");
            var $newOrderBy = [], found;
            if (self.list.$orderBy) {
                self.list.$orderBy.forEach(function($orderItem){
                    if ($orderItem.binding == $bind) {
                        found = true;
                        if ($orderItem.$step != 2) {
                            $orderItem.$step = ($orderItem.$step || 0) + 1;
                            if (!$orderItem.descending) {
                                $orderItem.descending = true;
                            }
                            $newOrderBy.push($orderItem);
                        }
                    }
                    else {
                        $newOrderBy.push($orderItem);
                    }
                });
            }
            if (!found) {
                $newOrderBy.push({
                    binding: $bind,
                    descending: false,
                    $step: 1
                });
            }
            self.list.fetch($newOrderBy ? {
                orderBy: $newOrderBy
            } : null);
            return false;
        });
    },
    _mouseOver: function(ev){
        this.list._$$body.css("overflow-y", "auto");
        this._$$scroller.css("overflow-x", "auto");
    },
    _mouseOut: function(ev){
        this.list._$$body.css("overflow-y", "hidden");
        this._$$scroller.css("overflow-x", "hidden");
    },
    endBinding: function($isDelta){
        this.list.dataLoaded = true;
        if (this.list.callBack) {
            this.list.callBack($isDelta, null, this.list.dataset);
        }
        console.log("gridBuilder.endBinding");
    },
    reSynch: function(record){
        if (!record.$range) 
            return;
        var self = this;
        var list = self.list;
        var del = (record.$range[0] === sapUtil.dataSetMvt.del);
        var insrt = (record.$range[0] === sapUtil.dataSetMvt.insrt);
        var start = record.$range[1];
        var count = record.$range[2];
        if (start <= self.state.fBuild + self.state.cBuild) {
            if (del) {
                self.state.cBuild -= count;
            }
        }
        Object.keys(list.dataset).forEach(function(val){
            if (list.dataset[val].$recordIndex >= start) {
                if (del) {
                    list.dataset[val]._refresh(list.dataset[val].$recordIndex - count, insrt);
                }
                else {
                    list.dataset[val]._refresh(list.dataset[val].$recordIndex + count, insrt);
                }
            }
            else {
                if (list.dataset[val].$recordIndex < 0) {
                    list.dataset[val]._refresh(Math.abs(list.dataset[val].$recordIndex) - 1 + start, insrt);
                }
            }
        });
    },
    toBuild: function(index){
        var r = (index <= this.state.fVisible + this.$lineCount + this.countLineFlow - 1 && index >= this.state.fBuild);
        return r;
    },
    recordAdded: function(record){
        this.rows[record.$recordIndex] = record;
        if (record.$recordIndex >= 0) {
            this.rowsOrder[record.$recordIndex] = record;
        }
        this.recordDataCount++;
    },
    recordRemoved: function(record){
        delete (this.rows[record.$recordIndex]);
        this.rowsOrder.splice(record.$recordIndex, 1);
        this.recordDataCount--;
    },
    drawOrientation: function(){
        var $item = this.list.$item;
        if ($item.$alternateStyle) {
            this.$alternateStyle = this.list.$skin + "-alt";
        }
        this.$columnsCount = $item.$layout.$items.length;
        if ($item.$preView) {
            this.$columnsCount++;
        }
        if (this.recordSelector && this.recordSelector.hasColumn) {
            this.$columnsCount++;
        }
    },
    makeTitleRow: function(){
        var self = this;
        var list = self.list;
        var o = {};
        var css = list.$skin + "-title-cell";
        var isNew;
        if (self.$$titleRow) {
            self.$$titleRow.empty();
        }
        else {
            isNew = true;
            self.$$titleRowFrozen = $("<div/>").addClass(self.makeSkinFusion(css + "s-frozen"));
            self.$$titleRowScroll = $("<div/>").addClass(self.makeSkinFusion(css + "s-scroll"));
        }
        /*
         if (list.$item.$preView) {
         self.$$titleRow.append($("<th/>").addClass(css + " " + list.$skin + "-preview-cell").append("<a class='" + list.$skin + "-preview-opener s-close'/>"));
         }
         if (this.recordSelector) {
         self.$$titleRow.append($("<th/>").addClass(css + " " + list.$skin + this.recordSelector.css).append(this.recordSelector.title));
         }*/
        self.$$titleCells = {};
        var cssLink = list.$skin + "-title-link " + list.$skin + "-title-link-fusion";
        if (!self.$fieldnl.$isHidden) {
            self.makeTitleColumn(self.$fieldnl, list.$itemnl, cssLink, css);
            list.$fields[self.getGridXid() + "_NL"] = self.$fieldnl;
            self.$$titleCells[self.getGridXid() + "_NL"].bind('click', function(event){
                self.resetSort();
            });
        }
        list.$item.$layout.$items.forEach(function($item){
            var $field = list.$fields[$item.$bind];
            self.makeTitleColumn($field, $item, cssLink, css);
            self.$$titleCells[$item.$bind].bind('click', function(event){
                if (event.ctrlKey) {self.sortTest($item.$bind);}
            });
        });
        if (isNew) {
            self.$$titleRowFrozen.width(self.$frozenLength);
            self.$$titleRowScroll.width(self.$scrollLength);
            list._$$header.width(self.$frozenLength + self.$scrollLength)
            list._$$header.append(self.$$titleRowFrozen).append(self.$$titleRowScroll);
        }
    },
	_isLineVisible:function(noLine){
		return (noLine >= (this.state.fVisible+1) && noLine <= this.state.fVisible+this.$lineCount);
	},
	setCellVisible:function(xid,noLine){
		this.setLineVisible(noLine);
		this._cellVisible(xid);
	},
	_cellVisible:function(xid){
		var list = this.list,$field = list.$fields[xid], pos=0;
		if ($field.$capability.frozen) return null;
		this._scrollCellToVisible(xid);
	},
	_scrollCellToVisible:function(xid){
		var a=this._$$scroller[0].clientWidth; 					// visible width;
		var b=this.$$rowsFrozen.width(); 						// Frozen width;
		var c=parseInt(this.$$rowsScroll.css("marginLeft"),10); // Scroll width
		var d=this.$$titleCells[xid].position().left; 			// pos cell
		var d2=this.$$titleCells[xid].width();					// Size cell
		/*var trace={};trace.xid=xid;trace.visibleWidth=a;trace.frozenWidth=b;trace.scrollWidth=c;trace.posCell=d;trace.sizeCell=d2;trace.scroll=0;*/
		if (d+c < 0) {
			this._$$scroller.scrollLeft(d);
			//trace.scroll=d;trace.type="1";
		}else{
			if((d+d2+c)-(a-b) > 0) {
				this._$$scroller.scrollLeft(d-a+b+d2+20);
				//trace.scroll=d-a+b+d2+20;trace.type="2"
			}
		}
		//console.log("gridBuilder._scrollCellToVisible :" + JSON.stringify(trace))
	},
	setLineVisible:function(noLine){
		if(!this._isLineVisible(noLine)){
			var i=Math.max((noLine-1)-Math.round(this.$lineCount/2),0);
			this.list._$$body.scrollTop(i*this.list.$lineHeight);
		}
	},
    sort: function(criteria){
        var srt = new X3SortData(), self = this;
        criteria.forEach(function(crit){
            crit.t = self.list.$field.$item.$[crit.p].$type;
        })
        srt.sort(self.rowsOrder, criteria, "dataset")
        self.redrawRows()
    },
    sortTest: function(id){
        if (!this.sortCriter) {
            this.sortCriter = []
        }
        this.sortCriter.push(id)
        var c = []
        this.sortCriter.forEach(function(cr, i){
            c.push({
                "p": cr,
                "asc": (i % 2)
            })
        })
        this.sort(c)
    },
    resetSort: function(){
        if (this.sortCriter && this.sortCriter.length > 0) {
            this.sortCriter = []
            var srt = new X3SortData()
            srt.sort(this.rowsOrder, [{
                "p": "$recordIndex",
                "asc": true,
                "t": "application/x-integer"
            }])
            this.redrawRows();
        }
    },
    makeTitleColumn: function($field, $item, cssLink, css){
        if ($field && !$field.$isHidden) {
            var self = this;
            $field.$constraints = ($field.$constraints) ? $field.$constraints : {}
            $field.$constraints.$maxLength = ($field.$constraints.$maxLength) ? $field.$constraints.$maxLength : 2
            $field.$constraints.$showLength = ($field.$constraints.$showLength) ? $field.$constraints.$showLength : $field.$constraints.$maxLength
            var $$title = $field.$capability.sort ? $("<a/>").attr("data-s-sort", $item.$bind).addClass(cssLink).attr("unselectable", "on") : $("<div/>").addClass(cssLink).attr("unselectable", "on");
            if ($field.$title) {
                $$title.text(self.list.getLocalizedTitle($field.$title));
            }
            else {
                $$title.html("&nbsp;");
            }
            var $$cell = $("<div/>").addClass(self.appendSkinFusion(css, "-header")).attr("s-bind", $item.$bind)
            var $$resize = $("<span/>").addClass(self.list.$skin + "-cell-resize-fusion").attr("unselectable", "on");
            $$cell.append($$title);
            $$cell.append($$resize);
            $$resize.bind('mousedown', function(event){
                self.startResizeCel(event);
            });
            $field.$cellLength = Math.max($field.$constraints.$showLength, ($field.$title || "").length + 2)
            $$cell.width($field.$cellLength * self.size("charWidth"))
            
            $field.$cellLength = Math.round($$cell.width())
            $$resize.width(self.size("charWidth"))
            $$resize.css("left", $$cell.width() - (self.size("charWidth")))
            if ($field.$capability.frozen) {
                $$cell.attr("s-frozen", true)
                self.$$titleRowFrozen.append(self.$$titleCells[$item.$bind] = $$cell);
                self.$frozenLength += $field.$cellLength + 1;
            }
            else {
                self.$$titleRowScroll.append(self.$$titleCells[$item.$bind] = $$cell);
                self.$scrollLength += $field.$cellLength + 1;
            }
        }
    },
    renderLines: function(newVisible, clear){
        this.scroll = null;
        this.state.down = (newVisible > this.state.fVisible);
        this.state.fVisible = newVisible;
        var start = (this.state.down) ? (Math.max(0, this.state.fVisible - this.countLineFlow)) : (Math.max(0, this.state.fVisible - this.countLineFlow))
        var end = (this.state.down) ? (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow)) : (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow))
        this.state.fBuild = start;
        clear = false
        this.cleanRows(clear);
        this.addRows(start, end)
    },
    appendNoRecordRow: function(){
        $("<tr/>").append($("<td/>").attr("colspan", this.$columnsCount).append(this.list.appendEmptyInfo())).appendTo(this.list._$$body);
    },
    onRedrawCore: function(){
        this.drawOrientation();
        if (!this.list.$item.$isTitleRowHidden) {
            this.makeTitleRow();
        }
        if (this.list.quickFilterBox) {
            this.list.quickFilterBox.drawBox();
        }
    },
    resizeRowsContainer: function(){
        this.$$rowsFrozen.height(this.recordDataCount * this.size("lineHight"));
        this.$$rowsScroll.height(this.recordDataCount * this.size("lineHight"));
    },
    size: function(t){
        if (!this.list.$lineHeight || !this.$charWidth) {
            var $$t = $("<div/>").appendTo(document.body);
            $$t.attr('class', this.makeSkinFusion(this.list.$skin, '-line'));
            $$t.html("A");
            $$t.show();
            this.list.$lineHeight = $$t.height();
            this.$charWidth = $$t.width();
            $$t.remove();
        };
        if (t === "lineHight") 
            return this.list.$lineHeight;
        if (t === "charWidth") 
            return this.$charWidth;
    },
    scrollTop: function(ev){
        var self = this;
        var t = 0
        var newVisible = Math.floor(ev.target.scrollTop / this.size("lineHight")), clear = (Math.abs(newVisible - this.state.fVisible) > (this.$lineCount + this.countLineFlow));
        if (newVisible == this.state.fVisible) {
            if (self.scroll) {
                clearTimeout(self.scroll);
                self.scroll = null
            }
            return;
        }
        if (self.scroll) {
            clearTimeout(self.scroll);
            self.scroll = null;
            t = 30
        }
        self.scroll = setTimeout((function(o, n, c){
            return function(){
                self.renderLines(n, c)
            }
        })(this.list, newVisible, clear), t)
    },
    scrollLeft: function(ev){
        this.$$rowsScroll.css('marginLeft', (-ev.target.scrollLeft) + 'px');
        this.$$titleRowScroll.css("marginLeft", (-ev.target.scrollLeft) + 'px');
    },
    addRows: function(start, end){
        var count = 0
        var t = new Date().getTime();
        for (var i = start; i < end; i++) {
            if (this.scroll) 
                return;
            if (!this.rowsOrder[i]._isBuilded()) {
                count++;
                this.rowsOrder[i].drawBox(i);
            }
        }
        //console.log("_addRows form:" + start +" to:"+(end-1) + " t:" +(new Date().getTime()-t) + " count:"+count)
    },
    redrawRows: function(){
        var c = this.state.cBuild + this.state.fBuild
        this.cleanRows(true);
        this.addRows(this.state.fBuild, c)
    },
    cleanRows: function(all){
        if (all) {
            this._clearRows();
        }
        else {
            this.removeRows()
        }
    },
    _clearRows: function(){
        this.rowsOrder.forEach(function(row){
            if (row._isBuilded()) {
                row._removeLineRow();
            }
        });
    },
    removeRows: function(){
        var count = 0
        var t = new Date().getTime()
        var s = (this.state.down) ? (0) : (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow));
        //var e = (this.state.down) ? (this.state.fBuild) : (this.recordDataCount), idx;
		var e = Math.min(this.rowsOrder.length,(this.state.down) ? (this.state.fBuild) : (this.recordDataCount)), idx;
        for (var i = s; i < e; i++) {
            //if(this.scroll) return
            count++
            if (this.rowsOrder[i]._isBuilded()) {
                this.rowsOrder[i]._removeLineRow();
            }
        }
        //console.log("_removeRows form:" + s +" to:"+(e-1) + " t:" +(new Date().getTime()-t) + " count:"+count)
    },
    //DC:bug metadata n'est pas passé
    endGuiMods: function(){
        console.log("Grid _endGuiMods");
        if (this.list.callBack) {
            this.list.callBack(null, metaData, null);
        }
    },
    setGuiMods: function(guiMods){
        var self = this;
        for (var k in guiMods) {
            self.setGuimodsByTyp(guiMods[k], k);
        }
    },
    setGuimodsByTyp: function($guimod, $typ){
        if (!X3GuiMod.prototype[$typ]) {
            console.log('Grid._setGuimodsByTyp typ undefined : ' + $typ);
            return;
        }
        var self = this;
        var list = this.list;
        var r, l;
        $guimod.forEach(function(item){
            if (list.$fields[item[0]]) {
                if (item[1] === 0) { //col
                    if ($typ === "tit" || $typ === "stt") {
                        if (!self.guimodCol[item[0]]) {
                            self.guimodCol[item[0]] = new X3GuiMod();
                        }
                        self.guimodCol[item[0]][$typ](item[2]);
                    }
                    if ($typ !== "tit") {
                        if (!self.memGuimodCol) {
                            self.memGuimodCol = {};
                        };
                        if (!self.memGuimodCol[item[0]]) {
                            self.memGuimodCol[item[0]] = new X3GuiMod();
                        };
                        self.memGuimodCol[item[0]][$typ](item[2], false);
                        Object.keys(list.dataset).forEach(function(val){
                            if (!list.dataset[val].guimodCel[item[0]]) {
                                list.dataset[val].guimodCel[item[0]] = new X3GuiMod();
                            }
                            list.dataset[val].guimodCel[item[0]][$typ](item[2], list.dataset[val]._isBuilded());
                        });
                    }
                }
                else { //cel
                    r = list.dataset[parseInt(item[1], 10) - 1];
                    if (!r.guimodCel[item[0]]) {
                        r.guimodCel[item[0]] = new X3GuiMod();
                    };
                    r.guimodCel[item[0]][$typ](item[2], self.rows[(parseInt(item[1], 10) - 1)]._isBuilded());
                }
            }
            else {
                if (item[1] === 0) { //tab
                    if (X3GuiMod[$typ]) {
                        self.guimod[$typ](item[2], false);
                    }
                    else {
                        console.log('Grid._setGuimodsByTyp typ undefined : ' + $typ);
                    }
                }
                else { //line
                    l = (parseInt(item[1], 10) - 1);
                    r = self.rows[l];
                    list.$item.$layout.$items.forEach(function($item){
                        if (!r.guimodCel[$item.$bind]) {
                            r.guimodCel[$item.$bind] = new X3GuiMod();
                        };
                        r.guimodCel[$item.$bind][$typ](item[2], self.rows[l]._isBuilded());
                    });
                }
            }
        });
    },
    applyGuiMod: function(){
        var self = this;
        if (self.guimodCol) {
            for (var key in self.guimodCol) {
                self.guimodCol[key].applyTitle(self.$$titleCells[key][0]) //title col
            }
        }
        var maxRec = Math.min((self.state.fBuild + self.state.cBuild - 1), (this.recordDataCount - 1))
        for (var i = self.state.fBuild; i <= (maxRec); i++) {
            self.rows[i].applyGuiMod()
        }
        this.resizeLeftScroll();
    },
    lineCount: function(v){
        this.$lineCount = (v) ? v : 5;
        this.countLineFlow = Math.round(this.$lineCount);
        this.list.$itemsPerPage = this.$lineCount;
    },
    changeLineCount: function(v){
        if (v && !isNaN(v)) {
            this.lineCount(v);
            this.renderLines(this.state.fVisible, false);
            this.resizeBody();
        }
    },
    resizeBody: function(){
        this.list._$$body.height(this.$lineCount * this.size("lineHight"));
    },
    startResizeCel: function(ev){
        var self = this;
        console.log("_startResizeCel");
        var size = $(ev.target.parentElement).width()
        $(document).bind('mousemove.' + this.id, function(event){
            self.resizingCell(event, ev.target, ev.clientX, size);
        });
        $(document).bind('mouseup.' + this.id, function(event){
            self.stopResizeCell(event, ev.target);
        });
        document.body.style.cursor = "w-resize";
    },
    resizingCell: function(ev, target, pos, sizeI){
        var wMove = ev.clientX - pos;
        var w = Math.max(sizeI + wMove, 14);
        var wm = w - sizeI;
        if ($(target.parentElement).attr("s-frozen")) {
            this.$$titleRowFrozen.width(this.$frozenLength + wm)
        }
        else {
            this.$$titleRowScroll.width(this.$scrollLength + wm)
        }
        this.list._$$header.width(this.$frozenLength + this.$scrollLength + wm)
        this.list.$fields[$(target.parentElement).attr("s-bind")].$cellLength = w
        $(target.parentElement).width(w);
        $(target).css("left", w - (this.size("charWidth")));
    },
    resizeLeftScroll: function(){
        var l = 0;
        this.$$titleRowFrozen.children().each(function(){
            if ($(this).css("display") != "none") {
                l += $(this).width() + 1;
            }
        });
        this.$$titleRowScroll.children().each(function(){
            if ($(this).css("display") != "none") {
                l += $(this).width() + 1;
            }
        });
        this._$$innerScroller.width(l + 18);
    },
    stopResizeCell: function(ev, target){
        $(document).unbind('mousemove');
        $(document).unbind('mouseup');
        document.body.style.cursor = "";
        this.$frozenLength = this.$$titleRowFrozen.width();
        this.$scrollLength = this.$$titleRowScroll.width();
        this.$$rowsFrozen.width(this.$frozenLength);
        this.$$rowsScroll.width(this.$scrollLength);
        this.resizeLeftScroll();
        this.$$rowsScroll.css("left", this.$frozenLength + "px");
        var w = this.list.$fields[$(target.parentElement).attr("s-bind")].$cellLength;
        $('[id="' + $(target.parentElement).attr("s-bind") + '"]').each(function(){
            $(this).width(w);
        });
    },
    getStringXmlData: function(){
        var xAr = [], list = this.list, ordered = this.rowsOrder.slice(0), srt = new X3SortData();
        var Prfx = this.getGridXid().substr(this.getGridXid().length - 1);
        srt.sort(ordered, [{
            "p": "$recordIndex",
            "asc": true,
            "t": "application/x-integer"
        }]);
        var l = Object.keys(ordered[0]).length;
        xAr.push("<ds" + this.getGridXid() + ">\n");
        ordered.forEach(function(record){
            xAr.push('<r I="' + (record.$recordIndex + 1) + '">');
            xAr.push('<' + Prfx + '1>');
            xAr.push(record.$recordIndex + 1);
            xAr.push('</' + Prfx + '1>');
            for (var i = 0; i < l; i++) {
                if (record.dataset[this.getGridXid() + (i + 1)]) {
                    xAr.push('<' + Prfx + (i + 1) + '>');
                    //TODO : Ajouter C_Xn Libelle menu locaux
                    xAr.push(list._getValue(record, this.getGridXid() + (i + 1)));
                    xAr.push('</' + Prfx + (i + 1) + '>');
                }
            }
            xAr.push('</r>\n');
        });
        xAr.push("</ds" + this.getGridXid() + ">");
        return xAr.join("");
    },
    getStringXmlColumnUsage: function($Caller){
        var xAr = [], list = this.list, Prfx = this.getGridXid().substr(this.getGridXid().length - 1);
        xAr.push('<CPH XD1="' + Prfx + '1" NAM="" TYP="6" FMT="N:4#" TDO="4"><![CDATA[]]></CPH>');
        Object.keys(list.$fields).forEach(function(key){
            if (list.$fields[key].$X3) {
                xAr.push('<CPH XD1="' + key.substr(1) + '" ');
                xAr.push('NAM="' + list.$fields[key].$X3.$name + '" ');
                xAr.push('TYP="' + list.$fields[key].$X3.$type + '" ');
                xAr.push('FMT="' + list.$fields[key].$X3.$format + '" ');
                xAr.push('TDO="' + list.$fields[key].$X3.$dataType + '" ');
                xAr.push('TFL="' + list.$fields[key].$X3.$usages[$Caller] + '">');
                xAr.push('<![CDATA[' + list.getLocalizedTitle(list.$fields[key].$title) + ']]>');
                xAr.push('</CPH>');
            }
        });
        return xAr.join('')
    },
    appendRecord: function(record, $recordIndex, isInsert){
        if (isInsert) {
            --$recordIndex;
        }
        if (!record.$uuid) {
            record.$uuid = $recordIndex;
        }
        (this.list.dataset[record.$uuid] = new this.list.RecordClass()).loadRecord(this.list, record, $recordIndex);
    },
    dispose: function(){
        if (this._$$scroller) {
            this._$$scroller.unbind();
            delete this._$$scroller;
        }
        if (this.id) {
            $(document).unbind("." + this.id);
        }
        RawListBuilder.prototype.dispose.call(this);
    }
});
