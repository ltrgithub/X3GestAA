"use strict";
var helpers = require('syracuse-core/lib/helpers');
var RawListBuilder = require("syracuse-ui/lib/common/field/collection/rawListBuilder").RawListBuilder;
var X3SortData = require('./x3SortData').X3SortData;
var X3GuiMod = require('./x3GuiMod').X3GuiMod;
var GridRecord = require('./gridRecord').GridRecord;
var sapUtil = require('../../core/client/sap/util').Fusion;

function GridBuilder(){
}

exports.Builder = helpers.defineClass(GridBuilder, RawListBuilder, {
    initialize: function(){
        this.list.RecordClass = this.list.RecordClass || GridRecord;
	this.list.$skin = this.list.$item.$skin || "s-grid";
	this.typeElement={};
        this.$fusionSkinSuffix = "-fusion";
		this._css=this._initCssClass();
        this.$frozenLength = 0;
        this.$scrollLength = 0;
        this.guimod = new X3GuiMod();
        this.guimodCol = {};
        this.recordDataCount = 0;
        this.recordIndexFocus = null;
        this.rowsOrder = [];
        this.rows = {};
        this.state = {
            'fBuild': 0,
            'cBuild': 0,
            'fVisible': 0,
            'down': true
        };
		this.sizesline={"frozen":{"cellsCount":0,"minLength":0,"length":0},"scroll":{"cellsCount":0,"minLength":0,"length":0}};
	},
	_initCssClass:function(){
		var css={}
		css.nolineFusion=this.makeSkinFusion(this.list.$skin, "-cell") + "-noline";
		this.typeElement[css.nolineFusion]="noline";
		css.noline=this.list.$skin + "-cell " + css.nolineFusion;
		css.lineFusion=this.makeSkinFusion(this.list.$skin, '-line')
		css.headerFusion=this.makeSkinFusion(this.list.$skin, "-header");
		css.headerCellFusion=this.list.$skin + "-title-cell";
		this.typeElement[css.headerCellFusion]="cellheader";
		css.cellFusion=this.list.$skin + "-cell";
		this.typeElement[css.cellFusion]="cell";
		return css
	},
    getGridXid: function(){
        return this.list.$item.$bind;
    },
    emptyDataBody: function(){
        this.$$rowsFrozen.empty();
        this.$$rowsScroll.empty();
        this.rowsOrder = [];
        this.rows = {};
        this.guimod = new X3GuiMod();
        this.guimodCol = {};
        this.recordDataCount = 0
    },
    makeSkinFusion: function(css, suffix){
        if (!suffix) {
            var suffix = "";
        }
        return (css + suffix + this.$fusionSkinSuffix);
    },
    appendSkinFusion: function(css, suffix){
        return (css + " " + this.makeSkinFusion(css, suffix));
    },
    drawBuilder: function(){
        var list = this.list;
        var isNew = true, self = this;
        list.$$item.bind('mouseover', function(event){
            self._mouseOver(event);
        });
        list.$$item.bind('mouseout', function(event){
            self._mouseOut(event);
        });
        
        var $$list = $("<div/>").addClass(self.appendSkinFusion(list.$skin)).hide();
        list._$$header = $("<div/>").appendTo($$list).addClass(self._css.headerFusion); //header
        if (list._$$body) {
            isNew = false
        }
        if (isNew) {
            list._$$body = $("<div/>").appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-content")); //container
            self.$$rowsFrozen = $("<div/>").appendTo(list._$$body).addClass(self.makeSkinFusion(list.$skin, "-frozen"));
            self.$$rowsScroll = $("<div/>").appendTo(list._$$body).addClass(self.makeSkinFusion(list.$skin, "-scroll"));
            self._$$hscroller = $("<div/>").appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-hScroll")); //scroller h
			self._$$vscroller = $("<div/>").appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-vScroll")); //scroller v
			self._$$vscroller.css("left",0);
            self._$$innerhScroller = $("<div/>").appendTo(self._$$hscroller).addClass(self.makeSkinFusion(list.$skin, "-innerhScroll"))
            self._$$innerhScroller.html("&nbsp;")
			self._$$innervScroller = $("<div/>").appendTo(self._$$vscroller).addClass(self.makeSkinFusion(list.$skin, "-innervScroll"))
            self._$$innervScroller.html("&nbsp;")
			
            self._$$vscroller.bind('scroll', function(event){
                self.scrollTop(event);
            });
            
            self._$$hscroller.bind('scroll', function(event){
                self.scrollLeft(event);
            });
			list.$$item.attr("id",this.list.id)
        }
        list.$$listSlot.append($$list);
        
        list.applyDesignMetaData(list.$item, false);
        self.drawOrientation();
        list.appendSelector();
        
        if (!list.$item.$isTitleRowHidden) {
            self.makeTitleRow();
        }
        self.$$rowsFrozen.width(self.sizesline.frozen.length+"%");
        self.$$rowsScroll.width(self.sizesline.scroll.length+"%");
        self.$$rowsFrozen.css("minWidth",self.sizesline.frozen.minLength);
        self.$$rowsScroll.css("minWidth",self.sizesline.scroll.minLength);
		list._$$body.css("minWidth",self.sizesline.scroll.minLength+self.sizesline.frozen.minLength);
		self._$$innerhScroller.width(self.sizesline.scroll.minLength+self.sizesline.frozen.minLength + 18);
        self.resizeWidth(0);
        self.list.appendQuickFilter();
        self._bindSort();
        list.boxParent.getArticle().bind(list, self.getGridXid());
        list._$$body.height(self.$lineCount * self.size("lineHeight"))
        $$list.show();
	console.log("Width : " +list._$$body.width())
    },
    
    _bindSort: function(){
        var self = this;
        self.list.$$item.delegate("a[data-s-sort]", "click", function(){
            var $bind = $(this).attr("data-s-sort");
            var $newOrderBy = [], found;
            if (self.list.$orderBy) {
                self.list.$orderBy.forEach(function($orderItem){
                    if ($orderItem.binding == $bind) {
                        found = true;
                        if ($orderItem.$step != 2) {
                            $orderItem.$step = ($orderItem.$step || 0) + 1;
                            if (!$orderItem.descending) {
                                $orderItem.descending = true;
                            }
                            $newOrderBy.push($orderItem);
                        }
                    }
                    else {
                        $newOrderBy.push($orderItem);
                    }
                });
            }
            if (!found) {
                $newOrderBy.push({
                    binding: $bind,
                    descending: false,
                    $step: 1
                });
            }
            self.list.fetch($newOrderBy ? {
                orderBy: $newOrderBy
            } : null);
            return false;
        });
    },
    _mouseOver: function(ev){
		this._$$hscroller.css("overflow-x", "auto");
		var t=this.list.$$core[0].offsetTop+this.list._$$header.height();
		this._$$vscroller.css("top",t);
		this._$$vscroller.css("left",this.list._$$body.parent().width()-this._$$vscroller.width());
		this._$$vscroller.height(this.list._$$body.height());
		this._$$vscroller.css("overflow-y", "auto");
    },
    _mouseOut: function(ev){
        this._$$vscroller.css("left",0);
        this._$$hscroller.css("overflow-x", "hidden");
	    this._$$vscroller.css("overflow-y", "hidden");
    },
    onClick: function(ctrl,ev){
		//TODO : cellFusion nolineFusion headerCellFusion
		console.log("gridBuilder onClick headerCell:"+ this._isHeaderCell($(ev.target)) + " Cell:"+ this._isCell($(ev.target)) + " Noline:"+ this._isNoLine($(ev.target)) ) ;
		var l=$(ev.target).parents("."+this._css.lineFusion);
		if(l!=undefined){
			var noreq=parseInt(l.data('s-record'),10);
			return this.rows[noreq].onClick(ctrl,ev);
		};
		return false;
   },
	_isHeaderCell:function($$elt){return this._isElementGrid($$elt,this._css.headerCellFusion);},
	_isCell:function($$elt){return this._isElementGrid($$elt,this._css.cellFusion);},
	_isNoLine:function($$elt){return this._isElementGrid($$elt,this._css.nolineFusion);},
   _isElementGrid:function($$elt,type){
		if(!$$elt.hasClass(type)){
			return ($$elt.parents("."+type).length!==0)
		}
		return true;
   },
   _getTypeElement:function($$elt,css){
		return ($$elt.hasClass(css))?this.typeElement[css]:this.typeElement[($$elt.parents("."+css).length!==0)?css:undefined];
   },
   endBinding: function($isDelta){
        this.list.dataLoaded = true;
        if (this.list.callBack) {
            this.list.callBack($isDelta, null, this.list.dataset);
        }
        console.log("gridBuilder.endBinding");
		this.list._$$body.scrollTop(this._$$vscroller.scrollTop())
    },
    reSynch: function(record){
        if (!record.$range) 
            return;
        var self = this;
        var list = self.list;
        var del = (record.$range[0] === sapUtil.dataSetMvt.del);
        var insrt = (record.$range[0] === sapUtil.dataSetMvt.insrt);
        var start = record.$range[1];
        var count = record.$range[2];
        if (start <= self.state.fBuild + self.state.cBuild) {
            if (del) {
                self.state.cBuild -= count;
            }
        }
        Object.keys(list.dataset).forEach(function(val){
            if (list.dataset[val].$recordIndex >= start) {
                if (del) {
                    list.dataset[val]._refresh(list.dataset[val].$recordIndex - count, insrt);
                }
                else {
                    list.dataset[val]._refresh(list.dataset[val].$recordIndex + count, insrt);
                }
            }
            else {
                if (list.dataset[val].$recordIndex < 0) {
                    list.dataset[val]._refresh(Math.abs(list.dataset[val].$recordIndex) - 1 + start, insrt);
                }
            }
        });
    },
    toBuild: function(index){
        var r = (index <= this.state.fVisible + this.$lineCount + this.countLineFlow - 1 && index >= this.state.fBuild);
        return r;
    },
    recordAdded: function(record){
        this.rows[record.$recordIndex] = record;
        if (record.$recordIndex >= 0) {
            this.rowsOrder[record.$recordIndex] = record;
        }
        this.recordDataCount++;
    },
    recordRemoved: function(record){
        delete (this.rows[record.$recordIndex]);
        this.rowsOrder.splice(record.$recordIndex, 1);
        this.recordDataCount--;
    },
    drawOrientation: function(){
        var $item = this.list.$item;
        if ($item.$alternateStyle) {
            this.$alternateStyle = this.list.$skin + "-alt";
        }
        this.$columnsCount = $item.$layout.$items.length;
        if ($item.$preView) {
            this.$columnsCount++;
        }
        if (this.recordSelector && this.recordSelector.hasColumn) {
            this.$columnsCount++;
        }
    },
    makeTitleRow: function(){
        var self = this;
        var list = self.list;
        var o = {};
        var css = self._css.headerCellFusion;
        var isNew;
        if (self.$$titleRow) {
            self.$$titleRow.empty();
        }
        else {
            isNew = true;
            self.$$titleRowFrozen = $("<div/>").addClass(self.makeSkinFusion(css + "s-frozen"));
            self.$$titleRowScroll = $("<div/>").addClass(self.makeSkinFusion(css + "s-scroll"));
        }
        /*
         
         if (this.recordSelector) {
         self.$$titleRow.append($("<th/>").addClass(css + " " + list.$skin + this.recordSelector.css).append(this.recordSelector.title));
         }*/
        self.$$titleCells = {};
        var cssLink = list.$skin + "-title-link " + list.$skin + "-title-link-fusion";
	var l=self._computeWidth();
	console.log("Width : "+ JSON.stringify(l));
        if (!self.$fieldnl.$isHidden) {
            self.makeTitleColumn(self.$fieldnl, list.$itemnl, cssLink, css);
            list.$fields[self.getGridXid() + "_NL"] = self.$fieldnl;
            self.$$titleCells[self.getGridXid() + "_NL"].bind('click', function(event){
                self.resetSort();
            });
        }
        list.$item.$layout.$items.forEach(function($item){
            var $field = list.$fields[$item.$bind];
            if(!$field.$isHidden){
				self.makeTitleColumn($field, $item, cssLink, css);
				self.$$titleCells[$item.$bind].bind('click', function(event){
					if (event.ctrlKey) {
						self.sortTest($item.$bind);
					}
				});
			}
        });
        if (isNew) {
	    self.$$titleRowFrozen.css("minWidth",l.frozen.minLength);
            self.$$titleRowScroll.css("minWidth",l.scroll.minLength);
            self.$$titleRowFrozen.width(l.frozen.length+"%");
            self.$$titleRowScroll.width(l.scroll.length+"%");
            list._$$header.css("minWidth",l.frozen.minLength + l.scroll.minLength);
	    list._$$header.width("100%");
            list._$$header.append(self.$$titleRowFrozen).append(self.$$titleRowScroll);
        }
    },
    makeTitleColumn: function($field, $item, cssLink, css){
        if ($field && !$field.$isHidden) {
            var self = this;
            var $$title = $field.$capability.sort ? $("<a/>").attr("data-s-sort", $item.$bind).addClass(cssLink).attr("unselectable", "on") : $("<div/>").addClass(cssLink).attr("unselectable", "on");
            if ($field.$title) {
                $$title.text(self.list.getLocalizedTitle($field.$title));
            }
            else {
                $$title.html("&nbsp;");
            }
            var $$cell = $("<div/>").addClass(self.appendSkinFusion(css, "-header")).attr("s-bind", $item.$bind)
            var $$resize = $("<span/>").addClass(self.list.$skin + "-cell-resize-fusion").attr("unselectable", "on");
            $$cell.append($$title);
            /*$$cell.append($$resize);
            $$resize.bind('mousedown', function(event){
                self.startResizeCel(event);
            });*/
           /*
            $field.$cellLength = Math.max($field.$constraints.$showLength, ($field.$title || "").length + 2)
			$field.$cellMinLength = Math.max($field.$constraints.$showLength, ($field.$title || "").length + 2)
*/           
			$$cell.width($field.$cellLength+"%");
            $$cell.css("minWidth",$field.$cellMinLength);
            //$field.$cellLength = Math.round($$cell.width());
            $$resize.width(self.size("charWidth"))
            $$resize.css("left", $$cell.width() - (self.size("charWidth")))
            if ($field.$capability.frozen) {
                $$cell.attr("s-frozen", true)
                self.$$titleRowFrozen.append(self.$$titleCells[$item.$bind] = $$cell);
               /* self.$frozenLength += $field.$cellLength + 1;
				self.$frozenMinLength += $field.$cellLength + 1;
				self.$frozenCount++;
				*/
            }
            else {
                self.$$titleRowScroll.append(self.$$titleCells[$item.$bind] = $$cell);
               /* self.$scrollLength += $field.$cellLength + 1;
				self.$scrollMinLength += $field.$cellLength + 1;
				self.$scrollCount++;
				*/
            }
        }
    },
	_computeWidth:function(){
		var self=this,line=this.sizesline;
		self._computeMinWidth(self.$fieldnl, self.list.$itemnl);
		self.list.$item.$layout.$items.forEach(function($item){
            var $field = self.list.$fields[$item.$bind];
            self._computeMinWidth($field, $item);
        });	
		line.frozen.length=line.frozen.minLength*100/(line.frozen.minLength+line.scroll.minLength);
		line.scroll.length=100-line.frozen.length;
		self._computePWidth(self.$fieldnl, self.list.$itemnl);
		self.list.$item.$layout.$items.forEach(function($item){
            var $field = self.list.$fields[$item.$bind];
            self._computePWidth($field, $item);
        });	
		return line;		
	},
	_computeMinWidth:function($field,$item){
		var line=this.sizesline;
		if ($field && !$field.$isHidden){
			$field.$constraints = ($field.$constraints) ? $field.$constraints : {}
            $field.$constraints.$maxLength = ($field.$constraints.$maxLength) ? $field.$constraints.$maxLength : 2
            $field.$constraints.$showLength = ($field.$constraints.$showLength) ? $field.$constraints.$showLength : $field.$constraints.$maxLength
			$field.$cellMinLength = Math.max($field.$constraints.$showLength, ($field.$title || "").length + 2)*this.size("charWidth")
			$field.$cellMinLength = $field.$constraints.$showLength*this.size("charWidth")
			var tl=line.frozen;
			if (!$field.$capability.frozen) {tl=line.scroll;}
			tl.minLength += $field.$cellMinLength+1;
			tl.cellsCount++;
		}
	},
	_computePWidth:function($field,$item){
		var line=this.sizesline;
		if ($field && !$field.$isHidden){
			var tl=line.frozen;
			if (!$field.$capability.frozen) {tl=line.scroll;}
			$field.$cellLength=$field.$cellMinLength*100/(tl.minLength);
		}
	},
    _isLineVisible: function(noLine){
        return (noLine >= (this.state.fVisible + 1) && noLine <= this.state.fVisible + this.$lineCount);
    },
    setCellVisible: function(xid, noLine){
        this.setLineVisible(noLine);
        this._cellVisible(xid);
    },
    _cellVisible: function(xid){
        var list = this.list, $field = list.$fields[xid], pos = 0;
        if ($field.$capability.frozen) 
            return null;
        this._scrollCellToVisible(xid);
    },
    _scrollCellToVisible: function(xid){
        var a = this._$$hscroller[0].clientWidth; // visible width;
        var b = this.$$rowsFrozen.width(); // Frozen width;
        var c = parseInt(this.$$rowsScroll.css("marginLeft"), 10); // Scroll width
        var d = this.$$titleCells[xid].position().left; // pos cell
        var d2 = this.$$titleCells[xid].width(); // Size cell
        /*var trace={};trace.xid=xid;trace.visibleWidth=a;trace.frozenWidth=b;trace.scrollWidth=c;trace.posCell=d;trace.sizeCell=d2;trace.scroll=0;*/
        if (d + c < 0) {
            this._$$hscroller.scrollLeft(d);
            //trace.scroll=d;trace.type="1";
        }
        else {
            if ((d + d2 + c) - (a - b) > 0) {
                this._$$hscroller.scrollLeft(d - a + b + d2 + 20);
                //trace.scroll=d-a+b+d2+20;trace.type="2"
            }
        }
        //console.log("gridBuilder._scrollCellToVisible :" + JSON.stringify(trace))
    },
    setLineVisible: function(noLine){
        if (!this._isLineVisible(noLine)) {
            var i = Math.max((noLine - 1) - Math.round(this.$lineCount / 2), 0);
            //this.list._$$body.scrollTop(i * this.list.$lineHeight);
			this._$$vscroller.scrollTop(i * this.list.$lineHeight);
        }
    },
    sort: function(criteria){
        var srt = new X3SortData(), self = this;
        criteria.forEach(function(crit){
            crit.t = self.list.$field.$item.$[crit.p].$type;
        })
        srt.sort(self.rowsOrder, criteria, "dataset")
        self.redrawRows()
    },
    sortTest: function(id){
        if (!this.sortCriter) {
            this.sortCriter = []
        }
        this.sortCriter.push(id)
        var c = []
        this.sortCriter.forEach(function(cr, i){
            c.push({
                "p": cr,
                "asc": (i % 2)
            })
        })
        this.sort(c)
    },
    resetSort: function(){
        if (this.sortCriter && this.sortCriter.length > 0) {
            this.sortCriter = []
            var srt = new X3SortData()
            srt.sort(this.rowsOrder, [{
                "p": "$recordIndex",
                "asc": true,
                "t": "application/x-integer"
            }])
            this.redrawRows();
        }
    },
    renderLines: function(newVisible, clear){
        this.scroll = null;
        this.state.down = (newVisible > this.state.fVisible);
        this.state.fVisible = newVisible;
        var start = (this.state.down) ? (Math.max(0, this.state.fVisible - this.countLineFlow)) : (Math.max(0, this.state.fVisible - this.countLineFlow))
        var end = (this.state.down) ? (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow)) : (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow))
        this.state.fBuild = start;
        clear = false
        this.cleanRows(clear);
        this.addRows(start, end)
    },
    appendNoRecordRow: function(){
        $("<tr/>").append($("<td/>").attr("colspan", this.$columnsCount).append(this.list.appendEmptyInfo())).appendTo(this.list._$$body);
    },
    onRedrawCore: function(){
        this.drawOrientation();
        if (!this.list.$item.$isTitleRowHidden) {
            this.makeTitleRow();
        }
        if (this.list.quickFilterBox) {
            this.list.quickFilterBox.drawBox();
        }
    },
    resizeRowsContainer: function(){
        this.$$rowsFrozen.height(this.recordDataCount * this.size("lineHeight"));
        this.$$rowsScroll.height(this.recordDataCount * this.size("lineHeight"));
	this._$$innervScroller.height(this.recordDataCount * this.size("lineHeight"));
    },
    size: function(t){
        if (!this.list.$lineHeight || !this.$charWidth) {
            var $$t = $("<div/>").appendTo(document.body);
            $$t.attr('class', this._css.lineFusion);
            $$t.html("A");
            $$t.show();
            this.list.$lineHeight = $$t.height();
            this.$charWidth = $$t.width();
            $$t.remove();
        };
        if (t === "lineHeight") 
            return this.list.$lineHeight;
        if (t === "charWidth") 
            return this.$charWidth;
    },
    scrollTop: function(ev){
        var self = this;
        var t = 0;
		self.list._$$body.scrollTop(ev.target.scrollTop);
        var newVisible = Math.floor(ev.target.scrollTop / this.size("lineHeight")), clear = (Math.abs(newVisible - this.state.fVisible) > (this.$lineCount + this.countLineFlow));
        if (newVisible == this.state.fVisible) {
            if (self.scroll) {
                clearTimeout(self.scroll);
                self.scroll = null
            }
            return;
        }
        if (self.scroll) {
            clearTimeout(self.scroll);
            self.scroll = null;
            t = 30
        }
        self.scroll = setTimeout((function(o, n, c){
            return function(){
                self.renderLines(n, c)
            }
        })(this.list, newVisible, clear), t)
    },
    scrollLeft: function(ev){
        this.$$rowsScroll.css('marginLeft', (-ev.target.scrollLeft) + 'px');
        this.$$titleRowScroll.css("marginLeft", (-ev.target.scrollLeft) + 'px');
    },
    addRows: function(start, end){
        var count = 0
        var t = new Date().getTime();
        for (var i = start; i < end; i++) {
            if (this.scroll) 
                return;
            if (!this.rowsOrder[i]._isBuilded()) {
                count++;
                this.rowsOrder[i].drawBox(i);
            }
        }
        //console.log("_addRows form:" + start +" to:"+(end-1) + " t:" +(new Date().getTime()-t) + " count:"+count)
    },
    redrawRows: function(){
        var c = this.state.cBuild + this.state.fBuild
        this.cleanRows(true);
        this.addRows(this.state.fBuild, c)
    },
    cleanRows: function(all){
        if (all) {
            this._clearRows();
        }
        else {
            this.removeRows()
        }
    },
    _clearRows: function(){
        this.rowsOrder.forEach(function(row){
            if (row._isBuilded()) {
                row._removeLineRow();
            }
        });
    },
    removeRows: function(){
        var count = 0
        var t = new Date().getTime()
        var s = (this.state.down) ? (0) : (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow));
        //var e = (this.state.down) ? (this.state.fBuild) : (this.recordDataCount), idx;
        var e = Math.min(this.rowsOrder.length, (this.state.down) ? (this.state.fBuild) : (this.recordDataCount)), idx;
        for (var i = s; i < e; i++) {
            //if(this.scroll) return
            count++
            if (this.rowsOrder[i]._isBuilded()) {
                this.rowsOrder[i]._removeLineRow();
            }
        }
        //console.log("_removeRows form:" + s +" to:"+(e-1) + " t:" +(new Date().getTime()-t) + " count:"+count)
    },
    //DC:bug metadata n'est pas passé
    endGuiMods: function(){
        console.log("Grid _endGuiMods");
        if (this.list.callBack) {
            this.list.callBack(null, metaData, null);
        }
		this.list._$$body.scrollTop(this._$$vscroller.scrollTop())
    },
    setGuiMods: function(guiMods){
        var self = this;
        for (var k in guiMods) {
            self.setGuimodsByTyp(guiMods[k], k);
        }
    },
    setGuimodsByTyp: function($guimod, $typ){
        if (!X3GuiMod.prototype[$typ]) {
            console.log('Grid._setGuimodsByTyp typ undefined : ' + $typ);
            return;
        }
        var self = this;
        var list = this.list;
        var r, l;
        $guimod.forEach(function(item){
            if (list.$fields[item[0]]) {
				if(!list.$fields[item[0]].$isHidden){
					if (item[1] === 0) { //col
						if ($typ === "tit" || $typ === "stt") {
							if (!self.guimodCol[item[0]]) {
								self.guimodCol[item[0]] = new X3GuiMod();
							}
							self.guimodCol[item[0]][$typ](item[2]);
						}
						if ($typ !== "tit") {
							if (!self.memGuimodCol) {
								self.memGuimodCol = {};
							};
							if (!self.memGuimodCol[item[0]]) {
								self.memGuimodCol[item[0]] = new X3GuiMod();
							};
							self.memGuimodCol[item[0]][$typ](item[2], false);
							Object.keys(list.dataset).forEach(function(val){
								if (!list.dataset[val].guimodCel[item[0]]) {
									list.dataset[val].guimodCel[item[0]] = new X3GuiMod();
								}
								list.dataset[val].guimodCel[item[0]][$typ](item[2], list.dataset[val]._isBuilded());
							});
						}
					}
					else { //cel
						r = list.dataset[parseInt(item[1], 10) - 1];
						if (!r.guimodCel[item[0]]) {
							r.guimodCel[item[0]] = new X3GuiMod();
						};
						r.guimodCel[item[0]][$typ](item[2], self.rows[(parseInt(item[1], 10) - 1)]._isBuilded());
					}
				}
            }
            else {
                if (item[1] === 0) { //tab
                    if (X3GuiMod[$typ]) {
                        self.guimod[$typ](item[2], false);
                    }
                    else {
                        console.log('Grid._setGuimodsByTyp typ undefined : ' + $typ);
                    }
                }
                else { //line
                    l = (parseInt(item[1], 10) - 1);
                    r = self.rows[l];
                    list.$item.$layout.$items.forEach(function($item){
                        if (!r.guimodCel[$item.$bind]) {
                            r.guimodCel[$item.$bind] = new X3GuiMod();
                        };
                        r.guimodCel[$item.$bind][$typ](item[2], self.rows[l]._isBuilded());
                    });
                }
            }
        });
    },
    applyGuiMod: function(){
        var self = this;
		var w=0;
        if (self.guimodCol) {
            for (var key in self.guimodCol) {
                self.guimodCol[key].applyTitle(self.$$titleCells[key][0]) //title col
				if(self.guimodCol[key]._status && self.guimodCol[key]._status.$isHidden){
					w+=self.list.$fields[key].$cellLength;
				};
            };
        };
        var maxRec = Math.min((self.state.fBuild + self.state.cBuild - 1), (this.recordDataCount - 1))
        for (var i = self.state.fBuild; i <= (maxRec); i++) {
			self.rows[i].applyGuiMod();
        };
		this.resizeWidth(w);
        //this.resizeLeftScroll();
    },
    lineCount: function(v){
        this.$lineCount = (v) ? v : 5;
        this.countLineFlow = Math.round(this.$lineCount);
        this.list.$itemsPerPage = this.$lineCount;
    },
    changeLineCount: function(v){
        if (v && !isNaN(v)) {
            this.lineCount(v);
            this.renderLines(this.state.fVisible, false);
            this.resizeBody();
        }
    },
    resizeBody: function(){
        this.list._$$body.height(this.$lineCount * this.size("lineHeight"));
    },
    startResizeCel: function(ev){
        var self = this;
        console.log("_startResizeCel");
        var size = $(ev.target.parentElement).width()
        $(document).bind('mousemove.' + this.id, function(event){
            self.resizingCell(event, ev.target, ev.clientX, size);
        });
        $(document).bind('mouseup.' + this.id, function(event){
            self.stopResizeCell(event, ev.target);
        });
        document.body.style.cursor = "w-resize";
    },
    resizingCell: function(ev, target, pos, sizeI){
        var wMove = ev.clientX - pos;
        var w = Math.max(sizeI + wMove, 14);
        var wm = w - sizeI;
        if ($(target.parentElement).attr("s-frozen")) {
            this.$$titleRowFrozen.width(this.$frozenLength + wm)
        }
        else {
            this.$$titleRowScroll.width(this.$scrollLength + wm)
        }
        this.list._$$header.width(this.$frozenLength + this.$scrollLength + wm)
        this.list.$fields[$(target.parentElement).attr("s-bind")].$cellLength = w
        $(target.parentElement).width(w);
        $(target).css("left", w - (this.size("charWidth")));
    },
    resizeWidth: function(wh){
		this._$$innerhScroller.width(this.sizesline.scroll.minLength+this.sizesline.frozen.minLength -(wh*(this.sizesline.scroll.minLength+this.sizesline.frozen.minLength)/100) + 18);
		this.list._$$header.width((this.sizesline.frozen.length + this.sizesline.scroll.length + wh)+ "%");
		this.list._$$body.width((this.sizesline.frozen.length + this.sizesline.scroll.length + wh)+ "%");
    },
    stopResizeCell: function(ev, target){
        $(document).unbind('mousemove');
        $(document).unbind('mouseup');
        document.body.style.cursor = "";
        this.$frozenLength = this.$$titleRowFrozen.width();
        this.$scrollLength = this.$$titleRowScroll.width();
        this.$$rowsFrozen.width(this.$frozenLength);
        this.$$rowsScroll.width(this.$scrollLength);
        this.resizeWidth(0);
        this.$$rowsScroll.css("left", this.$frozenLength + "px");
        var w = this.list.$fields[$(target.parentElement).attr("s-bind")].$cellLength;
        $('[id="' + $(target.parentElement).attr("s-bind") + '"]').each(function(){
            $(this).width(w);
        });
    },
    getStringXmlData: function(){
        var xAr = [], list = this.list, ordered = this.rowsOrder.slice(0), srt = new X3SortData();
        var Prfx = this.getGridXid().substr(this.getGridXid().length - 1);
        srt.sort(ordered, [{
            "p": "$recordIndex",
            "asc": true,
            "t": "application/x-integer"
        }]);
        var l = Object.keys(ordered[0]).length;
        xAr.push("<ds" + this.getGridXid() + ">\n");
        ordered.forEach(function(record){
            xAr.push('<r I="' + (record.$recordIndex + 1) + '">');
            xAr.push('<' + Prfx + '1>');
            xAr.push(record.$recordIndex + 1);
            xAr.push('</' + Prfx + '1>');
            for (var i = 0; i < l; i++) {
                if (record.dataset[this.getGridXid() + (i + 1)]) {
                    xAr.push('<' + Prfx + (i + 1) + '>');
                    //TODO : Ajouter C_Xn Libelle menu locaux
                    xAr.push(list._getValue(record, this.getGridXid() + (i + 1)));
                    xAr.push('</' + Prfx + (i + 1) + '>');
                }
            }
            xAr.push('</r>\n');
        });
        xAr.push("</ds" + this.getGridXid() + ">");
        return xAr.join("");
    },
    getStringXmlColumnUsage: function($Caller){
        var xAr = [], list = this.list, Prfx = this.getGridXid().substr(this.getGridXid().length - 1);
        xAr.push('<CPH XD1="' + Prfx + '1" NAM="" TYP="6" FMT="N:4#" TDO="4"><![CDATA[]]></CPH>');
        Object.keys(list.$fields).forEach(function(key){
            if (list.$fields[key].$X3) {
                xAr.push('<CPH XD1="' + key.substr(1) + '" ');
                xAr.push('NAM="' + list.$fields[key].$X3.$name + '" ');
                xAr.push('TYP="' + list.$fields[key].$X3.$type + '" ');
                xAr.push('FMT="' + list.$fields[key].$X3.$format + '" ');
                xAr.push('TDO="' + list.$fields[key].$X3.$dataType + '" ');
                xAr.push('TFL="' + list.$fields[key].$X3.$usages[$Caller] + '">');
                xAr.push('<![CDATA[' + list.getLocalizedTitle(list.$fields[key].$title) + ']]>');
                xAr.push('</CPH>');
            }
        });
        return xAr.join('')
    },
    appendRecord: function(record, $recordIndex, isInsert){
        if (isInsert) {
            $recordIndex=-$recordIndex-1;
        }
        if (!record.$uuid) {
            record.$uuid = $recordIndex;
        }
        RawListBuilder.prototype.appendRecord.call(this, record, $recordIndex)
    },
    dispose: function(){
        if (this._$$hscroller) {
            this._$$hscroller.unbind();
            delete this._h$$scroller;
        }
        if (this._$$vscroller) {
            this._$$vscroller.unbind();
            delete this._v$$scroller;
        }
        if (this.id) {
            $(document).unbind("." + this.id);
        }
        RawListBuilder.prototype.dispose.call(this);
    }
});
