"use strict";
var helpers = require('syracuse-core/lib/helpers');
var RawListBuilder = require("syracuse-ui/lib/common/field/collection/rawListBuilder").RawListBuilder;
var X3SortData = require('./x3SortData').X3SortData;
var X3GuiMod = require('./x3GuiMod').X3GuiMod;
var GridRecord = require('./gridRecord').GridRecord;
var sapUtil = require('../../core/client/sap/util').Fusion;
var syraUtil = require('../../core/client/sap/util').Syra;

function GridBuilder(){
}

exports.Builder = helpers.defineClass(GridBuilder, RawListBuilder, {
    initialize: function(){
        this.RecordClass = this.RecordClass || GridRecord;
        this.list.$skin = this.list.$item.$skin || "s-grid";
        this.typeElement = {};
        this.$fusionSkinSuffix = "-fusion";
        this._css = this._initCssClass();
        this.$frozenLength = 0;
        this.$scrollLength = 0;
        this.guimod = new X3GuiMod();
        this.guimodCol = {};
        this.recordDataCount = 0;
        this.recordIndexFocus = null;
        this.rowsOrder = [];
        this.rows = {};
        this.state = {
            'fBuild': 0,
            'cBuild': 0,
            'fVisible': 0,
            'down': true
        };
        this.sizesline = {
            "frozen": {
                "cellsCount": 0,
                "minLength": 0,
                "length": 0
            },
            "scroll": {
                "cellsCount": 0,
                "minLength": 0,
                "length": 0
            }
        };
    },
    _initCssClass: function(){
        var css = {}
        css.nolineFusion = this.makeSkinFusion(this.list.$skin, "-cell") + "-noline";
        this.typeElement[css.nolineFusion] = "noline";
        css.noline = this.list.$skin + "-cell " + css.nolineFusion;
        css.lineFusion = this.makeSkinFusion(this.list.$skin, '-line')
        css.headerFusion = this.makeSkinFusion(this.list.$skin, "-header");
        css.headerCellFusion = this.list.$skin + "-title-cell";
        this.typeElement[css.headerCellFusion] = "cellheader";
        css.cellFusion = this.list.$skin + "-cell";
        this.typeElement[css.cellFusion] = "cell";
        return css
    },
    getGridXid: function(){
        return this.list.$item.$bind;
    },
    emptyDataBody: function(){
        this.$$rowsFrozen.empty();
        this.$$rowsScroll.empty();
        this.rowsOrder = [];
        this.rows = {};
        this.guimod = new X3GuiMod();
        this.guimodCol = {};
        this.recordDataCount = 0
    },
    makeSkinFusion: function(css, suffix){
        if (!suffix) {
            var suffix = "";
        }
        return (css + suffix + this.$fusionSkinSuffix);
    },
    appendSkinFusion: function(css, suffix){
        return (css + " " + this.makeSkinFusion(css, suffix));
    },
    drawBuilder: function(){
        var list = this.list;
        var isNew = true, self = this;
        list.$$item.bind('mouseover', function(event){
            self._mouseOver(event);
        });
        list.$$item.bind('mouseout', function(event){
            self._mouseOut(event);
        });
        
        var $$list = $("<div/>").addClass(self.appendSkinFusion(list.$skin)).hide();
        list._$$header = $("<div/>").appendTo($$list).addClass(self._css.headerFusion); //header
        if (list._body) {
            isNew = false
        }
        if (isNew) {
            list._$$body = $(list._body = document.createElement("div")).appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-content")); //container
            self.$$rowsFrozen = $("<div/>").appendTo(list._$$body).addClass(self.makeSkinFusion(list.$skin, "-frozen"));
            self.$$rowsScroll = $("<div/>").appendTo(list._$$body).addClass(self.makeSkinFusion(list.$skin, "-scroll"));
            self._$$hscroller = $("<div/>").appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-hScroll")); //scroller h
            self._$$vscroller = $("<div/>").appendTo($$list).addClass(self.makeSkinFusion(list.$skin, "-vScroll")); //scroller v
            self._$$vscroller.css("left", 0);
            self._$$innerhScroller = $("<div/>").appendTo(self._$$hscroller).addClass(self.makeSkinFusion(list.$skin, "-innerhScroll"))
            self._$$innerhScroller.html("&nbsp;")
            self._$$innervScroller = $("<div/>").appendTo(self._$$vscroller).addClass(self.makeSkinFusion(list.$skin, "-innervScroll"))
            self._$$innervScroller.html("&nbsp;")
            
            self._$$vscroller.bind('scroll', function(event){
                self.scrollTop(event);
            });
            
            self._$$hscroller.bind('scroll', function(event){
                self.scrollLeft(event);
            });
            list.$$item.attr("id", this.list.id)
        }
        list._listSlot.appendChild($$list[0]);
        
        list.applyDesignMetaData(list.$item, false);
        self.drawOrientation();
        list.appendSelector();
        
        if (!list.$item.$isTitleRowHidden) {
            self.makeTitleRow();
        }
        self.$$rowsFrozen.width(self.sizesline.frozen.length + "%");
        self.$$rowsScroll.width(self.sizesline.scroll.length + "%");
        self.$$rowsFrozen.css("minWidth", self.sizesline.frozen.minLength);
        self.$$rowsScroll.css("minWidth", self.sizesline.scroll.minLength);
        list._$$body.css("minWidth", self.sizesline.scroll.minLength + self.sizesline.frozen.minLength);
        self._$$innerhScroller.width(self.sizesline.scroll.minLength + self.sizesline.frozen.minLength + 18);
        self.resizeWidth(0);
        self.list.appendQuickFilter();
        self._bindSort();
        list.boxParent.getArticle().bind(list, self.getGridXid());
        list._$$body.height(self.$lineCount * self.size("lineHeight"))
        $$list.show();
        //console.log("Width : " + list._$$body.width())
    },
    _bindSort: function(){
        var self = this;
        self.list.$$item.delegate("div[data-s-sort]", "click", function(event){
            self.sortColumn(event.target);
        });
    },
    _mouseOver: function(ev){
        this._$$hscroller.css("overflow-x", "auto");
        var t = this.list._core.offsetTop + this.list._$$header.height();
        this._$$vscroller.css("top", t);
        this._$$vscroller.css("left", this.list._$$body.parent().width() - this._$$vscroller.width());
        this._$$vscroller.height(this.list._$$body.height());
        this._$$vscroller.css("overflow-y", "auto");
    },
    _mouseOut: function(ev){
        this._$$vscroller.css("left", 0);
        this._$$hscroller.css("overflow-x", "hidden");
        this._$$vscroller.css("overflow-y", "hidden");
    },
    onClick: function(ctrl, ev){
        //TODO : cellFusion nolineFusion headerCellFusion
        console.log("gridBuilder onClick headerCell:" + this._isHeaderCell($(ev.target)) + " Cell:" + this._isCell($(ev.target)) + " Noline:" + this._isNoLine($(ev.target)));
        var l = $(ev.target).parents("." + this._css.lineFusion);
        if (l != undefined && l.length > 0) {
            var noreq = parseInt(l.data('s-record'), 10);
            return this.rows[noreq].onClick(ctrl, ev.target);
        };
        return false;
    },
    _isHeaderCell: function($$elt){
        return this._isElementGrid($$elt, this._css.headerCellFusion);
    },
    _isCell: function($$elt){
        return this._isElementGrid($$elt, this._css.cellFusion);
    },
    _isNoLine: function($$elt){
        return this._isElementGrid($$elt, this._css.nolineFusion);
    },
    _isElementGrid: function($$elt, type){
        if (!$$elt.hasClass(type)) {
            return ($$elt.parents("." + type).length !== 0)
        }
        return true;
    },
    _hasFocus: function(){
        return (this.recordIndexFocus != null);
    },
    _isTableEditing: function(){
        if (!this._hasFocus()) {
            return false
        };
        var r = this.rows[this.recordIndexFocus];
        var c = r.getCurrentField();
        return (c != null) ? c.$isEditMode : null;
    },
    _getTypeElement: function($$elt, css){
        return ($$elt.hasClass(css)) ? this.typeElement[css] : this.typeElement[($$elt.parents("." + css).length !== 0) ? css : undefined];
    },
    endBinding: function($isDelta){
        this.list.dataLoaded = true;
        if (this.list.callBack) {
            this.list.callBack($isDelta, null, this.list.dataset);
        }
        //console.log("gridBuilder.endBinding");
        this.list._$$body.scrollTop(this._$$vscroller.scrollTop())
    },
    reSynch: function(record){
        if (!record.$range) 
            return;
        var self = this;
        var list = self.list;
        var del = (record.$range[0] === sapUtil.dataSetMvt.del);
        var insrt = (record.$range[0] === sapUtil.dataSetMvt.insrt);
        var start = record.$range[1];
        var count = record.$range[2];
        if (start <= self.state.fBuild + self.state.cBuild) {
            if (del) {
                self.state.cBuild -= count;
            }
        }
        Object.keys(list.dataset).forEach(function(val){
            if (list.dataset[val].$recordIndex >= start) {
                if (del) {
                    list.dataset[val]._refresh(list.dataset[val].$recordIndex - count, insrt, del);
                }
                else {
                    list.dataset[val]._refresh(list.dataset[val].$recordIndex + count, insrt, del);
                }
            }
            else {
                if (list.dataset[val].$recordIndex < 0) {
                    list.dataset[val]._refresh(Math.abs(list.dataset[val].$recordIndex) - 1 + start, insrt, del);
                }
            }
        });
        if (del) {
            var l = this.rowsOrder.length
            for (var i = l - 1; i >= 0; i--) {
                if (!this.rowsOrder[i]) 
                    this.rowsOrder.splice(i, 1);
            }
        }
    },
    toBuild: function(index){
        var r = (index <= this.state.fVisible + this.$lineCount + this.countLineFlow - 1 && index >= this.state.fBuild);
        return r;
    },
    recordAdded: function(record){
        this.rows[record.$recordIndex] = record;
        if (record.$recordIndex >= 0) {
            this.rowsOrder[record.$recordIndex] = record;
        }
        this.recordDataCount++;
    },
    recordRemoved: function(record){
        delete (this.rows[record.$recordIndex]);
        //this.rowsOrder.splice(record.$recordIndex, 1);
        this.rowsOrder[record.$recordIndex] = null;
        this.recordDataCount--;
    },
    drawOrientation: function(){
        var $item = this.list.$item;
        if ($item.$alternateStyle) {
            this.$alternateStyle = this.list.$skin + "-alt";
        }
        this.$columnsCount = $item.$layout.$items.length;
        if ($item.$preView) {
            this.$columnsCount++;
        }
        if (this.recordSelector && this.recordSelector.appendToRecord) {
            this.$columnsCount++;
        }
    },
    makeTitleRow: function(){
        var self = this;
        var list = self.list;
        var o = {};
        var css = self._css.headerCellFusion;
        var isNew;
        if (self.$$titleRow) {
            self.$$titleRow.empty();
        }
        else {
            isNew = true;
            self.$$titleRowFrozen = $("<div/>").addClass(self.makeSkinFusion(css + "s-frozen"));
            self.$$titleRowScroll = $("<div/>").addClass(self.makeSkinFusion(css + "s-scroll"));
        }
        /*
         
         if (this.recordSelector) {
         self.$$titleRow.append($("<th/>").addClass(css + " " + list.$skin + this.recordSelector.css).append(this.recordSelector.title));
         }*/
        self.$$titleCells = {};
        var cssLink = list.$skin + "-title-link-fusion";
        var l = self._computeWidth();
        if (!self.$fieldnl.$isHidden) {
            self.makeTitleColumn(self.$fieldnl, list.$itemnl, cssLink, css);
            list.$fields[self.getGridXid() + "_NL"] = self.$fieldnl;
        }
        list.parseItems(function($item, $field){
            self.makeTitleColumn($field, $item, cssLink, css);
        });
        if (isNew) {
            //self.$$titleRowFrozen.css("minWidth", l.frozen.minLength);
            //self.$$titleRowScroll.css("minWidth", l.scroll.minLength);
            self.$$titleRowFrozen.width(l.frozen.length + "%");
            self.$$titleRowScroll.width(l.scroll.length + "%");
            list._$$header.css("minWidth", l.frozen.minLength + l.scroll.minLength);
            list._$$header.width("100%");
            list._$$header.append(self.$$titleRowFrozen).append(self.$$titleRowScroll);
        }
    },
    makeTitleColumn: function($field, $item, cssLink, css){
        if ($field && !$field.$isHidden) {
            var self = this;
            //var $$title = $field.$capability.sort ? $("<a/>").attr("data-s-sort", $item.$bind).addClass(cssLink).attr("unselectable", "on") : $("<div/>").addClass(cssLink).attr("unselectable", "on");
            var $$title = $("<div/>").attr("unselectable", "on");
            if (!$field.$isNoline) {
                $$title.attr("data-s-sort", $item.$bind).addClass(cssLink)
            }
            else {
                $$title.addClass("s-grid-title-nl-fusion")
            };
            ($field.$title == "") ? $$title.html("&nbsp;") : $$title.text($field.$title);
            var $$cell = $("<div/>").addClass(self.appendSkinFusion(css, "-header")).attr("s-bind", $item.$bind)
            var $$resize = $("<span/>").addClass(self.list.$skin + "-cell-resize-fusion").attr("unselectable", "on");
            $$cell.append($$title);
            $$cell.append($$resize);
            $$resize.bind('mousedown', function(event){
                self.startResizeCel(event);
            });
            $$cell.width($field.$cellLength + "%");
            //$$cell.css("minWidth", $field.$cellMinLength);
            $$resize.width(self.size("charWidth"))
            $$resize.css("left", self._leftResizeHandPos($field));
            if ($field.$capability.frozen) {
                $$cell.attr("s-frozen", true)
                self.$$titleRowFrozen.append(self.$$titleCells[$item.$bind] = $$cell);
            }
            else {
                self.$$titleRowScroll.append(self.$$titleCells[$item.$bind] = $$cell);
            }
        }
    },
    _leftResizeHandPos: function($field){
        return (($field.$cellMinLength - (this.size("charWidth") / 2)) / $field.$cellMinLength * 100) + "%";
    },
    _computeWidth: function(){
        var self = this, line = this.sizesline;
        self._computeMinWidth(self.$fieldnl, self.list.$itemnl);
        self.list.$item.$layout.$items.forEach(function($item){
            var $field = self.list.$fields[$item.$bind];
            self._computeMinWidth($field, $item);
        });
        line.frozen.length = line.frozen.minLength * 100 / (line.frozen.minLength + line.scroll.minLength);
        line.scroll.length = 100 - line.frozen.length;
        self._computePWidth(self.$fieldnl, self.list.$itemnl);
        self.list.$item.$layout.$items.forEach(function($item){
            var $field = self.list.$fields[$item.$bind];
            self._computePWidth($field, $item);
        });
        return line;
    },
    _computeMinWidth: function($field, $item){
        var line = this.sizesline;
        if ($field && !$field.$isHidden) {
            $field.$title = ($field.$title ? this.list.getLocalizedTitle($field.$title) : "");
            $field.$constraints = ($field.$constraints) ? $field.$constraints : {};
            $field.$constraints.$maxLength = ($field.$constraints.$maxLength >= 3) ? $field.$constraints.$maxLength : 3;
            $field.$constraints.$showLength = ($field.$constraints.$showLength) ? $field.$constraints.$showLength : $field.$constraints.$maxLength;
            $field.$cellMinLength = Math.max($field.$constraints.$showLength, 3) * this.size("charWidth");
            var tl = line.frozen;
            if (!$field.$capability.frozen) {
                tl = line.scroll;
            }
            tl.minLength += $field.$cellMinLength + 1;
            tl.cellsCount++;
        }
    },
    _computePWidth: function($field, $item){
        var line = this.sizesline;
        if ($field && !$field.$isHidden) {
            var tl = line.frozen;
            if (!$field.$capability.frozen) {
                tl = line.scroll;
            }
            $field.$cellLength = $field.$cellMinLength * 100 / (tl.minLength);
        }
    },
    _isLineVisible: function(noLine){
        return (noLine >= (this.state.fVisible + 1) && noLine <= this.state.fVisible + this.$lineCount);
    },
    setCellVisible: function(xid, noLine){
        this.setLineVisible(noLine);
        this._cellVisible(xid);
    },
    _cellVisible: function(xid){
        var list = this.list, $field = list.$fields[xid], pos = 0;
        if ($field.$capability.frozen) 
            return null;
        this._scrollCellToVisible(xid);
    },
    _scrollCellToVisible: function(xid){
        var a = this._$$hscroller[0].clientWidth; // visible width;
        var b = this.$$rowsFrozen.width(); // Frozen width;
        var c = parseInt(this.$$rowsScroll.css("marginLeft"), 10); // Scroll width
        var d = this.$$titleCells[xid].position().left; // pos cell
        var d2 = this.$$titleCells[xid].width(); // Size cell
        /*var trace={};trace.xid=xid;trace.visibleWidth=a;trace.frozenWidth=b;trace.scrollWidth=c;trace.posCell=d;trace.sizeCell=d2;trace.scroll=0;*/
        if (d + c < 0) {
            this._$$hscroller.scrollLeft(d);
            //trace.scroll=d;trace.type="1";
        }
        else {
            if ((d + d2 + c) - (a - b) > 0) {
                this._$$hscroller.scrollLeft(d - a + b + d2 + 20);
                //trace.scroll=d-a+b+d2+20;trace.type="2"
            }
        }
        //console.log("gridBuilder._scrollCellToVisible :" + JSON.stringify(trace))
    },
    setLineVisible: function(noLine){
        if (!this._isLineVisible(noLine)) {
            var i = Math.max((noLine - 1) - Math.round(this.$lineCount / 2), 0);
            //this.list._$$body.scrollTop(i * this.list.$lineHeight);
            this._$$vscroller.scrollTop(i * this.list.$lineHeight);
        }
    },
    sort: function(){
        if (!this.sortCriter || this.sortCriter.length == 0) {
            this.resetSort();
            return;
        }
        var srt = new X3SortData(), self = this;
        this.sortCriter.forEach(function(crit){
            crit.t = self.list.$field.$item.$[crit.p].$type;
        })
        srt.sort(self.rowsOrder, this.sortCriter, "dataset")
        self.redrawRows()
    },
    sortColumn: function(item){
        var id = $(item).data('s-sort'), asc = null;
        if (!this.sortCriter) {
            this.sortCriter = []
        }
        if ($(item).hasClass("s-grid-sort-asc")) {
            $(item).removeClass("s-grid-sort-asc");
            $(item).addClass("s-grid-sort-desc");
            asc = false
        }
        else 
            if ($(item).hasClass("s-grid-sort-desc")) {
                $(item).removeClass("s-grid-sort-desc");
            }
            else {
                $(item).addClass("s-grid-sort-asc");
                this.sortCriter.push({
                    'p': id
                });
                asc = true;
            }
        var remove = undefined;
        this.sortCriter.forEach(function(cr, i){
            if (cr.p == id) {
                if (asc == null) {
                    remove = i
                }
                else {
                    cr.asc = asc;
                }
            }
        })
        if (remove != undefined) {
            this.sortCriter.splice(remove, 1);
        }
        this.sort()
    },
    resetSort: function(){
        this.sortCriter = []
        var srt = new X3SortData()
        srt.sort(this.rowsOrder, [{
            "p": "$recordIndex",
            "asc": true,
            "t": "application/x-integer"
        }])
        this.redrawRows();
    },
    renderLines: function(newVisible, clear){
        this.scroll = null;
        this.state.down = (newVisible > this.state.fVisible);
        this.state.fVisible = newVisible;
        var start = (this.state.down) ? (Math.max(0, this.state.fVisible - this.countLineFlow)) : (Math.max(0, this.state.fVisible - this.countLineFlow))
        var end = (this.state.down) ? (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow)) : (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow))
        this.state.fBuild = start;
        clear = false
        this.cleanRows(clear);
        this.addRows(start, end)
    },
    appendNoRecordRow: function(){
        $("<tr/>").append($("<td/>").attr("colspan", this.$columnsCount).append(this.list.appendEmptyInfo())).appendTo(this.list._$$body);
    },
    onRedrawCore: function(){
        this.drawOrientation();
        if (!this.list.$item.$isTitleRowHidden) {
            this.makeTitleRow();
        }
        if (this.list.quickFilterBox) {
            this.list.quickFilterBox.drawBox();
        }
    },
    resizeRowsContainer: function(){
        this.$$rowsFrozen.height(this.recordDataCount * this.size("lineHeight"));
        this.$$rowsScroll.height(this.recordDataCount * this.size("lineHeight"));
        this._$$innervScroller.height(this.recordDataCount * this.size("lineHeight"));
    },
    size: function(t){
        if (!this.list.$lineHeight || !this.$charWidth) {
            var $$t = $("<div/>").appendTo(document.body);
            $$t.attr('class', this._css.lineFusion);
            $$t.html("A");
            $$t.show();
            this.list.$lineHeight = $$t.height();
            this.$charWidth = $$t.width();
            $$t.remove();
        };
        if (t === "lineHeight") 
            return this.list.$lineHeight;
        if (t === "charWidth") 
            return this.$charWidth;
    },
    scrollTop: function(ev){
        var self = this;
        var t = 0;
        self.list._$$body.scrollTop(ev.target.scrollTop);
        var newVisible = Math.floor(ev.target.scrollTop / this.size("lineHeight")), clear = (Math.abs(newVisible - this.state.fVisible) > (this.$lineCount + this.countLineFlow));
        if (newVisible == this.state.fVisible) {
            if (self.scroll) {
                clearTimeout(self.scroll);
                self.scroll = null
            }
            return;
        }
        if (self.scroll) {
            clearTimeout(self.scroll);
            self.scroll = null;
            t = 30
        }
        self.scroll = setTimeout((function(o, n, c){
            return function(){
                self.renderLines(n, c)
            }
        })(this.list, newVisible, clear), t)
    },
    scrollLeft: function(ev){
        this.$$rowsScroll.css('marginLeft', (-ev.target.scrollLeft) + 'px');
        this.$$titleRowScroll.css("marginLeft", (-ev.target.scrollLeft) + 'px');
    },
    addRows: function(start, end){
        var count = 0
        var t = new Date().getTime();
        for (var i = start; i < end; i++) {
            if (this.scroll) 
                return;
            if (!this.rowsOrder[i]._isBuilded()) {
                count++;
                this.rowsOrder[i].drawBox(i);
            }
        }
        //console.log("_addRows form:" + start +" to:"+(end-1) + " t:" +(new Date().getTime()-t) + " count:"+count)
    },
    redrawRows: function(){
        var c = this.state.cBuild + this.state.fBuild
        this.cleanRows(true);
        this.addRows(this.state.fBuild, c)
    },
    cleanRows: function(all){
        if (all) {
            this._clearRows();
        }
        else {
            this.removeRows()
        }
    },
    _clearRows: function(){
        this.rowsOrder.forEach(function(row){
            if (row._isBuilded()) {
                row._removeLineRow();
            }
        });
    },
    removeRows: function(){
        var count = 0
        var t = new Date().getTime()
        var s = (this.state.down) ? (0) : (Math.min(this.recordDataCount, this.state.fVisible + this.$lineCount + this.countLineFlow));
        //var e = (this.state.down) ? (this.state.fBuild) : (this.recordDataCount), idx;
        var e = Math.min(this.rowsOrder.length, (this.state.down) ? (this.state.fBuild) : (this.recordDataCount)), idx;
        for (var i = s; i < e; i++) {
            //if(this.scroll) return
            count++
            if (this.rowsOrder[i]._isBuilded()) {
                this.rowsOrder[i]._removeLineRow();
            }
        }
        //console.log("_removeRows form:" + s +" to:"+(e-1) + " t:" +(new Date().getTime()-t) + " count:"+count)
    },
    //DC:bug metadata n'est pas passé
    endGuiMods: function(){
        console.log("Grid _endGuiMods");
        if (this.list.callBack) {
            this.list.callBack(null, metaData, null);
        }
        this.list._$$body.scrollTop(this._$$vscroller.scrollTop())
    },
    setGuiMods: function(guiMods){
        var self = this;
        for (var k in guiMods) {
            self.setGuimodsByTyp(guiMods[k], k);
        }
    },
    setGuimodsByTyp: function($guimod, $typ){
        if (!X3GuiMod.prototype[$typ]) {
            console.log('Grid._setGuimodsByTyp typ undefined : ' + $typ);
            return;
        }
        var self = this;
        var list = this.list;
        var r, l;
        $guimod.forEach(function(item){
            if (list.$fields[item[0]]) {
                if (!list.$fields[item[0]].$isHidden) {
                    if (item[1] === 0) { //col
                        if ($typ === "tit" || $typ === "stt") {
                            if (!self.guimodCol[item[0]]) {
                                self.guimodCol[item[0]] = new X3GuiMod();
                            }
                            self.guimodCol[item[0]][$typ](item[2]);
                        }
                        if ($typ !== "tit") {
                            if (!self.memGuimodCol) {
                                self.memGuimodCol = {};
                            };
                            if (!self.memGuimodCol[item[0]]) {
                                self.memGuimodCol[item[0]] = new X3GuiMod();
                            };
                            self.memGuimodCol[item[0]][$typ](item[2], false);
                            Object.keys(list.dataset).forEach(function(val){
                                if (!list.dataset[val].guimodCel[item[0]]) {
                                    list.dataset[val].guimodCel[item[0]] = new X3GuiMod();
                                }
                                list.dataset[val].guimodCel[item[0]][$typ](item[2], list.dataset[val]._isBuilded());
                            });
                        }
                    }
                    else { //cel
                        r = self.rows[parseInt(item[1], 10) - 1];
                        if (!r.guimodCel[item[0]]) {
                            r.guimodCel[item[0]] = new X3GuiMod();
                        };
                        r.guimodCel[item[0]][$typ](item[2], self.rows[(parseInt(item[1], 10) - 1)]._isBuilded());
                    }
                }
            }
            else {
                if (item[1] === 0) { //tab
                    if (X3GuiMod[$typ]) {
                        self.guimod[$typ](item[2], false);
                    }
                    else {
                        console.log('Grid._setGuimodsByTyp typ undefined : ' + $typ);
                    }
                }
                else { //line
                    l = (parseInt(item[1], 10) - 1);
                    r = self.rows[l];
                    list.$item.$layout.$items.forEach(function($item){
                        if (!r.guimodCel[$item.$bind]) {
                            r.guimodCel[$item.$bind] = new X3GuiMod();
                        };
                        r.guimodCel[$item.$bind][$typ](item[2], self.rows[l]._isBuilded());
                    });
                }
            }
        });
    },
    applyGuiMod: function(){
        var self = this;
        var w = 0;
        if (self.guimodCol) {
            for (var key in self.guimodCol) {
                self.guimodCol[key].applyTitle(self.$$titleCells[key][0]) //title col
                if (self.guimodCol[key]._status && self.guimodCol[key]._status.$isHidden) {
                    w += self.list.$fields[key].$cellLength;
                };
                            };
                    };
        var maxRec = Math.min((self.state.fBuild + self.state.cBuild - 1), (this.recordDataCount - 1))
        for (var i = self.state.fBuild; i <= (maxRec); i++) {
            self.rows[i].applyGuiMod();
        };
        this.resizeWidth(w);
        //this.resizeLeftScroll();
    },
    lineCount: function(v){
        this.$lineCount = (v) ? v : 5;
        this.countLineFlow = Math.round(this.$lineCount);
        this.list.$itemsPerPage = this.$lineCount;
    },
    changeLineCount: function(v){
        if (v && !isNaN(v)) {
            this.lineCount(v);
            this.renderLines(this.state.fVisible, false);
            this.resizeBody();
        }
    },
    resizeBody: function(){
        this.list._$$body.height(this.$lineCount * this.size("lineHeight"));
    },
    startResizeCel: function(ev){
        return;
        var self = this;
        var size = $(ev.target.parentElement).width();
        var sig = 0;
        self.$$titleRowFrozen.children().each(function(){
            sig += $(this).width() + 1;
            $(this).width($(this).width());
        });
        self.$$titleRowFrozen.width(sig);
        sig = 0;
        self.$$titleRowScroll.children().each(function(){
            sig += $(this).width() + 1;
            $(this).width($(this).width());
        });
        self.$$titleRowScroll.width(sig);
        
        self.list._$$header.width(self.$$titleRowFrozen.width() + self.$$titleRowScroll.width())
        self.$frozenLength = self.$$titleRowFrozen.width();
        self.$scrollLength = self.$$titleRowScroll.width();
        $(document).bind('mousemove.' + this.id, function(event){
            self.resizingCell(event, ev.target, ev.clientX, size);
        });
        $(document).bind('mouseup.' + this.id, function(event){
            self.stopResizeCell(event, ev.target);
        });
        document.body.style.cursor = "w-resize";
    },
    resizingCell: function(ev, target, pos, sizeI){
        var wMove = ev.clientX - pos;
        var w = Math.max(sizeI + wMove, 14);
        console.log(" resizingCell  pos:" + pos + " sizeI:" + sizeI + "Move:" + wMove + "w:" + w)
        var wm = w - sizeI;
        if ($(target.parentElement).attr("s-frozen")) {
            this.$$titleRowFrozen.width(this.$frozenLength + wm)
            //this.$$titleRowFrozen.width(this.$$titleRowFrozen.width() + w)
        }
        else {
            this.$$titleRowScroll.width(this.$scrollLength + wm)
            //this.$$titleRowScroll.width(this.$$titleRowScroll.width() + w)
        }
        this.list._$$header.width(this.$frozenLength + this.$scrollLength + wm)
        //this.list._$$header.width(this.$$titleRowFrozen.width()+ this.$$titleRowScroll.width())
        this.list.$fields[$(target.parentElement).attr("s-bind")].$cellLength = w
        $(target.parentElement).width(w);
        $(target).css("left", w - (this.size("charWidth")));
    },
    resizeWidth: function(wh){
        this._$$innerhScroller.width(this.sizesline.scroll.minLength + this.sizesline.frozen.minLength - (wh * (this.sizesline.scroll.minLength + this.sizesline.frozen.minLength) / 100) + 18);
        this.list._$$header.width((this.sizesline.frozen.length + this.sizesline.scroll.length + wh) + "%");
        this.list._$$body.width((this.sizesline.frozen.length + this.sizesline.scroll.length + wh) + "%");
    },
    stopResizeCell: function(ev, target){
        $(document).unbind('mousemove');
        $(document).unbind('mouseup');
        document.body.style.cursor = "";
        var w = this.$$titleRowFrozen.width() + this.sizesline.frozen.cellsCount;
        this.$$titleRowFrozen.children().each(function(){
            $(this).width(($(this).width() * 100 / w) + "%");
        });
        w = this.$$titleRowScroll.width() + this.sizesline.scroll.cellsCount;
        ;
        this.$$titleRowScroll.children().each(function(){
            $(this).width(($(this).width() * 100 / w) + "%");
        });
        var line = this.sizesline;
        line.frozen.length = this.$$titleRowFrozen.width() * 100 / (this.$$titleRowFrozen.width() + this.$$titleRowScroll.width());
        line.scroll.length = 100 - line.frozen.length;
        this.$$titleRowFrozen.width(line.frozen.length + "%");
        this.$$titleRowScroll.width(line.scroll.length + "%");
        w = this.$$titleRowFrozen.width() + this.$$titleRowScroll.width();
        var c = this.list._$$body.parent().width();
        this.list._$$body.width((w * 100 / c) + "%");
        this.list._$$header.width((w * 100 / c) + "%");
        //this.resizeWidth(0);
        this.$$rowsScroll.css("left", this.$frozenLength + "px");
        w = this.list.$fields[$(target.parentElement).attr("s-bind")].$cellLength;
        return;
        $('[data-s-xid="' + $(target.parentElement).attr("s-bind") + '"]').each(function(){
            $(this).width(w);
        });
    },
    getStringXmlData: function(){
        var xAr = [], list = this.list, ordered = this.rowsOrder.slice(0), srt = new X3SortData();
        var Prfx = this.getGridXid().substr(this.getGridXid().length - 1);
        srt.sort(ordered, [{
            "p": "$recordIndex",
            "asc": true,
            "t": "application/x-integer"
        }]);
        var l = Object.keys(ordered[0]).length;
        xAr.push("<ds" + this.getGridXid() + ">\n");
        ordered.forEach(function(record){
            xAr.push('<r I="' + (record.$recordIndex + 1) + '">');
            xAr.push('<' + Prfx + '1>');
            xAr.push(record.$recordIndex + 1);
            xAr.push('</' + Prfx + '1>');
            for (var i = 0; i < l; i++) {
                if (record.dataset[this.getGridXid() + (i + 1)]) {
                    xAr.push('<' + Prfx + (i + 1) + '>');
                    //TODO : Ajouter C_Xn Libelle menu locaux
                    xAr.push(list._getValue(record, this.getGridXid() + (i + 1)));
                    xAr.push('</' + Prfx + (i + 1) + '>');
                }
            }
            xAr.push('</r>\n');
        });
        xAr.push("</ds" + this.getGridXid() + ">");
        return xAr.join("");
    },
    getStringXmlColumnUsage: function($Caller){
        var xAr = [], list = this.list, Prfx = this.getGridXid().substr(this.getGridXid().length - 1);
        xAr.push('<CPH XD1="' + Prfx + '1" NAM="" TYP="6" FMT="N:4#" TDO="4"><![CDATA[]]></CPH>');
        Object.keys(list.$fields).forEach(function(key){
            if (list.$fields[key].$X3) {
                xAr.push('<CPH XD1="' + key.substr(1) + '" ');
                xAr.push('NAM="' + list.$fields[key].$X3.$name + '" ');
                xAr.push('TYP="' + list.$fields[key].$X3.$type + '" ');
                xAr.push('FMT="' + list.$fields[key].$X3.$format + '" ');
                xAr.push('TDO="' + list.$fields[key].$X3.$dataType + '" ');
                xAr.push('TFL="' + list.$fields[key].$X3.$usages[$Caller] + '">');
                xAr.push('<![CDATA[' + list.$fields[key].$title + ']]>');
                xAr.push('</CPH>');
            }
        });
        return xAr.join('')
    },
    appendRecord: function(options){
        if (options.isInsert) {
            options.$recordIndex = -options.$recordIndex - 1;
        }
        if (!options.record.$uuid) {
            options.record.$uuid = options.$recordIndex;
        }
        return RawListBuilder.prototype.appendRecord.call(this, options)
    },
    dispose: function(){
        if (this._$$hscroller) {
            this._$$hscroller.unbind();
            delete this._$$hscroller;
        }
        if (this._$$vscroller) {
            this._$$vscroller.unbind();
            delete this._$$vscroller;
        }
        if (this.id) {
            $(document).unbind("." + this.id);
        }
        if (this.list) {
            delete (this.list.$fusionPageMeta);
        }
        RawListBuilder.prototype.dispose.call(this);
        
    }
});
