"use strict";
var helpers = require('syracuse-core/lib/helpers');
var Article = require("syracuse-ui/lib/desktop/article/article").Article;
var syraUtil = require('../../core/client/sap/util').Syra;
var fusionUtil = require('../../core/client/sap/util').Fusion;
var X3GuiMod = require('./x3GuiMod').X3GuiMod;

function GridRecord(){
}

exports.GridRecord = helpers.defineClass(GridRecord, Article, {
    initializeRecord: function(options){
        this.guimodCel = {};
        if (this.$recordIndex < 0 && this.builder.memGuimodCol) {
            this.guimodCel = this.builder.memGuimodCol;
        }
        this.current = null;
        options.$item = {
            $layout: {
                $items: this.list.$item.$layout.$items
            }
        };
        this.list.builder.recordAdded(this);
    },
    dispose: function(){
        delete this.list
        delete this.builder;
        if (this._contextMenu) {
            document.controller.disposeObject(this._contextMenu);
            delete this._contextMenu;
        }
        Article.prototype.dispose.call(this);
    },
    applyMetaData: function(metaData){
    },
    remove: function(){
        this._removeLineRow();
        this.boxParent.builder.recordRemoved(this);
    },
    _removeLineRow: function(){
        if (!this._isBuilded()) 
            return null;
        this.boxParent.builder.state.cBuild--;
        this.$$dataRowFrozen.empty().remove();
        this.$$dataRowScroll.empty().remove();
        delete (this.$$dataRowFrozen);
        delete (this.$$dataRowScroll);
    },
    _refresh: function(recordIndex, insert, del){
        var top;
        var listBuilder = this.boxParent.builder;
        var newRec = (this.$recordIndex < 0);
        listBuilder.rows[recordIndex] = this;
        if (newRec) {
            delete (listBuilder.rows[this.$recordIndex]);
            listBuilder.rowsOrder.splice(recordIndex, 0, this);
        }
        this.$recordIndex = recordIndex
        if (this._isBuilded()) {
            top = (this.$recordIndex * listBuilder.size("lineHeight")) + "px";
            this.$$noline[0].firstChild.textContent = (this.$recordIndex + 1);
            this.$$dataRowFrozen.attr('style', 'top:' + top + ';width:100%');
            this.$$dataRowFrozen.attr("data-s-record", this.$recordIndex);
            this.$$dataRowScroll.attr('style', 'top:' + top + ';width:100%');
            this.$$dataRowScroll.attr("data-s-record", this.$recordIndex);
        }
        else {
            this.drawBox();
        }
    },
    drawBox: function(position){
        var self = this, list = self.boxParent;
        var listBuilder = list.builder;
        if (self._isBuilded()) 
            return;
        if (!listBuilder.toBuild(((position != undefined) ? position : self.$recordIndex))) 
            return;
        listBuilder.state.cBuild++
        self.$$dataRowFrozen = $("<div/>").attr("data-s-record", self.$recordIndex);
        self.$$dataRowFrozen.addClass(listBuilder._css.lineFusion)
        self.$$dataRowScroll = $("<div/>").attr("data-s-record", self.$recordIndex);
        self.$$dataRowScroll.addClass(listBuilder._css.lineFusion)
        if (listBuilder.$alternateStyle && ((position != undefined) ? position : self.$recordIndex % 2)) {
            self.$$dataRowFrozen.addClass(list.$skin + "-alt");
            self.$$dataRowScroll.addClass(list.$skin + "-alt");
        }
        var css = listBuilder.appendSkinFusion(listBuilder._css.cellFusion, null);
        /*
         
         if (listBuilder.recordSelector) {
         self.$$dataRow.append($("<td/>").addClass(css).addClass(list.$skin + listBuilder.recordSelector.css).append(self.$$selector = $(listBuilder.recordSelector.record)));
         }
         */
        if (!listBuilder.$fieldnl.$isHidden) {
            var c = self._buildCel(listBuilder.$fieldnl, list.$itemnl, self.boxParent.builder._css.noline);
            if (listBuilder.$fieldnl.$capability.frozen) {
                this.$$dataRowFrozen[0].appendChild(c);
            }
            else {
                this.$$dataRowScroll[0].appendChild(c);
            };
            self.$$noline = $(c);
            self.$$noline.html('<div class="s-inplace-value s-inplace-value' + listBuilder.$fusionSkinSuffix + '">' + (this.$recordIndex + 1) + '</div>');
        }
        list.parseItems(function($item, $field){
            self._drawCel($field, $item, css);
        });
        
        self.$$dataRowFrozen.css("minWidth", list.builder.sizesline.frozen.minLength + "px")
        self.addHtmlRow(((position != undefined) ? position : self.$recordIndex));
        if (self.current) {
            //self._setInterfaceCurrentCell()
        };
            //self.$$menuRow = $("<tr/>").appendTo(list._$$body);
        //list.appendRecordMenu($("<td/>").addClass(self.boxParent.$skin + "-menu-row").attr("colspan", self.boxParent.builder.$columnsCount).appendTo(self.$$menuRow), this);
    },
    _drawCel: function($field, $item, css){
        if ($field) {
            if (!this.boundFields[$item.$bind]) {
                var c = this._buildCel($field, $item, css);
                this._drawInnerCel(c, $item, null, false);
            }
            else {
                var c = this.boundFields[$item.$bind][0].$$item[0]
            }
            if ($field.$capability.frozen) {
                this.$$dataRowFrozen[0].appendChild(c);
            }
            else {
                this.$$dataRowScroll[0].appendChild(c);
            };
                    }
    },
    _buildCel: function($field, $item, css){
        var c = document.createElement("div");
        c.id = $item.$bind;
        $(c).attr("data-s-xid", $item.$bind)
        c.className = css;
        var g = this.guimodCel[$item.$bind];
        if ($field.$isReadOnly) {
            if (!g) {
                this.guimodCel[$item.$bind] = new X3GuiMod();
            };
            if (!this.guimodCel[$item.$bind]._status) {
                this.guimodCel[$item.$bind]._status = {}
            }
            this.guimodCel[$item.$bind]._status.$isReadOnlyStatic = true;
            g = this.guimodCel[$item.$bind];
        };
        if ($field.$isDisabled) {
            if (!g) {
                this.guimodCel[$item.$bind] = new X3GuiMod();
            };
            if (!this.guimodCel[$item.$bind]._status) {
                this.guimodCel[$item.$bind]._status = {}
            }
            this.guimodCel[$item.$bind]._status.$isDisabled = true;
            g = this.guimodCel[$item.$bind];
        };
        if (g) {
            g.apply(c);
        };
        //c.style.minWidth = $field.$cellMinLength + "px";
        c.style.width = $field.$cellLength + "%";
        return c;
    },
    _drawInnerCel: function(c, $item, initData, edit){
        $(c).empty();
        return document.itemFactory.load($(c), {
            $bind: $item.$bind,
            $isCellChild: true,
            $inplace: true,
            $isEditMode: edit
        }, this, initData);
    },
    _isBuilded: function(){
        if (this.$$dataRowFrozen) 
            return true;
        return false;
    },
    addHtmlRow: function(position){
        var listBuilder = this.boxParent.builder, top = (position * listBuilder.size("lineHeight")) + "px";
        this.$$dataRowFrozen.attr('style', 'top:' + top + ';width:100%');
        this.$$dataRowScroll.attr('style', 'top:' + top + ';width:100%');
        this.$$dataRowFrozen.appendTo(listBuilder.$$rowsFrozen);
        this.$$dataRowScroll.appendTo(listBuilder.$$rowsScroll);
    },
    highlightSelection: function(selected){
        this.$$dataRow.toggleClass("s-list-record-selected", selected);
        this.$$menuRow.toggleClass("s-list-record-selected", selected);
        if (this.$$selector && this.$$selector.is("input")) {
            this.$$selector.attr('checked', selected);
        }
    },
    applyChange: function(record){
        Article.prototype.applyChange.call(this, record);
    },
    applyGuiMod: function(){
        var c;
        for (var k in this.guimodCel) {
            c = this.$$dataRowFrozen[0].querySelector("#" + k)
            if (c == null) {
                c = this.$$dataRowScroll[0].querySelector("#" + k)
            }
            if (c != null) {
                this.guimodCel[k].apply(c);
            }
        }
    },
    getSiteController: function(){
        return syraUtil.getFusionController(this.boxParent);
    },
    onIconFieldClick: function(field){
        console.log(" onIconFieldClick");
        return this.onClick(this.getSiteController(), field.$$icon);
    },
    onClick: function(ctrl, target){
        var doEvt = true;
        var self = this;
        if (ctrl) {
            var p = self.getOnClickParams(target);
            doEvt = ctrl.triggerAdx(p.event, p.opt);
            console.log("onClick " + doEvt)
        }
        return doEvt
        //TEST
        //this.boxParent.setFocus(p.opt.data.xid,p.opt.data.line,true)
    },
    getOnClickParams: function(target){
        var lineClicked = this._isLineClicked(target), $field;
        var p = {
            "event": "",
            "opt": {}
        };
        if (lineClicked) {
            p.event = "wdgt.grid.clickline";
            p.opt = {
                "target": this,
                "type": "click",
                "data": {
                    "line": (this.$recordIndex + 1),
                    "xid": this.boxParent.builder.getGridXid()
                }
            };
        }
        else {
            var css = this.boxParent.builder._css.cellFusion, isCheck = false, isIcon = false, readOnly = false, readOnlyStatic = false, disabled = false, xid;
            var element = ($(target).hasClass(css)) ? $(target) : $(target).parents("." + css);
            var field = this.getField(element.data('s-xid'));
            isCheck = (field.$field.$type == syraUtil.dataTypes.booleanType);
            isIcon = (field.$field.$type == syraUtil.dataTypes.iconType && $(target).hasClass("s-inplace-value-icon"));
            readOnlyStatic = (element.hasClass(this.boxParent.builder.guimod.css.readOnlyStatic));
            readOnly = (element.hasClass(this.boxParent.builder.guimod.css.readOnly));
            disabled = (element.hasClass(this.boxParent.builder.guimod.css.disabled));
            xid = (element.data('s-xid'))
            if (readOnly && !isIcon) {
                p.event = "wdgt.grid.clickcell";
            }
            else 
                if (readOnlyStatic && !isIcon) {
                    p.event = "wdgt.grid.clickcell";
                }
                else 
                    if (isCheck) {
                        p.event = "wdgt.grid.clickcellCheck";
                    }
                    else 
                        if (isIcon) {
                            p.event = "wdgt.grid.clickcellIco";
                        }
                        else {
                            p.event = "wdgt.grid.clickcell";
                        }
            p.opt = {
                "target": this,
                "type": "click",
                "data": {
                    "line": (this.$recordIndex + 1),
                    "xid": xid,
                    "isReadOnly": readOnly,
                    "isReadOnlyStatic": readOnlyStatic,
                    "isDisabled": disabled
                }
            };
        }
        return p;
    },
    _isLineClicked: function(target){
        return (($(target).data("s-record") != undefined) || $(target).hasClass(this.boxParent.builder._css.noline) || $(target).parents("." + this.boxParent.builder._css.nolineFusion).length !== 0);
    },
    setFocus: function(xid, edit, opt){
        var self = this;
        var list = this.boxParent;
        list.builder.recordIndexFocus = this.$recordIndex;
        this.current = {
            "xid": xid,
            "edit": edit,
            "opt": opt
        };
        var field = this.getField(xid);
        if (field && edit && !field.$isEditMode) {
            field.$item.$isFieldEditOnfly = edit;
            //setTimeout(function(){
            // FDB - check .$item - Le champ a peut être supprimé pendant le setTimeout (close)
            if (field && !field.$isReadOnly && field.$item) {
                console.log(self.constructor.name + '.setFocus xid:' + xid + " recordIndex:" + self.$recordIndex + " isEditMode:" + field.$item.$isEditMode)
                if (!field.$item.$isEditMode) {
                    field.$$item.toggleClass("s-grid-fusion-select-edit", true);
                    document.fieldController.toggleEditMode(field);
                }
                setTimeout(function(){
                    if (edit) {
                        field.focus();
                        if (field.$$input) {
                            field.$$input.select();
                        }
                        //list.idMap[field.id]=field
                    }
                    else {
                        field.$$container.focus();
                    }
                }, 10)
            }
            //}, 10); 
        
        };
        if (!edit) 
            field.$$item.toggleClass("s-grid-fusion-select", true);
    },
    resetFocus: function(xid){
        var self = this, list = self.boxParent;
        if (!xid) {
            var xid = this.current.xid;
        };
        var field = this.getField(xid);
        if (field) {
            //setTimeout(function(){					
            // FDB - check .$item - Le champ a peut être supprimé pendant le setTimeout (close)
            if (field && field.$item) {
                field.$$item.toggleClass("s-grid-fusion-select", false);
                field.$$item.toggleClass("s-grid-fusion-select-edit", false);
                console.log(self.constructor.name + '.resetFocus xid:' + xid + " recordIndex:" + self.$recordIndex + " isEditMode:" + field.$item.$isEditMode)
                if (field.$item.$isEditMode && !field.$isReadOnly) {
                    //delete(list.idMap[field.id]) //&& !(field.$field.$type == syraUtil.dataTypes.iconType)
                    document.fieldController.toggleEditMode(field);
                }
            }
            //}, 10); ;
        };
        this.current = null;
    },
    setFocusStyle: function(style, xid){
        if (!xid) {
            return;
        };
        var field = this.getField(xid);
        if (field) {
            if (field && field.$$input && fusionUtil.focusStyle[style] && fusionUtil.focusStyle[style].css) {
                field.$$input.toggleClass(fusionUtil.focusStyle[style].css, true);
            }
        }
        //style !std, fmtErr
        console.log(this.constructor.name + '.setFocusStyle')
    },
    getCurrentField: function(){
        if (this.current == null) {
            return null
        };
        return this.getField(this.current.xid);
    },
    getValue: function(xid){
        if (xid || (xid = this.current ? this.current.xid : null)) {
            var field = this.getField(xid);
            console.log(this.constructor.name + ".getValue xid:" + xid + " record:" + this.$recordIndex + " EditMode :" + field.$isEditMode);
            if (!field.$isEditMode) 
                return null;
            return this.getDataSrcValue(xid); // FDB - Lecture de la valeur de l'input - currentValue;
        }
        else {
            return null
        }
    },
    getDataSrcValue: function(xid){
        var field = this.getField(xid);
        if (!field.$isEditMode) {
            return field.currentValue;
        }
        else {
            return field.getDataValue(); // FDB - Lecture de la valeur de l'input - currentValue;
        }
    },
    getField: function($bind){
        if (this.boundFields[$bind] && this.boundFields[$bind][0]) {
            return this.boundFields[$bind][0];
        };
        return null
    },
    bindFieldEvents: function(){
    }
});
