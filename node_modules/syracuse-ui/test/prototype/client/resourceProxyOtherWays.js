"use strict";
var helpers = require('syracuse-core').helpers;
var walkPath = helpers.object.walkPath;
var forEachKey = helpers.object.forEachKey;

var _templatePattern = /(\{.*?\})/g;

function Template(expression, matches) {
	var self = this;
	self.expression = expression;
	self.linkedProperties = []; //propriétés utilisées par le template
	matches.forEach(function(match) {
		var propertyPath = match.trim().substr(1, match.length - 2);
		self.linkedProperties.push({
			expression: match.trim(),
			propertyPath: propertyPath
		});
	});
	//validate if not return null, check if new Template retourne bien null
}

Template.create = function(expression) {
	//Guard clauses, do not use isTemplate for performance (reuse of matches latter)
	if (typeof expression != "string") {
		return null;
	}
	var matches = expression.match(_templatePattern);
	if (!matches) return null;
	return new Template(expression, matches);
};
Template.prototype.execute = function(obj, fallbackObj) {
	var self = this;
	var result = self.expression;

	self.linkedProperties.forEach(function(linkedProperty) {
		var propertyPath = linkedProperty.propertyPath;
		var value = "";
		var path = walkPath(obj, propertyPath);
		if (path) {
			value = path.resource[path.property];
			if (typeof value == "undefined") {
				path = walkPath(fallbackObj, propertyPath);
				value = path.resource[path.property];
			}
		}
		var tpl = Template.create(value);
		if (tpl) {
			value = tpl.execute(obj, fallbackObj);
		}
		result = result.replace(linkedProperty.expression, value);
	});
	return result;
};

//should create concrete type and deserialize obj ?
//should 
var mandatoryMetadataProperties = ["$diagnoses"];

var _deepProxy = exports.deepProxy = function(obj, proto, rootObj, rootProto, parentPath, allLinked, allArrayItems) { //fastest on creation, slowest to use
	var isRoot = rootObj ? false : true;
	var proxy = {};
	rootObj = rootObj || obj;
	rootProto = rootProto || proto;
	allLinked = allLinked || {};
	allArrayItems = allArrayItems || {};
	//Part du principe que le proto contient toutes les propriétés de l'objet, y compris $uuid

	forEachKey(proto, function(name, protoValue) {
		var path = parentPath ? parentPath + "." + name : name;
		var hasChange = true;
		var tpl; //Mis en cache.
		var linkedTo;
		if (typeof protoValue !== "object" || protoValue == null) {
			Object.defineProperty(proxy, name, {
				get: function() {
					//on peut utiliser protoValue au lieu de proto[name] si une modification du prototype 
					//a posteriori ne doit pas impacter la resource finale (le "merge" de delta resource + proto)
					//aujourd'hui, une modification du proto impacte immédiatement les getters
					var val = obj.hasOwnProperty(name) ? obj[name] : proto[name];
					if (hasChange) {
						tpl = Template.create(val);
						if (tpl) {
							tpl.linkedProperties.forEach(function(propertyInfo) {
								allLinked[propertyInfo.propertyPath] = allLinked[propertyInfo.propertyPath] || [];
								allLinked[propertyInfo.propertyPath].push(path);
							});
						}
					}
					if (tpl) {
						val = tpl.execute(rootObj, rootProto);
					}
					hasChange = false;
					return val;
				},
				set: function(v) {
					obj[name] = v;
					hasChange = true;
					var linked = allLinked[path];
					if (linked) {
						linked.forEach(function(propertyName) {
							//Should fire event change for propertyName
						});
					}
					//Pour que ça se propage dans un href par exemple, il faudrait pouvoir
					//déclancher un event.

					//Un set pourrait déclencher une validation locale + validation des propriétés de template liées
					//Encode que là, à mon avis peu probable qu'il y ait des règles.
					//Si une erreur, possibilité de modifier le diagnoses + d'envoyer un event d'erreur,
					//Pas besoin d'avoir un "vrai" proxy qui gérerait l'ajout d'une propriété
					//non existante jusque là (le diagnoses)
				},
				enumerable: true
			});
		} else {
			if (Array.isArray(protoValue)) {
				proxy[name] = protoValue;
			} else {
				if (parentPath == "$properties" && protoValue.$type && protoValue.$type.indexOf("application/x-list") != -1 && protoValue.$item) {
					var realPath = path.substring(2, path.length);
					allArrayItems[realPath] = protoValue.$item;
				}
				proxy[name] = _deepProxy(obj[name] || {}, protoValue, rootObj, rootProto, path, allLinked, allArrayItems);
			}
		}
		if (parentPath == "$properties") {
			mandatoryMetadataProperties.forEach(function(propertyName) {
				if (!protoValue[propertyName]) {
					Object.defineProperty(proxy[name], propertyName, {
						get: function() {
							var parent = obj.hasOwnProperty(name) ? obj[name] : proto[name];
							return parent[propertyName];
						},
						set: function(v) {
							var parent = obj[name];
							if (!parent) {
								parent = obj[name] = {};
							}
							obj[name][propertyName] = v;
						},
						enumerable: true
					});
				}
			});
		}
	});

	if (isRoot) { //Seconde passe, utilisée notamment pour les arrays de l'objet.
		forEachKey(allArrayItems, function(pathStr, itemProto) {
			var path = walkPath(obj, pathStr);
			var array = path.resource[path.property];
			path.resource[path.property] = array.map(function(item) {
				return _deepProxy(item, itemProto, item, itemProto, pathStr);
			});
		});
	}

	return proxy;
};

var _merge = exports.simpleMerge = function(resource, proto, resourceRoot, protoRoot, allLinked) {
	//Incorrect normalement, voir simpleMergeWithTemplates
	resourceRoot = resourceRoot || resource;
	protoRoot = protoRoot || proto;
	allLinked = allLinked || {};
	helpers.object.forEachKey(proto, function(protoKey, protoValue) {
		var resourceValue = resource[protoKey];
		var typeOfResourceValue = typeof resourceValue;
		if (typeOfResourceValue != "object") {
			if (typeOfResourceValue == "undefined") {
				if (typeof protoValue != "object") {
					resource[protoKey] = protoValue;
				} else {
					resource[protoKey] = helpers.object.clone(protoValue, true);
				}
			}
		} else {
			if (Array.isArray(resourceValue)) {
				if (protoRoot.$properties && protoRoot.$properties[protoKey]) {
					var metadata = protoRoot.$properties[protoKey];
					if (metadata.$type && metadata.$type.indexOf("application/x-list;") != -1) {
						var itemProto = metadata.$item;
						if (itemProto) {
							resource[protoKey] = resourceValue.map(function(itemValue) {
								return _merge(itemValue, itemProto, itemValue, itemProto, allLinked);
							});
						}
					}
				}
			} else {
				resource[protoKey] = _merge(resourceValue, protoValue, resourceRoot, protoRoot, allLinked);
			}
		}
	});
	return resource;
};

var _merge = exports.simpleMergeWithTemplates = function(resource, proto, resourceRoot, protoRoot, allLinked) {
	var isRoot = resourceRoot ? false : true;
	resourceRoot = resourceRoot || resource;
	protoRoot = protoRoot || proto;
	allLinked = allLinked || {};
	helpers.object.forEachKey(proto, function(protoKey, protoValue) {
		var resourceValue = resource[protoKey];
		var typeOfResourceValue = typeof resourceValue;
		if (typeOfResourceValue != "object") {
			if (typeOfResourceValue == "undefined") {
				if (typeof protoValue != "object") {
					if (typeof protoValue == "string") {
						var tpl = Template.create(protoValue);
						if (tpl) {
							resource[protoKey] = tpl.execute(resourceRoot, protoRoot);
						} else {
							resource[protoKey] = protoValue;
						}
					} else {
						resource[protoKey] = protoValue;
					}
				} else {
					resource[protoKey] = _merge({}, protoValue, resourceRoot, protoRoot, allLinked);
				}
			}
		} else {
			if (Array.isArray(resourceValue)) {
				if (protoRoot.$properties && protoRoot.$properties[protoKey]) {
					var metadata = protoRoot.$properties[protoKey];
					if (metadata.$type && metadata.$type.indexOf("application/x-list;") != -1) {
						var itemProto = metadata.$item;
						if (itemProto) {
							resource[protoKey] = resourceValue.map(function(itemValue) {
								return _merge(itemValue, itemProto, itemValue, itemProto, allLinked);
							});
						}
					}
				}
			} else {
				resource[protoKey] = _merge(resourceValue, protoValue, resourceRoot, protoRoot, allLinked);
			}
		}
	});
	return resource;
};

var _mergeAndProxy = exports.mergeAndProxy = function(obj, proto, rootObj, rootProto, parentPath, allLinked, allArrayItems) { //fastest on creation, slowest to use
	//Dans quel cas besoin de getter setter
	//getter si proto est un template
	//setter si champ lié à un template

	//Tester avec lazy loading aussi

};

var _lazyProxy = exports.lazyProxy = function(obj, proto, rootObj, rootProto, parentPath, allLinked, allArrayItems, proxyIsObject) {
	var isRoot = rootObj ? false : true;
	var proxy = {};
	rootObj = rootObj || obj;
	rootProto = rootProto || proto;
	allLinked = allLinked || {};
	allArrayItems = allArrayItems || {};
	//Part du principe que le proto contient toutes les propriétés de l'objet, y compris $uuid

	//Un scanner l'objet
	//Deux scanner le proto, et ne remplacer que si pas déjà de valeur.

	forEachKey(proto, function(name, protoValue) {
		var path = parentPath ? parentPath + "." + name : name;
		var hasChange = true;
		var tpl; //Mis en cache.
		var linkedTo;
		var value;
		var condition = false;

		var isPrimitiveProperty = false;
		if (obj[name] === undefined) { //A revoir
			isPrimitiveProperty = typeof protoValue !== "object" || protoValue == null;
		} else {
			isPrimitiveProperty = typeof obj[name] !== "object" || obj[name] == null;
		}
		if (isPrimitiveProperty) {
			Object.defineProperty(proxy, name, {
				get: function() {
					//on peut utiliser protoValue au lieu de proto[name] si une modification du prototype 
					//a posteriori ne doit pas impacter la resource finale (le "merge" de delta resource + proto)
					//aujourd'hui, une modification du proto impacte immédiatement les getters
					var val = obj.hasOwnProperty(name) ? obj[name] : proto[name];
					if (hasChange) {
						tpl = Template.create(val);
						if (tpl) {
							tpl.linkedProperties.forEach(function(propertyInfo) {
								allLinked[propertyInfo.propertyPath] = allLinked[propertyInfo.propertyPath] || [];
								allLinked[propertyInfo.propertyPath].push(path);
							});
						}
					}
					if (tpl) {
						val = tpl.execute(rootObj, rootProto);
					}
					hasChange = false;
					return val;
				},
				set: function(v) {
					obj[name] = v;
					hasChange = true;
					var linked = allLinked[path];
					if (linked) {
						linked.forEach(function(propertyName) {
							//Should fire event change for propertyName
						});
					}
					//Pour que ça se propage dans un href par exemple, il faudrait pouvoir
					//déclancher un event.

					//Un set pourrait déclencher une validation locale + validation des propriétés de template liées
					//Encode que là, à mon avis peu probable qu'il y ait des règles.
					//Si une erreur, possibilité de modifier le diagnoses + d'envoyer un event d'erreur,
					//Pas besoin d'avoir un "vrai" proxy qui gérerait l'ajout d'une propriété
					//non existante jusque là (le diagnoses)
				},
				enumerable: true
			});
		} else {
			Object.defineProperty(proxy, name, {
				get: function() {
					if (typeof value != "undefined") {
						return value;
					} else { //Pfiou... à retravailler.
						if (Array.isArray(protoValue)) {
							return protoValue;
						} else {
							var val = protoValue;
							if (val == null) {
								val = obj[name];
							}
							if (Array.isArray(val)) {
								var itemProto = rootProto.$properties[name];
								if (itemProto && itemProto.$item) {
									itemProto = itemProto.$item;
								}
								value = val.map(function(v) {
									return _lazyProxy(v, itemProto, v, itemProto, path, allLinked, allArrayItems);
								});
								Object.defineProperty(value, "push", {
									value: function(item) {
										item = _lazyProxy(item, itemProto, item, itemProto, path, allLinked, allArrayItems, true);
										return Array.prototype.push.apply(value, [item]);
									},
									enumerable: false
								});
								//Should manage [] + ?
								return value;
							} else {
								value = _lazyProxy(obj[name] || {}, protoValue, rootObj, rootProto, path, allLinked, allArrayItems);
								return value;
							}
						}
					}
				},
				set: function(v) {
					obj[name] = v;
					value = _lazyProxy(obj[name], protoValue, rootObj, rootProto, path, allLinked); //Marche pas car doit prendre en compte les propriétés de l'objet aussi
				},
				enumerable: true
			});

		}
		if (parentPath == "$properties") {
			mandatoryMetadataProperties.forEach(function(propertyName) {
				if (!protoValue[propertyName]) {
					Object.defineProperty(proxy[name], propertyName, {
						get: function() {
							var parent = obj.hasOwnProperty(name) ? obj[name] : proto[name];
							return parent[propertyName];
						},
						set: function(v) {
							var parent = obj[name];
							if (!parent) {
								parent = obj[name] = {};
							}
							obj[name][propertyName] = v;
						}
					});
				}
			});
		}
	});
	/*
	if (isRoot) { //Seconde passe, utilisée notamment pour les arrays de l'objet.
		forEachKey(allArrayItems, function(pathStr, itemProto) {
			var path = walkPath(obj, pathStr);
			var array = path.resource[path.property];
			path.resource[path.property] = array.map(function(item) {
				return _create(item, itemProto, item, itemProto, pathStr);
			});
		})
	}
	*/

	return proxy;
};

//PrimitiveProperty
//ArrayProperty
//ObjectProperty

//Getter/Setter definition
//observers
//hasChanges sur setter pour prochain getter

function _arrayDescriptor() {

}

function _objectDescriptor() {

}

function _primitiveDescriptor() {

}

function _isPrimitive(value) {
	return typeof value !== "object" || value == null;
}

function _createPropertyDescriptor(value) {
	if (_isPrimitive(value)) {
		return _primitiveDescriptor(value);
	} else {
		if (Array.isArray(value)) {
			return _arrayDescriptor(value);
		} else {
			return _objectDesciptor(value);
		}
	}
}

function _applyObjToProxy(proxy, obj) {
	forEachKey(obj, function(propertyName, value) {
		if (proxy.hasOwnProperty(propertyName)) return;
		var descriptor = _createPropertyDescriptor(obj[propertyName]);

		Object.defineProperty(proxy, propertyName, descriptor);

	});
}

var lazyProxyNew = exports.lazyProxyNew = function(obj, proto) {
	var proxy = {};
	_applyObjToProxy(proxy, obj);
	_applyObjToProxy(proxy, proto);
};

//Class proto
//proto.getValue(instance, 'nomPropriété')
//proto.setValue(instance, 'nomPropriété')
//setvalue ne sert à rien.
//Comprends rien sur le wrapper des arrays.

//getValue() renvoyer template exécuté + dépendances.

var Prototype = exports.Prototype = function(proto) {
	this._proto = proto;
};

Prototype.prototype.parse = function(expression, instance) {
	var self = this;
	if (typeof expression != "string") {
		return null;
	}
	var matches = expression.match(_templatePattern);
	if (!matches) return null;
	var linkedProperties = []; //propriétés utilisées par le template
	matches.forEach(function(match) {
		var propertyPath = match.trim().substr(1, match.length - 2);
		var value = "";
		var path = walkPath(instance, propertyPath);
		if (path) {
			value = path.resource[path.property];
		};
		expression = expression.replace(match.trim(), value);
		linkedProperties.push(propertyPath);
	});
	return {
		isTemplate: true,
		value: expression,
		linkedProperties: linkedProperties
	};
};
Prototype.prototype.getValue = function(instance, propertyPath) {
	var self = this;
	var path = walkPath(instance, propertyPath);
	var value = path ? path.resource[path.property] : undefined;
	if (typeof value == "undefined") {
		path = walkPath(self._proto, propertyPath);
		value = path.resource[path.property];
		var templatedValue = self.parse(value, instance);
		if (templatedValue != null) value = templatedValue;
	} else {
		if (Array.isArray(value)) {
			var itemProto = self._proto.$properties[propertyPath];
			if (itemProto && itemProto.$item) {
				itemProto = itemProto.$item;
				value = value.map(function(v) {
					var p = new Prototype(itemProto);
					var oldGetValue = p.getValue;
					p.getValue = function(propertyPath) {
						return oldGetValue.apply(p, [v, propertyPath]);
					};
					return p;
				});
			}
		}
	}
	return value;
};
Prototype.prototype.addChild = function(instance, propertyPath, child) {
	var self = this;
	var path = walkPath(instance, propertyPath);
	var value = path ? path.resource[path.property] : undefined;
	if (value && Array.isArray(value)) {
		value.push(child);
		return child;
	}
};

var PrototypeV2 = exports.PrototypeV2 = function(proto) {
	this._proto = proto;
};

PrototypeV2.prototype.getTemplateInfo = function(propertyPath) {
	var self = this;
	var path = walkPath(self._proto, propertyPath);
	var expression = path.resource[path.property];
	if (typeof expression != "string") {
		return null;
	}
	var matches = expression.match(_templatePattern);
	if (!matches) return null;
	var linkedProperties = []; //propriétés utilisées par le template
	matches.forEach(function(match) {
		var propertyPath = match.trim().substr(1, match.length - 2);
		linkedProperties.push(propertyPath);
	});
	return {
		linkedProperties: linkedProperties
	};
};

PrototypeV2.prototype.getChildProto = function(propertyPath) {
	var self = this;
	var itemProto = self._proto.$properties[propertyPath];
	if (itemProto && itemProto.$item) {
		return new PrototypeV2(itemProto.$item);
	}
	return null;
};

PrototypeV2.prototype.parse = function(expression, instance) {
	var self = this;
	if (typeof expression != "string") {
		return null;
	}
	var matches = expression.match(_templatePattern);
	if (!matches) return null;
	var linkedProperties = []; //propriétés utilisées par le template
	matches.forEach(function(match) {
		var propertyPath = match.trim().substr(1, match.length - 2);
		var value = "";
		var path = walkPath(instance, propertyPath);
		if (path) {
			value = path.resource[path.property];
		};
		expression = expression.replace(match.trim(), value);
		linkedProperties.push(propertyPath);
	});
	return expression;
};

PrototypeV2.prototype.getValue = function(instance, propertyPath) {
	var self = this;
	var path = walkPath(instance, propertyPath);
	var value = path ? path.resource[path.property] : undefined;
	if (typeof value == "undefined") {
		path = walkPath(self._proto, propertyPath);
		value = path.resource[path.property];
		var templatedValue = self.parse(value, instance);
		if (templatedValue != null) value = templatedValue;
	}
	return value;
};
PrototypeV2.prototype.addChild = function(instance, propertyPath, child) {
	var self = this;
	var path = walkPath(instance, propertyPath);
	var value = path ? path.resource[path.property] : undefined;
	if (value && Array.isArray(value)) {
		value.push(child);
		return child;
	}
};

function PropertyDesc(proto, key) {
	this._metadata = proto.$properties[key];
}
helpers.defineClass(PropertyDesc, null, {
	getType: function() {
		if (this._metadata) return this._metadata.$type;
	},
	isList: function() {
		var type = this.getType();
		if (type) return type.indexOf("application/x-list") == 0;
	},
	isAggregate: function() {
		var type = this.getType();
		if (type) return type.indexOf("application/x-aggregate") == 0;
	},
	isLeaf: function() {
		return !this.isList() && !this.isAggregate();
	}
});

function Template2(expression) {
	this.expression = expression;
	this._matches = this.getMatches();
}
helpers.defineClass(Template2, null, {
	getMatches: function() {
		if (typeof this.expression != "string") {
			return null;
		}
		var matches = this.expression.match(_templatePattern);
		if (!matches) return null;
		return matches;
	},
	_getPathValue: function(path, obj) {
		var self = this;
		var path = walkPath(obj, path);
		return path ? path.resource[path.property] : undefined;
	},
	isTemplate: function() {
		var self = this;
		return self._matches != null;
	},
	resolve: function(obj, fallbackObj) {
		var self = this;
		if (!self._matches) return null;
		var result = this.expression;
		self._matches.forEach(function(match) {
			var propertyPath = match.trim().substr(1, match.length - 2);
			var value = self._getPathValue(propertyPath, obj);
			if (value === undefined) {
				value = self._getPathValue(propertyPath, fallbackObj);
			}
			result = result.replace(match.trim(), value);
		});
		return result;
	}
});

var _getInstanceConstructor = exports.getInstanceConstructor = function(protoDesc, rootProto) {

	rootProto = rootProto || protoDesc;

	var Instance = function(data, root) {
		this._data = data;
		this._root = root || this._data;
		this._subInstances = {};
	};

	forEachKey(protoDesc, function(key, value) {
		var property = new PropertyDesc(rootProto, key);
		var cachedSubInstanceConstructor; //Used by all instances when created
		if (property.isLeaf()) {
			var tpl = new Template2(value);
			if (tpl.isTemplate()) {
				Object.defineProperty(Instance.prototype, key, {
					get: function() {
						return tpl.resolve(this._root, rootProto);
					}
				});
			} else {
				Object.defineProperty(Instance.prototype, key, {
					get: function() {
						var instValue = this._data[key];
						if (typeof instValue != "undefined") return instValue;
						return value;
					},
					set: function(v) {
						this._data[key] = v;
					}
				});
			}
		} else {
			if (property.isList()) {
				Object.defineProperty(Instance.prototype, key, {
					get: function() {
						var array = this._data[key];
						if (!cachedSubInstanceConstructor) {
							var itemProto = rootProto.$properties[key];
							if (itemProto && itemProto.$item) {
								cachedSubInstanceConstructor = _getInstanceConstructor(itemProto.$item);
							}
						}
						array.forEach(function(arrVal, index) {
							if (!(arrVal instanceof cachedSubInstanceConstructor)) {
								array[index] = new cachedSubInstanceConstructor(arrVal);
							}
						});
						this._data[key] = array;
						return array;
					}
				});
			} else {
				Object.defineProperty(Instance.prototype, key, {
					get: function() {
						var subInstance = this._subInstances[key];
						if (!cachedSubInstanceConstructor) {
							cachedSubInstanceConstructor = _getInstanceConstructor(value, rootProto);
						} else {
							if (subInstance) {
								return subInstance;
							}
						}
						subInstance = this._subInstances[key] = new cachedSubInstanceConstructor(this._data[key], this._root);
						return subInstance;
					},
					set: function(v) {
						console.log("oups");
					}
				});
			}
		}

	});

	return Instance;
};

function _isLeaf(value) {
	//Gérer dates et types syracuse...
	if (value == null) //A voir si à garder
		return true;
	return {
		"string": 1,
		"boolean": 1,
		"number": 1
	}[typeof value];
}