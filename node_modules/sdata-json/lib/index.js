"use strict";

function clone(node) {
	if (typeof node !== 'object') return node;
	return Object.keys(node).reduce(function(result, key) {
		var val = node[key];
		if (val && typeof val === 'object') {
			if (Array.isArray(val)) val = val.map(clone);
			else val = clone(val);
		}
		result[key] = val;
		return result;
	}, {});
}

exports.combine = function(proto, res) {
	var stack = [];

	function substitute(val, depth) {
		if (typeof val !== 'string') return val;
		if (depth > 10) throw new Error("circular substitution on " + val);
		return val.replace(/\{([^\}]+)\}/g, function(s, ref) {
			for (var i = stack.length - 1; i >= 0; i--) {
				var v = stack[i][ref];
				if (v !== undefined) return substitute(v, depth + 1);
			}
			throw new Error("cannot replace " + s + " in " + val);
		});
	}

	function merge(meta, val) {
		switch (meta.$type) {
		case 'application/json':
			if (!meta.$properties) throw new Error("invalid object definition: $properties missing");
			if (val == null) return meta;
			if (typeof val !== 'object') throw new Error("invalid value, expected object, got " + val);
			var obj = {};
			stack.push(obj);
			try {
				// transfer values of the object that don't correspond to properties ($key, $uuid, ...)
				Object.keys(val).filter(function(key) {
					return !meta.$properties[key];
				}).forEach(function(key) {
					if (key[0] !== '$') throw new Error("no property descriptor for " + key);
					obj[key] = val[key];
				});
				// transfer properties
				Object.keys(meta.$properties).forEach(function(key) {
					var v = val[key];
					var prop = meta.$properties[key];
					obj[key] = merge(prop, v);
				}, meta);
				// copy values that exist in meta but not in val
				var remain = Object.keys(meta).filter(function(key) {
					return val[key] === undefined;
				});
				remain.forEach(function(key) {
					obj[key] = meta[key];
				});
				remain.forEach(function(key) {
					obj[key] = substitute(meta[key], 0);
				});
			} finally {
				stack.pop();
			}
			return obj;
		case 'application/x-reference':
			if (!meta.$item) throw new Error("invalid reference definition: $item missing");
			if (meta.$item.$type !== 'application/json') throw new Error("invalid reference definition: bad $item.$type: " + meta.$item.$type);
			return merge(meta.$item, val);
		case 'application/x-collection':
			if (!meta.$item) throw new Error("invalid collection definition: $item missing");
			if (val == null) return [];
			if (!Array.isArray(val)) throw new Error("invalid value: expected array, got" + val);
			return val.map(function(v) {
				return merge(clone(meta.$item), v);
			});
		case 'image':
			if (val != null && typeof val !== 'object') throw new Error("invalid value, expected image object, got " + typeof val);
			return val;
		default:
			if (val != null && typeof val === 'object') throw new Error("invalid value, expected " + meta.$type + ", got object");
			// todo: check type
			return val;
		}
	}

	return merge(clone(proto), res);
}