var qu = require("./qunit");
var QUnit = qu.QUnit;

var oldDone = QUnit.done;
QUnit.done = function() {
    if (oldDone) oldDone();
    // shutdown message; marker xqz to identify the origin
    console.log(JSON.stringify({
        shutdown: true,
        xqz: "t@)$" 
    }));
}

// redirect chai APIs to QUnit
var assert = require('chai').assert;
function badAssertion(name) {
	return () => { throw new Error(`assert.${name} not supported by QUnit`); }
}

QUnit.throws = function(fn, re) {
	try {
		fn();
		assert.ok(false, "function did not throw");
	} catch (ex) {
		assert.ok(re.test(ex.message), "exception message matches " + re);
	}
}

Object.keys(assert).forEach(name => {
	assert[name] = QUnit[name] || badAssertion(name);
	if (/(isNaN)/.test(name)) return;
	delete QUnit[name];
	delete global[name];
});

// map mocha API to QUnit
var qModule = QUnit.module;
var qAsyncTest = QUnit.asyncTest;
var qTest = QUnit.test;
var qStart = QUnit.start;

// redirect mocha API to QUnit
global.describe = function(name, fn) {
	qModule(name);
	fn();
}

global.it = function(name, fn) {
	if (fn.length === 1) {
		qAsyncTest(name, (_) => {
			fn(_);
			qStart();
		});
	} else {
		qTest(name, fn);
	}
}
global.run = () => {};

// Now, cripple QUnit API to make sure that it is not used directly by our unit tests
const forbidden = ['module', 'asyncTest', 'test', 'start'].concat(Object.keys(assert).filter(k => k !== 'isNaN'));
forbidden.forEach(key => {
	if (QUnit[key]) QUnit[key] = () => { throw new Error("QUnit." + key + " API is disabled. Use mocha instead"); };
	if (QUnit.api[key]) QUnit.api[key] = () => { throw new Error("QUnit." + key + " API is disabled. Use mocha instead"); };
	delete global[key];
});
