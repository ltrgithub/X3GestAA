"use strict";

var pathUtil = require("path");
var fs = require('streamline-fs');
var qunit = require('qunit');
var spawn = require("child_process").spawn;
var streamline = require("streamline/lib/compiler/register");
var readers = require("streamline/lib/streams/readers");
var globals = require("streamline/lib/globals");
var config = require('config');

var root = pathUtil.join(__dirname, "../../..");

var qunitOpts = {
		deps: __dirname + '/init-streamline.js',
		coverage: true,
		log: {
//			summary: true,
//			errors: true,
//			coverage: true
		}
	};

function doDir(_, path, depth, result, tier) {
	function _dirOk(file) {
		switch (depth) {
			case 0:
				return true;
			case 1:
				return file == "test";
			case 2:
				return file == "common" || file == tier;
			default:
				return false;
		}
	}

	var files = fs.readdir(root + path, _);
	files.forEach_(_, function(_, file, i) {
		var fpath = path + "/" + file;
		var stats = fs.lstat(root + fpath, _);
		if (stats.isDirectory()) {
			if (_dirOk(file)) doDir(_, fpath, depth + 1, result, tier);
		} else if (stats.isFile()) {
			var match;
			if (depth == 3 && (match = /(^[^.].*)\.(_?js|src)$/.exec(file))) {
				if (match[2] === 'src' && !config.etna) return;
				var name = path + "/" + match[1];
				if (tier === 'client' && name.indexOf('--fibers') > 0) return;
				if (name[name.length - 1] != "_") result.push(name.substring(1));
			}
		}
	});
}

function _getFiles(_, tier) {
	var result = [];
	doDir(_, "", 0, result, tier);
	return result;
}

// for Code Coverage, must match up tests to code
// Assume this will be done via JSON file in the future?
function getCode(_, file) {
	var test = root + '/' + file;
	test += (fs.exists(test + '._js', _) ? '._js' : '.js');
	var codeMatch = fs.readFile(test, 'utf8', _).match(new RegExp('["\'](' + file.split('/')[0] + '.+)["\']'));
	var code = codeMatch ? root + '/' + codeMatch[1] + test.substr(test.lastIndexOf('.')) : test;
	if (code.slice(-3) === '_js' && !fs.exists(code, _)) code = code.substr(0, code.lastIndexOf('.')) + '.js';
	return code;
}

function _runFile(_, file, verbose, results) {
	var harmony = false;
	try {
		eval("(function*(){})");
		harmony = true;
	} catch (ex) {}
	if (!harmony && /galaxy/.test(file)) return;

	console.log("======> UNIT TEST " + file);

	var logpath = root + '/' + file + '.testlog';
	var logfd = fs.openSync(logpath, 'w');

	function log(str) {
		var buf = new Buffer(str + '\n', "utf8");
		console.log(str);
		fs.writeSync(logfd, buf, 0, buf.length);
	}
	try {
		// Run the tests.
		qunit.run({
			code: getCode(_, file),
			tests: [root + '/' + file]
		}, _);

		//		var child = spawn(process.execPath, nodeOpts.concat([root + "/qunit/index.js", JSON.stringify(opts)]));
		//		child.stdout.setEncoding("utf8");
		//		var reader = new readers.Reader(child.stdout);
		//		child.stderr.setEncoding("utf8");
		//		child.stderr.on("data", function(data) {
		//			log(data);
		//		});
		//		var str;
		//		while ((str = reader.readItem(_)) != null) {
		//			if (str[0] == "{") {
		//				try {
		//					var result = JSON.parse(str);
		//					if (!harmony && result.errorStack && result.errorStack.indexOf("SyntaxError: Unexpected token *") >= 0) {
		//						result.message = "TEST SKIPPED (requires V8 generators)";
		//						delete result.errorStack;
		//						str = JSON.stringify(result);
		//					}
		//					if (result.message !== undefined) {
		//						verbose && console.log(str);
		//						results.push(result);
		//					} else log(str);
		//				} catch (ex) {
		//					log(str);
		//				}
		//			} else log(str);
		//		}
	} catch (ex) {
		console.error(ex);
	} finally {
		fs.closeSync(logfd);
	}
}

function _runServer(_, files, verbose) {
	var results = [];
	files.forEach_(_, 4, function(_, file) {
		_runFile(_, file, verbose, results);
	});
	return JSON.stringify(results);
}

exports.runUnitTest = function(_, file, verbose) {
	var results = [];
	_runFile(_, file, verbose, results);
	return results;
};

exports.dispatch = function(_, request, response) {
	function jsonReply(obj) {
		var json = typeof obj === "string" ? obj : JSON.stringify(obj);
		response.writeHead(200, {
			'content-type': 'application/json',
			//'content-length': json.length
		});
		response.end(json, "utf8");
	}
	try {
		var result;
		switch (request.url) {
			case '/tests/files':
				jsonReply({
					client: _getFiles(_, "client"),
					server: _getFiles(_, "server")
				});
				break;
			case '/tests/start':
				jsonReply(_runServer(_, JSON.parse(request.readAll(_))));
				break;
			default:
				response.writeHead(404);
				response.end("resource not found: " + request.url);
		}
	} catch (ex) {
		response.writeHead(500);
		response.end(ex.message + '\n' + ex.stack);
	}
};

function runIt(_) {
	var arg = process.argv[2];
	var files = _getFiles(_, "server").filter(function(f) {
		return !arg || ~f.indexOf(arg);
	});
	qunit.setup(qunitOpts);
	_runServer(_, files, true);
}

exports.run = function() {
	runIt(_ >>
		function(err) {
			if (err) throw err;
		});
};
