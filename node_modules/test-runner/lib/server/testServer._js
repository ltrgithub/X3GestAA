"use strict";

var pathUtil = require("path");
var fs = require('streamline-fs');
var nodeQUnit = require("../../deps/node-qunit/lib/index");
var spawn = require("child_process").spawn;
var streamline = require("streamline/lib/compiler/register");
var ez = require('ez-streams');
var globals = require("streamline/lib/globals");
var config = require('config');
//var QUnit = require('../support/qunit/qunit/qunit.js');

nodeQUnit.options.coverage = false;
nodeQUnit.options.errorsOnly = true;
nodeQUnit.options.errorStack = true;
nodeQUnit.options.summary = true;


function doDir(_, root, path, rPath, depth, result, tier) {
	function _dirOk(file) {
		switch (depth) {
			case 0:
				return rPath ? rPath.test(file) : true;
			case 1:
				return file == "test";
			case 2:
				return file == "common" || file == tier;
			default:
				return false;
		}
	}

	var files = fs.readdir(root + path, _);
	files.forEach_(_, function(_, file, i) {
		var fpath = path + "/" + file;
		var stats = fs.lstat(root + fpath, _);
		if (stats.isDirectory()) {
			if (_dirOk(file)) doDir(_, root, fpath, rPath, depth + 1, result, tier);
		} else if (stats.isFile()) {
			var match;
			if (depth == 3 && (match = /(^[^.].*)\.(_?js|src)$/.exec(file))) {
				if (match[2] === 'src' && !config.etna) return;
				var name = path + "/" + match[1];
				if (tier === 'client' && name.indexOf('--fibers') > 0) return;
				if (name[name.length - 1] != "_") result.push(name.substring(1));
			}
		}
	});
}

function _getFiles(_, tier) {
	var result = [];

	if (config.unit_test && config.unit_test.rootDirs) {
		config.unit_test.rootDirs.forEach_(_, function(_, rootDir) {
			var root = (!rootDir.root || rootDir.root == ".") ? pathUtil.join(__dirname, "../../..") : rootDir.root;
			var rPath = new RegExp((rootDir.module) ? rootDir.module : ".*");
			doDir(_, root, "", rPath, 0, result, tier);
		});
	} else {
		doDir(_, pathUtil.join(__dirname, "../../.."), "", /.*/, 0, result, tier);
	}
	return result;
}

function _runFile(_, file, verbose, results) {
	var opts = {
		code: file,
		tests: [file],
		coverage: false,
		errorsOnly: false,
		errorStack: true,
		summary: true,
		streamline: streamline.options,
		tenantId: globals.context.tenantId,
		etna: !!config.etna,
	};
	var nodeOpts = ["--debug"];
	var harmony = false;
	try {
		eval("(function*(){})");
		nodeOpts.push("--harmony");
		harmony = true;
	} catch (ex) {}

	if (!harmony && /galaxy/.test(file)) return;
	//verbose && console.log("running " + file);
	console.log("======> UNIT TEST " + file);

	var logpath = pathUtil.join(__dirname, "../../..") + '/' + file + '.testlog';
	var logfd = fs.openSync(logpath, 'w');

	function log(str) {
		var buf = new Buffer(str + '\n', "utf8");
		console.log(str);
		fs.writeSync(logfd, buf, 0, buf.length);
	}
	try {		
		var child = spawn(process.execPath, nodeOpts.concat([__dirname + "/../../deps/node-qunit/lib/bootstrap.js", JSON.stringify(opts)]));
		child.stdout.setEncoding("utf8");
		var reader = ez.devices.node.reader(child.stdout).transform(ez.transforms.lines.parser());
		child.stderr.setEncoding("utf8");
		child.stderr.on("data", function(data) {
			log(data.substring(0, data.length - 1)); // eliminate trailing \n
		});
		var str;
		var tests = [];
		var resi = results.length;
		while ((str = reader.read(_)) != undefined) {
			if (str[0] == "{") {
				try {
					var result = JSON.parse(str);
                    if (result.shutdown && result.xqz === "t@)$") {
                        child.kill();
                    } else {
                        if (!harmony && result.errorStack && result.errorStack.indexOf("SyntaxError: Unexpected token *") >= 0) {
                            result.message = "TEST SKIPPED (requires V8 generators)";
                            delete result.errorStack;
                            str = JSON.stringify(result);
                        }
                        if (result.test !== undefined && result.xqz === "t@)$") {
                            tests.push(result);
                        } else if (result.message !== undefined && result.xqz === "t@)$") {
                            verbose && console.log(str);
                            results.push(result);
                        } else log(str);
                    }
				} catch (ex) {
					log(str);
				}
			} else log(str);
		}
		tests.forEach(function(test) {
			test.got = 0;
			while (resi < results.length && results[resi].name === test.test) {
				if (results[resi].done == null) test.got++;
				resi++;
			}
			if (test.expect != null && test.got !== test.expect) {
				results.splice(resi, 0, {
					module: test.module,
					name: test.test,
					message: "bad result count",
          			errorStack: "Expected " + test.expect + " results, got " + test.got, 
				});
				resi++;
			}
		});
	} finally {
		fs.closeSync(logfd);
	}
}

function _runServer(_, files, verbose, opt) {
    var results = [];
	files.forEach_(_, function(_, file) {
		_runFile(_, file, verbose, results);
	});
	return results;
}

exports.runUnitTest = function(_, file, verbose) {
	var results = [];
	_runFile(_, file, verbose, results);
	return results;
};

exports.dispatch = function(_, request, response) {
	function jsonReply(obj) {
		var json = typeof obj === "string" ? obj : JSON.stringify(obj);
		response.writeHead(200, {
			'content-type': 'application/json',
			//'content-length': json.length
		});
		response.end(json, "utf8");
	}
	try {
		var result;
		switch (request.url) {
			case '/tests/files':
				jsonReply({
					client: _getFiles(_, "client"),
					server: _getFiles(_, "server")
				});
				break;
			case '/tests/start':
				jsonReply(_runServer(_, JSON.parse(request.readAll(_))));
				break;
			default:
				response.writeHead(404);
				response.end("resource not found: " + request.url);
		}
	} catch (ex) {
		response.writeHead(500);
		response.end(ex.message + '\n' + ex.stack);
	}
};

function runIt(_) {
    // arguments :
    // --out=ez.devices.console.log ; define output destination, default ez.device.console.log
    // --filter ; filter to files
    // --details ; include test details into rapport
    //
    var runOpt = process.argv.slice(2).reduce(function(prev, crt) {
        var mm = crt.match(/--(.*)=(.*)/);
        if (mm && mm[1]) prev[mm[1]] = mm[2] || "*";
        else prev.filter = crt;
        return prev;
    }, {});
 	var arg = runOpt.filter;
    //console.log("run options", runOpt);
    if (runOpt.help != undefined) {
        console.log("Usage: \"node ./node_modules/test-runner [--out=url] [--details=*|error] [files_filter]");
        console.log("--out=url examples: ");
        console.log("  --out=http://host:port/segs");
        console.log("  --out=mongodb://host:port/database/collection");
        return;
    }

    var files = _getFiles(_, "server").filter(function(f) {
		return !arg || ~f.indexOf(arg);
	});
    // we want to store the result test by test so loop here
    var rapport = {
        runDate: (new Date()),
        tests: []
    };
    if (runOpt.details) rapport.details = runOpt.details;
    files.forEach_(_, function(_, file) {
        var start = (new Date()).getTime();
        var res = _runServer(_, [file], true, runOpt).map(function(it) {
            return {
                message: it.message,
                name: it.name,
                status: it.errorStack ? "error" : "success"
            }
        });
        var diff = (new Date()).getTime() - start;
        var testRes = {
            duration: diff,
            module: file,
            status: res.some(function(it) { return it.status === "error"; }) ? "error" : "success"
        };
        if (runOpt.details) testRes.tests = (runOpt.details !== "*") ? res.filter(function(tt) {
            return tt.status === runOpt.details;
        }) : res;
        if (!runOpt.details || (runOpt.details !== "*" && runOpt.details === testRes.status)) rapport.tests.push(testRes);
    });
    if (runOpt.out) {
        console.log("Writing result to " + runOpt.out, rapport);
        rapport.status = rapport.tests.some(function(it) { return it.status === "error"; }) ? "error" : "success";
        var writer = ez.factory(runOpt.out).writer(_);
        writer.write(_, rapport);
        writer.write(_, undefined);
    }
    process.exit();
}

exports.run = function() {
	runIt(_ >>
		function(err) {
			if (err) throw err;
		});
};

exports.getFiles = function(_, tier) {
	return _getFiles(_, tier);
};
