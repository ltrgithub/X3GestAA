"use strict";

var config =  require('../../../../nodelocal').config;
require('coffee-script').register();
require('syracuse-core/lib/streamline-loader')(config.streamline);

var pathUtil = require("path");
var fs = require('streamline-fs');
var nodeQUnit = require("../../deps/node-qunit/lib/index");
var spawn = require("child_process").spawn;
var ez = require('ez-streams');
var globals = require('streamline-runtime').globals;
var config = require('config');
var program = require('commander');
var colors = require('colors/safe');

var errorStatus = 0;

//var QUnit = require('../support/qunit/qunit/qunit.js');

nodeQUnit.options.coverage = false;
nodeQUnit.options.errorsOnly = true;
nodeQUnit.options.errorStack = true;
nodeQUnit.options.summary = true;

process.nextTick(function() {
	// disable server timeout, to avoid auto restart of long tests.
	require('syracuse-main/lib/syracuse').server.setTimeout(0);
});
function doDir(_, root, path, rPath, depth, result, tier) {
	function _dirOk(file) {
		switch (depth) {
			case 0:
				return rPath ? rPath.test(file) : true;
			case 1:
				return file == "test";
			case 2:
				return file == "common" || file == tier;
			default:
				return false;
		}
	}

	var files = fs.readdir(root + path, _);
	files.forEach_(_, function(_, file, i) {
		var fpath = path + "/" + file;
		var stats = fs.lstat(root + fpath, _);
		if (stats.isDirectory()) {
			if (_dirOk(file)) doDir(_, root, fpath, rPath, depth + 1, result, tier);
		} else if (stats.isFile()) {
			var match;
			if (depth == 3 && (match = /(^[^.].*)\.(_?js|src)$/.exec(file))) {
				if (match[2] === 'src' && !config.etna) return;
				var name = path + "/" + match[1];
				if (tier === 'client' && name.indexOf('--fibers') > 0) return;
				if (name[name.length - 1] != "_") result.push(name.substring(1));
			}
		}
	});
}

function _getFiles(_, tier) {
	var result = [];

	if (config.unit_test && config.unit_test.rootDirs) {
		config.unit_test.rootDirs.forEach_(_, function(_, rootDir) {
			var root = (!rootDir.root || rootDir.root == ".") ? pathUtil.join(__dirname, "../../..") : rootDir.root;
			var rPath = new RegExp((rootDir.module) ? rootDir.module : ".*");
			doDir(_, root, "", rPath, 0, result, tier);
		});
	} else {
		doDir(_, pathUtil.join(__dirname, "../../.."), "", /.*/, 0, result, tier);
	}
	return result;
}

function _runFile(_, file, verbose, results) {
	var opts = {
		code: file,
		tests: [file],
		coverage: false,
		errorsOnly: false,
		errorStack: true,
		summary: true,
		streamline: config.streamline,
		tenantId: globals.context.tenantId,
		etna: !!config.etna,
	};
	// disable --debug option in node 0.12 because it prevents dbgpProxyHttpTest from forking its proxy
	var nodeOpts = /^v0\.10/.test(process.version) ? ["--debug"] : [];
	var harmony = false;
	try {
		eval("(function*(){})");
		nodeOpts.push("--harmony");
		harmony = true;
	} catch (ex) {}

	function reTest(re) {
		return re.test(file);
	}
	var only = config.unit_test && config.unit_test.only;
	var ignore = config.unit_test && config.unit_test.ignore;
	if ((only && !only.some(reTest)) || (ignore && ignore.some(reTest))) {
		console.log(colors.yellow(file + ": ignored by nodelocal config"));
		return;
	}
	
	verbose && console.log("======> UNIT TEST " + file);

	var logpath = pathUtil.join(__dirname, "../../..") + '/' + file + '.testlog';
	var logfd = fs.openSync(logpath, 'w');

	function log(str) {
		var buf = new Buffer(str + '\n', "utf8");
		verbose && console.log(str);
		if (logfd) fs.writeSync(logfd, buf, 0, buf.length);
		else console.error(str);
	}
	try {		
		var child = spawn(process.execPath, nodeOpts.concat([__dirname + "/../../deps/node-qunit/lib/bootstrap.js", JSON.stringify(opts)]));
		child.stdout.setEncoding("utf8");
		var reader = ez.devices.node.reader(child.stdout).transform(ez.transforms.lines.parser());
		child.stderr.setEncoding("utf8");
		child.stderr.on("data", function(data) {
			log(data.substring(0, data.length - 1)); // eliminate trailing \n
		});
		var str;
		var tests = [];
		var resi = results.length;
		var gotMarker;
		while (child && (str = reader.read(_)) != undefined) {
		    if (str[0] == "{") {
		        try {
		            var result = JSON.parse(str);
		            if (result.shutdown && result.xqz === "t@)$") {
		                child.kill();
		                child = null;
		                gotMarker = true;
		            } else {
		                if (!harmony && result.errorStack && result.errorStack.indexOf("SyntaxError: Unexpected token *") >= 0) {
		                    result.message = "TEST SKIPPED (requires V8 generators)";
		                    delete result.errorStack;
		                    str = JSON.stringify(result);
		                }
		                if (result.test !== undefined && result.xqz === "t@)$") {
		                    tests.push(result);
		                } else if (result.errorStack !== undefined && result.xqz === "t@)$") {
		                    log(str);
		                    results.push(result);
		                } else if (result.message !== undefined && result.xqz === "t@)$") {
		                    log(str);
		                    results.push(result);
		                } else {
		                    log(str);
		                }
		            }
		        } catch (ex) {
		            log(str);
		        }
		    } else {
		        log(str);
		    }
		}
		var summary = {
		    module: file,
            pass: true,
		    expect: 0,
		    got: 0,
            error: 0
		};
		if (!gotMarker) {
			summary.pass = false;
			summary.error = 1;
			results.push({
				module: "bootstrap",
				name: file,
				message: "process exited abnormally",
				errorStack: "Abnormal process exit",
			});
		}

		tests.forEach(function(test) {
		    test.got = 0;
		    test.error = 0;
			while (resi < results.length && results[resi].name === test.test) {
			    if (results[resi].errorStack !== undefined) test.error++;
			    else if (results[resi].done == null) test.got++;
				resi++;
			}
			var resultSummary = {
			    module: test.module,
			    name: test.test
			};
			if (test.error > 0) {
				summary.pass = false;
				resultSummary.message = "Errors encountered";
				resultSummary.errorStack = "Completed " + test.got + " tests, " + test.error + " errors";
			} else if (test.expect != null) {
				if (test.got !== test.expect) {
					summary.pass = false;
					resultSummary.message = "bad result count";
					resultSummary.errorStack = "Expected " + test.expect + " results, got " + test.got + ", encountered " + test.error + " errors";
				} else {
					resultSummary.message = "Successfully completed " + test.got + " of " + test.expect + " tests";
				}
				summary.expect += test.expect;
			} else {
				resultSummary.message = "Completed " + test.got + " tests";
			}
			results.splice(resi, 0, resultSummary);
			resi++;
			str = JSON.stringify(resultSummary);
			log(str);
			summary.got += test.got;
			summary.error += test.error;
		});

		var prefix, clr;
		if (summary.pass) {
			if (summary.got > 0) {
				prefix = "PASS";
				clr = "green";
			} else {
				prefix = "SKIP";
				clr = "yellow";
			}
		} else {
			prefix = "FAIL";
			clr = "red";
		}
		var message = prefix + " Module " + summary.module + " Exp: " + summary.expect + " Got: " + summary.got + " Err: " + summary.error;
		console.log(colors[clr](message));
    } finally {
		fs.closeSync(logfd);
		logfd = null;
	}
}

function _runServer(_, files, verbose) {
    var results = [];
    files.forEach_(_, function (_, file) {
        _runFile(_, file, verbose, results);
    });

    // Results are returned for display by UI when running from html page
	return JSON.stringify(results);
}

exports.runUnitTest = function(_, file, verbose) {
	var results = [];
	_runFile(_, file, verbose, results);
	return results;
};

exports.dispatch = function(_, request, response) {
	function jsonReply(obj) {
		var json = typeof obj === "string" ? obj : JSON.stringify(obj);
		response.writeHead(200, {
			'content-type': 'application/json',
			//'content-length': json.length
		});
		response.end(json, "utf8");
	}
	try {
		var result;
		switch (request.url) {
			case '/tests/files':
				jsonReply({
					client: _getFiles(_, "client"),
					server: _getFiles(_, "server")
				});
				break;
			case '/tests/start':
				jsonReply(_runServer(_, JSON.parse(request.readAll(_)), false));
				break;
			default:
				response.writeHead(404);
				response.end("resource not found: " + request.url);
		}
	} catch (ex) {
		console.error(ex.stack);
		response.writeHead(500);
		response.end(ex.stack);
	}
};
function _formatOutputUrl(program) {
    var outUrl;
    // http out takes precedence over mongo
    if (program.httpOut) {
        outUrl = "http://" + program.httpOut;
        if (program.httpPort) outUrl += ":" + program.httpPort;
        if (program.httpPath) outUrl += "/" + program.httpPath;
    } else {
        // Assume mongo
        outUrl = "mongodb://" + program.mongoServer;
        outUrl += ":" + program.mongoPort ? program.mongoPort: "27017";
        outUrl += "/" + program.mongoDb ? program.mongoDb: "syr_unittest";
        outUrl += "/" + program.mongoCollection ? program.mongoCollection: "UnitTestResult";
    }

}

function runIt(_) {
    // parse command line input via commander
    program
        .version('0.0.1')
        .option('-f, --filter <error|summary>', 'send only error or summary results to output')
        .option('-h, --httpOut <hostname>', 'send output to http host')
        .option('-i, --httpPort <port>', 'optional port for http server')
        .option('-u, --httpPath <path>', 'optional path to append to http url')
        .option('-m, --mongoServer <mongoserver>', 'send output to mongodb (default collection unless specified)')
        .option('-p, --mongoPort <portno>', 'port number for mongodb (default 27017 if not specified)')
        .option('-d, --mongoDb <database>', 'mongodb database name (default syr_unittest)')
        .option('-c, --mongoCollection <collection>', 'send output to specific mongodb collection (default UnitTestResult)')
        .option('-t, --testFolder <folder>', 'run only tests for the specified root folder')
        .option('-s, --stopOnFirstError', 'stop after encountering the first error in the run')
        .option('-v, --verbose', 'Verbose output to the console')
        .parse(process.argv);

    var folder = program.testFolder;
	var files = _getFiles(_, "server").filter(function(f) {
	    return !folder || ~f.indexOf(folder);
	});

    // we want to store the result test by test so loop here
	var rapport = {
	    runDate: (new Date()),
	    tests: []
	};
	if (!program.filter) rapport.details = true;
	files.forEach_(_, function (_, file) {
	    var start = (new Date()).getTime(), errors = 0;
	    var results = [];
	    _runFile(_, file, program.verbose, results);
	    var res = results.map(function (it) {
	        return {
	            message: it.message,
	            name: it.name,
	            status: it.errorStack ? "error" : "success"
	        }
	    });
	    var diff = (new Date()).getTime() - start;
	    var testRes = {
	        duration: diff,
	        module: file,
	        status: res.some(function (it) { return it.status === "error"; }) ? "error" : "success"
	    };

	    if (testRes.status === "error") errorStatus++;

        // I've kept this filter in, but I'm not sure if it is going to be needed
	    if (program.filter) {
	        testRes.tests = res.filter(function (tt) {
	            return tt.status === program.filter;
	        })
	    } else {
	        testRes.tests = res;
	    }
	    rapport.tests.push(testRes);
	});
	if (program.httpOut || program.mongoServer) {
	    console.log("Writing result to " + runOpt.out, rapport);
	    rapport.status = rapport.tests.some(function (it) { return it.status === "error"; }) ? "error" : "success";
	    var writer = ez.factory(_formatOutputUrl(program)).writer(_);
	    writer.write(_, rapport);
	    writer.write(_, undefined);
	}

	if (errorStatus !== 0) {
	    console.log('Errors encountered in ' + errorStatus + ' unit tests. See log for details.');
	}
}

exports.run = function() {
	runIt(function(err) {
		    if (err) throw err;
		    process.exit(errorStatus === 0 ? 0 : 1);
		});

};

exports.getFiles = function(_, tier) {
	return _getFiles(_, tier);
};
