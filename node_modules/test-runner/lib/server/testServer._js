"use strict";

var pathUtil = require("path");
var fs = require('streamline-fs');
var nodeQUnit = require("../../deps/node-qunit/lib/index");
var spawn = require("child_process").spawn;
var streamline = require("streamline/lib/compiler/register");
var ez = require('ez-streams');
var MongoClient = require('streamline-mongodb').MongoClient;
var ezmongo = require('ez-mongodb');
var globals = require("streamline/lib/globals");
var config = require('config');
var program = require('commander');

//var QUnit = require('../support/qunit/qunit/qunit.js');

nodeQUnit.options.coverage = false;
nodeQUnit.options.errorsOnly = true;
nodeQUnit.options.errorStack = true;
nodeQUnit.options.summary = true;


function doDir(_, root, path, rPath, depth, result, tier) {
	function _dirOk(file) {
		switch (depth) {
			case 0:
				return rPath ? rPath.test(file) : true;
			case 1:
				return file == "test";
			case 2:
				return file == "common" || file == tier;
			default:
				return false;
		}
	}

	var files = fs.readdir(root + path, _);
	files.forEach_(_, function(_, file, i) {
		var fpath = path + "/" + file;
		var stats = fs.lstat(root + fpath, _);
		if (stats.isDirectory()) {
			if (_dirOk(file)) doDir(_, root, fpath, rPath, depth + 1, result, tier);
		} else if (stats.isFile()) {
			var match;
			if (depth == 3 && (match = /(^[^.].*)\.(_?js|src)$/.exec(file))) {
				if (match[2] === 'src' && !config.etna) return;
				var name = path + "/" + match[1];
				if (tier === 'client' && name.indexOf('--fibers') > 0) return;
				if (name[name.length - 1] != "_") result.push(name.substring(1));
			}
		}
	});
}

function _getFiles(_, tier) {
	var result = [];

	if (config.unit_test && config.unit_test.rootDirs) {
		config.unit_test.rootDirs.forEach_(_, function(_, rootDir) {
			var root = (!rootDir.root || rootDir.root == ".") ? pathUtil.join(__dirname, "../../..") : rootDir.root;
			var rPath = new RegExp((rootDir.module) ? rootDir.module : ".*");
			doDir(_, root, "", rPath, 0, result, tier);
		});
	} else {
		doDir(_, pathUtil.join(__dirname, "../../.."), "", /.*/, 0, result, tier);
	}
	return result;
}

function _runFile(_, file, verbose, results, summary) {
	var opts = {
		code: file,
		tests: [file],
		coverage: false,
		errorsOnly: false,
		errorStack: true,
		summary: true,
		streamline: streamline.options,
		tenantId: globals.context.tenantId,
		etna: !!config.etna,
	};
	var nodeOpts = ["--debug"];
	var harmony = false;
	try {
		eval("(function*(){})");
		nodeOpts.push("--harmony");
		harmony = true;
	} catch (ex) {}

	if (!harmony && /galaxy/.test(file)) return;

	verbose && console.log("======> UNIT TEST " + file);

	var logpath = pathUtil.join(__dirname, "../../..") + '/' + file + '.testlog';
	var logfd = fs.openSync(logpath, 'w');

	function log(str) {
		var buf = new Buffer(str + '\n', "utf8");
		verbose && console.log(str);
		fs.writeSync(logfd, buf, 0, buf.length);
	}
	try {		
		var child = spawn(process.execPath, nodeOpts.concat([__dirname + "/../../deps/node-qunit/lib/bootstrap.js", JSON.stringify(opts)]));
		child.stdout.setEncoding("utf8");
		var reader = ez.devices.node.reader(child.stdout).transform(ez.transforms.lines.parser());
		child.stderr.setEncoding("utf8");
		child.stderr.on("data", function(data) {
			log(data.substring(0, data.length - 1)); // eliminate trailing \n
		});
		var str;
		var tests = [];
		var resi = results.length;
		while ((str = reader.read(_)) != undefined) {
		    if (str[0] == "{") {
		        try {
		            var result = JSON.parse(str);
		            if (result.shutdown && result.xqz === "t@)$") {
		                child.kill();
		            } else {
		                if (!harmony && result.errorStack && result.errorStack.indexOf("SyntaxError: Unexpected token *") >= 0) {
		                    result.message = "TEST SKIPPED (requires V8 generators)";
		                    delete result.errorStack;
		                    str = JSON.stringify(result);
		                }
		                if (result.test !== undefined && result.xqz === "t@)$") {
		                    tests.push(result);
		                } else if (result.errorStack !== undefined && result.xqz === "t@)$") {
		                    log(str);
		                    results.push(result);
		                } else if (result.message !== undefined && result.xqz === "t@)$") {
		                    log(str);
		                    results.push(result);
		                } else {
		                    log(str);
		                }
		            }
		        } catch (ex) {
		            log(str);
		        }
		    } else {
		        log(str);
		    }
		}
		var testSummary = {
		    module: file,
            pass: true,
		    expect: 0,
		    got: 0,
            error: 0
		};

		tests.forEach(function(test) {
		    test.got = 0;
		    test.error = 0;
			while (resi < results.length && results[resi].name === test.test) {
			    if (results[resi].errorStack !== undefined) test.error++;
			    else if (results[resi].done == null) test.got++;
				resi++;
			}
			var resultSummary = {
			    module: test.module,
			    name: test.test
			};
			if (test.expect != null) {
			    if (test.got !== test.expect) {
			        summary.pass = false;
			        resultSummary.message = "bad result count";
			        resultSummary.errorStack = "Expected " + test.expect + " results, got " + test.got + ", encountered " + test.error + " errors";
			    } else {
			        resultSummary.message = "Successfully completed " + test.got + " of " + test.expect + " tests";
			    }
			    summary.expect += test.expect;
			} else {
			    if (test.error > 0) {
			        summary.pass = false;
			        resultSummary.message = "Errors encountered";
			        resultSummary.errorStack = "Completed " + test.got + " tests, " + test.error + " errors";
			    } else {
			        resultSummary.message = "Completed " + test.got + " tests";
			    }
			}
			results.splice(resi, 0, resultSummary);
			resi++;
			str = JSON.stringify(resultSummary);
			log(str);
			summary.got += test.got;
			summary.error += test.error;
		});
	} finally {
		fs.closeSync(logfd);
	}
}

function _runServer(_, files, verbose, stopOnError) {
    var results = [], errors = 0;
    files.forEach_(_, function (_, file) {
        var summary = {
            module: file,
            pass: true,
            expect: 0,
            got: 0,
            error: 0
        };
        _runFile(_, file, verbose, results, summary);
        console.log((summary.pass ? "PASS" : "FAIL") + " Module " + summary.module + " Exp: " + summary.expect + " Got: " + summary.got + " Err: " + summary.error);
        if (!summary.pass) {
            if (stopOnError) {
                throw new Error('Stopped immediately after error in test: ' + file);
            } else {
                errors++;
            }
        }
    });

    if (errors !== 0) {
        throw new Error('Errors encountered in ' + errors + ' unit tests. See log for details.');
    }

    // Not sure how useful this is - leave it in place for now
	return JSON.stringify(results);
}

exports.runUnitTest = function(_, file, verbose) {
	var results = [];
    var summary = [];
	_runFile(_, file, verbose, results, summary);
	return results;
};

exports.dispatch = function(_, request, response) {
	function jsonReply(obj) {
		var json = typeof obj === "string" ? obj : JSON.stringify(obj);
		response.writeHead(200, {
			'content-type': 'application/json',
			//'content-length': json.length
		});
		response.end(json, "utf8");
	}
	try {
		var result;
		switch (request.url) {
			case '/tests/files':
				jsonReply({
					client: _getFiles(_, "client"),
					server: _getFiles(_, "server")
				});
				break;
			case '/tests/start':
				jsonReply(_runServer(_, JSON.parse(request.readAll(_))));
				break;
			default:
				response.writeHead(404);
				response.end("resource not found: " + request.url);
		}
	} catch (ex) {
		response.writeHead(500);
		response.end(ex.message + '\n' + ex.stack);
	}
};

function runIt(_) {
    // parse command line input via commander
    program
        .version('0.0.1')
        .option('-h, --httpOut <url>', 'send output to http server')
        .option('-m, --mongoServer <mongoserver>', 'send output to mongodb (default collection unless specified)')
        .option('-p, --mongoPort <portno>', 'port number for mongodb (default 27017 if not specified)')
        .option('-d, --mongoDb <portno>', 'port number for  (default syr_unittest if not specified)')
        .option('-c, --mongoCollection <collection>', 'send output to specific mongodb collection (default UnitTestResult)')
        .option('-t, --testFolder <folder>', 'run only tests for the specified root folder')
        .option('-s, --stopOnFirstError', 'stop after encountering the first error in the run')
        .option('-v, --verbose', 'Verbose output to the console')
        .parse(process.argv);

    var folder = program.testFolder;
	var files = _getFiles(_, "server").filter(function(f) {
	    return !folder || ~f.indexOf(folder);
	});
	_runServer(_, files, program.verbose, program.stopOnFirstError);
	//nodeQUnit.run(files, function(report) {
	// summary option is set => report is already printed
	// console.log(JSON.stringify(report));
	//});
}

exports.run = function() {
	runIt(_ >>
		function(err) {
			if (err) throw err;
		});
};

exports.getFiles = function(_, tier) {
	return _getFiles(_, tier);
};
