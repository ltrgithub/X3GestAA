"use strict";
var sys = require("util");
var url = require("url");
var fs = require("fs");
var ez = require('ez-streams');
var jsxml = require("jsxml/lib/jsxml");
var helpers = require('syracuse-core/lib/helpers');
var util = require('etna-engine/lib/runtime/util');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var config = require("config");
var breakpoint = require('etna-engine/lib/debugger/breakpoint');

function log(s) {
	console.error("DebugContext." + s);
}

function DebugContext(socket) {

	this.readCommand = function(_) {
		var seg = [],
			c, cmd;
		while ((c = socket.read(_, 1))) {
			if (c[0] === 0)
				break;
			seg.push(c[0]);
		}

		cmd = new Buffer(seg).toString('utf8');
		// log("readCommand cmd= " + cmd);
		return cmd;
	};

	this.write = function(_, data) {
		if (data instanceof DbgpResponse) {
			data = data.toString(this.indent);
		} else if (typeof(data) === "object") {
			data = jsxml.stringify(data, this.indent);
		}
		// log("write: " + data);
		socket.write(_, [Buffer.byteLength(data, 'utf8'), data, ""].join("\0"));
	};

	this.close = function() {
		socket.end();
		socket.destroy();
		socket = null;
	};

	this.getDescription = function() {
		return socket.localAddress + ":" + socket.localPort;
	};

	Object.defineProperty(this, 'isActive', {
		get: function() {
			return socket && !socket.closed;
		}
	});

	this.features = {
		"language_supports_threads": "0",
		"language_name": "x3-etna",
		"language_version": "9.0",
		"encoding": "UTF-8",
		"data_encoding": "base64",
		"protocol_version": "1",
		"supports_async": "0",
		// seems not to be called by Eclipse DLTK framework
		"breakpoint_types": "line conditional exception watch",
		"multiple_sessions": "0",
		// max number of array or object children to initially retrieve
		"max_children": 100,
		// max amount of variable data to initially retrieve
		"max_data": 8192,
		// maximum depth that the debugger engine may return when sending arrays, hashs or object structures to the IDE.
		"max_depth": 2
	};

	this.breakpointsById = {};
	this.breakpointsByLocation = {};
}

exports.DebugContext = helpers.defineClass(DebugContext, null, {
	listen: function(_) {
		try {
			var cmd;
			while (!this.session && (cmd = this.readCommand(_))) {
				this.interpret(_, cmd);
			}
		} catch (e) {
			this.abort("Debug listening aborted", e);
		}
	},
	hit: function(_, frame, request) {
		this.frame = frame;
		this.request = request;
		try {
			if (this.state === "init") {
				this.state = "attached";
				this.write(_, getInitMessage());
			}
			if (this.status === "break") {
				var cmd, debug = frame && frame.sub && frame.sub.debug || {},
					mod = typeof(debug.module) === "string" ? debug.module.substring(0, debug.module.lastIndexOf(".")) : "";
				log("hit: " + debug.instruction + " in " + mod + ":" + debug.location.line + ", status=" + this.status);
				this.leave = false;
				while (!this.leave && this.status === "break" && (cmd = this.readCommand(_))) {
					this.interpret(_, cmd);
				}
			}
		} catch (e) {
			this.abort("Debug session aborted", e);
		}
	},
	interpret: function(_, commandLine) {
		var parts = commandLine.split(/ /g),
			cmd = parts[0] && parts[0].toLowerCase().replace(/-/g, "_"),
			command = _commandsMap[cmd],
			options = {},
			resp;
		for (var i = 1, len = parts.length; i < len; i++) {
			if (parts[i][0] === "-") {
				options[parts[i].substring(1)] = parts[++i];
			}
		}
		// log("interpret: '" + commandLine + "' parts=" + parts + " => command=" + typeof(command));
		if (command) {
			resp = newResponse(cmd, options);
			try {
				command.call(this, _, resp, options);
			} catch (e) {
				resp.error = {
					$: {
						code: 500,
						apperr: 0
					},
					message: {
						$value: e.message + ((config.system || {}).enableDevelopmentFeatures ? e.stack : "")
					}
				};
			}
		}

		if (resp)
			this.write(_, resp);
	},
	setStatus: function(resp, status, reason) {
		this.status = status || this.status;
		resp.$.status = this.status;
		resp.$.reason = reason || "ok";
	},
	abort: function(m, e) {
		this.state = "detached";
		this.status = "stopped";
		console.error(m + (e ? ": " + e.message : "") + e.stack);
		// console.error(m + (e ? ": " + e.message : ""));
	}
});


var _commandsMap = {
	list: function(_, resp, options) {
		var sessions = sessionManager.getTenantSessions();
		// log("list: sessions\n" + Object.keys(sessions).join("\n"));
		resp.session = Object.keys(sessions).map(function(s) {
			return {
				$: {
					id: s
				}
			};
		});
	},
	options: function(_, resp, options) {
		var beautify = /s(\d*)/.exec(options.b);
		if (beautify)
			this.indent = new Array(~~beautify[1] + 1).join(" ");
		else
			this.indent = options.b === "t" ? "\t" : null;

	},
	attach: function(_, resp, options) {
		var id = options.s,
			session = id && sessionManager.sessionById(id);

		if (session) {
			this.status = "break";
			this.state = "init";
			session.debugContext = this;
			this.session = session;
		}
		// log("attach: id=" + id + ", session=" + sys.inspect(session, {
		// 	depth: 3
		// }));
		// log("attach: id=" + id + ", session=" + typeof(session));
		resp.$.session = id || "";
		this.setStatus(resp);
	},

	// ====================================================
	// DGBP protocol standard commands
	// see http://xdebug.org/docs-dbgp.php
	// ====================================================

	// status
	status: function(_, resp, options) {
		this.setStatus(resp);
		// resp.$value = "message....";
	},

	// feature_get
	// -n	feature_name
	feature_get: function(_, resp, options) {
		var name = options.n || "",
			value = this.features[name];
		resp.$.feature_name = name;
		resp.$.supported = ~~ (value != null);
		resp.$value = value;
	},

	// feature_set
	// -n	feature_name
	// -v	value to be set
	feature_set: function(_, resp, options) {
		var name = options.n;
		// max_depth cannot be set to a different value because of an issue in Eclipse DLTK framework
		if (name && name != "max_depth")
			this.features[name] = options.v;
		resp.$.feature = name;
		resp.$.success = ~~ (this.features[name] != null);
	},

	// run
	run: function(_, resp, options) {
		// TODO
		this.setStatus(resp);
	},

	// step_into
	step_into: function(_, resp, options) {
		// TODO
		this.leave = true;
		this.setStatus(resp);
	},

	// step_over
	step_over: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
	},

	// step_out
	step_out: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
	},

	// stop
	stop: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
	},

	// detach
	detach: function(_, resp, options) {
		this.leave = true;
		this.session.debugContext = null;
		// TODO
		this.status = "run";
		this.setStatus(resp);
	},

	// BREAKPOINTS
	// Type			Req'd Attrs				Description
	// line			filename, lineno		break on the given lineno in the given file
	// call			function				break on entry into new stack for function name
	// return		function				break on exit from stack for function name
	// exception	exception				break on exception of the given name
	// conditional	expression, filename	break when the given expression is true at the given filename and line number or just in given filename
	// watch		expression				break on write of the variable or address defined by the expression argument

	// breakpoint_set
	// -t TYPE			breakpoint type, see above for valid values [required]
	// -s STATE			breakpoint state [optional, defaults to "enabled"]
	// -f FILENAME		the filename to which the breakpoint belongs [optional]
	// -n LINENO		the line number (lineno) of the breakpoint [optional]
	// -m FUNCTION		function name [required for call or return breakpoint types]
	// -x EXCEPTION		exception name [required for exception breakpoint types]
	// -h HIT_VALUE		hit value (hit_value) used with the hit condition to determine if should break; a value of zero indicates hit count processing is disabled for this breakpoint [optional, defaults to zero (i.e. disabled)]
	// -o HIT_CONDITION	hit condition string (hit_condition); see hit_condition documentation above; BTW 'o' stands for 'operator' [optional, defaults to '>=']
	// -r 0|1			Boolean value indicating if this breakpoint is temporary. [optional, defaults to false]
	// -- EXPRESSION	code expression, in the language of the debugger engine. The breakpoint should activate when the evaluated code evaluates to true. [required for conditional breakpoint types]
	breakpoint_set: function(_, resp, options) {
		var bpOptions = Object.keys(options).reduce(function(r, k) {
			return r[_bpOptionMap[k]] = options[k];
		}, {});
		var bp = this.addBreakpoint(bpOptions);
		resp.$.state = bp.$state;
		resp.$.id = bp.$id;
	},

	addBreakpoint: function(bpOptions) {
		var bp = breakpoint.create(bpOptions);
		this.breakpointsById[bp.$id] = bp;
		return bp;
	},

	getBreakpoint: function(id) {
		var bp = this.breakpointsById[bp.$id];
	}

	// breakpoint_get
	// -d BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	// returns:
	// <response command="breakpoint_get"
	//           transaction_id="TRANSACTION_ID">
	//     <breakpoint id="BREAKPOINT_ID"
	//                 type="TYPE"
	//                 state="STATE"
	//                 filename="FILENAME"
	//                 lineno="LINENO"
	//                 function="FUNCTION"
	//                 exception="EXCEPTION"
	//                 expression="EXPRESSION"
	//                 hit_value="HIT_VALUE"
	//                 hit_condition="HIT_CONDITION"
	//                 hit_count="HIT_COUNT">
	//         <expression>EXPRESSION</expression>
	//     </breakpoint>
	// </response>	
	breakpoint_get: function(_, resp, options) {
		var bp = this.getBreakpoint(options.d);
		resp.breakpoint = {
			$: {
				id: bp.$id,
				type: bp.$type,
			},
			expression: {
				$value: ""
			}
		};
	},

	// breakpoint_update
	// -s	STATE
	// -n	LINENO
	// -h	HIT_VALUE
	// -o	HIT_CONDITION	
	breakpoint_update: function(_, resp, options) {
		throw new Error("NIY");
	},

	// breakpoint_remove
	// -d BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	breakpoint_remove: function(_, resp, options) {
		throw new Error("NIY");
	},

	// breakpoint_list
	breakpoint_list: function(_, resp, options) {
		throw new Error("NIY");
	},

	// stack_depth
	stack_depth: function(_, resp, options) {
		// TODO
		resp.$.depth = 10;
	},

	// stack_get
	// -d	stack depth (optional)
	stack_get: function(_, resp, options) {
		resp.stack = [];
		var sub = this.frame && this.frame.sub;
		// log("stack_get: frame.sub=" + sys.inspect(sub));
		if (sub) {
			var frm = this.frame,
				loc, stackinfo, debug, level = 0;
			while (sub) {
				debug = sub.debug || {};
				loc = debug && debug.location || {};
				stackinfo = {
					level: level++,
					type: debug.module ? "file" : "builtin",
					filename: loc.file,
					lineno: loc.line,
					where: (debug.module ? debug.module + "." : "") + (debug.instruction || ""),
					// cmdbegin: "line_number:offset",
					// cmdend: "line_number:offset"
				};
				resp.stack.push({
					$: stackinfo
				});
				sub = sub.prev;
			}
		}
	},

	// context_names
	// -d	stack depth (optional)
	context_names: function(_, resp, options) {
		resp.context = [{
				name: "Local",
				id: 0
			}
			// , {
			// 	name: "Global",
			// 	id: 1
			// }, {
			// 	name: "Class",
			// 	id: 2
			// }
		];
	},

	// context_get
	// -d	stack depth (optional)
	// -c	context id (optional, retrieved by context-names)
	context_get: function(_, resp, options) {
		var ctxid = ~~options.c,
			depth = ~~options.d,
			frame = this.frame,
			sub = this.frame && this.frame.sub,
			values = frame.values;

		while (depth-- && frame.prev) {
			frame = frame.prev;
		}
		sub = frame.sub;
		// values = values.THIS.slots;
		resp.$.context = ctxid;
		// log("context_get: frame=" + sys.inspect(this.frame));
		log("context_get: values=" + sys.inspect(values));
		switch (ctxid) {
			// Local
			case 0:
				resp.property = getProperty(null, "", values, {
					sub: sub,
					features: this.features
				});
				break;

				// Global: NIY
			case 1:
				throw new Error("NIY");
		}
	},

	// property_get
	// -d	stack depth (optional, debugger engine should assume zero if not provided)
	// -c	context id (optional, retrieved by context-names, debugger engine should assume zero if not provided)
	// -n	property long name (required)
	// -m	max data size to retrieve (optional, defaults to the length as negotiated through feature_set with max_data). 0 means unlimited data.
	// -t	data type (property_set only, optional)
	// -p	data page (property_get, property_value: optional for arrays, hashes, objects, etc.; property_set: not required; debugger engine should assume zero if not provided)
	// -k	property key as retrieved in a property element, optional, used for property_get of children and property_value, required if it was provided by the debugger engine.
	// -a	property address as retrieved in a property element, optional, used for property_set/value
	property_get: function(_, resp, options) {
		var longName = options.n;

		if (!longName)
			throw new Error("Missing options -n");

		throw new Error("NIY");
	},

	// property_set
	// -d	stack depth (optional, debugger engine should assume zero if not provided)
	// -c	context id (optional, retrieved by context-names, debugger engine should assume zero if not provided)
	// -n	property long name (required)
	// -m	max data size to retrieve (optional, defaults to the length as negotiated through feature_set with max_data). 0 means unlimited data.
	// -t	data type (property_set only, optional)
	// -p	data page (property_get, property_value: optional for arrays, hashes, objects, etc.; property_set: not required; debugger engine should assume zero if not provided)
	// -k	property key as retrieved in a property element, optional, used for property_get of children and property_value, required if it was provided by the debugger engine.
	// -a	property address as retrieved in a property element, optional, used for property_set/value
	property_set: function(_, resp, options) {
		throw new Error("NIY");
	},

	// source
	// -b	begin line (optional)
	// -e	end line (optional)
	// -f	file URI
	// In the legacy version uri is in the form "x3://AWS-X3-DEVSUP.sagefr.adinternal.com:17000/SUPERV/GOBJSUB.src"
	source: function(_, resp, options) {
		var uri = url.parse(options.f),
			segments = uri.pathname.split("/"),
			file = segments[segments.length - 1],
			ext = file && file.substring(file.lastIndexOf('.') + 1),
			frame = this.frame,
			fullpath = [frame.context.superv.solutionPath.replace(/\\/g, '/'), segments[1], _folderMap[ext], file].join("/"),
			source = getSource(fullpath, options.b, options.e);

		resp.$.success = ~~ (source != null);
		resp.$value = source;
	},

	// stdout
	// -c	[0|1|2] 0 - disable, 1 - copy data, 2 - redirection
	stdout: function(_, resp, options) {
		throw new Error("NIY");
	},

	// ====================================================
	// DGBP protocol Extended Commands
	// ====================================================

	// stdin
	stdin: function(_, resp, options) {
		throw new Error("NIY");
	},

	// break
	break: function(_, resp, options) {
		throw new Error("NIY");
	},

	// eval
	eval: function(_, resp, options) {
		throw new Error("NIY");
	},

	// interact
	interact: function(_, resp, options) {
		throw new Error("NIY");
	},

};

var _folderMap = {
	"src": "TRT",
	"adx": "TRT",
	"stc": "STC"
};

function getProperty(parents, name, value, context) {
	parents = parents || [];
	var parent = parents[0],
		descendents,
		depth = parents.length,
		sub = context.sub,
		features = context.features;

	if (depth > features.max_depth)
		return;

	var vtype = value === null ? "null" : typeof(value);
	var type = dbgpType(value) || vtype,
		prop = {
			$: {
				name: name,
				fullname: (parent && parent.$.fullname ? parent.$.fullname + "." : "") + (typeof(name) === "string" ? name : "(" + name + ")"),
				type: type,
				// classname:"name_of_object_class",
				// constant: "0|1",
				children: 0,
				// size: "{NUM}",
				// page: "{NUM}",
				// pagesize: "{NUM}",
				// address: "{NUM}",
				// key: "language_dependent_key",
				// encoding: "none",
				// numchildren: "{NUM}",
			}
		};

	// if (parent == null)
	// 	log("getProperty: property=" + sys.inspect(value, {
	// 		depth: 3
	// 	}));
	// log("getProperty: parent=" + parent + ", name=" + name + ", value=" + value + ", type=" + type);
	descendents = [prop].concat(parents);
	if (Array.isArray(value)) {
		prop.$.type = "array";
		prop.$.children = 1;
		prop.$.numchildren = value.length;
		prop.$.pagesize = features.max_children;
		if (context.pageNumber)
			prop.$.page = context.pageNumber;
		prop.$.size = value.length;

		prop.property = value.map(function(e, i) {
			return getProperty(descendents, i, e, context);
		});
	} else if (vtype === "object") {
		var keys = Object.keys(value);
		prop.$.type = "object";
		prop.$.children = 1;
		prop.$.numchildren = keys.length;
		prop.$.pagesize = features.max_children;
		if (context.pageNumber)
			prop.$.page = context.pageNumber;
		prop.$.size = keys.length;

		prop.property = keys.map(function(k) {
			return getProperty(descendents, k, value[k], context);
		});
		if (parent == null)
			return prop.property;
	} else {
		if (value instanceof Buffer) {
			prop.$.encoding = "base64";
			prop.$value = value.toString('base64');
		} else {
			prop.$value = "" + value;
		}
	}
	return prop;
}

function newResponse(cmd, options) {
	return new DbgpResponse(cmd, options);
}

function DbgpResponse(cmd, options) {
	this.$ = {
		command: cmd,
		transaction_id: options.i
	};
}

DbgpResponse.prototype = {
	toString: function(indent) {
		return jsxml.stringify({
			response: this
		}, indent);
	}
};


function getInitMessage(options) {
	options = options || {};
	var idekey = options.idekey || "com.sage.x3.xdt.dltk.debugger.etna";
	return {
		init: {
			$: {
				idekey: idekey,
				session: options.baseurl + "/$debug?idekey=" + idekey + "&rtm=" + (options.rtm || "etna.9.0"),
				fileuri: "",
				thread: 0,
				parent: "",
				server: options.server || "", //"AWS-X3-DEVSUP.sagefr.adinternal.com:17000/SUPERV/erbou/101007375",
				language: "x3-etna",
				protocol_version: "1.0"
			},
			engine: {
				$: {
					version: (options.rtm || "etna.9.0")
				}
			},
			author: {
				$value: "Sage"
			},
			url: {
				$cdata: "http://www.sage.com"
			},
			copyright: {
				$cdata: "Copyright (c) 2000-2015 Sage"
			},
		}
	};
}

function dbgpType(value) {
	return util.x3Typename(value);
}

var _sourceCache = {};

function getSource(path, begin, end) {
	path = path.replace(/\\/g, '/');
	// Basic source cache for testing. Need improvement
	var source = _sourceCache[path];
	if (source == null && fs.existsSync(path)) {
		source = _sourceCache[path] = fs.readFileSync(path, 'utf8');
	}
	if (source != null && (begin != null || end != null)) {
		var lines = source.split(/\n/);
		begin = ~~begin;
		end = end != null ? end : lines.length - 1;
		return lines.splice(begin, end).join("\n");
	}
	return source;
}


var _bpOptionMap = {
	"t": "type", //	breakpoint type, see above for valid values [required]
	"s": "state", //	breakpoint state [optional, defaults to "enabled"]
	"f": "filename", //	the filename to which the breakpoint belongs [optional]
	"n": "lineno", // the line number (lineno) of the breakpoint [optional]
	"m": "function", //	function name [required for call or return breakpoint types]
	"x": "exception", // exception name [required for exception breakpoint types]
	"h": "hit_value", // hit value (hit_value) used with the hit condition to determine if should break; a value of zero indicates hit count processing is disabled for this breakpoint [optional, defaults to zero (i.e. disabled)]
	"o": "hit_condition", //hit condition string (hit_condition); see hit_condition documentation above; BTW 'o' stands for 'operator' [optional, defaults to '>=']
	"r": "temporary", // 0|1 Boolean value indicating if this breakpoint is temporary. [optional, defaults to false]
	"-": "expression" //	code expression, in the language of the debugger engine. The breakpoint should activate when the evaluated code evaluates to true. [required for conditional breakpoint types]
};