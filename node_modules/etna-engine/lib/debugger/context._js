"use strict";
var sys = require("util");
var url = require("url");
var fs = require("fs");
var ez = require('ez-streams');
var jsxml = require("jsxml/lib/jsxml");
var helpers = require('syracuse-core/lib/helpers');
var util = require('etna-engine/lib/runtime/util');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var config = require("config");
var breakpoint = require('etna-engine/lib/debugger/breakpoint');
var evalue = require('etna-engine/lib/runtime/evaluate').evalue;

var log = {
	info: function(s) {
		console.error("[INFO] DebugContext." + s);
	},
	error: function(s, e) {
		console.error("[ERROR] DebugContext." + s + (e ? ": " + e.message + ((config.system || {}).exposeStacktrace ? "\n  at " + e.stack : "") : ""));
	}
};
// Status are: 
// starting - State prior to execution of any code
// stopping - State after completion of code execution. This typically happens at the end of code execution, allowing the IDE to further interact with the debugger engine (for example, to collect performance data, or use other extended commands).
// stopped  - IDE is detached from process, no further interaction is possible.
// running  - code is currently executing. Note that this state would only be seen with async support turned on, otherwise the typical state during IDE/debugger interaction would be 'break'
// break    - code execution is paused, for whatever reason (see below), and the IDE/debugger can pass information back and forth.

function DebugContext(socket) {

	this.readCommand = function(_) {
		var seg = [],
			c, cmd;
		while ((c = socket.read(_, 1))) {
			if (c[0] === 0)
				break;
			seg.push(c[0]);
		}

		cmd = new Buffer(seg).toString('utf8');
		// log.info("readCommand cmd= " + cmd);
		return cmd;
	};

	this.write = function(_, data) {
		if (data instanceof DbgpResponse) {
			data = data.toString(this.indent);
		} else if (typeof(data) === "object") {
			data = jsxml.stringify(data, this.indent);
		}
		// log.info("write: " + data);
		socket.write(_, [Buffer.byteLength(data, 'utf8'), data, ""].join("\0"));
	};

	this.close = function() {
		socket.end();
		socket.destroy();
		socket = null;
	};

	this.getDescription = function() {
		return socket.localAddress + ":" + socket.localPort;
	};

	Object.defineProperty(this, 'isActive', {
		get: function() {
			return socket && !socket.closed;
		}
	});

	this.features = {
		"language_supports_threads": "0",
		"language_name": "x3-etna",
		"language_version": "9.0",
		"encoding": "UTF-8",
		"data_encoding": "base64",
		"protocol_version": "1",
		"supports_async": "0",
		// seems not to be called by Eclipse DLTK framework
		"breakpoint_types": "line conditional exception watch",
		"multiple_sessions": "0",
		// max number of array or object children to initially retrieve
		"max_children": 100,
		// max amount of variable data to initially retrieve
		"max_data": 8192,
		// maximum depth that the debugger engine may return when sending arrays, hashs or object structures to the IDE.
		"max_depth": 2
	};

	this.breakpointsById = {};
	this.breakpointsByKey = {};
}

exports.DebugContext = helpers.defineClass(DebugContext, null, {
	listen: function(_) {
		try {
			var cmd;
			while (!this.session && (cmd = this.readCommand(_))) {
				this.interpret(_, cmd);
			}
		} catch (e) {
			this.abort("Debug listening aborted", e);
		}
	},
	hit: function(_, frame, request) {
		this.frame = frame;
		this.request = request;
		log.info("hit: state=" + this.state);
		try {
			if (this.state === "init") {
				this.state = "attached";
				this.write(_, getInitMessage());
			}
			if (this.status === "running" && this.breakOn(frame)) {
				this.status = "break";
			}
			if (this.status === "break") {
				var cmd, debug = frame && frame.sub && frame.sub.debug || {},
					mod = typeof(debug.module) === "string" ? debug.module.substring(0, debug.module.lastIndexOf(".")) : "";
				log.info("hit: " + debug.instruction + " in " + mod + ":" + debug.location.line + ", status=" + this.status);
				this.leave = false;
				while (!this.leave && this.status === "break" && (cmd = this.readCommand(_))) {
					this.interpret(_, cmd);
				}
			}
		} catch (e) {
			this.abort("Debug session aborted", e);
		}
	},
	interpret: function(_, commandLine) {
		var parts = commandLine.split(" "),
			cmd = parts[0] && parts[0].toLowerCase().replace(/-/g, "_"),
			command = _commandsMap[cmd],
			options = {},
			resp;
		for (var i = 1, len = parts.length; i < len; i++) {
			if (parts[i][0] === "-") {
				options[parts[i].substring(1)] = parts[++i];
			}
		}
		// log.info("interpret: '" + commandLine + "' parts=" + parts + " => command=" + typeof(command));
		if (command) {
			resp = newResponse(cmd, options);
			try {
				command.call(this, _, resp, options);
			} catch (e) {
				resp.error = {
					$: {
						code: 500,
						apperr: 0
					},
					message: {
						$value: e.message + ((config.system || {}).enableDevelopmentFeatures ? e.stack : "")
					}
				};
			}
		}

		if (resp)
			this.write(_, resp);
	},
	setStatus: function(resp, status, reason) {
		this.status = status || this.status;
		resp.$.status = this.status;
		resp.$.reason = reason || "ok";
	},
	abort: function(m, e) {
		this.state = "detached";
		this.status = "stopped";
		log.error(m, e);
		// log.error(m, e);
	},
	breakOn: function(frame) {
		var debug = frame && frame.sub && frame.sub.debug;
		if (!debug)
			return;

		// line breakpoints
		var mod = typeof(debug.module) === "string" && debug.module,
			bpkey;
		if (mod) {
			bpkey = mod + ":" + debug.location.line;
			var bp = this.getBreakpointByKey(bpkey);
			if (bp && bp.isEnabled())
				return true;
		}
	},
	_getFrame: function(depth) {
		var frame = this.frame;
		depth = ~~depth;
		while (depth-- && frame.prev) {
			frame = frame.prev;
		}
		return frame;
	},
	addBreakpoint: function(options) {
		var bp = breakpoint.createFromDbgpOptions(options),
			bp2 = this.getBreakpointByKey(bp.$key);
		if (bp2) {
			throw new Error("Duplicate breakpoint: " + bp.$key);
		}
		this.breakpointsById[bp.$id] = bp;
		this.breakpointsByKey[bp.$key] = bp;
		return bp;
	},
	getBreakpointById: function(id) {
		return this.breakpointsById[id];
	},

	getBreakpointByKey: function(key) {
		return this.breakpointsByKey[key];
	},


});

var _commandsMap = {
	list: function(_, resp, options) {
		var sessions = sessionManager.getTenantSessions();
		// log.info("list: sessions\n" + Object.keys(sessions).join("\n"));
		resp.session = Object.keys(sessions).map(function(s) {
			return {
				$: {
					id: s
				}
			};
		});
	},
	options: function(_, resp, options) {
		var beautify = /s(\d*)/.exec(options.b);
		if (beautify)
			this.indent = new Array(~~beautify[1] + 1).join(" ");
		else
			this.indent = options.b === "t" ? "\t" : null;

	},
	attach: function(_, resp, options) {
		var id = options.s,
			session = id && sessionManager.sessionById(id);

		log.info("attach: id=" + id + ", session=" + sys.inspect(session, {
			depth: 1
		}));
		if (session) {
			this.status = "break";
			this.state = "init";
			session.debugContext = this;
			this.session = session;
		}
		// log.info("attach: id=" + id + ", session=" + typeof(session));
		resp.$.session = id || "";
		this.setStatus(resp);
	},

	// ====================================================
	// DGBP protocol standard commands
	// see http://xdebug.org/docs-dbgp.php
	// ====================================================

	// status
	status: function(_, resp, options) {
		this.setStatus(resp);
		// resp.$value = "message....";
	},

	// feature_get
	// -n	feature_name
	feature_get: function(_, resp, options) {
		var name = options.n || "",
			value = this.features[name];
		resp.$.feature_name = name;
		resp.$.supported = ~~ (value != null);
		resp.$value = value;
	},

	// feature_set
	// -n	feature_name
	// -v	value to be set
	feature_set: function(_, resp, options) {
		var name = options.n;
		// max_depth cannot be set to a different value because of an issue in Eclipse DLTK framework
		if (name && name != "max_depth")
			this.features[name] = options.v;
		resp.$.feature = name;
		resp.$.success = ~~ (this.features[name] != null);
	},

	// run
	run: function(_, resp, options) {
		this.status = "running";
		// in sync mode status is always "break"
		// this.status = "break";
		this.setStatus(resp);
	},

	// step_into
	step_into: function(_, resp, options) {
		// TODO
		this.leave = true;
		this.setStatus(resp);
	},

	// step_over
	step_over: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
	},

	// step_out
	step_out: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
	},

	// stop
	stop: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
	},

	// detach
	detach: function(_, resp, options) {
		this.leave = true;
		this.session.debugContext = null;
		// TODO
		this.status = "stopped";
		this.setStatus(resp);
	},

	// BREAKPOINTS
	// Type			Req'd Attrs				Description
	// line			filename, lineno		break on the given lineno in the given file
	// call			function				break on entry into new stack for function name
	// return		function				break on exit from stack for function name
	// exception	exception				break on exception of the given name
	// conditional	expression, filename	break when the given expression is true at the given filename and line number or just in given filename
	// watch		expression				break on write of the variable or address defined by the expression argument

	// breakpoint_set
	// -t TYPE			breakpoint type, see above for valid values [required]
	// -s STATE			breakpoint state [optional, defaults to "enabled"]
	// -f FILENAME		the filename to which the breakpoint belongs [optional]
	// -n LINENO		the line number (lineno) of the breakpoint [optional]
	// -m FUNCTION		function name [required for call or return breakpoint types]
	// -x EXCEPTION		exception name [required for exception breakpoint types]
	// -h HIT_VALUE		hit value (hit_value) used with the hit condition to determine if should break; a value of zero indicates hit count processing is disabled for this breakpoint [optional, defaults to zero (i.e. disabled)]
	// -o HIT_CONDITION	hit condition string (hit_condition); see hit_condition documentation above; BTW 'o' stands for 'operator' [optional, defaults to '>=']
	// -r 0|1			Boolean value indicating if this breakpoint is temporary. [optional, defaults to false]
	// -- EXPRESSION	code expression, in the language of the debugger engine. The breakpoint should activate when the evaluated code evaluates to true. [required for conditional breakpoint types]
	breakpoint_set: function(_, resp, options) {
		var bp = this.addBreakpoint(options);
		resp.$.state = bp.$state;
		resp.$.id = bp.$id;
	},

	// breakpoint_get
	// -d BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	// returns:
	// <response command="breakpoint_get"
	//           transaction_id="TRANSACTION_ID">
	//     <breakpoint id="BREAKPOINT_ID"
	//                 type="TYPE"
	//                 state="STATE"
	//                 filename="FILENAME"
	//                 lineno="LINENO"
	//                 function="FUNCTION"
	//                 exception="EXCEPTION"
	//                 expression="EXPRESSION"
	//                 hit_value="HIT_VALUE"
	//                 hit_condition="HIT_CONDITION"
	//                 hit_count="HIT_COUNT">
	//         <expression>EXPRESSION</expression>
	//     </breakpoint>
	// </response>	
	breakpoint_get: function(_, resp, options) {
		var bp = this.getBreakpointById(options.d);
		if (!bp)
			return;
		resp.breakpoint = bp.getDbgpInfo();
	},

	// breakpoint_update
	// -d	BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	// -s	STATE
	// -n	LINENO
	// -h	HIT_VALUE
	// -o	HIT_CONDITION	
	breakpoint_update: function(_, resp, options) {
		var bp = this.getBreakpointById(options.d);
		if (bp) {
			bp.updateFromDbgpOptions(options);
		}
	},

	// breakpoint_remove
	// -d BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	breakpoint_remove: function(_, resp, options) {
		var bp = this.getBreakpointById(options.d);
		if (bp) {
			delete this.breakpointsById[bp.$id];
			delete this.breakpointsByKey[bp.$key];
		}
	},

	// breakpoint_list
	breakpoint_list: function(_, resp, options) {
		var bps = this.breakpointsById,
			list = resp.breakpoint = [];
		Object.keys(bps).forEach(function(k) {
			list.push(bps[k].getDbgpInfo());
		});
	},

	// stack_depth
	// Returns the maximum stack depth that can be returned by the debugger
	stack_depth: function(_, resp, options) {
		// TODO
		resp.$.depth = 10;
	},

	// stack_get
	// -d	stack depth (optional)
	stack_get: function(_, resp, options) {
		resp.stack = [];
		var sub = this.frame && this.frame.sub;
		// log.info("stack_get: frame.sub=" + sys.inspect(sub));
		if (sub) {
			var frm = this.frame,
				loc, stackinfo, debug, level = 0;
			while (sub) {
				debug = sub.debug || {};
				loc = debug && debug.location || {};
				stackinfo = {
					level: level++,
					type: debug.module ? "file" : "builtin",
					filename: loc.file,
					lineno: loc.line,
					where: (debug.module ? debug.module + "." : "") + (debug.instruction || ""),
					// cmdbegin: "line_number:offset",
					// cmdend: "line_number:offset"
				};
				resp.stack.push({
					$: stackinfo
				});
				sub = sub.prev;
			}
		}
	},

	// context_names
	// -d	stack depth (optional)
	context_names: function(_, resp, options) {
		resp.context = [{
				name: "Local",
				id: 0
			}
			// , {
			// 	name: "Global",
			// 	id: 1
			// }, {
			// 	name: "Class",
			// 	id: 2
			// }
		];
	},

	// context_get
	// -d	stack depth (optional)
	// -c	context id (optional, retrieved by context-names)
	context_get: function(_, resp, options) {
		var ctxid = ~~options.c,
			frame = this._getFrame(options.d),
			values = frame.values;

		resp.$.context = ctxid;
		// log.info("context_get: frame=" + sys.inspect(this.frame));
		// log.info("context_get: values=" + sys.inspect(values));
		switch (ctxid) {
			// Local
			case 0:
				resp.property = _get(_, null, "", values, {
					sub: frame.sub,
					features: this.features
				});
				break;

				// Global: NIY
			case 1:
				throw new Error("NIY");
				// Class: NIY
			case 2:
				throw new Error("NIY");
		}
	},

	// property_get
	// -d	stack depth (optional, debugger engine should assume zero if not provided)
	// -c	context id (optional, retrieved by context-names, debugger engine should assume zero if not provided)
	// -n	property long name (required)
	// -m	max data size to retrieve (optional, defaults to the length as negotiated through feature_set with max_data). 0 means unlimited data.
	// -p	data page (property_get, property_value: optional for arrays, hashes, objects, etc.; property_set: not required; debugger engine should assume zero if not provided)
	// -k	property key as retrieved in a property element, optional, used for property_get of children and property_value, required if it was provided by the debugger engine.
	// -a	property address as retrieved in a property element, optional, used for property_set/value
	property_get: function(_, resp, options) {
		var ctxid = ~~options.c,
			longName = options.n,
			maxsize = ~~ (options.m || this.features.max_data),
			page = ~~options.p,
			// Address and key are not supported
			// propKey = options.k,
			// propAddr = options.a,
			frame = this._getFrame(options.d),
			values = frame.values;

		if (!longName)
			throw new Error("Missing options -n");

		var value = evalue(_, longName);
		log.info("property_get name='" + longName + "', value=" + sys.inspect(value));
		var parts = longName.split(".");
		var name = parts.pop();
		var parents = [{
			$: {
				fullname: parts.join(".")
			}
		}];
		resp.property = _get(_, parents, name, value, {
			sub: frame.sub,
			features: this.features
		});
	},

	// property_set
	// -d	stack depth (optional, debugger engine should assume zero if not provided)
	// -c	context id (optional, retrieved by context-names, debugger engine should assume zero if not provided)
	// -n	property long name (required)
	// -t	data type (optional)
	// -p	data page (property_get, property_value: optional for arrays, hashes, objects, etc.; property_set: not required; debugger engine should assume zero if not provided)
	// -k	property key as retrieved in a property element, optional, used for property_get of children and property_value, required if it was provided by the debugger engine.
	// -a	property address as retrieved in a property element, optional, used for property_set/value
	property_set: function(_, resp, options) {
		var ctxid = ~~options.c,
			longName = options.n,
			page = ~~options.p,
			// Address and key are not supported
			// propKey = options.k,
			// propAddr = options.a,
			frame = this._getFrame(options.d),
			values = frame.values;

		var parts = longName.split(".");

		throw new Error("NIY");
	},

	// source
	// -b	begin line (optional)
	// -e	end line (optional)
	// -f	file URI
	// In the legacy version uri is in the form "x3://AWS-X3-DEVSUP.sagefr.adinternal.com:17000/SUPERV/GOBJSUB.src"
	source: function(_, resp, options) {
		var uri = url.parse(options.f),
			segments = uri.pathname.split("/"),
			file = segments[segments.length - 1],
			ext = file && file.substring(file.lastIndexOf('.') + 1),
			frame = this.frame,
			fullpath = [frame.context.superv.solutionPath.replace(/\\/g, '/'), segments[1], _folderMap[ext], file].join("/"),
			source = getSource(fullpath, options.b, options.e);

		log.info("source: uri=" + sys.inspect(uri));
		resp.$.success = ~~ (source != null);
		resp.$value = source;
	},

	// stdout
	// -c	[0|1|2] 0 - disable, 1 - copy data, 2 - redirection
	stdout: function(_, resp, options) {
		throw new Error("NIY");
	},

	// ====================================================
	// DGBP protocol Extended Commands
	// ====================================================

	// stdin
	stdin: function(_, resp, options) {
		throw new Error("NIY");
	},

	// break
	break: function(_, resp, options) {
		throw new Error("NIY");
	},

	// eval
	eval: function(_, resp, options) {
		throw new Error("NIY");
	},

	// interact
	interact: function(_, resp, options) {
		throw new Error("NIY");
	},

};

var _folderMap = {
	"src": "TRT",
	"adx": "TRT",
	"stc": "STC"
};

function _get(_, parents, name, value, context) {
	parents = parents || [];
	var parent = parents[0],
		descendents,
		depth = parents.length,
		sub = context.sub,
		features = context.features;

	if (depth > features.max_depth)
		return;

	var vtype = value === null ? "null" : typeof(value);
	var type = dbgpType(value) || vtype,
		prop = {
			$: {
				name: name,
				fullname: (parent && parent.$.fullname ? parent.$.fullname + "." : "") + (typeof(name) === "string" ? name : "(" + name + ")"),
				type: type,
				// classname:"name_of_object_class",
				// constant: "0|1",
				children: 0,
				// size: "{NUM}",
				// page: "{NUM}",
				// pagesize: "{NUM}",
				// address: "{NUM}",
				// key: "language_dependent_key",
				// encoding: "none",
				// numchildren: "{NUM}",
			}
		};

	// if (parent == null)
	// 	log.info("_get: property=" + sys.inspect(value, {
	// 		depth: 3
	// 	}));
	// log.info("_get: parent=" + parent + ", name=" + name + ", value=" + value + ", type=" + type);
	descendents = [prop].concat(parents);
	if (type === "Array") {
		prop.$.type = "array";
		prop.$.children = 1;
		prop.$.numchildren = value.length;
		prop.$.pagesize = features.max_children;
		if (context.pageNumber)
			prop.$.page = context.pageNumber;
		prop.$.size = value.length;

		prop.property = value.map_(_, function(_, e, i) {
			return _get(_, descendents, i, e, context);
		});
	} else if (type === "Blbfile") {
		prop.$.encoding = "base64";
		prop.$value = value.x3ToBase64();
	} else if (value && typeof(value.x3ToString) === "function") {
		prop.$value = value.x3ToString();
	} else if (type === "Object") {
		var x3Obj = typeof value.get === "function";

		var keys = Object.keys(x3Obj && value.properties || value);
		prop.$.type = "object";
		if (x3Obj) prop.$.classname = value.class && value.class.codclaPath;
		prop.$.children = 1;
		prop.$.numchildren = keys.length;
		prop.$.pagesize = features.max_children;
		if (context.pageNumber)
			prop.$.page = context.pageNumber;
		prop.$.size = keys.length;

		prop.property = keys.map_(_, function(_, k) {
			return _get(_, descendents, k, x3Obj ? value.get(_, k, true) : value[k], context);
		});
		if (parent == null) {
			return prop.property;
		}
	} else {
		if (value instanceof Buffer) {
			prop.$.encoding = "base64";
			prop.$value = value.toString('base64');
		} else {
			prop.$value = "" + value;
		}
	}

	return prop;
}

function newResponse(cmd, options) {
	return new DbgpResponse(cmd, options);
}

function DbgpResponse(cmd, options) {
	this.$ = {
		command: cmd,
		transaction_id: options.i
	};
}

DbgpResponse.prototype = {
	toString: function(indent) {
		return jsxml.stringify({
			response: this
		}, indent);
	}
};


function getInitMessage(options) {
	options = options || {};
	var idekey = options.idekey || "com.sage.x3.xdt.dltk.debugger.etna";
	return {
		init: {
			$: {
				idekey: idekey,
				session: options.baseurl + "/$debug?idekey=" + idekey + "&rtm=" + (options.rtm || "etna.9.0"),
				fileuri: "",
				thread: 0,
				parent: "",
				server: options.server || "", //"AWS-X3-DEVSUP.sagefr.adinternal.com:17000/SUPERV/erbou/101007375",
				language: "x3-etna",
				protocol_version: "1.0"
			},
			engine: {
				$: {
					version: (options.rtm || "etna.9.0")
				}
			},
			author: {
				$value: "Sage"
			},
			url: {
				$cdata: "http://www.sage.com"
			},
			copyright: {
				$cdata: "Copyright (c) 2000-2015 Sage"
			},
		}
	};
}

function dbgpType(value) {
	return util.x3Typename(value);
}

var _sourceCache = {};

function getSource(path, begin, end) {
	path = path.replace(/\\/g, '/');
	// Basic source cache for testing. Need improvement
	var source = _sourceCache[path];
	if (source == null && fs.existsSync(path)) {
		source = _sourceCache[path] = fs.readFileSync(path, 'utf8');
	}
	if (source != null && (begin != null || end != null)) {
		var lines = source.split(/\n/);
		begin = ~~begin;
		end = end != null ? end : lines.length - 1;
		return lines.splice(begin, end).join("\n");
	}
	return source;
}