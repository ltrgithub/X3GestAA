"use strict";
var sys = require("util");
var ez = require('ez-streams');
var jsxml = require("jsxml/lib/jsxml");
var helpers = require('syracuse-core/lib/helpers');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;

function log(s) {
	console.error("DebugContext." + s);
}

function DebugContext(socket) {

	this.readCommand = function(_) {
		var seg = [],
			c, cmd;
		while ((c = socket.read(_, 1))) {
			if (c[0] === 0)
				break;
			seg.push(c[0]);
		}

		cmd = new Buffer(seg).toString('utf8');
		// log("readCommand cmd= " + cmd);
		return cmd;
	};

	this.write = function(_, data) {
		if (data instanceof DbgpResponse) {
			data = data.toString(this.indent);
		} else if (typeof(data) === "object") {
			data = jsxml.stringify(data, this.indent);
		}
		// log("write: " + data);
		socket.write(_, [Buffer.byteLength(data, 'utf8'), data, ""].join("\0"));
	};

	this.close = function() {
		socket.end();
		socket.destroy();
		socket = null;
	};

	this.getDescription = function() {
		return socket.localAddress + ":" + socket.localPort;
	};

	Object.defineProperty(this, 'isActive', {
		get: function() {
			return socket && !socket.closed;
		}
	});

	this.features = {
		"language_supports_threads": "0",
		"language_name": "x3-etna",
		"language_version": "9.0",
		"encoding": "UTF-8",
		"data_encoding": "base64",
		"protocol_version": "1",
		"supports_async": "0",
		// seems not to be called by Eclipse DLTK framework
		"breakpoint_types": "line conditional exception watch",
		"multiple_sessions": "0",
		// max number of array or object children to initially retrieve
		"max_children": 100,
		// max amount of variable data to initially retrieve
		"max_data": 8192,
		// maximum depth that the debugger engine may return when sending arrays, hashs or object structures to the IDE.
		"max_depth": 2
	};
}

exports.DebugContext = helpers.defineClass(DebugContext, null, {
	listen: function(_) {
		try {
			var cmd;
			while (!this.session && (cmd = this.readCommand(_))) {
				this.interpret(_, cmd);
			}
		} catch (e) {
			this.abort("Debug listening aborted", e);
		}
	},
	hit: function(_, frame, request) {
		this.frame = frame;
		this.request = request;
		try {
			if (this.state === "init") {
				this.state = "attached";
				this.write(_, getInitMessage());
			}
			if (this.status === "break") {
				var cmd, debug = frame && frame.sub && frame.sub.debug || {};
				log("hit: " + debug.instruction + " in " + debug.module + ":" + debug.location.line + ", status=" + this.status);
				this.leave = false;
				while (!this.leave && this.status === "break" && (cmd = this.readCommand(_))) {
					this.interpret(_, cmd);
				}
			}
		} catch (e) {
			this.abort("Debug session aborted", e);
		}
	},
	interpret: function(_, commandLine) {
		var parts = commandLine.split(/ /g),
			cmd = parts[0] && parts[0].toLowerCase().replace(/-/g, "_"),
			command = _commandsMap[cmd],
			options = {};
		for (var i = 1, len = parts.length; i < len; i++) {
			if (parts[i][0] === "-") {
				options[parts[i].substring(1)] = parts[++i];
			}
		}
		// log("interpret: '" + commandLine + "' parts=" + parts + " => command=" + typeof(command));
		var res = command && command.call(this, _, newResponse(cmd, options), options);
		if (res)
			this.write(_, res);
	},
	setStatus: function(resp, status, reason) {
		this.status = status || this.status;
		resp.$.status = this.status;
		resp.$.reason = reason || "ok";
	},
	abort: function(m, e) {
		this.state = "detached";
		this.status = "stopped";
		console.error(m + (e ? ": " + e.message : "") + e.stack);
		// console.error(m + (e ? ": " + e.message : ""));
	}
});


var _commandsMap = {
	list: function(_, resp, options) {
		var sessions = sessionManager.getTenantSessions();
		// log("list: sessions\n" + Object.keys(sessions).join("\n"));
		resp.session = Object.keys(sessions).map(function(s) {
			return {
				$: {
					id: s
				}
			};
		});
		return resp;
	},
	options: function(_, resp, options) {
		var beautify = /s(\d*)/.exec(options.b);
		if (beautify)
			this.indent = new Array(~~beautify[1] + 1).join(" ");
		else
			this.indent = options.b === "t" ? "\t" : null;

		return resp;
	},
	attach: function(_, resp, options) {
		var id = options.s,
			session = id && sessionManager.sessionById(id);

		if (session) {
			this.status = "break";
			this.state = "init";
			session.debugContext = this;
			this.session = session;
		}
		// log("attach: id=" + id + ", session=" + sys.inspect(session, {
		// 	depth: 3
		// }));
		// log("attach: id=" + id + ", session=" + typeof(session));
		resp.$.session = id || "";
		this.setStatus(resp);
		return resp;
	},

	// ====================================================
	// DGBP protocol standard commands
	// see http://xdebug.org/docs-dbgp.php
	// ====================================================

	// status
	status: function(_, resp, options) {
		this.setStatus(resp);
		// resp.$value = "message....";
		return resp;
	},

	// feature_get
	// -n	feature_name
	feature_get: function(_, resp, options) {
		var name = options.n || "",
			value = this.features[name];
		resp.$.feature_name = name;
		resp.$.supported = ~~ (value != null);
		resp.$value = value;
		return resp;
	},

	// feature_set
	// -n	feature_name
	// -v	value to be set
	feature_set: function(_, resp, options) {
		var name = options.n;
		// max_depth cannot be set to a different value because of an issue in Eclipse DLTK framework
		if (name && name != "max_depth")
			this.features[name] = options.v;
		resp.$.feature = name;
		resp.$.success = ~~ (this.features[name] != null);
		return resp;
	},

	// run
	run: function(_, resp, options) {
		// TODO
		this.setStatus(resp);
		return resp;
	},

	// step_into
	step_into: function(_, resp, options) {
		// TODO
		this.leave = true;
		this.setStatus(resp);
		return resp;
	},

	// step_over
	step_over: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
		return resp;
	},

	// step_out
	step_out: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
		return resp;
	},

	// stop
	stop: function(_, resp, options) {
		this.leave = true;
		// TODO
		this.setStatus(resp);
		return resp;
	},

	// detach
	detach: function(_, resp, options) {
		this.leave = true;
		this.session.debugContext = null;
		// TODO
		this.status = "run";
		this.setStatus(resp);
		return resp;
	},

	// breakpoint_set
	// -t TYPE			breakpoint type, see above for valid values [required]
	// -s STATE			breakpoint state [optional, defaults to "enabled"]
	// -f FILENAME		the filename to which the breakpoint belongs [optional]
	// -n LINENO		the line number (lineno) of the breakpoint [optional]
	// -m FUNCTION		function name [required for call or return breakpoint types]
	// -x EXCEPTION		exception name [required for exception breakpoint types]
	// -h HIT_VALUE		hit value (hit_value) used with the hit condition to determine if should break; a value of zero indicates hit count processing is disabled for this breakpoint [optional, defaults to zero (i.e. disabled)]
	// -o HIT_CONDITION	hit condition string (hit_condition); see hit_condition documentation above; BTW 'o' stands for 'operator' [optional, defaults to '>=']
	// -r 0|1			Boolean value indicating if this breakpoint is temporary. [optional, defaults to false]
	// -- EXPRESSION	code expression, in the language of the debugger engine. The breakpoint should activate when the evaluated code evaluates to true. [required for conditional breakpoint types]
	breakpoint_set: function(_, resp, options) {
		// TODO
		return resp;
	},

	// breakpoint_get
	// -d BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	// returns:
	// <response command="breakpoint_get"
	//           transaction_id="TRANSACTION_ID">
	//     <breakpoint id="BREAKPOINT_ID"
	//                 type="TYPE"
	//                 state="STATE"
	//                 filename="FILENAME"
	//                 lineno="LINENO"
	//                 function="FUNCTION"
	//                 exception="EXCEPTION"
	//                 expression="EXPRESSION"
	//                 hit_value="HIT_VALUE"
	//                 hit_condition="HIT_CONDITION"
	//                 hit_count="HIT_COUNT">
	//         <expression>EXPRESSION</expression>
	//     </breakpoint>
	// </response>	
	breakpoint_get: function(_, resp, options) {
		// TODO
		return resp;
	},

	// breakpoint_update
	// -s	STATE
	// -n	LINENO
	// -h	HIT_VALUE
	// -o	HIT_CONDITION	
	breakpoint_update: function(_, resp, options) {
		// TODO
		return resp;
	},

	// breakpoint_remove
	// -d BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	breakpoint_remove: function(_, resp, options) {
		// TODO
		return resp;
	},

	// breakpoint_list
	breakpoint_list: function(_, resp, options) {
		// TODO
		return resp;
	},

	// stack_depth
	stack_depth: function(_, resp, options) {
		// TODO
		resp.$.depth = 10;
		return resp;
	},

	// stack_get
	// -d	stack depth (optional)
	stack_get: function(_, resp, options) {
		resp.stack = [];
		var sub = this.frame && this.frame.sub;
		// log("stack_get: frame.sub=" + sys.inspect(sub));
		if (sub) {
			var frm = this.frame,
				loc, stackinfo, debug, level = 0;
			while (sub) {
				debug = sub.debug || {};
				loc = debug && debug.location || {};
				stackinfo = {
					level: level++,
					type: debug.file ? "file" : "builtin",
					filename: loc.file,
					lineno: loc.line,
					where: (debug.file ? debug.file + "." : "") + (debug.instruction || ""),
					// cmdbegin: "line_number:offset",
					// cmdend: "line_number:offset"
				};
				resp.stack.push({
					$: stackinfo
				});
				sub = sub.prev;
			}
		}

		return resp;
	},

	// context_names
	// -d	stack depth (optional)
	context_names: function(_, resp, options) {
		resp.context = [{
			name: "Local",
			id: 0
		}, {
			name: "Global",
			id: 1
		}, {
			name: "Class",
			id: 2
		}];
		return resp;
	},
	// context_get
	// -d	stack depth (optional)
	// -c	context id (optional, retrieved by context-names)
	context_get: function(_, resp, options) {
		var ctxid = ~~options.c,
			depth = options.d,
			sub = this.frame && this.frame.sub;
		resp.$.context = ctxid;
		// log("context_get: frame=" + sys.inspect(this.frame));
		switch (ctxid) {
			// Local
			case 0:
				resp.property = getProperty(null, "", sub.values, "LY", {
					sub: sub,
					features: this.features
				});
				break;

				// Global: NIY
			case 1:
				break;

		}
		return resp;
	}
};

function getProperty(parents, name, value, type, context) {
	parents = parents || [];
	var parent = parents[0],
		descendents,
		depth = parents.length,
		sub = context.sub,
		features = context.features;

	if (depth > features.max_depth)
		return;

	var vtype = value === null ? "null" : typeof(value);
	if (type == null) {
		if (vtype === "number")
			type = "LI";
		else if (vtype === "object")
			type = "LY";
		else
			type = "LS";
	}
	var dbgpType = _typeMap[type] || vtype,
		prop = {
			$: {
				name: name,
				fullname: (parent && parent.$.fullname ? parent.$.fullname + "." : "") + (typeof(name) === "string" ? name : "(" + name + ")"),
				type: dbgpType,
				// classname:"name_of_object_class",
				// constant: "0|1",
				children: 0,
				// size: "{NUM}",
				// page: "{NUM}",
				// pagesize: "{NUM}",
				// address: "{NUM}",
				// key: "language_dependent_key",
				// encoding: "none",
				// numchildren: "{NUM}",
			},

		};

	// if (parent == null)
	// 	log("getProperty: property=" + sys.inspect(value, {
	// 		depth: 3
	// 	}));
	// log("getProperty: parent=" + parent + ", name=" + name + ", value=" + value + ", type=" + type);
	descendents = [prop].concat(parents);
	if (Array.isArray(value)) {
		prop.$.type = "array";
		prop.$.children = 1;
		prop.$.numchildren = value.length;
		prop.$.pagesize = features.max_children;
		if (context.pageNumber)
			prop.$.page = context.pageNumber;
		prop.$.size = value.length;

		prop.property = value.map(function(e, i) {
			return getProperty(descendents, i, e, null, context);
		});
	} else if (vtype === "object") {
		var keys = Object.keys(value);
		prop.$.type = "object";
		prop.$.children = 1;
		prop.$.numchildren = keys.length;
		prop.$.pagesize = features.max_children;
		if (context.pageNumber)
			prop.$.page = context.pageNumber;
		prop.$.size = keys.length;

		prop.property = keys.map(function(k) {
			return getProperty(descendents, k, value[k], null, context);
		});
		if (parent == null)
			return prop.property;
	} else {
		if (value instanceof Buffer) {
			prop.$.encoding = "base64";
			prop.$value = value.toString('base64');
		} else {
			prop.$value = "" + value;
		}
	}
	return prop;
}

function newResponse(cmd, options) {
	return new DbgpResponse(cmd, options);
}

function DbgpResponse(cmd, options) {
	this.$ = {
		command: cmd,
		transaction_id: options.i
	};
}

DbgpResponse.prototype = {
	toString: function(indent) {
		return jsxml.stringify({
			response: this
		}, indent);
	}
};


function getInitMessage(options) {
	options = options || {};
	var idekey = options.idekey || "com.sage.x3.xdt.dltk.debugger.etna";
	return {
		init: {
			$: {
				idekey: idekey,
				session: options.baseurl + "/$debug?idekey=" + idekey + "&rtm=" + (options.rtm || "etna.9.0"),
				fileuri: "",
				thread: 0,
				parent: "",
				server: options.server || "", //"AWS-X3-DEVSUP.sagefr.adinternal.com:17000/SUPERV/erbou/101007375",
				language: "x3-etna",
				protocol_version: "1.0"
			},
			engine: {
				$: {
					version: (options.rtm || "etna.9.0")
				}
			},
			author: {
				$value: "Sage"
			},
			url: {
				$cdata: "http://www.sage.com"
			},
			copyright: {
				$cdata: "Copyright (c) 2000-2015 Sage"
			},
		}
	};
}

var _typeMap = {
	"LI": "float",
	"LS": "string",
	"LD": "string",
	"LY": "object"
};