"use strict";
var sys = require("util");
var url = require("url");
var fs = require("fs");
var ez = require('ez-streams');
var helpers = require('syracuse-core/lib/helpers');
var uuid = require('syracuse-core/lib/uuid');
var util = require('etna-engine/lib/runtime/util');
var config = require("config");

var _typeMap = {
	"line": BreakpointLine,
	"call": BreakpointCall,
	"return": BreakpointReturn,
	"exception": BreakpointException,
	"conditional": BreakpointConditional,
	"watch": BreakpointWatch
};

var _bpOptionMap = {
	"t": "type", //	breakpoint type, see above for valid values [required]
	"s": "state", //	breakpoint state [optional, defaults to "enabled"]
	"f": "filename", //	the filename to which the breakpoint belongs [optional]
	"n": "lineno", // the line number (lineno) of the breakpoint [optional]
	"m": "function", //	function name [required for call or return breakpoint types]
	"x": "exception", // exception name [required for exception breakpoint types]
	"h": "hit_value", // hit value (hit_value) used with the hit condition to determine if should break; a value of zero indicates hit count processing is disabled for this breakpoint [optional, defaults to zero (i.e. disabled)]
	"o": "hit_condition", //hit condition string (hit_condition); see hit_condition documentation above; BTW 'o' stands for 'operator' [optional, defaults to '>=']
	"r": "temporary", // 0|1 Boolean value indicating if this breakpoint is temporary. [optional, defaults to false]
	"-": "expression" //	code expression, in the language of the debugger engine. The breakpoint should activate when the evaluated code evaluates to true. [required for conditional breakpoint types]
};

var _bpProperties = [
	"id", "type", "state", "filename", "lineno", "function", "exception", "hit_value", "hit_condition", "temporary"
];

function _convertOptions(options) {
	return Object.keys(options).reduce(function(r, k) {
		return r[_bpOptionMap[k]] = options[k];
	}, {});
}

exports.createFromDbgpOptions = function(options) {
	var bpOptions = _convertOptions(options);
	var clazz = _typeMap[bpOptions.type];
	return clazz && new clazz(bpOptions);
};

function Breakpoint(options) {
	var id = uuid.generate();
	Object.defineProperty(this, '$id', {
		get: function() {
			return id;
		}
	});

	Object.keys(options).forEach(function(k) {
		this["$" + k] = options[k];
	});
};

helpers.defineClass(Breakpoint, null, {
	getProperties: function() {
		var self = this;
		return _bpProperties.reduce(function(r, p) {
			r[p] = self["$" + p];
		}, {});
	},

	getDbgpInfo: function() {
		var info = {
			$: this.getProperties(),
		};
		if (this.$expression) {
			info.expression = {
				$value: this.$expression
			};
		}
		return info;
	},

	updateFromDbgpOptions: function(options) {
		var self = this;
		Object.keys(options).forEach(function(k) {
			self["$" + _bpOptionMap[k]] = options[k];
		}, {});
	},

	isEnabled: function() {
		return this.$state === "enabled";
	}
});

// line: break on the given lineno in the given file
// require: filename, lineno
function BreakpointLine(options) {
	Breakpoint.call(this, options);
	this.$key = this.$filename + ":" + this.$lineno;
};

helpers.defineClass(BreakpointLine, Breakpoint, {
	//
});

// call: break on entry into new stack for function name
// require: function
function BreakpointCall(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointCall, Breakpoint, {
	//
});

// return: break on exit from stack for function name
// require:	function
function BreakpointReturn(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointReturn, Breakpoint, {
	//
});

// exception: break on exception of the given name
// require: exception
function BreakpointException(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointException, Breakpoint, {
	//
});

// conditional:  filename	break when the given expression is true at the given filename and line number or just in given filename
// require: expression
function BreakpointConditional(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointConditional, Breakpoint, {
	//
});

// watch: break on write of the variable or address defined by the expression argument
// require: 	expression
function BreakpointWatch(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointWatch, Breakpoint, {
	//
});