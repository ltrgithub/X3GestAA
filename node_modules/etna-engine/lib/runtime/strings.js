"use strict";
var util = require('./util');
var Parser = require("../parser").Parser;

var errors = require('./errors');
var X3Error = errors.X3Error;
var RE_NUMBER = /^([+-]?\d+(\.\d*)?([eE][+-]?\d+)?)$/;
var format = require('./format');

var tdate = require('./tdate');
var tstring = require('./tstring');
var tbcd = require('./tbcd');
var tinteger = require('./tinteger');

var SP = ' '.charCodeAt(0);

var _latin1_192_255 = ["A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "Y", "P", "B", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "-", "o", "u", "u", "u", "u", "y", "p", "y"];

function _toAscii(ch) {
	if (ch >= 0x20 && ch <= 0x7e) return String.fromCharCode(ch);
	else if (ch == 140) return "OE";
	else if (ch == 156) return "oe";
	else if (ch >= 192 && ch <= 255) return _latin1_192_255[ch - 192];
	else return "?";
}

var trimFuncs = exports.trimFuncs = [function(s) { // left
	var i, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	return i === 0 ? s : s.substring(i);
}, function(s) { // right
	var i, len = s.length;
	for (i = len - 1; i >= 0 && s.charCodeAt(i) === SP; i--);
	return i === len ? s : s.substring(0, i + 1);
}, function(s) { // both
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = len - 1; j >= i && s.charCodeAt(j) === SP; j--);
	return s.substring(i, j + 1);
}, function(s) { // token
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = i; j < len && s.charCodeAt(j) !== SP; j++);
	return s.substring(i, j);
}, function(s) { // all
	return s.replace(/ /g, '');
}, function(s) { // adjacent
	return s.replace(/[ ]+/g, ' ');
}];

function repeat(ch, n) {
	var s = "";
	for (var i = 0; i < n; i++)
	s += ch;
	return s;
}

exports.functions = {
	ASCII: {
		count: 1,
		fn: function(s) {
			return s.charCodeAt(0);
		}
	},
	LEN: {
		count: 1,
		fn: function(s) {
			return s.length;
		}
	},
	PARSE: {
		count: 1,
		fn: function(expression) {
			try {
				var node = new Parser(expression, "eval").parseExp(true);
			}
			catch(e) {
				return 5;
			}
			return 0;
		}
	},
	PAT: {
		count: 2,
		fn: function(s1, s2) {
			//util.checkString(s1);
			//util.checkString(s2);
			var regex = new RegExp("^"+s2.toString().replace(/\*/g, ".*").replace(/#/g,"\\d{1}").replace(/!/g,"[a-zA-Z]{1}").replace(/\?/g,".{1}")+"$");
			return new tinteger.Integer(regex.test(s1.toString())?1:0);
		}
	},
	VAL: {
		count: 1,
		fn: function(s) {
			if(s.isDate) return s.toTString();

			if(tstring.isString(s)) {
				var m = RE_NUMBER.exec(s.toString());
				if (m) {
					if(m[2]) return new tbcd.BCD(parseFloat(s.toString()));
					return new tinteger.Integer(parseFloat(s.toString()));
				}
			}
		}
	},
	LEFT$: {
		count: 2,
		fn: function(s, i) {
			return new tstring.TString(s.toString().substring(0, i));
		}
	},
	MID$: {
		count: 3,
		fn: function(s, i, l) {
			return new tstring.TString(s.toString().substring(i - 1, i - 1 + l));
		}
	},
	RIGHT$: {
		count: 2,
		fn: function(s, i) {
			return tstring.TString(s.toString().substring(i - 1));
		}
	},
	SEG$: {
		count: 3,
		fn: function(s, i, j) {
			return tstring.TString(s.toString().substring(i - 1, j));
		}
	},
	CTRANS: {
		count: -1,
		fn: function(src, from, to) {
			var dst = "",
				ch;
			util.checkString(src);
			if (from) {
				util.checkString(from);
				util.checkString(to);
				if (from.length < src.length) {
					var map = {};
					for (var i = 0, l = from.length; i < l; i++) map[from.charCodeAt(i)] = to.charCodeAt(i) || -1;

					for (var i = 0, l = src.length; i < l; i++) {
						var tch = map[ch = src.charCodeAt(i)];
						if (tch !== -1) dst += String.fromCharCode(tch === undefined ? ch : tch);
					}
				} else {
					for (var i = 0, l = src.length; i < l; i++) {
						var off = from.indexOf(ch = src[i]);
						if (off >= 0) {
							if (off < to.length) dst += to[off];
						} else dst += ch;
					}

				}
			} else {
				for (var i = 0, l = src.length; i < l; i++)
				dst += _toAscii(src.charCodeAt(i));
			}
			//console.error("ctrans: src=" + src + " dst=" + dst);
			return dst;
		}
	},
	TOLOWER: {
		count: 1,
		fn: function(s) {
			return s.toLowerCase();
		}
	},
	TOUPPER: {
		count: 1,
		fn: function(s) {
			return s.toUpperCase();
		}
	},
	VIREBLC: {
		//count: 2,
		// 2nd arg seems optional (see AVOLUME_CSTD line 523)
		fn: function(s, mode) {
			var fn = trimFuncs[mode || 0];
			if (!fn) throw new X3Error(50, "bad mode: " + mode);
			return fn(s);
		}
	},
	CHR$: {
		count: 1,
		fn: function(n) {
			return String.fromCharCode(n);
		}
	},
	GRAPH$: {
		count: -1,
		fn: function(nb, n) {
			if (n == null) n = nb, nb = 1;
			return repeat(String.fromCharCode(149 + n), nb);
		}
	},
	SPACE$: {
		count: 1,
		fn: function(n) {
			return repeat(' ', n);
		}
	},
	STRING$: {
		count: 2,
		fn: function(n, ch) {
			return repeat(typeof(ch) === "number" ? String.fromCharCode(ch) : ch, n);
		}
	},
	FORMAT$: {
		count: 2,
		fn: function(fmt, val) {
			util.checkString(fmt);
			return format.format(this, fmt, val, trimFuncs);
		}
	},
	NUM$: {
		count: 1,
		fn: function(x) {
			return x.toTString();
		}
	},
	INSTR: {
		count: 3,
		fn: function(start, str, s) {
			util.checkInteger(start);
			util.checkString(str);
			util.checkString(s);
			return start <= 0 ? 0 : str.indexOf(s, start - 1) + 1;
		}
	},
	MESS: {
		count: 3,
		fn: function(id, chapter, dummy) {
			// TODO: get it from APLSTD
			return "message " + chapter + "/" + id
		}
	},
	XGETCHAR: {
		count: 2,
		fn: function(s, pos) {
			return s.charAt(pos-1);
		}
	},
};