"use strict";
var util = require('./util');
var Parser = require("../parser").Parser;

var errors = require('./errors');
var X3Error = errors.X3Error;
var RE_NUMBER = /^([+-]?\d+(\.\d*)?([eE][+-]?\d+)?)/;
var format = require('./format');
var datetime = require('syracuse-core/lib/types/datetime');

var SP = ' '.charCodeAt(0);

var _latin1_192_255 = ["A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "Y", "P", "B", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "-", "o", "u", "u", "u", "u", "y", "p", "y"];

function _toAscii(ch) {
	if (ch >= 0x20 && ch <= 0x7e) return String.fromCharCode(ch);
	else if (ch == 140) return "OE";
	else if (ch == 156) return "oe";
	else if (ch >= 192 && ch <= 255) return _latin1_192_255[ch - 192];
	else return "?";
}

var trimFuncs = exports.trimFuncs = [function(s) { // left
	var i, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	return i === 0 ? s : s.substring(i);
}, function(s) { // right
	var i, len = s.length;
	for (i = len - 1; i >= 0 && s.charCodeAt(i) === SP; i--);
	return i === len ? s : s.substring(0, i + 1);
}, function(s) { // both
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = len - 1; j >= i && s.charCodeAt(j) === SP; j--);
	return s.substring(i, j + 1);
}, function(s) { // token
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = i; j < len && s.charCodeAt(j) !== SP; j++);
	return s.substring(i, j);
}, function(s) { // all
	return s.replace(/ /g, '');
}, function(s) { // adjacent
	return s.replace(/[ ]+/g, ' ');
}];

function repeat(ch, n) {
	var s = "";
	for (var i = 0; i < n; i++)
	s += ch;
	return s;
}

exports.functions = {
	ASCII: {
		count: 1,
		fn: function(s) {
			return s.charCodeAt(0);
		}
	},
	LEN: {
		count: 1,
		fn: function(s) {
			return s.length;
		}
	},
	PARSE: {
		count: 1,
		fn: function(expression) {
			try {
				var node = new Parser(expression, "eval").parseExp(true);
			}
			catch(e) {
				return 5;
			}
			return 0;
		}
	},
	PAT: {
		count: 2,
		fn: function(s1, s2) {
			return new RegExp("^"+s2.replace(/\*/g, ".*").replace(/#/g,"\\d{1}").replace(/!/g,"[a-zA-Z]{1}").replace(/\?/g,".{1}")+"$").test(s1)?1:0;;
		}
	},
	VAL: {
		count: 1,
		fn: function(s) {
			var m = RE_NUMBER.exec(s);
			if (m) return parseFloat(m[1]);
		}
	},
	LEFT$: {
		count: 2,
		fn: function(s, i) {
			return s.substring(0, i);
		}
	},
	MID$: {
		count: 3,
		fn: function(s, i, l) {
			return s.substring(i - 1, i - 1 + l);
		}
	},
	RIGHT$: {
		count: 2,
		fn: function(s, i) {
			return s.substring(i - 1);
		}
	},
	SEG$: {
		count: 3,
		fn: function(s, i, j) {
			return s.substring(i - 1, j);
		}
	},
	CTRANS: {
		count: -1,
		fn: function(src, from, to) {
			var dst = "",
				ch;
			util.checkString(src);
			if (from) {
				util.checkString(from);
				util.checkString(to);
				if (from.length < src.length) {
					var map = {};
					for (var i = 0, l = from.length; i < l; i++) map[from.charCodeAt(i)] = to.charCodeAt(i) || -1;

					for (var i = 0, l = src.length; i < l; i++) {
						var tch = map[ch = src.charCodeAt(i)];
						if (tch !== -1) dst += String.fromCharCode(tch === undefined ? ch : tch);
					}
				} else {
					for (var i = 0, l = src.length; i < l; i++) {
						var off = from.indexOf(ch = src[i]);
						if (off >= 0) {
							if (off < to.length) dst += to[off];
						} else dst += ch;
					}

				}
			} else {
				for (var i = 0, l = src.length; i < l; i++)
				dst += _toAscii(src.charCodeAt(i));
			}
			//console.error("ctrans: src=" + src + " dst=" + dst);
			return dst;
		}
	},
	TOLOWER: {
		count: 1,
		fn: function(s) {
			return s.toLowerCase();
		}
	},
	TOUPPER: {
		count: 1,
		fn: function(s) {
			return s.toUpperCase();
		}
	},
	VIREBLC: {
		//count: 2,
		// 2nd arg seems optional (see AVOLUME_CSTD line 523)
		fn: function(s, mode) {
			var fn = trimFuncs[mode || 0];
			if (!fn) throw new X3Error(50, "bad mode: " + mode);
			return fn(s);
		}
	},
	CHR$: {
		count: 1,
		fn: function(n) {
			return String.fromCharCode(n);
		}
	},
	GRAPH$: {
		count: -1,
		fn: function(nb, n) {
			if (n == null) n = nb, nb = 1;
			return repeat(String.fromCharCode(149 + n), nb);
		}
	},
	SPACE$: {
		count: 1,
		fn: function(n) {
			return repeat(' ', n);
		}
	},
	STRING$: {
		count: 2,
		fn: function(n, ch) {
			return repeat(typeof(ch) === "number" ? String.fromCharCode(ch) : ch, n);
		}
	},
	FORMAT$: {
		count: 2,
		fn: function(fmt, val) {
			util.checkString(fmt);
			return format.format(this, fmt, val, trimFuncs);
		}
	},
	NUM$: {
		count: 1,
		fn: function(x) {
			if(datetime.isDatetime(x)) {
				console.log("x:"+x._value);
				return (x.isUndefined())?"0000-00-00T00:00:00Z":x.toString("yyyy-MM-ddTHH:mm:ss")+"Z";
			}
			return "" + x.toString().replace('e+','e');
		}
	},
	INSTR: {
		count: 3,
		fn: function(start, str, s) {
			util.checkInteger(start);
			util.checkString(str);
			util.checkString(s);
			return start <= 0 ? 0 : str.indexOf(s, start - 1) + 1;
		}
	},
	MESS: {
		count: 3,
		fn: function(id, chapter, dummy) {
			// TODO: get it from APLSTD
			return "message " + chapter + "/" + id
		}
	},
	XGETCHAR: {
		count: 2,
		fn: function(s, pos) {
			return s.charAt(pos-1);
		}
	},
};