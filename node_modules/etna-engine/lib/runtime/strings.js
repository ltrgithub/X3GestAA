"use strict";
var util = require('./util');
var Parser = require("../parser").Parser;

var format = require('./format');


var _latin1_192_255 = ["A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "Y", "P", "B", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "-", "o", "u", "u", "u", "u", "y", "p", "y"];

function _toAscii(ch) {
	if (ch >= 0x20 && ch <= 0x7e) return String.fromCharCode(ch);
	else if (ch == 140) return "OE";
	else if (ch == 156) return "oe";
	else if (ch >= 192 && ch <= 255) return _latin1_192_255[ch - 192];
	else return "?";
}

function repeat(ch, n) {
	var s = "";
	for (var i = 0; i < n; i++)
	s += ch;
	return s;
}

exports.functions = {
	ASCII: {
		count: 1,
		fn: function(expression) {
	
			if (typeof expression!=='string') throw util.badOperand(expression) ;

			return expression.charCodeAt(0) ;
		}
	},
	LEN: {
		count: 1,
		fn: function(expression) {
			if (expression.x3Length) return expression.x3Length( ) ;
			throw util.badOperand(expression) ;
		}
	},
	PARSE: {
		count: 2,
		fn: function(expression) {
			if (typeof expression !== 'string') throw util.badOperand(expression) ;

			try {			
				var prs = new Parser(expression, "eval") ;
				var node = prs.parseExp(true);
			}
			catch(e) {
				return 5 ;
			}
			return 0 ;
		}
	},
	PAT: {
		count: 2,
		fn: function(s1, s2) {
		    if (! util.x3IsString(s1) )  throw util.badOperand(s1) ;
		    if (! util.x3IsString(s2))  throw util.badOperand(s2) ;

			var regex = new RegExp("^"+s2.replace(/\*/g, ".*").replace(/#/g,"\\d{1}").replace(/!/g,"[a-zA-Z]{1}").replace(/\?/g,".{1}")+"$");
			return regex.test(s1)?1:0;
		}
	},
	VAL: {
		count: 1,
		fn: function(s) {
			if(s.x3Val) return s.x3Val();
			throw  util.badOperand(s) ;
		}
	},
	LEFT$: {
		count: 2,
		fn: function(s, i) {
			if (!util.x3IsString(s)) throw util.badOperand(s) ;
			return s.substring(0, i);
		}
	},
	MID$: {
		count: 3,
		fn: function(s, i, l) {
			if (!util.x3IsString(s)) throw util.badOperand(s) ;
			return s.substring(i - 1, i - 1 + l);
		}
	},
	RIGHT$: {
		count: 2,
		fn: function(s, i) {
			if (!util.x3IsString(s)) throw util.badOperand(s) ;
			return s.substring(i - 1);
		}
	},
	SEG$: {
		count: 3,
		fn: function(s, i, j) {
			if (!util.x3IsString(s)) throw util.badOperand(s) ;
			return s.substring(i - 1, j);
		}
	},
	CTRANS: {
		count: -1,
		fn: function(src, from, to) {
			var dst = "",
				ch;
			util.checkString(src);
			if (from) {
				util.checkString(from);
				util.checkString(to);
				if (from.length < src.length) {
					var map = {};
					for (var i = 0, l = from.length; i < l; i++) map[from.charCodeAt(i)] = to.charCodeAt(i) || -1;

					for (var i = 0, l = src.length; i < l; i++) {
						var tch = map[ch = src.charCodeAt(i)];
						if (tch !== -1) dst += String.fromCharCode(tch === undefined ? ch : tch);
					}
				} else {
					for (var i = 0, l = src.length; i < l; i++) {
						var off = from.indexOf(ch = src[i]);
						if (off >= 0) {
							if (off < to.length) dst += to[off];
						} else dst += ch;
					}

				}
			} else {
				for (var i = 0, l = src.length; i < l; i++)
				dst += _toAscii(src.charCodeAt(i));
			}
			//console.error("ctrans: src=" + src + " dst=" + dst);
			return dst;
		}
	},
	TOLOWER: {
		count: 1,
		fn: function(s) {
			return s.toLowerCase();
		}
	},
	TOUPPER: {
		count: 1,
		fn: function(s) {
			return s.toUpperCase();
		}
	},
	VIREBLC: {
		//count: 2,
		// 2nd arg seems optional (see AVOLUME_CSTD line 523)
		fn: function(s, mode) {
			/*var fn = trimFuncs[mode || 0];
			if (!fn) throw new X3Error(50, "bad mode: " + mode);*/
			if (!util.x3IsString( s )) throw util.badOperand(s) ;
			return util.x3Trim( s, mode ) ; 
		}
	},
	CHR$: {
		count: 1,
		fn: function(n) {
			return String.fromCharCode(n);
		}
	},
	GRAPH$: {
		count: -1,
		fn: function(nb, n) {
			if (n == null) n = nb, nb = 1;
			return repeat(String.fromCharCode(149 + n), nb);
		}
	},
	SPACE$: {
		count: 1,
		fn: function(n) {
			return repeat(' ', n);
		}
	},
	STRING$: {
		count: 2,
		fn: function(n, ch) {
			return repeat(typeof(ch) === "number" ? String.fromCharCode(ch) : ch, n);
		}
	},
	FORMAT$: {
		count: 2,
		fn: function(fmt, val) {
			util.checkString(fmt);
			return format.format(this,fmt,val);
		}
	},
	NUM$: {
		count: 1,
		fn: function(x) {
		if (x.x3NumDollar) return x.x3NumDollar( ) ;
			else return x.x3ToString();
		}
	},
	INSTR: {
		count: 3,
		fn: function(start, str, s) {
			util.checkInteger(start);
			util.checkString(str);
			util.checkString(s);
			return start <= 0 ? 0 : str.indexOf(s, start - 1) + 1;
		}
	},
	XGETCHAR: {
		count: 2,
		fn: function(s, pos) {
			return s.charAt(pos-1);
		}
	},
};