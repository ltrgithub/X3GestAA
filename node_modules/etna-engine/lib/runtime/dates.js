"use strict";
var glob = require('streamline/lib/globals');
var util     = require('./util');
var time     = require('syracuse-core/lib/types/time');
var X3Error  = require('./errors').X3Error;
var date     = require('etna-engine/lib/runtime/tdate') ;
var datetime = require('etna-engine/lib/runtime/tdatetime') ;
var tinteger = require('etna-engine/lib/runtime/tinteger') ;

var variables = require('./variables');

var ORIGIN   = date.make(1600,1,1);
var NULLDAT  = date.make(0,0,0);

function x3DateCasse(val) {
	return val.substring(0,1).toUpperCase() + val.substring(1);
}

exports.functions = {
	DAY: {
		count: 1,
		fn: function(d) {
			if (d.day) return d.day;
			throw util.badArgumentType(d);			
		}
	},
	DAYN: {
		count: 1,
		fn: function(d) {
			// shift sunday from 0 to 7, others unchanged
			return 1 + (d.weekDay + 6) % 7;
		}
	},
	MONTH: {
		count: 1,
		fn: function(d) {
			if (d.month) return d.month;
			throw util.badArgumentType(d);
		}
	},
	NDAY: {
		count: 1,
		fn: function(d) {
			if (d.x3Nday) return d.x3Nday(ORIGIN);
			throw util.badArgumentType(d);
		}
	},
	WEEK: {
		count: 1,
		fn: function(d) {
			if (d.week) return d.week;
			throw util.badArgumentType(d);
		}
	},
	YEAR: {
		count: 1,
		fn: function(d) {
			if(d.x3Year) return d.x3Year;
			throw util.badArgumentType(d);
		}
	},
	DAY$: {
		count: 1,
		fn: function(d) {
			if (d.weekDay) d = d.weekDay;
			else if (util.x3IsInteger(d)) d = d % 7;
			else throw util.badArgumentType(d);
			return x3DateCasse(date.dayName(d));
		}
	},
	MONTH$: {
		count: 1,
		fn: function(m) {
			if (date.isDate(m)) m = m.month;
			else if (util.isInteger(m)) m = 1 + (m + 11) % 12;
			else throw util.badArgumentType(m);
			return x3DateCasse(date.monthName(m));
		}
	},
	TIME$: {
		count: 0,
		fn: function() {
			return time.now().toString();
		}
	},
	ADDMONTH: {
		count: 2,
		fn: function(d, dm) {
			if (d.x3AddMonths) return d.x3AddMonths(dm);
			throw util.badArgumentType(d);			
		}
	},
	AWEEK: {
		count: 2,
		fn: function(w, y) {
			util.checkInteger(w);
			util.checkInteger(y);
			if(y < 1600) throw new X3Error(56,"out off limit");
			return date.makeInWeek(y, w, 1);
		}
	},
	DATE$: {
		count: 0,
		fn: function() {
			return date.today();
		}
	},
	DATETIME$: {
		count: 0,
		fn: function() {
			return datetime.now();
		}
	},
	GDATETIME$: {
		count: 1,
		fn: function(s) {
			return datetime.parse(s);
		}
	},
	EOMONTH: {
		count: 1,
		fn: function(d) {
			if (d.endOfMonth) return d.endOfMonth();
			throw util.badArgumentType(d);				
		}
	},
	GDAT$: {
		//count: 3, -- sometimes used with 1 - see AFNC line 588
		fn: function(d, m, y) {
			util.checkInteger(d);
			util.checkInteger(m);
			util.checkInteger(y);
			if( !d || !m || !y) return NULLDAT;

			if(y < 100) {
				var frame = glob.context.x3frame;
				y = ((1900+y) < frame.context.sys.values.adxdcs)? 2000+y:1900+y;
			}

			var dd = 0,
				dy = 0;
			if (d <= 0) dd = d - 1, d = 1;
			if (m <= 0 || m > 12) dy = Math.floor((m - 1) / 12), y += dy, m -= dy * 12;
			var d = date.make(y, m, d);
			return dd ? d.addDays(dd) : d;
		}
	},
	NDAY$: {
		count: 1,
		fn: function(n) {
			return ORIGIN.x3AddDays(n);
		}
	},
	TIME: {
		count: 0,
		fn: function() {
			return time.now().value % (24 * 3600);
		}
	},
	TIMESTAMP$: {
		count: 0,
		fn: function() {
			return datetime.now().toString();
		}
	},

};

exports.instructions = {
	DATE: function(year, month, day) {
		return util.instructions.C(date.make(year, month, day));
	}
};