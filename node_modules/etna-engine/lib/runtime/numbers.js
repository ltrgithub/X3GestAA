"use strict";
var util = require('./util') ;
var errors = require('./errors') ;
var X3Error = errors.X3Error ;
var glob = require('streamline/lib/globals') ;
var tdouble = require('./tdouble') ;
var tbcd = require('./tbcd') ;
var tinteger = require('./tinteger') ;

function fac(n) {
	return (n > 1) ? n * fac(n - 1) : 1;
}
function anp(n, p) {
	return fac(n)/fac(n-p);
}

function toRadians(angle) {
	var frame = glob.context.x3frame;
	switch(frame.context.sys.values.adxmda) {
		case 0 : return angle * (Math.PI / 180); //Degrees => Radians
		case 2 : return angle * (Math.PI / 200); //Grades => Radians
	}
	return angle;
}

exports.functions = {
	ABS: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			return x.abs()
		}
	},
	MOD: {
		count: 2,
		fn: function mod(x, y) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			if (!y.isNumeric()) throw util.badOperand(y) ;	
			return x.mod(y) ;
		}
	},
	RND: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	

			return new tdouble.Double(x.toDouble().valueOf()*Math.random());		
		}
	},
	SGN: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			return new tinteger.Integer(x.compare(new tinteger.Integer(0)));
		}
	},
	SQR: {
		count: 1,
		fn: function(x) { 
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			return new tdouble.Double(Math.sqrt(x.toDouble().valueOf()));
		}
	},
	AR2: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			if (tinteger.isInteger(x)) return x ;

			var b = x.abs().mul(new tbcd.BCD(100)).add( new tbcd.BCD(0.5) ) ;
			var sign=new tinteger.Integer((x.toDouble().valueOf()<0)?-1:1);
			return b.truncate().div(new tbcd.BCD(100)).mul(sign) ;
		}
	},
	ARR: {
		count: 2,
		fn: function(x, y) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			if (!y.isNumeric()) throw util.badOperand(y) ;	
			if (y.isZero()) return( x ) ;	
						
			var val = x.div(y) ;
			var sign=new tinteger.Integer((val.valueOf()<0)?-1:1);

			return y.mul( val.abs().add(new tbcd.BCD(0.5)).truncate().mul(sign) ) ;
		}
	},
	FIX: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			if (tinteger.isInteger(x)) return x ;

			return new tinteger.Integer(x.truncate().toDouble().valueOf()) ;
		}
	},
	INT: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.floor(x.toDouble().valueOf()));
		}
	},
	ANP: {
		count: 2,
		fn: function(n, p) {
			if (!n.isNumeric()) throw util.badOperand(n) ;
			if (!p.isNumeric()) throw util.badOperand(p) ;
			return new tdouble.Double(anp(n.toDouble().valueOf(), p.toDouble().valueOf()));
		}
	},
	CNP: {
		count: 2,
		fn: function(n, p) {
			if (!n.isNumeric()) throw util.badOperand(n) ;
			if (!p.isNumeric()) throw util.badOperand(p) ;
			return new tdouble.Double(anp(n.toDouble().valueOf(), p.toDouble().valueOf()) / anp(p.toDouble().valueOf()));
		}
	},
	FAC: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(fac(x.toDouble().valueOf()));
		}
	},
	COS: {
		count: 1,
		fn: function(angle) {
			if (!angle.isNumeric()) throw util.badOperand(angle) ;
			return new tdouble.Double(Math.cos(toRadians(angle.toDouble().valueOf())));
		}
	},
	SIN: {
		count: 1,
		fn: function(angle) {
			if (!angle.isNumeric()) throw util.badOperand(angle) ;
			return new tdouble.Double(Math.sin(toRadians(angle.toDouble().valueOf())));
		}
	},
	TAN: {
		count: 1,
		fn: function(angle) {
			if (!angle.isNumeric()) throw util.badOperand(angle) ;
			return new tdouble.Double(Math.tan(toRadians(angle.toDouble().valueOf())));
		}
	},
	ACOS: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.acos(x.toDouble().valueOf()));
		}
	},
	ASIN: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.asin(x.toDouble().valueOf()));
		}
	},
	ATAN: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.atan(x.toDouble().valueOf()));
		}
	},
	ACH: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.log(x.toDouble().valueOf() + Math.sqrt(x.toDouble().valueOf() * x.toDouble().valueOf() - 1)));
		}
	},
	ASH: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.log(x.toDouble().valueOf() + Math.sqrt(x.toDouble().valueOf() * x.toDouble().valueOf() + 1)));
		}
	},
	ATH: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.log((1 + x.toDouble().valueOf()) / (1 - x.toDouble().valueOf())) / 2);
		}
	},
	CH: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double((Math.exp(x.toDouble().valueOf()) + Math.exp(-x.toDouble().valueOf())) / 2);
		}
	},
	SH: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double((Math.exp(x.toDouble().valueOf()) - Math.exp(-x.toDouble().valueOf())) / 2);
		}
	},
	TH: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double((Math.exp(2 * x.toDouble().valueOf()) - 1) / (Math.exp(2 * x.toDouble().valueOf()) + 1));
		}
	},
	EXP: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.exp(x.toDouble().valueOf()));
		}
	},
	LN: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(Math.log(x.toDouble().valueOf()));
		}
	},
	LOG: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;
			return new tdouble.Double(parseFloat( (Math.log(x.toDouble().valueOf()) / Math.LN10).toFixed(10) ) );
		}
	},
	PI: {
		count: 0,
		fn: function() {
			return new tdouble.Double(Math.PI) ;
		}
	},
	SETBIT: {
		count: 3,
		fn: function(val,pos,bit) {
			return  bit==1 ? val | (1 << (pos-1)) : val & ~(1 << (pos-1));
		}
	},
	GETBIT: {
		count: 2,
		fn: function(val,pos) {
			return (val & (1 << (pos-1)))?1:0;
		}
	}
};