"use strict";
var util = require('./util') ;
var errors = require('./errors') ;
var X3Error = errors.X3Error ;
var glob = require('streamline/lib/globals') ;
var bcd = require('etna-engine/lib/runtime/bcd') ;
var operators = require('./operators').binaryOps ;
var operatorsRoot = require('./operators') ;
var integer = require('./integer') ;
var convert = require('./convert') ;
var tdouble = require('./tdouble') ;

function fac(n) {
	return (n > 1) ? n * fac(n - 1) : 1;
}
function anp(n, p) {
	return fac(n)/fac(n-p);
}

function toRadians(angle) {
	var frame = glob.context.x3frame;
	switch(frame.context.sys.values.adxmda) {
		case 0 : return angle * (Math.PI / 180); //Degrees => Radians
		case 2 : return angle * (Math.PI / 200); //Grades => Radians
	}
	return angle;
}

exports.functions = {
	ABS: {
		count: 1,
		fn: function(x) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			return x.abs()
		}
	},
	MOD: {
		count: 2,
		fn: function mod(x, y) {
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			if (!y.isNumeric()) throw util.badOperand(y) ;	
			return x.mod(y) ;
		}
	},
	RND: {
		count: 1,
		fn: function(x) {
			//return convert.toDouble(x) * Math.random() ;
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			return new tdouble.Double(x.toDouble().valueOf()*Math.random());
		}
	},
	SGN: {
		count: 1,
		fn: function(x) {
			//return operatorsRoot.Compare(x, 0) ;
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			return new tinteger.Integer(x.compare(0));
		}
	},
	SQR: {
		count: 1,
		fn: function(x) { 
			//return  Math.sqrt(convert.toDouble(v)) ;
			if (!x.isNumeric()) throw util.badOperand(x) ;	
			return new tdouble.Double(Math.sqrt(x.toDouble().valueOf()));
		}
	},
	AR2: {
		count: 1,
		fn: function(v) {
			if (integer.isInteger(v)) return v ;
			else if (typeof v === "number") return Math.floor(v * 100 + 0.5) / 100 ;
			else if (bcd.isBCD(v)) {			
				var b = operators.ADD( operators.MUL(bcd.abs(v), bcd.fromDouble(100)), bcd.fromDouble(0.5) ) ;
				if (operators.LE(v, bcd.fromDouble(0))) return bcd.minus(operators.DIV(bcd.truncate(b,0), bcd.fromDouble(100))) ;
				else return operators.DIV(bcd.truncate(b,0), bcd.fromDouble(100)) ;
			}
			else throw util.badOperand(v) ;
		}
	},
	ARR: {
		count: 2,
		fn: function(x, y) {
			if ((typeof y === "number") && (y === 0)) return( x ) ;
			if (bcd.isBCD(y) && bcd.isZero(y)) return ( x ) ;
			if (integer.isInteger(y) && integer.isZero(y)) return x ;
						
			var val = operators.ADD( operators.DIV( x, y ) , bcd.fromDouble(0.5) ) ;			
			if (bcd.isBCD(val)) val = bcd.fromInt32(bcd.toInt32(val)) ;
			else if (typeof val === number) val = Math.floor(val) ;

			return operators.MUL( y, val ) ;
		}
	},
	FIX: {
		count: 1,
		fn: function(v) {
			if (integer.isInteger(v)) return v ;
			else if (typeof v === "number") return v >= 0 ? Math.floor(v) : -Math.floor(-v) ;
			else if (bcd.isBCD(v)) {
				var e = bcd.truncate(v, 0) ;
				if (operatorsRoot.Compare(e, bcd.fromDouble(2^31-1)) < 0) return integer.fromBCD(e) ;
				else return e ;

			}
			else throw util.badOperand(v) ;
		}
	},
	INT: {
		count: 1,
		fn: Math.floor

	},
	ANP: {
		count: 2,
		fn: anp
	},
	CNP: {
		count: 2,
		fn: function(n, p) {
			return anp(n, p) / anp(p);
		}
	},
	FAC: {
		count: 1,
		fn: fac
	},
	COS: {
		count: 1,
		fn: function(angle) {
			return Math.cos(toRadians(convert.toDouble(angle))) ;
		}
	},
	SIN: {
		count: 1,
		fn: function(angle) {
			return Math.sin(toRadians(convert.toDouble(angle))) ;
		}
	},
	TAN: {
		count: 1,
		fn: function(angle) {
			return Math.tan(toRadians(convert.toDouble(angle)));
		}
	},
	ACOS: {
		count: 1,
		fn: Math.acos
	},
	ASIN: {
		count: 1,
		fn: Math.asin
	},
	ATAN: {
		count: 1,
		fn: Math.atan
	},
	ACH: {
		count: 1,
		fn: function(x) {
			return Math.log(x + Math.sqrt(x * x - 1));
		}
	},
	ASH: {
		count: 1,
		fn: function(x) {
			return Math.log(x + Math.sqrt(x * x + 1));
		}
	},
	ATH: {
		count: 1,
		fn: function(x) {
			return Math.log((1 + x) / (1 - x)) / 2;
		}
	},
	CH: {
		count: 1,
		fn: function(x) {
			return (Math.exp(x) + Math.exp(-x)) / 2;
		}
	},
	SH: {
		count: 1,
		fn: function(x) {
			return (Math.exp(x) - Math.exp(-x)) / 2;
		}
	},
	TH: {
		count: 1,
		fn: function(x) {
			return (Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1);
		}
	},
	EXP: {
		count: 1,
		fn: Math.exp
	},
	LN: {
		count: 1,
		fn: Math.log
	},
	LOG: {
		count: 1,
		fn: function(val) {
			if (typeof val === "number") return parseFloat( (Math.log(val) / Math.LN10).toFixed(10) );
			else if (integer.isInteger(val)) return  parseFloat( (Math.log(integer.toDouble(val)) / Math.LN10).toFixed(10) ) ;
			else if (bcd.isBCD(val)) return parseFloat( (Math.log(bcd.toDouble(val)) / Math.LN10).toFixed(10) ) ;
			else throw util.badOperand(val) ;
		}
	},
	PI: {
		count: 0,
		fn: function() {
			return Math.PI ;
		}
	},
	SETBIT: {
		count: 3,
		fn: function(val,pos,bit) {
			return  bit==1 ? val | (1 << (pos-1)) : val & ~(1 << (pos-1));
		}
	},
	GETBIT: {
		count: 2,
		fn: function(val,pos) {
			return (val & (1 << (pos-1)))?1:0;
		}
	}
};