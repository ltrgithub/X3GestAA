"use strict";
var helpers = require('syracuse-core/lib/helpers');
var util = require('./util');

var Blbfile = helpers.defineClass(function(v) { // constructor
	var self = this;
	if (v instanceof Buffer) {
		self.value = v;
	} else throw util.badOperand(v);
}, null, { // Pass null if no parent class - public methods follow

	valueOf: function() {
		var self = this;
		return self.value;
	},
	// more public methods
	x3IsNumeric: function() {
		return false;
	},
	x3AssertOverflow: function(type) {
		return true;
	},

	x3Minus: function(v) {
		throw util.badOperand(v);
	},

	x3ToDouble: function(v) {
		throw util.badOperand(v);
	},

	x3ToString: function(t) {
		return this.value.toString(t === 50 ? 'binary' : 'utf8');
	},
	x3ToBase64: function() {
		return this.value.toString('base64');
	},

	x3ToBCD: function(v) {
		throw util.badOperand(v);
	},

	x3ToInteger: function() {
		var self = this;
		var b = this.value;
		var uint8 = function(v) {
			return (v < 0) ? v + 256 : v;
		};
		var int32 = function(v) {
			return (v >= Math.pow(2, 31)) ? v - Math.pow(2, 32) : v;
		};
		var int16 = function(v) {
			return (v >= Math.pow(2, 15)) ? v - Math.pow(2, 16) : v;
		};

		switch (b.length) {
			case 4:
				return int32((uint8(b.readInt8(0)) << 24) + (uint8(b.readInt8(1)) << 16) + (uint8(b.readInt8(2)) << 8) + uint8(b.readInt8(3)));
			case 2:
				return int16((uint8(b.readInt8(0)) << 8) + uint8(b.readInt8(1)));
			case 1:
				return b.readInt8(0);
			default:
				throw util.badOperand(v);
		}

	},

	x3ToDate: function(v) {
		throw util.badOperand(v);
	},

	x3ToDatetime: function(v) {
		throw util.badOperand(v);
	},

	x3IsZero: function(v) {
		throw util.badOperand(v);
	},

	x3IsEmpty: function(v) {
		throw util.badOperand(v);
	},

	x3Length: function() {
		var self = this;
		return self.value.length;
	},

	x3Compare: function(b) {
		var self = this;
		if (!util.x3IsBlbfile(b))
			throw util.badOperand(b);

		if (self.value.length < b.value.length) return -1;
		else if (self.value.length > b.value.length) return 1;
		else {
			for (var i = 0; i < this.value.length; i++) {
				if (self.value[i] < b.value[i]) return -1;
				else if (self.value[i] > b.value[i]) return 1;
			}
			return 0;
		}
	},

	x3Add: function(b) {
		throw util.badOperand(b);
	},

	x3Sub: function(b) {
		throw util.badOperand(b);
	},

	x3Mul: function(b) {
		throw util.badOperand(b);
	},

	x3Div: function(b) {
		throw util.badOperand(b);
	},

	x3Mod: function(b) {
		throw util.badOperand(b);
	},

	x3Pow: function(b) {
		throw util.badOperand(b);
	},

	x3Xor: function(b) {
		throw util.badOperand(b);
	},

	x3Abs: function(v) {
		throw util.badOperand(v);
	},

	x3Truncate: function(v) {
		throw util.badOperand(v);
	}
});

function fromString(s, t) {
	return new Blbfile(new Buffer(s, t === 50 ? 'binary' : 'utf8'));
}

function fromBase64(s) {
	return new Blbfile(new Buffer(s, 'base64'));
}

exports.Blbfile = Blbfile;

exports.functions = {
	TOBLBFILE: {
		count: 2,
		fn: function(c, t) {
			if (typeof c !== 'string') throw util.badOperand(c);
			if (typeof t !== 'number') throw util.badOperand(t);
			return fromString(c, t);
		}
	},
	TOCLBFILE: {
		count: 2,
		fn: function(b, t) {
			if (!util.x3IsBlbfile(b)) throw util.badOperand(b);
			if (typeof t !== 'number') throw util.badOperand(t);
			return b.x3ToString(t);
		}
	},
	TOBASE64: {
		count: 1,
		fn: function(b) {
			if (util.x3IsBlbfile(b)) return b.x3ToBase64();
			if (typeof b === 'string') return fromString(b).x3ToBase64();

			throw util.badOperand(b);
		}
	},
	FROMBASE64: {
		count: 1,
		fn: function(c) {
			if (typeof c !== 'string') throw util.badOperand(c);
			return fromBase64(c);
		}
	}
};

exports.fromString = fromString;
exports.fromBase64 = fromBase64;