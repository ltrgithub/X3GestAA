"use strict";

var date = require('syracuse-core/lib/types/date');
var util = require('./util');
var variables = require('./variables');
var trimFuncs = require('./strings').trimFuncs;
var bcd = require('etna-engine/lib/runtime/bcd') ;
var integer = require('./integer');
var undefined;

var _unaryOps = {
	USUB: function minus(a) {
		return -a;
	},
	UADD: function minus(a) {
		return +a;
	},
	NOT: function not(a) {
		if (integer.isInteger(a)) return integer.isZero(a)?1:0 ;
		else if (bcd.isBCD(a)) return bcd.isZero(a)?1:0 ;
		else return a?0:1;
	}
};

exports.round = function (val) {
	return Math.round(val * 1e6) / 1e6;
}

function compare( a, b ) {
	var ta = typeof a,
		tb = typeof b;
try {
	if (integer.isInteger(a) && integer.isInteger(b))
		return integer.compare(a, b) ;
	else if ((ta === "number") || (tb == "number"))
	{
		console.log( "compare number || number ")
		if (ta !== "number")
		{
			console.log( "compare a != number ")
			if (bcd.isBCD(a)) a = bcd.toDouble(a)
			else if (integer.isInteger(a)) a = integer.toDouble(a) ;
			else throw util.badOperand(a);
		}
		if (tb !== "number")
		{
			if (bcd.isBCD(b)) b = bcd.toDouble(b) ;
			else if (integer.isInteger(b)) b = integer.toDouble(b) ;				
			else throw util.badOperand(b);
		}
		console.log( "ouf passe! !! 1.0 ")
		var e = (a >= 0)? a : -a ;
		var d = (b >= 0)? b : -b ;

		console.log( "ouf passe! !! 1.1 ")
		if (d < e) e = d ;
		if (e === 0) e = 1 ;
		e /= 10 ;
		d = a - b ;
		console.log( "ouf passe! !! 1.2 ")
		if ((-e < d) && (d < e)) return 0
		else if (d >= e) return 1 ;
		else return -1 ;
	} else if (bcd.isBCD(a) || bcd.isBCD(b)) {
		if (!bcd.isBCD(a)) {
			if (ta === "number") return bcd.compare(bcd.fromDouble(a), b)
			else if (integer.isInteger(a)) return bcd.compare(bcd.fromInteger(a), b) ;
			else throw util.badOperand(a);
		}
		if (!bcd.isBCD(b)) {
			if (tb === "number") return bcd.compare(a, bcd.fromDouble(b)) ;
			else if (integer.isInteger(b)) return bcd.compare(a, bcd.fromInteger(b)) ;
			else throw util.badOperand(b);
		}
		return bcd.compare( a, b ) ;			
	} else if (date.isDate(a) || date.isDate(b)) {
		if (!date.isDate(a))
		{
			if (ta === "string") a = date.from
		}
		if (!date.isDate(b))
		{
			
		}
		return a.compare(b) ;
	} else if ((ta === "string") && (tb === "string")) {
		if (a === b) return 0 ;
		else if (a < b) return -1 ;
		else return 1 ;
	}
	else throw util.badOperand(undefined);
} catch (e) {console.log(e) ; } ;

}

exports.binaryOps = {
	ADD: function add(a, b) {
		var ta = typeof a,
			tb = typeof b;		

		if (integer.isInteger(a) && integer.isInteger(b)) return integer.add( a, b ) ;
		else if ((ta === "string") || (tb === "string"))
		{
			if (ta !== "string")
			{
				if (date.isDate(a)) return a.toString("yyyyMMdd")+b ;
				else throw util.badOperand(a);
			}
			if (tb !== "string")
			{
				if (date.isDate(b)) return a+b.toString("yyyyMMdd") ;
				else throw util.badOperand(b);	
			}
			return a + b ;
		}
		else if (date.isDate(a)) {
			if (bcd.isBCD(b)) return a.addDays(bcd.toInt32(b))
			else if (integer.isInteger(b)) return a.addDays(integer.toDouble(b));
			else if (tb === "number") return a.addDays((b >= 0)?Math.floor(b):Math.ceil(b)) ;
			else throw util.badOperand(b);
		} else if (date.isDate(b)) {
			if (bcd.isBCD(a)) return b.addDays(bcd.toInt32(a))
			else if (integer.isInteger(a)) return b.addDays(integer.toDouble(a));
			else if (ta === "number") return b.addDays((a >= 0)?Math.floor(a):Math.ceil(a)) ;
			else throw util.badOperand(a);
		} else if ((ta === "number") || (tb === "number")) {
			if (ta !== "number") {
				if (bcd.isBCD(a)) return b+bcd.toDouble(a)
				else if (integer.isInteger(a)) return b+integer.toDouble(a) ;
				else throw util.badOperand(a);
			}
			if (tb !== "number") {
				if (bcd.isBCD(b)) return a+bcd.toDouble(b) ;
				else if (integer.isInteger(b)) return a+integer.toDouble(b) ;				
				else throw util.badOperand(b);
			}
			return a+b ;
		} else if (bcd.isBCD(a) || bcd.isBCD(b)) {
			if (!bcd.isBCD(a)) {
				if (ta === "number") return bcd.add(bcd.fromDouble(a), b)
				else if (integer.isInteger(a)) return bcd.add(bcd.fromInteger(a), b) ;
				else throw util.badOperand(a);
			}
			if (!bcd.isBCD(b)) {
				if (tb === "number") return bcd.add(a, bcd.fromDouble(b)) ;
				else if (integer.isInteger(b)) return bcd.add(a, bcd.fromInteger(b)) ;
				else throw util.badOperand(b);
			}
			return bcd.add( a, b ) ;
		}
		else
			throw util.badOperand(undefined);

	},
	SUB: function sub(a, b) {
		var ta = typeof a,
			tb = typeof b;

		if (integer.isInteger(a) && integer.isInteger(b)) return integer.sub( a, b ) ;
		else if ((ta === "string") || (tb === "string"))
		{
			if (ta !== "string")
			{
				if (date.isDate(a)) return trimFuncs[1](a.toString("yyyyMMdd")) + " " + trimFuncs[0](b) ;
				else throw util.badOperand(a);
			}
			if (tb !== "string")
			{
				if (date.isDate(b)) return trimFuncs[1](a) + " " + trimFuncs[0](b.toString("yyyyMMdd")) ;
				else throw util.badOperand(b);	
			}
			return trimFuncs[1](a) + " " + trimFuncs[0](b) ;
		}
		else if (date.isDate(a)) {
			if (date.isDate(b)) return a.daysDiff(b);
			else if (bcd.isBCD(b)) return a.addDays(-bcd.toInt32(b)) ;
			else if (integer.isInteger(b)) return a.addDays(-bcd.toDouble(b)) ;
			else if (tb === "number") return a.addDays(-b);
			else throw util.badOperand(b);
		} else if ((ta === "number") || (tb === "number")) {
			if (ta !== "number") {
				if (bcd.isBCD(a)) return b-bcd.toDouble(a)
				else if (integer.isInteger(a)) return b-integer.toDouble(a) ;
				else throw util.badOperand(a);
			}
			if (tb !== "number") {
				if (bcd.isBCD(b)) return a-bcd.toDouble(b) ;
				else if (integer.isInteger(b)) return a-integer.toDouble(b) ;				
				else throw util.badOperand(b);
			}
			return a-b ;
		} else if (bcd.isBCD(a) || bcd.isBCD(b)) {
			if (!bcd.isBCD(a)) {
				if (ta === "number") return bcd.sub(bcd.fromDouble(a), b)
				else if (integer.isInteger(a)) return bcd.sub(bcd.fromInteger(a), b) ;
				else throw util.badOperand(a);
			}
			if (!bcd.isBCD(b)) {
				if (tb === "number") return bcd.sub(a, bcd.fromDouble(b)) ;
				else if (integer.isInteger(b)) return bcd.sub(a, bcd.fromInteger(b)) ;
				else throw util.badOperand(b);
			}
			return bcd.sub(a, b) ;
		}
		else
			throw util.badOperand(undefined) ;

	},
	MUL: function mul(a, b) {
		var ta = typeof a,
			tb = typeof b;
		
		if (integer.isInteger(a) && integer.isInteger(b)) return integer.multiply( a, b ) ;
		else if ((ta === "number")  || (tb === "number")) {		
			if (ta !== "number") {
				if (bcd.isBCD(a)) return  bcd.toDouble(a) * b ;
				else if (integer.isInteger(a)) return integer.toDouble(a) * b ;
				else throw util.badOperand(a);
			}
			if (tb !== "number") {
				if (bcd.isBCD(b)) return  bcd.toDouble(b) * a ;
				else if (integer.isInteger(b)) return integer.toDouble(b) * a ;
				else throw util.badOperand(b);
			}
			return a * b		
		} else if (bcd.isBCD(a) || bcd.isBCD(b)) {
			if (!bcd.isBCD(a)) {
				if (ta === "number") return bcd.multiply(bcd.fromDouble(a), b)
				else if (integer.isInteger(a)) return bcd.multiply(bcd.fromInteger(a), b) ;
				else throw util.badOperand(a);
			}
			if (!bcd.isBCD(b)) {
				if (tb === "number") return bcd.multiply(a, bcd.fromDouble(b)) ;
				else if (integer.isInteger(b)) return bcd.multiply(a, bcd.fromInteger(b)) ;
				else throw util.badOperand(b);
			}
			return bcd.multiply( a, b ) ;
		}
		else
			throw util.badOperand(undefined) ;
	},
	DIV: function div(a, b) {
		var ta = typeof a,
			tb = typeof b;

		if ((ta === "number") || (tb === "number")) {
			if (ta !== "number") {
				if (b === 0)  throw new X3Error(53) ;

				if (bcd.isBCD(a)) return  bcd.toDouble(a) / b ;
				else if (integer.isInteger(a)) return integer.toDouble(a) / b ;				
				else throw util.badOperand(a);
			}
			if (tb !== "number") {
				if (bcd.isBCD(b)) {
					var dbl = bcd.toDouble(b) ;
					if (dbl === 0 )  throw new X3Error(53) ;
					return  a / dbl ;
				} else if (integer.isInteger(b)) {
					var dbl = integer.toDouble(b) ;
					if (dbl === 0 )  throw new X3Error(53) ;
					return a / dbl ;
				}
				else throw util.badOperand(b);
			}
			return a / b ;
		} else if (bcd.isBCD(a) || bcd.isBCD(b)) {
			if (!bcd.isBCD(a)) {
				if (bcd.isZero( b )) throw new X3Error(53) ;

				if (ta === "number") return bcd.divide(bcd.fromDouble(a), b)
				else if (integer.isInteger(a)) return bcd.divide(bcd.fromInteger(a), b) ;
				else throw util.badOperand(a);
			}
			if (!bcd.isBCD(b)) {

				if (tb === "number") {
					if (b === 0)  throw new X3Error(53) ;
					return bcd.divide(a, bcd.fromDouble(b)) ;
				} else if (integer.isInteger(b)) {
					if (integer.isZero(b)) throw new X3Error(53) ;
				 	return bcd.divide(a, bcd.fromInteger(b)) ;
				}
				else throw util.badOperand(b);
			}
			return bcd.divide( a, b )	;
		} else if (integer.isInteger(a) && integer.isInteger(b)) {
			if (integer.isZero( b )) throw new X3Error(53) ;

			if (integer.isModulo(a, b)) return integer.divide(a, b) ;
			else return bcd.divide( bcd.fromInteger(a), bcd.fromInteger(b)) ;
			
		} else throw util.badOperand(undefined) ;
		
	},
	MOD: function mod(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (integer.isInteger(a) && integer.isInteger(b)) {
			return a.toDouble(a)%a.toDouble(b)
		}
		else if (ta === "number" || tb === "number") {
			if (ta !== "number") {
				if (bcd.isBCD(a)) return  bcd.toDouble(a) % b ;
				else if (integer.isInteger(a)) return integer.toDouble(a) % b ;				
				else throw util.badOperand(a);
			}
			if (tb !== "number") {
				if (bcd.isBCD(b)) return  a / bcd.toDouble(b) ;
				else if (integer.isInteger(b)) return a / integer.toDouble(b) ;
				else throw util.badOperand(b);
			}
			return a % b
		}
		else if (bcd.isBCD(a) || bcd.isBCD(b)) {
			var bcda ;
			var bcdb ;
			if (!bcd.isBCD(a)) {
				bcdb = b ;
				if (ta === "number") bcda = bcd.fromDouble(a) ;
				else if (integer.isInteger(a)) bcda = bcd.fromInteger(a) ;
				else throw util.badOperand(a);
			}
			if (!bcd.isBCD(b)) {
				bcda = a ;
				if (tb === "number") bcdb = bcd.fromDouble(b) ;
				if (integer.isInteger(b)) bcdb =  bcd.fromInteger(b) ;
				else throw util.badOperand(b);
			}
			
			var dv = bcd.div( bcda, bcdb) ;
			var fx = bcd.toInt32( dv ) ;
			var ml = bcd.mul( bcd.fromInt32(fx), bcdb ) ;
			return bcd.sub( bcda, ml ) ;
		}
		else throw util.badOperand(undefined);
	},
	POW: function pow(a, b) {
		var ta = typeof a,
			tb = typeof b;
		

		if (integer.isInteger(a)) {
		 	if (integer.isInteger(b)) { 
		 		return integer.pow(a, b) ;
		 	}
		 	if (typeof b === "number") {
		 		return Math.pow( integer.toDouble(a), b ) ;
		 	}
		} else if (ta === "number") {
			if (tb === "number") {		 	
		 		return Math.pow(a, b) ;
		 	}
		 	if (integer.isInteger(b)) {		 	
		 		return Math.pow(a, integer.toDouble(b)) ;
		 	}
		}
		
		/*
			if (bcd.isBCD(b)) b = bcd.toInt32(b) ;

			if (ta === "number" && a === 0) return 0 ;
			if (bcd.isBCD(a) && bcd.isZero(a)) return 0 ;

			var rs = 1 ;
			if (bcd.isBCD(a)) a = bcd.toDouble(a) ;
			for (var i = b; i > 0; i-- ) rs =  rs*a ;
		
			return bcd.fromDouble(rs) ;
		*/
	},
	XOR: function xor(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a ^ b ;
		if (bcd.isBCD(a) || bcd.isBCD(a))
		{
			var bcda ;
			var bcdb ;
			if (ta === "number") {
				bcda = bcd.fromInt32( a ) ;
				bcdb = b ;
			} else if (tb === "number"){
				bcda = a ;
				bcdb = bcd.fromInt32( b ) ;
			} else {
				bcda = a ;
				bcdb = b ;
			}
			if (!bcd.isBCD(a) || !bcd.isBCD(b)) throw !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);

			var zero = bcd.fromInt32(0) ;
			var za = bcd.compare( bcda, zero )? 0 : 1 ;
			var zb = bcd.compare( bcdb, zero )? 0 : 1 ;

			return za ^ zb ;			
		}
		throw ta !== "number" && !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);
	},

	EQ: function eq(a, b) {
		return compare(a, b) === 0 ? 1 : 0 ;
	},
	NE: function ne(a, b) {
		return compare(a, b) === 0 ? 0 : 1 ;
	},
	LT: function lt(a, b) {
		return compare(a, b) < 0 ? 1 : 0
	},
	LE: function le(a, b) {
		return compare(a, b) <= 0 ? 1 : 0
	},
	GT: function gt(a, b) {
		return compare(a, b) > 0 ? 1 : 0
	},
	GE: function ge(a, b) {
		return compare(a, b) >= 0 ? 1 : 0
	},
};

/* 
 * Operators
 */

function op1(f) {
	return function(f1) {
		return function op1$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
			return f(v11);
		};
	};
}

function op2(f) {
	return function(f1, f2) {
		return function op2$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_), f2.value !== undefined ? f2.value : f2(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
			var v2= (f2.value !== undefined ? f2.value : f2(_));

 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
 		    var v22= (Array.isArray(v2)? (v2[2][0] === undefined ? v2[1] : v2[2][0]) : v2);
			return f(v11, v22);
		};
	};
}

exports.instructions = {
	AND: function(f1, f2) {
		return function and$do(_) {
			return f1(_) && f2(_);
		};
	},
	OR: function(f1, f2) {
		return function or$do(_) {
			return f1(_) || f2(_);
		};
	},
	PLUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.ADD(lhs, rhs));
	},
	MINUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.SUB(lhs, rhs));
	},
	MULEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.MUL(lhs, rhs));
	},
	DIVEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.DIV(lhs, rhs));
	}
};

for (var op in _unaryOps) exports.instructions[op] = op1(_unaryOps[op]);
for (var op in exports.binaryOps) exports.instructions[op] = op2(exports.binaryOps[op]);
//for (var op in _binaryOps) exports.binaryOps[op] = _binaryOps[op] ;
//for (var op in _unaryOps) exports.unaryOps[op] = _unaryOps[op];