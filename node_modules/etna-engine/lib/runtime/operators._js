"use strict";

var date = require('syracuse-core/lib/types/date');
var util = require('./util');
var variables = require('./variables');
var trimFuncs = require('./strings').trimFuncs;

var undefined;

var _unaryOps = {
	USUB: function minus(a) {
		if (a.x3IsNumeric( )) return a.x3Minus( ) ;
		else throw util.badOperand(a) ;
	},

	UADD: function plus(a) {
		if (a.x3IsNumeric( )) return a ;
		else throw util.badOperand(a) ;
	},

	NOT: function not(a) {
		if (a.x3IsNumeric( )) return (a.x3IsZero( ) ? 1 : 0 ) ;
		else throw util.badOperand(a) ;
	}
};

exports.round = function (val) {
	return Math.round(val * 1e6) / 1e6;
}

exports.binaryOps = {
	ADD: function add(a, b) {
		return a.x3Add( b ) ;
	},
	SUB: function sub(a, b) {
		return a.x3Sub( b ) ;
	},
	MUL: function mul(a, b) {
		return a.x3Mul( b ) ;
	},
	DIV: function div(a, b) {
		return a.x3Div( b ) ; 
	},
	MOD: function mod(a, b) {
		return a.x3Mod( b ) ;
	},
	POW: function pow(a, b) {
		return a.x3Pow( b ) ;
	},
	XOR: function xor(a, b) {
		return a.x3Xor( b ) ;
	},
	EQ: function eq(a, b) {
		return ( a.compare(b) === 0 ? 1 : 0 ) ;
	},
	NE: function ne(a, b) {
		return ( a.compare(b) === 0 ? 0 : 1 ) ;
	},
	LT: function lt(a, b) {
		return ( a.compare(b) < 0 ? 1 : 0 ) ;
	},
	LE: function le(a, b) {
		return ( a.compare(b) <= 0 ? 1 : 0 ) ;
	},
	GT: function gt(a, b) {
		return ( a.compare(b) > 0 ? 1 : 0 ) ;
	},
	GE: function ge(a, b) {
		return ( a.compare(b) >= 0 ? 1 : 0 ) ;
	},
};

/* 
 * Operators
 */

function op1(f) {
	return function(f1) {
		return function op1$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
			return f(v11);
		};
	};
}

function op2(f) {
	return function(f1, f2) {
		return function op2$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_), f2.value !== undefined ? f2.value : f2(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
			var v2= (f2.value !== undefined ? f2.value : f2(_));

 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
 		    var v22= (Array.isArray(v2)? (v2[2][0] === undefined ? v2[1] : v2[2][0]) : v2);
			return f(v11, v22);
		};
	};
}

exports.instructions = {
	AND: function(f1, f2) {
		return function and$do(_) {
			var op1 = f1(_) ;
			var op2 = f2(_) ;
			if (!op1.x3IsNumeric( )) throw util.badOperand(op1) ;
			if (!op2.x3IsNumeric( )) throw util.badOperand(op2) ;

			return new Integer((!op1.isZero( ) && !op2.isZero( ))?1:0);
		};
	},
	OR: function(f1, f2) {
		return function or$do(_) {
			var op1 = f1(_) ;
			var op2 = f2(_) ;
			if (!op1.x3IsNumeric( )) throw util.badOperand(op1) ;
			if (!op2.x3IsNumeric( )) throw util.badOperand(op2) ;

			return new Integer((!op1.isZero( ) || !op2.isZero( ))?1:0);
		};
	},
	PLUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.ADD(lhs, rhs));
	},
	MINUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.SUB(lhs, rhs));
	},
	MULEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.MUL(lhs, rhs));
	},
	DIVEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.DIV(lhs, rhs));
	}
};

for (var op in _unaryOps) exports.instructions[op] = op1(_unaryOps[op]);
for (var op in exports.binaryOps) exports.instructions[op] = op2(exports.binaryOps[op]);
//for (var op in _binaryOps) exports.binaryOps[op] = _binaryOps[op] ;
//for (var op in _unaryOps) exports.unaryOps[op] = _unaryOps[op];