"use strict";

var date = require('syracuse-core/lib/types/date');
var util = require('./util');
var variables = require('./variables');
var trimFuncs = require('./strings').trimFuncs;
var undefined;

var _unaryOps = {
	USUB: function minus(a) {
		return -a;
	},
	UADD: function minus(a) {
		return +a;
	},
	NOT: function not(a) {
		return a?0:1;
	}
};

exports.round = function (val) {
	return Math.round(val * 1e6) / 1e6;
}

var _binaryOps = {
	ADD: function add(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a + b;
		if (ta === "string" && tb === "string") return a + b;
		if (date.isDate(a) && tb === "number") return a.addDays(b);
		if (date.isDate(b) && ta === "number") return b.addDays(a);
		throw (ta !== "number" && ta !== "string" && !date.isDate(a)) ? util.badOperand(a) : util.badOperand(b);
	},
	SUB: function sub(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a - b;
		if (ta === "string" && tb === "string") return trimFuncs[1](a) + " " + trimFuncs[0](b);
		if (date.isDate(a) && tb === "number") return a.addDays(-b);
		if (date.isDate(a) && date.isDate(b)) return a.daysDiff(b);
		throw (ta !== "number" && ta !== "string" && !date.isDate(a)) ? util.badOperand(a) : util.badOperand(b);
	},
	MUL: function mul(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a * b;
		throw ta !== "number" ? util.badOperand(a) : util.badOperand(b);
	},
	DIV: function div(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") {
			if (b === 0) throw new X3Error(53);
			return a / b;
		}
		throw ta !== "number" ? util.badOperand(a) : util.badOperand(b);
	},
	MOD: function mod(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") {
			if (b === 0) throw new X3Error(53);
			return a % b;
		}
		throw ta !== "number" ? util.badOperand(a) : util.badOperand(b);
	},
	POW: function pow(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return Math.pow(a, b);
		throw ta !== "number" ? util.badOperand(a) : util.badOperand(b);
	},
	XOR: function xor(a, b) {
		return a ^ b;
	},
	EQ: function eq(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.equals(b);
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) == 0) ? 1 : 0;
		}
		return a == b ? 1 : 0;
	},
	NE: function ne(a, b) {
		if (date.isDate(a) && date.isDate(b)) return !a.equals(b);
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) != 0) ? 1 : 0;
		}
		return a != b ? 1 : 0;
	},
	LT: function lt(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) < 0;
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) < 0) ? 1 : 0;
		}
		return a < b ? 1 : 0;
	},
	LE: function le(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) <= 0;
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) <= 0) ? 1 : 0;
		}
		return a <= b ? 1 : 0;
	},
	GT: function gt(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) > 0;
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) > 0) ? 1 : 0;
		}
		return a > b ? 1 : 0;
	},
	GE: function ge(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) >= 0;
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) >= 0) ? 1 : 0;
		}
		return a >= b ? 1 : 0;
	},
};

/* 
 * Operators
 */

function op1(f) {
	return function(f1) {
		return function op1$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
			return f(v11);
		};
	};
}

function op2(f) {
	return function(f1, f2) {
		return function op2$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_), f2.value !== undefined ? f2.value : f2(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
			var v2= (f2.value !== undefined ? f2.value : f2(_));

 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
 		    var v22= (Array.isArray(v2)? (v2[2][0] === undefined ? v2[1] : v2[2][0]) : v2);
			return f(v11, v22);
		};
	};
}

exports.instructions = {
	AND: function(f1, f2) {
		return function and$do(_) {
			return f1(_) && f2(_);
		};
	},
	OR: function(f1, f2) {
		return function or$do(_) {
			return f1(_) || f2(_);
		};
	},
	PLUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.ADD(lhs, rhs));
	},
	MINUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.SUB(lhs, rhs));
	},
	MULEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.MUL(lhs, rhs));
	},
	DIVEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.DIV(lhs, rhs));
	}
};

for (var op in _unaryOps) exports.instructions[op] = op1(_unaryOps[op]);
for (var op in _binaryOps) exports.instructions[op] = op2(_binaryOps[op]);