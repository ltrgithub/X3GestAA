"use strict";

var date = require('syracuse-core/lib/types/date');
var util = require('./util');
var variables = require('./variables');
var trimFuncs = require('./strings').trimFuncs;
var bcd = require('etna-engine/lib/runtime/bcd') ;
var undefined;

var _unaryOps = {
	USUB: function minus(a) {
		return -a;
	},
	UADD: function minus(a) {
		return +a;
	},
	NOT: function not(a) {
		return a?0:1;
	}
};

exports.round = function (val) {
	return Math.round(val * 1e6) / 1e6;
}

exports.binaryOps = {
	ADD: function add(a, b) {
		var ta = typeof a,
			tb = typeof b;		
		
		if (bcd.isBCD(a)) {
			if (bcd.isBCD(b)) return bcd.add(a, b);
			if (date.isDate(b)) return b.addDays(bcd.toInt32(a));
			if (tb === "number") return bcd.add(a, bcd.fromInt32(b)) ;
		}
		if (date.isDate(a)) {
			if (tb === "number") return a.addDays(b);
			if (bcd.isBCD(b)) return a.addDays(bcd.toInt32(b));
			if (tb === "string") return a.toString("yyyyMMdd")+b ;
		}

		if (ta === "number") {
			if (date.isDate(b)) return b.addDays(a);
			if (bcd.isBCD(b)) return bcd.add(bcd.fromInt32(a), b) ;
			if (tb === "number") return a + b;
		}

		if (ta === "string") { 
			if (date.isDate(b)) return a+b.toString("yyyyMMdd") ;
			if (tb === "string") return a + b;
		}

		throw (ta !== "number" && ta !== "string" && !date.isDate(a)) ? util.badOperand(a) : util.badOperand(b);
	},
	SUB: function sub(a, b) {
		var ta = typeof a,
			tb = typeof b;

		if (ta === "number") { 
			if (tb === "number") return a - b;
			if (bcd.isBCD(b)) return bcd.sub( bcd.fromInt32(a),  b ) ;
		}
		if (ta === "string") {
			if (tb === "string") return trimFuncs[1](a) + " " + trimFuncs[0](b);
			if (date.isDate(b)) return trimFuncs[1](a) + " " + trimFuncs[0](b.toString("yyyyMMdd")) ;
		}	
		if (date.isDate(a)) { 
			if (date.isDate(b)) return a.daysDiff(b);
			if (tb === "number") return a.addDays(-b);
			if (bcd.isBCD(b)) return a.addDays(bcd.toInt32(-b));
			if (tb === "string") return trimFuncs[1](a.toString("yyyyMMdd"))+ " " + trimFuncs[0](b) ;
		}
		if (bcd.isBCD(a)) {
			if (bcd.isBCD(b)) return bcd.sub( a, b ) ;
			if (tb === "number") return bcd.sub( a, bcd.fromInt32( b )) ;
		}

		throw (ta !== "number" && ta !== "string" && !date.isDate(a)) ? util.badOperand(a) : util.badOperand(b);
	},
	MUL: function mul(a, b) {
		var ta = typeof a,
			tb = typeof b;

		if (ta === "number") {
			if (tb === "number")	return a * b;		
			if (bcd.isBCD(b)) return bcd.multiply( b, bcd.fromInt32(a)) ;
		}

		if (bcd.isBCD(a)) { 
			if (tb === "number") return bcd.multiply( a, bcd.fromInt32(b)) ;
			if (bcd.isBCD(b)) return bcd.multiply( a, b ) ;
		}
		
		throw (ta !== "number" && !bcd.isBCD(a))? util.badOperand(a) : util.badOperand(b);
	},
	DIV: function div(a, b) {
		var ta = typeof a,
			tb = typeof b;

		if (ta === "number") { 
			if (tb === "number") {
				if (b === 0) throw new X3Error(53) ;
				return (a % b)? bcd.divide( bcd.fromInt32( a ), bcd.fromInt32( b )) : a / b ;
			}
			if (bcd.isBCD(b)) {
				if (bcd.isZero( b )) throw new X3Error(53) ;
				return bcd.divide( bcd.fromInt32(a), b ) ;
			}	
		}		
		if (bcd.isBCD(a)) { 
			if (tb === "number") {
				if (b === 0) throw new X3Error(53) ;
				return bcd.divide( a, bcd.fromInt32(b) ) ;
			}
			if (bcd.isBCD(b)) {
				if (bcd.isZero( b )) throw new X3Error(53) ;
				return bcd.divide( a, b ) ; ;
			}
		}

		throw (ta !== "number" && !bcd.isBCD(a))? util.badOperand(a) : util.badOperand(b);
	},
	MOD: function mod(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") {
			if (b === 0) throw new X3Error(53);
			return a % b;
		}
		if (bcd.isBCD(a) || bcd.isBCD(b)) {
			var bcda ;
			var bcdb ;
			if (ta === "number") 	{
				bcda = bcd.fromInt32( a ) ;
				bcdb = b ;
			} else if (tb === "number"){
				bcda = a
				bcdb = bcd.fromInt32( b ) ;
			} else {
				bcda = a ;
				bcdb = b ;
			}
			if (!bcd.isBCD(a) || !bcd.isBCD(b)) throw !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);

			var dv = bcd.div( bcda, bcdb) ;
			var fx = bcd.toInt32( dv ) ;
			var ml = bcd.mul( bcd.fromInt32(fx), bcdb ) ;
			return bcd.sub( bcda, ml ) ;
		}
		throw ta !== "number" && !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);
	},
	POW: function pow(a, b) {
		var ta = typeof a,
			tb = typeof b;
		
		if (!(bcd.isBCD(a)) && (typeof a != "number")) throw util.badOperand(a) ;
		if (!(bcd.isBCD(b)) && (typeof b != "number")) throw util.badOperand(b) ;

		if (ta === "number" && tb === "number") return Math.pow(a, b);

		if (bcd.isBCD(b)) b = bcd.toInt32(b) ;

		if (ta === "number" && a === 0) return 0 ;
		if (bcd.isBCD(a) && bcd.isZero(a)) return 0 ;

		var rs = 1 ;
		if (bcd.isBCD(a)) a = bcd.toDouble(a) ;
		for (var i = b; i > 0; i-- ) rs =  rs*a ;
		
		return bcd.fromDouble(rs) ;
	},
	XOR: function xor(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a ^ b ;
		if (bcd.isBCD(a) || bcd.isBCD(a))
		{
			var bcda ;
			var bcdb ;
			if (ta === "number") {
				bcda = bcd.fromInt32( a ) ;
				bcdb = b ;
			} else if (tb === "number"){
				bcda = a ;
				bcdb = bcd.fromInt32( b ) ;
			} else {
				bcda = a ;
				bcdb = b ;
			}
			if (!bcd.isBCD(a) || !bcd.isBCD(b)) throw !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);

			var zero = bcd.fromInt32(0) ;
			var za = bcd.compare( bcda, zero )? 0 : 1 ;
			var zb = bcd.compare( bcdb, zero )? 0 : 1 ;

			return za ^ zb ;			
		}
		throw ta !== "number" && !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);
	},
	EQ: function eq(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.equals(b);

		if (bcd.isBCD(a)) { 
			if (date.isBCD(b)) return (bcd.compare( a, b ) === 0)? 1 : 0 ;
			if (typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) === 0)? 1 : 0 ;
		}
		if (typeof a === "number") { 
			if (bcd.isBCD(b)) return (bcd.compare( b, bcd.fromInt32(a) ) === 0)? 1 : 0 ;
			if (typeof b === "number") return (exports.round(a- b) == 0) ? 1 : 0;
		}

		return a == b ? 1 : 0;
	},
	NE: function ne(a, b) {
		if (date.isDate(a) && date.isDate(b)) return !a.equals(b);
		
		if (bcd.isBCD(a)) { 
			if (date.isBCD(b)) return (bcd.compare( a, b ) === 0)? 0 : 1 ;
			if (typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) === 0)? 0 : 1 ;
		}
		if (typeof a === "number") { 
			if (bcd.isBCD(b)) return (bcd.compare( b, bcd.fromInt32(a) ) === 0)? 0 : 1 ;
			if (typeof b === "number") return (exports.round(a- b) != 0) ? 1 : 0;
		}

		return a != b ? 1 : 0;
	},
	LT: function lt(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) < 0;
		if (bcd.isBCD(a)) {
			if (date.isBCD(b)) return (bcd.compare( a, b ) < 0)? 1 : 0 ;
			if (typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) < 0)? 1 : 0 ;
		}
		if (typeof a === "number") { 
			if (bcd.isBCD(b)) return (bcd.compare( b, bcd.fromInt32(a) ) > 0)? 1 : 0 ;
			if (typeof b === "number") return (exports.round(a- b) < 0) ? 1 : 0;
		}
		return a < b ? 1 : 0;
	},
	LE: function le(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) <= 0;

		if (bcd.isBCD(a)) { 
			if (date.isBCD(b)) return (bcd.compare( a, b ) <= 0)? 1 : 0 ;
			if (typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) <= 0)? 1 : 0 ;
		}
		if (typeof a === "number") { 
			if (bcd.isBCD(b)) return (bcd.compare( b, bcd.fromInt32(a) ) >= 0)? 1 : 0 ;		
			if (typeof b === "number") return (exports.round(a- b) <= 0) ? 1 : 0;
		}
		
		return a <= b ? 1 : 0;
	},
	GT: function gt(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) > 0;

		if (bcd.isBCD(a)) { 
			if (date.isBCD(b)) return (bcd.compare( a, b ) > 0)? 1 : 0 ;
			if (typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) > 0)? 1 : 0 ;
		}
		if (typeof a === "number") { 
			if (bcd.isBCD(b)) return (bcd.compare( b, bcd.fromInt32(a) ) < 0)? 1 : 0 ;
			if (typeof b === "number") return (exports.round(a- b) > 0) ? 1 : 0;
		}
		
		return a > b ? 1 : 0;
	},
	GE: function ge(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) >= 0;
		if (bcd.isBCD(a)) { 
			if (date.isBCD(b)) return (bcd.compare( a, b ) >= 0)? 1 : 0 ;
			if (typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) >= 0)? 1 : 0 ;
		}
		if (typeof a === "number") { 
			if (bcd.isBCD(b)) return (bcd.compare( b, bcd.fromInt32(a) ) <= 0)? 1 : 0 ;		
			if (typeof b === "number") return (exports.round(a- b) >= 0) ? 1 : 0;
		}
		return a >= b ? 1 : 0;
	},
};

/* 
 * Operators
 */

function op1(f) {
	return function(f1) {
		return function op1$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
			return f(v11);
		};
	};
}

function op2(f) {
	return function(f1, f2) {
		return function op2$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_), f2.value !== undefined ? f2.value : f2(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
			var v2= (f2.value !== undefined ? f2.value : f2(_));

 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
 		    var v22= (Array.isArray(v2)? (v2[2][0] === undefined ? v2[1] : v2[2][0]) : v2);
			return f(v11, v22);
		};
	};
}

exports.instructions = {
	AND: function(f1, f2) {
		return function and$do(_) {
			return f1(_) && f2(_);
		};
	},
	OR: function(f1, f2) {
		return function or$do(_) {
			return f1(_) || f2(_);
		};
	},
	PLUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.ADD(lhs, rhs));
	},
	MINUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.SUB(lhs, rhs));
	},
	MULEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.MUL(lhs, rhs));
	},
	DIVEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.DIV(lhs, rhs));
	}
};

for (var op in _unaryOps) exports.instructions[op] = op1(_unaryOps[op]);
for (var op in exports.binaryOps) exports.instructions[op] = op2(exports.binaryOps[op]);
//for (var op in _binaryOps) exports.binaryOps[op] = _binaryOps[op] ;
//for (var op in _unaryOps) exports.unaryOps[op] = _unaryOps[op];