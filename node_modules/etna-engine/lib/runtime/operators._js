"use strict";

var date = require('syracuse-core/lib/types/date');
var util = require('./util');
var variables = require('./variables');
var trimFuncs = require('./strings').trimFuncs;
var bcd = require('etna-engine/lib/runtime/bcd') ;
var undefined;

var _unaryOps = {
	USUB: function minus(a) {
		return -a;
	},
	UADD: function minus(a) {
		return +a;
	},
	NOT: function not(a) {
		return a?0:1;
	}
};

exports.round = function (val) {
	return Math.round(val * 1e6) / 1e6;
}

var _binaryOps = {
	ADD: function add(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a + b;
		if (ta === "string" && tb === "string") return a + b;
		if (bcd.isBCD(a) && bcd.isBCD(b)) return bcd.add(a, b);

		if (date.isDate(a) && tb === "number") return a.addDays(b);
		if (date.isDate(a) && bcd.isBCD(b)) return a.addDays(bcd.toInt32(b));
		if (date.isDate(a) && tb === string) return a.toString("yyyMMdd")+b ;

		if (date.isDate(b) && ta === "number") return b.addDays(a);
		if (date.isDate(b) && bcd.isBCD(a)) return b.addDays(bcd.toInt32(a));
		if (date.isDate(b) && ta === string) return b.toString("yyyMMdd")+a ;		

		if (bcd.isBCD(a) && tb === "number") return bcd.add(a, bcd.fromInt32(b)) ;
		if (bcd.isBCD(b) && ta === "number") return bcd.add(bcd.fromInt32(a), b) ;

		throw (ta !== "number" && ta !== "string" && !date.isDate(a)) ? util.badOperand(a) : util.badOperand(b);
	},
	SUB: function sub(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a - b;
		if (ta === "string" && tb === "string") return trimFuncs[1](a) + " " + trimFuncs[0](b);
		if (date.isDate(a) && date.isDate(b)) return a.daysDiff(b);

		if (bcd.isBCD(a) && bcd.isDCB(b)) return bcd.sub( a, b ) ;
		if (bcd.isBCD(a) && tb === "number") return bcd.sub( a, bcd.fromInt32( b )) ;
		if (bcd.isBCD(b) && ta === "number") return bcd.sub( bcd.fromInt32(a),  b ) ;

		if (date.isDate(a) && tb === "number") return a.addDays(-b);
		if (date.isDate(a) && bcd.isBCD(b)) return a.addDays(bcd.toInt32(-b));
		if (date.isDate(a) && tb === string) return trimFuncs[1](a.toString("yyyMMdd"))+ " " + trimFuncs[0](b) ;

		if (date.isDate(b) && ta === string) return trimFuncs[1](a) + " " + trimFuncs[0](b.toString("yyyMMdd")) ;
		
		throw (ta !== "number" && ta !== "string" && !date.isDate(a)) ? util.badOperand(a) : util.badOperand(b);
	},
	MUL: function mul(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a * b;
		if (bcd.isBCD(a) && tb === "number") return bcd.multiply( a, bcd.fromInt32(b)) ;
		if (bcd.isBCD(b) && ta === "number") return bcd.multiply( b, bcd.fromInt32(a)) ;
		throw ta !== "number" ? util.badOperand(a) : util.badOperand(b);
	},
	DIV: function div(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") {
			if (b === 0) throw new X3Error(53) ;

			return (a % b)? bcd.divide( bcd.fromInt32( a ), bcd.fromInt32( b )) : a / b ;
		}
		if (bcd.isBCD(a) || bcd.isBCD(b)) {
			if (ta === "number") return bcd.divide( bcd.fromInt32(a), b ) ;
			if (tb === "number") return bcd.divide( a, bcd.fromInt32(b) ) ;
		}
		throw ta !== "number" ? util.badOperand(a) : util.badOperand(b);
	},
	MOD: function mod(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") {
			if (b === 0) throw new X3Error(53);
			return a % b;
		}
		if (bcd.isBCD(a) || bcd.isBCD(b)) {
			var bcda ;
			var bcdb ;
			if (ta === "number") 	{
				bcda = bcd.fromInt32( a ) ;
				bcdb = b ;
			} else if (tb === "number"){
				bcda = a
				bcdb = bcd.fromInt32( b ) ;
			} else {
				bcda = a ;
				bcdb = b ;
			}
			if (!bcd.isBCD(a) || !bcd.isBCD(b)) throw !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);

			var dv = bcd.div( bcda, bcdb) ;
			var fx = bcd.toInt32( dv ) ;
			var ml = bcd.mul( bcd.fromInt32(fx), bcdb ) ;
			return bcd.sub( bcda, ml ) ;
		}
		throw ta !== "number" && !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);
	},
	POW: function pow(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return Math.pow(a, b);

		if (bcd.isBCD(a) || bcd.isBCD(a)) {
			var bcda ;
			var bcdb ;
			if (ta === "number") {
				bcda = bcd.fromInt32( a ) ;
				bcdb = bcd.truncate(b, 0) ;
			} else if (tb === "number") {
				bcda = a ;
				bcdb = bcd.fromInt32( b ) ;
			} else {
				bcda = a ;
				bcdb = b ;
			}
			if (!bcd.isBCD(a) || !bcd.isBCD(b)) throw !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);

		}
		throw ta !== "number" && !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);
	},
	XOR: function xor(a, b) {
		var ta = typeof a,
			tb = typeof b;
		if (ta === "number" && tb === "number") return a ^ b ;
		if (bcd.isBCD(a) || bcd.isBCD(a))
		{
			var bcda ;
			var bcdb ;
			if (ta === "number") {
				bcda = bcd.fromInt32( a ) ;
				bcdb = b ;
			} else if (tb === "number"){
				bcda = a ;
				bcdb = bcd.fromInt32( b ) ;
			} else {
				bcda = a ;
				bcdb = b ;
			}
			if (!bcd.isBCD(a) || !bcd.isBCD(b)) throw !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);

			var zero = bcd.fromInt32(0) ;
			var za = bcd.compare( bcda, zero )? 0 : 1 ;
			var zb = bcd.compare( bcdb, zero )? 0 : 1 ;

			return za ^ zb ;			
		}
		throw ta !== "number" && !bcd.isBCD(a) ? util.badOperand(a) : util.badOperand(b);
	},
	EQ: function eq(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.equals(b);
		if (bcd.isBCD(a) && date.isBCD(b)) return (bcd.compare( a, b ) === 0)? 1 : 0 ;
		if (bcd.isBCD(a) && typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) === 0)? 1 : 0 ;
		if (bcd.isBCD(b) && typeof a === "number") return (bcd.compare( b, bcd.fromInt32(a) ) === 0)? 1 : 0 ;
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) == 0) ? 1 : 0;
		}
		return a == b ? 1 : 0;
	},
	NE: function ne(a, b) {
		if (date.isDate(a) && date.isDate(b)) return !a.equals(b);
		if (bcd.isBCD(a) && date.isBCD(b)) return (bcd.compare( a, b ) === 0)? 0 : 1 ;
		if (bcd.isBCD(a) && typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) === 0)? 0 : 1 ;
		if (bcd.isBCD(b) && typeof a === "number") return (bcd.compare( b, bcd.fromInt32(a) ) === 0)? 0 : 1 ;
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) != 0) ? 1 : 0;
		}
		return a != b ? 1 : 0;
	},
	LT: function lt(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) < 0;
		if (bcd.isBCD(a) && date.isBCD(b)) return (bcd.compare( a, b ) < 0)? 1 : 0 ;
		if (bcd.isBCD(a) && typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) < 0)? 1 : 0 ;
		if (bcd.isBCD(b) && typeof a === "number") return (bcd.compare( b, bcd.fromInt32(a) ) > 0)? 1 : 0 ;

		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) < 0) ? 1 : 0;
		}
		return a < b ? 1 : 0;
	},
	LE: function le(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) <= 0;
		if (bcd.isBCD(a) && date.isBCD(b)) return (bcd.compare( a, b ) <= 0)? 1 : 0 ;
		if (bcd.isBCD(a) && typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) <= 0)? 1 : 0 ;
		if (bcd.isBCD(b) && typeof a === "number") return (bcd.compare( b, bcd.fromInt32(a) ) >= 0)? 1 : 0 ;		
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) <= 0) ? 1 : 0;
		}
		return a <= b ? 1 : 0;
	},
	GT: function gt(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) > 0;
		if (bcd.isBCD(a) && date.isBCD(b)) return (bcd.compare( a, b ) > 0)? 1 : 0 ;
		if (bcd.isBCD(a) && typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) > 0)? 1 : 0 ;
		if (bcd.isBCD(b) && typeof a === "number") return (bcd.compare( b, bcd.fromInt32(a) ) < 0)? 1 : 0 ;

		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) > 0) ? 1 : 0;
		}
		return a > b ? 1 : 0;
	},
	GE: function ge(a, b) {
		if (date.isDate(a) && date.isDate(b)) return a.compare(b) >= 0;
		if (bcd.isBCD(a) && date.isBCD(b)) return (bcd.compare( a, b ) >= 0)? 1 : 0 ;
		if (bcd.isBCD(a) && typeof b === "number") return (bcd.compare( a, bcd.fromInt32(b) ) >= 0)? 1 : 0 ;
		if (bcd.isBCD(b) && typeof a === "number") return (bcd.compare( b, bcd.fromInt32(a) ) <= 0)? 1 : 0 ;		
		if (typeof a === "number" && typeof b === "number") {
			return (exports.round(a- b) >= 0) ? 1 : 0;
		}
		return a >= b ? 1 : 0;
	},
};

/* 
 * Operators
 */

function op1(f) {
	return function(f1) {
		return function op1$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
			return f(v11);
		};
	};
}

function op2(f) {
	return function(f1, f2) {
		return function op2$do(_) {
			//return f(f1.value !== undefined ? f1.value : f1(_), f2.value !== undefined ? f2.value : f2(_));
			var v1= (f1.value !== undefined ? f1.value : f1(_));
			var v2= (f2.value !== undefined ? f2.value : f2(_));

 		    var v11= (Array.isArray(v1)? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
 		    var v22= (Array.isArray(v2)? (v2[2][0] === undefined ? v2[1] : v2[2][0]) : v2);
			return f(v11, v22);
		};
	};
}

exports.instructions = {
	AND: function(f1, f2) {
		return function and$do(_) {
			return f1(_) && f2(_);
		};
	},
	OR: function(f1, f2) {
		return function or$do(_) {
			return f1(_) || f2(_);
		};
	},
	PLUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.ADD(lhs, rhs));
	},
	MINUSEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.SUB(lhs, rhs));
	},
	MULEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.MUL(lhs, rhs));
	},
	DIVEQ: function(lhs, rhs) {
		return variables.instructions.SET(lhs, exports.instructions.DIV(lhs, rhs));
	}
};

for (var op in _unaryOps) exports.instructions[op] = op1(_unaryOps[op]);
for (var op in _binaryOps) exports.instructions[op] = op2(_binaryOps[op]);