"use strict";
var glob = require('streamline/lib/globals');
var util     = require('./util');
var time     = require('syracuse-core/lib/types/time');
var X3Error  = require('./errors').X3Error;
var date     = require('etna-engine/lib/runtime/tdate') ;
var datetime = require('etna-engine/lib/runtime/tdatetime') ;
var tinteger = require('etna-engine/lib/runtime/tinteger') ;
var variables = require('./variables');
var flowControl = require('./flowControl');

var ORIGIN   = date.ORIGIN();
var NULLDATE = date.NULLDATE();

exports.functions = {
	DAY: {
		count: 1,
		fn: function(d) {
			if (d.day) return d.day;
			throw util.badArgumentType(d);			
		}
	},
	DAYN: {
		count: 1,
		fn: function(d) {
			// shift sunday from 0 to 7, others unchanged
			return 1 + (d.weekDay + 6) % 7;
		}
	},
	MONTH: {
		count: 1,
		fn: function(d) {
			if (d.month) return d.month;
			throw util.badArgumentType(d);
		}
	},
	NDAY: {
		count: 1,
		fn: function(d) {
			if (d.x3Nday) return d.x3Nday(ORIGIN);
			throw util.badArgumentType(d);
		}
	},
	WEEK: {
		count: 1,
		fn: function(d) {
			if (d.week) return d.week;
			throw util.badArgumentType(d);
		}
	},
	YEAR: {
		count: 1,
		fn: function(d) {
			if(util.x3IsDate(d)) return d.x3Year;
			throw util.badArgumentType(d);
		}
	},
	DAY$: {
		async: true,
		count: 1,
		fn: function(_, d) {
			var frame = glob.context.x3frame ;
			if (util.x3IsDate(d)) d = d.weekDay ;
			else if (util.x3IsInteger(d)) d = d % 7;
			else throw util.badArgumentType(d);
			return flowControl.functions.MESS.fn(_,d||7,742,1);
		}
	},
	MONTH$: {
		async: true,
		count: 1,
		fn: function(_, m) {
			var frame = glob.context.x3frame ;
			if (util.x3IsDate(m)) m = m.month;
			else if (util.x3IsInteger(m)) m = 1 + (m + 11) % 12;
			else throw util.badArgumentType(m);
			return flowControl.functions.MESS.fn(_,m,9001,1);
		}
	},
	TIME$: {
		count: 0,
		fn: function() {
			return time.now().toString();
		}
	},
	ADDMONTH: {
		count: 2,
		fn: function(d, dm) {
			if (d.x3AddMonths) return d.x3AddMonths(dm);
			throw util.badArgumentType(d);			
		}
	},
	AWEEK: {
		count: 2,
		fn: function(w, y) {
			util.checkInteger(w);
			util.checkInteger(y);
			if(y < 1600) throw new X3Error(56,"out off limit");
			return date.makeInWeek(y, w, 1);
		}
	},
	DATE$: {
		count: 0,
		fn: function() {
			return date.today();
		}
	},
	DATETIME$: {
		count: 0,
		fn: function() {
			return datetime.now();
		}
	},
	GDATETIME$: {
		count: 1,
		fn: function(s) {
			return datetime.x3Parse(s);
		}
	},
	EOMONTH: {
		count: 1,
		fn: function(d) {
			if (d.endOfMonth) return d.endOfMonth();
			throw util.badArgumentType(d);				
		}
	},
	GDAT$: {
		//count: 3, -- sometimes used with 1 - see AFNC line 588
		fn: function(d, m, y) {
			util.checkInteger(d);
			util.checkInteger(m);
			util.checkInteger(y);
			if( !d && !m && !y) return NULLDATE;

			if(y < 100) {
				var frame = glob.context.x3frame;
				y = ((1900+y) < frame.context.sys.values.ADXDCS)? 2000+y:1900+y;
			}

			var dd = 0,
				dy = 0;
			if (d <= 0) dd = d - 1, d = 1;
			if (m <= 0 || m > 12) dy = Math.floor((m - 1) / 12), y += dy, m -= dy * 12;
			var d2 = date.make(y, m, d);
			return dd ? d2.addDays(dd) : d2;
		}
	},
	NDAY$: {
		count: 1,
		fn: function(n) {
			return ORIGIN.x3AddDays(n);
		}
	},
	TIME: {
		count: 0,
		fn: function() {
			return time.now().value % (24 * 3600);
		}
	},
	TIMESTAMP$: {
		count: 0,
		fn: function() {
			return datetime.now().toString();
		}
	},

};

exports.instructions = {
	DATE: function(year, month, day) {
		return util.instructions.C(date.make(year, month, day));
	}
};