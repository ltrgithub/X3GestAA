"use strict";
var X3Error = require('./errors').X3Error;
var helpers = require('syracuse-core/lib/helpers');
var util = require('./util');
var bcd = require('./tbcd');

class Double {
	constructor(v) {
		var self = this;
		if (typeof v === 'number') {
			self.value = v;
		} else if (v.x3IsNumeric && v.x3IsNumeric()) {
			self.value = v.x3ToDouble().valueOf();
		} else throw util.badOperand(v);
		return self;
	}
	valueOf() {
		var self = this;
		return self.value;
	}
	x3IsNumeric() {
		return true;
	}
	x3IsEmpty() {
		var self = this;
		throw util.badOperand(self);
	}
	x3AssertOverflow(type) {
		return true;
	}
	x3Minus() {
		var self = this;
		return new Double(-self.value);
	}
	x3ToDouble() {
		var self = this;
		return self;
	}
	x3ToString() {
		var self = this;
		return "" + self.value;
	}
	x3ToBCD() {
		var self = this;
		return new bcd.fromDouble(self.value);
	}
	x3ToInteger() {
		var self = this;
		var sign = (self.value < 0) ? -1 : 1;
		return Math.floor(Math.abs(self.value)) * sign;
	}
	x3ToDate() {
		var self = this;
		throw util.badOperand(self);
	}
	x3ToDatetime() {
		var self = this;
		throw util.badOperand(self);
	}
	x3IsZero() {
		var self = this;
		return (self.value === 0) ? true : false;
	}
	x3Compare(b) {
		var self = this;
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		var bb = b.x3ToDouble();
		var e = Math.abs(self.value);
		var d = Math.abs(bb.value);

		// compute precision  min(a, b)/10000000 or 1/100000000
		if (d < e) e = d;
		if (e === 0) e = 1;
		e /= 1000000000;
		d = self.value - bb.value;

		if ((-e < d) && (d < e)) return 0;
		else if (d >= e) return 1;
		else return -1;
	}
	x3Add(b) {
		var self = this;
		if (b.x3IsNumeric()) {
			var bb = b.x3ToDouble();
			return new Double(self.value + bb.value);
		} else if (util.x3IsDate(b) || util.x3IsDatetime(b)) {
			return b.x3Add(self);
		} else throw util.badOperand(b);

	}
	x3Sub(b) {
		var self = this;
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		var bb = b.x3ToDouble();
		return new Double(self.value - bb.value);

	}
	x3Mul(b) {
		var self = this;
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		var bb = b.x3ToDouble();
		return new Double(self.value * bb.value);

	}
	x3Div(b) {
		var self = this;
		if (!b.x3IsNumeric()) throw util.badOperand(b);
		if (b.x3IsZero()) throw new X3Error(53, "");
		var bb = b.x3ToDouble();
		return new Double(self.value / bb.value);

	}
	x3Mod(b) {
		var self = this;
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		var bb = b.x3ToDouble();
		return new Double(self.value % bb.value);

	}
	x3Pow(b) {
		var self = this;
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		var bb = b.x3ToDouble();
		return new Double(Math.pow(self.value, bb.value));

	}
	x3Xor(b) {
		var self = this;
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		var i = (self.x3IsZero()) ? 1 : 0;
		var j = (b.x3IsZero()) ? 1 : 0;

		return i ^ j;
	}
	x3Abs() {
		var self = this;
		return new Double(Math.abs(self.value));
	}
	x3Truncate() {
		var self = this;
		var sign = (self.value < 0) ? -1 : 1;
		return new Double(Math.floor(Math.abs(self.value)) * sign);
	}
	x3ToSql(driver) {
		throw new X3Error(26, "Double is an illegal type to insert");
	}
	x3Type() {
		return 6;
	}
}

exports.Double = Double;