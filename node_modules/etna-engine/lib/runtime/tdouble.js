"use strict";
var X3Error = require('./errors').X3Error;
var helpers = require('syracuse-core/lib/helpers');
var util = require('./util');
var bcd = require('./bcd');

var Double = helpers.defineClass(function(v) { // constructor
    var self = this;
    if (typeof v==='number') {
      self.value= v ;
    }
    else if (v.x3IsNumeric && v.x3IsNumeric()) {
      self.value= v.x3ToDouble( ).valueOf( ) ;
    }
    else throw util.badOperand(v);
  }, null, { // Pass null if no parent class - public methods follow

  valueOf : function() {
    var self = this;
    return self.value ;
  },
  // more public methods
  x3IsNumeric : function() {
    return true ;
  },
  x3AssertOverflow : function ( type ) {
    return true ;    
  },

  x3Minus : function( ) {
    var self = this;
    return new Double( -self.value ) ;
  },

  x3ToDouble : function() {
    var self = this;
    return self ;
  },

  x3ToString : function() {
    var self = this;
    return ""+self.value ;
  },

  x3ToBCD : function() {
    var self = this;
    return new bcd.fromDouble( self.value ) ;
  },

  x3ToInteger : function() {
    var self = this;
    var sign=(self.value < 0)?-1:1;
    return Math.floor( Math.abs( self.value ) )*sign ;
  },

	x3ToDate : function() {
    var self = this;
    throw util.badOperand(self) ;
  },

  x3ToDatetime : function() {
    var self = this;
    throw util.badOperand(self) ;
  },

  x3IsZero : function() {
    var self = this;
		return (self.value === 0)?true : false ;
	},

  x3Compare : function( b ) {
    var self = this;
      if (!b.x3IsNumeric()) throw util.badOperand(b);
      
      var bb=b.x3ToDouble();
      var e = Math.abs( self.value ) ;
      var d = Math.abs( bb.value ) ;

      // compute precision  min(a, b)/10000000 or 1/100000000
      if (d < e) e = d ;
      if (e === 0) e = 1 ;
      e /= 1000000000 ;
      d = self.value - bb.value ;      

      if ((-e < d) && (d < e)) return 0
      else if (d >= e) return 1 ;
      else return -1 ;
  },

	x3Add : function( b ) {
    var self = this;
      if (b.x3IsNumeric()) { 
        var bb=b.x3ToDouble();
        return new Double (self.value+bb.value) ;
      }
      else if (util.x3IsDate(b) || util.x3IsDatetime(b)) { 
        return b.x3Add(self) ;
      }
      else throw util.badOperand(b);
    
  },

	x3Sub : function( b ) {
    var self = this;
      if (!b.x3IsNumeric()) throw util.badOperand(b);

      var bb=b.x3ToDouble();
      return new Double(self.value-bb.value) ;
    
  },

	x3Mul : function( b ) {
    var self = this;
      if (!b.x3IsNumeric()) throw util.badOperand(b);

      var bb=b.x3ToDouble();
      return new Double(self.value*bb.value) ;
    
  },

	x3Div : function( b ) {
    var self = this;
      if (!b.x3IsNumeric()) throw util.badOperand(b);
      if (b.x3IsZero())  throw new X3Error(53) ;

      var bb=b.x3ToDouble();
      return new Double(self.value/bb.value);
    
  },

	x3Mod : function( b ) {
    var self = this;
      if (!b.x3IsNumeric()) throw util.badOperand(b);

      var bb=b.x3ToDouble();
      return new Double(self.value%bb.value) ;
    
  },

	x3Pow : function( b ) {
    var self = this;
      if (!b.x3IsNumeric()) throw util.badOperand(b);

      var bb=b.x3ToDouble();
      return new Double (Math.pow(self.value, bb.value));

  },

  x3Xor : function( b ) {
    var self = this;
      if (!b.x3IsNumeric()) throw util.badOperand(b);

      var i = (self.x3IsZero())?1:0 ;
      var j = (b.x3IsZero())?1:0 ;

      return i ^ j ;
  },

  x3Abs : function() {
    var self = this;
    	return new Double( Math.abs( self.value )) ;
  },

  x3Truncate : function() {
     var self = this;
      var sign=(self.value < 0)?-1:1;
  		return new Double( Math.floor( Math.abs( self.value ) )*sign ) ;
  },

});

exports.Double = Double ;