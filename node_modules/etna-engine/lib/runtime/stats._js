"use strict";

var variables = require('./variables');
var errors = require('./errors');
var util = require('./util');
var X3Error = errors.X3Error;
var glob = require('streamline/lib/globals');

function _iter(args, fn) {
	for (var i = 0; i < args.length; i++) {
		var val = args[i];
		//console.error("iter " + i +" = " + val)
		if (Array.isArray(val)) {
			var ndims = val[0];
			//console.error("iter: ndims=" + ndims)
			var data = val[2];
			var sliced = val.length === 3 + 4 * ndims;
			if (sliced) {
				var _doSlice = function(dim, off, mult) {
					var size = val[4 + 2 * dim];
					var offset = val[3 + 2 * (ndims + dim)];
					var count = val[4 + 2 * (ndims + dim)];
					if (dim < ndims - 1) {
						for (var j = 0; j < count; j++)
						_doSlice(dim + 1, (off + offset + j) * mult, size);
					} else {
						//console.error("ITER slice: off=" + off + " offset=" + offset + ", count=" + count)
						for (var j = 0; j < count; j++) {
							var v = data[off + offset + j];
							if (fn(v)) return;
						}
					}
				};
				_doSlice(0, 0, 1);
			} else {
				var size = 1;
				for (var j = 0; j < ndims; j++) {
					if(val[4 + 2 * j] == null) {
						size = val[2].length;
						break;
					} else {
						size *= (val[4 + 2 * j]-val[3 + 2 * j]+1);
					}
				}
				for (var j = 0; j < size; j++) {
					var v = data[j];
					if (fn(v)) return;
				}
			}
		} else {
			if (fn(val)) return;
		}
	}
}

exports.functions = {
	AVG: {
		count: -1,
		fn: function() {
			var total = 0;
			var count = 0;
			_iter(arguments, function(v) {
				total = total.x3Add( v ) ;
				count++;
			});
			return count === 0 ? 0 : total.x3Div( count ) ;
		}
	},
	FIND: {
		count: -1,
		fn: function(val, args) {
			args = Array.prototype.slice.call(arguments, 1);
			var i = 0,
				result = 0;
			_iter(args, function(v) {
				++i;
				if (v.x3Compare(val) === 0) {
					result = i;
					return true;
				}
			});
			return result;
		}
	},
	MAX: {
		count: -1,
		fn: function() {
			var result;
			_iter(arguments, function(v) {
				result = (result === undefined || result.x3Compare(v) < 0) ? v : result;
			});
			return result;
		}
	},
	MIN: {
		count: -1,
		fn: function() {
			var result;
			_iter(arguments, function(v) {
				result = (result === undefined || result.x3Compare(v) > 0) ? v : result;
			});
			return result;
		}
	},
	SUM: {
		count: -1,
		fn: function() {
			var result;
			_iter(arguments, function(v) {
				result = (result === undefined) ? v : result.x3Add(v);
			});
			return result;
		}
	},
	PRD: {
		count: -1,
		fn: function() {
			var result = 1;
			_iter(arguments, function(v) {
				result = result.x3Mul( v ) ;
			});
			return result;
		}
	},
	UNI: {
		count: -1,
		fn: function() {
			var map = {};
			var result = 0;
			var i = 0;
			_iter(arguments, function(v) {
				++i;
				v = v.x3ToString( ) ;
				if (map[v]) {
					result = i;
					return true;
				}
				map[v] = true;
			});
			return result;
		}
	},
	VAR: {
		count: -1,
		fn: function() {
			var sum = 0,
				sum2 = 0,
				count = 0;
			_iter(arguments, function(v) {
				sum = sum.x3Add( v ) ;
				sum2 = sum2.x3Add( v.x3Mul( v )) ;
				count++;
			});
			//return count === 0 ? 0 : (sum2 - (sum * sum) / count)/count;
			return count === 0 ? 0 : sum2.x3Sub(sum.x3Mul(sum).x3Div( count )).x3Div(count) ;
			//( sx2 - ( sx * sx / n ) ) / n
		}
	},
	SIGMA: { // parser needs it in this table but fn will never be called
		count: -1
	},
};

exports.instructions = {
	SIGMA: function(field, args) {
		return function sigma$do(_) {
			var frame = glob.context.x3frame;
			var result = null;
			//var lhs = exports.V(field);
			var first = (args[0](_)).x3ToInteger( ) ;
			var last =  (args[1](_)).x3ToInteger( ) ;
			var values = frame.values;

			for (var i = first; i <= last; i++) {
				//lhs(_, i);
				values[field] = i;
				var val = args[2](_);
				result = result == null ? val : result.x3Add( val ) ;
			}
			return result;
		};
	}
};