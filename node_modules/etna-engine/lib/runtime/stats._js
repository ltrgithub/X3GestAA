"use strict";

var variables = require('./variables');
var errors = require('./errors');
var X3Error = errors.X3Error;
var glob = require('streamline/lib/globals');

function _iter(args, fn) {
	for (var i = 0; i < args.length; i++) {
		var val = args[i];
		//console.error("iter " + i +" = " + val)
		if (Array.isArray(val)) {
			var ndims = val[0];
			//console.error("iter: ndims=" + ndims)
			var data = val[2];
			var sliced = val.length === 3 + 4 * ndims;
			if (sliced) {
				var _doSlice = function(dim, off, mult) {
					var size = val[4 + 2 * dim];
					var offset = val[3 + 2 * (ndims + dim)];
					var count = val[4 + 2 * (ndims + dim)];
					if (dim < ndims - 1) {
						for (var j = 0; j < count; j++)
						_doSlice(dim + 1, (off + offset + j) * mult, size);
					} else {
						//console.error("ITER slice: off=" + off + " offset=" + offset + ", count=" + count)
						for (var j = 0; j < count; j++) {
							var v = data[off + offset + j];
							if (fn(v)) return;
						}
					}
				};
				_doSlice(0, 0, 1);
			} else {
				var size = 1;
				for (var j = 0; j < ndims; j++)
				size *= val[4 + 2 * j];
				//console.error("ITER no slice: size=" +size);
				for (var j = 0; j < size; j++) {
					var v = data[j];
					if (fn(v)) return;
				}
			}
		} else {
			if (fn(val)) return;
		}
	}
}

exports.functions = {
	AVG: {
		count: -1,
		fn: function() {
			var total = 0;
			var count = 0;
			_iter(arguments, function(v) {
				total += v;
				count++;
			});
			return count === 0 ? 0 : total / count;
		}
	},
	FIND: {
		count: -1,
		fn: function(val, args) {
			args = Array.prototype.slice.call(arguments, 1);
			var i = 0,
				result = 0;
			val = "" + val;
			_iter(args, function(v) {
				v = "" + v;
				++i;
				if (v === val) {
					result = i;
					return true;
				}
			});
			return result;
		}
	},
	MAX: {
		count: -1,
		fn: function() {
			var result;
			_iter(arguments, function(v) {
				result = (result === undefined || result < v) ? v : result;
			});
			return result;
		}
	},
	MIN: {
		count: -1,
		fn: function() {
			var result;
			_iter(arguments, function(v) {
				result = (result === undefined || result > v) ? v : result;
			});
			return result;
		}
	},
	SUM: {
		count: -1,
		fn: function() {
			var result = 0;
			_iter(arguments, function(v) {
				result += v;
			});
			return result;
		}
	},
	PRD: {
		count: -1,
		fn: function() {
			var result = 1;
			_iter(arguments, function(v) {
				result *= v;
			});
			return result;
		}
	},
	UNI: {
		count: 1,
		fn: function() {
			var map = {};
			var result = 0;
			var i = 0;
			_iter(arguments, function(v) {
				++i;
				v = "" + v;
				if (map[v]) {
					result = i;
					return true;
				}
				map[v] = true;
			});
			return result;
		}
	},
	VAR: {
		count: 1,
		fn: function() {
			var sum = 0,
				sum2 = 0,
				count = 0;
			_iter(arguments, function(v) {
				sum += v;
				sum2 += v * v;
				count++;
			});
			return count === 0 ? 0 : (sum2 - sum * sum) / count;
		}
	},
	SIGMA: { // parser needs it in this table but fn will never be called
		count: -1
	},
};

exports.instructions = {
	SIGMA: function(field, args) {
		return function sigma$do(_) {
			var frame = glob.context.x3frame;
			var result = null;
			//var lhs = exports.V(field);
			var first = args[0](_);
			var last = args[1](_);
			var values = frame.values;
			for (var i = first; i <= last; i++) {
				//lhs(_, i);
				values[field] = i;
				var val = args[2](_);
				result = result == null ? val : result + val;
			}
			return result;
		};
	}
};