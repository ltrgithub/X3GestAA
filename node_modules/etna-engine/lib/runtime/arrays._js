"use strict";

var util = require('./util');
var variables = require('./variables');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');

// not used for now

function _lookup(array, len, elt, comparator) {
	var c, l, m, r;

	if (len == 0) return -1;

	l = 0;
	r = len - 1;
	while (true) {
		m = Math.floor((l + r) / 2);
		c = comparator(elt, array[m]);
		if (c == 0) return m;
		if (m == l && c < 0) return -(m + 1);
		if (m == r && c > 0) return -(m + 2);

		if (l == m) l++;
		else if (r == m) r--;
		else if (c > 0) l = m;
		else r = m;
	}
}

function _sort(compare, swap, beg, end) {
	function _qsort(beg, end) {
		if (beg >= end) return;

		if (end == beg + 1) {
			if (compare(beg, end) > 0) {
				swap(beg, end);
			}
			return;
		}

		var mid = Math.floor((beg + end) / 2);
		var nbeg = beg;
		var nend = end;

		while (nbeg <= nend) {
			while (nbeg < end && compare(nbeg, mid) < 0) nbeg++;
			while (beg < nend && compare(mid, nend) < 0) nend--;

			if (nbeg <= nend) {
				swap(nbeg, nend);
				if (mid === nbeg) mid = nend;
				else if (mid === nend) mid = nbeg;
				nbeg++;
				nend--;
			}
		}

		if (nbeg < end) _qsort(nbeg, end);
		if (beg < nend) _qsort(beg, nend);
	}
	_qsort(beg, end);
}

// Array layout:
// [ndims, def, data, base1, size1, base2, size2, ... offset1, count1, offset2, count2, ...]
// 
// ndims: number of dimensions (1 or more)
// def: default value for entries ("", 0, or date(0))
// data: the array of values
// baseN: index of first valid entry for dimension N (if slice, this is index of the first slice entry, not of the first data entry)
// sizeN: number of data entries for dimension N
// offsetN: offset of first slice entry in data for dimension N
// countN: number of entries in slice for dimension N 
// 
// offsetN, countN part is only present if a slice is active.
// size of the array is 3 + 4 * ndims is a slice is active, 3 + 2 *  ndims otherwise.
// size of the data is size1 * size2 * ... regardless of whether there is a slice or not.
var _isSliced = exports.isSliced = function(arr) {
	return arr.length === 3 + 4 * arr[0];
};

function _offset(arr, args, forOrderBy) {
	var ndims = arr[0];
	if (ndims !== args.length) throw new X3Error(8, "expected " + ndims + " dimensions, got " + args.length);
	var result = 0;
	var sliced = arr.length === 3 + 4 * ndims;
	var size, sliceSize = 1;
	for (var i = ndims - 1; i >= 0; i--) {
		var arg = args[i];
		if (Array.isArray(arg)) return null; // get will branch to _slice
		//result = result * size;
		var base = forOrderBy ? 0 : arr[3 + 2 * i];

		size = (arr[4 + 2 * i] != null)? arr[4 + 2 * i]-arr[3 + 2 * i]+1 : null;
		//console.error("sliced=" + sliced)
		if (sliced) {
			var offset = arr[3 + 2 * (ndims + i)];
			var count = arr[4 + 2 * (ndims + i)];
			if (!(arg >= base && arg < base + count)) throw new X3Error(8, "index out of range: " + arg + " not in [" + base + "," + (base + count - 1) + "]");
			//result += arg - base + offset;
			result += (arg - base + offset) * sliceSize; 
		} else {
			if (!(arg >= base && ((size === null && i === 0) || arg < base + size))) throw new X3Error(8, "index out of range: " + arg + " not in [" + base + "," + (base + size - 1) + "]");
			//console.log("i=" + i + ", size=" + size + " base=" + base + ", before=" + result + ", after=" + (result + arg - base));
			// result += arg - base;
			result += (arg - base) * sliceSize;
		}
		sliceSize *= size;
	}
	return result;
}

function _slice(arr, args) {
	var ndims = arr[0];
	var result = arr.slice(0);
	var sliced = arr.length === 3 + 4 * ndims;
	for (var i = ndims - 1; i >= 0; i--) {
		var arg = args[i],
			lo, hi;
		var base = arr[3 + 2 * i];
		var size = arr[4 + 2 * i];
		var offset = sliced ? arr[3 + 2 * (ndims + i)] : 0;
		var count = sliced ? arr[4 + 2 * (ndims + i)] : size;

		if (Array.isArray(arg)) {
			lo = arg[0];
			hi = arg[1];
			if (hi === null) hi = base + count - 1;
			//console.error("slice: lo=" + lo + ", hi=" + hi + ", sliced=" + sliced)
		} else {
			lo = hi = arg;
		}
		if (!(lo >= base && lo <= hi && hi < base + count)) throw new X3Error(8, "invalid subrange: [" + [lo, hi] + "] not in [" + [base, base + count - 1] + "]");

		result[3 + 2 * i] = lo;
		if (sliced) result[3 + 2 * (ndims + i)] += lo - base;
		else result[3 + 2 * (ndims + i)] = lo - base;
		result[4 + 2 * (ndims + i)] = hi + 1 - lo;
	}
	//console.error("_slice returns: " + JSON.stringify(result))
	return result;
}

function _evalOrder(order) {
	return function evalOrder$do(_) {
		var frame = glob.context.x3frame;
		var values = [];
		frame.values.INDICE = 0;
		frame.types.INDICE = 'LI';
		while (frame.values.INDICE < frame.orderCount) {
			values.push(order(_));
			frame.values.INDICE++;
		}
		return [1, null, values, 0, frame.orderCount];
	};
}

function _insDela(isDel) {
	return function(ints, vars) {
		var aints = util.instructions.A(ints);
		var avars = util.instructions.A(vars);
		return function insa$do(_) {
			var intVals = aints(_);
			intVals.map(util.checkInteger);
			var lo = intVals[0];
			var num = intVals.length > 1 ? intVals[1] : 1;
			var hi = intVals[2];
			if (num <= 0) throw new X3Error(8, "bad num parameter: " + num);
			var varVals = avars(_);
			varVals.forEach(util.checkMonoArray);
			varVals.forEach(function(arr) {
				// console.error("INSA: " + JSON.stringify(arr));
				var base = arr[3];
				var offset, count;
				if (arr.length === 7) {
					offset = arr[3 + 2];
					count = arr[4 + 2];
				} else {
					offset = 0;
					count = arr[4];
				}
				if (lo < base) throw new X3Error(8, "bad low bound: " + lo + " < " + base);
				if (hi != null && hi >= base + count) throw new X3Error(8, "bad high bound: " + hi + " >= " + base + count);
				if (hi == null) hi = base + count - 1;
				var data = arr[2];
				var def = arr[1];
				if (isDel) {
					var i = lo;
					while (i + num <= hi) {
						data[i] = data[i + num];
						i++;
					}
					while (i <= hi) {
						data[i++] = def;
					}
				} else {
					var i = hi;
					while (i - num >= lo) {
						data[i] = data[i - num];
						i--;
					}
					while (i >= lo) {
						data[i--] = def;
					}
				}
			});
		};
	};
}

exports.functions = {
	MAXTAB: {
		count: 1,
		fn: function(arr) {
			// arr[2] is base and arr[3] is the array
			if (arr[0] !== 1) throw new X3Error(26, "maxtab not allowed on multi-dimensional array: " + arr[0]); 
			return arr[3] + arr[2].length;
		}
	},
};

exports.instructions = {
	RANGE: function(lo, hi) {
		hi = hi || util.instructions.C(null);
		return function range$do(_) {
			return [lo(_), hi(_)];
		};
	},
	INDEX: function(target, args) {
		var aargs = util.instructions.A(args);
		return function index$do(_, assign, val) {
			var frame = glob.context.x3frame;

			var targetVal = target(_);
			
			if (!Array.isArray(targetVal)) throw new X3Error(35);
		
			var data = targetVal[2];
			var argVals = aargs(_);
		
			var offset = _offset(targetVal, argVals, frame.orderCount > 0);
			if (assign) {
				if (offset === null) throw new X3Error(8, "range not allowed in lhs");
				data[offset] = val;
			} else {
				return offset !== null ? data[offset] : _slice(targetVal, argVals);
			}
		};
	},
	SORTA: function(rep, vars, orders) {
		var avars = util.instructions.A(vars);
		var aorders = util.instructions.A((orders || []).map(_evalOrder));
		return function sorta$do(_) {
			var frame = glob.context.x3frame;
			var repVal = rep(_);
			if (repVal === null) repVal = -1;
			util.checkInteger(repVal);
			// TODO: handle repVal
			var varVals = avars(_);
			varVals.forEach(util.checkArray);
			var arr = varVals[0];
			var ndims = arr[0];
			// sorta ignores base and uses zero-based index
			// so we only care about slice offset here
			var offset, count;
			if (arr.length === 3 + 4 * ndims) {
				offset = arr[3 + 2 * ndims];
				count = arr[4 + 2 * ndims];
			} else {
				offset = 0;
				count = arr[4];
			}
			// warning: indexing works differently when frame.orderCount is set
			frame.orderCount = count;
			var orderVals = aorders(_);
			frame.orderCount = 0;
			orderVals.forEach(util.checkArray);
			var swapVals = varVals.concat(orderVals);
			if (orderVals.length === 0) orderVals = varVals;

			var swapDepth = swapVals.length;

			function swap(i, j) {
				for (var k = 0; k < swapDepth; k++) {
					var arrk = swapVals[k][2];
					var tmp = arrk[i];
					arrk[i] = arrk[j];
					arrk[j] = tmp;
				}
			}
			var orderDepth = orderVals.length;

			function compare(i, j) {
				var delta = 0;
				for (var k = 0; k < orderDepth && !delta; k++) {
					var arrk = orderVals[k][2],
						elt1 = arrk[i],
						elt2 = arrk[j];
					// console.error("arrk=" + JSON.stringify(arrk));
					// console.error("k=" + k + ", i=" + i + ", j=" + j);
					var t = typeof elt1;
					if (t === "number") delta = elt1 - elt2;
					else if (t === "string") delta = elt1 < elt2 ? -1 : elt1 > elt2 ? +1 : 0;
					else if (date.isDate(elt1)) delta = elt1.daysDiff(elt2);
					else throw util.badArgumentType(elt1);
				}
				return delta;
			}
			_sort(compare, swap, offset, offset + count - 1);
		};
	},
	INSA: _insDela(false),
	DELA: _insDela(true)
};