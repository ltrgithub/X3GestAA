"use strict";

var util = require('./util');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');
var variables = require('./variables');

// not used for now

function _lookup(array, len, elt, comparator) {
	var c, l, m, r;

	if (len === 0) return -1;

	l = 0;
	r = len - 1;
	while (true) {
		m = Math.floor((l + r) / 2);
		c = comparator(elt, array[m]);
		if (c === 0) return m;
		if (m == l && c < 0) return -(m + 1);
		if (m == r && c > 0) return -(m + 2);

		if (l == m) l++;
		else if (r == m) r--;
		else if (c > 0) l = m;
		else r = m;
	}
}

function _sort(compare, swap, beg, end) {
	function _qsort(beg, end) {
		//console.log("_qsort beg="+beg+", end="+end);
		if (beg >= end) return;

		if (end == beg + 1) {
			if (compare(beg, end) > 0) {
				swap(beg, end);
			}
			return;
		}

		var mid = Math.floor((beg + end) / 2);
		var nbeg = beg;
		var nend = end;
		//console.log("    1- midmid="+mid+", nbeg="+nbeg+", nend="+nend);

		while (nbeg <= nend) {
			while (nbeg < end && compare(nbeg, mid) < 0) nbeg++;
			while (beg < nend && compare(mid, nend) < 0) nend--;

			//console.log("    X- mid="+mid+", nbeg="+nbeg+", nend="+nend);
			if (nbeg <= nend) {
				if (nbeg !== nend) swap(nbeg, nend);
				if (mid === nbeg) mid = nend;
				else if (mid === nend) mid = nbeg;
				nbeg++;
				nend--;
			}
			//console.log("    2- mid="+mid+", nbeg="+nbeg+", nend="+nend);
		}

		if (nbeg < end) _qsort(nbeg, end);
		if (beg < nend) _qsort(beg, nend);
	}
	_qsort(beg, end);
}

// Array layout:
// [ndims, def, data, base1, size1, base2, size2, ... offset1, count1, offset2, count2, ...]
// 
// ndims: number of dimensions (1 or more)
// def: default value for entries ("", 0, or date(0))
// data: the array of values
// baseN: index of first valid entry for dimension N (if slice, this is index of the first slice entry, not of the first data entry)
// sizeN: number of data entries for dimension N
// offsetN: offset of first slice entry in data for dimension N
// countN: number of entries in slice for dimension N 
// 
// offsetN, countN part is only present if a slice is active.
// size of the array is 3 + 4 * ndims is a slice is active, 3 + 2 *  ndims otherwise.
// size of the data is size1 * size2 * ... regardless of whether there is a slice or not.
var _isSliced = exports.isSliced = function(arr) {
	return arr.length === 3 + 4 * arr[0];
};

function _offset(arr, args, forOrderBy) {
	var ndims = arr[0];
	if (ndims !== args.length) throw new X3Error(8, "expected " + ndims + " dimensions, got " + args.length);
	var result = 0;
	var result1 = 0;
	var sliced = arr.length === 3 + 4 * ndims;
	var size, sliceSize = 1;
	for (var i = ndims - 1; i >= 0; i--) {
		var arg = args[i];
		if (Array.isArray(arg)) return null; // get will branch to _slice
		//result = result * size;
		var base = forOrderBy ? 0 : arr[3 + 2 * i];

		size = (arr[4 + 2 * i] != null) ? arr[4 + 2 * i] - arr[3 + 2 * i] + 1 : null;
		//console.log("sliced=" + sliced +" size="+size+" sliceSize="+sliceSize+" result="+result);
		if (sliced) {
			var offset = arr[3 + 2 * (ndims + i)];
			var count = arr[4 + 2 * (ndims + i)];
			if (!(arg >= base && arg < base + count)) throw new X3Error(8, "index out of range: " + arg + " not in [" + base + "," + (base + count - 1) + "]");
			//result += arg - base + offset;
			result += (arg - base + offset) * sliceSize;
		} else {
			if (!(arg >= base && ((size === null && i === 0) || arg < base + size))) throw new X3Error(8, "index out of range: " + arg + " not in [" + base + "," + (base + size - 1) + "]");
			//console.log("i=" + i + ", size=" + size + " base=" + base + ", before=" + result + ", after=" + (result + arg - base));
			// result += arg - base;
			result += (arg - base) * sliceSize;
			if (size !== null)
				result1 += size * sliceSize;
			else
				result1 += (arg - base) * sliceSize;
		}
		sliceSize *= size;
	}
	//special case for MAXTAB on multi-dimension X3 array
	if (!sliced & arr[0] > 1 & arr[4] === null & result1 > arr[2].length) { // set maximun index with default value
		arr[2][result1] = arr[1];
	}
	return result;
}

function _slice(arr, args) {
	var ndims = arr[0];
	var result = arr.slice(0);
	var sliced = arr.length === 3 + 4 * ndims;
	for (var i = ndims - 1; i >= 0; i--) {
		var arg = args[i],
			lo, hi;
		var base = sliced ? arr[3 + 2 * i] : arr[3];
		var size = sliced ? arr[4 + 2 * i] : arr[4] === null ? arr[2].length : arr[4] - arr[3] + 1;
		var offset = sliced ? arr[3 + 2 * (ndims + i)] : 0;
		var count = sliced ? arr[4 + 2 * (ndims + i)] : size;

		if (Array.isArray(arg)) {
			lo = arg[0];
			hi = arg[1];
			if (hi === null) hi = base + count - 1;
			//console.error("slice: lo=" + lo + ", hi=" + hi + ", sliced=" + sliced)
		} else {
			lo = hi = arg;
		}
		if (!(lo >= base && lo <= hi && hi < base + count)) throw new X3Error(8, "invalid subrange: [" + [lo, hi] + "] not in [" + [base, base + count - 1] + "]");

		result[3 + 2 * i] = lo;
		if (sliced) result[3 + 2 * (ndims + i)] += lo - base;
		else result[3 + 2 * (ndims + i)] = lo - base;
		result[4 + 2 * (ndims + i)] = hi + 1 - lo;
	}
	//console.error("_slice returns: " + JSON.stringify(result))
	return result;
}

function _evalOrder(order) {
	return function evalOrder$do(_) {
		var frame = glob.context.x3frame;
		var values = [];
		frame.values.INDICE = 0 - frame.orderBase;
		frame.types.INDICE = 'LI';
		//console.log("frame.orderCount= "+frame.orderCount+" frame.values.INDICE="+frame.values.INDICE);
		while (frame.values.INDICE + frame.orderBase < frame.orderCount) {
			values.push(order(_));
			//console.log("values ="+values+"  indice ="+frame.values.INDICE);

			frame.values.INDICE++;
		}
		//console.log("Return _evalOrder");

		//return [1, null, values, frame.orderBase, frame.orderCount];
		return [1, null, values, frame.orderBase, (frame.orderBase === 0 ? frame.orderCount - 1 : frame.orderCount)];
	};
}

function _insDela(isDel) {
	return function(ints, vars) {
		var aints = util.instructions.A(ints);
		var avars = util.instructions.A(vars);
		return function insa$do(_) {
			var intVals = aints(_);
			intVals.map(util.checkInteger);
			var lo = intVals[0];
			var num = intVals.length > 1 ? intVals[1] : 1;
			var hi = intVals[2];
			if (num <= 0) throw new X3Error(8, "bad num parameter: " + num);
			var varVals = avars(_);
			varVals.forEach(util.checkMonoArray);
			varVals.forEach(function(arr) {
				console.log("_insDela: " + JSON.stringify(arr));
				console.log("_insDela: lo=" + lo + " hi=" + hi + " num=" + num);
				var base = arr[3];
				var i;
				var offset, count;
				if (arr.length === 3 + 4 * arr[0]) {
					offset = arr[3 + 2];
					count = arr[4 + 2];
				} else {
					offset = 0;
					count = arr[4] === null ? arr[2].length : arr[4] - arr[3] + 1;
				}
				if (lo < base) throw new X3Error(8, "bad low bound: " + lo + " < " + base);
				if (hi != null && hi >= base + count) throw new X3Error(8, "bad high bound: " + hi + " >= " + base + count);
				if (hi == null & count === 0) hi = -1;
				else if (hi == null) hi = base + count - 1;
				var data = arr[2];
				var def = arr[1];
				if (isDel) {
					//console.log("DELA: lo=" +lo+" hi="+hi+" num="+num+" base="+base);
					i = lo - base;
					while (i + num <= hi - base) {
						data[i] = data[i + num];
						i++;
					}
					while (i <= hi - base) {
						data[i++] = def;
					}
					//console.log("DELA: apres=" + JSON.stringify(arr));
				} else {
					//console.log("INSA: lo=" +lo+" hi="+hi+" num="+num+" base="+base);
					i = hi - base;
					if (arr[4] !== null) {
						while (i - num >= lo - base) {
							data[i] = data[i - num];
							i--;
						}
						while (i >= lo - base) {
							data[i--] = def;
						}
					} else {
						while (i >= lo - base) {
							data[i + num] = data[i];
							i--;
						}
						if (hi < 0) i += base; // special case for add first element in array(base..)
						while (i + num >= lo - base) {
							data[i + num] = def;
							i--;
						}
					}
					//console.log("INSA: apres=" + JSON.stringify(arr));
				}
			});
		};
	};
}

exports.functions = {
	MAXTAB: {
		count: 1,
		fn: function(arr) {
			if (arr === null) return 1;
			if (Array.isArray(arr)) {
				// arr[2] is base and arr[3] is the array
				var sliced = arr.length === 3 + 4 * arr[0];
				if (sliced) throw new X3Error(26, "maxtab not allowed on sliced array: " + arr[0]);
				//maxtab gives the maximum index defined in the array : it's not  the array's count
				console.log("array:" + JSON.stringify(arr));

				if (arr[4] === null) {
					if (arr[0] === 1) return arr[2].length + arr[3] - 1;
					if (!arr[2].length) return -1;

					var size, sliceSize = 1;
					var maxtab, result = 0;
					for (var i = arr[0] - 1; i > 0; i--) {
						size = (arr[4 + 2 * i] != null) ? arr[4 + 2 * i] - arr[3 + 2 * i] + 1 : null;
						result += size * sliceSize;
						sliceSize *= size;
					}
					maxtab = ((arr[2].length - 1 - result) / sliceSize) + arr[3];
					if (maxtab < 0) return 0;
					return maxtab;
				} else {
					//return arr[4] - arr[3] + 1;
					return arr[4];
				}
			} else if (arr.x3Maxtab) return arr.x3Maxtab();
			return 1;
		}
	},
};

exports.instructions = {
	RANGE: function(lo, hi) {
		hi = hi || util.instructions.C(null);
		return function range$do(_) {
			return [lo(_), hi(_)];
		};
	},
	INDEX: function(target, args) {
		var aargs = util.instructions.A(args);
		return function index$do(_, assign, val) {
			var frame = glob.context.x3frame;

			var targetVal = target(_);

			var argVals;
			if (Array.isArray(targetVal)) {
				var data = targetVal[2];
				argVals = aargs(_);
				/*dbg*/
				console.log("index targetVal:" + JSON.stringify(targetVal));
				/*dbg*/
				console.log("index argVals:" + JSON.stringify(argVals));

				var offset = _offset(targetVal, argVals, frame.orderCount > 0);
				/*dbg*/
				console.log("index offset:" + offset);
				if (assign) {
					if (offset === null) throw new X3Error(8, "range not allowed in lhs");
					var vinfo = target(_, variables.vOperations.GETINFO);

					if (vinfo.vtype === 'C')
						throw new X3Error(62, frame.prog.name + ": '" + field + "' Variable not modifiable");

					data[offset] = variables.types[vinfo.vtype].set(vinfo.vname, vinfo.vstring, val);

				} else {
					return offset !== null ? (data[offset] || targetVal[1]) : _slice(targetVal, argVals);
				}
			} else if (targetVal.collection) {
				argVals = aargs(_);
				return targetVal.index(_, argVals[0]);
			} else {
				throw new X3Error(8, "Index incorrect");
			}
		};
	},
	SORTA: function(rep, vars, orders, direction) {
		var avars = util.instructions.A(vars);
		var aorders = util.instructions.A((orders || []).map(_evalOrder));
		return function sorta$do(_) {
			var frame = glob.context.x3frame;
			var repVal = rep(_);
			if (repVal === null) repVal = -1;
			util.checkInteger(repVal);

			var dirVal = direction(_);
			if (dirVal === null) dirVal = 1;
			util.checkInteger(dirVal);

			// TODO: handle repVal
			var varVals = avars(_);
			varVals.forEach(util.checkArray);

			var arr = varVals[0];
			var ndims = arr[0];
			// sorta ignores base and uses zero-based index
			// so we only care about slice offset here
			var offset, count;
			if (arr.length === 3 + 4 * ndims) {
				offset = arr[3 + 2 * ndims];
				count = arr[4 + 2 * ndims];
			} else {
				offset = 0;
				count = arr[4] === null ? arr[2].length : arr[4] - arr[3] + 1;
			}
			// warning: indexing works differently when frame.orderCount is set
			frame.orderCount = count;
			frame.orderBase = arr[3];
			//console.log("arr = "+JSON.stringify(arr));
			var orderVals = aorders(_);
			frame.orderCount = 0;
			//console.log("orderVals = "+JSON.stringify(orderVals));

			orderVals.forEach(util.checkArray);
			var swapVals = varVals.concat(orderVals);
			if (orderVals.length === 0) orderVals = varVals;

			var swapDepth = swapVals.length;

			function swap(i, j) {
				//console.log("swap entrée.......");
				for (var k = 0; k < swapDepth; k++) {
					var arrk = swapVals[k][2];
					var tmp = arrk[i];

					//console.log("     k="+k+", swapDepth="+swapDepth+", swapVals[k][2]="+swapVals[k][2]);
					//console.log("     i="+i+", arrk[i]="+arrk[i]+",j="+j+", arrk[j]="+arrk[j]);

					arrk[i] = arrk[j];
					arrk[j] = tmp;
					//console.log("                                 arrk=" + arrk);
				}
				//console.log("swap sortie.......");
			}
			var orderDepth = orderVals.length;

			function compare(i, j) {
				var delta = 0;
				for (var k = 0; k < orderDepth && !delta; k++) {
					var arrk = orderVals[k][2],
						elt1 = arrk[i],
						elt2 = arrk[j];
					//console.log("arrk=" + JSON.stringify(arrk));
					//!console.log("Compare k=" + k + ", i=" + i + ", j=" + j);
					var t = typeof elt1;
					if (t === "number") delta = elt1 - elt2;
					else if (t === "string") delta = elt1 < elt2 ? -1 : elt1 > elt2 ? +1 : 0;
					/*					else if (util.x3IsDate(elt1)) delta = elt1.daysDiff(elt2);
					else if (util.x3IsBCD(elt1))  delta = elt1.x3Compare(elt2);*/
					else if (util.x3IsDate(elt1) || util.x3IsBCD(elt1)) delta = elt1.x3Compare(elt2);
					else throw util.badArgumentType(elt1);
				}
				return delta * dirVal;
			}

			_sort(compare, swap, offset, offset + count - 1);
			//console.log(" ap -- orderVals = "+JSON.stringify(orderVals));

		};
	},
	INSA: _insDela(false),
	DELA: _insDela(true)
};