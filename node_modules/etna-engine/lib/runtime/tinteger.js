"use strict";
var X3Error = require('./errors').X3Error;
var util = require('./util');
var Double = require('./tdouble').Double;
var bcd = require('./tbcd');
var Blbfile = require('./tblbfile').Blbfile;

exports.MAX_INT = Math.pow(2, 31);
exports.MIN_SHORTINT = -Math.pow(2, 15);
exports.MAX_SHORTINT = Math.pow(2, 15) - 1;
exports.MIN_TINYINT = 0;
exports.MAX_TINYINT = 255;

Number.prototype.x3AssertOverflow = function(type) {
	/* whatever the type, error 50 in this case*/

	if (Math.abs(this) >= Math.pow(2, 31))
		throw new X3Error(50, "");

	if (type === 'J')
		return (Math.abs(this) < Math.pow(2, 15) + ((this >= 0) ? 0 : 1)) ? true : false;
	else if (type === 'V')
		return ((this >= 0) && (this < Math.pow(2, 8))) ? true : false;

	return true;
};

Number.prototype.x3Minus = function() {
	return -this;
};

Number.prototype.x3ToInteger = function() {
	return this;
};

Number.prototype.x3ToString = function(v) {
	return "" + this;
};

Number.prototype.x3ToDouble = function() {
	return new Double(this);
};

Number.prototype.x3ToBCD = function() {
	// be carefull that x3ToBCD applies to numbers (see flowcontrol)
	//return bcd.fromInt32( this ) ;
	return bcd.fromDouble(this);
};

Number.prototype.x3ToDate = function() {
	throw util.badOperand(this);
};

Number.prototype.x3ToDatetime = function() {
	throw util.badOperand(this);
};

Number.prototype.x3IsNumeric = function() {
	return true;
};

Number.prototype.x3IsZero = function() {
	return (this === 0) ? true : false;
};
Number.prototype.x3IsUndefined = Number.prototype.x3IsZero;


Number.prototype.x3IsEmpty = function() {
	throw util.badOperand(this);
};

Number.prototype.x3Compare = function(b) {
	if (util.x3IsInteger(b)) {
		var diff = this - b;
		return !diff ? 0 : ((diff > 0) ? 1 : -1);
	} else if (util.x3IsDouble(b)) {
		return this.x3ToDouble().x3Compare(b);
	} else if (util.x3IsBCD(b)) {
		return this.x3ToBCD().x3Compare(b);
	} else throw util.badOperand(b);

};

Number.prototype.x3Add = function(b) {
	if (util.x3IsInteger(b)) {
		return this + b;
	} else if (util.x3IsDate(b)) {
		return b.x3Add(this);
	} else if (util.x3IsDatetime(b)) {
		return b.x3Add(this);
	} else if (b.x3IsNumeric()) {
		return b.x3Add(this);
	} else
		throw util.badOperand(b);
};

Number.prototype.x3Sub = function(b) {
	if (util.x3IsInteger(b)) {
		return this - b;
	} else if (util.x3IsDouble(b)) {
		return this.x3ToDouble.x3Sub(b);
	} else if (util.x3IsBCD(b)) {
		return this.x3ToBCD().x3Sub(b);
	} else
		throw util.badOperand(b);
};

Number.prototype.x3Mul = function(b) {
	if (util.x3IsInteger(b)) {
		return this * b;
	} else if (b.x3IsNumeric()) {
		return b.x3Mul(this);
	} else
		throw util.badOperand(b);
};

Number.prototype.x3Div = function(b) {
	if (util.x3IsDouble(b)) {
		return this.x3ToDouble().x3Div(b);
	} else if (util.x3IsBCD(b)) {
		return this.x3ToBCD().x3Div(b);
	} else if (util.x3IsInteger(b)) {
		if (b.x3IsZero())
			throw new X3Error(53, "");

		if (this % b === 0) return this / b;
		else return this.x3ToBCD().x3Div(b.x3ToBCD());
	} else
		throw util.badOperand(b);
};

Number.prototype.x3Mod = function(b) {
	if (util.x3IsInteger(b)) {
		if (b.x3IsZero()) return this;
		return this % b;
	} else if (util.x3IsDouble(b)) {
		return this.x3ToDouble.x3Mod(b);
	} else if (util.x3IsBCD(b)) {
		return this.x3ToBCD().x3Mod(b);
	} else
		throw util.badOperand(b);
};

Number.prototype.x3Pow = function(b) {
	if (util.x3IsInteger(b)) {
		if (this === 0) {
			if (b >= 0) return 0;
			throw new X3Error(53, "");
		}
		if (b >= 0) return Math.pow(this, b);
		else return this.x3ToDouble().x3Pow(b);
	} else if (util.x3IsDouble(b)) {
		return this.x3ToDouble().x3Pow(b);
	} else if (util.x3IsBCD(b)) {
		return this.x3ToBCD().x3Pow(b);
	} else
		throw util.badOperand(b);
};

Number.prototype.x3Xor = function(b) {
	if (b.x3IsNumeric()) {
		var i = (this.x3IsZero()) ? 1 : 0;
		var j = (b.x3IsZero()) ? 1 : 0;

		return i ^ j;
	} else
		throw util.badOperand(b);
};

Number.prototype.x3Abs = function() {
	return Math.abs(this);
};

Number.prototype.x3Truncate = function(v) {
	return this;
};


Number.prototype.x3Serialize = function(size) {
	var b = new Buffer(size);
	var v;
	var int8 = function(v) {
		return (v >= 128) ? v - 256 : v;
	};
	switch (size) {
		case 8:
			var lo = this % 0x100000000;
			var hi = Math.floor(this / 0x100000000);

			b.writeInt32BE(hi, 0);
			b.writeInt32BE(lo, 4);
			break;
		case 4:
			b.writeInt32BE(this, 0);
			break;
		case 3:
			b.writeInt8(int8(((this) >> 16) & 0xff), 0);
			b.writeInt8(int8(((this) >> 8) & 0xff), 1);
			b.writeInt8(int8((this) & 0xff), 2);
		case 2:
			b.writeInt16BE(this, 0);
			break;
		case 1:
			b.writeUInt8(this, 0);
			break;
		default:
			throw X3Error(26, "Illegal Number size");
	}
	return b;
};

Number.prototype.x3ToSql = function(driver) {
	return this;
};