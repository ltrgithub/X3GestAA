"use strict";

var util = require('./util');
var variables = require('./variables');
var errors = require('./errors');
var X3Error = errors.X3Error;

var trace = util.trace;
var warn = util.warn;

var config = {
	db: { // hardcoded values for now
		//driver: 'node-db-oracle',
		//hostname: 'sodaix02',
		//database: 'X3DVLP',
		//user: 'SUPERV',
		//password: 'tiger',
		driver: 'node-db-mysql',
		hostname: 'localhost',
		database: 'SUPERV',
		user: 'root',
		password: '',
	}
};

/* 
 * Error handling
 */

function _handleError(_, frame, e) {
	if (e.fill) e.fill(frame);
	//console.error(e.stack);
	var cx = frame.context;
	//console.error("HANDLE ERROR: " + typeof frame.errgo);
	if (!frame) throw new X3Error(26, "empty stack: " + e.stack);

	if (!frame.errgo) {
		//console.error("HANDLE ERROR RETHROWS");
		throw e;
	}

	if (cx.err) { // error while processing error!
		//console.error("Error during error handling: " + e);
		console.error("Error during error handling: " + e.stack);
		process.exit(2);
		//cx.err = null;
		//throw new X3Error(26, "error while processing error: " + e.stack);
	}
	//console.error("HANDLE ERROR CALLS ERRGO " + e)
	cx.err = e;
	frame.errgo(_, frame);
	cx.err = null; // if we reach end
}

function _locPrefix(loc) {
	return errors.moduleName(loc) + ":" + loc.line + ": ";
}

var indentLevel = 0;

function indent(delta) {
	if (delta < 0) indentLevel += delta;
	var str = Array(indentLevel + 1).join('    ');
	if (delta > 0) indentLevel += delta;
	return str;
}
function callProg(_, frame, prog, args, argVals, loc) {
	//console.error(prog.name + ": args=" + JSON.stringify(argVals));
	var prev = frame;
	var cx = prev.context;
	frame = {
		values: {},
		types: {},
		context: cx,
		prev: prev,
		loopLevel: 0,
		loc: loc || {
			file: module.id,
			line: 0
		},
		name: prog.name,
	};
	// current sub is the prog itself
	frame.sub = frame;
	frame.dicts = [frame, cx.globals, cx.sys];
	var params = prog.params;
	for (var i = 0; i < params.length; i++) {
		// TODO: copy arrays passed by value (must be done in DECL)
		frame.values[params[i]] = argVals[i];
	}
	//console.log(indent(1) + "ENTER " + prog.name + ": args=" + argVals);
	try {
		prog.body(_, frame);
	} finally {
		for (var i = 0; i < params.length; i++) {
			var param = params[i];
			var arg = args[i];
			var key = frame.types[param];
			// assign variable parameters back (in prev frame scope)
			if (key && key[0] === 'A' && arg) {
				var val = frame.values[param];
				if (!Array.isArray(val)) // arrays are passed by reference
				arg(_, prev, true, frame.values[param]);
			}
		}
	}
	//console.log(indent(-1) + "EXIT " + prog.name + ": result=" + frame.result);
	return frame.result;
}

exports.callProg = function(_, frame, prog, args, argVals, loc) {
	return callProg(_, frame, prog, args, argVals, loc);
};

exports.labelProg = function(ns, name) {
	return exports.instructions.PROG({}, "stub", [], exports.instructions.GOSUB(util.instructions.C(ns), name));
};

var voidRet = util.instructions.C();

var gotMain;

exports.functions = {
	ERRL: {
		count: 0,
		fn: function() {
			var cx = this.context;
			return cx.err && cx.err.frames && cx.err.frames[0] ? cx.err.frames[0].line : 0;
		}
	},
	ERRN: {
		count: 0,
		fn: function() {
			var cx = this.context;
			return cx.err ? cx.err.errn || 26 : 0;
		}
	},
	ERRP: {
		count: 0,
		fn: function() {
			var cx = this.context;
			return cx.err && cx.err.frames && cx.err.frames[0] ? cx.err.frames[0].file : "";
		}
	},
	ERRM: {
		count: 0,
		fn: function() {
			var cx = this.context;
			return "" + cx.err;
		}
	},
	ERRMES$: {
		count: 1,
		fn: errors.errmes$
	},
};

exports.instructions = {
	REQ: function(req, v) {
		return function req$do(_, frame) {
			var r = v(_, frame);
			try {
				return req(_, r);
			} catch (ex) {
				throw ex.errn ? ex : new X3Error(20, ex.message, ex.stack);
			}
		};
	},
	// utility to delay resolution of p[i] branch
	GO: function(p, i) {
		return function go$do(_, frame) {
			return p[i](_, frame);
		};
	},

	// block
	B: function(f1, f2) {
		var fns = Array.prototype.slice.call(arguments, 0);
		if (fns.length == 1) return fns[0];
		fns = fns.filter(function(fn) { // eliminate NL(n) instructions
			return fn;
		});
		return function b$do(_, frame) {
			var sub = frame.sub;
			var level = frame.loopLevel;
			for (var i = 0; i < fns.length && !sub.done && !frame.done && frame.loopLevel >= level; i++) {
				try {
					fns[i](_, frame);
				} catch (e) {
					_handleError(_, frame, e);
				}
			}
		};
	},
	GOSUB: function(ns, label) {
		return function gosub$do(_, frame) {
			var nsVal = ns(_, frame);
			if (!nsVal || !nsVal[label]) throw new X3Error(20, "invalid gosub target: " + label);
			var prevSub = frame.sub;
			try {
				frame.sub = {
					prevSub: prevSub,
					name: label,
					loc: prevSub.loc,
				};
				//console.error("GOSUB: " + label)
				nsVal[label](_, frame);
				return frame.sub.ret;
			} finally {
				frame.sub = prevSub;
			}
		};
	},
	GOTO: function(ns, label) {
		return function gosub$do(_, frame) {
			// warning: ok for debug but eats memory!!!
			frame.sub.name = frame.sub.name + '/' + label;
			var nsVal = ns(_, frame);
			if (!nsVal || !nsVal[label]) throw new X3Error(20, "invalid gosub target: " + label);
			nsVal[label](_, frame);
			return frame.sub.ret;
		}
	},
	RET: function(arg) {
		return function ret$do(_, frame) {
			frame.sub.result = arg && arg(_, frame);
			frame.sub.done = true;
		};
	},
	ONERRGO: function(ns, label) {
		var target = label && exports.instructions.GOSUB(ns, label);
		return function onerrgo$do(_, frame) {
			frame.errgo = target;
		};
	},
	RESUME: function() {
		return function resume$do(_, frame) {
			//console.error("BEGIN RESUME " + cx.err);
			var cx = frame.context;
			if (!cx.err) {
				//console.error("FATAL"); process.exit();
				throw new X3Error(32, "invalid attempt to resume without error");
			}
			frame.sub.done = true;
			//console.error("END RESUME")
		};
	},
	PROG: function(e, name, params, body) {
		return e[name] = {
			name: name,
			params: params,
			body: body
		};
	},
	CALL: function(ns, name, args) {
		var aargs = util.instructions.A(args);
		return function call$do(_, frame) {
			var nsVal = ns.value !== undefined ? ns.value : ns(_, frame);
			// TODO: pass literals as direct strings 'xxx' rather than C('xxx')
			var nameVal = typeof name === 'string' ? name : name.value !== undefined ? name.value : name(_, frame);
			if (!nsVal) throw new X3Error(20, "bad script name: " + nsVal);
			var prog = nsVal[nameVal];
			if (!prog) throw new X3Error(20, "bad prog name: " + nameVal);
			if (!prog.params) throw new X3Error(113, "call target is not a prog: " + nameVal);
			// don't bark on extra parameters -- AXUNIT has some -- will just be ignored
			if (prog.params.length > args.length) throw new X3Error(69, "parameter count mismatch: expected " + prog.params.length + ", got " + args.length);
			// eval params before pushing stack
			var argVals = aargs(_, frame);
			return callProg(_, frame, prog, args, argVals, frame.sub.loc);
		};
	},
	END: function(arg) {
		return function end$do(_, frame) {
			if (!frame) throw new X3Error(32, "unexpected return or end");
			frame.result = arg && arg(_, frame);
			frame.sub.done = true;
			frame.done = true;
		};
	},
	F: function(name, args) {
		var fn = require('./index').functions[name];
		if (fn == null) throw new X3Error(4, "bad function name: " + name);
		var argc = (args ? args.length : 0);
		if (fn.count >= 0 && fn.count != argc) throw new X3Error(69, _locPrefix(util.sourceLoc) + "bad arg count: function'" + name + "' expected " + fn.count + ", got " + argc);
		var aargs = args ? util.instructions.A(args) : voidRet;
		if (fn.fn == null) {
			warn && warn("function : " + name);
			return util.instructions.NIY({
				tag: name
			});
		}
		return function f$do(_, frame) {
			var vals = aargs(_, frame);
			var fcall = frame.fcall;
			frame.fcall = name;
			try {
				if (fn.async) return fn.fn.apply_(_, frame, vals, 0);
				else return fn.fn.apply(frame, vals);
			} finally {
				frame.fcall = fcall;
			}
		};
	},
	IF: function(cond, p, branch, block) {
		return function if$do(_, frame) {
			var val = cond(_, frame);
			return (val ? block : p[branch])(_, frame);
		};
	},
	CASE: function(exp, p, branch) {
		return function case$do(_, frame) {
			var val = exp(_, frame);
			p[branch](_, frame, val);
		};
	},
	WHEN: function(exps, p, branch, block) {
		return function when$do(_, frame, val) {
			if (exps.length === 0) // When Default
			return block(_, frame);
			for (var i = 0; i < exps.length; i++) {
				var exp = exps[i];
				if ((exp.value !== undefined ? exp.value : exp(_, frame)) == val) return block(_, frame);
			}
			p[branch](_, frame, val);
		};
	},
	WHILE: function(cond, p, end, block, isRepeat) {
		return function while$do(_, frame) {
			var level = ++frame.loopLevel;
			var beenHere = false;
			while (frame.loopLevel === level) {
				var condVal = (isRepeat && !beenHere) ? false : cond(_, frame);
				beenHere = true;
				if (isRepeat) condVal = !condVal;
				if (condVal) block(_, frame);
				else frame.loopLevel = level - 1;
			}
			if (frame.loopLevel === level - 1) p[end](_, frame);
		};
	},
	FORV: function(varName, from, to, step, p, end, block) {
		return function forv$do(_, frame) {
			var fromI = from(_, frame);
			var toI = to(_, frame);
			var stepI = step ? step(_, frame) : 1;
			var values = frame.values;
			var level = ++frame.loopLevel;
			for (var i = fromI; i <= toI && frame.loopLevel === level; i += stepI) {
				values[varName] = i;
				block(_, frame);
			}
			if (frame.loopLevel === level) {
				frame.loopLevel--;
				p[end](_, frame);
			}
		};
	},
	FORIN: function(varName, items, p, end, block) {
		return function forv$do(_, frame) {
			var values = frame.values;
			var level = ++frame.loopLevel;
			for (var i = 0, l = items.length; i < l && frame.loopLevel === level; i++) {
				values[varName] = items[i](_, frame);
				block(_, frame);
			}
			if (frame.loopLevel === level) {
				frame.loopLevel--;
				p[end](_, frame);
			}
		};
	},
	BREAK: function(p, level) {
		return function break$do(_, frame) {
			var l = level(_, frame);
			if (frame.loopLevel === null || frame.loopLevel < l) throw new X3Error(8, "invalid break level: " + l);
			frame.loopLevel -= l;
		};
	},
	MAIN: function(e, _) {
		if (gotMain) return;
		gotMain = true;
		var frame = variables.createStack(config);
		// desynchronize execution to load rest of module and dependencies
		process.nextTick(_);
		var t0 = Date.now();
		try {
			var r = exports.instructions.GOSUB(util.instructions.C(e), 'MAIN')(_, frame);
			console.log("OK: " + r);
		} catch (e) {
			console.log("FAILED: " + e + "\njs stack=" + e.stack);
		}
		console.log("completed in: " + (Date.now() - t0) / 1000 + " s");
		console.log(Math.floor(process.memoryUsage().heapUsed / (1024 * 1024)) + " MB heap used");
		require('./index').dumpCounters();
	}
};