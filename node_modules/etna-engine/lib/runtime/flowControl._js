"use strict";

var util = require('./util');
var variables = require('./variables');
//var tdouble  = require('./tdouble') ;
var errors = require('./errors');
var X3Error = errors.X3Error;
var glob = require('streamline/lib/globals');

var config = {
	db: { // hardcoded values for now
		//driver: 'node-db-oracle',
		//hostname: 'sodaix02',
		//database: 'X3DVLP',
		//user: 'SUPERV',
		//password: 'tiger',
		driver: 'node-db-mysql',
		hostname: 'localhost',
		database: 'SUPERV',
		user: 'root',
		password: '',
	}
};

/* 
 * Error handling
 */

function _handleError(_, frame, e) {
	// unwind stack
	// console.log("_handleError:"+JSON.stringify(e));
	glob.context.frame = frame;
	if (e.fill) {
		e = new X3Error(e);
		e.fill(frame);
	}

	//console.error(e.stack);
	var cx = frame.context;
	//console.error("HANDLE ERROR: " + typeof frame.errgo);
	if (!frame) throw new X3Error(26, "empty stack: " + e.stack);

	if (!frame.errgo) {
		//console.error("HANDLE ERROR RETHROWS");
		throw e;
	}

	if (cx.err) { // error while processing error!
		//console.error("Error during error handling: " + e);
		console.error("Error during error handling: " + e.stack);
		process.exit(2);
		//cx.err = null;
		//throw new X3Error(26, "error while processing error: " + e.stack);
	}
	//!console.error("HANDLE ERROR CALLS ERRGO " + e)
	cx.err = e;
	frame.errgo(_);
	cx.err = null; // if we reach end
}

function _locPrefix(loc) {
	return errors.moduleName(loc) + ":" + loc.line + ": ";
}

var indentLevel = 0;

function indent(delta) {
	if (delta < 0) indentLevel += delta;
	var str = Array(indentLevel + 1).join('    ');
	if (delta > 0) indentLevel += delta;
	return str;
}

function callProg(_, prog, args, argVals, loc) {
	//console.log(prog.name + ": args=" + JSON.stringify(argVals));
	var frame = glob.context.x3frame;

	var prev = frame;
	var cx = prev.context;
	glob.context.x3frame = frame = {
		values: {},
		types: {},
		context: cx,
		prev: prev,
		loopLevel: 0,
		loc: prog.loc || {
			file: module.id,
			line: 0
		},
		prog: prog,
	};
	cx.traceCall && cx.traceCall(_, "enter", argVals);
	exports.monitorCall && exports.monitorCall(frame, "enter");
	// current sub is the prog itself
	frame.sub = frame;
	frame.dicts = [frame, cx.globals, cx.sys];
	var params = prog.params;
	var i, j;
	for (i = 0; i < params.length; i++) {
		if (Array.isArray(argVals[i])) {
			// arrays passed by reference : 
			// Save dimensions and default value . The actual "array" is saved in variables
			var newtab = [];
			for (var j = 0; j < argVals[i].length; j++) {
				newtab[j] = argVals[i][j];
			}
			//save copy in argVals[i]
			argVals[i] = newtab;
		}
		// By default the parameter is a constant of type ANY
		frame.types[params[i]] = "CX";
		frame.values[params[i]] = argVals[i];
	}
	try {
		prog.body(_);
	} finally {
		exports.monitorCall && exports.monitorCall(frame, "exit");
		cx.traceCall && cx.traceCall(_, "exit", frame.result);

		// pop frame
		glob.context.x3frame = prev;
		for (i = 0; i < params.length; i++) {
			var param = params[i];
			var arg = args[i];
			var key = frame.types[param];
			// assign variable parameters back (in prev frame scope)
			if (key && key[0] === 'A' && arg) {
				var val = frame.values[param];
				if (Array.isArray(val)) {
					// arrays are passed by reference
					// Restore dimensions but preserve the saved array :
					for (j = 0; j < argVals[i].length; j++) {
						if (!Array.isArray(argVals[i][j])) argVals[i][j] = val[j];
					}
				} else {
					arg(_, variables.vOperations.SET, frame.values[param]);
				}
			}
		}
	}
	return frame.result;
}

exports.callProg = function(_, prog, args, argVals, loc) {
	return callProg(_, prog, args, argVals, loc);
};

exports.labelProg = function(ns, name) {
	return exports.instructions.PROG({}, "stub", [], exports.instructions.GOSUB(util.instructions.C(ns), name));
};

function callJS(_, ns, prog, argVals, frame) {
	if (typeof prog !== "function") throw new X3Error(113, "not a function: " + prog);
	try {
		return prog.apply_(_, null, argVals, 0);
	} catch (ex) {
		_handleError(_, frame, ex);
	}
}

function getSetter(field, val) {
	var frame = glob.context.x3frame;
	var dicts = frame.dicts;
	var key;
	var setter;
	for (var i = 0, len = dicts.length; i < len; i++) {
		if (dicts[i].values && dicts[i].values[field] !== undefined) {
			key = dicts[i].types[field];
			setter = variables.types[key[1]].set;
			return function(val) {
				dicts[i].values[field] = setter(field, key, val);
			};
		}
	}
	// Declare a local variable ;
	key = "LI";
	var def = 0;
	if (val !== undefined) {
		def = val;
		if (typeof val !== "number") {
			if (typeof val === "string") key = "LS";
			else if (util.isDate(val)) key = "LD";
		}
	}

	frame.values[field] = def;
	frame.types[field] = key;

	setter = variables.types[key[1]].set;
	return function(val) {
		frame.values[field] = setter(field, key, val);
	};
};

var voidRet = util.instructions.C();

var gotMain;

exports.functions = {
	ERRL: {
		count: 0,
		fn: function() {
			var cx = this.context;
			return cx.err && cx.err.frames && cx.err.frames[0] ? cx.err.frames[0].line : 0;
		}
	},
	ERRN: {
		count: 0,
		fn: function() {
			var cx = this.context;
			return (cx.err ? cx.err.errn || 26 : 0);
		}
	},
	ERRP: {
		count: 0,
		fn: function() {
			var cx = this.context;
			return cx.err && cx.err.frames && cx.err.frames[0] ? cx.err.frames[0].file : "";
		}
	},
	ERRM: {
		count: 0,
		fn: function() {
			var cx = this.context;
			return "" + cx.err;
		}
	},
	ERRMES$: {
		count: 1,
		fn: errors.errmes$
	},

	MESS: {
		async: true,
		count: 3,
		fn: function(_, id, chapter, swtch) {
			var frame = glob.context.x3frame;

			if (!util.x3IsInteger(chapter)) throw util.badOperand(chapter);
			if (!util.x3IsInteger(id)) throw util.badOperand(id);
			if (!util.x3IsInteger(swtch)) throw util.badOperand(swtch);

			if ((id < 0) || (chapter < 0) || (swtch < 0)) throw new X3Error(50, "");
			if ((swtch === 0) && (chapter > 149)) return "";

			// hack in order to test other languages, has to be deleted later !!
			// --------------------------------------------------------------------------
			if (frame.context.sys.values["MESSNAME"] !== frame.context.superv.LAN(_))
				return frame.context.superv.loadMess(_, (swtch !== 0) ? chapter : chapter + 9001, id, frame.context.sys.values["MESSNAME"]);
			else
				return frame.context.superv.loadMess(_, (swtch !== 0) ? chapter : chapter + 9001, id);
		}
	},
};

exports.instructions = {
	REQ: function(req, v) {
		return function req$do(_) {
			var r = v(_);
			try {
				return req(_, r);
			} catch (ex) {
				//throw ex.errn ? ex : new X3Error(20, ex.message, ex.stack);
				throw new X3Error(20, ex.message, ex.stack);
			}
		};
	},
	// utility to delay resolution of p[i] branch
	GO: function(p, i) {
		return function go$do(_) {
			return p[i](_);
		};
	},

	// block
	B: function(f1, f2) {
		var fns = Array.prototype.slice.call(arguments, 0);
		if (fns.length == 1) return fns[0];
		fns = fns.filter(function(fn) { // eliminate NL(n) instructions
			return fn;
		});
		return function b$do(_) {
			var frame = glob.context.x3frame;
			var sub = frame.sub;
			var level = frame.loopLevel;
			for (var i = 0; i < fns.length && !sub.done && !frame.done && frame.loopLevel >= level; i++) {
				try {
					fns[i](_);
				} catch (e) {
					_handleError(_, frame, e);
				}
			}
		};
	},
	GOSUB: function(ns, label) {
		return function gosub$do(_) {
			var frame = glob.context.x3frame;
			var nsVal = ns(_);
			if (!nsVal || !nsVal[label]) throw new X3Error(20, "invalid gosub target: " + label);
			var prevSub = frame.sub;
			try {
				frame.sub = {
					prevSub: prevSub,
					name: label,
					loc: prevSub.loc,
				};
				//console.error("GOSUB: " + label)
				nsVal[label](_);
				return frame.sub.ret;
			} finally {
				frame.sub = prevSub;
			}
		};
	},
	GOTO: function(ns, label) {
		return function gosub$do(_) {
			var frame = glob.context.x3frame;
			// warning: ok for debug but eats memory!!!
			frame.sub.name = frame.sub.name + '/' + label;
			var nsVal = ns(_);
			if (!nsVal || !nsVal[label]) throw new X3Error(20, "invalid gosub target: " + label);
			nsVal[label](_);
			return frame.sub.ret;
		};
	},
	RET: function(arg) {
		return function ret$do(_) {
			var frame = glob.context.x3frame;
			frame.sub.result = arg && arg(_);
			frame.sub.done = true;
		};
	},
	ONERRGO: function(ns, label) {
		var target = label && exports.instructions.GOSUB(ns, label);
		return function onerrgo$do(_) {
			var frame = glob.context.x3frame;
			frame.errgo = target;
		};
	},
	RESUME: function() {
		return function resume$do(_) {
			//console.error("BEGIN RESUME ",cx.err);
			var frame = glob.context.x3frame;
			var cx = frame.context;
			if (!cx.err) {
				//console.error("FATAL"); process.exit();
				throw new X3Error(32, "invalid attempt to resume without error");
			}
			frame.sub.done = true;
			//console.error("END RESUME")
		};
	},
	PROG: function(e, name, params, body) {
		return e[name] = {
			name: name,
			params: params,
			body: body,
			module: e,
			loc: util.sourceLoc,
		};
	},
	CALL: function(ns, name, args) {
		var aargs = util.instructions.A(args);
		return function call$do(_) {
			var frame = glob.context.x3frame;
			var nsVal = ns.value !== undefined ? ns.value : ns(_);
			// TODO: pass literals as direct strings 'xxx' rather than C('xxx')
			var nameVal = typeof name === 'string' ? name : name.value !== undefined ? name.value : name(_);
			if (!nsVal) throw new X3Error(20, "bad script name: " + nsVal);
			var prog = nsVal[nameVal];
			if (!prog) throw new X3Error(39, "bad prog name: " + nameVal);
			// eval params before pushing stack

			var argVals = aargs(_);
			if (nsVal.$exported) return callJS(_, nsVal, prog, argVals, frame);
			if (!prog.params) throw new X3Error(113, "call target is not a prog: " + nameVal);
			// don't bark on extra parameters -- AXUNIT has some -- will just be ignored
			if (prog.params.length > args.length) throw new X3Error(69, "parameter count mismatch: expected " + prog.params.length + ", got " + args.length);
			return callProg(_, prog, args, argVals, frame.sub.loc);
		};
	},
	END: function(arg) {
		return function end$do(_) {
			var frame = glob.context.x3frame;
			if (!frame) throw new X3Error(32, "unexpected return or end");
			frame.result = arg && arg(_);
			frame.sub.done = true;
			frame.done = true;
		};
	},
	F: function(name, args) {
		var fn = require('./index').functions[name];
		if (fn == null) throw new X3Error(4, "bad function name: " + name);
		var argc = (args ? args.length : 0);
		if (fn.count >= 0 && fn.count != argc) throw new X3Error(69, _locPrefix(util.sourceLoc) + "bad arg count: function'" + name + "' expected " + fn.count + ", got " + argc);
		var aargs = args ? util.instructions.A(args) : voidRet;
		if (fn.fn == null) {
			console.error("NIY function : " + name);
			return util.instructions.NIY({
				tag: name
			});
		}
		var fdo = function f$do(_) {
			var frame = glob.context.x3frame;
			var vals = aargs(_);
			var fcall = frame.fcall;
			frame.fcall = name;
			var traceFunc = frame.context.traceFunc;
			try {
				traceFunc && traceFunc(_, "enter", vals);
				var result;
				if (fn.async) result = fn.fn.apply_(_, null, vals, 0);
				else result = fn.fn.apply(frame, vals);
				traceFunc && traceFunc(_, "exit", result);
				return result;
			} finally {
				frame.fcall = fcall;
			}
		};
		fdo.instName = name;
		return fdo;
	},
	IF: function(cond, p, branch, block) {
		return function if$do(_) {
			var val = cond(_);
			return (val ? block : p[branch])(_);
		};
	},
	CASE: function(exp, p, branch) {
		return function case$do(_) {
			var val = exp(_);
			p[branch](_, val);
		};
	},
	WHEN: function(exps, p, branch, block) {
		return function when$do(_, val) {
			if (exps.length === 0) // When Default
				return block(_);
			for (var i = 0; i < exps.length; i++) {
				var exp = exps[i];
				if ((exp.value !== undefined ? exp.value : exp(_)).x3Compare(val) == 0) return block(_);
			}
			p[branch](_, val);
		};
	},
	WHILE: function(cond, p, end, block, isRepeat) {
		return function while$do(_) {
			var frame = glob.context.x3frame;
			var level = ++frame.loopLevel;
			var beenHere = false;
			while (frame.loopLevel === level) {
				var condVal = (isRepeat && !beenHere) ? false : cond(_);
				beenHere = true;
				if (isRepeat) condVal = !condVal;
				if (condVal) block(_);
				else frame.loopLevel = level - 1;
			}
			if (frame.loopLevel === level - 1) p[end](_);
		};
	},
	FORV: function(varName, from, to, step, p, end, block) {
		return function forv$do(_) {
			var frame = glob.context.x3frame;

			function toNumber(v) {
				if (typeof v === "number") return v;
				if (util.x3IsDouble(v)) return v.valueOf();
				if (util.x3IsBCD(v)) return v.x3ToDouble().valueOf();
				return v;
			}
			var fromI = toNumber(from(_));
			var toI = toNumber(to(_));
			var stepI = toNumber(step ? step(_) : 1);
			if (stepI === 0) {
				//If the error is 'handled' the next statement after a FORV is
				// p[end] :
				_handleError(_, frame, new X3Error(41, "invalid step value: " + stepI));
				p[end](_);
				return;
			}

			var condition = (stepI >= 0) ?
					function() {
						return idx <= toI && frame.loopLevel === level;
				} :
					function() {
						return idx >= toI && frame.loopLevel === level;
				};

			var setIndex = (function(field) {
				var setValue = getSetter(field);
				return function(val) {
					setValue(val);
				};
			})(varName);

			var level = ++frame.loopLevel;
			for (var idx = fromI; condition(); idx += stepI) {
				setIndex(idx);
				block(_);
			}
			var fend = ((level - frame.loopLevel) <= 1) ? p[end] : null;

			if (frame.loopLevel === level) {
				setIndex(idx);
				frame.loopLevel--;
			}
			if (fend) fend(_);
		};
	},
	FORIN: function(varName, items, p, end, block) {
		return function forv$do(_) {
			var frame = glob.context.x3frame;
			var level = ++frame.loopLevel;

			var setValue;

			for (var i = 0, l = items.length; i < l && frame.loopLevel === level; i++) {
				var val = items[i](_);
				setValue = setValue || getSetter(varName, val);
				setValue(val);
				block(_);
			}
			var fend = ((level - frame.loopLevel) <= 1) ? p[end] : null;

			if (frame.loopLevel === level) {
				frame.loopLevel--;
				p[end](_);
			}
			if (fend) fend(_);
		};
	},
	BREAK: function(p, level) {
		return function break$do(_) {
			var frame = glob.context.x3frame;
			var l = level(_);
			if (l < 0) throw new X3Error(50, "invalid break level: " + l);
			if (frame.loopLevel === null || frame.loopLevel < l) throw new X3Error(50, "invalid break level: " + l);
			frame.loopLevel -= l;
		};
	},
	MAIN: function(e, _) {
		if (gotMain) return;
		gotMain = true;
		var frame = glob.context.x3frame = variables.createStack(config);
		// desynchronize execution to load rest of module and dependencies
		process.nextTick(_);
		var t0 = Date.now();
		try {
			var r = exports.instructions.GOSUB(util.instructions.C(e), 'MAIN')(_);
			console.log("OK: " + r);
		} catch (e) {
			console.log("FAILED: " + e + "\njs stack=" + e.stack);
		}
		console.log("completed in: " + (Date.now() - t0) / 1000 + " s");
		console.log(Math.floor(process.memoryUsage().heapUsed / (1024 * 1024)) + " MB heap used");
		require('./index').dumpCounters();
	}
};