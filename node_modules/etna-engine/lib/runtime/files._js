"use strict";
var helpers = require('syracuse-core/lib/helpers');
var fs = require('streamline-fs');
var X3Error = require('./errors').X3Error;
var Blbfile = require('./tblbfile').Blbfile;

var _ium = {
	0: "utf8",
	1: "utf8",
	50: "ascii"
};

var _fium = {
	"utf8": fromUTF8,
	"ascii": from8Bits
};


function op_error(ex) {
	switch (ex.code) {
		case "ENOENT":
			throw new X3Error(20, ex.message);
		case "EPERM":
		case "EACCES":
			throw new X3Error(27, ex.message);
		default:
			throw new X3Error(26, ex.message);
	}
}

function byteLength(str) {
	// returns the byte length of an utf8 string
	var s = str.length;
	for (var i = str.length - 1; i >= 0; i--) {
		var code = str.charCodeAt(i);
		if (code > 0x7f && code <= 0x7ff) s++;
		else if (code > 0x7ff && code <= 0xffff) s += 2;
		if (code >= 0xDC00 && code <= 0xDFFF) i--; //trail surrogate
	}
	return s;
}

function from8Bits(buf, len) {
	var str = "";
	for (var i = 0; i < len; i++)
		str += String.fromCharCode(buf[i]);

	return str;
}

function fromUTF8(buf, len) {
	return buf.toString('utf8', 0, len);
}

function isTrailer(byte) {
	return (byte & 0xc0) === 0x80;
}

function UT8Backward(buf) {
	var i = buf.length - 1;

	while (isTrailer(buf[i]) && (i-- >= 0));
	return buf.length - i;
}


var File = helpers.defineClass(function(ctx) {
	var self = this;
	self.ctx = ctx;
	self.fd = null;
	self.mode = "";
	self.offset = 0;
	return self;
}, null, {

	x3open: function(_, xfil, seekVal, mode) {
		var self = this;
		//dbg:console.log("x3open " +xfil.toString(_)+ " seekVal:"+seekVal+" mode:"+ mode);
		if (mode === "w" && seekVal === -1) mode = "r+";
		else if (!mode) mode = "r";

		try {
			var fd = fs.open(xfil.toString(_), mode, _);

		} catch (ex) {
			if (mode === "r+") {
				// Try again with w+
				mode = "w+";
				try {
					fd = fs.open(xfil.toString(_), mode, _);
				} catch (ex) {
					op_error(ex);
				}
			} else op_error(ex);
		}
		self.fd = fd;
		self.mode = mode;
		if (seekVal === -1) {
			var stat = fs.fstat(self.fd, _);
			self.offset = stat.size;
		} else {
			self.offset = 0;
		}
		self.mda = 0;
		self.bom = 0;
	},

	x3seek: function(_, mode, direction, value) {
		var self = this;
		//console.log("Seek " + mode + " " + value + " " + direction+ " typeof value:"+(typeof value));
		switch (mode) {
			case 'FIRST':
				self.offset = value;
				break;
			case 'LAST':
				var stat = fs.fstat(self.fd, _);
				self.offset = stat.size - value;
				break;
			case "CURR":
				self.offset += (direction * value); //direction = -1 / 1
				break;
			default:
		}
		//console.log("Result offset " + self.offset);
	},

	x3write: function(_, vals, nl) {
		var self = this;
		var ifs = self.adxifs || self.ctx.values["ADXIFS"];
		var irs = self.adxirs || self.ctx.values["ADXIRS"];
		var vium = self.adxium || self.ctx.values["ADXIUM"];
		var ium = _ium[vium];

		// bom management
		if (self.mda === 0) {
			self.mda = 2;
			if (vium === 1) {
				var bom = new Buffer([0xef, 0xbb, 0xbf]);
				fs.write(self.fd, bom, 0, bom.length, 0, _);
				self.bom = 3;
			}
		}

		// value to write management
		var newvals = vals.map(function(v) {
			if (Array.isArray(v)) {
				var t = v[2];
				var r = "";
				if (v[1] > 1)
					throw new X3Error(26, "More than 1 dimension is not supported");
				var min = (v[5]) ? v[3] - v[5] : 0;
				var max = (v[6]) ? v[3] + v[6] - v[5] - 1 : v[4] - v[3];

				for (var i = min; i <= max; i++) {
					if (i !== min) r += ifs;
					r += (t[i]) ? t[i].x3ToString() : "";
				}
				return r;
			} else
				return v.x3ToString();
		});
		var str = newvals.join(ifs);

		// write it
		// 2 conditions have to be met in order to make the position parameter work :
		// 1°/ Use a Buffer instead of a string
		// 2°/ Open the file with r+ instead of a
		var buffer = new Buffer(str + ((nl) ? irs : ifs), ium || "utf8");

		//dbg:console.log("x3write fs.write fd:"+self.fd+" position:"+ self.offset + self.bom);
		var len = fs.write(self.fd, buffer, 0, buffer.length, self.offset + self.bom, _);
		self.offset += len;
		return len;
	},

	x3read: function(_) {
		var self = this;

		// read parameters
		var ifs = self.adxifs || self.ctx.values["ADXIFS"];
		var irs = self.adxirs || self.ctx.values["ADXIRS"];
		var ium = _ium[self.adxium || self.ctx.values["ADXIUM"]];
		var fium = _fium[ium];

		// tool variables
		var curr = self.offset;
		var cache = new Buffer(500);
		var bom = new Buffer(3);
		var lines;
		var str = "";
		var bck;

		if (self.mda === 0) {
			self.mda = 2;

			if (ium === "utf8") {

				var len = fs.read(self.fd, bom, 0, bom.length, 0, _);
				self.bom = ((bom[0] === 0xef) && (bom[1] === 0xbb) && (bom[2] === 0xbf)) ? 3 : 0;
			}
		}

		// algo 
		var len = fs.read(self.fd, cache, 0, cache.length, curr + self.bom, _);
		if (len === 0) return [];

		while (len > 0) {
			bck = (ium === "utf8") ? UT8Backward(cache) : 0;

			str += fium(cache, cache.length - bck);
			lines = str.split(irs);
			if (lines.length > 1)
				break;
			else {
				curr += (len - bck);
				len = fs.read(self.fd, cache, 0, cache.length, curr + self.bom, _);
			}
		}
		// end

		self.offset += ((ium === "ascii") ? lines[0].length + 1 : byteLength(lines[0] + 1));

		return ifs.length ? lines[0].split(ifs) : [lines[0]];
	},

	x3get: function(_, size) {
		var self = this;
		self.mda = 1;
		var curr = self.offset;

		var bf = new Buffer(size);
		var len = fs.read(self.fd, bf, 0, bf.length, curr, _);
		if (len === 0) return null;
		self.offset += len;

		return new Blbfile(bf);
	},

	x3put: function(_, nbr, vals, size) {
		var self = this;
		var i = 0,
			nbv = 0;
		var vlist = [];
		var tsize = 0;
		var curr = self.offset;

		self.mda = 1;

		// build buffer to write 
		while (vals[i]) {
			var v = vals[i];
			if (Array.isArray(v)) {
				var t = v[2];
				if (v[1] > 1)
					throw new X3Error(26, "More than 1 dimension is not supported");
				var min = (v[5]) ? v[3] - v[5] : 0;
				var max = (v[6]) ? v[3] + v[6] - v[5] - 1 : v[4] - v[3];

				for (var j = min; j <= max; j++) {
					var val = (t[j] !== undefined ? t[j] : v[1]).x3Serialize(size[i]);

					tsize += val.length;
					vlist.push(val);
					if (++nbv >= nbr) break;
				}
				if (nbv >= nbr) break;
			} else {
				var val = v.x3Serialize(size[i]);
				tsize += val.length;
				vlist.push(val);
				if (++nbv >= nbr) break;
			}
			i++;
		}
		var bf = Buffer.concat(vlist, tsize);

		// write buffer in file
		//dbg:console.log("x3put fs.write fd:"+self.fd+" position:"+ curr);
		var len = fs.write(self.fd, bf, 0, bf.length, curr, _);
		self.offset += len;
		return len;
	},

	x3close: function(_) {
		var self = this;
		try {
			fs.close(self.fd, _);
		} catch (ex) {
			throw new X3Error(20, ex.message);
		}
	},

	x3adxseek: function() {
		var self = this;
		return self.offset;
	}
});

exports.File = File;