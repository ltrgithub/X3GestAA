"use strict";
var helpers = require('syracuse-core/lib/helpers');
var fs = require('streamline-fs');

var _ium = {
	0: "utf8",
	50: "ascii"
};

var File = helpers.defineClass(function(ctx) {
	var self = this;
	this.ctx = ctx;
	this.fd = null;
	this.mode = "";
	this.offset = 0;
	return self;
}, null, {

	x3open: function(_, xfil, offset, mode) {
		var self = this;
		try {
			if (mode === "w") mode = "a";
			else if (mode === "r+") mode = "a+";

			var fd = fs.open(xfil.toString(_), mode, _);

		} catch (ex) {
			throw new X3Error(20, ex.message);
		}
		self.fd = fd;
		self.mode = mode;
		self.offset = offset;
	},

	x3seek: function(pos) {
		this.offset = pos;
	},

	x3write: function(_, vals, nl) {
		var self = this;
		var ifs = self.adxifs || self.ctx.values["ADXIFS"];
		var irs = self.adxirs || self.ctx.values["ADXIRS"];
		var ium = _ium[self.adxium || self.ctx.values["ADXIUM"]];

		var newvals = vals.map(function(v) {
			return v.x3ToString();
		});
		var str = newvals.join(ifs);

		// write it
		var len = fs.write(self.fd, str + ((nl) ? irs : ifs), self.offset, ium || "utf8", _);

		self.offset += len;
		return len;
	},

	x3read: function(_) {

	},

	x3get: function(_) {

	},

	x3put: function(_) {

	},

	x3close: function(_) {
		var self = this;
		try {
			fs.close(self.fd, _);
		} catch (ex) {
			throw new X3Error(20, ex.message);
		}
	}
});

exports.File = File;