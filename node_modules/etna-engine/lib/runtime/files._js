"use strict";
var helpers = require('syracuse-core/lib/helpers');
var fs = require('streamline-fs');
//var fs = require('fs');

var _ium = {
	0: "utf8",
	50: "ascii"
};

var _fium = {
	"utf8": fromUTF8,
	"ascii": from8Bits
};

function byteLength(str) {
	// returns the byte length of an utf8 string
	var s = str.length;
	for (var i = str.length - 1; i >= 0; i--) {
		var code = str.charCodeAt(i);
		if (code > 0x7f && code <= 0x7ff) s++;
		else if (code > 0x7ff && code <= 0xffff) s += 2;
		if (code >= 0xDC00 && code <= 0xDFFF) i--; //trail surrogate
	}
	return s;
}

function from8Bits(buf, len) {
	var str = "";
	for (var i = 0; i < len; i++)
		str += String.fromCharCode(buf[i]);

	return str;
}

function fromUTF8(buf, len) {
	return buf.toString('utf8', 0, len);
}

function isTrailer(byte) {
	return (byte & 0xc0) === 0x80;
}

function UT8Backward(buf) {
	var i = buf.length - 1;

	while (isTrailer(buf[i]) && (i-- >= 0));
	return buf.length - i;
}


var File = helpers.defineClass(function(ctx) {
	var self = this;
	this.ctx = ctx;
	this.fd = null;
	this.mode = "";
	this.offset = 0;
	return self;
}, null, {

	x3open: function(_, xfil, offset, mode) {
		var self = this;
		try {
			if (mode === "w") mode = "a";
			else if (mode === "r+") mode = "a+";

			var fd = fs.open(xfil.toString(_), mode, _);

		} catch (ex) {
			throw new X3Error(20, ex.message);
		}
		self.fd = fd;
		self.mode = mode;
		self.offset = offset;
		self.mda = 0;
	},

	x3seek: function(_, mode, direction, value) {
		var self = this;
		console.log("Seek " + mode + " " + value + " " + direction);
		switch (mode) {
			case 'FIRST':
				self.offset = value;
				break;
			case 'LAST':
				var stat = fs.fstat(self.fd, _);
				self.offset = stat.size - value;
				break;
			case "CURR":
				self.offset += (direction * value); //direction = -1 / 1
				break;
			default:
		}
		console.log("Result offset " + self.offset);
	},

	x3write: function(_, vals, nl) {
		var self = this;
		var ifs = self.adxifs || self.ctx.values["ADXIFS"];
		var irs = self.adxirs || self.ctx.values["ADXIRS"];
		var ium = _ium[self.adxium || self.ctx.values["ADXIUM"]];

		self.mda = 2;

		var newvals = vals.map(function(v) {
			if (Array.isArray(v)) {
				var t = v[2];
				var r = "";
				for (var i = v[3]; i <= v[4]; i++) {
					if (i !== v[3]) r += ifs;
					r += (t[i - v[3]]) ? t[i - v[3]].x3ToString() : "";
				}
				return r;
			} else
				return v.x3ToString();
		});
		var str = newvals.join(ifs);

		// write it
		var len = fs.write(self.fd, str + ((nl) ? irs : ifs), self.offset, ium || "utf8", _);

		self.offset += len;
		return len;
	},

	x3read: function(_) {
		var self = this;

		// read parameters
		var ifs = self.adxifs || self.ctx.values["ADXIFS"];
		var irs = self.adxirs || self.ctx.values["ADXIRS"];
		var ium = _ium[self.adxium || self.ctx.values["ADXIUM"]];
		var fium = _fium[ium];

		self.mda = 2;

		// tool variables
		var curr = self.offset;
		var cache = new Buffer(20);
		var lines;
		var str = "";
		var bck;

		// algo 
		var len = fs.read(self.fd, cache, 0, cache.length, curr, ~_);

		while (len > 0) {
			bck = (ium === "utf8") ? UT8Backward(cache) : 0;

			str += fium(cache, cache.length - bck);
			lines = str.split(irs);
			if (lines.length > 1)
				break;
			else {
				curr += (len - bck);
				len = fs.read(self.fd, cache, 0, cache.length, curr, ~_);
			}
		}
		// end

		self.offset += (byteLength(lines[0]) + 1);
		return (lines[0].split(ifs));
	},

	x3get: function(_) {
		self.mda = 1;
	},

	x3put: function(_) {
		self.mda = 1;
	},

	x3close: function(_) {
		var self = this;
		try {
			fs.close(self.fd, _);
		} catch (ex) {
			throw new X3Error(20, ex.message);
		}
	}
});

exports.File = File;