"use strict";

var fs = require('streamline-fs');
var X3path = require('./x3path').X3path;
var File = require('./files').File;
var util = require('./util');
var variables = require('./variables');
var arrays = require('./arrays');
var X3Error = require('./errors').X3Error;
var config = require("etna-util/lib/nodeconfig").config.etna;
var glob = require('streamline/lib/globals');
var fs = require('streamline-fs');
/* 
 * Sequential I/0
 */

exports.functions = {
	DIR$: {
		count: 0,
		fn: function() {
			return process.cwd();
		}
	},
	FILINFO: {
		count: 2,
		async: true,
		fn: function(_, path, what) {
			var frame = glob.context.x3frame;
			var stat;

			var xp = new X3path(_, frame.context.superv, path, "", "", "", "");
			if (xp === "") throw new X3Error(20, "");

			try {
				stat = fs.stat(xp.toString(_), _);
			} catch (ex) {
				if (ex.code === 'ENOENT') return -20;
				else throw ex;
			}
			//console.log("FILINFO: " + path + ": " + require("sys").inspect(stat));
			switch (what) {
				case 0:
					// mode 
					return stat.mode;
				case 1:
					return stat.ino;
				case 2:
					// device id, 
				case 3:
					// device id, char or block mode (who cares?)
					return stat.dev;
				case 4:
					// link number
					return stat.nlink;
				case 5:
					return stat.uid;
				case 6:
					return stat.gid;
				case 7:
					return stat.size;
				case 8:
					return stat.uid;
				case 9:
					return stat.atime;
				case 10:
					return stat.mtime;
				case 11:
					return stat.ctime;
				default:
					// cannot find 
					throw new X3Error(10, "bad filinfo action: " + what);
			}
		},
	},
	FILCOM: {
		//count: 6,
		// some args are optional (for ex only 4 in AVOLUME_CSTD line 665)
		fn: function(folder, name, ext, app, drive, host) {
			util.checkString(folder);
			util.checkString(name);
			util.checkString(ext);
			app = app || "test";
			return config.tmpRoot + "/" + app + (folder ? "/" + folder : "") + "/" + name + (ext ? "." + ext : "");
		}
	},
	FILPATH: {
		async: true,
		count: -1,
		fn: function(_, dir, nam, ext, app, vol, hst) {
			var frame = glob.context.x3frame;

			// app, vol and hst are optionnals
			if (!util.x3IsString(dir)) throw util.badOperand(dir);
			if (!util.x3IsString(nam)) throw util.badOperand(nam);
			if (!util.x3IsString(ext)) throw util.badOperand(ext);
			if (app && (!util.x3IsString(app))) throw util.badOperand(app);
			if (vol && (!util.x3IsString(vol))) throw util.badOperand(vol);
			if (hst && (!util.x3IsString(hst))) throw util.badOperand(hst);

			// see later
			var xp = new X3path(_, frame.context.superv, dir, nam, ext, app || "", vol || "", hst || "");
			return xp.toString(_);
		}
	},
	DELFILE: {
		async: true,
		count: 1,
		fn: function(_, name) {
			var frame = glob.context.x3frame;
			if (!util.x3IsString(name)) throw util.badOperand(name);

			var xp = new X3path(_, frame.context.superv, name, "", "", "", "");

			try {
				fs.unlink(xp.toString(_), _);
				return 0;
			} catch (ex) {
				return -20;
			}

		}
	},
	RENAMEFILE: {
		async: true,
		count: 2,
		fn: function(_, oldf, newf) {
			var frame = glob.context.x3frame;
			if (!util.x3IsString(oldf)) throw util.badOperand(oldf);
			if (!util.x3IsString(newf)) throw util.badOperand(newf);

			var xpo = new X3path(_, frame.context.superv, oldf, "", "", "", "");
			var xpn = new X3path(_, frame.context.superv, newf, "", "", "", "");

			try {
				fs.rename(xpo.toString(_), xpn.toString(_), _);
				return 0;
			} catch (ex) {
				return -20;
			}
		}
	}
};

function findFile(frame, abbrev) {
	var file = frame.context.files[abbrev];
	if (!file) throw new X3Error(7, "Sequential file abbrev not found: " + abbrev);
	return file;
}
exports.instructions = {
	OPEN: function(abbrev, name, mode, seek) {
		seek = seek || util.instructions.C(0);
		return function open$do(_) {
			var frame = glob.context.x3frame;
			var nameVal = name(_);
			var seekVal = seek(_);

			var xp = new X3path(_, frame.context.superv, nameVal, "", "", "", "");
			var fl = new File(frame.context.sys);

			fl.x3open(_, xp, seekVal, mode);

			frame.context.files[abbrev] = fl;
		};
	},
	CLOSE: function(abbrev) {
		return function close$do(_) {
			var frame = glob.context.x3frame;
			var file = findFile(frame, abbrev);

			file.x3close(_);
		};
	},
	IOMODE: function(abbrev, mode, value) {
		mode = mode.toLowerCase();
		return function iomode$do(_) {
			var frame = glob.context.x3frame;
			var file = findFile(frame, abbrev);
			var val = value(_);

			file[mode] = (val === "" || val === 0) ? undefined : val;
		};
	},
	SEEK: function(abbrev, mode, direction, value) {
		return function seek$do(_) {
			var frame = glob.context.x3frame;
			var file = findFile(frame, abbrev);
			var val = value(_);

			file.x3seek(_, mode, direction, val);
		};
	},
	WRSEQ: function(abbrev, exps) {
		return function wrseq$do(_) {
			var frame = glob.context.x3frame;
			var file = findFile(frame, abbrev);
			var vals = exps(_);

			if (vals[vals.length - 1])
				var newline = 1;
			else {
				vals.pop();
				var newline = 0;
			}
			return file.x3write(_, vals, newline);
		};
	},
	RDSEQ: function(abbrev, vars) {
		return function rdseq$do(_) {
			var frame = glob.context.x3frame;
			var file = findFile(frame, abbrev);
			var f, s, i = 0,
				index = 0;

			// read the line
			var vals = file.x3read(_);

			// loop on all variables and values
			while (vars[i]) {
				f = vars[i++];
				s = f(_);

				//console.log(s);
				if (Array.isArray(s)) {
					var fidx;

					for (var j = s[3]; j < s[4]; j++) {
						fidx = arrays.instructions.INDEX(vars[0], [util.instructions.C(j)]);
						fidx(_, true, vals[index++]);
						if (index >= vals.length) break;
					}
				} else {
					//console.log("set value "+vals[index++]);
					f(_, variables.vOperations.SET, vals[index++], 0);
					if (index >= vals.length) break;
				}
			}
		};
	}
};