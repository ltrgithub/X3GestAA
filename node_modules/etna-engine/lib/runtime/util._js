var errors = require('./errors');
var X3Error = errors.X3Error;
var tdouble = require('./tdouble') ;
var tinteger = require('./tinteger') ;
var tstring = require('./tstring') ;
var tdatetime = require('./tdatetime') ;
var bcd = require('./bcd') ;
var basedate = require('syracuse-core/lib/types/date');
var Blbfile = require('./tblbfile').Blbfile ;
/* 
 * Line numbers
 */
// _sourceLoc and _sourceFile are set at 'require' time
// _sourceLoc is incremented as we load statements
var _sourceFile = null;
var _moduleName = null;
exports.sourceLoc = {
	module: _moduleName,
	line: 0,
};
var SP = ' '.charCodeAt(0);

exports.x3Trim = function( s, opt ) {
    
    var trimFuncs = [function( ) { // left
      var i, len = s.length;
      for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
      return i === 0 ? s : s.substring(i);
    }, function( ) { // right
      var i, len = s.length;
      for (i = len - 1; i >= 0 && s.charCodeAt(i) === SP; i--);
      return i === len ? s : s.substring(0, i + 1);
    }, function( ) { // both
      var i, j, len = s.length;
      for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
      for (j = len - 1; j >= i && s.charCodeAt(j) === SP; j--);
      return s.substring(i, j + 1);
    }, function( ) { // token
      var i, j, len = s.length;
      for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
      for (j = i; j < len && s.charCodeAt(j) !== SP; j++);
      return s.substring(i, j);
    }, function( ) { // all
      return s.replace(/ /g, '');
    }, function( ) { // adjacent
      return s.replace(/[ ]+/g, ' ');
    }];

    if (!trimFuncs[opt]) return s ;

    return trimFuncs[opt]( ) ;
}

exports.badOperand = function(x) {
	//return new X3Error(10, "bad operand" + x? (": "+x + " (type " + x.constructor.name + ")"):"");
	return new X3Error(10, "bad operand" + (x? (": "+x + " (type " + x.constructor.name + ")"):""));
};

exports.badArgumentType = function(x) {
	return new X3Error(10, "bad argument: " + x + " (type " + x.constructor.name + ")");
};

exports.checkNumber = function(x) {
	if (!x.x3IsNumeric || !x.x3IsNumeric()) throw exports.badArgumentType(x);
};

exports.checkInteger = function(x) {
	if (!exports.x3IsInteger(x)) throw exports.badArgumentType(x);
};

exports.checkString = function(x) {
	if (!exports.x3IsString(x)) throw exports.badArgumentType(x);
};

exports.checkArray = function(x) {
	if (!Array.isArray(x)) throw exports.badArgumentType(x);
};

exports.checkMonoArray = function(x) {
	if (!Array.isArray(x)) throw exports.badArgumentType(x);
	if (x[0] !== 1) throw new X3Error(55, "bad array dimension: " + x[0]);
};

exports.checkNotZero = function(x) {
	if (!x.x3IsZero || !x.x3IsZero( )) throw new X3Error(53);
};

exports.x3IsDouble = function(val) {
	return val instanceof tdouble.Double ;
}

exports.x3IsInteger = function(x) {
	return typeof x === 'number';
};

exports.x3IsString = function(x) {
	return typeof x === 'string';
}

exports.x3IsBCD = function(x) {
	return bcd.isBCD(x) ;
};

exports.x3IsDate = function(x) {
	return basedate.isDate(x) ;
};

exports.x3IsDatetime = function(x) {
	return x instanceof tdatetime.Datetime ;
};

exports.x3IsBlbfile = function(x) {
	return x instanceof Blbfile ;
};

exports.instructions = {
	C: function(x) {
		var fn = function c$do(_) {
			//console.log(x);
			return x;
		};
		fn.value = x;
		return fn;
	},
	A: function(items, forget) {
		return function a$do(_) {
			var results = !forget && [];
			for (var i = 0; i < items.length; i++) {
				var item = items[i];
				var v = item.value !== undefined ? item.value : item(_);
				results && results.push(v);
			}
			return results;
		};
	},
	NIY: function(node) {
		return function niy$do(_) {
			throw new X3Error(33, "NIY: " + (node && node.tag));
		};
	},
	BEGIN: function(mod) {
		_sourceFile = mod.filename.replace(/\.js$/, ".src");
		_moduleName = mod.filename.replace(/[\/\/]([^\/\/]*).js$/, "$1");
	},
	NL: function(delta) {
		exports.sourceLoc = {
			file: _sourceFile,
			line: delta ? exports.sourceLoc.line + delta : 1
		};
		return null;
	},
};