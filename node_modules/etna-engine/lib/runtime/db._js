"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var array = require('./arrays');
var dates = require('./dates');
var dbevaluate = require('./dbevaluate');
var DBTable = require('./dbtable').DBTable;
var GClass = require('./gclass').GClass;
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');
var tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");

exports.functions = {
	FILECLA: {
		count: 0
	},
	FILETYP: {
		count: 0
	},
	CLANBS: {
		count: 2,
		fn: function(name, kind) {
			// kind is 1 or 2 to indicate existing or allocated - ignore for now
			var context = this;
			var cla = context.tables[name];
			if (!cla) throw new X3Error(7, "invalid class: " + name);
			switch (kind) {
				case 1:
					return cla.types.length;
				case 2:
					return cla.values.length;
				default:
					throw new X3Error(10, "invalid value for clanbs parameter: " + typeof arg);
			}
		}
	},
	CLASIZ: {
		count: 2,
		fn: function(classe, exp_buf) {
			return 16;
		}
	},
	CLANAM: {
		count: 1
	},
	CLAVAR: {
		count: 1
	},
	CLALEV: {
		count: 1,
		fn: function(classe) {
			return 0;
		}
	},
};

function concat(a1, a2) {
	return (a1 && a2) ? a1.concat(a2) : (a1 || a2);
}

function genSql(_, exp) {
	var frame = glob.context.x3frame;
	var driver = frame.context.superv.sqlDriver;

	var val = typeof exp === 'function' ? exp(_) : exp;
	if (val && val.sql) return val;

	//special case
	if (Array.isArray(val)) {
		var t = val[2];
		var r = "";
		if (val[1] > 1)
			throw new X3Error(26, "More than 1 dimension is not supported");
		var min = (val[5]) ? val[3] - val[5] : 0;
		var max = (val[6]) ? val[3] + val[6] - val[5] - 1 : val[4] - val[3];

		var r = {
			sql: "",
			type: typeof t[min],
			constants: [],
			func: [],
			isConstant: true,
		};

		for (var i = min; i <= max; i++) {
			if (t[i]) {
				r.constants.push(t[i]);
				r.func.push(util.instructions.C(t[i]));
				r.sql += (i > min) ? ',' : '';
				r.sql += "@?";
			}
		}
		return r;
	} else return {
		sql: "@?",
		type: typeof val,
		constants: [val.x3ToSql(driver) || val],
		isConstant: true,
		func: util.instructions.C(val)
	};
}

function binaryOp(op, sqlOp, type, numOp, numType) {
	return function(op1, op2) {
		return function binaryOp$do(_) {
			var frame = glob.context.x3frame;
			var ctx = frame.whereContext;
			if (!frame.tryingSql) return operators.instructions[op](op1, op2)(_);
			var v1 = genSql(_, op1);
			var v2 = genSql(_, op2);
			var unary = false;

			if (v1.tooComplex || v2.tooComplex) return {
				sql: "(1 = 1)",
				tooComplex: true,
				func: binaryOp(op, sqlOp, type, numOp, numType)(v1.func, v2.func),
				constants: [],
			};

			// the killing death hack for pat and find			
			if (v1.field && (["PAT", "FIND"].indexOf(v1.field) >= 0)) {
				var v = v2.constants[0];
				if (!(
					((v === 0) && (op === "NE")) ||
					((v !== 0) && (op === "EQ")) ||
					((v > 0) && (op === "GE")) ||
					((v >= 0) && (op === "GT")) ||
					((v < 0) && (op === "LE")) ||
					((v <= 0) && (op === "LT"))
				)) {
					ctx.revert = true;
					var v1 = genSql(_, op1);
					ctx.revert = false;
				}
				unary = true;
			}

			if (numOp && v1.type === v2.type && v1.type === "number") sqlOp = numOp, type = numType;
			var sql;
			if (sqlOp === "CONCAT") {
				if (numOp === '-') {
					v1.sql = "RTRIM(" + v1.sql + "),' '";
					v2.sql = "' ',LTRIM(" + v2.sql + ")";
				}
				sql = "CONCAT(" + v1.sql + "," + v2.sql + ")";
			} else {
				sql = (unary) ? "(" + v1.sql + ")" : "(" + v1.sql + " " + sqlOp + " " + v2.sql + ")";
			}
			var vals = (unary) ? (v1.constants || []) : (v1.constants || []).concat(v2.constants || []);
			return {
				sql: sql,
				type: type,
				constants: vals,
				tooComplex: false,
				func: binaryOp(op, sqlOp, type, numOp, numType)(v1.func, v2.func)
			};
		};
	};
}

function closeFile(abbrevs, local) {
	var frame = glob.context.x3frame;
	abbrevs.forEach(function(abbrev) {
		if (frame.context.tables[abbrev] && (frame.context.tables[abbrev].local >= local)) {
			(frame.context.tables[abbrev].sisters || []).forEach(function(absister) {
				delete frame.context.tables[absister];
				delete frame.context.gclass[absister];
				if (absister === frame.abbrev) frame.abbrev = null;
			});
			delete frame.context.tables[abbrev];
			delete frame.context.gclass[abbrev];
			if (abbrev === frame.abbrev) frame.abbrev = null;
		}
	});
}

function rowIn(row, descs) {
	return descs.reduce(function(obj, desc) {
		obj[desc.name] = desc.type.fromSql(row[desc.name]); // for now!
		return obj;
	}, {});
}

function sqlFn(name, type) {
	return function() {
		var thesql = name + "(" + Array.prototype.map.call(arguments, function(arg) {
			return arg.sql;
		}).join(',') + ")";
		return {
			sql: thesql,
			type: type,
			tooComplex: false
		};
	};
}

function tooComplex() {
	return {
		sql: "(1 = 1)",
		tooComplex: true,
	};
}

function defVal(type) {
	switch (type) {
		case 'string':
			return '';
		case 'number':
			return 0;
		case 'date':
			return null; //TODO : dates.ORIGIN;
		case 'binary':
			return null;
		default:
			throw new Error('unsupported column type: ' + type);
	}
}

var sqlCmpOps = {
	EQ: {
		op: '=',
		combine: 'and',
	},
	NE: {
		op: '<>',
		combine: 'or'
	},
	LT: {
		op: '<',
		combine: 'lexi'
	},
	LE: {
		op: '<=',
		combine: 'lexi'
	},
	GT: {
		op: '>',
		combine: 'lexi'
	},
	GE: {
		op: '>=',
		combine: 'lexi'
	},
};

var sqlFunctions = {
	// string functions
	LEN: sqlFn("LENGTH", "number"),
	//RIGHT$: sqlFn("RIGHT", "string"),
	//MID$: sqlFn("SUBSTRING", "string"),
	TOUPPER: sqlFn("UPPER", "string"),
	TOLOWER: sqlFn("LOWER", "string"),
	CHR$: sqlFn("CHAR", "string"),
	LEFT$: function(arg, len) {
		var frame = glob.context.x3frame;
		var driver = frame.context.superv.sqlDriver;

		return {
			sql: driver.subString(arg.sql, "1", len.sql),
			type: "string",
			tooComplex: false
		};
	},
	MID$: function(arg, first, len) {
		var frame = glob.context.x3frame;
		var driver = frame.context.superv.sqlDriver;

		return {
			sql: driver.subString(arg.sql, first.sql, len.sql),
			type: "string",
			tooComplex: false
		};
	},
	/*
	// have to repeat twice one paramter, can t do it
	SEG$: function(arg, first, last) {
		var frame = glob.context.x3frame;
		var driver = frame.context.superv.sqlDriver;

		return {
			sql: driver.subString(arg.sql, first.sql, len.sql),
			sql: "SUBSTRING(" + arg.sql + "," + first.sql + "," + last.sql + " + 1 - " + first.sql + ")",
			type: "string",
			tooComplex: false
		};
	},
	*/
	CTRANS: function(arg) {
		//if (arguments.length > 1) throw tooComplex();
		return {
			sql: "CONVERT(" + arg.sql + " USING ASCII)",
			type: "string",
			tooComplex: false,
		};
	},
	PAT: function(str, pat, revert) {
		var not = (revert) ? " NOT" : "";
		return {
			sql: "(" + str.sql + not + " LIKE '" + pat.constants[0].replace(/%/g, '%%').replace(/\*/g, '%' + "'") + ")",
			type: "string",
			constants: [],
			tooComplex: false,
		};
	},

	// Numeric functions
	ABS: sqlFn("ABS", "number"),
	MOD: sqlFn("MOD", "number"),
	// investigate neg values
	ARR2: function(arg) {
		return {
			sql: "ROUND(" + arg.sql + ",2)",
			type: "number",
			tooComplex: false,
		};
	},


	ARR: sqlFn("ROUND", "number"),
	FIX: sqlFn("TRUNCATE", "number"),
	INT: sqlFn("FLOOR", "number"),
	SQR: sqlFn("SQRT", "number"),
	COS: sqlFn("COS", "number"),
	SIN: sqlFn("SIN", "number"),
	TAN: sqlFn("TAN", "number"),
	ACOS: sqlFn("ACOS", "number"),
	ASIN: sqlFn("ASIN", "number"),
	ATAN: sqlFn("ATAN", "number"),
	PI: sqlFn("PI", "number"),
	EXP: sqlFn("EXP", "number"),
	LN: sqlFn("LOG", "number"),
	LOG: sqlFn("LOG10", "number"),

	// Find
	FIND: function(arg) {
		var not = '';
		var vals = Array.prototype.slice.call(arguments, 1);
		if (!(vals[vals.length - 1].sql)) {
			vals.pop();
			not = " NOT";
		}
		return {
			sql: "(" + arg.sql + not + " IN (" + vals.map(function(val) {
				return val.sql;
			}).join(',') + "))",
			type: "number",
		};
	}

	// see later about date functions
};


var sqlFindPat = {
	FIND: function(_, args, ctx) {
		var sqlFunc = sqlFunctions["FIND"];
		var frame = glob.context.x3frame;
		if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_);

		var cst = true;
		var params = [];
		var consts = [];

		var argSqls = args.map_(_, function(_, arg) {
			var s = genSql(_, arg, ctx);
			if (!s.isConstant) cst = false;
			if (Array.isArray(s.func)) params = params.concat(s.func);
			else params.push(s.func);
			consts = consts.concat(s.constants || []);
			return s;
		});

		if (cst) return flowControl.instructions.F(field, args)(_);
		else {
			if (ctx.revert) {
				argSqls.push(true);
				ctx.revert = false;
			}
			var r = sqlFunc.apply(this, argSqls);
			r.func = exports.instructions.SQLF("FIND", params);
			r.field = "FIND";
			if (!(r.constants)) r.constants = consts;
			return r;
		}
	},

	PAT: function(_, args, ctx) {
		var sqlFunc = sqlFunctions["PAT"];
		var frame = glob.context.x3frame;
		if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_);

		var cst = true;
		var params = [];
		var consts = [];

		var argSqls = args.map_(_, function(_, arg) {
			var s = genSql(_, arg, ctx);
			if (!s.isConstant) cst = false;
			params.push(s.func);
			consts = consts.concat(s.constants || []);
			return s;
		});

		if (cst) return flowControl.instructions.F(field, args)(_);
		else {
			if (ctx.revert) {
				argSqls.push(true);
				ctx.revert = false;
			}
			var r = sqlFunc.apply(this, argSqls);
			r.func = exports.instructions.SQLF("PAT", params);
			r.field = "PAT";
			if (!(r.constants)) r.constants = consts;
			return r;
		}
	}
};



function findTable(frame, abbrev) {
	// use frame's default abbrev by default
	var table = frame.context.tables[abbrev || frame.abbrev];
	if (!table) throw new X3Error(7, "bad table abbrev: " + abbrev);
	return table;
}

function keyAnalysis(_, cmd, key, op, vals) {

	var frame = glob.context.x3frame;
	var session = glob.context.x3session;
	var driver = frame.context.superv.sqlDriver;
	var k = key(_);

	if (k.indices && k.indices.length > 1) {
		throw new X3Error(26, "Illegal number of indice");
	}

	//var vals = avalues(_);
	var table = findTable(frame, k.abbrev);
	var nkey = table.findKey(k.name);
	var kln = (k.indices && k.indices[0]) || nkey.items.length;
	var direction = 1;

	var keyw;
	var wkey;

	op = op || 'CURR';
	switch (op) {
		case 'CURR':
			if (cmd !== "wdelete") {
				wkey = {};
				if (!table.values["ROWID"]) throw new X3Error(26, "No Current rowid");

				wkey = {
					rowid: true,
					sql: table.abbrev + ".ROWID = " + driver.param(0),
					constants: [table.values["ROWID"]],
					tooComplex: false,
					isConstant: false,
				};
			}
			break;
		case 'GT':
		case 'GE':
		case 'LT':
		case 'LE':
		case 'EQ':
			if (vals.length === 0) vals = table.getKeyValues(_, nkey, kln);
			var keyw = exports.instructions.SQLKEY(k.name, op, ((k.indice) ? exports.instructions.A(util.instructions.C(k.indices)) : util.instructions.C(null)), vals);
			break;
		case 'FIRST':
		case 'LAST':
		case 'PREV':
		case 'NEXT':
		case 'NXT':
			throw new X3Error(26, "Deprecated functionnnality");
			break;
		default:
			throw new X3Error(26, "Illegal read operator");
	}
	if (keyw) {
		var ctx = {};
		ctx.tables = [table.abbrev];
		wkey = exports.instructions.WHERE([keyw])(_, ctx);
	}

	return {
		table: table,
		nkey: nkey,
		wkey: wkey,
		kln: kln,
	};
}


function identity(x) {
	return x;
}

exports.instructions = {
	NBRECORD: function(abbrev) {
		return function nbrecord$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);

			var qry = "Select Count(*) as A$RESULT_0 From " + table.desc.name + " A";

			var res = frame.context.superv.executeSql(_, qry, [], [3], true);
			return res[0]["A"].RESULT;
		};
	},
	UNIQID: function(abbrev) {
		return function uniqid$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);
			var driver = frame.context.superv.sqlDriver;
			var qry = driver.uniqid(table.desc.name);
			var res = frame.context.superv.executeSql(_, qry, [], [3], true);

			return res[0]["A"].RESULT;
		};
	},
	ROWCOUNT: function(abbrev) {
		return function rowcount$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;
			var table = findTable(frame, abbrev);

			return table.x3Rowcount(_, session.dbConnection);
		};
	},

	KEY: function(letter, abbrev, name, indices) {
		return function key$do(_) {
			return {
				letter: letter,
				abbrev: abbrev,
				name: name,
				indices: indices && indices.map_(_, function(_, exp) {
					return exp(_);
				})
			};
		};
	},
	FILESQL: function(abbrev, name, where, order) {
		return function file$do(_) {
			var frame = glob.context.x3frame;
			var driver = frame.context.superv.sqlDriver;
			var nameVal = name(_);
			var desc = frame.context.superv.load(_, 'Table', nameVal);
			if (!desc) throw new X3Error(7, "unknown table or unsupport FILE syntax: " + nameVal);
			var abb = abbrev || desc.abbrev;
			var ctx = {};
			ctx.tables = [abb];


			// init keys
			var tkeys = Object.keys(desc.indexes).map(function(name) {
				var idx = desc.indexes[name];
				var sql = "";
				var funcs = [];
				var dir = [];
				var items = [];
				for (var i = 0; i < idx.columns.length; i++) {
					dir.push(idx.direction[i]);
					funcs.push(exports.instructions.SQLCV('F', abb, idx.columns[i].name));
					if (i > 0) sql += ", ";
					sql += idx.columns[i].sqlNames(abb + ".") + ((idx.direction < 0) ? " Desc" : "");
					items.push(idx.columns[i].sqlNames(abb + "."));
				}
				return {
					name: desc.indexes[name].name,
					unique: desc.indexes[name].unique,
					hidden: false,
					constants: [],
					func: funcs,
					sql: sql,
					directions: dir,
					items: items,
					index: idx,
				};
			});

			// where
			var table = frame.context.tables[abb] = new DBTable(driver, abb, frame.context.superv, desc, tkeys, frame.stackLevel).init(_);
			frame.context.gclass[abb] = new GClass(table);
			table.where = where && where(_, ctx);

			// order by
			var newkey = order && order(_, ctx);
			if (newkey) {
				tkeys.forEach(function(ky) {
					ky.hidden = true;
				});
				table.currkey = tkeys.push(newkey) - 1;;
			}

			// init filter
			table.filter = {},

			// default table
			frame.abbrev = abb;
		};
	},
	CLOSEFILE: function(scope, abbrevs) {
		return function closefile$do(_) {
			closeFile(abbrevs, (scope === 'LOCAL') ? glob.context.x3frame.stackLevel : 0);
			/*
			var frame = glob.context.x3frame;
			abbrevs.forEach(function(abbrev) {
				if (frame.context.tables[abbrev] && (frame.context.tables[abbrev].local >= frame.stackLevel)) {
					(frame.context.tables[abbrev].sisters || []).forEach(function(absister) {
						delete frame.context.tables[absister];
						if (absister === frame.abbrev) frame.abbrev = null;
					});
					delete frame.context.tables[abbrev];
					if (abbrev === frame.abbrev) frame.abbrev = null;
				}
			});
*/
		};
	},
	LOGICCLOSE: function(scope, abbrev) {
		return function logicclose$do(_) {};
	},
	FILTER: function(abbrev, where, order) {
		return function filter$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);

			// delete old filter
			if (table.filter) {
				if (table.filter.key) {
					delete table.keys[table.filter.key];
					table.keys.forEach(function(ky) {
						ky.hidden = false;
					});
				}
				if (table.currkey === table.filter.key) table.currkey = 0;
				table.filter = {};
			}

			if ((!(where)) && (!(order))) return 0;

			// table in views
			var ctx = {};
			ctx.tables = [table.abbrev];
			if (table.joins) {
				table.joins.forEach(function(join) {
					ctx.tables.push(join.table.abbrev);
				});
			}

			var newkey = order && order(_, ctx);
			if (newkey) {
				table.keys.forEach(function(ky) {
					ky.hidden = true;
				});
				table.currkey = table.keys.push(newkey) - 1;
			}

			table.filter = {
				where: where && where(_, ctx),
				key: (newkey) ? table.currkey : undefined,
			};
		};
	},

	COLUMNS: function(abbrev, columns) {
		return function columns$do(_) {
			/*			var frame = glob.context.x3frame;
			var table = table(frame, abbrev);
			// columns is an array of [abbrev, field] pairs
			table.columns = columns;*/
		};
	},
	HINT: function(nohint, key) {
		return function hint$do(_) {

		};
	},
	LINKITEM: function(key, outer, values) {
		return function linkitem$do(_, ctx) {
			var frame = glob.context.x3frame;
			var k = key(_);
			var abv = k.abbrev || frame.abbrev;
			var table = findTable(frame, k.abbrev);
			var index = table.findIndex(k.name);
			var consts = [];

			ctx.tables.push(abv);

			if (table.master) throw new X3Error(26, "Alread linked");

			var sql = ((outer) ? " LEFT OUTER " : " ") + " JOIN " + table.desc.name + " " + k.abbrev //
			+ " ON " + values.map_(_, function(_, val, i) {
				frame.tryingSql = true;
				frame.whereContext = ctx;
				val = genSql(_, val);
				frame.tryingSql = false;
				frame.whereContext = undefined;

				if (val.tooComplex) throw new X3Error(26, "Unable to build the link because of comlexity");
				consts = consts.concat(val.constants || []);

				return index.columns[i].sqlNames(abv + ".") + " = " + val.sql;
			}).join(" AND ");

			return {
				table: table,
				sql: sql,
				constants: consts,
			};
		};
	},
	LINK: function(abbrev, as, joins, where, order) {
		return function link$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);
			var ctx = {};
			ctx.tables = [table.abbrev];
			if (table.master) throw new X3Error(26, "Link on a Link");
			if (frame.context.tables[as]) throw new X3Error(28, as);
			table.sisters = table.sisters || [];
			table.sisters.push(as);
			var lktable = frame.context.tables[as] = new DBTable(table, table.abbrev).init(_);

			lktable.joins = joins.map_(_, function(_, jitm) {
				return jitm(_, ctx);
			});


			lktable.filter = {};
			lktable.where = where && where(_, ctx);
			var newkey = order && order(_, ctx);
			if (newkey) {
				lktable.keys.forEach(function(ky) {
					ky.hidden = true;
				});
				lktable.currkey = table.keys.push(newkey) - 1;
			}
		};
	},
	READ: function(key, op, values, lock, hint) {
		var avalues = util.instructions.A(values);
		return function read$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;
			var vals = avalues(_);

			var ka = keyAnalysis(_, 'read', key, op, vals);

			frame.context.sys.values.FSTAT = ka.table.x3Read(_, ka.nkey, ka.kln, ka.wkey, lock, hint, session.dbConnection);
		};
	},
	WRITE: function(abbrev) {
		return function write$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);

			table.setCurrentLogin(frame.loginName || "USER");

			frame.context.sys.values.FSTAT = table.x3Write(_);
		};
	},
	REWRITE: function(key, op, values) {
		var avalues = util.instructions.A(values);
		return function rewrite$do(_) {
			var frame = glob.context.x3frame;
			var k = key(_);
			if (k.indices) throw new X3Error(26, "Key");
			var vals = avalues(_);
			var table = findTable(frame, k.abbrev);
			var driver = frame.context.superv.sqlDriver;
			var colNames = Object.keys(table.desc.columns);
			if (table.master) throw new X3Error(26, "The table is a link");
			if ((op !== 'EQ') && (op !== '')) throw new X3Error(26, "Illegal key operator");

			// key or rowid resolution
			// ----------------------------------------------------------
			var keyw;
			var wkey;
			if (k.name) {
				throw new X3Error(26, "Deprecated operation");

				// if we need to do it, we have to build a complete select for update and the rewrite behind
				var nkey = table.findKey(k.name);
				if (!nkey.unique) throw new X3Error(26, "Key has to be unique");
				if (values.length !== nkey.items.length) throw new X3Error(26, "Key has to be unique");

				var ctx = {};
				ctx.tables = [table.abbrev];

				if (vals.length === 0) vals = table.getKeyValues(_, nkey, kln);
				keyw = exports.instructions.SQLKEY(k.name, 'EQ', ((k.indice) ? exports.instructions.A(util.instructions.C(k.indices)) : util.instructions.C(null)), vals);
				wkey = exports.instructions.WHERE([keyw])(_, ctx);
			} else {
				wkey = {};
				if (!table.values["ROWID"]) throw new X3Error(26, "No Current rowid");

				wkey = {
					rowid: true,
					sql: "ROWID = @?",
					constants: [table.values["ROWID"]],
					tooComplex: false,
					isConstant: false,
				};
			}

			// build values tables assignation 
			// ----------------------------------------------------------
			var vassig = [];
			Object.keys(table.desc.columns).forEach(function(cname) {
				if (cname === "ROWID") return;
				if (Array.isArray(table.values[cname])) {
					var col = self.desc.columns[name];
					for (var i = 0; i < col.data.DIME; i++) {
						if (table.values[cname][i] !== undefined)
							vassig.push(table.values[cname][i].x3ToSql(driver));
						else {
							vassig.push(col.type.defaultValue().x3ToSql(driver));
						}
					}

				} else {
					tracer.debug && tracer.debug("Assig " + cname + ":" + table.values[cname]);
					vassig.push(table.values[cname].x3ToSql(driver));
				}
			});

			// guive the hand to the table for query and execution
			var fs = table.x3Rewrite(_, wkey, vassig);

			frame.context.sys.values.FSTAT = fs;
		};
	},
	DELETE: function(key, where, op, values) {
		var avalues = util.instructions.A(values);
		return function delete$do(_) {

			var frame = glob.context.x3frame;
			var session = glob.context.x3session;

			var vals = avalues(_);
			var ka = keyAnalysis(_, (where) ? "wdelete" : "kdelete", key, op, vals);
			//debugger;
			if (!session.dbConnection) throw new X3Error(26, "Try to delete whithout transaction");

			var rs = ka.table.x3Delete(_, ka.nkey, ka.wkey, where, session.dbConnection);

			if (rs < 0) {
				frame.context.sys.values.FSTAT = -rs;
				frame.context.sys.values.ADXDLREC = 0;
			} else {
				frame.context.sys.values.FSTAT = 0;
				frame.context.sys.values.ADXDLREC = rs;
			}

		};
	},
	ASSIGNUPDATE: function(lhs, rhs) {
		return function assignupdate$do(_, ctx) {
			var frame = glob.context.x3frame;

			frame.tryingSql = true;
			frame.whereContext = ctx;

			var mbl = genSql(_, lhs);
			var mbr = genSql(_, rhs);

			frame.tryingSql = false;
			frame.whereContext = undefined;

			if (mbl.tooComplex || mbr.tooComplex) throw new X3Error(26, "Invalid assignment");

			return {
				sql: mbl.sql + " = " + mbr.sql,
				constants: mbr.constants,
			};
		};
	},
	UPDATE: function(abbrev, where, assign) {
		return function update$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;

			var table = findTable(frame, abbrev);

			var ctx = {};

			// compute the clause
			ctx.tables = [table.abbrev];
			ctx.noabbrev = true;

			// compute assign clause
			var consts = [];
			var asssql = "" + assign.map_(_, function(_, ass) {
				var asg = ass(_, ctx);
				consts = consts.concat(asg.constants || []);
				return asg.sql;
			}).join(",");

			var rs = table.x3Update(_, where, asssql, consts, session.dbConnection);

			if (rs < 0) {
				frame.context.sys.values.FSTAT = -rs;
				frame.context.sys.values.ADXUPREC = 0;
			} else {
				frame.context.sys.values.FSTAT = 0;
				frame.context.sys.values.ADXUPREC = rs;
			}
		};
	},
	TRBEGIN: function(abbrevs) {
		//var aabrevs = util.instructions.A(abbrevs);
		return function trbegin$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;
			if ((session.dbConnection !== null) && (session.dbConnection !== undefined)) throw new X3Error(49, "");

			session.dbConnection = frame.context.superv.sqlDriver.driverPopConnection(_);

			frame.context.superv.sqlDriver.beginTransaction(_, session.dbConnection);
		};
	},
	COMMIT: function() {
		return function commit$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;

			if (!session.dbConnection) throw new X3Error(48, "");

			frame.context.superv.sqlDriver.commitTransaction(_, session.dbConnection);
			frame.context.superv.sqlDriver.driverPushConnection(session.dbConnection);
			session.dbConnection = null;
		};
	},
	ROLLBACK: function() {
		return function rollback$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;

			if (!session.dbConnection) throw new X3Error(48, "");

			frame.context.superv.sqlDriver.rollbackTransaction(_, session.dbConnection);
			frame.context.superv.sqlDriver.driverPushConnection(session.dbConnection);
			session.dbConnection = null;
			//frame.context.superv.executeSql(_, "rollback");
		};
	},
	FORF: function(key, hint, lock, where, p, end, block) {
		return function forf$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;
			var k = key(_);
			var klvl = k && k.indices && k.indices[0];
			var table = findTable(frame, k.abbrev);
			var ky = table.findKey(k.name);
			var rec = {};
			var cf = table.x3GetCurrentFor();
			var kvalues;

			if (cf && cf.klvl === undefined) throw new X3Error(26, "Bad nested loop");

			if (!cf) {
				cf = table.x3OpenFor(_, ky, klvl, hint, lock, where, session.dbConnection);
				rec = cf.x3GetRecord(_);
				if (klvl) {
					cf.klvl = klvl;
					kvalues = table.getKeyValues(_, ky, klvl);
				}
			} else {
				if (ky.name !== cf.key.name) throw new X3Error(26, "Inconsitent nested loop key");

				cf.level++;
				if (klvl) cf.klvl = klvl;
				kvalues = table.getKeyValues(_, ky, klvl || cf.klvl);
			}

			// loop
			var level = ++frame.loopLevel;
			var exit = false;
			while (frame.loopLevel === level) {
				if (rec) {
					// execution du block
					block(_);

					//next (did you take pills ?)
					if ((!klvl) && (!(cf.klvl))) {
						// classic for
						rec = cf.x3GetRecord(_);
					} else if (klvl && cf.klvl) {
						// nested loop part
						while ((rec) && (table.keyCompare(_, ky, kvalues) === 0)) {
							rec = cf.x3GetRecord(_);
						}
						if (rec) {
							kvalues = table.getKeyValues(_, ky, klvl);
						}
					} else {
						// nested loop final
						rec = cf.x3GetRecord(_, true);
						if (rec && table.keyCompare(_, ky, kvalues) < 0) {
							cf.x3DiscardCurrent();
							exit = true;
						} else cf.x3FreeLast();
					}
				} else {
					frame.loopLevel = level - 1;
				}

				// special exit loop
				if (exit) {
					frame.loopLevel = level - 1;
					break;
				}
			}
			if (frame.loopLevel === level - 1) {
				if (cf.level === 0) table.x3CloseFor();
				else cf.level--;
				p[end](_);
			}
		};
	},
	WHERE: function(wheres) {
		return function(_, ctx) {
			var frame = glob.context.x3frame;
			var sqls = [];
			var exps = [];
			var funcs = [];
			var pe = false;

			wheres.forEach_(_, function(_, exp) {
				frame.tryingSql = true;
				frame.whereContext = ctx;

				var r = genSql(_, exp);
				sqls.push(r.sql);
				exps = exps.concat(r.constants || []);
				if (r.tooComplex) pe = true;
				funcs.push(r.func);

				frame.tryingSql = false;
				frame.whereContext = undefined;
			});

			return {
				sql: sqls.join(" AND "),
				constants: exps,
				postEvaluation: pe,
				func: exports.instructions.WHERE2(funcs)
			};
		};
	},
	WHERE2: function(wheres) {
		return function(_) {
			var frame = glob.context.x3frame;
			var res = [];

			wheres.forEach_(_, function(_, exp) {
				var r = exp(_);
				res.push(r);
			});
			return res;
		};
	},
	ORDERITEM: function(exp, dir) {
		return function(_, ctx) {
			var frame = glob.context.x3frame;
			frame.tryingSql = true;
			frame.whereContext = ctx;
			var val = genSql(_, exp);
			var sql = val.sql + ((dir === "-") ? " Desc" : "");
			frame.tryingSql = false;
			frame.whereContext = undefined;

			return {
				sql: sql,
				isConstant: val.isConstant,
				constants: val.constants,
				func: val.func,
				item: val.sql,
				dir: ((dir === "-") ? -1 : 1),
			};
		};
	},
	ORDER: function(keyName, by, withExp) {
		return function(_, ctx) {
			var items = by;
			if (withExp) {
				//todo.............
				items = withExp(_).split(';').map(function(s) {
					var pair = s.split(' ');
					return (pair[1] && pair[1].toLowerCase() === 'desc' ? '-' : '+') + pair[0];
				});
			} else {
				var consts = [];
				var funcs = [];
				var dir = [];
				var items = [];
				var sql = "" + by.map_(_, function(_, kitem) {
					var sk = kitem(_, ctx);
					consts = consts.concat(sk.constants || []);
					funcs.push(sk.func);
					dir.push(sk.dir);
					items.push(sk.item);
					return sk.sql;
				}).join(",");
			}
			return {
				name: keyName,
				sql: sql,
				hidden: false,
				unique: false,
				constants: consts,
				func: funcs,
				directions: dir,
				items: items,
			};
		};
	},
	SQLV: function(field) {
		return function sqlv$do(_) {
			var frame = glob.context.x3frame;
			var ctx = frame.whereContext;

			if (!frame.tryingSql) return variables.instructions.V(field)(_);
			//throw new X3Error(26, "NIY");
			var tables = frame.context.tables;
			var abbrevs = ctx.tables; //Object.keys(tables);

			var dicts = frame.dicts;
			for (var j = 0, len = dicts.length; j < len; j++) {
				var dict = dicts[j];
				if (dict !== tables) {
					if (dict.values[field] !== undefined) {
						return variables.instructions.V(field)(_);
					}
				}
			}
			for (var i = 0; i < abbrevs.length; i++) {
				var abbrev = abbrevs[i];
				var abv = (ctx.noabbrev) ? "" : (abbrev + '.');
				var table = tables[abbrev];

				if (table.values && table.values[field] !== undefined) return {
					sql: abv + field + '_0',
					type: table.types[field],
					func: exports.instructions.SQLCV("F", abbrev, field),
					tooComplex: false,
				};
			}
			throw new X3Error(6, field);
		};
	},
	SQLINDEX: function(field, args) {
		var aargs = util.instructions.A(args);
		return function sqlindex$do(_) {
			var frame = glob.context.x3frame;
			var driver = frame.context.superv.sqlDriver;

			var ctx = frame.whereContext;

			if (!frame.tryingSql) return array.instructions.INDEX(field, args);
			var f = genSql(_, field);
			var i = aargs(_);

			if (f.isConstant) {
				var tryingSql = frame.tryingSql;
				frame.tryingSql = false;
				var val = array.instructions.INDEX(field, args)(_);
				frame.tryingSql = tryingSql;
				return {
					sql: "@?",
					type: typeof val,
					constants: [val.x3ToSql(driver) || val],
					isConstant: true,
					func: util.instructions.C(val)
				};
			}

			return {
				sql: f.sql.replace("_0", "_" + i),
				type: f.type,
				func: exports.instructions.SQLINDEX(field, args),
				tooComplex: false,
			};

		};
	},
	SQLCV: function(letter, abbrev, field) {
		return function sqlcv$do(_) {
			var frame = glob.context.x3frame;
			var ctx = frame.whereContext;
			//console.log("Letter : " + letter + " abbrev:" + abbrev + " field:" + field);
			if (!frame.tryingSql || letter === 'L' || letter === 'V' || letter === 'S') return variables.instructions.CV(letter, abbrev, field)(_);
			if (abbrev) {
				if (ctx.tables.indexOf(abbrev) >= 0) {
					var abv = (ctx.noabbrev) ? "" : (abbrev + '.');
					var table = frame.context.tables[abbrev];
					var col = table && table.desc && table.desc.columns[field];
					return {
						sql: abv + field + '_0',
						type: col && col.type,
						func: exports.instructions.SQLCV(letter, abbrev, field),
						tooComplex: false,
					};
				} else
					return variables.instructions.CV(letter, abbrev, field)(_);
			} else {
				for (var i = 0; i < ctx.tables.length; i++) {
					var table = frame.context.tables[ctx.tables[i]];
					var abv = (ctx.noabbrev) ? "" : (abbrev + '.');

					if (table.desc.columns[field]) {
						var col = table.desc.columns[field];
						return {
							sql: abv + '.' + field + '_0',
							type: col && col.type,
							func: exports.instructions.SQLCV(letter, abbrev, field),
							tooComplex: false,
						};
					}
				}
				return variables.instructions.CV(letter, abbrev, field)(_);
			}
		};
	},
	SQLF: function(field, args) {
		var sqlFunc = sqlFunctions[field];
		//if (!sqlFunc) return flowControl.instructions.F(field, args);
		return function sqlf$do(_) {
			var frame = glob.context.x3frame;
			var ctx = frame.whereContext;

			if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_);
			if (sqlFindPat[field]) return sqlFindPat[field](_, args, ctx);

			var cst = true;
			var params = [];
			var consts = [];

			var argSqls = args.map_(_, function(_, arg) {
				var s = genSql(_, arg);
				if (!s.isConstant) cst = false;
				params.push(s.func);
				consts = consts.concat(s.constants || []);
				return s;
			});

			if (cst) {
				frame.tryingSql = false;
				var rs = flowControl.instructions.F(field, args)(_);
				frame.tryingSql = true;
				return rs;
			} else if (sqlFunc) {
				var r = sqlFunc.apply(this, argSqls);
				r.func = exports.instructions.SQLF(field, params);
				if (!(r.constants)) r.constants = consts;
				return r;
			} else {
				var r = tooComplex();
				r.func = exports.instructions.SQLF(field, params);
				r.constants = consts;
				return r;
			}
		};
	},

	SQLEVALUE: function(req, ns, arg) {
		return function sqlevalue$do(_) {
			var frame = glob.context.x3frame;
			var ctx = frame.whereContext;

			var ev = dbevaluate.instructions.EVALUE(req, ns, arg)(_);
			return ev;
		};
	},
	SQLKEY: function(kyname, op, np, args) {
		//
		return function sqlsql$do(_) {
			// find key
			var frame = glob.context.x3frame;
			var ctx = frame.whereContext;
			var abbrev = ctx.tables[0];
			var table = frame.context.tables[abbrev];
			var key = table.findKey(kyname);
			var kln = key.items.length;

			// find right length
			var npk = np && np(_);
			npk = (npk) ? npk[0] : kln;
			npk = (npk > args.length) ? args.length : npk;

			// get arguments key
			var consts = [];
			var afunc;

			if (op === 'EQ' || op === "NE" || npk === 1) {
				// simple case
				var sql = "(";
				for (var i = 0; i < npk; i++) {
					if (i) sql += " AND ";
					var s = genSql(_, args[i]);
					sql += "(" + key.items[i] + " " + sqlCmpOps[op].op + " " + s.sql + ")";
					consts = consts.concat(s.constants || []);
					var fequal = exports.instructions.SQLEQ(key.func[i], s.func);
					if (afunc) afunc = exports.instructions.SQLAND(afunc, fequal);
					else afunc = fequal;
				}
				sql += ")";
				return {
					sql: sql,
					type: 'boolean',
					func: afunc,
					constants: consts,
					tooComplex: false,
				};
			} else {
				// should be replace by a multi-query
				var kp = npk;
				var ofunc;
				var sql = "(";
				for (var i = 0; i < npk; i++) {
					afunc = null;
					if (i) sql += " OR ";
					sql += "(";
					for (var j = 0; j < kp; j++) {
						var f;
						var s = genSql(_, args[j]);
						if (j) sql += " AND ";
						if (j < kp - 1) {
							sql += "(" + key.items[i] + " = " + s.sql + ")";
							f = exports.instructions.SQLEQ(key.func[j], s.func);
						} else {
							sql += "(" + key.items[i] + " " + sqlCmpOps[op].op + " " + s.sql + ")";
							f = exports.instructions['SQL' + op](key.func[j], s.func);
						}
						consts = consts.concat(s.constants || []);

						if (afunc) afunc = exports.instructions.SQLAND(afunc, f);
						else afunc = f;
					}
					sql += ")";
					kp -= 1;
					if (ofunc) ofunc = exports.instructions.SQLOR(ofunc, afunc);
					else ofunc = afunc;
				}
				sql += ")";
				return {
					sql: sql,
					constants: consts,
					tooComplex: false,
					type: 'boolean',
					func: ofunc,
				};
			}
		};
	},

	SQLAND: binaryOp('AND', 'AND', 'boolean'),
	SQLOR: binaryOp('OR', 'OR', 'boolean'),
	SQLEQ: binaryOp('EQ', '=', 'boolean'),
	SQLNE: binaryOp('NE', '<>', 'boolean'),
	SQLLT: binaryOp('LT', '<', 'boolean'),
	SQLLE: binaryOp('LE', '<=', 'boolean'),
	SQLGT: binaryOp('GT', '>', 'boolean'),
	SQLGE: binaryOp('GE', '>=', 'boolean'),
	SQLADD: binaryOp('ADD', 'CONCAT', 'string', '+', 'number'),
	SQLSUB: binaryOp('SUB', 'CONCAT', 'string', '-', 'number'),
	SQLMUL: binaryOp('MUL', '*', 'number'),
	SQLDIV: binaryOp('DIV', '/', 'number'),
};