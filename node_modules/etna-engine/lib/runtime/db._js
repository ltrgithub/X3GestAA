"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var array = require('./arrays');
var dates = require('./dates');
var dbevaluate = require('./dbevaluate');
var DBTable = require('./dbtable').DBTable;
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');
var tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");

exports.functions = {
	FILECLA: {
		count: 0
	},
	FILETYP: {
		count: 0
	},
	CLANBS: {
		count: 2,
		fn: function(name, kind) {
			// kind is 1 or 2 to indicate existing or allocated - ignore for now
			var context = this;
			var cla = context.tables[name];
			if (!cla) throw new X3Error(7, "invalid class: " + name);
			switch (kind) {
				case 1:
					return cla.types.length;
				case 2:
					return cla.values.length;
				default:
					throw new X3Error(10, "invalid value for clanbs parameter: " + typeof arg);
			}
		}
	},
	CLASIZ: {
		count: 2,
		fn: function(classe, exp_buf) {
			return 16;
		}
	},
	CLANAM: {
		count: 1
	},
	CLAVAR: {
		count: 1
	},
	CLALEV: {
		count: 1,
		fn: function(classe) {
			return 0;
		}
	},
};

function concat(a1, a2) {
	return (a1 && a2) ? a1.concat(a2) : (a1 || a2);
}

function genSql(_, exp, ctx) {
	var val = typeof exp === 'function' ? exp(_, ctx) : exp;
	if (val && val.sql) return val;

	//special case
	if (Array.isArray(val)) {
		var t = val[2];
		var r = "";
		if (val[1] > 1)
			throw new X3Error(26, "More than 1 dimension is not supported");
		var min = (val[5]) ? val[3] - val[5] : 0;
		var max = (val[6]) ? val[3] + val[6] - val[5] - 1 : val[4] - val[3];

		var r = {
			sql: "",
			type: typeof t[min],
			constants: [],
			func: [],
			isConstant: true,
		};

		for (var i = min; i <= max; i++) {
			if (t[i]) {
				r.constants.push(t[i]);
				r.func.push(util.instructions.C(t[i]));
				r.sql += (i > min) ? ',' : '';
				r.sql += "@?";
			}
		}
		return r;
	} else return {
		sql: "@?",
		type: typeof val,
		constants: [val.x3ToSql() || val],
		isConstant: true,
		func: util.instructions.C(val)
	};
}

function binaryOp(op, sqlOp, type, numOp, numType) {
	return function(op1, op2) {
		return function binaryOp$do(_, ctx) {
			var frame = glob.context.x3frame;
			if (!frame.tryingSql) return operators.instructions[op](op1, op2)(_);
			var v1 = genSql(_, op1, ctx);
			var v2 = genSql(_, op2, ctx);
			var unary = false;

			if (v1.tooComplex || v2.tooComplex) return {
				sql: "(1 = 1)",
				tooComplex: true,
				func: binaryOp(op, sqlOp, type, numOp, numType)(v1.func, v2.func),
				constants: [],
			};

			// the killing death hack for pat and find			
			if (v1.field && (["PAT", "FIND"].indexOf(v1.field) >= 0)) {
				var v = v2.constants[0];
				if (!(
					((v === 0) && (op === "NE")) ||
					((v !== 0) && (op === "EQ")) ||
					((v > 0) && (op === "GE")) ||
					((v >= 0) && (op === "GT")) ||
					((v < 0) && (op === "LE")) ||
					((v <= 0) && (op === "LT"))
				)) {
					ctx.revert = true;
					var v1 = genSql(_, op1, ctx);
					ctx.revert = false;
				}
				unary = true;
			}

			if (numOp && v1.type === v2.type && v1.type === "number") sqlOp = numOp, type = numType;
			var sql;
			if (sqlOp === "CONCAT") {
				if (numOp === '-') {
					v1.sql = "RTRIM(" + v1.sql + "),' '";
					v2.sql = "' ',LTRIM(" + v2.sql + ")";
				}
				sql = "CONCAT(" + v1.sql + "," + v2.sql + ")";
			} else {
				sql = (unary) ? "(" + v1.sql + ")" : "(" + v1.sql + " " + sqlOp + " " + v2.sql + ")";
			}
			var vals = (unary) ? (v1.constants || []) : (v1.constants || []).concat(v2.constants || []);
			return {
				sql: sql,
				type: type,
				constants: vals,
				tooComplex: false,
				func: binaryOp(op, sqlOp, type, numOp, numType)(v1.func, v2.func)
			};
		};
	};
}

function closeFile(abbrevs, local) {
	var frame = glob.context.x3frame;
	abbrevs.forEach(function(abbrev) {
		if (frame.context.tables[abbrev] && (frame.context.tables[abbrev].local >= local)) {
			(frame.context.tables[abbrev].sisters || []).forEach(function(absister) {
				delete frame.context.tables[absister];
				if (absister === frame.abbrev) frame.abbrev = null;
			});
			delete frame.context.tables[abbrev];
			if (abbrev === frame.abbrev) frame.abbrev = null;
		}
	});
}

function rowIn(row, descs) {
	return descs.reduce(function(obj, desc) {
		obj[desc.name] = desc.type.fromSql(row[desc.name]); // for now!
		return obj;
	}, {});
}

function sqlFn(name, type) {
	return function() {
		var thesql = name + "(" + Array.prototype.map.call(arguments, function(arg) {
			return arg.sql;
		}).join(',') + ")";
		return {
			sql: thesql,
			type: type,
			tooComplex: false
		};
	};
}

function tooComplex() {
	return {
		sql: "(1 = 1)",
		tooComplex: true,
	};
}

function defVal(type) {
	switch (type) {
		case 'string':
			return '';
		case 'number':
			return 0;
		case 'date':
			return null; //TODO : dates.ORIGIN;
		case 'binary':
			return null;
		default:
			throw new Error('unsupported column type: ' + type);
	}
}

var sqlCmpOps = {
	EQ: {
		op: '=',
		combine: 'and',
	},
	NE: {
		op: '<>',
		combine: 'or'
	},
	LT: {
		op: '<',
		combine: 'lexi'
	},
	LE: {
		op: '<=',
		combine: 'lexi'
	},
	GT: {
		op: '>',
		combine: 'lexi'
	},
	GE: {
		op: '>=',
		combine: 'lexi'
	},
};

var sqlFunctions = {
	// string functions
	LEN: sqlFn("LENGTH", "number"),
	//RIGHT$: sqlFn("RIGHT", "string"),
	//MID$: sqlFn("SUBSTRING", "string"),
	TOUPPER: sqlFn("UPPER", "string"),
	TOLOWER: sqlFn("LOWER", "string"),
	CHR$: sqlFn("CHAR", "string"),
	LEFT$: function(arg, len) {
		var frame = glob.context.x3frame;
		var driver = frame.context.superv.sqlDriver;

		return {
			sql: driver.subString(arg.sql, "1", len.sql),
			type: "string",
			tooComplex: false
		};
	},
	MID$: function(arg, first, len) {
		var frame = glob.context.x3frame;
		var driver = frame.context.superv.sqlDriver;

		return {
			sql: driver.subString(arg.sql, first.sql, len.sql),
			type: "string",
			tooComplex: false
		};
	},
	/*
	// have to repeat twice one paramter, can t do it
	SEG$: function(arg, first, last) {
		var frame = glob.context.x3frame;
		var driver = frame.context.superv.sqlDriver;

		return {
			sql: driver.subString(arg.sql, first.sql, len.sql),
			sql: "SUBSTRING(" + arg.sql + "," + first.sql + "," + last.sql + " + 1 - " + first.sql + ")",
			type: "string",
			tooComplex: false
		};
	},
	*/
	CTRANS: function(arg) {
		//if (arguments.length > 1) throw tooComplex();
		return {
			sql: "CONVERT(" + arg.sql + " USING ASCII)",
			type: "string",
			tooComplex: false,
		};
	},
	PAT: function(str, pat, revert) {
		var not = (revert) ? " NOT" : "";
		return {
			sql: "(" + str.sql + not + " LIKE '" + pat.constants[0].replace(/%/g, '%%').replace(/\*/g, '%' + "'") + ")",
			type: "string",
			constants: [],
			tooComplex: false,
		};
	},

	// Numeric functions
	ABS: sqlFn("ABS", "number"),
	MOD: sqlFn("MOD", "number"),
	// investigate neg values
	ARR2: function(arg) {
		return {
			sql: "ROUND(" + arg.sql + ",2)",
			type: "number",
			tooComplex: false,
		};
	},


	ARR: sqlFn("ROUND", "number"),
	FIX: sqlFn("TRUNCATE", "number"),
	INT: sqlFn("FLOOR", "number"),
	SQR: sqlFn("SQRT", "number"),
	COS: sqlFn("COS", "number"),
	SIN: sqlFn("SIN", "number"),
	TAN: sqlFn("TAN", "number"),
	ACOS: sqlFn("ACOS", "number"),
	ASIN: sqlFn("ASIN", "number"),
	ATAN: sqlFn("ATAN", "number"),
	PI: sqlFn("PI", "number"),
	EXP: sqlFn("EXP", "number"),
	LN: sqlFn("LOG", "number"),
	LOG: sqlFn("LOG10", "number"),

	// Find
	FIND: function(arg) {
		var not = '';
		var vals = Array.prototype.slice.call(arguments, 1);
		if (!(vals[vals.length - 1].sql)) {
			vals.pop();
			not = " NOT";
		}
		return {
			sql: "(" + arg.sql + not + " IN (" + vals.map(function(val) {
				return val.sql;
			}).join(',') + "))",
			type: "number",
		};
	}

	// see later about date functions
};


var sqlFindPat = {
	FIND: function(_, args, ctx) {
		var sqlFunc = sqlFunctions["FIND"];
		var frame = glob.context.x3frame;
		if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_);

		var cst = true;
		var params = [];
		var consts = [];

		var argSqls = args.map_(_, function(_, arg) {
			var s = genSql(_, arg, ctx);
			if (!s.isConstant) cst = false;
			if (Array.isArray(s.func)) params = params.concat(s.func);
			else params.push(s.func);
			consts = consts.concat(s.constants || []);
			return s;
		});

		if (cst) return flowControl.instructions.F(field, args)(_);
		else {
			if (ctx.revert) {
				argSqls.push(true);
				ctx.revert = false;
			}
			var r = sqlFunc.apply(this, argSqls);
			r.func = exports.instructions.SQLF("FIND", params);
			r.field = "FIND";
			if (!(r.constants)) r.constants = consts;
			return r;
		}
	},

	PAT: function(_, args, ctx) {
		var sqlFunc = sqlFunctions["PAT"];
		var frame = glob.context.x3frame;
		if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_);

		var cst = true;
		var params = [];
		var consts = [];

		var argSqls = args.map_(_, function(_, arg) {
			var s = genSql(_, arg, ctx);
			if (!s.isConstant) cst = false;
			params.push(s.func);
			consts = consts.concat(s.constants || []);
			return s;
		});

		if (cst) return flowControl.instructions.F(field, args)(_);
		else {
			if (ctx.revert) {
				argSqls.push(true);
				ctx.revert = false;
			}
			var r = sqlFunc.apply(this, argSqls);
			r.func = exports.instructions.SQLF("PAT", params);
			r.field = "PAT";
			if (!(r.constants)) r.constants = consts;
			return r;
		}
	}
};



function findTable(frame, abbrev) {
	// use frame's default abbrev by default
	var table = frame.context.tables[abbrev || frame.abbrev];
	if (!table) throw new X3Error(7, "bad table abbrev: " + abbrev);
	return table;
}


function identity(x) {
	return x;
}

exports.instructions = {
	KEY: function(letter, abbrev, name, indices) {
		return function key$do(_) {
			return {
				letter: letter,
				abbrev: abbrev,
				name: name,
				indices: indices && indices.map_(_, function(_, exp) {
					return exp(_);
				})
			};
		};
	},
	FILESQL: function(abbrev, name, where, order) {
		return function file$do(_) {
			var frame = glob.context.x3frame;
			var driver = frame.context.superv.sqlDriver;
			var nameVal = name(_);
			var desc = frame.context.superv.load(_, 'Table', nameVal);
			if (!desc) throw new X3Error(7, "unknown table or unsupport FILE syntax: " + nameVal);
			var abb = abbrev || desc.abbrev;
			var ctx = {};
			ctx.tables = [abb];


			// init keys
			var tkeys = Object.keys(desc.indexes).map(function(name) {
				var idx = desc.indexes[name];
				var sql = "";
				var funcs = [];
				var dir = [];
				var items = [];
				for (var i = 0; i < idx.columns.length; i++) {
					dir.push(idx.direction[i]);
					funcs.push(exports.instructions.SQLCV('F', abb, idx.columns[i].name));
					if (i > 0) sql += ", ";
					sql += idx.columns[i].sqlNames(abb + ".") + ((idx.direction < 0) ? " Desc" : "");
					items.push(idx.columns[i].sqlNames(abb + "."));
				}
				return {
					name: desc.indexes[name].name,
					hidden: false,
					constants: [],
					func: funcs,
					sql: sql,
					directions: dir,
					items: items,
					index: idx,
				};
			});

			// where
			var table = frame.context.tables[abb] = new DBTable(driver, abb, frame.context.superv, desc, tkeys, frame.stackLevel).init(_);
			table.where = where && where(_, ctx);

			// order by
			var newkey = order && order(_, ctx);
			if (newkey) {
				tkeys.forEach(function(ky) {
					ky.hidden = true;
				});
				table.currkey = tkeys.push(newkey) - 1;;
			}

			// init filter
			table.filter = {},

			// default table
			frame.abbrev = abb;
		};
	},
	CLOSEFILE: function(scope, abbrevs) {
		return function closefile$do(_) {
			closeFile(abbrevs, (scope === 'LOCAL') ? glob.context.x3frame.stackLevel : 0);
			/*
			var frame = glob.context.x3frame;
			abbrevs.forEach(function(abbrev) {
				if (frame.context.tables[abbrev] && (frame.context.tables[abbrev].local >= frame.stackLevel)) {
					(frame.context.tables[abbrev].sisters || []).forEach(function(absister) {
						delete frame.context.tables[absister];
						if (absister === frame.abbrev) frame.abbrev = null;
					});
					delete frame.context.tables[abbrev];
					if (abbrev === frame.abbrev) frame.abbrev = null;
				}
			});
*/
		};
	},
	LOGICCLOSE: function(scope, abbrev) {
		return function logicclose$do(_) {};
	},
	FILTER: function(abbrev, where, order) {
		return function filter$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);

			// delete old filter
			if (table.filter) {
				if (table.filter.key) {
					delete table.keys[table.filter.key];
					table.keys.forEach(function(ky) {
						ky.hidden = false;
					});
				}
				if (table.currkey === table.filter.key) table.currkey = 0;
				table.filter = {};
			}

			if ((!(where)) && (!(order))) return 0;

			// table in views
			var ctx = {};
			ctx.tables = [table.abbrev];
			if (table.joins) {
				table.joins.forEach(function(join) {
					ctx.tables.push(join.table.abbrev);
				});
			}

			var newkey = order && order(_, ctx);
			if (newkey) {
				table.keys.forEach(function(ky) {
					ky.hidden = true;
				});
				table.currkey = table.keys.push(newkey) - 1;
			}

			table.filter = {
				where: where && where(_, ctx),
				key: (newkey) ? table.currkey : undefined,
			};
		};
	},

	COLUMNS: function(abbrev, columns) {
		return function columns$do(_) {
			/*			var frame = glob.context.x3frame;
			var table = table(frame, abbrev);
			// columns is an array of [abbrev, field] pairs
			table.columns = columns;*/
		};
	},
	LINKITEM: function(key, outer, values) {
		return function linkitem$do(_, ctx) {
			var frame = glob.context.x3frame;
			var k = key(_);
			var abv = k.abbrev || frame.abbrev;
			var table = findTable(frame, k.abbrev);
			var index = table.findIndex(k.name);
			var consts = [];

			ctx.tables.push(abv);

			if (table.master) throw new X3Error(26, "Alread linked");

			var sql = ((outer) ? " LEFT OUTER " : " ") + " JOIN " + table.desc.name + " " + k.abbrev //
			+ " ON " + values.map_(_, function(_, val, i) {
				frame.tryingSql = true;
				val = genSql(_, val, ctx);
				frame.tryingSql = false;

				if (val.tooComplex) throw new X3Error(26, "Unable to build the link because of comlexity");
				consts = consts.concat(val.constants || []);

				return index.columns[i].sqlNames(abv + ".") + " = " + val.sql;
			}).join(" AND ");

			return {
				table: table,
				sql: sql,
				constants: consts,
			};
		};
	},
	LINK: function(abbrev, as, joins, where, order) {
		return function link$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);
			var ctx = {};
			ctx.tables = [table.abbrev];
			if (table.master) throw new X3Error(26, "Link on a Link");
			if (frame.context.tables[as]) throw new X3Error(28, as);
			table.sisters = table.sisters || [];
			table.sisters.push(as);
			var lktable = frame.context.tables[as] = new DBTable(table, table.abbrev).init(_);

			/*lktable.joins = [] ;
			joins.map_(_, function(_, jitm) {
					return jitm(_, ctx);
				}).forEach(function(j) {
					lktable.joins[j.table.abbrev] = j ;
				});
			*/
			lktable.joins = joins.map_(_, function(_, jitm) {
				return jitm(_, ctx);
			});


			lktable.filter = {};
			lktable.where = where && where(_, ctx);
			var newkey = order && order(_, ctx);
			if (newkey) {
				lktable.keys.forEach(function(ky) {
					ky.hidden = true;
				});
				lktable.currkey = table.keys.push(newkey) - 1;
			}
		};
	},
	READ: function(key, op, values) {
		var avalues = util.instructions.A(values);
		return function read$do(_) {
			var frame = glob.context.x3frame;
			var k = key(_);

			if (k.indices && k.indices.length > 1) {
				throw new X3Error(26, "NIY: READ with indices");
			}
			var vals = avalues(_);
			var table = findTable(frame, k.abbrev);
			var nkey = table.findKey(k.name);

			frame.context.sys.values.FSTAT = table.x3Read(_, nkey, op, vals);
		};
	},
	WRITE: function(abbrev) {
		return function write$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);

			table.setCurrentLogin(frame.loginName || "USER");

			frame.context.sys.values.FSTAT = table.x3Write(_);
		};

	},
	REWRITE: function(key, op, values) {
		var avalues = util.instructions.A(values);
		return function rewrite$do(_) {
			var frame = glob.context.x3frame;
			var k = key(_);
			if (k.indices) throw new X3Error(26, "NIY: READ with indices");
			var vals = avalues(_);
			var table = findTable(frame, k.abbrev);
			var driver = frame.context.superv.sqlDriver;

			var descs = [];
			var rowVals = [];
			var colNames = Object.keys(table.desc.columns);
			colNames.forEach_(_, function(_, name) {
				var column = table.desc.columns[name];
				column.sqlDescs(descs);
			});
			descs.forEach(function(desc) {
				// TODO: check indexed array layout
				var val = desc.index != null ? table.values[desc.name][desc.offset] : table.values[desc.name];
				val = desc.type.toSql(val);
				rowVals.push(val);
			});

			var index = k.name ? table.desc.index(k.name) : table.desc.indexes[0];
			if (!index) throw new X3Error(26, "index not found: " + k.name);
			var indexExps = index.sqlNames(_);
			if (vals.length === 0) vals = index.columns.map(function(col) {
				return col.type.toSql(table.values[col.name]);
			});
			var cmpOp = sqlCmpOps[op || 'EQ'];
			var where = '(' + indexExps[0] + cmpOp.op + driver.param(descs.length) + ')';
			var lexi = '(' + indexExps[0] + '=' + driver.param(descs.length) + ')';
			for (var i = 1; i < vals.length; i++) {
				var clause = indexExps[i] + cmpOp.op + driver.param(descs.length + i);
				if (cmpOp.combine === 'lexi') {
					where = where + ' or (' + lexi + ' and (' + clause + '))';
					lexi = '(' + lexi + ' and (' + indexExps[i] + '=' + driver.param(descs.length + i) + ')';
				} else {
					where = where + ' ' + cmpOp.combine + ' (' + clause + ')';
				}
			}
			var sql = "update " + table.desc.name + " set " + descs.map(function(desc) {
				return desc.name + "_" + (desc.index || 0) + '=' + driver.param(desc.offset);
			}).join(',') + " where " + where;
			//console.log(vals);
			var result = frame.context.superv.executeSql(_, sql, rowVals.concat(vals))[0];
			var updateCount = (result && result.updateCount) || 0; // fix driver, I get undefined if 0 updated!
			//if (!result || result.updateCount === undefined) throw new X3Error(26, "bad SQL result: " + result);
			frame.context.sys.values.ADXUPREC = updateCount;
			frame.context.sys.values.FSTAT = 0;
		};
	},
	DELETE: function(abbrev, where, op, values) {
		return function delete$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);
			var driver = frame.context.superv.sqlDriver;
			var ctx = {};
			ctx.tables = [table.abbrev];
			ctx.noabbrev = true;
			if (op) throw new X3Error(33, "NIY delete with op");

			// generate WHERE clause
			var whereSqls = [],
				constants = [];
			[table.where, table.filter.where, where && where(_, ctx)].filter(identity).forEach(function(w) {
					w.sql && whereSqls.push(w.sql);
					constants = constants.concat(w.constants);
				});
			//if (whereExps.length > 0) throw new X3Error(26, "where clause cannot be fully translated to SQL");
			var currtag = 0;
			var whereSql = whereSqls.length ? " where " + whereSqls.join(' and ') : '';
			whereSql = whereSql.replace(/@\?/g, function(val) {
				return driver.param(currtag++);
			});
			var sql = "delete from " + table.desc.name + " " + whereSql;
			tracer.debug && tracer.debug("Delete : " + sql);
			var result = frame.context.superv.executeSql(_, "delete from " + table.desc.name + " " + whereSql, constants);
			tracer.debug && tracer.debug("Delete : " + result);
			if (!result || result.updateCount === undefined) throw new X3Error(26, "bad SQL result: " + result);
			frame.context.sys.values.ADXDLREC = result.updateCount;
			frame.context.sys.values.FSTAT = 0;
		};
	},
	TRBEGIN: function(abbrevs) {
		//var aabrevs = util.instructions.A(abbrevs);
		return function trbegin$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;
			if ((session.dbConnection !== null) && (session.dbConnection !== undefined)) throw new X3Error(49, "");

			session.dbConnection = frame.context.superv.sqlDriver.driverPopConnection(_);

			frame.context.superv.sqlDriver.beginTransaction(_, session.dbConnection);
		};
	},
	COMMIT: function() {
		return function commit$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;

			if (!session.dbConnection) throw new X3Error(48, "");

			frame.context.superv.sqlDriver.commitTransaction(_, session.dbConnection);
			frame.context.superv.sqlDriver.driverPushConnection(session.dbConnection);
			session.dbConnection = null;
		};
	},
	ROLLBACK: function() {
		return function rollback$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;

			if (!session.dbConnection) throw new X3Error(48, "");

			frame.context.superv.sqlDriver.rollbackTransaction(_, session.dbConnection);
			frame.context.superv.sqlDriver.driverPushConnection(session.dbConnection);
			session.dbConnection = null;
			//frame.context.superv.executeSql(_, "rollback");
		};
	},
	FORF: function(key, where, p, end, block) {
		return function forf$do(_) {
			var frame = glob.context.x3frame;
			var session = glob.context.x3session;
			var k = key(_);
			var klvl = k && k.indices && k.indices[0];
			var table = findTable(frame, k.abbrev);
			var ky = table.findKey(k.name);
			var rec = {};
			var cf = table.x3GetCurrentFor();
			var kvalues;


			if (cf && cf.klvl === undefined) throw new X3Error(26, "Bad nested loop");

			if (!cf) {
				cf = table.x3OpenFor(_, ky, klvl, where, session.dbConnection);
				rec = cf.x3GetRecord(_);
				if (klvl) {
					cf.klvl = klvl;
					kvalues = table.getKeyValues(_, ky, klvl);
				}
			} else {
				if (ky.name !== cf.key.name) throw new X3Error(26, "Inconsitent nested loop key");

				cf.level++;
				if (klvl) cf.klvl = klvl;
				kvalues = table.getKeyValues(_, ky, klvl || cf.klvl);
			}

			// loop
			var level = ++frame.loopLevel;
			var exit = false;
			while (frame.loopLevel === level) {
				if (rec) {
					// execution du block
					block(_);

					//next
					if ((!klvl) && (!(cf.klvl))) {
						// classic for
						rec = cf.x3GetRecord(_);
					} else if (klvl && cf.klvl) {
						// nested loop part
						while ((rec) && (table.keyCompare(_, ky, kvalues) === 0)) {
							rec = cf.x3GetRecord(_);
						}
						if (rec) {
							kvalues = table.getKeyValues(_, ky, klvl);
						}
					} else {
						// nested loop final
						rec = cf.x3GetRecord(_);
						if (rec && table.keyCompare(_, ky, kvalues) < 0) exit = true;
					}
				} else {
					frame.loopLevel = level - 1;
				}

				// special exit loop
				if (exit) {
					frame.loopLevel = level - 1;
					break;
				}
			}
			if (frame.loopLevel === level - 1) {
				if (cf.level === 0) table.x3CloseFor();
				else cf.level--;
				p[end](_);
			}
		};
	},
	WHERE: function(wheres) {
		return function(_, ctx) {
			var frame = glob.context.x3frame;
			var sqls = [];
			var exps = [];
			var funcs = [];
			var pe = false;

			wheres.forEach_(_, function(_, exp) {
				frame.tryingSql = true;

				var r = genSql(_, exp, ctx);
				sqls.push(r.sql);
				exps = exps.concat(r.constants || []);
				if (r.tooComplex) pe = true;
				funcs.push(r.func);

				frame.tryingSql = false;
			});

			return {
				sql: sqls.join(" AND "),
				constants: exps,
				postEvaluation: pe,
				func: exports.instructions.WHERE2(funcs)
			};
		};
	},
	WHERE2: function(wheres) {
		return function(_) {
			var frame = glob.context.x3frame;
			var res = [];

			wheres.forEach_(_, function(_, exp) {
				var r = exp(_);
				res.push(r);
			});
			return res;
		};
	},
	ORDERITEM: function(exp, dir) {
		return function(_, ctx) {
			var frame = glob.context.x3frame;
			frame.tryingSql = true;
			var val = genSql(_, exp, ctx);
			var sql = val.sql + ((dir === "-") ? " Desc" : "");
			frame.tryingSql = false;

			return {
				sql: sql,
				isConstant: val.isConstant,
				constants: val.constants,
				func: val.func,
				item: val.sql,
				dir: ((dir === "-") ? -1 : 1),
			};
		};
	},
	ORDER: function(keyName, by, withExp) {
		return function(_, ctx) {
			var items = by;
			if (withExp) {
				//todo.............
				items = withExp(_).split(';').map(function(s) {
					var pair = s.split(' ');
					return (pair[1] && pair[1].toLowerCase() === 'desc' ? '-' : '+') + pair[0];
				});
			} else {
				var consts = [];
				var funcs = [];
				var dir = [];
				var items = [];
				var sql = "" + by.map_(_, function(_, kitem) {
					var sk = kitem(_, ctx);
					consts = consts.concat(sk.constants || []);
					funcs.push(sk.func);
					dir.push(sk.dir);
					items.push(sk.item);
					return sk.sql;
				}).join(",");
			}
			return {
				name: keyName,
				sql: sql,
				hidden: false,
				constants: consts,
				func: funcs,
				directions: dir,
				items: items,
			};
		};
	},
	SQLV: function(field) {
		return function sqlv$do(_, ctx) {
			var frame = glob.context.x3frame;
			if (!frame.tryingSql) return variables.instructions.V(field)(_);
			//throw new X3Error(26, "NIY");
			var tables = frame.context.tables;
			var abbrevs = ctx.tables; //Object.keys(tables);

			var dicts = frame.dicts;
			for (var j = 0, len = dicts.length; j < len; j++) {
				var dict = dicts[j];
				if (dict !== tables) {
					if (dict.values[field] !== undefined) {
						return variables.instructions.V(field)(_);
					}
				}
			}
			for (var i = 0; i < abbrevs.length; i++) {
				var abbrev = abbrevs[i];
				var abv = (ctx.noabbrev) ? "" : (abbrev + '.');
				var table = tables[abbrev];

				if (table.values && table.values[field] !== undefined) return {
					sql: abv + field + '_0',
					type: table.types[field],
					func: exports.instructions.SQLCV("F", abbrev, field),
					tooComplex: false,
				};
			}
			throw new X3Error(6, field);
		};
	},
	SQLINDEX: function(field, args) {
		var aargs = util.instructions.A(args);
		return function sqlindex$do(_, ctx) {
			var frame = glob.context.x3frame;
			if (!frame.tryingSql) return array.instructions.INDEX(field, args);
			var f = genSql(_, field, ctx);
			var i = aargs(_);

			if (f.isConstant) {
				var tryingSql = frame.tryingSql;
				frame.tryingSql = false;
				var val = array.instructions.INDEX(field, args)(_);
				frame.tryingSql = tryingSql;
				return {
					sql: "@?",
					type: typeof val,
					constants: [val.x3ToSql() || val],
					isConstant: true,
					func: util.instructions.C(val)
				};
			}

			return {
				sql: f.sql.replace("_0", "_" + i),
				type: f.type,
				func: exports.instructions.SQLINDEX(field, args),
				tooComplex: false,
			};

		};
	},
	SQLCV: function(letter, abbrev, field) {
		return function sqlcv$do(_, ctx) {
			var frame = glob.context.x3frame;
			//console.log("Letter : " + letter + " abbrev:" + abbrev + " field:" + field);
			if (!frame.tryingSql || letter === 'L' || letter === 'V' || letter === 'S') return variables.instructions.CV(letter, abbrev, field)(_);
			if (abbrev) {
				if (ctx.tables.indexOf(abbrev) >= 0) {
					var abv = (ctx.noabbrev) ? "" : (abbrev + '.');
					var table = frame.context.tables[abbrev];
					var col = table && table.desc && table.desc.columns[field];
					return {
						sql: abv + field + '_0',
						type: col && col.type,
						func: exports.instructions.SQLCV(letter, abbrev, field),
						tooComplex: false,
					};
				} else
					return variables.instructions.CV(letter, abbrev, field)(_);
			} else {
				for (var i = 0; i < ctx.tables.length; i++) {
					var table = frame.context.tables[ctx.tables[i]];
					var abv = (ctx.noabbrev) ? "" : (abbrev + '.');

					if (table.desc.columns[field]) {
						var col = table.desc.columns[field];
						return {
							sql: abv + '.' + field + '_0',
							type: col && col.type,
							func: exports.instructions.SQLCV(letter, abbrev, field),
							tooComplex: false,
						};
					}
				}
				return variables.instructions.CV(letter, abbrev, field)(_);
			}
		};
	},
	SQLF: function(field, args) {
		var sqlFunc = sqlFunctions[field];
		//if (!sqlFunc) return flowControl.instructions.F(field, args);
		return function sqlf$do(_, ctx) {
			var frame = glob.context.x3frame;
			if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_);
			if (sqlFindPat[field]) return sqlFindPat[field](_, args, ctx);

			var cst = true;
			var params = [];
			var consts = [];

			var argSqls = args.map_(_, function(_, arg) {
				var s = genSql(_, arg, ctx);
				if (!s.isConstant) cst = false;
				params.push(s.func);
				consts = consts.concat(s.constants || []);
				return s;
			});

			if (cst) {
				frame.tryingSql = false;
				var rs = flowControl.instructions.F(field, args)(_);
				frame.tryingSql = true;
				return rs;
			} else if (sqlFunc) {
				var r = sqlFunc.apply(this, argSqls);
				r.func = exports.instructions.SQLF(field, params);
				if (!(r.constants)) r.constants = consts;
				return r;
			} else {
				var r = tooComplex();
				r.func = exports.instructions.SQLF(field, params);
				r.constants = consts;
				return r;
			}
		};
	},

	SQLEVALUE: function(req, ns, arg) {
		return function sqlevalue$do(_, ctx) {
			var ev = dbevaluate.instructions.EVALUE(req, ns, arg)(_, ctx);
			return ev;
		};
	},
	SQLAND: binaryOp('AND', 'AND', 'boolean'),
	SQLOR: binaryOp('OR', 'OR', 'boolean'),
	SQLEQ: binaryOp('EQ', '=', 'boolean'),
	SQLNE: binaryOp('NE', '<>', 'boolean'),
	SQLLT: binaryOp('LT', '<', 'boolean'),
	SQLLE: binaryOp('LE', '<=', 'boolean'),
	SQLGT: binaryOp('GT', '>', 'boolean'),
	SQLGE: binaryOp('GE', '>=', 'boolean'),
	SQLADD: binaryOp('ADD', 'CONCAT', 'string', '+', 'number'),
	SQLSUB: binaryOp('SUB', 'CONCAT', 'string', '-', 'number'),
	SQLMUL: binaryOp('MUL', '*', 'number'),
	SQLDIV: binaryOp('DIV', '/', 'number'),
};