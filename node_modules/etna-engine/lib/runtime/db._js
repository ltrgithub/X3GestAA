"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var dates = require('./dates');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');

exports.functions = {
	FILECLA: {
		count: 0
	},
	FILETYP: {
		count: 0
	},
	CLANBS: {
		count: 2,
		fn: function(name, kind) {
			// kind is 1 or 2 to indicate existing or allocated - ignore for now
			var context = this;
			var cla = context.tables[name];
			if (!cla) throw new X3Error(7, "invalid class: " + name);
			switch (kind) {
			case 1:
				return cla.types.length;
			case 2:
				return cla.values.length;
			default:
				throw new X3Error(10, "invalid value for clanbs parameter: " + typeof arg);
			}
		}
	},
	CLASIZ: {
		count: 2,
		fn: function(classe, exp_buf) {
			return 16;
		}
	},
	CLANAM: {
		count: 1
	},
	CLAVAR: {
		count: 1
	},
};

function concat(a1, a2) {
	return (a1 && a2) ? a1.concat(a2) : (a1 || a2);
}

function genSql(_, exp) {
	var val = typeof exp === 'function' ? exp(_) : exp;
	if (val && val.sql) return val;
	return {
		sql: typeof val === "string" ? "'" + val.replace(/'/g, "''") + "'" : "" + val,
		type: typeof val
	};
}

function binaryOp(op, sqlOp, type, numOp, numType) {
	return function(op1, op2) {
		return function binaryOp$do(_) {
			var frame = glob.context.x3frame;
			if (!frame.tryingSql) return operators.instructions[op](op1, op2)(_);
			var v1 = genSql(_, op1);
			var v2 = genSql(_, op2);
			if (numOp && v1.type === v2.type && v1.type === "number") sqlOp = numOp, type = numType;
			var sql;
			if (sqlOp === "CONCAT") {
				if (numOp === '-') {
					v1.sql = "RTRIM(" + v1.sql + "),' '";
					v2.sql = "' ',LTRIM(" + v2.sql + ")";
				}
				sql = "CONCAT(" + v1.sql + "," + v2.sql + ")";
			} else sql = "(" + v1.sql + " " + sqlOp + " " + v2.sql + ")";
			return {
				sql: sql,
				type: type,
			};
		};
	};
}

function rowIn(row, descs) {
	return descs.reduce(function(obj, desc) {
		obj[desc.name] = desc.type.fromSql(row[desc.name]); // for now!
		return obj;
	}, {});
}

function sqlFn(name, type) {
	return function() {
		return {
			sql: name + "(" + Array.prototype.map.call(arguments, function(arg) {
				return arg.sql;
			}).join(',') + ")",
			type: type,
		};
	};
}

function tooComplex() {
	return {
		tooComplexForSql: true
	};
}

function defVal(type) {
	switch (type) {
	case 'string':
		return '';
	case 'number':
		return 0;
	case 'date':
		return dates.ORIGIN;
	case 'binary':
		return null;
	default:
		throw new Error('unsupported column type: ' + type);
	}
}

var sqlCmpOps = {
	EQ: {
		op: '=',
		combine: 'and',
	},
	NE: {
		op: '<>',
		combine: 'or'
	},
	LT: {
		op: '<',
		combine: 'lexi'
	},
	LE: {
		op: '<=',
		combine: 'lexi'
	},
	GT: {
		op: '>',
		combine: 'lexi'
	},
	GE: {
		op: '>=',
		combine: 'lexi'
	},
}

var sqlFunctions = {
	// string functions
	LEN: sqlFn("LENGTH", "number"),
	LEFT$: sqlFn("LEFT", "string"),
	RIGHT$: sqlFn("RIGHT", "string"),
	MID$: sqlFn("SUBSTRING", "string"),
	TOUPPER: sqlFn("UPPER", "string"),
	TOLOWER: sqlFn("LOWER", "string"),
	CHR$: sqlFn("CHAR", "string"),
	SEG$: function(arg, first, last) {
		return {
			sql: "SUBSTRING(" + arg.sql + "," + first.sql + "," + last.sql + " + 1 - " + first.sql + ")",
			type: "string",
		};
	},
	CTRANS: function(arg) {
		if (arguments.length > 1) throw tooComplex();
		return {
			sql: "CONVERT(" + arg.sql + " USING ASCII)",
			type: "string",
		};
	},
	PAT: function(str, pat) {
		if (/[?#!]/.match(pat.sql)) throw tooComplex();
		return {
			sql: "(" + str.sql + " LIKE " + pat.sql.replace(/%/g, '%%').replace(/\*/g, '%') + ")",
			type: "string",
		};
	},

	// Numeric functions
	ABS: sqlFn("ABS", "number"),
	MOD: sqlFn("MOD", "number"),
	// investigate neg values
	ARR2: function(arg) {
		return {
			sql: "ROUND(" + arg.sql + ",2)",
			type: "number",
		};
	},
	ARR: sqlFn("ROUND", "number"),
	FIX: sqlFn("TRUNCATE", "number"),
	INT: sqlFn("FLOOR", "number"),

	SQR: sqlFn("SQRT", "number"),
	COS: sqlFn("COS", "number"),
	SIN: sqlFn("SIN", "number"),
	TAN: sqlFn("TAN", "number"),
	ACOS: sqlFn("ACOS", "number"),
	ASIN: sqlFn("ASIN", "number"),
	ATAN: sqlFn("ATAN", "number"),
	PI: sqlFn("PI", "number"),
	EXP: sqlFn("EXP", "number"),
	LN: sqlFn("LOG", "number"),
	LOG: sqlFn("LOG10", "number"),

	// Find
	FIND: function(arg) {
		var vals = Array.prototype.slice.call(arguments, 1);
		return {
			sql: "FIND_IN_SET(" + arg.sql + ",'" + vals.map(function(val) {
				if (!/['\-\d]/.test(val.sql[0])) throw tooComplex();
				return val.sql.substring(1, val.sql.length - 1);
			}).join(',') + "')",
			type: "number",
		};
	}

	// see later about date functions
};

function findTable(frame, abbrev) {
	// use frame's default abbrev by default
	var table = frame.context.tables[abbrev || frame.abbrev];
	if (!table) throw new X3Error(7, "bad table abbrev: " + abbrev);
	return table;
}

function findView(frame, abbrev) {
	// use frame's default abbrev by default
	var abb = abbrev || frame.abbrev;
	var table = frame.context.tables[abb];
	if (!table) throw new X3Error(7, "bad table abbrev: " + abbrev);
	return table.views[abb];
}

function findIndex(table, name) {
	var index = table.desc.indexes(name);
	if (!index) throw new X3Error(21, "bad index: " + name);
	return index;
}

function allocateSlots(frame, table, columns, first) {
	Object.keys(columns).forEach(function(colName) {
		var type = columns[colName].type.jsType;
		table.values[colName] = defVal(type);
		table.types[colName] = type;
	});
}

function identity(x) {
	return x;
}

exports.instructions = {
	KEY: function(letter, abbrev, name, indices) {
		return function key$do(_) {
			return {
				letter: letter,
				abbrev: abbrev,
				name: name,
				indices: indices && indices.map_(_, function(_, exp) {
					return exp(_);
				})
			};
		};
	},
	FILESQL: function(abbrev, name, where, order) {
		return function file$do(_) {
			var frame = glob.context.x3frame;
			var nameVal = name(_);
			var desc = frame.context.supervisor.load(_, 'Table', nameVal);
			if (!desc) throw new X3Error(7, "unknown table or unsupport FILE syntax: " + nameVal);
			var abb = abbrev || desc.abbrev;
			var table = frame.context.tables[abb] = {
				abbrev: abb,
				desc: desc,
				views: {},
				types: {},
				values: {},
			};
			// allocate column slots
			allocateSlots(frame, table, desc.columns, true);
			// add link to self with where and order clauses
			table.views[abb] = {
				table: table,
				joins: [],
				where: where && where(_),
				order: order && order(_),
				filter: {},
			};
			// record last abbrev as default one
			frame.abbrev = abb;
		};
	},
	CLOSEFILE: function(scope, abbrevs) {
		return function closefile$do(_) {
			var frame = glob.context.x3frame;
			abbrevs.forEach(function(abbrev) {
				delete frame.context.tables[abbrev];
				if (abbrev === frame.abbrev) frame.abbrev = null;
			});
		};
	},
	FILTER: function(abbrev, where, order) {
		return function filter$do(_) {
			var frame = glob.context.x3frame;
			var view = findView(frame, abbrev);
			view.filter = {
				where: where && where(_),
				order: order && order(_)
			};
		};
	},
	COLUMNS: function(abbrev, columns) {
		return function columns$do(_) {
			var frame = glob.context.x3frame;
			var view = findView(frame, abbrev);
			// columns is an array of [abbrev, field] pairs
			table.columns = columns;
		};
	},
	LINKITEM: function(key, outer, values) {
		return function linkitem$do(_) {
			var frame = glob.context.x3frame;
			var k = key(_);
			var table = findTable(frame, k.abbrev);
			var index = findIndex(table, k.name);
			allocateSlots(frame, table, table.desc.columns);
			var sql = (outer ? " LEFT" : " INNER") + " JOIN " + table.desc.name + " AS " + k.abbrev //
			+ " ON " + values.map_(_, function(_, val, i) {
				frame.tryingSql = true;
				try {
					val = genSql(_, val);
					frame.tryingSql = false;
					return k.abbrev + "." + index.columns[i].substring(1) + "_0 = " + val.sql;
				} catch (ex) {
					frame.tryingSql = false;
					throw ex; // TODO: handle this
					if (!ex.tooComplexForSql) throw ex;
					//exps.push(exp);
				}
			});
			return {
				sql: sql,
				abbrev: k.abbrev
			};
		};
	},
	LINK: function(abbrev, as, joins, where, order) {
		return function link$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);
			// main table is also accessible with the link abbrev
			frame.context.tables[as] = table;
			// link information is 
			table.views[as] = {
				table: table,
				joins: joins.map_(_, function(_, join) {
					return genSql(_, join);
				}),
				where: where && where(_),
				order: order && order(_),
				filter: {},
			};
			// TODO: should we insert it in dicts (table is already there)?
		};
	},
	READ: function(key, op, values) {
		var avalues = util.instructions.A(values);
		return function read$do(_) {
			var frame = glob.context.x3frame;
			var k = key(_);
			if (k.indices) throw new X3Error(26, "NIY: READ with indices");
			var vals = avalues(_);
			var table = findTable(frame, k.abbrev);
			var driver = table.supervisor.sqlDriver;
			var index = table.desc.index(k.name);
			if (!index) throw new X3Error(26, "index not found: " + k.name);
			var indexExps = index.sqlNames(_);
			var cmpOp = sqlCmpOps[op || 'EQ'];
			var where = '(' + indexExps[0] + cmpOp.op + driver.param(0) +')';
			var lexi = '(' + indexExps[0] + '=:1)';;
			for (var i = 1; i < vals.length; i++) {
				var clause = indexExps[i] + cmpOp.op + driver.param(i);
				if (cmpOp.combine === 'lexi') {
					where = where + ' or (' + lexi + ' and (' + clause + '))';
					lexi = '(' + lexi + ' and (' + indexExps[i] + '=' + driver.param(i) + ')';
				} else {
					where = where + ' ' + cmpOp.combine + ' (' + clause + ')'
				}
			}
			var descs = [];
			var sql = "select " + Object.keys(table.desc.columns).map_(_, function(_, name) {
				var column = table.desc.columns[name];
			 	column.sqlDescs(descs);
				return column.sqlNamesSelect(_);
			}).join(',') + " from " + table.desc.name + " where " + where;
			var row = frame.context.supervisor.executeSql(_, sql, vals)[0];
			//console.log(row);
			if (row) {
				table.values = rowIn(row, descs);
				frame.context.sys.values.FSTAT = 0;
			} else {
				frame.context.sys.values.FSTAT = 5;
			}
		};
	},
	WRITE: function(abbrev) {
		return function write$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);
			var driver = table.supervisor.sqlDriver;
			var colNames = Object.keys(table.desc.columns);
			var sql = table.insert || (table.insert = "INSERT INTO " + driver.escape(table.desc.name) + " (" + colNames.map(function(colName) {
				return colName + "_0";
			}) + ") VALUES (" + colNames.map(function(colName, i) {
				return driver.param(i);
			}) + ")");
			var row = table.values;
			var abbrev = table.abbrev;
			var values = colNames.map(function(colName) {
				var val = row[colName];
				if (val === undefined) throw new X3Error(26, colName + ": bad value: " + val);
				var desc = table.desc.columns[colName];
				val = desc.type.toSql(val);
				return val;
			});
			var result = frame.context.supervisor.executeSql(_, sql, values);
			if (!result || result.updateCount === undefined) throw new X3Error(26, "bad SQL result: " + result);
			frame.context.sys.values.ADXUPREC = result.updateCount;
			frame.context.sys.values.FSTAT = 0;
		};
	},
	REWRITE: function(key, op, values) {
		var avalues = util.instructions.A(values);
		return function rewrite$do(_) {
			var frame = glob.context.x3frame;
			var k = key(_);
			if (k.indices) throw new X3Error(26, "NIY: READ with indices");
			var vals = avalues(_);
			var table = findTable(frame, k.abbrev);
			var driver = table.supervisor.sqlDriver;

			var descs = [];
			var rowVals = [];
			var colNames = Object.keys(table.desc.columns);
			colNames.forEach_(_, function(_, name) {
			 	var column = table.desc.columns[name];
			 	column.sqlDescs(descs);
			 });
			descs.forEach(function(desc) {
				// TODO: check indexed array layout
			 	var val = desc.index != null ? table.values[desc.name][desc.offset] : table.values[desc.name];
			 	val = desc.type.toSql(val);
			 	rowVals.push(val);
			})

			var index = k.name ? table.desc.index(k.name) : table.desc.indexes[0];
			if (!index) throw new X3Error(26, "index not found: " + k.name);
			var indexExps = index.sqlNames(_);
			if (vals.length === 0) vals = index.columns.map(function(col) {
				return col.type.toSql(table.values[col.name]);
			});
			var cmpOp = sqlCmpOps[op || 'EQ'];
			var where = '(' + indexExps[0] + cmpOp.op + driver.param(descs.length) + ')';
			var lexi = '(' + indexExps[0] + '=' + driver.param(descs.length) + ')';
			for (var i = 1; i < vals.length; i++) {
				var clause = indexExps[i] + cmpOp.op + driver.param(descs.length + i);
				if (cmpOp.combine === 'lexi') {
					where = where + ' or (' + lexi + ' and (' + clause + '))';
					lexi = '(' + lexi + ' and (' + indexExps[i] + '=' + driver.param(descs.length + i) + ')';
				} else {
					where = where + ' ' + cmpOp.combine + ' (' + clause + ')'
				}
			}
			var sql = "update " + table.desc.name + " set " + descs.map(function(desc) {
				return desc.name + "_" + (desc.index || 0) + '=' + driver.param(desc.offset);
			}).join(',') + " where " + where;
			//console.log(vals);
			var result = frame.context.supervisor.executeSql(_, sql, rowVals.concat(vals))[0];
			var updateCount = (result && result.updateCount) || 0; // fix driver, I get undefined if 0 updated!
			//if (!result || result.updateCount === undefined) throw new X3Error(26, "bad SQL result: " + result);
			frame.context.sys.values.ADXUPREC = updateCount;
			frame.context.sys.values.FSTAT = 0;
		};
	},
	DELETE: function(abbrev, where, op, values) {
		return function delete$do(_) {
			var frame = glob.context.x3frame;
			var table = findTable(frame, abbrev);
			var view = findView(frame, abbrev);
			if (op) throw new X3Error(33, "NIY delete with op")

			// generate WHERE clause
			var whereSqls = [],
				whereExps = [];
			[view.where, view.filter.where, where && where(_)].filter(identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				whereExps = concat(whereExps, w.exps);
			});
			if (whereExps.length > 0) throw new X3Error(26, "where clause cannot be fully translated to SQL");

			var whereSql = whereSqls.length ? " where " + whereSqls.join(' and ') : '';
			var result = frame.context.supervisor.executeSql(_, "delete from " + driver.escape(view.table.desc.name) + " " + abbrev + " " + whereSql);
			if (!result || result.updateCount === undefined) throw new X3Error(26, "bad SQL result: " + result);
			frame.context.sys.values.ADXDLREC = result.updateCount;
			frame.context.sys.values.FSTAT = 0;
		};
	},
	TRBEGIN: function(abbrevs) {
		//var aabrevs = util.instructions.A(abbrevs);
		return function trbegin$do(_) {
			var frame = glob.context.x3frame;
			var name = "TX"; //aabrevs(_).join('_');
			frame.context.supervisor.executeSql(_, "set transaction name '" + name + "'");
		};
	},
	COMMIT: function() {
		return function commit$do(_) {
			var frame = glob.context.x3frame;
			frame.context.supervisor.executeSql(_, "commit");
		};
	},
	ROLLBACK: function() {
		return function rollback$do(_) {
			var frame = glob.context.x3frame;
			frame.context.supervisor.executeSql(_, "rollback");
		};
	},
	FORF: function(key, where, p, end, block) {
		return function forf$do(_) {
			var frame = glob.context.x3frame;
			var k = key(_);
			var table = frame.context.tables[k.abbrev];
			if (!table) throw new X3Error(7, "class not found: " + k.abbrev);
			return table.doFor(_, where, p, end, block);

			// repackage as doFor
			var view = findView(frame, k.abbrev);

			// generate WHERE clause
			var whereSqls = [],
				whereExps = [];
			[view.where, view.filter.where, where && where(_)].filter(identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				whereExps = concat(whereExps, w.exps);
			});

			var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';

			// generate ORDER BY clause
			var ord = view.filter.order || view.order;
			var orderBySql = ord ? " ORDER BY " + ord.items.map(function(item) {
				return item.substring(1) + "_0" + (item[0] === '-' ? ' DESC' : ' ASC');
			}).join(',') : '';

			var abbrevs = [view.table.abbrev];
			var tablesSql = driver.escape(view.table.desc.name) + " AS " + view.table.abbrev + view.joins.map(function(join) {
				abbrevs.push(join.abbrev);
				return join.sql;
			}).join('');

			var descs = [];
			var columnsSql = (view.columns ? view.columns.map(function(column) {
				column.sqlDescs(descs);
				return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
			}) : abbrevs.reduce(function(result, abbrev) {
				Object.keys(findTable(frame, abbrev).desc.columns).forEach(function(column) {
					column.sqlDescs(descs);
					result.push(abbrev + "." + column + "_0 AS " + abbrev + "_" + column);
				});
				return result;
			}, [])).join(',');

			var sql = "SELECT " + columnsSql + " FROM " + tablesSql + whereSql + orderBySql;

			whereExps.length > 0 && console.log(whereExps.length + " WHERE clause(s) not translated to SQL.");
			var q = _connect(_).query(sql);

			var cursor = q.execute(_, {
				useCursor: true
			});

			var level = ++frame.loopLevel;
			while (frame.loopLevel === level) {
				var row = cursor.next(_);
				if (row) {
					view.table.values = rowIn(row, descs);
					if (whereExps.every_(_, function(_, exp) {
						return exp(_);
					})) block(_);
				} else {
					frame.loopLevel = level - 1;
				}
			}
			if (frame.loopLevel === level - 1) p[end](_);
		};
	},
	WHERE: function(wheres) {
		return function(_) {
			var frame = glob.context.x3frame;
			var sqls = [],
				exps = [];
			wheres.forEach_(_, function(_, exp) {
				frame.tryingSql = true;
				try {
					var r = genSql(_, exp);
					sqls.push(r.sql);

					frame.tryingSql = false;
				} catch (ex) {
					frame.tryingSql = false;
					if (!ex.tooComplexForSql) throw ex;
					exps.push(exp);
				}
			});
			return {
				sql: sqls.join(" AND "),
				exps: exps,
			};
		};
	},
	ORDER: function(keyName, by, withExp) {
		return function(_) {
			var items = by;
			if (withExp) {
				items = withExp(_).split(';').map(function(s) {
					var pair = s.split(' ');
					return (pair[1] && pair[1].toLowerCase() === 'desc' ? '-' : '+') + pair[0];
				});
			}
			return {
				name: keyName,
				items: items
			};
		};
	},

	SQLV: function(field) {
		return function sqlv$do(_) {
			var frame = glob.context.x3frame;
			if (!frame.tryingSql) return variables.instructions.V(field)(_);
			//throw new X3Error(26, "NIY");
			var tables = frame.context.tables;
			var abbrevs = Object.keys(tables);
			for (var i = 0; i < abbrevs.length; i++) {
				var abbrev = abbrevs[i];
				var table = tables[abbrev];
				if (table.values[field] !== undefined) return {
					sql: abbrev + '.' + field + '_0',
					type: table.types[field],
				};
			}
			return variables.instructions.V(field)(_);
		};
	},
	SQLCV: function(letter, abbrev, field) {
		return function sqlcv$do(_) {
			var frame = glob.context.x3frame;
			if (!frame.tryingSql || letter === 'L' || letter === 'V' || letter === 'S') return variables.instructions.CV(letter, abbrev, field)(_);
			throw new X3Error(26, "NIY");
			var table = frame.context.tables[abbrev];
			var col = table && table.desc && table.desc.columns[field];
			return {
				sql: abbrev + '.' + field + '_0',
				type: col && col.type,
			};
		};
	},
	SQLF: function(field, args) {
		var sqlFunc = sqlFunctions[field];
		if (!sqlFunc) return flowControl.instructions.F(field, args);
		return function sqlf$do(_) {
			var frame = glob.context.x3frame;
			if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_);
			var argSqls = args.map_(_, function(_, arg) {
				return genSql(_, arg);
			});
			return sqlFunc.apply(this, argSqls);
		};
	},
	SQLAND: binaryOp('AND', 'AND', 'boolean'),
	SQLOR: binaryOp('OR', 'OR', 'boolean'),
	SQLEQ: binaryOp('EQ', '=', 'boolean'),
	SQLNE: binaryOp('NE', '<>', 'boolean'),
	SQLLT: binaryOp('LT', '<', 'boolean'),
	SQLLE: binaryOp('LE', '<=', 'boolean'),
	SQLGT: binaryOp('GT', '>', 'boolean'),
	SQLGE: binaryOp('GE', '>=', 'boolean'),
	SQLADD: binaryOp('ADD', 'CONCAT', 'string', '+', 'number'),
	SQLSUB: binaryOp('SUB', 'CONCAT', 'string', '-', 'number'),
	SQLMUL: binaryOp('MUL', '*', 'number'),
	SQLDIV: binaryOp('DIV', '/', 'number'),
};