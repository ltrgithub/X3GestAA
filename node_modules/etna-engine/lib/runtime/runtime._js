"use strict";

var modules = ['arrays', 'dates', 'db', 'evaluate', 'fileio', 'flowControl', 'misc', 'numbers', 'operators', 'stats', 'strings', 'system', 'util', 'variables'].map(function(name) {
	return require('./' + name);
});
var util = require('./util');
var variables = require('./variables');

function collect(key) {
	exports[key] = {};
	modules.forEach(function(mod) {
		mod[key] && Object.keys(mod[key]).forEach(function(k) {
			if (exports[key][k]) throw new Error("duplicate definition of " + key + " " + k);
			//console.log(key + "/" + k)
			exports[key][k] = mod[key][k];
		});
	});
}

collect('functions');
collect('instructions');

Object.keys(exports.instructions).forEach(function(k) {
	var instruction = exports.instructions[k];
	exports.instructions[k] = function $do() {
		var fn = instruction.apply(this, arguments);
		if (typeof fn !== "function") return;
		var loc = util.sourceLoc;
		return function(_, frame) {
			var args = Array.prototype.slice.call(arguments, 1);
			console.log(loc);
			frame.sub.loc = loc;
			return fn.apply_(_, this, args, 0);
		}
	}
});

var instCounters = {};
var prevCounter = {};
var funcCounters = {};

exports.setupCounters = function() {
	false && require('streamline/lib/compiler/register').options.fibers && Object.keys(exports.instructions).forEach(function(k) {
		var instr = exports.instructions[k];
		exports.instructions[k] = function() {
			//console.error("compile " + k)
			var compiled = instr.apply(this, arguments);
			if (typeof compiled !== 'function' || k === 'MAIN') return compiled;
			if (typeof compiled.fstreamlineFunction !== 'function') throw new Error("bad instruction: " + k + ": " + compiled);
			var counter = (instCounters[k] = instCounters[k] || {
				compile: 0,
				execute: 0,
				allMillis: 0,
				selfMillis: 0
			});
			counter.compile++;
			var fn = function(_, frame) {
				//console.error("called " + k)
				var prev = prevCounter;
				prevCounter = counter;
				counter.execute++;
				var t0 = Date.now();
				var result = require('streamline/lib/fibers/runtime').invoke(this, compiled, arguments, 0);
				var dt = Date.now() - t0;
				counter.allMillis += dt;
				counter.selfMillis += dt;
				prev.selfMillis -= dt;
				prevCounter = prev;
				return result;
			};
			fn.value = compiled.value;
			return fn;
		};
	});
	false && Object.keys(exports.functions).forEach(function(k) {
		var func = exports.functions[k].fn;
		func && (exports.functions[k].fn = function() {
			var counter = (funcCounters[k] = funcCounters[k] || {
				execute: 0,
				millis: 0
			});
			counter.execute++;
			var t0 = Date.now();
			var result = func.apply(this, arguments);
			counter.millis += Date.now() - t0;
			return result;
		});
	});
};

exports.dumpCounters = function() {
	console.log("*** INSTRUCTIONS ***");
	Object.keys(instCounters).sort(function(k1, k2) {
		return instCounters[k2].selfMillis - instCounters[k1].selfMillis;
	}).forEach(function(k) {
		var counter = instCounters[k];
		console.log([k] + '\t' + counter.selfMillis + '\t' + counter.allMillis + '\t' + counter.execute + '\t' + counter.compile);
	});
	console.log("*** FUNCTIONS ***");
	Object.keys(funcCounters).sort(function(k1, k2) {
		return funcCounters[k2].millis - funcCounters[k1].millis;
	}).forEach(function(k) {
		var counter = funcCounters[k];
		console.log([k] + '\t' + counter.millis + '\t' + counter.execute);
	});
};