"use strict";

var config = require("etna-util/lib/nodeconfig").config.etna;

config = config || {};
var glob = require('streamline/lib/globals');
var fs = require('streamline-fs');
var register = require("etna-engine/lib/register");

var Parser = require("etna-engine/lib/parser").Parser;
var jsgen = require('etna-engine/lib/jsgen');
var version = require('etna-engine/lib/version').version;

var modules = ['arrays', 'dates', 'db', 'evaluate', 'fileio', 'flowControl', 'misc', 'numbers', 'operators', 'stats', 'strings', 'system', 'util', 'variables', 'tbcd', 'uuid', 'tblbfile'].map(function(name) {
	return require('./' + name);
});
var util = require('./util');
var variables = require('./variables');

function collect(key) {
	exports[key] = {};
	modules.forEach(function(mod) {
		mod[key] && Object.keys(mod[key]).forEach(function(k) {
			if (exports[key][k]) throw new Error("duplicate definition of " + key + " " + k);
			//console.log(key + "/" + k)
			exports[key][k] = mod[key][k];
		});
	});
}

collect('functions');
collect('instructions');

exports.requireScript = function(_, name) {
	var frame = glob.context.x3frame;
	var files;
	if (!exports.requireScript.builtins) {
		exports.requireScript.builtins = {};

		files = fs.readdir(__dirname + "/../../../etna-supervisor/lib/builtins/", _);
		files.filter(function(file) {
			return file.length == (4 + file.lastIndexOf("._js"));
		}).forEach_(_, function(_, file, i) {
			exports.requireScript.builtins[file.substring(0, file.lastIndexOf("._js"))] = __dirname + "/../../../etna-supervisor/lib/builtins/" + file;

		});
	}

	if (!exports.requireScript.nodeScript) {
		exports.requireScript.nodeScript = {};

		files = fs.readdir(__dirname + "/../../../etna-engine/test/server/", _);
		files.filter(function(file) {
			return file.length == (4 + file.lastIndexOf(".src"));
		}).forEach_(_, function(_, file, i) {
			exports.requireScript.nodeScript[file.substring(0, file.lastIndexOf(".src"))] = __dirname + "/../../../etna-engine/test/server/" + file;
		});
	}

	/*	if(!exports.requireScript.serverScript) {
		exports.requireScript.serverScript = {};

        var trtdir = (frame.context.superv.solutionPath+'/'+frame.context.superv.folderName+"/TRT/").replace(/\\/g, '/') ;
        files = fs.readdir(trtdir, _); // "W:\\SUPERV\\TRT\\"
		files.filter(function(file) {
			return file.length == (4+file.lastIndexOf(".src"));
		}).forEach_(_, function(_, file, i) {	
			exports.requireScript.serverScript[file.substring(0,file.lastIndexOf(".src"))] = trtdir+file;			
		});
	}*/

	//console.log("config " + config.folderName+"  ")+config.solutionPath;
	exports.requireScript.scripts = exports.requireScript.scripts || {};

	if (exports.requireScript.scripts[name]) return exports.requireScript.scripts[name];

	if (exports.requireScript.builtins[name]) {
		exports.requireScript.scripts[name] = require(exports.requireScript.builtins[name]);
		return exports.requireScript.scripts[name];
	}

	if (exports.requireScript.nodeScript[name]) {
		exports.requireScript.scripts[name] = require(exports.requireScript.nodeScript[name]);
		return exports.requireScript.scripts[name];
	}

	// Is it a script stored on the shared folder ?
	var trtdir = (frame.context.superv.solutionPath + '/' + frame.context.superv.folderName + "/TRT/").replace(/\\/g, '/');
	var path = trtdir + name + ".src";

	if (fs.exists(path, _)) {
		// Yes, it is :
		var banner = "/* Generated by etna " + version + " -- DO NOT EDIT */";
		var source = fs.readFileSync(path, 'utf8');
		var parsed = new Parser(source, path).parse();
		var transformed = banner + jsgen.generate(parsed.node, path);

		var cpath = __dirname + "/../../trt/" + name + ".js";
		register.mkdirsSync(cpath);
		fs.writeFileSync(cpath, transformed, "utf8");
		//dbg:console.log("cpath:"+cpath);
		exports.requireScript.scripts[name] = require(cpath);
		return exports.requireScript.scripts[name];

		// var path = path.replace(/\\/g, '/');
		// var cpath = __dirname + "/../../../etna-engine/test/tmp/" + name + ".src";
		// register.mkdirsSync(cpath);
		// var source = fs.readFile(path, "utf8", _);
		// fs.writeFileSync(cpath, source, "utf8");
		// exports.requireScript.scripts[name] = require(cpath);
		// return exports.requireScript.scripts[name];
	}

	exports.requireScript.scripts[name] = require(name);
	return exports.requireScript.scripts[name];
};

var runtime = require('streamline/lib/globals').runtime;

function fastFn(fn) {
	var ffn;
	switch (runtime) {
		case 'fibers-fast':
		case 'generators-fast':
		case 'callbacks':
			ffn = fn;
			break;
		case 'fibers':
			ffn = fn.fstreamlineFunction;
			break;
		case 'generators':
			ffn = fn.__starred__0;
			break;
		default:
			throw new Error("bad streamline runtime: " + runtime);
	}
	if (!ffn) throw new Error("bad streamline function: " + fn.name);
	return ffn;
}

// TODO: improve - we need to wrap to trace instructions but we don't need it to trace calls/funcs
function initTraces() {
	var indent = "";

	function traceCall(_, action, arg) {
		var frame = glob.context.x3frame;
		var loc = frame.prev.sub.loc;
		if (!config.traceCallRE.test(loc.module + ((frame.prog && (':' + frame.prog.name)) || ""))) return;
		if (action === "exit") indent = indent.substring(0, indent.length - 2);
		console.log(indent + loc.file.substring(loc.file.lastIndexOf("\\") + 1) + ':' + loc.line + ': ' + action + ' ' + frame.prog.name + (arg ? ": " + arg : ""));
		if (action === "enter") indent += "  ";
	}

	function traceFunc(_, action, arg) {
		var frame = glob.context.x3frame;
		var loc = frame.sub.loc;
		if (!config.traceFuncRE.test(loc.module + ((frame.prog && (':' + frame.prog.name)) || "") + ':' + frame.fcall)) return;
		console.log(indent + loc.file.substring(loc.file.lastIndexOf("\\") + 1) + ':' + loc.line + ': ' + action + ' ' + frame.fcall + (arg ? ": " + arg : ""));
	}

	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		exports.instructions[k] = function traceWrapper() {
			var instArgs = Array.prototype.slice.call(arguments);
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			fn = fastFn(fn);
			var loc = util.sourceLoc;
			return function(_) {
				var frame = glob.context.x3frame;
				if (config.traceCallRE) frame.context.traceCall = traceCall;
				if (config.traceFuncRE) frame.context.traceFunc = traceFunc;
				frame.sub.loc = loc;
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				return fn.apply(this, arguments);
			};
		};
	});
}

if (config.traceCallRE || config.traceFuncRE) initTraces();

function millis(nanos) {
	return nanos / 1000000;
}

function nanos(hr) {
	return hr[0] * 1e9 + hr[1];
}

var instCounters = {};
var curInstCounter = {
	hr: process.hrtime()
};

function initInstructionMonitoring() {
	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		var counter = instCounters[k] = {
			name: k,
			hits: 0,
			hr: null,
			nanos: 0,
		};
		exports.instructions[k] = function perfmonWrapper() {
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			var instName = fn.instName;
			if (instName) {
				instCounters[instName] = {
					name: "F(" + instName + ")",
					hits: 0,
					hr: null,
					nanos: 0,
				};
			}
			fn = fastFn(fn);
			return function(_) {
				var prevCounter = curInstCounter;
				prevCounter.nanos += nanos(process.hrtime(prevCounter.hr));
				curInstCounter = counter;
				counter.hits++;
				counter.hr = process.hrtime();
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				try {
					return fn.apply(this, arguments);
				} finally {
					var time = nanos(process.hrtime(counter.hr));
					curInstCounter = prevCounter;
					prevCounter.hr = process.hrtime();
					if (instName) {
						instCounters[instName].hits += 1;
						instCounters[instName].nanos += time;
					} else {
						counter.nanos += time;
					}

				}
			};
		};
	});
}

function _dumpInstructionCounters() {
	function padL(a, b) {
		return (new Array(b + 1).join(" ") + a).slice(-b);
	}

	var counters = Object.keys(instCounters).map(function(k) {
		return instCounters[k];
	}).filter(function(c) {
		return c.hits;
	}).sort(function(c1, c2) {
		return c2.nanos - c1.nanos;
	}).map(function(c) {
		return 'total (ms): ' + millis(c.nanos) + '\thits: ' + padL(c.hits, 9) + '\tcost (ns):' + padL(Math.round(c.nanos / c.hits, 2), 9) + '\t' + c.name;
	});
	console.log(counters.join('\n'));
	instCounters = {};
}

function _razInstructionCounters() {
	Object.keys(instCounters).forEach(function(c) {
		instCounters[c].nanos = 0;
		instCounters[c].hits = 0;
	});
}

if (config.monitorInstructions) {
	initInstructionMonitoring();
	process.on('exit', _dumpInstructionCounters);
}

var callCounters = {};
var curCallCounter = null;

function initCallMonitoring() {
	require('./flowControl').monitorCall = function(frame, action) {
		var key = frame.loc.file + ':' + frame.prog.name;
		var counter = callCounters[key] = callCounters[key] || {
			name: key,
			hits: 0,
			hr: null,
			nanos: 0,
			selfNanos: 0,
		};
		if (action === "enter") {
			if (curCallCounter) curCallCounter.selfNanos += nanos(process.hrtime(curCallCounter.hr));
			curCallCounter = counter;
			counter.hits++;
			counter.hr = process.hrtime();
		} else if (action === "exit") {
			counter.nanos += nanos(process.hrtime(counter.hr));
			counter.hr = process.hrtime(); // in case we got reentered.
		}
	};
}

function dumpCallCounters() {
	var counters = Object.keys(callCounters).map(function(k) {
		return callCounters[k];
	}).filter(function(c) {
		return c.hits;
	}).sort(function(c1, c2) {
		return c2.selfNanos - c1.selfNanos;
	}).map(function(c) {
		return 'self (ms): ' + millis(c.selfNanos) + '\ttotal (ms): ' + millis(c.nanos) + '\thits: ' + c.hits + //
		'\tcost (ns):' + Math.round(c.selfNanos / c.hits, 2) + '\t' + c.name;
	});
	console.log(counters.join('\n'));
}

if (config.monitorCalls) {
	initCallMonitoring();
	process.on('exit', dumpCallCounters);
}

var hr0 = process.hrtime();

function dumpTotalTime() {
	console.log("Total millis: " + millis(nanos(process.hrtime(hr0))));
}

if (config.monitorInstructions || config.monitorCalls) process.on('exit', dumpTotalTime);

exports.exit = function(code) {
	if (config.monitorInstructions) {
		_dumpInstructionCounters();
		_razInstructionCounters();
	}
	if (config.monitorCalls) dumpCallCounters();

	if (config.monitorInstructions || config.monitorCalls) dumpTotalTime();

	if (process.stdout.write("")) {
		//process.exit(0);
		setTimeout(function() {
			process.exit(0);
		}, 100);
	} else {
		process.stdout.on('drain', function() {
			process.exit(0);
		});
		process.stdout.write("");
	}
};

exports.executeProg = function(_, mod, prog, args) {
	var frame = glob.context.x3frame;
	var prev = frame;
	var cx = prev.context;

	glob.context.x3frame = frame = {
		values: {},
		types: {},
		context: cx,
		prev: prev,
		loopLevel: 0,
		name: mod.name,
		loc: {
			file: mod.name,
			line: 0
		}
	};
	// current sub is the prog itself
	frame.sub = frame;
	frame.dicts = [frame, cx.globals, cx.sys];

	try {
		Object.keys(args).forEach(function(name) {
			frame.values[name] = args[name].value;
			frame.types[name] = args[name].type;
		});
		//SUBPROG

		if (prog.indexOf("$") < 0) {
			mod[prog].body(_);
		} else { //ACTION must have $in the name
			var label = prog.substr(1);
			if (frame.values["ACTION"]) frame.values["ACTION"] = frame.values["ACTION"].substr(1);
			var ex = mod[label] || mod.body[label];
			ex(_);
		}
		Object.keys(args).forEach(function(name) {
			if (args[name].type.charAt(0) === 'A') {
				args[name].value = frame.values[name];
			}
		});
	} finally {
		glob.context.x3frame = prev;
	}
};


exports.dumpInstructionCounters = _dumpInstructionCounters;
exports.razInstructionCounters = _razInstructionCounters;