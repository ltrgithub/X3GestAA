"use strict";

var config = require('../../../../nodelocal').config.etna;
config = config || {};
var glob = require('streamline/lib/globals');
var fs = require('streamline-fs');

var modules = ['arrays', 'dates', 'db', 'evaluate', 'fileio', 'flowControl', 'misc', 'numbers', 'operators', 'stats', 'strings', 'system', 'util', 'variables', 'bcd'].map(function(name) {
	return require('./' + name);
});
var util = require('./util');
var variables = require('./variables');

function collect(key) {
	exports[key] = {};
	modules.forEach(function(mod) {
		mod[key] && Object.keys(mod[key]).forEach(function(k) {
			if (exports[key][k]) throw new Error("duplicate definition of " + key + " " + k);
			//console.log(key + "/" + k)
			exports[key][k] = mod[key][k];
		});
	});
}

collect('functions');
collect('instructions');

var builtins;
var scripts = {};
exports.requireScript = function(_, name) {
	if(!builtins) {
		builtins = {};
		var files = fs.readdir(__dirname + "/../../../etna-supervisor/lib/builtins/", _);
		files.filter(function(file) {
			return file.length == (4+file.lastIndexOf("._js"));
		}).forEach_(_, function(_, file, i) {
			builtins[file.substring(0,file.lastIndexOf("._js"))] = __dirname + "/../../../etna-supervisor/lib/builtins/"+file;
			
		});
	}

	if(scripts[name]) return scripts[name]

	if(builtins[name]) {
		scripts[name] = require(builtins[name]);
		return scripts[name]
	}
	scripts[name] = require(name);
	return scripts[name];
}

var runtime = require('streamline/lib/globals').runtime;

function fastFn(fn) {
	var ffn;
	switch (runtime) {
		case 'fibers-fast':
		case 'generators-fast':
		case 'callbacks':
			ffn = fn;
			break;
		case 'fibers':
			ffn = fn.fstreamlineFunction;
			break;
		case 'generators':
			ffn = fn.__starred__0;
			break;
		default:
			throw new Error("bad streamline runtime: " + runtime);
	}
	if (!ffn) throw new Error("bad streamline function: " + fn.name);
	return ffn;
}

// TODO: improve - we need to wrap to trace instructions but we don't need it to trace calls/funcs
function initTraces() {
	var indent = "";

	function traceCall(_, action, arg) {
		var frame = glob.context.x3frame;
		var loc = frame.prev.sub.loc;
		if (!config.traceCallRE.test(loc.module + ':' + frame.prog.name)) return;
		if (action === "exit") indent = indent.substring(0, indent.length - 2);
		console.log(indent + loc.file.substring(loc.file.lastIndexOf("\\")+1) + ':' + loc.line + ': ' + action + ' ' + frame.prog.name + (arg ? ": " + arg:""));
		if (action === "enter") indent += "  ";
	}

	function traceFunc(_, action, arg) {
		var frame = glob.context.x3frame;
		var loc = frame.sub.loc;
		if (!config.traceFuncRE.test(loc.module + ':' + frame.prog.name + ':' + frame.fcall)) return;
		console.log(indent + loc.file.substring(loc.file.lastIndexOf("\\")+1) + ':' + loc.line + ': ' + action + ' ' + frame.fcall + (arg ? ": " + arg:""));
	}

	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		exports.instructions[k] = function traceWrapper() {
			var instArgs = Array.prototype.slice.call(arguments);
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			fn = fastFn(fn);
			var loc = util.sourceLoc;
			return function(_) {
				var frame = glob.context.x3frame;
				if (config.traceCallRE) frame.context.traceCall = traceCall;
				if (config.traceFuncRE) frame.context.traceFunc = traceFunc;
				frame.sub.loc = loc;
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				return fn.apply(this, arguments);
			}
		}
	});
}

if (config.traceCallRE || config.traceFuncRE) initTraces();

function millis(nanos) {
	return nanos / 1000000;
}
function nanos(hr) {
	return hr[0] * 1e9 + hr[1];
}

var instCounters = {};
var curInstCounter = { hr: process.hrtime() };

function initInstructionMonitoring() {
	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		var counter = instCounters[k] = {
			name: k,
			hits: 0,
			hr: null,
			nanos: 0,
		};
		exports.instructions[k] = function perfmonWrapper() {
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			fn = fastFn(fn);
			return function(_) {
				var prevCounter = curInstCounter;
				prevCounter.nanos += nanos(process.hrtime(prevCounter.hr));
				curInstCounter = counter;
				counter.hits++;
				counter.hr = process.hrtime();
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				try {
					return fn.apply(this, arguments);
				} finally {
					counter.nanos += nanos(process.hrtime(counter.hr));
					curInstCounter = prevCounter;
					prevCounter.hr = process.hrtime();
				}
			}
		}
	});	
}

function dumpInstructionCounters() {
	var counters = Object.keys(instCounters).map(function(k) {
		return instCounters[k];
	}).filter(function(c) {
		return c.hits;
	}).sort(function(c1, c2) {
		return c2.nanos - c1.nanos;
	}).map(function(c) {
		return 'total (ms): ' + millis(c.nanos) + '\thits: ' + c.hits + '\tcost (ns):' + Math.round(c.nanos / c.hits, 2) + '\t' + c.name;
	});
	console.log(counters.join('\n'))
}

if (config.monitorInstructions) {
	initInstructionMonitoring();
	process.on('exit', dumpInstructionCounters);
}

var callCounters = {};
var curCallCounter = null;

function initCallMonitoring() {
	require('./flowControl').monitorCall = function(frame, action) {
		var key = frame.loc.file + ':' + frame.prog.name;
		var counter = callCounters[key] = callCounters[key] || {
			name: key,
			hits: 0,
			hr: null,
			nanos: 0,
			selfNanos: 0,
		};
		if (action === "enter") {
			if (curCallCounter) curCallCounter.selfNanos +=  nanos(process.hrtime(curCallCounter.hr));
			curCallCounter = counter;
			counter.hits++;
			counter.hr = process.hrtime();
		} else if (action === "exit") {
			counter.nanos += nanos(process.hrtime(counter.hr));
			counter.hr = process.hrtime(); // in case we got reentered.
		}
	}
}

function dumpCallCounters() {
	var counters = Object.keys(callCounters).map(function(k) {
		return callCounters[k];
	}).filter(function(c) {
		return c.hits;
	}).sort(function(c1, c2) {
		return c2.selfNanos - c1.selfNanos;
	}).map(function(c) {
		return 'self (ms): ' + millis(c.selfNanos) + '\ttotal (ms): ' + millis(c.nanos) + '\thits: ' + c.hits + //
		'\tcost (ns):' + Math.round(c.selfNanos / c.hits, 2) + '\t' + c.name;
	});
	console.log(counters.join('\n'));
}

if (config.monitorCalls) {
	initCallMonitoring();
	process.on('exit', dumpCallCounters);
}

var hr0 = process.hrtime();
function dumpTotalTime() {
	console.log("Total millis: " + millis(nanos(process.hrtime(hr0))));
}

if (config.monitorInstructions || config.monitorCalls) process.on('exit', dumpTotalTime);

exports.exit = function(code) {
	if(config.monitorInstructions) dumpInstructionCounters();
	if(config.monitorCalls) dumpCallCounters();
	if(config.monitorInstructions || config.monitorCalls) dumpTotalTime();

	process.stdout.on('drain',function(){
		process.exit(0);
	});
	console.log("");
}
