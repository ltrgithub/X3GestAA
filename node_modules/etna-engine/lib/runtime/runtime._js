"use strict";

var config = require('../../../../nodelocal').config.etna;
config = config || {};

var modules = ['arrays', 'dates', 'db', 'evaluate', 'fileio', 'flowControl', 'misc', 'numbers', 'operators', 'stats', 'strings', 'system', 'util', 'variables'].map(function(name) {
	return require('./' + name);
});
var util = require('./util');
var variables = require('./variables');

function collect(key) {
	exports[key] = {};
	modules.forEach(function(mod) {
		mod[key] && Object.keys(mod[key]).forEach(function(k) {
			if (exports[key][k]) throw new Error("duplicate definition of " + key + " " + k);
			//console.log(key + "/" + k)
			exports[key][k] = mod[key][k];
		});
	});
}

collect('functions');
collect('instructions');

var runtime = require('streamline/lib/globals').runtime;

function fastFn(fn) {
	var ffn;
	switch (runtime) {
		case 'fibers-fast':
		case 'generators-fast':
		case 'callbacks':
			ffn = fn;
			break;
		case 'fibers':
			ffn = fn.fstreamlineFunction;
			break;
		case 'generators':
			ffn = fn.__starred__0;
			break;
		default:
			throw new Error("bad streamline runtime: " + runtime);
	}
	if (!ffn) throw new Error("bad streamline function: " + fn.name);
	return ffn;
}

// TODO: improve - we need to wrap to trace instructions but we don't need it to trace calls/funcs
function initTraces() {
	var indent = "";

	function traceCall(_, frame, action, arg) {
		var loc = frame.prev.sub.loc;
		if (!config.traceCallRE.test(loc.module + ':' + frame.name)) return;
		if (action === "exit") indent = indent.substring(0, indent.length - 2);
		console.log(indent + loc.module + ':' + loc.line + ': ' + action + ' ' + frame.name + ": " + arg);
		if (action === "enter") indent += "  ";
	}

	function traceFunc(_, frame, action, arg) {
		var loc = frame.sub.loc;
		if (!config.traceFuncRE.test(loc.module + ':' + frame.name + ':' + frame.fcall)) return;
		console.log(indent + loc.module + ':' + loc.line + ': ' + action + ' ' + frame.fcall + ": " + arg);
	}

	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		exports.instructions[k] = function traceWrapper() {
			var instArgs = Array.prototype.slice.call(arguments);
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			fn = fastFn(fn);
			var loc = util.sourceLoc;
			return function(_, frame) {
				if (config.traceCallRE) frame.context.traceCall = traceCall;
				if (config.traceFuncRE) frame.context.traceFunc = traceFunc;
				frame.sub.loc = loc;
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				return fn.apply(this, arguments);
			}
		}
	});
}

if (config.traceCallRE || config.traceFuncRE) initTraces();

function millis(nanos) {
	return nanos / 1000000;
}
function nanos(hr) {
	return hr[0] * 1000 * 1000 * 1000 + hr[1];
}

var instCounters = {};
var curInstCounter = null;

function initInstructionMonitoring() {
	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		var counter = instCounters[k] = {
			name: k,
			hits: 0,
			hr: null,
			nanos: 0,
		};
		exports.instructions[k] = function perfmonWrapper() {
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			fn = fastFn(fn);
			return function(_, frame) {
				if (curInstCounter) curInstCounter.nanos += nanos(process.hrtime(curInstCounter.hr));
				curInstCounter = counter;
				counter.hits++;
				counter.hr = process.hrtime();
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				return fn.apply(this, arguments);
			}
		}
	});	
}

function dumpInstructionCounters() {
	var counters = Object.keys(instCounters).map(function(k) {
		return instCounters[k];
	}).filter(function(c) {
		return c.hits;
	}).sort(function(c1, c2) {
		return c2.nanos - c1.nanos;
	}).map(function(c) {
		return 'total (ms): ' + millis(c.nanos) + '\thits: ' + c.hits + '\tcost (ns):' + Math.round(c.nanos / c.hits, 2) + '\t' + c.name;
	});
	console.log(counters.join('\n'))
}

if (config.monitorInstructions) {
	initInstructionMonitoring();
	process.on('exit', dumpInstructionCounters);
}

var callCounters = {};
var curCallCounter = null;

function initCallMonitoring() {
	require('./flowControl').monitorCall = function(frame, action) {
		var key = frame.loc.file + ':' + frame.name;
		var counter = callCounters[key] = callCounters[key] || {
			name: key,
			hits: 0,
			hr: null,
			nanos: 0,
			selfNanos: 0,
		};
		if (action === "enter") {
			if (curCallCounter) curCallCounter.selfNanos +=  nanos(process.hrtime(curCallCounter.hr));
			curCallCounter = counter;
			counter.hits++;
			counter.hr = process.hrtime();
		} else if (action === "exit") {
			counter.nanos += nanos(process.hrtime(counter.hr));
			counter.hr = process.hrtime(); // in case we got reentered.
		}
	}
}

function dumpCallCounters() {
	var counters = Object.keys(callCounters).map(function(k) {
		return callCounters[k];
	}).filter(function(c) {
		return c.hits;
	}).sort(function(c1, c2) {
		return c2.selfNanos - c1.selfNanos;
	}).map(function(c) {
		return 'self (ms): ' + millis(c.selfNanos) + '\ttotal (ms): ' + millis(c.nanos) + '\thits: ' + c.hits + //
		'\tcost (ns):' + Math.round(c.selfNanos / c.hits, 2) + '\t' + c.name;
	});
	console.log(counters.join('\n'));
}

if (config.monitorCalls) {
	initCallMonitoring();
	process.on('exit', dumpCallCounters);
}

var hr0 = process.hrtime();
function dumpTotalTime() {
	console.log("Total millis: " + millis(nanos(process.hrtime(hr0))));
}

if (config.monitorInstructions || config.monitorCalls) process.on('exit', dumpTotalTime);
