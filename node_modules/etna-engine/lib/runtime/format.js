"use strict";
var errors = require('./errors');
var X3Error = errors.X3Error;
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');

function _isLower(ch) {
	return ch >= 'a' && ch <= 'z';
}

function _isUpper(ch) {
	return ch >= 'A' && ch <= 'Z';
}

function _isDigit(ch) {
	return ch >= '0' && ch <= '9';
}

function _isHexa(ch) {
	return (ch >= 'A' && ch <= 'F') || (ch >= '0' && ch <= '9');
}

function _fmtInt(val, rep) {
	var s = val.toString();
	while (s.length < rep)
	s = "0" + s;
	return s;
}

var _months3 = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

function _monthName(month, rep) {
	// for now, get it from JS resource and capitalize (wrong for French!)
	var s = date.monthName(month);
	s = s[0].toUpperCase() + s.substring(1);
	while (s.length < rep)
	s += ' ';
	return s.length > rep ? s.substring(0, len) : s;
}

exports.format = function(frame, fmt, val, trimFuncs) {
	var options = {},
	i = 0,
		ch, rep;
	var valid = true,
		bad = ' ';
	var len = fmt.length,
		j = 0,
		result = "",
		pwc, now, integ, decim = "",
		tail = "",
		cur, n3 = 0;
	var special = frame.context.sys.values.ADXSCA;

	var formatters = {
		K: function() {
			for (; rep > 0; rep--) {
				var vch = val[j++];
				var defined = vch != null;
				vch = vch || ' ';
				switch (ch) {
					case 'X':
						break;
					case 'A':
						if (!_isUpper(vch)) {
							if (_isLower(vch) && !options.A) vch = vch.toUpperCase();
							else valid = false;
						}
						break;
					case 'a':
						if (!_isLower(vch)) {
							if (_isUpper(vch) && !options.A) vch = vch.toLowerCase();
							else valid = false;
						}
						break;
					case 'B':
						if (!_isUpper(vch) && !_isDigit(vch)) {
							if (_isLower(vch) && !options.A) vch = vch.toUpperCase();
							else valid = false;
						}
						break;
					case 'b':
						if (!_isLower(vch) && !_isDigit(vch)) {
							if (_isUpper(vch) && !options.A) vch = vch.toLowerCase();
							else valid = false;
						}
						break;
					case 'C':
						if (!_isLower(vch) && !_isUpper(vch) && !_isDigit(vch)) {
							valid = false;
						}
						break;
					case 'L':
						if (!_isLower(vch) && !_isUpper(vch)) {
							valid = false;
						}
						break;
					case 'H':
						if (!_isHexa(vch)) {
							valid = false;
						}
						break;
					case ' ':
						if (ch !== ' ') {
							valid = false;
						}
						break;
					case '#':
						if (!_isDigit(vch)) {
							valid = false;
						}
						break;
					default:
						throw new X3Error(5, "bad format character: " + ch);
				}
				if (pwc && defined) vch = pwc;
				result += vch;
			}
		},
		N: function() {
			if (cur !==null && ch != '#') {
				ch = '#';
				i--; // backtrack
			}
			switch (ch) {
				case '#':
					if (cur === integ) {
						// allow thousand seps can overflow (weird!)
						rep += n3;
						if (cur.length < rep) {
							var fill = options['*'] ? special[5] : options['0'] ? '0' : ' ';
							if (fill === '0' && cur[0] === '-') {
								result += '-';
								cur = cur.substring(1);
								rep--;
							}
							while (cur.length < rep--)
							result += fill;
							result += cur;
						} else if (cur.length === rep) {
							result += cur;
						} else {
							result += cur.substring(0, rep);
							valid = false;
						}
						cur = null;
					} else if (cur === decim) {
						if (cur.length < rep) {
							// X3 engine does not follow spec: Z option is now set by default
							var fill = '0'; //options['Z'] ? '0' : ' ';
							result += cur;
							while (cur.length < rep--)
							result += fill;

						} else {
							result += cur.substring(0, rep);
						}
						cur = null;
					} else {
						throw new X3Error(5, "too many # directives in format");
					}
					break;
				case '.':
					result += special[3];
					cur = decim;
					break;
				default:
					throw new X3Error(5, "bad format character: " + ch);

			}
		},
		D: function() {
			switch (ch) {
				case 'D':
					result += _fmtInt(val.day, rep);
					break;
				case 'M':
					if (rep <= 2) {
						result += _fmtInt(val.month, rep);
					} else if (rep === 3) {
						result += _months3[val.month - 1];
					} else {
						result += _monthName(val.month, rep);
					}
					break;
				case 'Y':
					result += _fmtInt(rep <= 2 ? val.year % 100 : val.year, rep);
					break;
				case 'h':
					result += _fmtInt((now = now || datetime.now()).hour, rep);
					break;
				case 'm':
					result += _fmtInt((now = now || datetime.now()).minute, rep);
					break;
				case 's':
					result += _fmtInt((now = now || datetime.now()).second, rep);
					break;
				default:
					throw new X3Error(5, "bad format character: " + ch);
			}
		},
		L: function() {
			result += "?";
		}
	};

	var tch = fmt[0];
	var fn = formatters[tch];
	if (fn) {
		for (i = 1; i < fmt.length && (ch = fmt[i]) !== ':'; i++) {
			switch (ch) {
				case 'v':
					options.v = parseInt(fmt[++i]);
					break;
				default:
					options[ch] = true;
					break;
			}
		}
		i++;
	} else {
		fn = formatters.K;
	}
	if (tch === 'N') {
		integ = val.toString();
		// TODO: handle scientific format
		var dot = integ.indexOf('.');
		if (dot >= 0) {
			decim = integ.substring(dot + 1);
			integ = integ.substring(0, dot);
		}
		if (integ[0] === '-' || integ[0] === '+') {
			if (options.D) {
				tail = integ[0];
				integ = integ.substring(1);
			}
		} else {
			if (options['-']) {
				if (options.D) tail = '+';
				else integ = '+' + integ;
			}
		}
		if (options["3"]) {
			// insert thousand separators
			n3 = (integ.length - (integ[0] === '_') - 1) / 3;
			for (var k = 0; k < n3; k++) {
				var l = integ.length - 4 * k - 3;
				integ = integ.substring(0, l) + special[2] + integ.substring(l);
			}
		}
		cur = integ;
		bad = special[4];
	}
	pwc = options.X && special[5];
	while (i < len) {
		var beg = i,
			ch;
		if ((ch = fmt[i]) === '[') {
			i = fmt.indexOf(']', i + 1);
			if (i < 0) i = len;
			result += fmt.substring(beg + 1, i);
			i++;
			continue;
		}
		while ((ch = fmt[i]) >= '0' && ch <= '9')
		i++;
		rep = i > beg ? parseInt(fmt.substring(beg, i), 10) : 1;
		while (ch && ch === fmt[i + 1]) {
			i++;
			rep++;
		}
		i++;
		fn.call(this);
	}
	if (tail) result += tail;
	if (!valid) result = result.replace(fmt[0] == 'N'?/[0-9]/g : /./g, bad);
	var trim = trimFuncs[options.v];
	return trim ? trim(result) : result;
};