"use strict";
var errors = require('./errors');
var X3Error = errors.X3Error;
var date     = require('etna-engine/lib/runtime/tdate') ;
var datetime = require('etna-engine/lib/runtime/tdatetime') ;
var tdouble  = require('./tdouble') ;
var x3Trim = require('etna-engine/lib/runtime/util').x3Trim ;
var util 	 = require('./util');
var locale   = require("syracuse-core/lib/locale");
var resources = locale.resources(module);
var numbers   = require('etna-engine/lib/runtime/numbers') ;


function _isLower(ch) {
	return ch >= 'a' && ch <= 'z';
}

function _isUpper(ch) {
	return (ch >= 'A' && ch <= 'Z') || ch == ' ';
}

function _isDigit(ch) {
	return ch >= '0' && ch <= '9';
}

function _isHexa(ch) {
	return (ch >= 'A' && ch <= 'F') || (ch >= '0' && ch <= '9');
}

function _fmtInt(val, rep) {
	var s = val.toString();
	while (s.length < rep)
	s = "0" + s;
	return s;
}

var _months3 = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

function _monthName(month, rep) {
	// for now, get it from JS resource and capitalize (wrong for French!)
	var s = date.monthName(month) || ' ';
	s = s[0].toUpperCase() + s.substring(1);
	while (s.length < rep)
	s += ' ';
	return s.length > rep ? s.substring(0, len) : s;
}

exports.format = function(frame, $fmt, $val ) {
	/*dbg*/////console.log("format fmt:"+$fmt+" val:"+$val);
	var val = $val;//local copy for making it possible to write val = '';
	var fmt = $fmt;
	if(fmt.indexOf(':') < 0) {
		if(util.x3IsDate(val) || util.x3IsDatetime(val)) {
			fmt = resources()[fmt] || fmt;
		} else {
			fmt = "K:" + fmt;
		}
	}
	var options = {},
	i = 0,
		ch, rep;
	var valid = true,
		bad = ' ';
	var len = fmt.length,
		j = 0,
		result = "",
		pwc, now, integ, decim = "",
		tail = "",
		cur, n3 = 0;
	var special = frame.context.sys.values.adxsca;

	var isDigit;
	var formatters = {
		K: function() {
			if(!util.x3IsString(val)) val = "";

			for (; rep > 0; rep--) {
				var vch = val[j++];
				var defined = vch != null;
				vch = vch || ' ';
				switch (ch) {
					case 'X':
						break;
					case 'A':
						if (!_isUpper(vch)) {
							if (_isLower(vch) && !options.A) vch = vch.toUpperCase();
							else valid = false;
						}
						break;
					case 'a':
						if (!_isLower(vch)) {
							if (_isUpper(vch) && !options.A) vch = vch.toLowerCase();
							else valid = false;
						}
						break;
					case 'B':
						if (!_isUpper(vch) && !_isDigit(vch)) {
							if (_isLower(vch) && !options.A) vch = vch.toUpperCase();
							else valid = false;
						}
						break;
					case 'b':
						if (!_isLower(vch) && !_isDigit(vch)) {
							if (_isUpper(vch) && !options.A) vch = vch.toLowerCase();
							else valid = false;
						}
						break;
					case 'C':
						if (!_isLower(vch) && !_isUpper(vch) && !_isDigit(vch)) {
							valid = false;
						}
						break;
					case 'L':
						if (!_isLower(vch) && !_isUpper(vch)) {
							valid = false;
						}
						break;
					case 'H':
						if (!_isHexa(vch)) {
							valid = false;
						}
						break;
					case ' ':
						if (ch !== ' ') {
							valid = false;
						}
						break;
					case '#':
						isDigit = isDigit || _isDigit(vch);
						if (!isDigit) {
							valid = false;
						}
						break;
					default:
						throw new X3Error(5, "bad format character: " + ch);
				}
				if (pwc && defined) vch = pwc;
				result += vch;
			}
		},
		N: function() {
			if(!val.x3IsNumeric()) return;
			if (cur !==null && '#F'.indexOf(ch) < 0 ) {
				ch = '#';
				i--; // backtrack
			}
			switch (ch) {
				case '#':
					if (cur === integ) {
						// allow thousand seps can overflow (weird!)
						rep += n3;
						if (cur.length < rep) {
							var fill = options['*'] ? special[5] : options['0'] ? '0' : ' ';
							if (fill === '0' && cur[0] === '-') {
								result += '-';
								cur = cur.substring(1);
								rep--;
							}
							while (cur.length < rep--)
							result += fill;
							result += cur;
						} else if (cur.length === rep) {
							result += cur;
						} else {
							result += cur.substring(0, rep);
							valid = false;
						}
						cur = null;
					} else if (cur === decim) {
						if (cur.length < rep) {
							// X3 engine does not follow spec: Z option is now set by default
							var fill = '0'; //options['Z'] ? '0' : ' ';
							result += cur;
							while (cur.length < rep--)
							result += fill;

						} else {
							result += cur.substring(0, rep);
						}
						cur = null;
					} else {
						throw new X3Error(5, "too many # directives in format");
					}
					break;
				case '.':
					result += special[3];
					cur = decim;
					break;

				default:
					throw new X3Error(5, "bad format character: " + ch);

			}
		},
		D: function() {
			switch (ch) {
				case 'D':
					result += _fmtInt(val.day, rep);
					break;
				case 'M':
					if (rep <= 2) {
						result += _fmtInt(val.month, rep);
					} else if (rep === 3) {
						result += _months3[val.month - 1];
					} else {
						result += _monthName(val.month, rep);
					}
					break;
				case 'Y':
					result += _fmtInt(rep <= 2 ? val.year % 100 : val.year, rep);
					break;
				case 'h':
					result += _fmtInt(val.hour || (now = now || datetime.now()).hour, rep);
					break;
				case 'm':
					result += _fmtInt(val.minute || (now = now || datetime.now()).minute, rep);
					break;
				case 's':
					result += _fmtInt(val.second || (now = now || datetime.now()).second, rep);
					break;
				default:
					throw new X3Error(5, "bad format character: " + ch);
			}
		},
		L: function() {
			result += "?";
		}
	};

	var tch = fmt[0];
	var fn = formatters[tch];
	if (fn) {
		for (i = 1; i < fmt.length && (ch = fmt[i]) !== ':'; i++) {
			switch (ch) {
				case 'v':
					// 0 is the default value
					options.v = /[0-5]/.test(fmt[i+1]) ? parseInt(fmt[++i]) : 0;
					break;
				default:
					options[ch] = true;
					break;
			}
		}
		i++;
	} else {
		fn = formatters.K;
	}
	if (tch === 'N') {
		if(options['+'] && val < 0) val = 0;
		integ = val.x3ToString();
		// TODO: handle scientific format
		var dot = integ.indexOf('.');
		if (dot >= 0) {
			decim = integ.substring(dot + 1);
			integ = integ.substring(0, dot);
		}
		if (integ[0] === '-' || integ[0] === '+') {
			if (options.D) {
				tail = integ[0];
				integ = integ.substring(1);
			}
		} else {
			if (options['-']) {
				if (options.D) tail = '+';
				else integ = '+' + integ;
			}
		}
		var savInteg = integ;
		if (options["3"]) {
			// insert thousand separators
			n3 = Math.floor((integ.length - ((/\d/.test(integ[0]))?0:1) - 1) / 3);
			for (var k = 0; k < n3; k++) {
				var l = integ.length - 4 * k - 3;
				integ = integ.substring(0, l) + special[2] + integ.substring(l);
			}
		}
		cur = integ;
		bad = special[4];
	}
	pwc = options.X && special[5];
	while (i < len) {
		var beg = i,
			ch;
		if ((ch = fmt[i]) === '[') {
			i = fmt.indexOf(']', i + 1);
			if (i < 0) i = len;
			var comment = fmt.substring(beg + 1, i);
			result += options.B?comment.replace(/./g,' '):comment;
			i++;
			continue;
		}
		while ((ch = fmt[i]) >= '0' && ch <= '9')
		i++;
		rep = i > beg ? parseInt(fmt.substring(beg, i), 10) : 1;
		while (ch && ch === fmt[i + 1]) {
			i++;
			rep++;
		}
		i++;
		if(ch=='F') {
			// Recompute the format if ch='F' in order to reuse the n.m# syntax :
			var _fmt='';
			if(!decim.length && options["3"]) {
				// Th option '3' isn't supported by integer values:
				integ = savInteg;
				cur = integ;
				n3 = 0;
				options["3"] = null;
			}
			if(!decim.length || integ.length>=rep) {
				_fmt = rep + '#';
			} else if((integ.length+1+decim.length) >= rep) {
				_fmt = integ.length + '.' + (rep-1-integ.length);
			} else {
				_fmt = (rep-1-decim.length)+ '.' + (decim.length);
			}

			len += _fmt.length;
			fmt = fmt.substring(0,i) + _fmt + fmt.substring(i+1); 
			continue;
		}
		fn.call(this);
	}
	if (tail) result += tail;

	/*dbg*///console.log("val:"+$val+" fmt:"+$fmt+ " result:'"+result + "' valid:"+valid);
	
	if(valid) {
		if(options.z && val.x3IsZero && val.x3IsZero()) result = result.replace(/./g,' ');
		if(fmt[0] == 'N' && options["3"]) 
			result = result.replace(/^(?:\s*)(\.{1})/, function(match) {
		      return match.substring(0,match.length-1);
 		    });
		if(fmt[0] == 'D' && val.x3IsZero && val.x3IsZero()) result = result.replace(/0/g,' ');

	} else {
		if(fmt[0] == 'N') {
			if(options.z) {
				// remove thousand separators (weird!)
				if(options["3"]) result = result.substring(0,result.length-n3);
				result = result.replace(/./g, ' ');
			}
			else result = result.replace(/[0-9]/g, bad);

		} else
			result = result.replace(/./g, bad);
	}
	/*dbg*///console.log("result:'"+result + "' options:"+JSON.stringify(options));
	return x3Trim(result, options.v) ;
};