"use strict";

var util = require('./util');
var config = require("etna-util/lib/nodeconfig").config.etna;

var tinteger = require('./tinteger') ;
var bcd = require('./tbcd') ;
var date     = require('etna-engine/lib/runtime/tdate') ;
var datetime = require('etna-engine/lib/runtime/tdatetime') ;
var tuuid = require('./tuuid') ;
var Blbfile = require('./tblbfile').Blbfile ;
var X3Error = require('./errors').X3Error;
var tdouble = require('./tdouble') ;
var glob = require('streamline/lib/globals');

var constants = {
	CST_ATRUE :1,
	CST_AFALSE:0,
	CST_ALASTPOS:-1,
	CST_AFIRSTPOS:0,
	CST_ANOTDEFINED:-1
}
exports.constants = constants;

exports.initStack = function(superv) {
	var cx = {
		globals: {
			values: {
				$exported: true
			},
			types: {}
		},
		sys: {
			values: {},
			types: {}
		},
		tables: {},
		superv: superv,
		loginName: process.env.USER || "<unknown>",
		// for now
		// seq file stuff
		files: {},
		messages : superv.engineErrMess
	};

	function declVar(dict,name, type, value) {
		dict.values[name] = value;
		dict.types[name] = 'V'+type;
	}
 
	declVar(cx.globals,'AVOID','Y',{
		$exported: true,
		ADATE: require("etna-engine/lib/runtime/dates").ORIGIN
	});
    
	declVar(cx.globals,'CST_AOK','I', 0);
	declVar(cx.globals,'CST_ANO','I', 1);
	declVar(cx.globals,'CST_AYES','I', 2);
	declVar(cx.globals,'CST_AINFO','I', 2);
	declVar(cx.globals,'CST_AWARNING','I', 3);
	declVar(cx.globals,'CST_AERROR','I', 4);
	declVar(cx.globals,'CST_AFATAL','I', 5);

	declVar(cx.globals,'CST_AFALSE','I'  , constants.CST_AFALSE);
	declVar(cx.globals,'CST_ATRUE','I'   , constants.CST_ATRUE);
	declVar(cx.globals,'CST_ALASTPOS'    ,'I', constants.CST_ALASTPOS);
	declVar(cx.globals,'CST_AFIRSTPOS'   ,'I', constants.CST_AFIRSTPOS);
	declVar(cx.globals,'CST_ANOTDEFINED' ,'I', constants.CST_ANOTDEFINED);

	declVar(cx.globals,'CST_ASUCCESS','I', 1);

	declVar(cx.globals,'GUSER','S',"bruno");
	declVar(cx.globals,'GLOGIN','S',"brjou");
	
	declVar(cx.globals,'GUTF8','I',0);
	declVar(cx.globals,'GASCII','I',50);
	declVar(cx.globals,'GUCS2','I',122);
 
	declVar(cx.globals,'GVIRTDIR','S',"localhost:8124");

	declVar(cx.sys,'ADXDCS', 'I', 1940);
	declVar(cx.sys,'ADXDLREC', 'I', 0);
	declVar(cx.sys,'ADXIFS', 'S', ',');
	declVar(cx.sys,'ADXIRS', 'S', '\n');
	declVar(cx.sys,'ADXIUM', 'I', 0);
	declVar(cx.sys,'ADXMBM', 'I', 0) ;
	declVar(cx.sys,'ADXMDA', 'I', 0);
	declVar(cx.sys,'ADXSCA', 'S', '?? .#*???');
	declVar(cx.sys,'ADXUPREC', 'I', 0);
	declVar(cx.sys,'DATESYST', 'D', date.today(false)) ;
	declVar(cx.sys,'FSTAT', 'I', 0);
	declVar(cx.sys,'INDICE', 'I', 0);
	declVar(cx.sys,'INDCUM', 'I', 0); // Used by sigma
	declVar(cx.sys,'MESSNAME', 'S', superv.LAN) ;
	declVar(cx.sys,'ADXTUL', 'S', [1,exports.types["S"].def,[],0,30]);
	declVar(cx.sys,'ADXTUT', 'S', [1,exports.types["S"].def,[],0,30]);
	declVar(cx.sys,'ADXTUC', 'S', [1,exports.types["S"].def,[],0,30]);
	declVar(cx.sys,'ADXMOTHER', 'S', [1,exports.types["S"].def,["SUPERV","SUPERV"],0,7]);


	var frame = {
		values: {},
		types: {},
		context: cx,
		loc: {
			file: module.id,
			line: 0,
		},
		prog: {},
		loopLevel: 0,
	};
	frame.sub = frame;
	// TODO: investigate how data (F class) is managed - global for now
	frame.dicts = [frame, cx.globals, cx.sys, cx.tables];
	frame.tablePos = 2;
	glob.context.x3frame = frame;
};

function x3Val(val) {
	return (typeof val === 'boolean')? (val ? constants.CST_ATRUE : constants.CST_AFALSE): val;
}
exports.x3Val = x3Val;

exports.functions = {
	VARMODE: {
		count: 0
	},
};

exports.types = {
	B: {
		name: 'BLBFILE',
		value: 522,
		def: new Blbfile( new Buffer(0) ),
		set: function(field,type,val) {
			if (!util.x3IsBlbfile(val)) throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
			// nothing else
			return val;
		}
	},
	D: {
		name: 'DATE',
		value: 3,
		def: date.make(0,0,0),
		set: function(field,type,val) {
			try{
				return val.x3ToDate() ;			
			} catch(e) {
				throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");	
			}
		}
	},
	E: {
		name: 'DATETIME',
		value: 526,
		def: new datetime.Datetime(),
		set:function(field,key,val) {return val;}
	},
	I: {
		name: 'INTEGER',
		value: 4,
		def: 0,
		set:function(field,key,val) {
			try {
				val = val.x3ToInteger();	
			} catch(e) {
				throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			if(Math.abs(val) >= tinteger.MAX_INT) throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		} 
	},
	J: {
		name: 'SHORTINT',
		value: 2,
		def:  0,
		set:function(field,key,val) {
			try {
				val = val.x3ToInteger();	
			} catch(e) {
				throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			if(val < tinteger.MIN_SHORTINT || val > tinteger.MAX_SHORTINT) throw new X3Error(13, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		}
	},
	N: {
		name: 'DECIMAL',
		value: 7,
		def: bcd.fromDouble( 0 ),
		set: function(field,type,val) {
			try{
				return val.x3ToBCD() ;			
			} catch(e) {
				throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");	
			}
		}
	},
	S: {
		name: 'CHAR',
		value: 10,
		def: "",
		set: function(field,type,val) {
			if(typeof val !== 'string') throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			return (type.length > 2)?val.substring(0,parseInt(type.substring(2))):val;
		}
	},
	T: {
		name: 'CLBFILE',
		value: 523,
		def: "",
		set:function(field,key,val) {return val;}
	},
/*	U: {
		name: 'SCHAR',
		value: 10,
		def: ""
	},*/
	V: {
		name: 'TINYINT',
		value: 1,
		def: 0,
		set: function(field,key,val) {
			try {
				val = val.x3ToInteger();	
			} catch(e) {
				throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			if(val < tinteger.MIN_TINYINT || val > tinteger.MAX_TINYINT) throw new X3Error(13, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		}
	},
	W: {
		name: 'DOUBLE',
		value: 6,
		def: new tdouble.Double(0),
		set: function(field,type,val) {
			try{
				return val.x3ToDouble() ;			
			} catch(e) {
				throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");	
			}
		}
	},
	X: {
		name: 'ANY',
		value: -1,
		def: null,
		set:function(field,key,val) {return val;}
	},
	Y: {
		name: 'INSTANCE',
		value: 524,
		def: null,
		set:function(field,key,val) {return val;}
	},
	Z: {
		name: 'UUIDENT',
		value: 525,
		def: tuuid.make( ),
		set:function(field,key,val) {return val;}
	},
};



// storage classes
exports.dictClasses = {
	VARIABLE: 'A',
	VALUE: 'B',
	CONST: 'C',
	DEFAULT: 'D',
	GLOBAL: 'V',
	LOCAL: 'L',
	// + F (table), M (mask) and S (sequential) that don't have keywords
};

exports.vOperations =  {
	GET: {
		fn:function(frame,dict, field, val, silent,strict) {
			//console.log("GET "+field+" type:"+dict.types[field]);
			if(dict.types[field] != "CX") {
				var key = dict.types[field];
				if (key && /^[cb]$/.test(key[0])) {
					// Let's copy data of the array : 
					var prevArr = dict.values[field][2];
					var newArr = [] ;
					for (var i = 0; i <prevArr.length; i++) {
						newArr[i] = prevArr[i];
					}
					dict.values[field][2] = newArr;
					dict.types[field]     = key[0].toUpperCase()+ key.substring(1);
					//console.log("dict.values[field] " + dict.values[field]);
				}
				return dict.values[field];
			}
			// Let's resolve the proper type :
			var v = Array.isArray(dict.values[field]) ? dict.values[field][2][0] : dict.values[field];

			if(typeof v == "number") 	 	dict.types[field] = "BI";
			else if(typeof v == "string")	dict.types[field] = "BS";
			else if(util.x3IsDate(v))  	 	dict.types[field] = "BD";
			else if(util.x3IsDatetime(v)) 	dict.types[field] = "BE";
			else if(util.x3IsBCD(v))     	dict.types[field] = "BN";
			else if(util.x3IsUuid(v))     	dict.types[field] = "BZ";
			if(Array.isArray(dict.values[field])) {
				//make a copy for Values and Const and not declared
				v = dict.values[field];
			    var newtab = [] ;
			    for (var n = 0; n<v.length; n++) {
					// copy arrays of object passed
					if (Array.isArray( v[n])) {
				     var newtab2 = [] ;
				     for (var k = 0; k <v[n].length; k++) {
							newtab2[k] =  v[n][k];
				     }
				     newtab[n] = newtab2;
					}
					else {
					 newtab[n] =  v[n];
					} 
			    }
			    if (newtab[4]!==null) newtab[4]=newtab[4]-newtab[3] ;
			    newtab[3]=0;
			    dict.values[field]=newtab;				
			}
			return dict.values[field];
		},
		error:function(_, frame,field, val, silent,strict) {
			if(field == 'GACTX') {
				return setACTX(_,frame);
			}
			if (silent) return;
			//console.log("frame:"+JSON.stringify(frame.values));
			throw new X3Error(6, "undefined variable: " + field);			
		}

	},
	SET:{
		fn:function(frame,dict, field, val, silent,strict) {
			/*dbg*///console.log("SET "+field+" type:"+dict.types[field]+" val:"+val);
			if (val == null || val === undefined) throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");

			var type = dict.types[field];
			if (type===undefined) {
				throw new X3Error(62, frame.prog.name+": '" + field + "' not declared");						
			}
			else if (type[0]==='C') {
				throw new X3Error(62, frame.prog.name+": '" + field + "' Variable not modifiable");						
			}
			else if (!Array.isArray(val) ) { 
				return dict.values[field] = exports.types[type[1]].set(field,type,val);
			}
			return dict.values[field]  = val;
		},
		error:function(_, frame,field, val, silent,strict) {
			if (strict ) {
				throw new X3Error(6, "undefined variable: " + field);
			} else {
				frame.values[field] = val;
				frame.types[field] = "L"+ (typeof val == 'number'? 'I':'S');
			}
		}
	},
	RAZ:{
		fn:function(frame,dict, field, val, silent,strict) {
			dict.values[field]  = exports.types[dict.types[field][1]].def;
			return 0;
		},
		error:function(_, frame,field, val, silent,strict) {
			throw new X3Error(6, "undefined variable: " + field);	
		}
	},
	TYPE:{
		fn:function(frame,dict, field, val, silent,strict) {
			var type =  exports.types[dict.types[field][1]].value;
			if(dict.types[field][1] == 'S' && dict.types[field].length > 2) 
				type += parseInt(dict.types[field].substring(2), 10);
			return type;
		},
		error:function(_, frame,field, val, silent,strict) {
			return -1;
		}
	},
	KILL:{
		fn:function(frame,dict, field, val, silent,strict) {
			dict.values[field] = undefined;
			dict.types[field]  = undefined;
			return 0;
		},
		error:function(_, frame,field, val, silent,strict) {
			throw new X3Error(6, "undefined variable: " + field);	
		}
	}
};

var setACTX = function(_,frame) {
	frame.context.globals.types.GACTX  = 'VY';
	return frame.context.globals.values.GACTX = frame.context.superv.currentContext(_);
};

exports.instructions = {
	DIM: function(arr, dim) {
		return function dim$do(_) {
			var a = arr(_, false, undefined, true);
			if (a === undefined) return -1;
			var d = dim !== undefined ? dim(_) : 1;
			//console.log("DIM: " + JSON.stringify(a) + " dim=" + dim)
			// basic values are considered to be arrays of 1 elt.
			if (!Array.isArray(a)) return d === -1 ? 0 : 1;
			var ndims = a[0];
			if (d === 0) return ndims;
			if (!(d >= -ndims && d <= ndims)) throw new X3Error(50, d);						
			var sliced =  a.length === 3 + 4 * a[0];
			//console.log("DIM: " + JSON.stringify(a) + " ndims=" + ndims+" sliced="+sliced)
			if (sliced) {
				if (d > 0) return a[4 + 2 * (ndims + (d - 1))];
				else return a[3 + 2 * -(d + 1)];
			} else {
				//if (d>0) return a[4]===null?32767:a[4]-a[3]+1;
				//else return a[3]
				if (d>0) return a[4 + 2 * (d - 1) ]===null?32767:a[4 + 2 * (d - 1) ]-a[3 + 2 * (d - 1) ]+1;
				else return a[3 + 2 * -(d + 1) ];
			}
			
		};
	},
	CLALEV: function(arg) {
		return function clalev$do(_) {
			var a = arg(_, false, undefined, true);
			var frame = glob.context.x3frame;
			if (!a) return 0;
			if (typeof a === "number") {
				var abbr = Object.keys(frame.context.table)[a - 1];
				if (abbr) return abbr;
				else throw new X3Error(10, "clalev number out of range: " + a);
			} else {
				if (!a.values) throw new X3Error(10, "clalev argument is not a class");
				return 1;
			}
		};
	},
	V: function(field) {
		return function v$do(_, operation, val, silent,strict) {
			var frame = glob.context.x3frame;
			var fdo  = operation ? operation : exports.vOperations.GET;
			// optimize read of local variable
			//if (!operation && (v = frame.values[field]) !== undefined) return v;
			var dicts = frame.dicts;
			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				if (dict === frame.context.tables) {
					var keys = Object.keys(dict);
					//for (var j = 0; !found && j < keys.length; j++) {
					for (var j = 0; j < keys.length; j++) {
						var abb = keys[j];
						var values = dict[abb].values;
						if(dict[abb].values[field]) {
							dict = dict[abb];
							return fdo.fn(frame,dict[abb], field, val, silent,strict);
						}
					}
				} else if(dict.values[field] !== undefined){
					return fdo.fn(frame,dict, field, val, silent,strict);
				}
			}
			return fdo.error(_,frame,field, val, silent,strict);
		};
	},
	TYPE: function(letter,field) {
		var fv;
		if(letter.length) fv = exports.instructions.CV(letter, '', field);
		else fv = exports.instructions.V(field);
		return function typev$do(_) {
			return fv(_,exports.vOperations.TYPE);
		};
	},
	CV: function(letter, abbrev, field, silent) {
		letter = (letter == 'D') ? 'L':letter;
		if(config.optimize ) {
			if(letter == 'L') {
				return function cv$do(_, operation, val, silent,strict) {
					var frame = glob.context.x3frame;
					var fdo  = operation ? operation : exports.vOperations.GET;
					if(frame.values[field] !== undefined) 
						return fdo.fn(frame,frame, field, val, silent,strict);
					else
						return fdo.error(_,frame,field, val, silent,strict);
				};
			} else if(letter == 'V') {
				return function cv$do(_, operation, val, silent,strict) {
					var frame = glob.context.x3frame;
					var fdo  = operation ? operation : exports.vOperations.GET;
					if(frame.context.globals.values[field]!== undefined) 
						return fdo.fn(frame,frame.context.globals, field, val, silent,strict);
					else
						return fdo.error(_,frame,field, val, silent,strict);
				};
			} else if(letter == 'S') {
				return function cv$do(_, operation, val, silent,strict) {
					var frame = glob.context.x3frame;
					var fdo  = operation ? operation : exports.vOperations.GET;
					if(frame.context.sys.values[field]!== undefined) 
						return fdo.fn(frame,frame.context.sys, field, val, silent,strict);
					else
						return fdo.error(_,frame,field, val, silent,strict);
				};	
			}
		}
		return function cv$do(_, operation, val, silent,strict) {
			var frame = glob.context.x3frame;
			var fdo  = operation ? operation : exports.vOperations.GET;

			var dict;

			switch (letter) {
			case 'L':
				dict = frame;
				break;
			case 'V':
				dict = frame.context.globals;
				break;
			case 'S':
				dict = frame.context.sys;
				break;
			case 'F':
			case '?':
				dict = frame.context.tables;
				if (abbrev) {
					dict = dict[abbrev];
					if (!dict) {
						if (operation) {
							val.abbrev = abbrev;
							return frame.context.tables[abbrev] = val;
						} else if (silent) return null;
						else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
					}
				} else {
					var found;
					var keys = Object.keys(dict);
					for (var i = 0; !found && i < keys.length; i++) {
						var abb = keys[i];
						var d = dict[abb];
						found = (d.values[field] !== undefined);
						if (found) dict = d;
					}
					if (!found) {
						if (silent) return null;
						else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
					}
				}
				break;
			default:
				throw new X3Error(26, 'unknown class letter: [' + letter + ']');

			}

			if (!dict) {
				if (false && frame.tryingSql) { // REVIEW!!!
					var err = new Error("trying sql (ignore)");
					err.tooComplexForSql = true;
					throw err;
				}
			} else {
				if(dict.values[field] !== undefined) 
					return fdo.fn(frame,dict, field, val, silent,strict);
				else
					return fdo.error(_,frame,field, val, silent,strict);
			}
		};
	},
	DECL: function(key, field, using, lens0, ranges0) {
		key = (key[0] == 'D') ? 'L'+key.substring(1) : key;
		var letter 	= key[0];
		var t       = key[1];
		var def 	= exports.types[t].def;
		if(config.optimize && lens0 === undefined && ranges0 === undefined){
			if(letter === "V" )
				return function decl$do(_) {
					glob.context.x3frame.context.globals.values[field] = def;
					glob.context.x3frame.context.globals.types[field]  = key;
				};
			else if(letter === "L" )
				return function decl$do(_) {
					glob.context.x3frame.values[field] = def;
					glob.context.x3frame.types[field]  = key;
				};
		}
		
		return function decl$do(_) {
			var frame = glob.context.x3frame;
			var lens = lens0,
				ranges = ranges0;
			var letter = key[0];
			var dict = letter === 'V' ? frame.context.globals : frame;
			var values = dict.values;
		
			if (lens) {
				if(!/^[STB]$/.test(t)) {
					ranges = lens;
					lens = undefined;
				} else {
					key += lens(_)[0];
				}
			}
			// Set the proper type :
			dict.types[field] = key;
			/*dbg*///console.log("decl "+field+" type:"+key);

			var arr;
			if (/^[LV]$/.test(letter)) values[field] = undefined ; // Kill : the value
			else arr = values[field]; // for arrays :	

			var rangesVals;
			if (ranges){
				rangesVals = ranges(_);
			} else if (arr && Array.isArray(arr)) {
				ranges     = [0, null];
				rangesVals = [ranges];
			}
			/*dbg*///console.log("ranges :"+!!ranges);

			// ignore using (for now)
			if (ranges) {
				var ndims = rangesVals.length;
				var dim;
				var range;
				if (arr === undefined) {
					// Create an empty array
					arr = [ndims, def, []];

					for (dim = 0; dim < ndims; dim++) {
						range = rangesVals[dim];
						if (typeof range === 'number') range = [0, range-1]; // for Value Integer A(6) -> A(0..5)
						arr = arr.concat(range);
					}
					values[field] = arr;
				} else {
					if (ndims != arr[0]) throw new X3Error(26, "dimensions mismatch for '" + field + "': expected " + ndims + ", got " + arr[0]);
					
					// note: array's dimensions were copied when parameter was assigned - so we can modify them :
					var sliced = arr.length === 3 + 4 * ndims;
					for (dim = 0; dim < ndims; dim++) {
						range = rangesVals[dim];
						if (range) {
							if (typeof range === 'number') range = [0, range-1]; // for Value Integer A(6) -> A(0..5)
							var decal = range[0] - arr[3 + 2 * dim];  
							arr[3 + 2 * dim] = range[0];
							if (arr[4 + 2 * dim] !== null)
							{
								arr[4 + 2 * dim] = arr[4 + 2 * dim] + decal; 
							}
							//
							if (range[1]) {
								var count = sliced ? arr[4 + 2 * (ndims + dim)] : arr[4 + 2 * dim];
								if (count !== range[1]) throw new X3Error(26, "range mismatch for '" + field + "': expected " + count + ", got " + range[1]);
							}
						}
					}
					// Make a copy of array's data for Values and Const
					if (/^[CB]$/.test(key[0]) && arr && Array.isArray(arr)) {
						// mark the field as 'has to be copied' is any instruction try access to it:
						// B => b !
						// C => c !
						// Be carefull that INDEX performs a GET first...
						dict.types[field] = key[0].toLowerCase()+ key.substring(1);
					}
				}
			} else if(/^[LV]$/.test(letter)) {
				// Set the type's default value
				values[field] = def;	
			}
		};
	},
	CA: function(field, exps) {
		var decl = exports.instructions.DECL('LX', field, util.instructions.A([util.instructions.C(exps.length)]));
		var aexps = util.instructions.A(exps);
		return function ca$do(_) {
			var frame = glob.context.x3frame;
			decl(_);
			var val = frame.values[field];
			var vals = aexps(_);
			val[2] = vals;
		};
	},
	GET: function(obj, prop) {
		return function get$do(_) {
			//console.error("GET " + prop);
			//console.error(obj);
			return obj[prop];
		};
	},
	SET: function(lhs, rhs, silent) {
		if(config.optimize && typeof rhs != "function")
			return function set$do(_) {
				lhs(_, exports.vOperations.SET, rhs, silent);
			};
		return function set$do(_) {
			lhs(_, exports.vOperations.SET, rhs.value !== undefined ? rhs.value : rhs(_), silent);
		};
	},
	ASSIGN: function(lhs, rhs, silent) {
		return function assign$do(_) {
			var target = lhs(_).toUpperCase();
			var value = rhs.value !== undefined ? rhs.value : rhs(_);
			var args;
			var beg = target.indexOf('(');
			if(beg > 0) {
				args = target.substring(beg+1,target.lastIndexOf(')')).split(',').reduce(function(result, arg) {
					result.push(util.instructions.C(parseInt(arg)));
					return result;
				}, []);
				target = target.substring(0,beg);
			}
			var fV = exports.instructions.V(target);
			if(args) {
				var fINDEX = require('./arrays').instructions.INDEX(fV,args);
				fINDEX(_,true, value);
			} else {
				//strict = true
				fV(_, exports.vOperations.SET, value, silent,true);
			}
		};
	},
	RAZ: function(exps) {
		return function raz$do(_) {
			exps.forEach_(_, function(_, exp) {
				exp(_, exports.vOperations.RAZ);
			});
		};

	},
	SNAP: function( target ) {	
		return function dot$do(_, assign, val, silent) {
			var t = target(_) ;

			t.setStateFlag("snapshotEnabled") ;

			if (assign)
				throw new X3Error(155, "") ;
			else {
				if (!t.getStateFlag("snapshotEnabled")) return null ;
				else {
					if (!t.snapshots) t.snapshots = [null, null] ;

					if (t.snapshots[0]) return t.snapshots[0] ;
					else return t.snapshots[0] = t.clone( ).setStateFlag("isClaSnapshot") ;
				}
			}
		}
	},
	PROP: function(target, name) {
		return function dot$do(_, assign, val, silent) {
			var t = target(_);
			//console.log("PROP:"+name+" assign:"+assign+" val:"+val);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid property target: " + t);
			try {
				if (assign) {
					if (typeof t.set === "function") return t.set(_, name, val);
					else return t[name] = val;
				} else {
					if (typeof t.get === "function") return t.get(_, name);
					else {
						var v = t[name];
						if (v === undefined) throw new X3Error(26, "missing property in built-in object: " + name);
						return v;
					}
				}
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}
		};
	},
	ATT: function(target, property, attribut) {
		if(property)
			return function att$do(_, assign, val, silent) {
				var t = target(_);
				//console.log("ATT attribut:"+attribut+" property:"+ property +" assign:"+assign+" val:"+val);

				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid property target: " + t);
				try {
					if (assign) {
						if (typeof t.setPropertyAttribute === "function") {
							return t.setPropertyAttribute(_, property, attribut, val);
						}
					} else {
						if (typeof t.getPropertyAttribute === "function") {
							return x3Val(t.getPropertyAttribute(_,property,attribut));
						}
					}
				} catch (ex) {
					throw new X3Error(26, ex.message, ex.stack);
				}

			};
		else
			return function att$do(_, assign, val, silent) {
				var t = target(_);
				//console.log("ATT attribut:"+attribut+" property:"+ property +" assign:"+assign+" val:"+val);

				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid target: " + t);
				try {
					if (assign) {
						if (typeof t.setAttribute === "function") return t.setAttribute(attribut,val);
					} else {
						if (typeof t.getAttribute === "function") {
							return x3Val(t.getAttribute(attribut));
						}
					}
				} catch (ex) {
					throw new X3Error(26, ex.message, ex.stack);
				}

			};
		 	
	},
	AGETATTR: function(target, property, attribut) {
		if(property)
			return function agetattr$do(_,silent) {
				var t = target(_);
				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
				try {
					if (typeof t.getPropertyAttribute === "function") {
						return x3Val(t.getPropertyAttribute(_,property,attribut(_)));
					}
				} catch (ex) {
					throw new X3Error(26, ex.message, ex.stack);
				}			
			};
		else
			return function agetattr$do(_,silent) {
				var t = target(_);
				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
				try {
					if (typeof t.getAttribute === "function") {
						return x3Val(t.getAttribute(attribut(_)));
					}
				} catch (ex) {
					throw new X3Error(26, ex.message, ex.stack);
				}			
			};
	},
	ASETATTR: function(target, property, attribut,val) {
		if(property)
			return function asetattr$do(_,silent) {
				var t = target(_);
				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
				try {
					/*if (t.getStateFlag("snapshotEnabled")) {
						if (!t.snapshots) t.snapshots = [null, null] ;
						if (t.snapshots[0] === null) t.snapshots[0] = t.clone( ).setStateFlag("isSnapshot") ;
						if (t.snapshots[1] === null) t.snapshots[1] = t.clone( ).setStateFlag("isSnapshot") ;
					}*/
					if (typeof t.setPropertyAttribute === "function") return t.setPropertyAttribute(_,property,attribut(_),val(_));
				} catch (ex) {
					throw new X3Error(26, ex.message, ex.stack);
				}			
			};
		else 
			return function asetattr$do(_,silent) {
				var t = target(_);
				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
				try {
					/*if (t.getStateFlag("snapshotEnabled")) {
						if (!t.snapshots) t.snapshots = [null, null] ;
						if (t.snapshots[0] === null) t.snapshots[0] = t.clone( ).setStateFlag("isSnapshot") ;
						if (t.snapshots[1] === null) t.snapshots[1] = t.clone( ).setStateFlag("isSnapshot") ;
					}*/
					if (typeof t.setAttribute === "function") return t.setAttribute(attribut(_),val(_));
				} catch (ex) {
					throw new X3Error(26, ex.message, ex.stack);
				}			
			};
	},
	XMET: function(target, name, args) { // fmet and callmet
		var aargs = util.instructions.A(args);
		return function dot$do(_) {
			var t = target(_);
			// todo: review error numbers
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid method target: " + t);
			var vals = aargs(_);
			var meth;
			if (t.class && !t.isContext && ["AGETATTRIBUTE","ASETATTRIBUTE"].indexOf(name) < 0) {
				meth = t.class.method(name);
				if (typeof meth !== "function") throw new X3Error(26, "method not found: " + name + " in class " + t.class.name);
			} else {
				meth = t[name];
				if (typeof meth !== "function") throw new X3Error(26, "missing method in built-in object: " + name);
			}
			try {
				return meth.apply_(_, t, vals, 0);
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}
		};
	},
	FILEVAL: function(abbrev, vars, from) {
		var avars = util.instructions.A(vars);
		return function dot$do(_) {
			throw new X3Error(26, "NIY: FILEVAL");
		};
	},
	NEW: function(clas) {
		return function new$do(_) {
			var frame = glob.context.x3frame;
			var name = clas(_);
			if (!/^C_/.test(name)) throw new X3Error(33, "NIY: new on " + name);
			var cl = frame.context.superv.load(_, 'Class', name.substring(2));
			if (!cl) throw new X3Error(26, "invalid class name: " + name); // TODO check errnum
			return cl.createInstance(_);
		};
	},
	FREE: function(allocGroup, isGroup) {
		return function free$do(_) {};
	},
	KILL: function(exps) {
		return function raz$do(_) {
			exps.forEach_(_, function(_, exp) {
				exp(_, exports.vOperations.KILL);
			});
		};

	},
	CLA: function(letter) {
		return function cla$do(_, operation, val, silent,strict) {
			var frame = glob.context.x3frame;
			var dict;

			switch (letter) {
			case 'L':
				dict = frame;
				break;
			case 'V':
				dict = frame.context.globals;
				break;	
			}
			if(dict && (operation == exports.vOperations.KILL || operation == exports.vOperations.RAZ)) {
				Object.keys(dict.values).forEach(function(field) {
					operation.fn(frame,dict, field);
				});
			} else if(!dict && operation == exports.vOperations.RAZ) {
				throw new X3Error(7, "Raz non-existent class");
			}
		}
	},
	AADD: function(target,position) {
		return function aadd$do(_,silent) {
			var t = target(_);
			if (!t || !(t.collection || t.$exported)) throw new X3Error(26, "invalid collection : " + t);
			try {
				if (typeof t.add === "function") return t.add(_,position(_));
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}			
		}
	},
	ADEL: function(target,position) {
		return function adel$do(_,silent) {
			var t = target(_);
			if (!t || !(t.collection || t.$exported)) throw new X3Error(26, "invalid collection : " + t);
			try {
				if (typeof t.del === "function") return t.del(_,position(_));
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}			
		}
	},
	ASETCOLUMNATTR: function(target, collection, column,  attribute,val) {
		return function asetcolumnattr$do(_,silent) {
			var t = target(_);
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid class : " + t);
			try {
				if (typeof t.setColumnAttribute === "function") return t.setColumnAttribute(_,collection,column(_),attribute(_),val(_));
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}				
		};
	},
	AGETCOLUMNATTR: function(target, collection, column, attribute) {
		return function agetcolumnattr$do(_,silent) {
			var t = target(_);
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid class : " + t);
			try {
				if (typeof t.getColumnAttribute === "function"){
					return x3Val(t.getColumnAttribute(_,collection,column(_),attribute(_)));
				} 
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}				
		};
	}
};