"use strict";

var util = require('./util');
var arrays = require('./arrays');

var tinteger = require('./tinteger') ;
var tbcd = require('./tbcd') ;
var date     = require('etna-engine/lib/runtime/tdate') ;
var datetime = require('etna-engine/lib/runtime/tdatetime') ;
var tstring = require('./tstring') ;
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');




exports.initStack = function(superv) {
	var cx = {
		globals: {
			values: {
				$exported: true,
				CST_AOK: 0,
				CST_ANO: 1,
				CST_AYES: 2,
				CST_AINFO: 2,
				CST_AWARNING: 3,
				CST_AERROR: 4,
				CST_AFATAL: 5,
				CST_AFALSE: 0,
				CST_ATRUE: 1,
				CST_ASUCCESS: 1,

				// fix later
				AVOID: {
					$exported: true,
					ADATE: require("etna-engine/lib/runtime/dates").ORIGIN,
				},
				GUSER: "bruno",
				GLOGIN: "brjou",
				// for adxium
				GUTF8: 1,
				GVIRTDIR: "localhost:8124",
			},
			types: {}
		},
		sys: {
			values: {},
			types: {}
		},
		tables: {},
		superv: superv,
		loginName: process.env.USER || "<unknown>",
		// for now
		// seq file stuff
		files: {}
	};

	function sysVar(name, type, value) {
		cx.sys.values[name] = value;
		cx.sys.types[name] = type;
	}
	sysVar('ADXIFS', 'S', ',');
	sysVar('ADXIRS', 'S', '\n');
	sysVar('ADXIUM', 'I', 0);
	sysVar('ADXSCA', 'S', '?? .#*???');
	sysVar('fstat', 'I', 0);
	sysVar('ADXUPREC', 'I', 0);
	sysVar('ADXDLREC', 'I', 0);
	sysVar('INDICE', 'I', 0);
	sysVar('adxmda', 'S', 0);


	var frame = {
		values: {},
		types: {},
		context: cx,
		loc: {
			file: module.id,
			line: 0,
		},
		prog: {},
		loopLevel: 0,
	};
	frame.sub = frame;
	// TODO: investigate how data (F class) is managed - global for now
	frame.dicts = [frame, cx.globals, cx.sys, cx.tables];
	frame.tablePos = 2;
	glob.context.x3frame = frame;
};

exports.functions = {
	TYPE: {
		count: 1,
		fn: function(t) {
			if(t.type) return t.type();
			
			if (typeof t !== "string") {
				// guess type from value
				var v = t.value;
				switch (typeof v) {
				case 'string':
					return 10 + 512;
				case 'number':
					return ((v | 0) === v) ? 4 : 7;
				case 'object':
					if (date.isDate(v)) return 3;
					if (datetime.isDatetime(v)) return 526;
					if (Buffer.isBuffer(v)) return 522;
					if (v && (v.$exported || v.class)) return 524;
					return -1;
				default:
					return -1;
				}
			}
			var type = exports.types[t[1]];
			if (!type) throw new X3Error(26, "bad type: " + t);
			return type.value === 10 && t.length > 2 ? 10 + parseInt(t.substring(2), 10) : type.value;
		}
	},
	VARMODE: {
		count: 0
	},
};

exports.types = {
	B: {
		name: 'BLBFILE',
		value: 522,
		def: new Buffer(0)
	},
	D: {
		name: 'DATE',
		value: 3,
		def: date.make(0, 0, 0)
	},
	E: {
		name: 'DATETIME',
		value: 526,
		def: new datetime.Datetime()
	},
	I: {
		name: 'INTEGER',
		value: 4,
		def: new tinteger.Integer( 0 )
	},
	J: {
		name: 'SHORTINT',
		value: 2,
		def: new tinteger.Integer( 0 )
	},
	N: {
		name: 'DECIMAL',
		value: 7,
		def: new tbcd.BCD( 0 )
	},
	S: {
		name: 'CHAR',
		value: 10,
		def: ""
	},
	T: {
		name: 'CLBFILE',
		value: 523,
		def: ""
	},
	U: {
		name: 'SCHAR',
		value: 10,
		// ? not listed in doc
		def: ""
	},
	V: {
		name: 'LIBELLE',
		value: 1,
		def: ""
	},
	X: {
		name: 'ANY',
		value: -1,
		def: null
	},
	Y: {
		name: 'INSTANCE',
		value: 524,
		def: null
	},
	Z: {
		name: 'UUIDENT',
		value: 525,
		def: null
	},
};

// storage classes
exports.dictClasses = {
	VARIABLE: 'A',
	VALUE: 'B',
	CONST: 'C',
	DEFAULT: 'D',
	GLOBAL: 'V',
	LOCAL: 'L',
	// + F (table), M (mask) and S (sequential) that don't have keywords
};

var raz = {};

exports.instructions = {
	DIM: function(arr, dim) {
		return function dim$do(_) {
			var a = arr(_, false, undefined, true);
			if (a === undefined) return -1;
			var d = dim !== undefined ? dim(_) : 1;
			//console.error("DIM: " + JSON.stringify(a) + " dim=" + dim)
			// basic values are considered to be arrays of 1 elt.
			if (!Array.isArray(a)) return d === -1 ? 0 : 1;
			var ndims = a[0];
			if (d === 0) return ndims;
			if (!(d >= -ndims && d <= ndims)) throw util.badArgumentType(d);
			var sliced = a.length === 3 + 4 * ndims;
			if (sliced) {
				if (d > 0) return a[4 + 2 * (ndims + (d - 1))];
				else return a[3 + 2 * -(d + 1)];
			} else {
				//if (d > 0) return a[4 + 2 * (d - 1)];
				//else return a[3 + 2 * -(d + 1)];
		    //console.log("DIM: a=" + JSON.stringify(a));
				//return a[4]===null?a[2].length:a[4]-a[3]+1;
				return a[4]===null?32767:a[4]-a[3]+1;
			}
		}
	},
	CLALEV: function(arg) {
		return function clalev$do(_) {
			var a = arg(_, false, undefined, true);
			if (!a) return 0;
			if (typeof a === "number") {
				var abbr = Object.keys(context.tables)[a - 1]
				if (abbr) return abbr;
				else throw new X3Error(10, "clalev number out of range: " + a);
			} else {
				if (!a.values) throw new X3Error(10, "clalev argument is not a class");
				return 1;
			}
		}
	},
	V: function(field) {
		return function v$do(_, assign, val, silent) {
			
			var frame = glob.context.x3frame, v;
			// optimize read of local variable
			//if (!assign && (v = frame.values[field]) !== undefined) return v;
			var dicts = frame.dicts;

            if (assign && val == null) throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");

			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				var key, found;
				if (dict === frame.context.tables) {
					var keys = Object.keys(dict);
					for (var j = 0; !found && j < keys.length; j++) {
						var abb = keys[j];
						var values = dict[abb].values;
						v = dict[abb].values[key];
						found = (v !== undefined);
					}
				} else {
					key = field;
					v = dict.values[key];
					found = (v !== undefined);
				}
				
				if (found) {
					if (assign) {
				
						val = val === raz ? exports.types[dict.types[key][1]].def : val;
						if (val === undefined) throw new X3Error(26, "undefined assigned to '" + field + "'");

						if (dict.types[key][1] === "I") {
							if (!val.isNumeric( ))
								throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");

							val = val.toInteger( ) ;
							if (!val.assertOverflow( dict.types[key][1]) )
								throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");

						} else if (dict.types[key][1] ==="N") {
							if (!val.isNumeric( ))
								throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
				
							val = val.toBCD( ) ;				
						} else if (dict.types[key][1] === "S" &&  dict.types[key].length > 2 ) {
							if (!tstring.isString(val))
								throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");

							val = new tstring.TString( val.valueOf( ).substring(0,parseInt(dict.types[key].substring(2))));
						}

						dict.values[key] = val;
						return;
					} else { 
			            if (Array.isArray(frame.prog.params)) {
			    			var ifield = frame.prog.params.indexOf(field);
						    if (ifield>=0 && frame.prog.pardef[ifield]===0) {
						    	if (Array.isArray(v) && v[3]===1)
						    	{
						    		v[3]=0;
						    		if (v[4]!==null) v[4]=v[4]-1 ;
						    	}
						    	frame.prog.pardef[ifield] = 1 ;
						    }
		                }
						return v; 
					}
				}
			}
			// not found, create in local dict if assign
			if (assign) {
				frame.values[field] = val;
				frame.types[field] = "L"+ (typeof val == 'number'? 'I':'S');
			}
			else if (silent) return;
			else throw new X3Error(6, "undefined variable: " + field);
		};
	},
	TYPEV: function(field) {
		var vv = exports.instructions.V(field);
		return function typev$do(_) {
			var frame = glob.context.x3frame;
			var dicts = frame.dicts;
			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				var key, t;
				if (dict === frame.context.tables) {
					var keys = Object.keys(dict);
					for (var j = 0; j < keys.length; j++) {
						var abb = keys[j];
						t = dict[abb].types[key];
						if (t) return t;
					}
				} else {
					key = field;
					t = dict.types[key];
					if (t) return t;
				}
			}
			// type(t) will analyze this structure
			return {
				value: vv(_),
			};
		};
	},
	CV: function(letter, abbrev, field, silent) {
		return function cv$do(_, assign, val, silent) {
			var frame = glob.context.x3frame;
			var dict;

			if (assign && val == null) {
				if (silent) return null;
				else throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");
			}

			switch (letter) {
			case 'L':
				dict = frame;
				break;
			case 'V':
				dict = frame.context.globals;
				break;
			case 'S':
				dict = frame.context.sys;
				break;
			case 'F':
			case '?':
				dict = frame.context.tables;
				if (abbrev) {
					dict = dict[abbrev];
					if (!dict) {
						if (assign) {
							val.abbrev = abbrev;
							return frame.context.tables[abbrev] = val;
						} else if (silent) return null;
						else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
					}
				} else {
					var found;
					var keys = Object.keys(dict)
					for (var i = 0; !found && i < keys.length; i++) {
						var abb = keys[i];
						var d = dict[abb];
						found = (d.values[field] !== undefined);
						if (found) dict = d;
					}
					if (!found) {
						if (silent) return null;
						else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
					}
				}
				break;
			default:
				throw new X3Error(26, 'unknown class letter: [' + letter + ']');

			}

			if (!dict) {
				if (false && frame.tryingSql) { // REVIEW!!!
					var err = new Error("trying sql (ignore)");
					err.tooComplexForSql = true;
					throw err;
				}
			}
			if (assign) {
				val = val === raz ? exports.types[dict.types[field][1]].def : val;
				dict.values[field] = val;
			} else {
				if (field) {
					var v = dict.values[field];
					if (v === undefined) throw new X3Error(26, "undefined variable: " + field);
					return v;
				} else {
					return dict;
				}
			}
		};
	},
	TYPECV: function(letter, abbrev, field) {
		return function typecv$do(_) {
			var frame = glob.context.x3frame;
			var dict;
			var key = field,
				t;
			switch (letter) {
			case 'L':
				dict = frame;
				break;
			case 'V':
				dict = frame.context.globals;
				break;
			case 'S':
				dict = frame.context.sys;
				break;
			case 'F':
			case '?':
				dict = frame.context.data;
				if (abbrev) key = abbrev + "_" + field;
				else {
					for (var i = 0; i < dict.abbrevs.length; i++) {
						key = dict.abbrevs[i] + "_" + field;
						t = dict.types[key];
						if (t) return t;
					}
					throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']' + field);
				}
				break;
			default:
				throw new X3Error(7, 'unknown class: [' + letter + ']');

			}
			return dict && dict.types[key];
		};
	},
	DECL: function(key, field, using, lens0, ranges0) {
		return function decl$do(_) {
			var frame = glob.context.x3frame;
			var lens = lens0,
				ranges = ranges0;
			var letter = key[0];
			var dict = letter === 'V' ? frame.context.globals : frame;
			var values = dict.values;
			if (letter === 'L' || letter === 'V') delete values[field];
			
			var ifield = (frame.prog.params && frame.prog.params.indexOf(field)) || -1;
			if (ifield>=0 && frame.prog.pardef[ifield]===0 ) {
		    	frame.prog.pardef[ifield] = 1;
		    }


			var t = key[1];
			if (t !== 'S' && t !== 'T' && lens) {
				ranges = lens;
				lens = undefined;
			}
			if (lens) {
				key += lens(_)[0];
			}
			var arr = values[field];
			if ((ranges===undefined || ranges===null) && Array.isArray(arr))
			{
				ranges = [0, null];
				var rangesVals = [ranges];
			}
			else if (ranges){
				var rangesVals = ranges(_);
			}
			
			dict.types[field] = key;
			// ignore using (for now)
			if (ranges) {
				var ndims = rangesVals.length;
				if (arr === undefined) {
					var def = exports.types[t].def;
					arr = [ndims, def, []];
					for (var dim = 0; dim < ndims; dim++) {
						var range = rangesVals[dim];
						if (typeof range === 'number') range = [0, range];
						arr = arr.concat(range);
					}
					values[field] = arr;
				} else {
					if (!Array.isArray(arr)) throw new X3Error(26, "initial value for '" + field + "' is not an array!");
					values[field] = arr = arr.slice(0); // clone it
					if (ndims != arr[0]) throw new X3Error(26, "dimensions mismatch for '" + field + "': expected " + ndims + ", got " + arr[0]);
					// note: array was copied when parameter was assigned - so we can modify it
					var sliced = arr.length === 3 + 4 * ndims;
					for (var dim = 0; dim < ndims; dim++) {
						var range = rangesVals[dim];
						if (range) {
							if (typeof range === 'number') range = [0, range]; // for Value Integer A(6) -> A(0..6)
							var decal = range[0] - arr[3 + 2 * dim];  
							arr[3 + 2 * dim] = range[0];
							if (arr[4 + 2 * dim] !== null)
							{
								arr[4 + 2 * dim] = arr[4 + 2 * dim] + decal; 
							}
							//
							if (range[1]) {
								var count = sliced ? arr[4 + 2 * (ndims + dim)] : arr[4 + 2 * dim];
								if (count !== range[1]) throw new X3Error(26, "range mismatch for '" + field + "': expected " + count + ", got " + range[1]);
							}
						}
					}
				}
			} else {
				if (values[field] === undefined) {
					var def = exports.types[t].def;
					values[field] = def;
				}
			}
		};
	},
	CA: function(field, exps) {
		var decl = exports.instructions.DECL('LX', field, util.instructions.A([util.instructions.C(exps.length)]));
		var aexps = util.instructions.A(exps);
		return function ca$do(_) {
			var frame = glob.context.x3frame;
			decl(_);
			var val = frame.values[field];
			var vals = aexps(_);
			val[2] = vals;
		};
	},
	GET: function(obj, prop) {
		return function get$do(_) {
			//console.error("GET " + prop);
			//console.error(obj);
			return obj[prop];
		};
	},
	SET: function(lhs, rhs, silent) {
		return function set$do(_) {
			lhs(_, true, rhs.value !== undefined ? rhs.value : rhs(_), silent);
		};
	},
	ASSIGN: function(lhs, rhs, silent) {
		return function assign$do(_) {
			var target = lhs(_);
			var value = rhs.value !== undefined ? rhs.value : rhs(_);
			var args;
			var beg = target.indexOf('(');
			if(beg > 0) {
				args = target.substring(beg+1,target.lastIndexOf(')')).split(',').reduce(function(result, arg) {
					result.push(util.instructions.C(parseInt(arg)));
					return result;
				}, []);
				target = target.substring(0,beg);
			}
			var fV = exports.instructions.V(target);
			if(args) {
				var fINDEX = require('./arrays').instructions.INDEX(fV,args);
				fINDEX(_,true, value);
			} else {
				fV(_, true, value, silent);
			}
		};
	},
	RAZ: function(exps) {
		return function raz$do(_) {
			exps.forEach_(_, function(_, exp) {
				exp(_, true, raz);
			});
		};

	},
	PROP: function(target, name) {
		return function dot$do(_, assign, val, silent) {
			var t = target(_);
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid property target: " + t);
			try {
				if (assign) {
					if (typeof t.set === "function") return t.set(_, name, val);
					else return t[name] = val;
				} else {
					if (typeof t.get === "function") return t.get(_, name, val);
					else {
						var v = t[name];
						if (v === undefined) throw new X3Error(26, "missing property in built-in object: " + name);
						return v;
					}
				}
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}
		};
	},
	XMET: function(target, name, args) { // fmet and callmet
		var aargs = util.instructions.A(args);
		return function dot$do(_) {
			var t = target(_);
			// todo: review error numbers
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid method target: " + t);
			var vals = aargs(_);
			var meth;
			if (t.class) {
				meth = t.class.method(name);
				if (typeof meth !== "function") throw new X3Error(26, "method not found: " + name + " in class " + t.class.name);
			} else {
				meth = t[name];
				if (typeof meth !== "function") throw new X3Error(26, "missing method in built-in object: " + name);
			}
			try {
				return meth.apply_(_, t, vals, 0);
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}
		};
	},
	FILEVAL: function(abbrev, vars, from) {
		var avars = util.instructions.A(vars);
		return function dot$do(_) {
			throw new X3Error(26, "NIY: FILEVAL");
		};
	},
	NEW: function(clas) {
		return function new$do(_) {
			var frame = glob.context.x3frame;
			var name = clas(_);
			if (!/^C_/.test(name)) throw new X3Error(33, "NIY: new on " + name);
			var cl = frame.context.supervisor.load(_, 'Class', name.substring(2));
			if (!cl) throw new X3Error(26, "invalid class name: " + name); // TODO check errnum
			return cl.createInstance(_);
		};
	},
	FREE: function(allocGroup, isGroup) {
		return function free$do(_) {};
	},
};