"use strict";

var util = require('./util');
var config = require("etna-util/lib/nodeconfig").config.etna;

var tinteger = require('./tinteger');
var bcd = require('./tbcd');
var date = require('etna-engine/lib/runtime/tdate');
var datetime = require('etna-engine/lib/runtime/tdatetime');
var flowControl = require('etna-engine/lib/runtime/flowControl');
var tuuid = require('./tuuid');
var Blbfile = require('./tblbfile').Blbfile;
var Clbfile = require('./tclbfile').Clbfile;
var X3Error = require('./errors').X3Error;
var tdouble = require('./tdouble');
var glob = require('streamline-runtime').globals;
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.engine");

var constants = {
	CST_ATRUE: 1,
	CST_AFALSE: 0,
	CST_ALASTPOS: -1,
	CST_AFIRSTPOS: 0,
	CST_ANOTDEFINED: -1,
	CST_UTF8: 0,
	CST_ASCII: 50,
	CST_UCS2: 122
};

exports.constants = constants;

exports.clone = function(v) {
	return (v !== null && v.x3Clone && v.x3Clone()) || v;
};

exports.initStack = function(superv) {
	var cx = {
		globals: {
			values: {
				$exported: true
			},
			types: {}
		},
		sys: {
			values: {},
			types: {}
		},
		tables: {},
		gclass: {},
		superv: superv,
		loginName: process.env.USER || "<unknown>",
		// for now
		// seq file stuff
		files: {},
		messages: superv.engineErrMess
	};

	function declVar(dict, name, type, value) {
		dict.values[name] = value;
		dict.types[name] = type;
	}

	superv && superv.constants && Object.keys(superv.constants).forEach(function(constant) {
		var type;
		var v = superv.constants[constant];
		if (typeof v == "number") type = "CI";
		else if (typeof v == "string") type = "CS";
		else if (util.x3IsDate(v)) type = "CD";
		else if (util.x3IsDatetime(v)) type = "CE";
		else if (util.x3IsBCD(v)) type = "CN";
		else if (util.x3IsUuid(v)) type = "CZ";
		if (type) declVar(cx.globals, constant, type, superv.constants[constant]);
	});

	declVar(cx.sys, 'ADXCPW', 'CS64', 'CRYPT:tgrseQksgrTxure');
	declVar(cx.sys, 'ADXCTX', 'CS', '');
	declVar(cx.sys, 'ADXCUS', 'CS24', 'user');
	declVar(cx.sys, 'ADXDBC', 'CS127', 'INPDBG');
	declVar(cx.sys, 'ADXDBO', 'CS127', 'INIDBG');
	declVar(cx.sys, 'ADXDBX', 'CS127', 'ENDDBG');
	declVar(cx.sys, 'ADXDCS', 'VI', 1950); // Pivot date
	declVar(cx.sys, 'ADXDIR', 'CS254', __dirname);
	declVar(cx.sys, 'ADXDLREC', 'CI', 0);
	declVar(cx.sys, 'ADXSQLREC', 'CI', 0);
	declVar(cx.sys, 'ADXDPG', 'CS127', 'DEBUGGER');
	declVar(cx.sys, 'ADXDWEEK', 'CI', 0);
	declVar(cx.sys, 'ADXFMT', 'CS', [1, exports.types["S"].def, [
		'##',
		'5#',
		'9#',
		'9.2',
		'5.2',
		'9.2',
		'X',
		'DD[/]MM[/]YYYYYY[-]MM[-]DD[T]hh[:]mm[:]ss[Z]'
	], 0, 7]);
	declVar(cx.sys, 'ADXFMT2', 'CS', [1, exports.types["S"].def, [
		'D:DD[/]MM[/]YYYY',
		'D:DD[ ]DD[ ]MMMMMMMMMM[ ]YYYY',
		'D:hh[:]mm',
		'D:hh[:]mm[:]ss',
		'D:DD[/]MM[/]YYYY[ ]hh[:]mm',
		'D:DD[ ]MMMMMMMMMM[ ]YYYY[ ]hh[:]mm[:]ss',
		'.',
		' '
	], 0, 7]);
	declVar(cx.sys, 'ADXFTL', 'CI', 20);
	declVar(cx.sys, 'ADXGTB', 'CJ', 0);
	declVar(cx.sys, 'ADXIFS', 'VS', ''); //Field separator
	declVar(cx.sys, 'ADXIRS', 'VS2', '\n'); //Record separator
	declVar(cx.sys, 'ADXIUM', 'VI', 0); //Character set
	declVar(cx.sys, 'ADXKPG', 'CS', 'CALCULETTE');
	declVar(cx.sys, 'ADXKSP', 'CS', 'CALCULETTE');
	declVar(cx.sys, 'ADXLIG', 'CJ', 200);
	declVar(cx.sys, 'ADXLOG', 'CI', 0);
	declVar(cx.sys, 'ADXMBM', 'CI', 512);
	declVar(cx.sys, 'ADXMDA', 'VI', 0); //Angular mode
	declVar(cx.sys, 'ADXMOTHER', 'CS13 ', superv.folderName);
	declVar(cx.sys, 'ADXMPGPRO', 'CS127', 'ACTLMASKFOL');
	declVar(cx.sys, 'ADXMPGTRT', 'CS127', 'GESECRAN');
	declVar(cx.sys, 'ADXMPR', 'CI', 200);
	declVar(cx.sys, 'ADXMSO', 'VI', 10);
	declVar(cx.sys, 'ADXMTO', 'CI', 200);
	declVar(cx.sys, 'ADXMUA', 'CI', 2047);
	declVar(cx.sys, 'ADXMXL', 'CJ', 250);
	declVar(cx.sys, 'ADXOVF', 'CS', 'VALID_ONDEMAND');
	declVar(cx.sys, 'ADXOVS', 'CS', 'ACLAVAL');
	declVar(cx.sys, 'ADXROB', 'CS254', 'ECR');
	declVar(cx.sys, 'ADXSAX', 'CS254', '');
	declVar(cx.sys, 'ADXSCA', 'VS', '?? .#*???');
	declVar(cx.sys, 'ADXSES', 'CI', 1);
	// declVar(cx.sys,'ADXSQLREC','CI',0);
	declVar(cx.sys, 'ADXTCT', 'CS254', 'APLCOM');
	declVar(cx.sys, 'ADXTLK', 'CS254', 'APLLCK');
	declVar(cx.sys, 'ADXTMS', 'CS254', 'APLSTD');
	declVar(cx.sys, 'ADXTRL', 'CS', 'ATRIOPE');
	declVar(cx.sys, 'ADXTRO', 'CS2', '');
	declVar(cx.sys, 'ADXTRP', 'CS254', 'ATRIFIL');
	declVar(cx.sys, 'ADXTUL', 'CS', superv.ADXTUL);
	declVar(cx.sys, 'ADXTUT', 'CS', superv.ADXTUT);
	declVar(cx.sys, 'ADXTUC', 'CS', superv.ADXTUC);
	declVar(cx.sys, 'ADXUPREC', 'CI', 0);
	declVar(cx.sys, 'ADXUSR', 'CS', process.env.USER || "AQCORE");
	declVar(cx.sys, 'ADXWRB', 'CI', 1);
	declVar(cx.sys, 'DATESYST', 'VD', date.today(false));
	declVar(cx.sys, 'LOCKWAIT', 'VI', 0);
	declVar(cx.sys, 'FSTAT', 'VI', 0);
	declVar(cx.sys, 'INDCUM', 'CI', 0);
	declVar(cx.sys, 'INDICE', 'VI', 0);
	declVar(cx.sys, 'MESSNAME', 'VS', "FRA");
	declVar(cx.sys, 'BASEURL', 'VS', superv.baseUrl);

	var frame = {
		values: {},
		types: {},
		context: cx,
		loc: {
			file: module.id,
			line: 0,
		},
		prog: {},
		stackLevel: 0,
		loopLevel: 0,
	};
	frame.sub = frame;
	// TODO: investigate how data (F class) is managed - global for now
	frame.dicts = [frame, cx.globals, cx.sys, cx.tables];
	frame.tablePos = 2;
	glob.context.x3frame = frame;
};

function x3Val(val) {
	if (val !== undefined)
		return (typeof val === 'boolean') ? (val ? constants.CST_ATRUE : constants.CST_AFALSE) : val;
}
exports.x3Val = x3Val;

exports.functions = {
	VARMODE: {
		count: 0
	},
};

exports.types = {
	B: {
		name: 'BLBFILE',
		value: 522,
		jsonDefaultType: "application/x-binary",
		default: new Blbfile(new Buffer(0)),
		set: function(field, type, val) {
			return val = util.x3IsBlbfile(val) ? val : new Blbfile(val);
		}
	},
	D: {
		name: 'DATE',
		value: 3,
		jsonDefaultType: "application/x-date",
		default: date.make(0, 0, 0),
		set: function(field, type, val) {
			try {
				return val.x3ToDate();
			} catch (e) {
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	E: {
		name: 'DATETIME',
		value: 526,
		jsonDefaultType: "application/x-datetime",
		default: datetime.fromMillis(0),
		set: function(field, key, val) {
			try {
				return val.x3ToDatetime();
			} catch (e) {
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	I: {
		name: 'INTEGER',
		value: 4,
		jsonDefaultType: "application/x-integer",
		default: 0,
		set: function(field, key, val) {
			try {
				val = val.x3ToInteger();
			} catch (e) {
				if (e.errn) throw new X3Error(e);
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			if (Math.abs(val) >= tinteger.MAX_INT) throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		}
	},
	J: {
		name: 'SHORTINT',
		value: 2,
		jsonDefaultType: "application/x-integer",
		default: 0,
		set: function(field, key, val) {
			try {
				val = val.x3ToInteger();
			} catch (e) {
				if (typeof val === 'boolean') {
					val = val ? constants.CST_ATRUE : constants.CST_AFALSE;
				} else {
					throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
				}
			}
			if (val < tinteger.MIN_SHORTINT || val > tinteger.MAX_SHORTINT) throw new X3Error(13, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		}
	},
	N: {
		name: 'DECIMAL',
		value: 7,
		jsonDefaultType: "application/x-decimal",
		default: bcd.fromDouble(0),
		set: function(field, type, val) {
			try {
				return val.x3ToBCD();
			} catch (e) {
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	S: {
		name: 'CHAR',
		value: 10,
		jsonDefaultType: "application/x-string",
		default: "",
		set: function(field, type, val) {
			try {
				val = val.x3ToString();
			} catch (e) {
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			return (type.length > 2) ? val.substring(0, parseInt(type.substring(2))) : val;
		}
	},
	T: {
		name: 'CLBFILE',
		value: 523,
		jsonDefaultType: "text",
		default: new Clbfile(""),
		set: function(field, key, val) {
			try {
				return val.x3ToClbfile();
			} catch (e) {
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	/*	U: {
		name: 'SCHAR',
		value: 10,
		def: ""
	},*/
	V: {
		name: 'TINYINT',
		value: 1,
		jsonDefaultType: "application/x-integer",
		default: 0,
		set: function(field, key, val) {
			try {
				val = val.x3ToInteger();
			} catch (e) {
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			if (val < tinteger.MIN_TINYINT || val > tinteger.MAX_TINYINT) throw new X3Error(13, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		}
	},
	W: {
		name: 'DOUBLE',
		jsonDefaultType: "application/x-decimal",
		value: 6,
		default: new tdouble.Double(0),
		set: function(field, type, val) {
			try {
				return val.x3ToDouble();
			} catch (e) {
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	X: {
		name: 'ANY',
		value: -1,
		jsonDefaultType: "",
		default: null,
		set: function(field, key, val) {
			return val;
		}
	},
	Y: {
		name: 'INSTANCE',
		value: 524,
		jsonDefaultType: "",
		default: null,
		set: function(field, key, val) {
			return val;
		}
	},
	Z: {
		name: 'UUIDENT',
		value: 525,
		jsonDefaultType: "application/x-string",
		default: tuuid.make(),
		set: function(field, key, val) {
			try {
				return val.x3ToUuid();
			} catch (e) {
				throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
};

exports.typeLetters = Object.keys(exports.types).reduce(function(r, l) {
	r[exports.types[l].value] = l;
	return r;
}, {});
(function() {
	for (var i = 1; i <= 255; i++) exports.typeLetters[10 + i] = 'S';
})();

// storage classes
exports.dictClasses = {
	VARIABLE: 'A',
	VALUE: 'B',
	CONST: 'C',
	DEFAULT: 'D',
	GLOBAL: 'V',
	LOCAL: 'L',
	// + F (table), M (mask) and S (sequential) that don't have keywords
};

function autoType(dict, field, v) {
	// Let's resolve the proper type :
	if (Array.isArray(v)) v = v[1];
	if (typeof v == "number") dict.types[field] = "BI";
	else if (typeof v == "string") dict.types[field] = "BS";
	else if (util.x3IsDate(v)) dict.types[field] = "BD";
	else if (util.x3IsDatetime(v)) dict.types[field] = "BE";
	else if (util.x3IsBCD(v)) dict.types[field] = "BN";
	else if (util.x3IsUuid(v)) dict.types[field] = "BZ";
	else if (util.x3IsDouble(v)) dict.types[field] = "BW";
	else if (util.x3IsBlbfile(v)) dict.types[field] = "BB";
	else if (util.x3IsClbfile(v)) dict.types[field] = "BT";
	else if (util.x3IsInstance(v)) dict.types[field] = "BY";
}

exports.vOperations = {
	GET: {
		fn: function(frame, dict, field, val, silent, strict) {
			//tracerJs.debug && tracerJs.debug("GET " + field + " type:" + dict.types[field]);
			if (dict.types[field] != "CX") {
				var key = dict.types[field];
				if (key && /^[cb]$/.test(key[0])) {
					// Let's copy data of the array : 
					var prevArr = dict.values[field][2];
					var newArr = [];
					for (var i = 0; i < prevArr.length; i++) {
						newArr[i] = prevArr[i];
					}
					dict.values[field][2] = newArr;
					dict.types[field] = key[0].toUpperCase() + key.substring(1);
					tracerJs.debug && tracerJs.debug("dict.values[field] " + dict.values[field]);
				}
				return dict.values[field];
			}
			var v = dict.values[field];
			autoType(dict, field, v);
			if (Array.isArray(v)) {
				//make a copy for Values and Const and not declared
				var newtab = [];
				for (var n = 0; n < v.length; n++) {
					// copy arrays of object passed
					if (Array.isArray(v[n])) {
						var newtab2 = [];
						for (var k = 0; k < v[n].length; k++) {
							newtab2[k] = v[n][k];
						}
						newtab[n] = newtab2;
					} else {
						newtab[n] = v[n];
					}
				}
				if (newtab[4] !== null) newtab[4] = newtab[4] - newtab[3];
				newtab[3] = 0;
				dict.values[field] = v = newtab;
			}
			return v;
		},
		error: function(_, frame, field, val, silent, strict) {
			if (silent) return;
			tracerJs.debug && tracerJs.debug("frame:" + JSON.stringify(frame.values));
			throw new X3Error(6, "undefined variable: " + field);
		}

	},
	SET: {
		fn: function(frame, dict, field, val, silent, strict) {
			tracerJs.debug && tracerJs.debug("SET " + field + " type:" + dict.types[field] + " val:" + val);
			var type = dict.types[field];
			if (type === undefined) {
				throw new X3Error(62, frame.prog.name + ": '" + field + "' not declared");
			} else if (type[0] === 'C') {
				throw new X3Error(62, frame.prog.name + ": '" + field + "' Variable not modifiable");
			} else if (!Array.isArray(val)) {
				return dict.values[field] = exports.types[type[1]].set(field, type, val);
			}
			return dict.values[field] = val;
		},
		error: function(_, frame, field, val, silent, strict) {
			if (strict || frame.loc.strict) {
				throw new X3Error(6, "undefined variable: " + field);
			} else {
				frame.values[field] = val;
				frame.types[field] = "L" + (typeof val == 'number' ? 'I' : 'S');
			}
		}
	},
	GETINFO: {
		fn: function(frame, dict, field) {
			var type = dict.types[field];
			var vsz = function() {

				switch (type[1]) {
					case "I":
						return 4;
					case "J":
						return 2;
					case "V":
						return 1;
					case "S":
						var l = parseInt(type.substr(2)) + 1;
						return l * 2;
					case "B":
					case "T":
						var l = parseInt(type.substr(2));
						l = 1 << (10 + l);
						return l;
					case "D":
						return ((type[0] === " ") && (dict !== glob.context.x3frame.context.sys)) ? 3 : 4;
					case "Z":
						return 16;
					case "E":
						return 8;
					case "N":
						return 20;
					default:
						return undefined;
				}
			};

			return {
				"dictionnary": dict,
				"vdeclaration": type[0],
				"vtype": type[1],
				"vlength": ("STB".lastIndexOf(type[1]) >= 0) ? parseInt(type.substr(2)) : undefined,
				"vstring": type,
				"vsize": vsz(),
				"vname": field
			};
		},
		error: function() {
			throw new X3Error(6, "undefined variable: " + field);
		}
	},
	RAZ: {
		fn: function(frame, dict, field, val, silent, strict) {
			if (Array.isArray(dict.values[field])) {
				var arr = dict.values[field];
				arr[2] = [];
				dict.values[field] = arr;
			} else {
				dict.values[field] = exports.clone(exports.types[dict.types[field][1]].default);
				// console.log("RAZ "+field+" value:"+dict.values[field]);
			}
			return 0;
		},
		error: function(_, frame, field, val, silent, strict) {
			throw new X3Error(6, "undefined variable: " + field);
		}
	},
	TYPE: {
		fn: function(frame, dict, field, val, silent, strict) {
			if (dict.types[field] === "CX") autoType(dict, field, dict.values[field]);
			var type = exports.types[dict.types[field][1]].value;
			if (dict.types[field][1] == 'S' && dict.types[field].length > 2)
				type += parseInt(dict.types[field].substring(2), 10);
			return type;
		},
		error: function(_, frame, field, val, silent, strict) {
			return -1;
		}
	},
	DIM: {
		fn: function(frame, dict, field, dim, silent, strict) {
			//!console.log("DIM:"+field+" type:"+dict.types[field]+" dim:"+dim);
			if (dict.types[field] === "CX") autoType(dict, field, dict.values[field]);
			var a = dict.values[field];
			if (a === undefined) return -1;
			var d = dim !== undefined ? dim : 1;
			//tracerJs.debug && tracerJs.debug("DIM: " + JSON.stringify(a) + " dim=" + dim);
			// basic values are considered to be arrays of 1 elt.
			if (!Array.isArray(a)) return d === -1 ? 0 : 1;
			var ndims = a[0];
			if (d === 0) return ndims;
			if (!(d >= -ndims && d <= ndims)) throw new X3Error(50, d);
			var sliced = a.length === 3 + 4 * a[0];
			//tracerJs.debug && tracerJs.debug("DIM: " + JSON.stringify(a) + " ndims=" + ndims + " sliced=" + sliced);
			if (sliced) {
				if (d > 0) return a[4 + 2 * (ndims + (d - 1))];
				else return a[3 + 2 * -(d + 1)];
			} else {
				if (d > 0) {
					if (a[4 + 2 * (d - 1)] === null) {
						return (dict.types[field][0] === 'B' && a[2].length) ? a[2].length : 32767;
					} else {
						return a[4 + 2 * (d - 1)] - a[3 + 2 * (d - 1)] + 1;
					}
				} else return a[3 + 2 * -(d + 1)];
			}
		},
		error: function(_, frame, field, val, silent, strict) {
			return -1;
		}
	},
	KILL: {
		fn: function(frame, dict, field, val, silent, strict) {
			dict.values[field] = undefined;
			dict.types[field] = undefined;
			return 0;
		},
		error: function(_, frame, field, val, silent, strict) {
			throw new X3Error(6, "undefined variable: " + field);
		}
	}
};

function handleError(ex) {
	if (ex instanceof X3Error) throw ex;
	throw new X3Error(26, ex.message, ex.stack);
}

exports.instructions = {
	DEFAULT: function(scope, exp) {
		return function defaultfn$do(_) {

		};
	},
	CLALEV: function(arg) {
		return function clalev$do(_) {
			var a = arg(_, false, undefined, true);
			var frame = glob.context.x3frame;
			if (!a) return 0;
			if (typeof a === "number") {
				var abbr = Object.keys(frame.context.table)[a - 1];
				if (abbr) return abbr;
				else throw new X3Error(10, "clalev number out of range: " + a);
			} else {
				if (!a.values) throw new X3Error(10, "clalev argument is not a class");
				return 1;
			}
		};
	},
	V: function(field) {
		if (typeof constants[field] !== 'undefined') {
			var fn = function v$do(_) {
				return constants[field];
			};
			fn.value = constants[field];
			return fn;
		}
		return function v$do(_, operation, val, silent, strict) {
			var frame = glob.context.x3frame;
			var fdo = operation ? operation : exports.vOperations.GET;
			// optimize read of local variable
			//if (!operation && (v = frame.values[field]) !== undefined) return v;
			var dicts = frame.dicts;
			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				if (dict === frame.context.tables) {

					var keys = Object.keys(dict);
					//for (var j = 0; !found && j < keys.length; j++) {
					for (var j = 0; j < keys.length; j++) {
						var abb = keys[j];
						var values = dict[abb].values;
						if (dict[abb].values[field]) {
							dict = dict[abb];
							return fdo.fn(frame, dict[abb], field, val, silent, strict, full);
						}
					}
				} else if (dict.values[field] !== undefined) {
					return fdo.fn(frame, dict, field, val, silent, strict);
				}
			}
			return fdo.error(_, frame, field, val, silent, strict);
		};
	},
	TYPE: function(letter, field) {
		var fv;
		if (letter.length) fv = exports.instructions.CV(letter, '', field);
		else fv = exports.instructions.V(field);
		return function typev$do(_) {
			return fv(_, exports.vOperations.TYPE);
		};
	},
	DIM: function(letter, field, rhs) {
		var fv;
		if (letter.length) fv = exports.instructions.CV(letter, '', field);
		else fv = exports.instructions.V(field);
		return function dim$do(_) {
			if (rhs !== undefined) return fv(_, exports.vOperations.DIM, rhs.value !== undefined ? rhs.value : rhs(_));
			return fv(_, exports.vOperations.DIM);
		};
	},
	DYNTYPE: function(arg) {
		return function dyntype$do(_) {
			var val = arg(_);
			return val && val.x3Type ? val.x3Type() : -1;
		};
	},
	DYNDIM: function(arg) {
		return function dyndim$do(_) {
			try {
				var val = arg(_);
				return val && val.x3Dim ? val.x3Dim() : 1;
			} catch (e) {
				// Has to support syntanx like DIM(AINSTANCE.ACTX.LAN) where ACTX doesn't exist
				console.error(e.message);
			}
			return 0;
		};
	},
	CV: function(letter, abbrev, field, silent) {
		if (typeof constants[field] !== 'undefined') {
			var fn = function v$do(_) {
				return constants[field];
			};
			fn.value = constants[field];
			return fn;
		}

		letter = (letter == 'D') ? 'L' : letter;
		if (config.optimize) {
			if (letter == 'L') {
				return function cv$do(_, operation, val, silent, strict) {
					var frame = glob.context.x3frame;
					var fdo = operation ? operation : exports.vOperations.GET;
					if (frame.values[field] !== undefined)
						return fdo.fn(frame, frame, field, val, silent, strict);
					else
						return fdo.error(_, frame, field, val, silent, strict);
				};
			} else if (letter == 'V') {
				return function cv$do(_, operation, val, silent, strict) {
					var frame = glob.context.x3frame;
					var fdo = operation ? operation : exports.vOperations.GET;
					if (frame.context.globals.values[field] !== undefined)
						return fdo.fn(frame, frame.context.globals, field, val, silent, strict);
					else
						return fdo.error(_, frame, field, val, silent, strict);
				};
			} else if (letter == 'S') {
				return function cv$do(_, operation, val, silent, strict) {
					var frame = glob.context.x3frame;
					var fdo = operation ? operation : exports.vOperations.GET;
					if (frame.context.sys.values[field] !== undefined)
						return fdo.fn(frame, frame.context.sys, field, val, silent, strict);
					else
						return fdo.error(_, frame, field, val, silent, strict);
				};
			}
		}
		return function cv$do(_, operation, val, silent, strict) {
			var frame = glob.context.x3frame;
			var fdo = operation ? operation : exports.vOperations.GET;

			var dict;

			switch (letter) {
				case 'L':
					dict = frame;
					break;
				case 'V':
					dict = frame.context.globals;
					break;
				case 'S':
					dict = frame.context.sys;
					break;
				case 'G':
					dict = frame.context.gclass[abbrev || frame.abbrev];
					if (!dict) throw new X3Error(7, 'unknown class: [G:' + (abbrev || frame.abbrev) + ']');
					break;
				case 'F':
				case '?':
					dict = frame.context.tables;

					if (abbrev) {
						dict = dict[abbrev];
						if (!dict) {
							if (operation) {
								val.abbrev = abbrev;
								return frame.context.tables[abbrev] = val;
							} else if (silent) return null;
							else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
						}
					} else {
						var found;
						var keys = Object.keys(dict);
						for (var i = 0; !found && i < keys.length; i++) {
							var abb = keys[i];
							var d = dict[abb];
							found = (d.values[field] !== undefined);
							if (found) dict = d;
						}
						if (!found) {
							if (silent) return null;
							else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
						}
					}
					break;
				default:
					throw new X3Error(26, 'unknown class letter: [' + letter + ']');

			}

			if (!dict) {
				if (false && frame.tryingSql) { // REVIEW!!!
					var err = new Error("trying sql (ignore)");
					err.tooComplexForSql = true;
					throw err;
				}
			} else {
				if (dict.values[field] !== undefined)
					return fdo.fn(frame, dict, field, val, silent, strict);
				else
					return fdo.error(_, frame, field, val, silent, strict);
			}
		};
	},
	DECL: function(key, field, using, lens0, ranges0) {
		key = (key[0] == 'D') ? 'L' + key.substring(1) : key;
		var letter = key[0];
		var t = key[1];
		var def = exports.types[t].default;

		if (config.optimize && lens0 === undefined && ranges0 === undefined) {
			if (letter === "V")
				return function decl$do(_) {
					glob.context.x3frame.context.globals.values[field] = exports.clone(def);
					glob.context.x3frame.context.globals.types[field] = key;
				};
			else if (letter === "L")
				return function decl$do(_) {
					glob.context.x3frame.values[field] = exports.clone(def);
					glob.context.x3frame.types[field] = key;
				};
		}

		return function decl$do(_) {
			var frame = glob.context.x3frame;
			var lens = lens0,
				ranges = ranges0;
			var letter = key[0];
			var dict = letter === 'V' ? frame.context.globals : frame;
			var values = dict.values;

			if (lens) {
				if (!/^[STB]$/.test(t)) {
					ranges = lens;
					lens = undefined;
				} else {
					key += (lens(_)[0] || "");
				}
			}
			// Set the proper type :
			dict.types[field] = key;

			var arr;
			if (/^[LV]$/.test(letter)) values[field] = undefined; // Kill : the value
			else arr = values[field]; // for arrays :	

			var rangesVals;
			if (ranges) {
				rangesVals = ranges(_);
			} else if (arr && Array.isArray(arr)) {
				ranges = [0, null];
				rangesVals = [ranges];
			}

			// ignore using (for now)
			if (ranges) {
				var ndims = rangesVals.length;
				var dim;
				var range;
				if (arr === undefined) {
					// Create an empty array
					arr = [ndims, def, []];

					for (dim = 0; dim < ndims; dim++) {
						range = rangesVals[dim];
						if (typeof range === 'number') range = [0, range - 1]; // for Value Integer A(6) -> A(0..5)
						arr = arr.concat(range);
					}
					values[field] = arr;
				} else {
					if (ndims != arr[0]) throw new X3Error(26, "dimensions mismatch for '" + field + "': expected " + ndims + ", got " + arr[0]);

					// note: array's dimensions were copied when parameter was assigned - so we can modify them :
					var sliced = arr.length === 3 + 4 * ndims;
					for (dim = 0; dim < ndims; dim++) {
						range = rangesVals[dim];
						if (range) {
							if (typeof range === 'number') range = [0, range - 1]; // for Value Integer A(6) -> A(0..5)
							var decal = range[0] - arr[3 + 2 * dim];
							arr[3 + 2 * dim] = range[0];
							if (arr[4 + 2 * dim] !== null) {
								arr[4 + 2 * dim] = arr[4 + 2 * dim] + decal;
							}
							//
							if (range[1]) {
								var count = sliced ? arr[4 + 2 * (ndims + dim)] : arr[4 + 2 * dim];
								if (count !== range[1]) throw new X3Error(26, "range mismatch for '" + field + "': expected " + count + ", got " + range[1]);
							}
						}
					}
					// Make a copy of array's data for Values and Const
					if (/^[CB]$/.test(key[0]) && arr && Array.isArray(arr)) {
						// mark the field as 'has to be copied' is any instruction try access to it:
						// B => b !
						// C => c !
						// Be carefull that INDEX performs a GET first...
						dict.types[field] = key[0].toLowerCase() + key.substring(1);
					}
				}
			} else if (/^[LV]$/.test(letter)) {
				// Set the type's default value
				values[field] = exports.clone(def);
			}
		};
	},
	CA: function(field, exps) {
		var decl = exports.instructions.DECL('LX', field, util.instructions.A([util.instructions.C(exps.length)]));
		var aexps = util.instructions.A(exps);
		return function ca$do(_) {
			var frame = glob.context.x3frame;
			decl(_);
			var val = frame.values[field];
			var vals = aexps(_);
			val[2] = vals;
		};
	},
	GET: function(obj, prop) {
		return function get$do(_) {
			//console.error("GET " + prop);
			//console.error(obj);
			return obj[prop];
		};
	},
	SET: function(lhs, rhs, silent) {
		if (config.optimize && typeof rhs != "function")
			return function set$do(_) {
				lhs(_, exports.vOperations.SET, rhs, silent);
			};
		return function set$do(_) {
			lhs(_, exports.vOperations.SET, rhs.value !== undefined ? rhs.value : rhs(_), silent);
		};
	},
	ASSIGN: function(lhs, rhs, silent) {
		return function assign$do(_) {
			var str = util.x3ToString(lhs(_), true);
			var lhs2 = require('./evaluate').compile(str);
			lhs2(_, exports.vOperations.SET, rhs.value !== undefined ? rhs.value : rhs(_), silent, true);
			/*
			var target = lhs(_).toUpperCase();
			var value = rhs.value !== undefined ? rhs.value : rhs(_);
			var args;
			var beg = target.indexOf('(');
			if (beg > 0) {
				args = target.substring(beg + 1, target.lastIndexOf(')')).split(',').reduce(function(result, arg) {
					result.push(util.instructions.C(parseInt(arg)));
					return result;
				}, []);
				target = target.substring(0, beg);
			}
			var fV = exports.instructions.V(target);
			if (args) {
				var fINDEX = require('./arrays').instructions.INDEX(fV, args);
				fINDEX(_, true, value);
			} else {
				//strict = true
				fV(_, exports.vOperations.SET, value, silent, true);
			}
			*/
		};
	},
	RAZ: function(exps) {
		return function raz$do(_) {
			exps.forEach_(_, function(_, exp) {
				exp(_, exports.vOperations.RAZ);
			});
		};

	},
	SNAP: function(target) {
		return function dot$do(_, assign, val, silent) {
			var t = target(_);

			if (assign)
				throw new X3Error(155, "");
			else {
				return t.snapshot();
			}
		};
	},
	PROP: function(target, name) {
		return function dot$do(_, assign, val, silent) {
			var t = target(_);
			tracerJs.debug && tracerJs.debug("PROP:" + name + " assign:" + assign + " val:" + val);

			if (!t || !(t.class || t.$exported)) {
				tracerJs.error && tracerJs.error("PROP:" + name + " assign:" + assign + " val:" + val);
				throw new X3Error(26, "invalid property target: " + JSON.stringify(t));
			}
			try {
				if (assign) {
					if (typeof t.set === "function") return x3Val(t.set(_, name, val));
					else return t[name] = val;
				} else {
					if (typeof t.get === "function") return x3Val(t.get(_, name, glob.context.debug));
					else {
						var v = t[name];
						if (v === undefined) {
							Object.keys(t).forEach(function(p) {
								console.error("t." + p);
							});
							throw new X3Error(26, "missing property in built-in object: " + name);
						}
						return v;
					}
				}
			} catch (ex) {
				tracerJs.error && tracerJs.error("PROP exception:" + JSON.stringify(ex));
				handleError(ex);
			}
		};
	},
	ATT: function(target, property, attribut) {
		if (property)
			return function att$do(_, assign, val, silent) {
				var t = target(_);
				tracerJs.debug && tracerJs.debug("ATT attribut:" + attribut + " property:" + property + " assign:" + assign + " val:" + val);

				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid property target: " + t);
				try {
					if (assign) {
						if (typeof t.setPropertyAttribute === "function") {
							return x3Val(t.setPropertyAttribute(_, property, attribut, val));
						}
					} else {
						if (typeof t.getPropertyAttribute === "function") {
							return x3Val(t.getPropertyAttribute(_, property, attribut));
						}
					}
				} catch (ex) {
					handleError(ex);
				}

			};
		else
			return function att$do(_, assign, val, silent) {
				var t = target(_);
				tracerJs.debug && tracerJs.debug("ATT attribut:" + attribut + " property:" + property + " assign:" + assign + " val:" + val);

				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid target: " + t);
				try {
					if (assign) {
						if (typeof t.setAttribute === "function") return t.setAttribute(attribut, val);
					} else {
						if (typeof t.getAttribute === "function") {
							return x3Val(t.getAttribute(attribut));
						}
					}
				} catch (ex) {
					handleError(ex);
				}

			};

	},
	AGETATTR: function(target, property, attribut) {
		if (property)
			return function agetattr$do(_, silent) {
				var t = target(_);
				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
				try {
					if (typeof t.getPropertyAttribute === "function") {
						return x3Val(t.getPropertyAttribute(_, property, attribut(_)));
					}
				} catch (ex) {
					handleError(ex);
				}
			};
		else
			return function agetattr$do(_, silent) {
				var t = target(_);
				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
				try {
					if (typeof t.getAttribute === "function") {
						return x3Val(t.getAttribute(attribut(_)));
					}
				} catch (ex) {
					handleError(ex);
				}
			};
	},
	ASETATTR: function(target, property, attribut, val) {
		if (property)
			return function asetattr$do(_, silent) {
				var t = target(_);
				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
				try {
					if (typeof t.setPropertyAttribute === "function") return x3Val(t.ASETATTRPROP(_, property, attribut(_), val(_)));
				} catch (ex) {
					handleError(ex);
				}
			};
		else
			return function asetattr$do(_, silent) {
				var t = target(_);
				if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
				try {
					if (typeof t.setAttribute === "function") return x3Val(t.ASETATTR(attribut(_), val(_)));
				} catch (ex) {
					handleError(ex);
				}
			};
	},
	XMET: function(target, name, args) { // fmet and callmet
		var aargs = util.instructions.A(args);
		return function dot$do(_) {
			var t = target(_);
			// todo: review error numbers
			// if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid method target: " + t);

			if (!t) throw new X3Error(26, "invalid method target: " + t);
			try {
				var meth = t[name];
				if (t.class || t.$exported) {
					if (meth && typeof meth === "function") {
						return x3Val(meth.apply_(_, t, aargs(_), 0));
					}
					meth = t.xmet(name);
					if (meth) {
						// Support methods with variables parameters:
						return x3Val(meth.apply_(_, t, args, 0));
					}
					throw new X3Error(26, "method not found: " + name + (t.class ? " in class " + t.class.name : ""));
				} else {
					if (meth && meth.params && meth.body && typeof meth.body === 'function') {
						var frame = glob.context.x3frame;
						return x3Val(flowControl.callProg(_, meth, args, aargs(_), frame.sub.loc));
					} else throw new X3Error(26, "missing method in built-in object: " + name + " t:" + Object.keys(t));

				}
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	FILEVAL: function(abbrev, vars, from) {
		var avars = util.instructions.A(vars);
		return function dot$do(_) {
			throw new X3Error(26, "NIY: FILEVAL");
		};
	},
	NEW: function(clas) {
		return function new$do(_) {
			var frame = glob.context.x3frame;
			var name = clas(_);
			if (!/^C_/.test(name)) throw new X3Error(33, "Invalid class name: " + name);
			var cl = frame.context.superv.load(_, 'Class', name.substring(2));
			if (!cl) throw new X3Error(26, "invalid class name: " + name); // TODO check errnum
			return cl.createInstance ? cl.createInstance(_) : cl;
		};
	},
	FREE: function(allocGroup, isGroup) {
		return function free$do(_) {};
	},
	KILL: function(exps) {
		return function raz$do(_) {
			exps.forEach_(_, function(_, exp) {
				exp(_, exports.vOperations.KILL);
			});
		};

	},
	CLA: function(letter, abbrev) {
		return function cla$do(_, operation, val, silent, strict) {
			var frame = glob.context.x3frame;
			var dict;

			switch (letter) {
				case 'L':
					dict = frame;
					break;
				case 'V':
					dict = frame.context.globals;
					break;
				case 'F':
					dict = frame.context.tables[abbrev || frame.abbrev];
					break;
			}
			if (dict && (operation == exports.vOperations.KILL || operation == exports.vOperations.RAZ)) {
				Object.keys(dict.values).forEach(function(field) {
					if (!(letter === 'F' && field === 'ROWID')) operation.fn(frame, dict, field);
				});
			} else if (!dict && operation == exports.vOperations.RAZ) {
				throw new X3Error(7, "Raz non-existent class");
			}
			return dict;
		};
	},
	AADD: function(target, position) {
		return function aadd$do(_, silent) {
			var t = target(_);
			if (!t || !(t.collection || t.$exported)) throw new X3Error(26, "invalid collection : " + t);
			try {
				if (typeof t.add === "function") return t.add(_, position(_));
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	ADEL: function(target, position) {
		return function adel$do(_, silent) {
			var t = target(_);
			if (!t || !(t.collection || t.$exported)) throw new X3Error(26, "invalid collection : " + t);
			try {
				if (typeof t.del === "function") return t.del(_, position(_));
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	ASETCOLUMNATTR: function(target, collection, column, attribute, val) {
		return function asetcolumnattr$do(_, silent) {
			var t = target(_);
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid class : " + t);
			try {
				if (typeof t.setColumnAttribute === "function") return t.setColumnAttribute(_, collection, column(_), attribute(_), val(_));
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	AGETCOLUMNATTR: function(target, collection, column, attribute) {
		return function agetcolumnattr$do(_, silent) {
			var t = target(_);
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid class : " + t);
			try {
				if (typeof t.getColumnAttribute === "function") {
					return x3Val(t.getColumnAttribute(_, collection, column(_), attribute(_)));
				}
			} catch (ex) {
				handleError(ex);
			}
		};
	},

	AGETTEXT: function(target, property) {
		return function agettext$do(_, silent) {
			const t = target(_);
			return t.AGETTEXT(_, property);
		};
	},
	ASETTEXT: function(target, property, intit) {
		return function asettext$do(_, silent) {
			const t = target(_);
			return t.ASETTEXT(_, property, intit, t.get(_, property));
		};
	},
	AGETTEXTLAN: function(target, property, lan) {
		return function agettextlan$do(_, silent) {
			const t = target(_);
			return t.ASETTEXTLAN(_, property, lan);

		};
	},
	ASETTEXTLAN: function(target, property, intit, lan) {
		return function asettextlan$do(_, silent) {
			const t = target(_);
			return t.ASETTEXTLAN(_, property, intit, t.get(_, property), lan);
		};
	},
};