"use strict";

var util = require('./util');
var arrays = require('./arrays');

var tinteger = require('./tinteger') ;
var bcd = require('./bcd') ;
var date     = require('etna-engine/lib/runtime/tdate') ;
var datetime = require('etna-engine/lib/runtime/tdatetime') ;
var tstring = require('./tstring') ;
var tuuid = require('./tuuid') ;
var Blbfile = require('./tblbfile').Blbfile ;
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');

exports.initStack = function(superv) {
	var cx = {
		globals: {
			values: {
				$exported: true
			},
			types: {}
		},
		sys: {
			values: {},
			types: {}
		},
		tables: {},
		superv: superv,
		loginName: process.env.USER || "<unknown>",
		// for now
		// seq file stuff
		files: {},
		messages : superv.engineErrMess
	};

	function declVar(dict,name, type, value) {
		dict.values[name] = value;
		dict.types[name] = type;
	}
 
	declVar(cx.globals,'AVOID','Y',{
		$exported: true,
		ADATE: require("etna-engine/lib/runtime/dates").ORIGIN,
	});
	//declVar(cx.globals,'GACTX','Y',superv.currentContext();

	declVar(cx.globals,'CST_AOK','I', 0);
	declVar(cx.globals,'CST_ANO','I', 1);
	declVar(cx.globals,'CST_AYES','I', 2);
	declVar(cx.globals,'CST_AINFO','I', 2);
	declVar(cx.globals,'CST_AWARNING','I', 3);
	declVar(cx.globals,'CST_AERROR','I', 4);
	declVar(cx.globals,'CST_AFATAL','I', 5);
	declVar(cx.globals,'CST_AFALSE','I', 0);
	declVar(cx.globals,'CST_ATRUE','I', 1);
	declVar(cx.globals,'CST_ASUCCESS','I', 1);

	declVar(cx.globals,'GUSER','S',"bruno");
	declVar(cx.globals,'GLOGIN','S',"brjou");
	
	// for adxium
	declVar(cx.globals,'GUTF8','I',1);
	declVar(cx.globals,'GVIRTDIR','S',"localhost:8124");

	declVar(cx.sys,'ADXIFS', 'S', ',');
	declVar(cx.sys,'ADXIRS', 'S', '\n');
	declVar(cx.sys,'ADXIUM', 'I', 0);
	declVar(cx.sys,'adxsca', 'S', '?? .#*???');
	declVar(cx.sys,'fstat', 'I', 0);
	declVar(cx.sys,'ADXUPREC', 'I', 0);
	declVar(cx.sys,'ADXDLREC', 'I', 0);
	declVar(cx.sys,'INDICE', 'I', 0);
	declVar(cx.sys,'adxmda', 'S', 0);
	declVar(cx.sys,'adxdcs', 'I', 1940);
	declVar(cx.sys,'messname', 'S', superv.LAN) ;
	declVar(cx.sys,'adxmbm', 'I', 0) ;
	declVar(cx.sys,'datesyst', 'D', date.today(false)) ;


	var frame = {
		values: {},
		types: {},
		context: cx,
		loc: {
			file: module.id,
			line: 0,
		},
		prog: {},
		loopLevel: 0,
	};
	frame.sub = frame;
	// TODO: investigate how data (F class) is managed - global for now
	frame.dicts = [frame, cx.globals, cx.sys, cx.tables];
	frame.tablePos = 2;
	glob.context.x3frame = frame;
};

exports.functions = {
	TYPE: {
		count: 1,
		fn: function(t) {
			if (typeof t !== "string") {
				// guess type from value
				var v = t.value;
				switch (typeof v) {
				case 'string':
					return 10 + 512;
				case 'number':
					return ((v | 0) === v) ? 4 : 7;
				case 'object':
					if (date.isDate(v)) return 3;
					if (datetime.isDatetime(v)) return 526;
					if (Buffer.isBuffer(v)) return 522;
					if (v && (v.$exported || v.class)) return 524;
					return -1;
				default:
					return -1;
				}
			}
			var type = exports.types[t[1]];
			if (!type) throw new X3Error(26, "bad type: " + t);
			return type.value === 10 && t.length > 2 ? 10 + parseInt(t.substring(2), 10) : type.value;
		}
	},
	VARMODE: {
		count: 0
	},
};

exports.types = {
	B: {
		name: 'BLBFILE',
		value: 522,
		def: new Blbfile( new Buffer(0) )
	},
	D: {
		name: 'DATE',
		value: 3,
		def: date.make(0,0,0)
	},
	E: {
		name: 'DATETIME',
		value: 526,
		def: new datetime.Datetime()
	},
	I: {
		name: 'INTEGER',
		value: 4,
		def: 0 
	},
	J: {
		name: 'SHORTINT',
		value: 2,
		def:  0 
	},
	N: {
		name: 'DECIMAL',
		value: 7,
		def: bcd.fromDouble( 0 )
	},
	S: {
		name: 'CHAR',
		value: 10,
		def: ""
	},
	T: {
		name: 'CLBFILE',
		value: 523,
		def: ""
	},
/*	U: {
		name: 'SCHAR',
		value: 10,
		def: ""
	},*/
	V: {
		name: 'TINYINT',
		value: 1,
		def: 0
	},
	X: {
		name: 'ANY',
		value: -1,
		def: null
	},
	Y: {
		name: 'INSTANCE',
		value: 524,
		def: null
	},
	Z: {
		name: 'UUIDENT',
		value: 525,
		def: tuuid.make( )
	},
};

// storage classes
exports.dictClasses = {
	VARIABLE: 'A',
	VALUE: 'B',
	CONST: 'C',
	DEFAULT: 'D',
	GLOBAL: 'V',
	LOCAL: 'L',
	// + F (table), M (mask) and S (sequential) that don't have keywords
};

var raz = {};

var setACTX = function(_,frame) {
	var v = frame.context.superv.currentContext(_);
	frame.context.globals.values.GACTX = v;
	frame.context.globals.types.GACTX  = 'VY';
	return v;
}

var setInteger = function(type) {
	return function(field,key,val) {
		try {
			val = val.x3ToInteger();	
		} catch(e) {
			throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
		}
	
		if (!val.x3AssertOverflow(type)) throw new X3Error(13, "invalid value '" + val + "' assigned to '" + field + "'");
		return val;
	}	
}

exports.setters = {
	I:setInteger('I'),
	J:setInteger('J'),
	V:setInteger('V'),
	N:function(field,key,val) {
		try{
			return val.x3ToBCD() ;			
		} catch(e) {
			throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");	
		}
	},
	D:function(field,key,val) {
		try{
			return val.x3ToDate() ;			
		} catch(e) {
			throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");	
		}
	},
	B:function(field,key,val) {
		if (!util.x3IsBlbfile(val)) throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
		// nothing else
		return val;
	},
	S:function(field,key,val) {
		if(typeof val !== 'string') throw new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
		return (key.length > 2)?val.substring(0,parseInt(key.substring(2))):val;
	}

};


exports.instructions = {
	DIM: function(arr, dim) {
		return function dim$do(_) {
			var a = arr(_, false, undefined, true);
			if (a === undefined) return -1;
			var d = dim !== undefined ? dim(_) : 1;
			//console.log("DIM: " + JSON.stringify(a) + " dim=" + dim)
			// basic values are considered to be arrays of 1 elt.
			if (!Array.isArray(a)) return d === -1 ? 0 : 1;
			var ndims = a[0];
			if (d === 0) return ndims;
			if (!(d >= -ndims && d <= ndims)) throw new X3Error(50, d);						
			var sliced =  a.length === 3 + 4 * a[0]
			//console.log("DIM: " + JSON.stringify(a) + " ndims=" + ndims+" sliced="+sliced)
			if (sliced) {
				if (d > 0) return a[4 + 2 * (ndims + (d - 1))];
				else return a[3 + 2 * -(d + 1)];
			} else {
				//if (d>0) return a[4]===null?32767:a[4]-a[3]+1;
				//else return a[3]
				if (d>0) return a[4 + 2 * (d - 1) ]===null?32767:a[4 + 2 * (d - 1) ]-a[3 + 2 * (d - 1) ]+1;
				else return a[3 + 2 * -(d + 1) ]
			}
			
		}
	},
	CLALEV: function(arg) {
		return function clalev$do(_) {
			var a = arg(_, false, undefined, true);
			if (!a) return 0;
			if (typeof a === "number") {
				var abbr = Object.keys(context.tables)[a - 1]
				if (abbr) return abbr;
				else throw new X3Error(10, "clalev number out of range: " + a);
			} else {
				if (!a.values) throw new X3Error(10, "clalev argument is not a class");
				return 1;
			}
		}
	},
	V: function(field) {
		return function v$do(_, assign, val, silent) {
			
			var frame = glob.context.x3frame, v;
			// optimize read of local variable
			//if (!assign && (v = frame.values[field]) !== undefined) return v;
			var dicts = frame.dicts;

            if (assign && (val == null || val === undefined )) throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");

			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				var key, found;
				if (dict === frame.context.tables) {
					var keys = Object.keys(dict);
					for (var j = 0; !found && j < keys.length; j++) {
						var abb = keys[j];
						var values = dict[abb].values;
						v = dict[abb].values[key];
						found = (v !== undefined);
					}
				} else {
					key = field;
					v = dict.values[key];
					found = (v !== undefined);
				}
				//console.log("field="+field+" found="+found+" assign="+assign+" val="+val);
				if (found) {
					if (assign) {
						//console.log("Assign !!!! "+key+" "+dict.types[key]) ;
						val = val === raz ? exports.types[dict.types[key][1]].def : val;
						
						if (dict.types[key]===undefined) {
							throw new X3Error(62, frame.prog.name+": '" + field + "' not declared");						
						}
						else if (dict.types[key][0]==='C') {
							throw new X3Error(62, frame.prog.name+": '" + field + "' Variable not modifiable");						
						}
						else if (!Array.isArray(val) && exports.setters[dict.types[key][1]]) {
							val = exports.setters[dict.types[key][1]](field,dict.types[key],val);
						}
						dict.values[key]  = val;
						return;
					} else { 
						if (frame.prog && frame.prog.params){ // use only with a call of subprog			           
							if (Array.isArray(v) && Array.isArray(frame.prog.params)) {
				    			var ifield = frame.prog.params.indexOf(field);
							    if (ifield>=0 && frame.prog.pardef[ifield]===0) {
	
						    		//make a copy for Values and Const and not declared
								    var newtab = [] ;
								    for (var j = 0; j <v.length; j++) {
										// copy arrays of object passed
										if (Array.isArray( v[j])) {
									     var newtab2 = [] ;
									     for (var k = 0; k <v[j].length; k++) {
												newtab2[k] =  v[j][k];
									     }
									     newtab[j] = newtab2;
										}
										else {
										 newtab[j] =  v[j];
										} 
								    }
						    		if (newtab[4]!==null) newtab[4]=newtab[4]-newtab[3] ;
						    		newtab[3]=0;
								    dict.values[key]=newtab;
								    v=newtab;
						    	}
						    	frame.prog.pardef[ifield] = 1 ;
			                }
						}
						return v; 
					}
				}
			}
			// not found, create in local dict if assign
			if (assign) {
				frame.values[field] = val;
				frame.types[field] = "L"+ (typeof val == 'number'? 'I':'S');
			}
			else if (silent) return;
			else if(field == 'GACTX') {
				return setACTX(_,frame);
			}
			else throw new X3Error(6, "undefined variable: " + field);
		};
	},
	TYPEV: function(field) {
		var vv = exports.instructions.V(field);
		return function typev$do(_) {
			var frame = glob.context.x3frame;
			var dicts = frame.dicts;
			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				var key, t;
				if (dict === frame.context.tables) {
					var keys = Object.keys(dict);
					for (var j = 0; j < keys.length; j++) {
						var abb = keys[j];
						t = dict[abb].types[key];
						if (t) return t;
					}
				} else {
					key = field;
					t = dict.types[key];
					if (t) return t;
				}
			}
			// type(t) will analyze this structure
			return {
				value: vv(_),
			};
		};
	},
	CV: function(letter, abbrev, field, silent) {
		return function cv$do(_, assign, val, silent) {
			var frame = glob.context.x3frame;
			var dict;

			if (assign && val == null) {
				if (silent) return null;
				else throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");
			}

			switch (letter) {
			case 'L':
				dict = frame;
				break;
			case 'V':
				dict = frame.context.globals;
				break;
			case 'S':
				dict = frame.context.sys;
				break;
			case 'F':
			case '?':
				dict = frame.context.tables;
				if (abbrev) {
					dict = dict[abbrev];
					if (!dict) {
						if (assign) {
							val.abbrev = abbrev;
							return frame.context.tables[abbrev] = val;
						} else if (silent) return null;
						else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
					}
				} else {
					var found;
					var keys = Object.keys(dict)
					for (var i = 0; !found && i < keys.length; i++) {
						var abb = keys[i];
						var d = dict[abb];
						found = (d.values[field] !== undefined);
						if (found) dict = d;
					}
					if (!found) {
						if (silent) return null;
						else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
					}
				}
				break;
			default:
				throw new X3Error(26, 'unknown class letter: [' + letter + ']');

			}

			if (!dict) {
				if (false && frame.tryingSql) { // REVIEW!!!
					var err = new Error("trying sql (ignore)");
					err.tooComplexForSql = true;
					throw err;
				}
			}
			if (assign) {
				val = val === raz ? exports.types[dict.types[field][1]].def : val;

				if (!Array.isArray(val) && exports.setters[dict.types[field][1]]) {
					val = exports.setters[dict.types[field][1]](field,dict.types[field],val);
				}
				dict.values[field] = val;
			} else {
				if (field) {
					var v = dict.values[field];
					if (v === undefined) {
						if(field == 'GACTX') {
							return setACTX(_,frame);
						}
						throw new X3Error(26, "undefined variable: " + field);
					}
					return v;
				} else {
					return dict;
				}
			}
		};
	},
	TYPECV: function(letter, abbrev, field) {
		return function typecv$do(_) {
			var frame = glob.context.x3frame;
			var dict;
			var key = field,
				t;
			switch (letter) {
			case 'L':
				dict = frame;
				break;
			case 'V':
				dict = frame.context.globals;
				break;
			case 'S':
				dict = frame.context.sys;
				break;
			case 'F':
			case '?':
				dict = frame.context.data;
				if (abbrev) key = abbrev + "_" + field;
				else {
					for (var i = 0; i < dict.abbrevs.length; i++) {
						key = dict.abbrevs[i] + "_" + field;
						t = dict.types[key];
						if (t) return t;
					}
					throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']' + field);
				}
				break;
			default:
				throw new X3Error(7, 'unknown class: [' + letter + ']');

			}
			return dict && dict.types[key];
		};
	},
	DECL: function(key, field, using, lens0, ranges0) {
		var letter 	= key[0];
		var def 	= exports.types[key[1]].def;
		if(lens0 === undefined && ranges0 === undefined){
			if(letter === "L" )
				return function decl$do(_) {
					glob.context.x3frame.values[field] = def;
					glob.context.x3frame.types[field]  = key;
				}
			else if(letter === "V" )
				return function decl$do(_) {
					glob.context.x3frame.context.globals.values[field] = def;
					glob.context.x3frame.context.globals.types[field]  = key;
				}
		}
		
		return function decl$do(_) {
			var frame = glob.context.x3frame;
			var lens = lens0,
				ranges = ranges0;
			var letter = key[0];
			var dict = letter === 'V' ? frame.context.globals : frame;
			var values = dict.values;
		    var ifield;
			if (/^[LV]$/.test(letter)) delete values[field];
		    if (/^[AB]$/.test(letter)) if(frame.prog.params && (ifield=frame.prog.params.indexOf(field))>=0) frame.prog.pardef[ifield] = 1;


			var t = key[1];
			if (lens) {
				if(!/^[STB]$/.test(t)) {
					ranges = lens;
					lens = undefined;
				} else {
					key += lens(_)[0];
				}
			}
			var arr = values[field];	
			var rangesVals;
			if (ranges){
				rangesVals = ranges(_);
			} else if (arr && Array.isArray(arr)) {
				ranges     = [0, null];
				rangesVals = [ranges];
			}

			dict.types[field] = key;
			//console.log(" Declare field "+ field+" "+dict.types[field]) ;
			// ignore using (for now)
			if (ranges) {
				//make a copy for Values and Const
				if (/^[CB]$/.test(key[0]) && arr && Array.isArray(arr)) {
				    var newtab = [] ;
				    for (var j = 0; j <arr.length; j++) {
						// copy arrays of object passed
						if (Array.isArray( arr[j])) {
					     var newtab2 = [] ;
					     for (var k = 0; k <arr[j].length; k++) {
								newtab2[k] =  arr[j][k];
					     }
					     newtab[j] = newtab2;
						}
						else {
						 newtab[j] =  arr[j];
						} 
				    }
				    values[field]=newtab;
				    arr=newtab;
				}
				var ndims = rangesVals.length;
				if (arr === undefined) {
					arr = [ndims, def, []];
					for (var dim = 0; dim < ndims; dim++) {
						var range = rangesVals[dim];
						if (typeof range === 'number') range = [0, range-1]; // for Value Integer A(6) -> A(0..5)
						arr = arr.concat(range);
					}
					values[field] = arr;
				} else {
					if (!Array.isArray(arr)) throw new X3Error(26, "initial value for '" + field + "' is not an array!");
					values[field] = arr = arr.slice(0); // clone it
					if (ndims != arr[0]) throw new X3Error(26, "dimensions mismatch for '" + field + "': expected " + ndims + ", got " + arr[0]);
					// note: array was copied when parameter was assigned - so we can modify it
					var sliced = arr.length === 3 + 4 * ndims;
					for (var dim = 0; dim < ndims; dim++) {
						var range = rangesVals[dim];
						if (range) {
							if (typeof range === 'number') range = [0, range-1]; // for Value Integer A(6) -> A(0..5)
							var decal = range[0] - arr[3 + 2 * dim];  
							arr[3 + 2 * dim] = range[0];
							if (arr[4 + 2 * dim] !== null)
							{
								arr[4 + 2 * dim] = arr[4 + 2 * dim] + decal; 
							}
							//
							if (range[1]) {
								var count = sliced ? arr[4 + 2 * (ndims + dim)] : arr[4 + 2 * dim];
								if (count !== range[1]) throw new X3Error(26, "range mismatch for '" + field + "': expected " + count + ", got " + range[1]);
							}
						}
					}
				}
			} else if (values[field] === undefined) {
				values[field] = def;
			}
			
		};
	},
	CA: function(field, exps) {
		var decl = exports.instructions.DECL('LX', field, util.instructions.A([util.instructions.C(exps.length)]));
		var aexps = util.instructions.A(exps);
		return function ca$do(_) {
			var frame = glob.context.x3frame;
			decl(_);
			var val = frame.values[field];
			var vals = aexps(_);
			val[2] = vals;
		};
	},
	GET: function(obj, prop) {
		return function get$do(_) {
			//console.error("GET " + prop);
			//console.error(obj);
			return obj[prop];
		};
	},
	SET: function(lhs, rhs, silent) {
		return function set$do(_) {
			lhs(_, true, rhs.value !== undefined ? rhs.value : rhs(_), silent);
		};
	},
	ASSIGN: function(lhs, rhs, silent) {
		return function assign$do(_) {
			var target = lhs(_);
			var value = rhs.value !== undefined ? rhs.value : rhs(_);
			var args;
			var beg = target.indexOf('(');
			if(beg > 0) {
				args = target.substring(beg+1,target.lastIndexOf(')')).split(',').reduce(function(result, arg) {
					result.push(util.instructions.C(parseInt(arg)));
					return result;
				}, []);
				target = target.substring(0,beg);
			}
			var fV = exports.instructions.V(target);
			if(args) {
				var fINDEX = require('./arrays').instructions.INDEX(fV,args);
				fINDEX(_,true, value);
			} else {
				fV(_, true, value, silent);
			}
		};
	},
	RAZ: function(exps) {
		return function raz$do(_) {
			exps.forEach_(_, function(_, exp) {
				exp(_, true, raz);
			});
		};

	},
	PROP: function(target, name) {
		return function dot$do(_, assign, val, silent) {
			var t = target(_);
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid property target: " + t);
			try {
				if (assign) {
					if (typeof t.set === "function") return t.set(_, name, val);
					else return t[name] = val;
				} else {
					if (typeof t.get === "function") return t.get(_, name, val);
					else {
						var v = t[name];
						if (v === undefined) throw new X3Error(26, "missing property in built-in object: " + name);
						return v;
					}
				}
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}
		};
	},
	XMET: function(target, name, args) { // fmet and callmet
		var aargs = util.instructions.A(args);
		return function dot$do(_) {
			var t = target(_);
			// todo: review error numbers
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid method target: " + t);
			var vals = aargs(_);
			var meth;
			if (t.class) {
				meth = t.class.method(name);
				if (typeof meth !== "function") throw new X3Error(26, "method not found: " + name + " in class " + t.class.name);
			} else {
				meth = t[name];
				if (typeof meth !== "function") throw new X3Error(26, "missing method in built-in object: " + name);
			}
			try {
				return meth.apply_(_, t, vals, 0);
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}
		};
	},
	FILEVAL: function(abbrev, vars, from) {
		var avars = util.instructions.A(vars);
		return function dot$do(_) {
			throw new X3Error(26, "NIY: FILEVAL");
		};
	},
	NEW: function(clas) {
		return function new$do(_) {
			var frame = glob.context.x3frame;
			var name = clas(_);
			if (!/^C_/.test(name)) throw new X3Error(33, "NIY: new on " + name);
			var cl = frame.context.superv.load(_, 'Class', name.substring(2));
			if (!cl) throw new X3Error(26, "invalid class name: " + name); // TODO check errnum
			return cl.createInstance(_);
		};
	},
	FREE: function(allocGroup, isGroup) {
		return function free$do(_) {};
	},
};