"use strict";

var util = require('./util');
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');

exports.initStack = function(superv) {
	var cx = {
		globals: {
			values: {
				$exported: true,
				CST_AOK: 0,
				CST_ANO: 1,
				CST_AYES: 2,
				CST_AINFO: 2,
				CST_AWARNING: 3,
				CST_AERROR: 4,
				CST_AFATAL: 5,
				CST_AFALSE: 0,
				CST_ATRUE: 1,
				CST_ASUCCESS: 1,

				// fix later
				AVOID: {
					$exported: true,
					ADATE: require("etna-engine/lib/runtime/dates").ORIGIN,
				},
				GUSER: "bruno",
				GLOGIN: "brjou",
				// for adxium
				GUTF8: 1,
				GVIRTDIR: "localhost:8124",
			},
			types: {}
		},
		sys: {
			values: {},
			types: {}
		},
		tables: {},
		superv: superv,
		loginName: process.env.USER || "<unknown>",
		// for now
		// seq file stuff
		files: {}
	};

	function sysVar(name, type, value) {
		cx.sys.values[name] = value;
		cx.sys.types[name] = type;
	}
	sysVar('ADXIFS', 'S', ',');
	sysVar('ADXIRS', 'S', '\n');
	sysVar('ADXIUM', 'I', 0);
	sysVar('ADXSCA', 'S', '?? .#*???');
	sysVar('FSTAT', 'I', 0);
	sysVar('ADXUPREC', 'I', 0);
	sysVar('ADXDLREC', 'I', 0);
	sysVar('INDICE', 'I', 0);

	var frame = {
		values: {},
		types: {},
		context: cx,
		loc: {},
		loopLevel: 0,
	};
	frame.sub = frame;
	// TODO: investigate how data (F class) is managed - global for now
	frame.dicts = [frame, cx.globals, cx.sys, cx.tables];
	frame.tablePos = 2;
	glob.context.x3frame = frame;
};

exports.functions = {
	TYPE: {
		count: 1,
		fn: function(t) {
			if (typeof t !== "string") {
				// guess type from value
				var v = t.value;
				switch (typeof v) {
				case 'string':
					return 10 + 512;
				case 'number':
					return ((v | 0) === v) ? 4 : 7;
				case 'object':
					if (date.isDate(v)) return 3;
					if (datetime.isDatetime(v)) return 526;
					if (Buffer.isBuffer(v)) return 522;
					if (v && (v.$exported || v.instanceFactory)) return 524;
					return -1;
				default:
					return -1;
				}
			}
			var type = exports.types[t[1]];
			if (!type) throw new X3Error(26, "bad type: " + t);
			return type.value === 10 && t.length > 2 ? 10 + parseInt(t.substring(2), 10) : type.value;
		}
	},
	VARMODE: {
		count: 0
	},
};

exports.types = {
	B: {
		name: 'BLBFILE',
		value: 522,
		def: new Buffer(0)
	},
	D: {
		name: 'DATE',
		value: 3,
		def: date.make(0, 0, 0)
	},
	E: {
		name: 'DATETIME',
		value: 526,
		def: datetime.make(0, 0, 0, 0, 0, 0)
	},
	I: {
		name: 'INTEGER',
		value: 4,
		def: 0
	},
	J: {
		name: 'SHORTINT',
		value: 2,
		def: 0
	},
	N: {
		name: 'DECIMAL',
		value: 7,
		def: 0
	},
	S: {
		name: 'CHAR',
		value: 10,
		def: ""
	},
	T: {
		name: 'CLBFILE',
		value: 523,
		def: ""
	},
	U: {
		name: 'SCHAR',
		value: 10,
		// ? not listed in doc
		def: ""
	},
	V: {
		name: 'LIBELLE',
		value: 1,
		def: ""
	},
	X: {
		name: 'ANY',
		value: -1,
		def: null
	},
	Y: {
		name: 'INSTANCE',
		value: 524,
		def: null
	},
	Z: {
		name: 'UUID',
		value: 525,
		def: null
	},
};

// storage classes
exports.dictClasses = {
	VARIABLE: 'A',
	VALUE: 'B',
	CONST: 'C',
	DEFAULT: 'D',
	GLOBAL: 'V',
	LOCAL: 'L',
	// + F (table), M (mask) and S (sequential) that don't have keywords
};

var raz = {};

exports.instructions = {
	DIM: function(arr, dim) {
		return function dim$do(_) {
			var a = arr(_, false, undefined, true);
			if (a === undefined) return -1;
			var d = dim !== undefined ? dim(_) : 1;
			//console.error("DIM: " + JSON.stringify(a) + " dim=" + dim)
			// basic values are considered to be arrays of 1 elt.
			if (!Array.isArray(a)) return d === -1 ? 0 : 1;
			var ndims = a[0];
			if (d === 0) return ndims;
			if (!(d >= -ndims && d <= ndims)) throw util.badArgumentType(d);
			var sliced = a.length === 3 + 4 * ndims;
			if (sliced) {
				if (d > 0) return a[4 + 2 * (ndims + (d - 1))];
				else return a[3 + 2 * -(d + 1)];
			} else {
				if (d > 0) return a[4 + 2 * (d - 1)];
				else return a[3 + 2 * -(d + 1)];
			}
		}
	},
	CLALEV: function(arg) {
		return function clalev$do(_) {
			var a = arg(_, false, undefined, true);
			if (!a) return 0;
			if (typeof a === "number") {
				var abbr = Object.keys(context.tables)[a - 1]
				if (abbr) return abbr;
				else throw new X3Error(10, "clalev number out of range: " + a);
			} else {
				if (!a.values) throw new X3Error(10, "clalev argument is not a class");
				return 1;
			}
		}
	},
	V: function(field) {
		return function v$do(_, assign, val, silent) {
			var frame = glob.context.x3frame;
			var dicts = frame.dicts;

			if (assign && val == null) throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");

			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				var key, v, found;
				if (dict === frame.context.tables) {
					var keys = Object.keys(dict);
					for (var j = 0; !found && j < keys.length; j++) {
						var abb = keys[j];
						var values = dict[abb].values;
						v = dict[abb].values[key];
						found = (v !== undefined);
					}
				} else {
					key = field;
					v = dict.values[key];
					found = (v !== undefined);
				}
				if (found) {
					if (assign) {
						val = val === raz ? exports.types[dict.types[key][1]].def : val;
						if (val === undefined) throw new X3Error(26, "undefined assigned to '" + field + "'");
						dict.values[key] = val;
						return;
					} else return v;
				}
			}
			// not found, create in local dict if assign
			if (assign) frame.values[field] = val;
			else if (silent) return;
			else throw new X3Error(26, "undefined variable: " + field);
		};
	},
	TYPEV: function(field) {
		var vv = exports.instructions.V(field);
		return function typev$do(_) {
			var frame = glob.context.x3frame;
			var dicts = frame.dicts;
			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				var key, t;
				if (dict === frame.context.tables) {
					var keys = Object.keys(dicts);
					for (var j = 0; !found && j < keys.length; j++) {
						var abb = keys[i];
						t = dict[abb].types[key];
						if (t) return t;
					}
				} else {
					key = field;
					t = dict.types[key];
					if (t) return t;
				}
			}
			// type(t) will analyze this structure
			return {
				value: vv(_),
			};
		};
	},
	CV: function(letter, abbrev, field, silent) {
		return function cv$do(_, assign, val, silent) {
			var frame = glob.context.x3frame;
			var dict;

			if (assign && val == null) {
				if (silent) return null;
				else throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");
			}

			switch (letter) {
			case 'L':
				dict = frame;
				break;
			case 'V':
				dict = frame.context.globals;
				break;
			case 'S':
				dict = frame.context.sys;
				break;
			case 'F':
			case '?':
				dict = frame.context.tables;
				if (abbrev) {
					dict = dict[abbrev];
					if (!dict) {
						if (assign) {
							val.abbrev = abbrev;
							return frame.context.tables[abbrev] = val;
						} else if (silent) return null;
						else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
					}
				} else {
					var found;
					var keys = Object.keys(dict)
					for (var i = 0; !found && i < keys.length; i++) {
						var abb = keys[i];
						var d = dict[abb];
						found = (d.values[field] !== undefined);
						if (found) dict = d;
					}
					if (!found) {
						if (silent) return null;
						else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
					}
				}
				break;
			default:
				throw new X3Error(26, 'unknown class letter: [' + letter + ']');

			}

			if (!dict) {
				if (false && frame.tryingSql) { // REVIEW!!!
					var err = new Error("trying sql (ignore)");
					err.tooComplexForSql = true;
					throw err;
				}
			}
			if (assign) {
				val = val === raz ? exports.types[dict.types[field][1]].def : val;
				dict.values[field] = val;
			} else {
				if (field) {
					var v = dict.values[field];
					if (v === undefined) throw new X3Error(26, "undefined variable: " + field);
					return v;
				} else {
					return dict;
				}
			}
		};
	},
	TYPECV: function(letter, abbrev, field) {
		return function typecv$do(_) {
			var frame = glob.context.x3frame;
			var dict;
			var key = field,
				t;
			switch (letter) {
			case 'L':
				dict = frame;
				break;
			case 'V':
				dict = frame.context.globals;
				break;
			case 'S':
				dict = frame.context.sys;
				break;
			case 'F':
			case '?':
				dict = frame.context.data;
				if (abbrev) key = abbrev + "_" + field;
				else {
					for (var i = 0; !found && i < dict.abbrevs.length; i++) {
						key = dict.abbrevs[i] + "_" + field;
						t = dict.types[key];
						if (t) return t;
					}
					throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']' + field);
				}
				break;
			default:
				throw new X3Error(7, 'unknown class: [' + letter + ']');

			}
			return dict && dict.types[key];
		};
	},
	DECL: function(key, field, using, lens0, ranges0) {
		return function decl$do(_) {
			var frame = glob.context.x3frame;
			var lens = lens0,
				ranges = ranges0;
			var letter = key[0];
			var dict = letter === 'V' ? frame.context.globals : frame;
			var values = dict.values;
			if (letter === 'L' || letter === 'V') delete values[field];

			var t = key[1];
			if (t !== 'S' && t !== 'T' && lens) {
				ranges = lens;
				lens = undefined;
			}
			if (lens) {
				key += lens(_)[0];
			}
			dict.types[field] = key;
			// ignore using (for now)
			if (ranges) {
				var rangesVals = ranges(_);
				var ndims = rangesVals.length;
				var arr = values[field];
				if (arr === undefined) {
					var def = exports.types[t].def;
					arr = [ndims, def, []];
					for (var dim = 0; dim < ndims; dim++) {
						var range = rangesVals[dim];
						if (typeof range === 'number') range = [0, range];
						arr = arr.concat(range);
					}
					values[field] = arr;
				} else {
					if (!Array.isArray(arr)) throw new X3Error(26, "initial value for '" + field + "' is not an array!");
					values[field] = arr = arr.slice(0); // clone it
					if (ndims != arr[0]) throw new X3Error(26, "dimensions mismatch for '" + field + "': expected " + ndims + ", got " + arr[0]);
					// note: array was copied when parameter was assigned - so we can modify it
					var sliced = arr.length === 3 + 4 * ndims;
					for (var dim = 0; dim < ndims; dim++) {
						var range = rangesVals[dim];
						//console.error("RANGE=" + range)
						if (range) {
							if (typeof range === 'number') range = [0, range];
							arr[3 + 2 * dim] = range[0];
							if (range[1]) {
								var count = sliced ? arr[4 + 2 * (ndims + dim)] : arr[4 + 2 * dim];
								if (count !== range[1]) throw new X3Error(26, "range mismatch for '" + field + "': expected " + count + ", got " + range[1]);
							}
						}
					}
				}
			} else {
				if (values[field] === undefined) {
					var def = exports.types[t].def;
					values[field] = def;
				}
			}
		};
	},
	CA: function(field, exps) {
		var decl = exports.instructions.DECL('LX', field, util.instructions.A([util.instructions.C(exps.length)]));
		var aexps = util.instructions.A(exps);
		return function ca$do(_) {
			var frame = glob.context.x3frame;
			decl(_);
			var val = frame.values[field];
			var vals = aexps(_);
			val[2] = vals;
		};
	},
	GET: function(obj, prop) {
		return function get$do(_) {
			//console.error("GET " + prop);
			//console.error(obj);
			return obj[prop];
		};
	},
	SET: function(lhs, rhs, silent) {
		return function set$do(_) {
			lhs(_, true, rhs.value !== undefined ? rhs.value : rhs(_), silent);
		};
	},
	RAZ: function(exps) {
		return function raz$do(_) {
			exps.forEach_(_, function(_, exp) {
				exp(_, true, raz);
			});
		};

	},
	PROP: function(target, name) {
		return function dot$do(_, assign, val, silent) {
			var t = target(_);
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid property target: " + t);
			try {
				if (assign) {
					if (typeof t.set === "function") return t.set(_, name, val);
					else return t[name] = val;
				} else {
					if (typeof t.get === "function") return t.get(_, name, val);
					else {
						var v = t[name];
						if (v === undefined) throw new X3Error(26, "missing property in built-in object: " + name);
						return v;
					}
				}
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}
		};
	},
	XMET: function(target, name, args) { // fmet and callmet
		var aargs = util.instructions.A(args);
		return function dot$do(_) {
			var t = target(_);
			// todo: review error numbers
			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid method target: " + t);
			var vals = aargs(_);
			var meth;
			if (t.class) {
				meth = t.class.method(name);
				if (typeof meth !== "function") throw new X3Error(26, "method not found: " + name + " in class " + t.class.name);
			} else {
				meth = t[name];
				if (typeof meth !== "function") throw new X3Error(26, "missing method in built-in object: " + name);
			}
			try {
				return meth.apply_(_, t, vals, 0);
			} catch (ex) {
				throw new X3Error(26, ex.message, ex.stack);
			}
		};
	},
	FILEVAL: function(abbrev, vars, from) {
		var avars = util.instructions.A(vars);
		return function dot$do(_) {
			throw new X3Error(26, "NIY: FILEVAL");
		};
	},
	NEW: function(clas) {
		return function new$do(_) {
			var frame = glob.context.x3frame;
			var name = clas(_);
			if (!/^C_/.test(name)) throw new X3Error(33, "NIY: new on " + name);
			var cl = frame.context.superv.load(_, 'Class', name.substring(2));
			if (!cl) throw new X3Error(26, "invalid class name: " + name); // TODO check errnum
			return cl.instanceFactory.createInstance(_);
		};
	},
	FREE: function(allocGroup, isGroup) {
		return function free$do(_) {};
	},
};