"use strict";
var config = require("etna-util/lib/nodeconfig").config;
var glob = require('streamline/lib/globals');
var trace = config.etna.traceError ? console.log : null;


var errmes$ = exports.errmes$ = function(errn) {
	try {
		return glob.context.x3frame.context.messages[errn] ;
	} catch(e) {
		// necessary for unit tests
		return errn;
	}
};

exports.moduleName = function(loc) {
	if (!loc.file) return "unknown";
	var file = loc.file;
	var s = file.substring(Math.max(file.lastIndexOf('/'), file.lastIndexOf('\\')) + 1);
	//console.log("moduleName: " + s);
	var dot = s.lastIndexOf('.');
	return /*"x3://host:port/folder/" +*/ dot >= 0 ? s.substring(0, dot) : s;
};

function X3Frame(file, line, name) {
	this.file = file, this.line = line, this.name = name;
}
X3Frame.prototype.toString = function() {
	return "  at " + (this.name || '<script>') + " (" + this.file + (this.line ? ":" + this.line : "") + ")";
};

function X3Error(errn, message, jsStack) {
	//Error.captureStackTrace(this, X3Error);
	function cut(s) {
		return s.substring(s.indexOf('\n') + 1);
	}
	if (arguments.length === 1) {
		// errn is an Error object
		this.message = errn.message;
		this.errn = errn.errn ;
		jsStack = errn.jsStack;		
	} else {
		this.message = "[" + errn + "] " + errmes$(errn) + (message?" ["+message+"]":"");
		this.errn = errn;
	}
	if (arguments.length > 3) {
		this.frames = [new X3Frame(arguments[2], arguments[3], arguments[4])];
		this.jsStack = cut(new Error('').stack);
	} else {
		this.frames = [];
		this.jsStack = jsStack || cut(new Error().stack);
	}
	if (trace) {
		trace("\nX3Error(" + errn + "):" + message);
		var root;
		var keep=0;
		this.jsStack.split(")\n").some(function(line) {
			if (!root) {
				var node_modules = "node_modules";
				root = line.substring(line.indexOf("(") + 1, line.indexOf(node_modules) + node_modules.length);
			}
			trace(line.replace(root, "."));
			return !(keep++ < 2);
		});
	}
}

X3Error.prototype.fill = function(frame) {
	for (; frame; frame = frame.prev) {
		if (frame.fcall) this.frames.push(new X3Frame("<built-in functions>", 0, frame.fcall));
		for (var sub = frame.sub; sub; sub = sub.prevSub) {
			this.frames.push(new X3Frame(sub.loc.file, sub.loc.line, sub.name || frame.prog.name ));
		}
	}
	this.fill = null; // fill only once	
};
X3Error.prototype.toString = function() {
	return this.message;
};
Object.defineProperty(X3Error.prototype, 'stack', {
	get: function() {
		//console.log(this);
		return this.message + //
			"\n  <<< X3 stack >>>\n" + this.frames.join("\n") + //
			"\n  <<< JS stack >>>\n" + this.jsStack;
	}
});

exports.X3Error = X3Error;