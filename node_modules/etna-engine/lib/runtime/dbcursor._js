"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");
var X3Error = require('./errors').X3Error;


function _extended(abv) {
	return abv !== "extended";
}

function _save(tables, columns) {
	var rec = {};
	if (columns) {
		Object.keys(columns).filter(_extended).forEach(
			function(abv) {
				if (columns[abv] !== null) {
					var cdef = columns[abv];
					var cpy = {};
					for (var i = 0; i < cdef.length; i++) {
						var nm = cdef[i].field.data.CODZONE;
						cpy[nm] = tables[abv].values[nm];
					}
					rec[abv] = cpy;
				} else
					rec[abv] = tables[abv].values;
			});
	} else {
		Object.keys(tables).forEach(function(abv) {
			rec[abv] = tables[abv].values;
		});
	}
	return rec;
}

function _dispatch(tables, row, columns) {
	if (columns) {
		Object.keys(columns).filter(_extended).forEach(function(abv) {
			var cdef = columns[abv];
			if (cdef === null) tables[abv].values = row[abv];
			else {
				// assign just values from columns
				for (var i = 0; i < cdef.length; i++) {
					var nm = cdef[i].field.data.CODZONE;
					tables[abv].values[nm] = row[abv][nm];
				}
			}
		});
	} else {
		Object.keys(row).forEach(function(abv) {
			tables[abv].values = row[abv];
		});
	}
}

var DBCursor = helpers.defineClass(function(reader, tables, maptrim, pwhere, key, lvl, typ, columns) {
	var self = this;

	self.reader = reader;
	self.tables = tables;
	self.maptrim = maptrim;
	self.pwhere = pwhere;
	self.key = key;
	self.klvl = lvl;
	self.level = 0;
	self.currkeyValues = [];
	self.pocket = undefined;
	self.lastRecord = undefined;
	self.finished = false;
	self.typecursor = typ;
	self.columns = columns;
	return self;
}, null, {

	x3GetRecord: function(_, sv) {
		var self = this;

		var maptrim = self.maptrim;
		var pwhere = self.pwhere;
		var tables = self.tables;
		var vsave;
		var wok = 1;

		// I have  anything in my pocket ?
		if (self.pocket) {
			_dispatch(tables, self.pocket);
			var r = self.pocket;
			self.pocket = undefined;
			return r;
		}

		// save last record
		vsave = _save(tables, self.columns);

		// let's go dancing with records
		tracer.debug && tracer.debug("Cursor Read....");
		var rec = self.reader.read(_);
		tracer.debug && tracer.debug("Cursor read ok");
		while (rec) {
			var row = maptrim(_, rec);
			_dispatch(tables, row, self.columns);

			tracer.debug && tracer.debug(row);

			// post evaluations have to be ok
			wok = 1;
			for (var i = 0; i < pwhere.length; i++) {
				var w = pwhere[i](_);
				var r = w.reduce(function(r, c) {
					return r && c;
				}, 1);
				wok = wok && r;
			}
			if (!wok) {
				rec = self.reader.read(_, 1);
			} else {
				break;
			}
		}

		if ((!wok) && (!rec)) _dispatch(tables, vsave, self.columns);
		if (sv) self.lastRecord = vsave;
		if (rec === undefined) self.finished = true;
		return rec;
	},

	x3DiscardCurrent: function() {
		var self = this;

		if (self.lastRecord === undefined) throw new X3Error(26, "x3DiscardCurrent without save");

		self.pocket = _save(self.tables);
		_dispatch(self.tables, self.lastRecord);
		self.lastRecord = undefined;
	},

	x3CloseDBReader: function(_) {
		var self = this;
		tracer.debug && tracer.debug("Reader stop....");
		self.reader.stop(_);
	},

	x3HasNoMoreRecord: function() {
		var self = this;

		return self.finished;
	},

	x3FreeLast: function() {
		var self = this;

		self.lastRecord = undefined;
	},
});

exports.DBCursor = DBCursor;