"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");
var X3Error = require('./errors').X3Error;

function _save(tables) {
	var rec = {};
	Object.keys(tables).forEach(function(abv) {
		rec[abv] = tables[abv].values;
	});
	return rec;
}

function _dispatch(tables, row) {
	Object.keys(row).forEach(function(abv) {
		tables[abv].values = row[abv];
	});
}

var DBCursor = helpers.defineClass(function(reader, dbreader, tables, maptrim, pwhere, key, lvl) {
	var self = this;

	self.reader = reader;
	self.dbreader = dbreader;
	self.tables = tables;
	self.maptrim = maptrim;
	self.pwhere = pwhere;
	self.key = key;
	self.klvl = lvl;
	self.level = 0;
	self.currkeyValues = [];
	self.pocket = undefined;
	self.lastRecord = undefined;
	self.finished = false;
	return self;
}, null, {

	x3GetRecord: function(_, sv) {
		var self = this;

		var maptrim = self.maptrim;
		var pwhere = self.pwhere;
		var tables = self.tables;
		var vsave;
		var wok = 1;

		// I have  anything in my pocket ?
		if (self.pocket) {
			_dispatch(tables, self.pocket);
			var r = self.pocket;
			self.pocket = undefined;
			return r;
		}

		// save last record
		vsave = _save(tables);

		/*
		var rec ;
		var r = self.reader.some(_, function(_, rec ) {
		
			var row = maptrim(rec);
			_dispatch(tables, row);

			tracer.debug && tracer.debug(row);

			// post evaluations have to be ok
			wok = 1;
			for (var i = 0; i < pwhere.length; i++) {
				var w = pwhere[i](_);
				var r = w.reduce(function(r, c) {
					return r & c;
				}, 1);
				wok = wok & r;
			}
			if (!wok) {
				return false ;
			} else {
				return true ;
			}
		}) ;
*/
		// let's go dancing with records
		var rec = self.reader.read(~_, 1);
		while (rec) {
			var row = maptrim(rec);
			_dispatch(tables, row);

			tracer.debug && tracer.debug(row);

			// post evaluations have to be ok
			wok = 1;
			for (var i = 0; i < pwhere.length; i++) {
				var w = pwhere[i](_);
				var r = w.reduce(function(r, c) {
					return r & c;
				}, 1);
				wok = wok & r;
			}
			if (!wok) {
				rec = self.reader.read(~_, 1);
			} else {
				//self.reader.stop( ) ;
				break;
			}
		}

		if ((!wok) && (!rec)) _dispatch(tables, vsave);
		if (sv) self.lastRecord = vsave;
		if (rec === undefined) self.finished = true;
		return rec;
	},

	x3DiscardCurrent: function() {
		var self = this;

		if (self.lastRecord === undefined) throw new X3Error(26, "x3DiscardCurrent without save");

		self.pocket = _save(self.tables);
		_dispatch(self.tables, self.lastRecord);
		self.lastRecord = undefined;
	},

	x3CloseDBReader: function() {
		var self = this;
		//self.reader.stop( ) ;
		self.dbreader.discard();
	},

	x3HasNoMoreRecord: function() {
		var self = this;

		return self.finished;
	},

	x3FreeLast: function() {
		var self = this;

		self.lastRecord = undefined;
	},
});

exports.DBCursor = DBCursor;