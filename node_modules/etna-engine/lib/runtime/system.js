"use strict";
var errors = require('./errors');
var util = require('./util');
var glob = require('streamline/lib/globals');

exports.functions = {
	FILELEV: {
		count: 1
	},
	NBRECORD: {
		count: 1
	},
	ROWCOUNT: {
		count: 1
	},
	UNIQID: {
		count: 1
	},
	ADXSEEK: {
		count: 1
	},
	INPMODE: {
		count: 1
	},
	VARINIT: {
		count: 1
	},
	MASKLEV: {
		count: 1
	},
	MASKNBF: {
		count: 1
	},
	MASKRK: {
		count: 1
	},
	MASKSIZ: {
		count: 1
	},
	ADXPID: {
		count: 0
	},
	ADXTCP: {
		count: 0
	},
	ADXUID: {
		count: 0
	},
	FREEMEM: {
		count: 0
	},
	NBRUSER: {
		count: 0
	},
	MASKABR: {
		count: 1
	},
	MASKCOU: {
		count: 0
	},
	MASKNAM: {
		count: 1
	},
	ADXMAC: {
		count: 0
	},
	ADXPAM: {
		count: 0
	},
	ADXUSR: {
		count: 0,
		fn: function() {
			var frame = glob.context.x3frame;
			return frame.context.loginName;
		}
	},
	ADXPNO: {
		count: 1,
		fn: function(level) {
			var frame = glob.context.x3frame;
			while (frame && level-- > 0) frame = frame.prev;
			if (!frame) return "";
			var modname = errors.moduleName(frame.sub.loc);
			// for now hard code folder, subfolder and extension
			// TODO: improve this
			return "@SUPERV.TRT/" + modname + "$adx";
		}
	},
	DBGCALLSTACK: {
		count: 2,
		fn: function(depth, result) {
			// TODO: handle it differently because we cannot return a value through result.
			return 0;
		}

	},
	COP$: {
		count: 0,
		fn: function() {
			return "ADONIX Copyright ADONIX Paris 1996";
		}
	},
	GETENV$: {
		count: 1,
		fn: function(s) {
			util.checkString(s);
			return process.env[s] || "";
		}
	},
	TRTCOU: {
		count: 0,
		fn: function() {
			var frame = glob.context.x3frame;
			return "@"+frame.context.superv.folderName+".TRT/"+ errors.moduleName(frame.sub.loc) + "$adx";
		}
	},
	VER$: {
		count: 1,
		fn: function() {
			return "etna 7.0.2";
		}
	},
	NOMAP: {
		count: 0,
		fn: function() {
			return "ETNA_APP"
		}
	},
	ADXCIO: {
		count: 0
	},
	ADXIOA: {
		count: 0
	},
	ADXNFS: {
		count: 0
	},
	MASKCLA: {
		count: 0
	},
	PROGCAN: {
		count: 0
	},
	PROGLDD: {
		count: 0
	},
	PROGSIZ: {
		count: 0
	},
	PROGUSD: {
		count: 0
	}
};

function sysFor(_, where, p, end, block) {
	console.error("System FOR loop - skipping for now");
	p[end](_);
}

exports.instructions = {
	FILESYS: function(abbrev, vars, from) {
		var avars = util.instructions.A(vars);
		return function dot$do(_) {
			var table = abbrev(_, true, {
				types: {},
				values: {},
				doFor: sysFor,
			});
		};
	},
}