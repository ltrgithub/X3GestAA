"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var array = require('./arrays');
var dates = require('./dates');
var evaluate = require('./dbevaluate');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');
var DBCursor = require('./dbcursor').DBCursor;
var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");
var activ;

var sqlCmpOps = {
	EQ: {
		op: '=',
		combine: 'and',
	},
	NE: {
		op: '<>',
		combine: 'or'
	},
	LT: {
		op: '<',
		combine: 'lexi'
	},
	LE: {
		op: '<=',
		combine: 'lexi'
	},
	GT: {
		op: '>',
		combine: 'lexi'
	},
	GE: {
		op: '>=',
		combine: 'lexi'
	},
};

function identity(x) {
	return x;
}


// build Read and for Query
// -----------------------------------------------------------------------
function _buildQuery(_, clause, self, key, wkey, fwhere, lock) {
	var utilDriver = require("etna-supervisor/lib/drivers/util");

	// buikld query
	var master = (self.master || self);
	var tablesSql = master.desc.name + " " + master.abbrev;
	var tables = {};
	var abbrevs = [master.abbrev];
	var constants = [];
	var ctx = {};

	// table from --------------------------
	tables[master.abbrev] = master;
	(self.joins || []).forEach(function(join) {
		abbrevs.push(join.table.abbrev);
		tables[join.table.abbrev] = join.table;
		constants = constants.concat(join.constants || []);
		tablesSql += " " + join.sql;
	});
	ctx.tables = abbrevs;

	// select ---------------------------------
	var typesmap = [0];
	var columnsSql = (self.columns ? self.columns.map(function(column) {
		column.sqlTypesMap(typesmap);;
		return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
	}) : abbrevs.reduce(function(result, abbrev) {
		var tab = tables[abbrev];
		Object.keys(tab.desc.columns).forEach(function(name) {
			var col = tab.desc.columns[name];
			col.sqlTypesMap(typesmap);
			result.push(col.sqlNames(abbrev + ".", abbrev));
		});
		return result;
	}, [])).join(', ');


	// where -----------------------------------
	var whereSqls = [],
		pwhere = [],
		wheres = [];
	if (wkey && wkey.rowid) {
		constants = constants.concat(wkey.constants || []);
		whereSqls.push(wkey.sql);
	} else {

		wheres = [self.where, self.filter.where, wkey];
		if (self.master) {
			wheres.push(master.where);
			wheres.push(master.filter.where);
		}
		wheres.push(fwhere && fwhere(_, ctx));

		wheres.filter(identity).forEach(function(w) {
			w.sql && whereSqls.push(w.sql);
			w.func && pwhere.push(w.func);
			if (!w.tooComplex) constants = constants.concat(w.constants || []);
		});
	}

	// complete query --------------------------------
	var currtag = 0;
	var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';
	var middleSql = (tablesSql + whereSql).replace(/@\?/g, function(val) {
		return self.driver.param(currtag++);
	});
	var orderBySql = "";
	if (((!wkey) || (!wkey.rowid)) && key.sql)
		orderBySql = " ORDER BY " + key.sql;

	var sql = "Select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, " + columnsSql + " From " + middleSql + orderBySql;
	if (lock) sql += self.driver.lockClause(clause === "read");
	var maptrim = utilDriver.maptrim(self.driver, typesmap, true);

	return {
		sql: sql,
		maptrim: maptrim,
		tables: tables,
		pwhere: pwhere,
		constants: constants,
	};
}
// -----------------------------------------------------------------------

// object DBTable classe
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------

var DBTable = helpers.defineClass(function(driver, abbrev, superv, desc, keys, loc) {
	var self = this;
	if (driver instanceof DBTable) {
		var tbl = driver;

		self.local = tbl.local;
		self.master = tbl;
		self.superv = tbl.superv;
		self.currkey = 0;
		self.driver = tbl.driver;
		self.reader = undefined;
		self.desc = tbl.desc;
		self.abbrev = abbrev;
		self.keys = tbl.keys;
		self.types = tbl.types;
		self.values = tbl.values;

	} else {
		self.local = loc;
		self.superv = superv;
		self.currkey = 0;
		self.driver = driver;
		self.reader = undefined;
		self.desc = desc;
		self.types = {};
		self.values = {};
		self.abbrev = abbrev;
		self.keys = keys;

	}
	return self;
}, null, {
	init: function(_) {
		var self = this;
		var table = this;
		var columns = this.desc.columns;

		Object.keys(columns).forEach_(_, function(_, colName) {
			if (columns[colName].data.DIME <= 1) {
				var etnaType = columns[colName].type.etnaType;
				table.values[colName] = variables.types[etnaType].def;
			} else if (columns[colName].data.CODACT) {
				activ = activ || require("etna-supervisor/lib/meta/activ");
				var dime = activ.getActiv(_, self.superv, columns[colName].data.CODACT);
				if (dime) columns[colName].data.DIME = dime;
				table.values[colName] = [];
			} else {
				table.values[colName] = [];
			}
			table.types[colName] = ' ' + etnaType;
		});
		return this;
	},

	// operation on table --------------------------------------
	// ---------------------------------------------------------
	x3Read: function(_, key, lvl, wkey, lock, hint, tcnx) {
		var self = this;
		if (lock && (!tcnx)) throw new X3Error(26, "Lock whitout transaction");

		var qry = _buildQuery(_, 'read', self, key, wkey, undefined, lock);

		tracer.debug && tracer.debug("Read SQL " + self.abbrev + ":" + qry.sql);
		tracer.debug && tracer.debug("Constants " + self.abbrev + ":" + qry.constants);

		var rdr;
		var ord = {};
		if (tcnx) {
			rdr = self.driver.reader(_, tcnx, qry.sql, qry.constants, ord);
		} else {
			self.driver.withConnection(_, function(_, cnx) {
				rdr = self.driver.reader(_, cnx, qry.sql, qry.constants, ord);
			});
		}
		var cf = new DBCursor(rdr, ord.reader, qry.tables, qry.maptrim, qry.pwhere);

		var fstat = (cf.x3GetRecord(_)) ? 0 : 5;
		cf.x3CloseDBReader();
		//var s = cf.x3GetRecord(_);	

		return fstat;
	},


	// --------------------------------------------------------------------------------
	x3Rewrite: function(_, wkey, values) {
		var self = this;
		var constants = [];

		var colNames = Object.keys(self.desc.columns);

		if (wkey.rowid && self.qrewrite) {
			var sql = self.qrewrite;
		} else {

			var sql = "Update " + self.desc.name + " set " + colNames.map(function(name) {
				var col = self.desc.columns[name];
				return col.sqlNamesAssign();
			}) + " Where " + wkey.sql;

			// complete query
			var currtag = 0;
			var sql = sql.replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});
			if (!wkey.rowid) sql = sql.replace(new RegExp(self.abbrev + ".", "g"), "");
		}

		var constants = values.concat(wkey.constants || []);

		try {
			tracer.debug && tracer.debug("REWRITE:" + sql);
			tracer.debug && tracer.debug("Constants :" + constants);


			var result = self.superv.executeSql(_, sql, constants);
			if (result.updateCount === 0) return 5;
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e))
				return 3;
			else if (self.driver.isLocked(e))
				return 1;
			else throw e;
		}
	},

	// --------------------------------------------------------------------------------
	x3Write: function(_) {
		var self = this;
		var currind = 0;
		var colNames = Object.keys(self.desc.columns);
		var row = self.values;

		// Build query if necessary
		var sql = self.qinsert || (self.qinsert = "Insert into " + self.desc.name + " (" + colNames.map(function(name) {
			var col = self.desc.columns[name];
			return col.sqlNames("");
		}) + ") VALUES (" + colNames.map(function(name) {
			var s = "";
			var col = self.desc.columns[name];
			s += self.driver.param(currind++);
			for (var i = 1; i < col.data.DIME; i++) {
				s += ',';
				s += self.driver.param(currind++);
			}
			return s;
		}) + ")");


		// build values table
		var values = [];
		colNames.forEach(function(colName) {
			var val = row[colName];
			var col = self.desc.columns[colName];
			var etnaType = col.type.etnaType;

			if (col.data.DIME > 1) {
				for (var i = 0; i < col.data.DIME; i++) {
					if (val[i] !== undefined) values.push(val[i]);
					else values.push(variables.types[etnaType].def);
				}
			} else {

				if (/^(CREDATTIM|UPDDATTIM)$/.test(colName) && (val === undefined || val === null || (val.x3IsZero && val.x3IsZero()))) {
					val = tdatetime.now();
					//val.setMilliseconds(0); // bug tds ??? insertion error with milliseconds
					//val = tdate.fromJsDate(now);
				} else if (/^(CREUSR|UPDUSR)$/.test(colName) && (!val || !val.length)) {
					val = self.defaultLogin;
				} else if (val === undefined) {
					throw new X3Error(26, colName + ": bad value: " + val);
				}
				values.push(val);
			}
		});
		tracer.debug && tracer.debug("WRITE sql:" + sql);
		tracer.debug && tracer.debug("WRITE values:" + values);

		try {
			var result = self.superv.executeSql(_, sql, values);
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e))
				return 3;
			else if (self.driver.isLocked(e))
				return 1;
			else throw e;
		}
	},

	// --------------------------------------------------------------------------------
	x3OpenFor: function(_, key, lvl, hint, lock, where, tcnx) {
		var self = this;

		var master = (self.master || self);

		var qry = _buildQuery(_, 'for', self, key, undefined, where, lock);

		tracer.debug && tracer.debug("FORF:" + qry.sql);
		tracer.debug && tracer.debug("Constants :" + qry.constants);

		// execution ---------------------------------------
		var dbrd = {};
		if (tcnx) {
			var rdr = self.driver.reader(_, tcnx, qry.sql, qry.constants, dbrd);
			master.currentFor = new DBCursor(rdr, dbrd.reader, qry.tables, qry.maptrim, qry.pwhere, key, lvl);
		} else {
			self.driver.withConnection(_, function(_, cnx) {
				var rdr = self.driver.reader(_, cnx, qry.sql, qry.constants, dbrd);
				master.currentFor = new DBCursor(rdr, dbrd.reader, qry.tables, qry.maptrim, qry.pwhere, key, lvl);
			});
		}

		return master.currentFor;
	},


	// --------------------------------------------------------------------------------
	x3Delete: function(_, key, wkey, fwhere, tcnx) {
		var self = this;
		var ctx = {};
		ctx.tables = [self.abbrev];

		var dwhere = fwhere && fwhere(_, ctx);

		if ((dwhere && dwhere.postEvaluation) ||
			(self.where && self.where.postEvaluation) ||
			(self.filter.where && self.filter.where.postEvaluation)) {
			// need to build a query ------------------------------
			var nrecord = 0;
			var qry = _buildQuery(_, "for", self, key, wkey, fwhere, true);
			var dqry = "Delete " + self.desc.name + " Where ROWID = " + self.driver.param(0);

			// execution ---------------------------------------			
			var rdr = self.driver.reader(_, tcnx, qry.sql, qry.constants);
			var cf = new DBCursor(rdr, undefined, qry.tables, qry.maptrim, qry.pwhere, key, key.items.length);

			var row_save = self.values;

			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {

				tracer.debug && tracer.debug("DELETE:" + dqry);
				tracer.debug && tracer.debug("Constants :" + [self.values["ROWID"]]);

				var rs = self.superv.executeSql(_, dqry, [self.values["ROWID"]]);
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			self.values = row_save;
			return nrecord;

		} else {
			// classie delete
			if (self.master) throw new X3Error(26, "Table can't be a link");
			var abbrevs = [self.abbrev];
			var constants = [];

			var whereSqls = [];
			var wheres = [self.where, self.filter.where, wkey, dwhere];

			wheres.filter(identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				constants = constants.concat(w.constants || []);
			});
			var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';

			var currtag = 0;
			var sql = ("Delete " + self.desc.name + whereSql).replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});;
			sql = sql.replace(new RegExp(self.abbrev + ".", "g"), "");

			tracer.debug && tracer.debug("DELETE:" + sql);
			tracer.debug && tracer.debug("Constants :" + constants);

			try {
				var result = self.superv.executeSql(_, sql, constants);
				return result.updateCount;
			} catch (e) {
				if (self.driver.isLocked(e)) return -1;
				else throw e;
			}
		}
	},

	// --------------------------------------------------------------------------------
	x3Update: function(_, wkey, fwhere) {
		var self = this;

		if ((fwhere && fwhere.tooComplex) ||
			(self.where && self.where.tooComplex) ||
			(self.filter.where && self.filter.where.tooComplex)) {

		} else {

		}
	},

	// misc ----------------------------------------------------
	// ---------------------------------------------------------
	x3CloseFor: function() {
		var self = this;
		var master = (self.master || self);
		master.currentFor = undefined;
	},

	x3GetCurrentFor: function() {
		var self = this;
		var master = (self.master || self);
		return master.currentFor;
	},

	findIndex: function(name) {
		var self = this;
		var index = self.desc.index(name);
		if (!index) throw new X3Error(21, "bad index: " + name);
		return index;
	},

	findKey: function(name) {
		var self = this;
		if (!(name)) return self.keys[self.currkey];

		var k = self.keys.filter(function(k) {
			return ((k.name === name) && (k.hidden === false));
		});
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	},

	keyCompare: function(_, k, values) {
		var self = this;
		var cmp = 0,
			lvl = 0;

		while ((cmp === 0) && (values[lvl] !== undefined)) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	},
	getKeyValues: function(_, k, lvl) {
		var res = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	},
	setCurrentLogin: function(login) {
		var self = this;
		self.defaultLogin = login;
	}
});

exports.DBTable = DBTable;