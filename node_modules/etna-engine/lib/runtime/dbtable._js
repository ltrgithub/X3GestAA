"use strict";

const util = require('./util');
const variables = require('./variables');
const operators = require('./operators');
const array = require('./arrays');
const dates = require('./dates');
const evaluate = require('./dbevaluate');
const tdate = require('etna-engine/lib/runtime/tdate');
const tdatetime = require('etna-engine/lib/runtime/tdatetime');
const flowControl = require('./flowControl');
const X3Error = require('./errors').X3Error;
const glob = require('streamline/lib/globals');
const DBCursor = require('./dbcursor').DBCursor;
const DBTableParent = require('./dbtableparent').DBTableParent;
const helpers = require('syracuse-core/lib/helpers');
const tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");
const ez = require('ez-streams');
var activ;


const _reckey = {
	sql: "",
	constants: [],
	func: [],
	name: null,
	directions: [1],
	items: [""],
};


function _identity(x) {
	return x;
}

function _extended(abv) {
	return abv !== "extended";
}

function _addColumn(r, t) {
	const n = r.length;
	for (var i = 0; i < n; i++) {
		if ((r[i].field === t.field) && (r[i].index === t.index)) break;
	}
	//if (t.abbrev) delete t.abbrev; // we don't need it anymore
	if (i === n) r.push(t);
}

function _addColumns(dest, origin) {
	for (var ki = 0; ki < origin.columns.length; ki++) {
		const ci = origin.columns[ki];

		// don't initialyse if null, we retriece complete table in this case				
		if (dest[ci.abbrev]) {
			_addColumn(dest[ci.abbrev], ci);
		} else if (dest[ci.abbrev] === undefined) {
			dest[ci.abbrev] = [];
			_addColumn(dest[ci.abbrev], ci);
		}
	}
}

// split a key where;


function _splitKeyWhere(kw) {
	const tsql = kw.sql.split("OR");
	const nbq = tsql.length;
	tsql[0] = tsql[0].slice(1);
	tsql[nbq - 1] = tsql[nbq - 1].slice(0, tsql[nbq - 1].length - 1);

	const kws = [];
	for (var i = 0; i < nbq; i++) {
		kws[i] = {
			sql: tsql[i],
			tooComplex: false,
			type: 'boolean',
			constants: kw.constants.slice(0, nbq - i),
			func: kw.func,
		};
	}
	return kws;
}

// tab criteria contains post evaluated
// -----------------------------------------------------------------------


function _isPostEvaluated(wh) {
	for (var i = 0; i < wh.length; i++) {
		if (wh[i].postEvaluation) return true;
	}
	return false;
}

// build Read and for Query
// -----------------------------------------------------------------------


function _buildQuery(_, clause, self, key, wkey, fwhere, fwfrom, fwto, lock, hint) {
	const utilDriver = require("etna-engine/lib/drivers/util");

	// buikld query
	const master = (self.master || self);
	var tablesSql = master.desc.name + " " + master.abbrev;
	const tables = {};
	const abbrevs = [master.abbrev];
	var constants = [];
	const ctx = {};

	if (lock && clause === "read") tablesSql += self.driver.lockClause0();

	// table from --------------------------
	tables[master.abbrev] = master;
	(self.joins || []).forEach(function(join) {
		abbrevs.push(join.table.abbrev);
		tables[join.table.abbrev] = join.table;
		constants = constants.concat(join.constants || []);
		tablesSql += " " + join.sql;
	});
	ctx.tables = abbrevs;

	// where -----------------------------------
	// -----------------------------------------
	const twhere = [],
	tconstants = [],
	tpwhere = [];

	var columns = self.columns;
	// read particular case
	if (clause === "read") columns = (columns && columns.extended) ? columns : undefined;

	if (wkey && wkey[0].rowid) {
		constants = constants.concat(wkey[0].constants || []);
		twhere[0] = wkey[0].sql;
		tconstants[0] = constants;
		tpwhere[0] = []; /* we don post evaluate rowid */

	} else {
		var wheres;

		// we gonna modify the columns list, so we clone it		
		columns = columns && (function(origin) {
			const cpy = {};
			Object.keys(origin).forEach(function(abv) {
				cpy[abv] = origin[abv];
			});
			return cpy;
		})(columns);

		if (wkey) {
			var twkey = ((clause === "read") && wkey[0].splitable) ? _splitKeyWhere(wkey[0]) : wkey;
		} else {
			var twkey = [null];
		}

		// add key columns if needned
		if (columns && key) _addColumns(columns, key);

		for (var i = 0; i < twkey.length; i++) {
			const tsql = [];
			tconstants[i] = constants.slice();
			tpwhere[i] = [];

			wheres = [twkey[i]].concat(self.where, self.filter.where);
			if (self.master) {
				wheres = wheres.concat(master.where, master.filter.where);
			}
			wheres = wheres.concat(fwhere && fwhere(_, ctx));
			wheres = wheres.concat(fwfrom && fwfrom(_, ctx));
			wheres = wheres.concat(fwto && fwto(_, ctx));

			wheres.filter(_identity).forEach(function(w) {
				w.sql && tsql.push(w.sql);
				w.func && tpwhere[i].push(w.func);
				if (!w.tooComplex) tconstants[i] = tconstants[i].concat(w.constants || []);
				if (columns && w.columns) _addColumns(columns, w);
			});
			twhere[i] = tsql.join(' AND ');
		}
	}

	// select ----------------------------------
	// -----------------------------------------
	var typesmap;
	var columnsSql;
	const sqlOpts = {};
	if (clause === "rowcount") {
		columnsSql = "Count(*) As A$RESULT_0";
		typesmap = [3];
	} else {
		typesmap = [0];
		columnsSql = (columns ? Object.keys(columns).filter(_extended).reduce(function(result, a) {
			//debugger ;
			const cdef = columns[a];
			if (cdef !== null) {
				for (var cnum = 0; cnum < cdef.length; cnum++) {
					const typtyp = cdef[cnum].field.type.data.TYPTYP;
					typesmap.push(typtyp);
					const nm = cdef[cnum].field.data.CODZONE + '_' + cdef[cnum].index;
					result.push(a + "." + nm + " As " + a + "$" + nm);
					if (typtyp === 4) {
						sqlOpts.decimalColumns = sqlOpts.decimalColumns || [];
						sqlOpts.decimalColumns.push(nm);
					}
				}
			} else {
				const tab = tables[a];
				Object.keys(tab.desc.columns).forEach(function(name) {
					const col = tab.desc.columns[name];
					col.sqlTypesMap(typesmap);
					result.push(col.sqlNames(abbrev + ".", abbrev, sqlOpts));
				});
			}
			return result;
		}, []) : abbrevs.reduce(function(result, abbrev) {
			const tab = tables[abbrev];
			Object.keys(tab.desc.columns).forEach(function(name) {
				const col = tab.desc.columns[name];
				col.sqlTypesMap(typesmap);
				result.push(col.sqlNames(abbrev + ".", abbrev, sqlOpts));
			});
			return result;
		}, [])).join(', ');
	}

	// complete queries --------------------------------	
	const tqry = twhere.map(function(whereSqls, idx) {
		var currtag = 0;
		var whereSql = whereSqls ? " WHERE " + whereSqls : ' ';
		const middleSql = (tablesSql + whereSql).replace(/@\?/g, function(val) {
			return self.driver.param(currtag++);
		});
		var orderBySql = "";
		if (((!wkey) || (!wkey[0].rowid)) && key && key.sql) orderBySql = " ORDER BY " + key.sql;

		var sql;
		if (hint) {
			hint.tname = master.desc.name;
			hint.abbrev = hint.abbrev || master.abbrev;
		}

		//if (clause === "rowcount") sql = "Select ";
		//else sql = "Select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, ";
		switch (clause) {
			case 'rowcount':
				sql = "Select ";
				break;
			case 'read':
				sql = "Select " + self.driver.hintClause0(hint, true) + " " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, ";
				break;
			case 'for':
				sql = "Select " + self.driver.hintClause0(hint, false) + " " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, ";
				break;
			default:
				throw new X3Error(26, "invalid query type :" + clause + " in buildQurery");
		}

		sql += columnsSql + " From " + middleSql + orderBySql;
		if (lock && clause === "read") sql += self.driver.lockClause1();

		switch (clause) {
			case 'read':
				sql += self.driver.hintClause1(hint, true);
				break;
			case 'for':
				sql += self.driver.hintClause1(hint, false);
				break;
			default:
		}

		return {
			sql: sql,
			maptrim: utilDriver.maptrim(self.driver, typesmap, true),
			typesmap: typesmap,
			tables: tables,
			pwhere: tpwhere[idx],
			constants: tconstants[idx],
			columns: columns,
			sqlOpts: sqlOpts,
		};
	});
	return tqry;
}
// -----------------------------------------------------------------------

function _transformKey(orik, mod) {
	//copy key
	const newk = {
		name: "",
		sqk: "",
		hidden: false,
		unique: (mod.length) ? false : orik.unique,
		constants: orik.constants,
		kslot: -1,
	};

	const len = (mod.length || orik.items.length);

	// treat items and sql
	newk.directions = orik.directions.map(function(d) {
		return d * mod.direction;
	}).slice(0, len);

	newk.items = orik.items.slice(0, len).map(function(itm, idx) {
		const p = itm.lastIndexOf(' ');
		if (p > 0) itm = itm.substring(0, p);
		//if (newk.directions[idx] < 0) itm += " Desc";
		return itm;
	});

	newk.func = orik.func.slice(0, len);

	newk.sql = newk.items.map(function(it, idx) {
		return it + ((newk.directions[idx] < 0) ? " Desc" : "");
	}).join(", ");
	return newk;
}

function _writeLobs(_, row, lobVars, outputVars) {
	lobVars.forEach_(_, function(_, lobVar, i) {
		const col = lobVar.column;
		const val = row[col.name];
		const isClob = col.type.isClob;
		const dev = isClob ? ez.devices.string : ez.devices.buffer;
		const v = isClob ? val : (val && val.value);
		if (isClob && typeof v !== "string") throw new X3Error(26, col.name + ": bad CLOB: " + typeof v);
		if (!isClob && !Buffer.isBuffer(v)) throw new X3Error(26, col.name + ": bad BLOB: " + typeof v);
		dev.reader(v).pipe(_, outputVars[i]);
	});
}

function _lobsReturningClause(driver, lobColumns, lobVars, currind) {
	var sql = " RETURNING ";
	lobColumns.forEach(function(col, i) {
		const sqlType = col.type.sqlType();
		for (var j = 0; j < col.data.DIME; j++) {
			if (i > 0 || j > 0) sql += ',';
			const colName = col.name + '_' + j;
			const param = driver.param(currind++);
			lobVars.push({
				name: param.substring(1),
				// remove leading :
				type: col.type.sqlType(),
				column: col,
				// for us below, not for driver
				ind: j,
				// idem
			});
			sql += colName + " INTO " + param;
		}
	});
	return sql;
}

// object DBTable classe
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------
class DBTable extends DBTableParent {
	constructor(driver, abbrev, superv, desc, keys, loc) {
		if (driver instanceof DBTable) {
			const tbl = driver;
			super(tbl.driver, abbrev, tbl.superv, tbl.local);
			this.master = tbl;
			this.currkey = 0;
			this.reader = undefined;
			this.desc = tbl.desc;
			this.keys = tbl.keys;

			this.types = tbl.types;
			this.values = tbl.values;
			this.columns = undefined;

		} else {
			super(driver, abbrev, superv, loc);

			this.currkey = 0;
			this.currlen = keys[0].items.length;

			this.reader = undefined;
			this.desc = desc;
			this.keys = keys;
		}
	}
	init(_) {
		const self = this;
		const table = this;
		const columns = this.desc.columns;

		Object.keys(columns).forEach_(_, function(_, colName) {
			const etnaType = columns[colName].type.etnaType;
			if (columns[colName].data.DIME <= 1) {
				table.values[colName] = variables.types[etnaType].
				default;
			} else if (columns[colName].data.CODACT) {
				activ = activ || require("etna-supervisor/lib/meta/activ");
				const dime = activ.getActiv(_, self.superv, columns[colName].data.CODACT);
				if (dime) columns[colName].data.DIME = dime;
				table.values[colName] = []; //[1, variables.types[etnaType].default, [], 0, dim-1];
			} else {
				table.values[colName] = [1, variables.types[etnaType].
					default, [], 0, columns[colName].data.DIME - 1
				];
			}
			table.types[colName] = ' ' + etnaType;
		});
		return this;
	}

	// operation on table --------------------------------------
	// ---------------------------------------------------------
	x3Read(_, key, lvl, wkey, krevert, lock, hint) {
		const self = this;
		var rkey;
		const cnx = glob.context.x3session.dbConnection;
		if (lock && (!cnx)) throw new X3Error(26, "Lock without transaction");

		//debugger;
		if (krevert) {
			rkey = _transformKey(key, {
				direction: -1,
				length: 0
			});
			if (hint) hint.revert = true;
		} else rkey = key;

		const tqry = _buildQuery(_, 'read', self, rkey, wkey, undefined, undefined, undefined, lock, hint);
		var fstat = 5; // not found
		for (var idx = 0; idx < tqry.length; idx++) {
			const q = tqry[idx];

			tracer.debug && tracer.debug("Read SQL(" + idx + ")" + self.abbrev + ":" + q.sql);
			tracer.debug && tracer.debug("Constants " + self.abbrev + ":" + q.constants);
			const rdr = self.driver.reader(_, cnx, q.sql, q.constants, q.sqlOpts);
			tracer.debug && tracer.debug("Cursor declaration....");
			const cf = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, undefined, undefined, "read", q.columns);
			tracer.debug && tracer.debug("Call x3GetRecord....");

			if (cf.x3GetRecord(_)) fstat = 0; // found
			tracer.debug && tracer.debug("Get record Ok : " + JSON.stringify(self.values));
			cf.x3CloseDBReader(_);
			tracer.debug && tracer.debug("Close reader done ");

			if (fstat === 0) break;
		}
		return fstat;
	}

	x3Rewrite(_, wkey, values) {
		const self = this;
		const abv = (self.master || self).abbrev;
		const lst = self.columns && self.columns[abv];

		if (lst) {

			var sql = "Update " + self.desc.name + " set ";
			for (var i = 0; i < lst.length; i++) {
				sql += ((i === 0) ? "" : ", ") + lst[i].field.sqlNamesAssign();
			}

			sql += " Where " + wkey[0].sql;

			// complete query
			var currtag = 0;
			sql = sql.replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});
			if (!wkey[0].rowid) sql = sql.replace(new RegExp(self.abbrev + "\\.", "g"), "");
		} else {
			const colNames = Object.keys(self.desc.columns);
			if (wkey[0].rowid && self.qrewrite) {
				var sql = self.qrewrite;
			} else {

				var sql = "Update " + self.desc.name + " set " + colNames.map(function(name) {
					const col = self.desc.columns[name];
					return col.sqlNamesAssign();
				}) + " Where " + wkey[0].sql;

				// complete query
				var currtag = 0;
				sql = sql.replace(/@\?/g, function(val) {
					return self.driver.param(currtag++);
				});
				if (!wkey[0].rowid) sql = sql.replace(new RegExp(self.abbrev + "\\.", "g"), "");
			}
		}

		const constants = values.concat(wkey[0].constants || []);

		try {
			tracer.debug && tracer.debug("REWRITE:" + sql);
			tracer.debug && tracer.debug("Constants :" + constants);


			const result = self.superv.executeSql(_, sql, constants);
			if (result.updateCount === 0) return 5;
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e)) return 3;
			else if (self.driver.isLocked(e)) return 1;
			else throw e;
		}
	}

	x3Write(_) {
		const self = this;
		var currind = 0;
		const colNames = Object.keys(self.desc.columns);
		const row = self.values;
		const lobColumns = [];
		const lobVars = [];

		function param(col, i) {
			if (self.driver.lobPlaceholder && col.type.isLob()) {
				if (i === 0) lobColumns.push(col);
				return self.driver.lobPlaceholder(col.type.sqlType());
			} else {
				return self.driver.param(currind++);
			}
		}

		// Build query if necessary
		var sql = self.qinsert || (self.qinsert = "Insert into " + self.desc.name + " (" + colNames.map(function(name) {
			const col = self.desc.columns[name];
			return col.sqlNames("");
		}) + ") VALUES (" + colNames.map(function(name) {
			var s = "";
			const col = self.desc.columns[name];
			for (var i = 0; i < col.data.DIME; i++) {
				if (i > 0) s += ',';
				s += param(col, i);
			}
			return s;
		}) + ")");

		if (lobColumns.length > 0) {
			sql += _lobsReturningClause(self.driver, lobColumns, lobVars, currind);
		}

		// build values table
		const values = [];
		colNames.forEach(function(colName) {
			var val = row[colName];
			const col = self.desc.columns[colName];
			if (self.driver.lobPlaceholder && col.type.isLob()) return;
			const etnaType = col.type.etnaType;

			if (col.data.DIME > 1) {
				const tb = val[2];
				for (var i = 0; i < col.data.DIME; i++) {
					if (tb[i] !== undefined) values.push(tb[i]);
					else values.push(variables.types[etnaType].default);
				}
			} else {

				if (/^(CREDATTIM|UPDDATTIM)$/.test(colName) && (val === undefined || val === null || (val.x3IsZero && val.x3IsZero()))) {
					val = tdatetime.now();
					//val.setMilliseconds(0); // bug tds ??? insertion error with milliseconds
					//val = tdate.fromJsDate(now);
				} else if (/^(CREUSR|UPDUSR)$/.test(colName) && (!val || !val.length)) {
					val = self.defaultLogin;
				} else if (val === undefined) {
					throw new X3Error(26, colName + ": bad value: " + val);
				}
				values.push(val);
			}
		});
		tracer.debug && tracer.debug("WRITE sql:" + sql);
		tracer.debug && tracer.debug("WRITE values:" + values);

		try {
			const result = self.superv.executeSql(_, sql, values, {
				outputVars: lobVars,
			});
			if (lobVars.length > 0) {
				_writeLobs(_, row, lobVars, result.outputVars);
			}
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e)) return 3;
			else if (self.driver.isLocked(e)) return 1;
			else throw e;
		}
	}

	x3OpenFor(_, key, lvl, hint, lock, where, wfrom, wto) {
		const self = this;

		const master = (self.master || self);

		const qry = _buildQuery(_, 'for', self, key, undefined, where, wfrom, wto, lock, hint);
		const q = qry[0];

		tracer.debug && tracer.debug("FORF:" + q.sql);
		tracer.debug && tracer.debug("Constants :" + q.constants);

		// execution ---------------------------------------
		const rdr = self.driver.reader(_, q.sql, q.constants, q.sqlOpts);
		master.currentFor = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, key, lvl, "for", q.columns);
		return master.currentFor;
	}


	x3Delete(_, key, wkey, fwhere) {
		const self = this;
		const ctx = {};
		ctx.tables = [self.abbrev];

		const dwhere = fwhere && fwhere(_, ctx);

		if ((dwhere && _isPostEvaluated(dwhere)) || (self.where && _isPostEvaluated(self.where)) || (self.filter.where && _isPostEvaluated(self.filter.where))) {
			// need to build a query ------------------------------
			var nrecord = 0;
			const qry = _buildQuery(_, "for", self, key, wkey, fwhere, undefined, undefined, true, null);
			const q = qry[0];
			const dqry = "Delete " + self.desc.name + " Where ROWID = " + self.driver.param(0);

			// execution ---------------------------------------			
			const rdr = self.driver.reader(_, q.sql, q.constants, q.sqlOpts);
			const cf = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, key, key.items.length, "for", q.columns);

			const row_save = self.values;

			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {

				tracer.debug && tracer.debug("DELETE:" + dqry);
				tracer.debug && tracer.debug("Constants :" + [self.values["ROWID"]]);

				const rs = self.superv.executeSql(_, dqry, [self.values["ROWID"]]);
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			self.values = row_save;
			return nrecord;

		} else {
			// classie delete
			if (self.master) throw new X3Error(26, "Table can't be a link");
			const abbrevs = [self.abbrev];
			var constants = [];

			const whereSqls = [];
			const wheres = (wkey || []).concat(self.where, self.filter.where, dwhere);

			wheres.filter(_identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				constants = constants.concat(w.constants || []);
			});
			const whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';

			var currtag = 0;
			var sql = ("Delete " + self.desc.name + whereSql).replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});;
			sql = sql.replace(new RegExp(self.abbrev + "\\.", "g"), "");

			tracer.debug && tracer.debug("DELETE:" + sql);
			tracer.debug && tracer.debug("Constants :" + constants);

			try {
				const result = self.superv.executeSql(_, sql, constants);
				return result.updateCount;
			} catch (e) {
				if (self.driver.isLocked(e)) return -1;
				else throw e;
			}
		}
	}

	x3Update(_, fwhere, asssql, consts) {
		const self = this;
		const ctx = {};
		ctx.tables = [self.abbrev];
		ctx.noabbrev = true;
		const dwhere = fwhere && fwhere(_, ctx);
		if ((dwhere && _isPostEvaluated(dwhere)) || (self.where && _isPostEvaluated(self.where)) || (self.filter.where && _isPostEvaluated(self.filter.where))) {

			// need to build a query ------------------------------
			var nrecord = 0;
			// BRJOU: changed lock to false
			const qry = _buildQuery(_, "for", self, undefined, undefined, fwhere, undefined, undefined, false, null);
			const q = qry[0];

			var currtag = 0;
			const dqry = ("Update " + self.desc.name + " Set " + asssql + " Where ROWID = @?").replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});

			const row_save = self.values;
			// execution ---------------------------------------			
			const rdr = self.driver.reader(_, q.sql, q.constants, q.sqlOpts);
			const cf = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, undefined, 0, "for", q.columns);


			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {

				tracer.debug && tracer.debug("UPDATE:" + dqry);
				tracer.debug && tracer.debug("Constants :" + consts.concat([self.values["ROWID"]]));

				const rs = self.superv.executeSql(_, dqry, consts.concat([self.values["ROWID"]]));
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			self.values = row_save;
			return nrecord;

		} else {
			if (self.master) throw new X3Error(26, "Table can't be a link");
			const abbrevs = [self.abbrev];
			var constants = [];

			const whereSqls = [];
			const wheres = [].concat(self.where, self.filter.where, dwhere);

			wheres.filter(_identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				constants = constants.concat(w.constants || []);
			});
			const whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';

			constants = consts.concat(constants);

			var currtag = 0;
			var sql = ("Update " + self.desc.name + " Set " + asssql + whereSql).replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});;
			sql = sql.replace(new RegExp(self.abbrev + "\\.", "g"), "");

			tracer.debug && tracer.debug("UPDATE:" + sql);
			tracer.debug && tracer.debug("Constants :" + constants);

			try {
				const result = self.superv.executeSql(_, sql, constants);
				return result.updateCount;
			} catch (e) {
				if (self.driver.isUniqueViolated(e)) return -3;
				else if (self.driver.isLocked(e)) return -1;
			}
		}
	}
	x3Rowcount(_) {
		const self = this;
		const master = (self.master || self);
		var loop = false;
		if ((self.where && _isPostEvaluated(self.where)) || (self.filter.where && _isPostEvaluated(self.filter.where))) loop = true;
		if ((!loop) && self.master && ((self.master.where && _isPostEvaluated(self.master.where)) || (self.master.filter.where && _isPostEvaluated(self.master.filter.where)))) loop = true;

		if (loop) {
			const qry = _buildQuery(_, "for", self, undefined, undefined, undefined, undefined, undefined, false, null);
			const q = qry[0];
			// execution ---------------------------------------			
			const row_save = self.values;
			var nrecord = 0;
			const rdr = self.driver.reader(_, q.sql, q.constants, q.sqlOpts);
			const cf = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, undefined, 0, "for", undefined);


			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			self.values = row_save;
			return nrecord;

		} else {
			const qry = _buildQuery(_, "rowcount", self, undefined, undefined, undefined, false);
			const q = qry[0];
			q.sqlOpts.typesmap = q.typesmap;
			q.sqlOpts.dispatch = true;
			const result = self.superv.executeSql(_, q.sql, q.constants, q.sqlOpts);
			return result[0]["A"].RESULT;
		}
	}

	// misc ----------------------------------------------------
	// ---------------------------------------------------------
	x3SetNewKey(newkey) {
		const self = this;

		if (newkey.sql) {
			self.keys.forEach(function(ky) {
				ky.hidden = true;
			});

			newkey.kslot = self.keys.push(newkey) - 1;
			self.currkey = newkey.kslot;
			self.currlen = newkey.items.length;
			delete newkey["modofied"];
		} else {
			const mk = self.findKey(newkey.name);

			self.keys.forEach(function(ky) {
				ky.hidden = true;
			});

			if (newkey.modified) {
				newkey = _transformKey(mk, newkey.modified);
				newkey.kslot = self.keys.push(newkey) - 1;
				self.currkey = newkey.kslot;
				self.currlen = newkey.items.length;
			} else {
				mk.hidden = false;
				self.currkey = mk.kslot;
				self.currlen = mk.items.length;
			}
		}
	}
	x3CloseFor() {
		const self = this;
		const master = (self.master || self);
		master.currentFor = undefined;
	}
	x3GetCurrentFor() {
		const self = this;
		const master = (self.master || self);
		return master.currentFor;
	}
	findIndex(name) {
		const self = this;
		const index = self.desc.index(name);
		if (!index) throw new X3Error(21, "bad index: " + name);
		return index;
	}
	findKey(name) {
		const self = this;
		if (name === "reckey") return _reckey;

		if (!(name)) return self.keys[self.currkey];

		const k = self.keys.filter(function(k) {
			return ((k.name === name) && (k.hidden === false));
		});
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	}
	keyCompare(_, k, values) {
		const self = this;
		var cmp = 0,
			lvl = 0;

		while ((cmp === 0) && (values[lvl] !== undefined)) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	}
	getKeyValues(_, k, lvl) {
		const res = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	}
	setCurrentLogin(login) {
		const self = this;
		self.defaultLogin = login;
	}
}

exports.DBTable = DBTable;