"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var array = require('./arrays');
var dates = require('./dates');
var evaluate = require('./dbevaluate');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');
var DBCursor = require('./dbcursor').DBCursor;
var DBTableParent = require('./dbtableparent').DBTableParent;
var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");
var activ;


var _reckey = {
	sql: "",
	constants: [],
	func: [],
	name: null,
	directions: [1],
	items: [""],
};


function identity(x) {
	return x;
}

/*
				return {
					key: key.kslot,
					operation: op,
					splitable:true,
					sql: sql,
					constants: consts,
					tooComplex: false,
					type: 'boolean',
					func: ofunc,
				};
*/


// split a key where;
function _splitKeyWhere(kw) {
	var tsql = kw.sql.split("OR");
	var nbq = tsql.length;
	tsql[0] = tsql[0].slice(1);
	tsql[nbq - 1] = tsql[nbq - 1].slice(0, tsql[nbq - 1].length - 1);

	var kws = [];
	for (var i = 0; i < nbq; i++) {
		kws[i] = {
			sql: tsql[i],
			tooComplex: false,
			type: 'boolean',
			constants: kw.constants.slice(0, nbq - i),
			func: kw.func,
		};
	}
	return kws;
}

// tab criteria contains post evaluated
// -----------------------------------------------------------------------
function _isPostEvaluated(wh) {
	for (var i = 0; i < wh.length; i++) {
		if (wh[i].postEvaluation) return true;
	}
	return false;
}

// build Read and for Query
// -----------------------------------------------------------------------
function _buildQuery(_, clause, self, key, wkey, fwhere, fwfrom, fwto, lock, hint) {
	var utilDriver = require("etna-supervisor/lib/drivers/util");

	// buikld query
	var master = (self.master || self);
	var tablesSql = master.desc.name + " " + master.abbrev;
	var tables = {};
	var abbrevs = [master.abbrev];
	var constants = [];
	var ctx = {};

	if (lock) tablesSql += self.driver.lockClause0(clause === "read");

	// table from --------------------------
	tables[master.abbrev] = master;
	(self.joins || []).forEach(function(join) {
		abbrevs.push(join.table.abbrev);
		tables[join.table.abbrev] = join.table;
		constants = constants.concat(join.constants || []);
		tablesSql += " " + join.sql;
	});
	ctx.tables = abbrevs;

	// select ---------------------------------
	var typesmap;
	var columnsSql;
	if (clause === "rowcount") {
		columnsSql = "Count(*) As A$RESULT_0";
		typesmap = [3];
	} else {
		typesmap = [0];
		columnsSql = (self.columns ? self.columns.map(function(column) {
			column.sqlTypesMap(typesmap);;
			return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
		}) : abbrevs.reduce(function(result, abbrev) {
			var tab = tables[abbrev];
			Object.keys(tab.desc.columns).forEach(function(name) {
				var col = tab.desc.columns[name];
				col.sqlTypesMap(typesmap);
				result.push(col.sqlNames(abbrev + ".", abbrev));
			});
			return result;
		}, [])).join(', ');
	}


	// where -----------------------------------
	var twhere = [],
		tconstants = [],
		tpwhere = [];

	//debugger;

	if (wkey && wkey[0].rowid) {
		constants = constants.concat(wkey[0].constants || []);
		twhere[0] = wkey[0].sql;
		tconstants[0] = constants;
		tpwhere[0] = []; /* we don post evaluate rowid */
	} else {
		var wheres;

		if (wkey) {
			var twkey = ((clause === "read") && wkey[0].splitable) ? _splitKeyWhere(wkey[0]) : wkey;
		} else {
			var twkey = [null];
		}

		for (var i = 0; i < twkey.length; i++) {
			var tsql = [];
			tconstants[i] = constants.slice();
			tpwhere[i] = [];

			wheres = [twkey[i]].concat(self.where, self.filter.where);
			if (self.master) {
				wheres = wheres.concat(master.where, master.filter.where);
			}
			wheres = wheres.concat(fwhere && fwhere(_, ctx));
			wheres = wheres.concat(fwfrom && fwfrom(_, ctx));
			wheres = wheres.concat(fwto && fwto(_, ctx));

			wheres.filter(identity).forEach(function(w) {
				w.sql && tsql.push(w.sql);
				w.func && tpwhere[i].push(w.func);
				if (!w.tooComplex) tconstants[i] = tconstants[i].concat(w.constants || []);
			});
			twhere[i] = tsql.join(' AND ');

		}
	}

	// complete queries --------------------------------	
	var tqry = twhere.map(function(whereSqls, idx) {
		var currtag = 0;
		var whereSql = whereSqls ? " WHERE " + whereSqls : ' ';
		var middleSql = (tablesSql + whereSql).replace(/@\?/g, function(val) {
			return self.driver.param(currtag++);
		});
		var orderBySql = "";
		if (((!wkey) || (!wkey[0].rowid)) && key && key.sql)
			orderBySql = " ORDER BY " + key.sql;

		var sql;
		if (hint) {
			hint.tname = master.desc.name;
			hint.abbrev = hint.abbrev || master.abbrev;
		}

		//if (clause === "rowcount") sql = "Select ";
		//else sql = "Select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, ";
		switch (clause) {
			case 'rowcount':
				sql = "Select ";
				break;
			case 'read':
				sql = "Select " + self.driver.hintClause0(hint, true) + " " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, ";
				break;
			case 'for':
				sql = "Select " + self.driver.hintClause0(hint, false) + " " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, ";
				break;
			default:
				throw new X3Error(26, "invalid query type :" + clause + " in buildQurery");
		}

		sql += columnsSql + " From " + middleSql + orderBySql;
		if (lock) sql += self.driver.lockClause1(clause === "read");

		switch (clause) {
			case 'read':
				sql += self.driver.hintClause1(hint, true);
				break;
			case 'for':
				sql += self.driver.hintClause1(hint, false);
				break;
			default:
		}

		return {
			sql: sql,
			maptrim: utilDriver.maptrim(self.driver, typesmap, true),
			typesmap: typesmap,
			tables: tables,
			pwhere: tpwhere[idx],
			constants: tconstants[idx],
		};
	});
	return tqry;
}
// -----------------------------------------------------------------------

function _transformKey(orik, mod) {
	//copy key
	var newk = {
		name: "",
		sqk: "",
		hidden: false,
		unique: (mod.length) ? false : orik.unique,
		constants: orik.constants,
		kslot: -1,
	};

	var len = (mod.length || orik.items.length);

	// treat items and sql
	newk.directions = orik.directions.map(function(d) {
		return d * mod.direction;
	}).slice(0, len);

	newk.items = orik.items.slice(0, len).map(function(itm, idx) {
		var p = itm.lastIndexOf(' ');
		if (p > 0) itm = itm.substring(0, p);
		//if (newk.directions[idx] < 0) itm += " Desc";
		return itm;
	});

	newk.func = orik.func.slice(0, len);

	newk.sql = newk.items.map(function(it, idx) {
		return it + ((newk.directions[idx] < 0) ? " Desc" : "");
	}).join(", ");
	return newk;
}


// object DBTable classe
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------

var DBTable = helpers.defineClass(function(driver, abbrev, superv, desc, keys, loc) {
	var self = this;
	if (driver instanceof DBTable) {
		var tbl = driver;

		DBTableParent.call(self, tbl.driver, abbrev, tbl.superv, tbl.local);
		self.master = tbl;
		self.currkey = 0;
		self.reader = undefined;
		self.desc = tbl.desc;
		self.keys = tbl.keys;

		self.types = tbl.types;
		self.values = tbl.values;

	} else {

		DBTableParent.call(self, driver, abbrev, superv, loc);

		self.currkey = 0;
		self.currlen = keys[0].items.length;

		self.reader = undefined;
		self.desc = desc;
		self.keys = keys;
	}
	return self;
}, DBTableParent, {
	init: function(_) {
		var self = this;
		var table = this;
		var columns = this.desc.columns;

		Object.keys(columns).forEach_(_, function(_, colName) {
			var etnaType = columns[colName].type.etnaType;
			if (columns[colName].data.DIME <= 1) {
				table.values[colName] = variables.types[etnaType].def;
			} else if (columns[colName].data.CODACT) {
				activ = activ || require("etna-supervisor/lib/meta/activ");
				var dime = activ.getActiv(_, self.superv, columns[colName].data.CODACT);
				if (dime) columns[colName].data.DIME = dime;
				table.values[colName] = []; //[1, variables.types[etnaType].def, [], 0, dim-1];
			} else {
				table.values[colName] = [1, variables.types[etnaType].def, [], 0, columns[colName].data.DIME - 1];
			}
			table.types[colName] = ' ' + etnaType;
		});
		return this;
	},

	// operation on table --------------------------------------
	// ---------------------------------------------------------
	x3Read: function(_, key, lvl, wkey, krevert, lock, hint, tcnx) {
		var self = this;
		var rkey;
		if (lock && (!tcnx)) throw new X3Error(26, "Lock whitout transaction");

		//debugger;
		if (krevert) {
			rkey = _transformKey(key, {
				direction: -1,
				length: 0
			});
			if (hint) hint.revert = true;
		} else rkey = key;

		var tqry = _buildQuery(_, 'read', self, rkey, wkey, undefined, undefined, undefined, lock, hint);
		var qry,
			rdr,
			ord;

		for (var idx = 0; idx < tqry.length; idx++) {
			ord = {};

			tracer.debug && tracer.debug("Read SQL(" + idx + ")" + self.abbrev + ":" + tqry[idx].sql);
			tracer.debug && tracer.debug("Constants " + self.abbrev + ":" + tqry[idx].constants);

			if (tcnx) {
				rdr = self.driver.reader(_, tcnx, tqry[idx].sql, tqry[idx].constants, ord);
				tracer.debug && tracer.debug("test read...");
				tracer.debug && tracer.debug("test read ok");
			} else {
				self.driver.withConnection(_, function(_, cnx) {
					rdr = self.driver.reader(_, cnx, tqry[idx].sql, tqry[idx].constants, ord);
				});
			}
			tracer.debug && tracer.debug("Cursor declaration....");
			var cf = new DBCursor(_, rdr, ord.reader, tqry[idx].tables, tqry[idx].maptrim, tqry[idx].pwhere, undefined, undefined, "read");
			tracer.debug && tracer.debug("Cursor declared....");
			tracer.debug && tracer.debug("Call x3GetRecord....");

			var fstat = (cf.x3GetRecord(_)) ? 0 : 5;
			tracer.debug && tracer.debug("Get record Ok : " + JSON.stringify(self.values));
			cf.x3CloseDBReader(_);
			tracer.debug && tracer.debug("Close reader done ");


			if (fstat === 0) break;
		}
		//var s = cf.x3GetRecord(_);	

		return fstat;
	},


	// --------------------------------------------------------------------------------
	x3Rewrite: function(_, wkey, values) {
		var self = this;
		var constants = [];

		var colNames = Object.keys(self.desc.columns);

		if (wkey[0].rowid && self.qrewrite) {
			var sql = self.qrewrite;
		} else {

			var sql = "Update " + self.desc.name + " set " + colNames.map(function(name) {
				var col = self.desc.columns[name];
				return col.sqlNamesAssign();
			}) + " Where " + wkey[0].sql;

			// complete query
			var currtag = 0;
			var sql = sql.replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});
			if (!wkey[0].rowid) sql = sql.replace(new RegExp(self.abbrev + "\\.", "g"), "");
		}

		var constants = values.concat(wkey[0].constants || []);

		try {
			tracer.debug && tracer.debug("REWRITE:" + sql);
			tracer.debug && tracer.debug("Constants :" + constants);


			var result = self.superv.executeSql(_, sql, constants);
			if (result.updateCount === 0) return 5;
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e))
				return 3;
			else if (self.driver.isLocked(e))
				return 1;
			else throw e;
		}
	},

	// --------------------------------------------------------------------------------
	x3Write: function(_) {
		var self = this;
		var currind = 0;
		var colNames = Object.keys(self.desc.columns);
		var row = self.values;

		// Build query if necessary
		var sql = self.qinsert || (self.qinsert = "Insert into " + self.desc.name + " (" + colNames.map(function(name) {
			var col = self.desc.columns[name];
			return col.sqlNames("");
		}) + ") VALUES (" + colNames.map(function(name) {
			var s = "";
			var col = self.desc.columns[name];
			s += self.driver.param(currind++);
			for (var i = 1; i < col.data.DIME; i++) {
				s += ',';
				s += self.driver.param(currind++);
			}
			return s;
		}) + ")");


		// build values table
		var values = [];
		colNames.forEach(function(colName) {
			var val = row[colName];
			var col = self.desc.columns[colName];
			var etnaType = col.type.etnaType;

			if (col.data.DIME > 1) {
				var tb = val[2];
				for (var i = 0; i < col.data.DIME; i++) {
					if (val[i] !== undefined) values.push(tb[i]);
					else values.push(variables.types[etnaType].def);
				}
			} else {

				if (/^(CREDATTIM|UPDDATTIM)$/.test(colName) && (val === undefined || val === null || (val.x3IsZero && val.x3IsZero()))) {
					val = tdatetime.now();
					//val.setMilliseconds(0); // bug tds ??? insertion error with milliseconds
					//val = tdate.fromJsDate(now);
				} else if (/^(CREUSR|UPDUSR)$/.test(colName) && (!val || !val.length)) {
					val = self.defaultLogin;
				} else if (val === undefined) {
					throw new X3Error(26, colName + ": bad value: " + val);
				}
				values.push(val);
			}
		});
		tracer.debug && tracer.debug("WRITE sql:" + sql);
		tracer.debug && tracer.debug("WRITE values:" + values);

		try {
			var result = self.superv.executeSql(_, sql, values);
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e))
				return 3;
			else if (self.driver.isLocked(e))
				return 1;
			else throw e;
		}
	},

	// --------------------------------------------------------------------------------
	x3OpenFor: function(_, key, lvl, hint, lock, where, wfrom, wto, tcnx) {
		var self = this;

		var master = (self.master || self);

		var qry = _buildQuery(_, 'for', self, key, undefined, where, wfrom, wto, lock, hint);

		tracer.debug && tracer.debug("FORF:" + qry[0].sql);
		tracer.debug && tracer.debug("Constants :" + qry[0].constants);

		// execution ---------------------------------------
		var dbrd = {};
		if (tcnx) {
			var rdr = self.driver.reader(_, tcnx, qry[0].sql, qry[0].constants, dbrd);
			master.currentFor = new DBCursor(_, rdr, dbrd.reader, qry[0].tables, qry[0].maptrim, qry[0].pwhere, key, lvl, "for");
		} else {
			self.driver.withConnection(_, function(_, cnx) {
				var rdr = self.driver.reader(_, cnx, qry[0].sql, qry[0].constants, dbrd);
				master.currentFor = new DBCursor(_, rdr, dbrd.reader, qry[0].tables, qry[0].maptrim, qry[0].pwhere, key, lvl, "for");
			});
		}

		return master.currentFor;
	},


	// --------------------------------------------------------------------------------
	x3Delete: function(_, key, wkey, fwhere, tcnx) {
		var self = this;
		var ctx = {};
		ctx.tables = [self.abbrev];

		var dwhere = fwhere && fwhere(_, ctx);

		if ((dwhere && _isPostEvaluated(dwhere)) ||
			(self.where && _isPostEvaluated(self.where)) ||
			(self.filter.where && _isPostEvaluated(self.filter.where))) {
			// need to build a query ------------------------------
			var nrecord = 0;
			var qry = _buildQuery(_, "for", self, key, wkey, fwhere, undefined, undefined, true, null);
			var dqry = "Delete " + self.desc.name + " Where ROWID = " + self.driver.param(0);

			// execution ---------------------------------------			
			var rdr = self.driver.reader(_, tcnx, qry[0].sql, qry[0].constants);
			var cf = new DBCursor(_, rdr, undefined, qry[0].tables, qry[0].maptrim, qry[0].pwhere, key, key.items.length);

			var row_save = self.values;

			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {

				tracer.debug && tracer.debug("DELETE:" + dqry);
				tracer.debug && tracer.debug("Constants :" + [self.values["ROWID"]]);

				var rs = self.superv.executeSql(_, dqry, [self.values["ROWID"]]);
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			self.values = row_save;
			return nrecord;

		} else {
			// classie delete
			if (self.master) throw new X3Error(26, "Table can't be a link");
			var abbrevs = [self.abbrev];
			var constants = [];

			var whereSqls = [];
			var wheres = (wkey || []).concat(self.where, self.filter.where, dwhere);

			wheres.filter(identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				constants = constants.concat(w.constants || []);
			});
			var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';

			var currtag = 0;
			var sql = ("Delete " + self.desc.name + whereSql).replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});;
			sql = sql.replace(new RegExp(self.abbrev + "\\.", "g"), "");

			tracer.debug && tracer.debug("DELETE:" + sql);
			tracer.debug && tracer.debug("Constants :" + constants);

			try {
				var result = self.superv.executeSql(_, sql, constants);
				return result.updateCount;
			} catch (e) {
				if (self.driver.isLocked(e)) return -1;
				else throw e;
			}
		}
	},

	// --------------------------------------------------------------------------------
	x3Update: function(_, fwhere, asssql, consts, tcnx) {
		var self = this;
		var ctx = {};
		ctx.tables = [self.abbrev];
		ctx.noabbrev = true;

		var dwhere = fwhere && fwhere(_, ctx);
		if ((dwhere && _isPostEvaluated(dwhere)) ||
			(self.where && _isPostEvaluated(self.where)) ||
			(self.filter.where && _isPostEvaluated(self.filter.where))) {

			// need to build a query ------------------------------
			var nrecord = 0;
			var qry = _buildQuery(_, "for", self, undefined, undefined, fwhere, undefined, undefined, true, null);

			var currtag = 0;
			var dqry = ("Update " + self.desc.name + " Set " + asssql + " Where ROWID = @?").replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});

			// execution ---------------------------------------			
			var rdr = self.driver.reader(_, tcnx, qry[0].sql, qry[0].constants);
			var cf = new DBCursor(_, rdr, undefined, qry[0].tables, qry[0].maptrim, qry[0].pwhere, undefined, 0, "for");

			var row_save = self.values;

			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {

				tracer.debug && tracer.debug("UPDATE:" + dqry);
				tracer.debug && tracer.debug("Constants :" + consts.concat([self.values["ROWID"]]));

				var rs = self.superv.executeSql(_, dqry, consts.concat([self.values["ROWID"]]));
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			self.values = row_save;
			return nrecord;

		} else {
			if (self.master) throw new X3Error(26, "Table can't be a link");
			var abbrevs = [self.abbrev];
			var constants = [];

			var whereSqls = [];
			var wheres = [].concat(self.where, self.filter.where, dwhere);

			wheres.filter(identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				constants = constants.concat(w.constants || []);
			});
			var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';

			constants = consts.concat(constants);

			var currtag = 0;
			var sql = ("Update " + self.desc.name + " Set " + asssql + whereSql).replace(/@\?/g, function(val) {
				return self.driver.param(currtag++);
			});;
			sql = sql.replace(new RegExp(self.abbrev + "\\.", "g"), "");

			tracer.debug && tracer.debug("UPDATE:" + sql);
			tracer.debug && tracer.debug("Constants :" + constants);

			try {
				var result = self.superv.executeSql(_, sql, constants);
				return result.updateCount;
			} catch (e) {
				if (self.driver.isUniqueViolated(e))
					return -3;
				else if (self.driver.isLocked(e))
					return -1;
			}
		}
	},

	x3Rowcount: function(_, tcnx) {
		var self = this;
		var master = (self.master || self);
		var loop = false;
		if ((self.where && _isPostEvaluated(self.where)) ||
			(self.filter.where && _isPostEvaluated(self.filter.where)))
			loop = true;
		if ((!loop) && self.master && (
			(self.master.where && _isPostEvaluated(self.master.where)) ||
			(self.master.filter.where && _isPostEvaluated(self.master.filter.where))))
			loop = true;

		if (loop) {
			var qry = _buildQuery(_, "for", self, undefined, undefined, undefined, undefined, undefined, false, null);

			// execution ---------------------------------------			
			var rdr;
			var ord = {};
			if (tcnx) {
				rdr = self.driver.reader(_, tcnx, qry[0].sql, qry[0].constants, ord);
			} else {
				self.driver.withConnection(_, function(_, cnx) {
					rdr = self.driver.reader(_, cnx, qry[0].sql, qry[0].constants, ord);
				});
			}
			var cf = new DBCursor(_, rdr, undefined, qry[0].tables, qry[0].maptrim, qry[0].pwhere, undefined, 0, "for");

			var row_save = self.values;

			// loop on record -----------------------------------
			var nrecord = 0;
			var rec = cf.x3GetRecord(_);
			while (rec) {
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			self.values = row_save;
			return nrecord;

		} else {
			var qry = _buildQuery(_, "rowcount", self, undefined, undefined, undefined, false);
			var result = self.superv.executeSql(_, qry[0].sql, qry[0].constants, qry[0].typesmap, true);
			return result[0]["A"].RESULT;
		}
	},

	// misc ----------------------------------------------------
	// ---------------------------------------------------------

	x3SetNewKey: function(newkey) {
		var self = this;

		if (newkey.sql) {
			self.keys.forEach(function(ky) {
				ky.hidden = true;
			});

			newkey.kslot = self.keys.push(newkey) - 1;
			self.currkey = newkey.kslot;
			self.currlen = newkey.items.length;
			delete newkey["modofied"];
		} else {
			var mk = self.findKey(newkey.name);

			self.keys.forEach(function(ky) {
				ky.hidden = true;
			});

			if (newkey.modified) {
				newkey = _transformKey(mk, newkey.modified);
				newkey.kslot = self.keys.push(newkey) - 1;
				self.currkey = newkey.kslot;
				self.currlen = newkey.items.length;
			} else {
				mk.hidden = false;
				self.currkey = mk.kslot;
				self.currlen = mk.items.length;
			}
		}
	},

	x3CloseFor: function() {
		var self = this;
		var master = (self.master || self);
		master.currentFor = undefined;
	},

	x3GetCurrentFor: function() {
		var self = this;
		var master = (self.master || self);
		return master.currentFor;
	},

	findIndex: function(name) {
		var self = this;
		var index = self.desc.index(name);
		if (!index) throw new X3Error(21, "bad index: " + name);
		return index;
	},

	findKey: function(name) {
		var self = this;
		if (name === "reckey") return _reckey;

		if (!(name)) return self.keys[self.currkey];

		var k = self.keys.filter(function(k) {
			return ((k.name === name) && (k.hidden === false));
		});
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	},

	keyCompare: function(_, k, values) {
		var self = this;
		var cmp = 0,
			lvl = 0;

		while ((cmp === 0) && (values[lvl] !== undefined)) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	},
	getKeyValues: function(_, k, lvl) {
		var res = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	},
	setCurrentLogin: function(login) {
		var self = this;
		self.defaultLogin = login;
	}
});

exports.DBTable = DBTable;