"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var array = require('./arrays');
var dates = require('./dates');
var evaluate = require('./dbevaluate');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');
var DBFor = require('./dbfor').DBFor;
var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");
var activ;

var sqlCmpOps = {
	EQ: {
		op: '=',
		combine: 'and',
	},
	NE: {
		op: '<>',
		combine: 'or'
	},
	LT: {
		op: '<',
		combine: 'lexi'
	},
	LE: {
		op: '<=',
		combine: 'lexi'
	},
	GT: {
		op: '>',
		combine: 'lexi'
	},
	GE: {
		op: '>=',
		combine: 'lexi'
	},
};

function identity(x) {
	return x;
}

function _buildQuery(_, self, key, wkey, fwhere, lock) {
	var utilDriver = require("etna-supervisor/lib/drivers/util");

	// buikld query
	var master = (self.master || self);
	var tablesSql = master.desc.name + " " + master.abbrev;
	var tables = {};
	var abbrevs = [master.abbrev];
	var constants = [];
	var ctx = {};

	// table from --------------------------
	tables[master.abbrev] = master;
	(self.joins || []).forEach(function(join) {
		abbrevs.push(join.table.abbrev);
		tables[join.table.abbrev] = join.table;
		constants = constants.concat(join.constants || []);
		tablesSql += " " + join.sql;
	});
	ctx.tables = abbrevs;

	// select ---------------------------------
	var typesmap = [0];
	var columnsSql = (self.columns ? self.columns.map(function(column) {
		column.sqlTypesMap(typesmap);;
		return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
	}) : abbrevs.reduce(function(result, abbrev) {
		var tab = tables[abbrev];
		Object.keys(tab.desc.columns).forEach(function(name) {
			var col = tab.desc.columns[name];
			col.sqlTypesMap(typesmap);
			result.push(col.sqlNames(abbrev + ".", abbrev));
		});
		return result;
	}, [])).join(', ');


	// where -----------------------------------
	var whereSqls = [],
		pwhere = [],
		wheres = [];
	if (wkey && wkey.rowid) {

		/*/ ..... */

	} else {

		wheres = [self.where, self.filter.where, wkey];
		if (self.master) {
			wheres.push(master.where);
			wheres.push(master.filter.where);
		}
		wheres.push(fwhere && fwhere(_, ctx));

		wheres.filter(identity).forEach(function(w) {
			w.sql && whereSqls.push(w.sql);
			w.func && pwhere.push(w.func);
			if (!w.tooComplex) constants = constants.concat(w.constants || []);
		});
	}

	// complete query --------------------------------
	var currtag = 0;
	var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';
	var middleSql = (tablesSql + whereSql).replace(/@\?/g, function(val) {
		return self.driver.param(currtag++);
	});
	var orderBySql = " ORDER BY " + key.sql;

	var sql = "Select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, " + columnsSql + " From " + middleSql + orderBySql;
	if (lock) sql += self.driver.lockClause(false);
	var maptrim = utilDriver.maptrim(self.driver, typesmap, true);

	return {
		sql: sql,
		maptrim: maptrim,
		tables: tables,
		pwhere: pwhere,
		constants: constants,
	};
}


// object DBTable classe
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------

var DBTable = helpers.defineClass(function(driver, abbrev, superv, desc, keys, loc) {
	var self = this;
	if (driver instanceof DBTable) {
		var tbl = driver;

		self.local = tbl.local;
		self.master = tbl;
		self.superv = tbl.superv;
		self.currkey = 0;
		self.driver = tbl.driver;
		self.reader = undefined;
		self.desc = tbl.desc;
		self.abbrev = abbrev;
		self.keys = tbl.keys;
		self.types = tbl.types;
		self.values = tbl.values;

	} else {
		self.local = loc;
		self.superv = superv;
		self.currkey = 0;
		self.driver = driver;
		self.reader = undefined;
		self.desc = desc;
		self.types = {};
		self.values = {};
		self.abbrev = abbrev;
		self.keys = keys;

	}
	return self;
}, null, {
	init: function(_) {
		var self = this;
		var table = this;
		var columns = this.desc.columns;

		Object.keys(columns).forEach_(_, function(_, colName) {
			if (columns[colName].data.DIME <= 1) {
				var etnaType = columns[colName].type.etnaType;
				table.values[colName] = variables.types[etnaType].def;
			} else if (columns[colName].data.CODACT) {
				activ = activ || require("etna-supervisor/lib/meta/activ");
				var dime = activ.getActiv(_, self.superv, columns[colName].data.CODACT);
				if (dime) columns[colName].data.DIME = dime;
				table.values[colName] = [];
			} else {
				table.values[colName] = [];
			}
			table.types[colName] = ' ' + etnaType;
		});
		return this;
	},


	x3Read: function(_, key, lvl, wkey, lock, hint, tcnx) {
		var self = this;
		if (lock && (!tcnx)) throw new X3Error(26, "Lock whitout transaction");
		/*

		// buikld query
		var master = (self.master || self);
		var tablesSql = master.desc.name + " " + master.abbrev;
		var tables = {};
		var constants = [] ;
		var abbrevs = [master.abbrev];

		// table from --------------------------
		tables[master.abbrev] = master;
		(self.joins || []).forEach(function(join) {
			abbrevs.push(join.table.abbrev);
			tables[join.table.abbrev] = join.table;
			constants = constants.concat(join.constants || []);
			tablesSql += " " + join.sql;
		});		

		// select ---------------------------------
		var typesmap = [0];
		var columnsSql = (self.columns ? self.columns.map(function(column) {
			column.sqlTypesMap(typesmap);;
			return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
		}) : abbrevs.reduce(function(result, abbrev) {
			var tab = tables[abbrev];
			Object.keys(tab.desc.columns).forEach(function(name) {
				var col = tab.desc.columns[name];
				col.sqlTypesMap(typesmap);
				result.push(col.sqlNames(abbrev + ".", abbrev));
			});
			return result;
		}, [])).join(', ');

		// where -----------------------------------
		var whereSqls = [],
			pwhere = [],
			wheres = [];
		if (wkey.rowid) {

		} else {
			wheres = [self.where, self.filter.where, wkey];
			if (self.master) {
				wheres.push(master.where);
				wheres.push(master.filter.where);
			}
		
			wheres.filter(identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				w.func && pwhere.push(w.func);
				if (!w.tooComplex) constants = constants.concat(w.constants || []);
			});
		}

		// complete query --------------------------------
		var currtag = 0;
		var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';
		var middleSql = (tablesSql + whereSql).replace(/@\?/g, function(val) {
			return self.driver.param(currtag++);
		});
		var orderBySql = " ORDER BY " + key.sql;
		
		var sql = "Select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, " + columnsSql + " From " + middleSql + orderBySql;
		if (lock) sql += driver.lockClause(false);
		var maptrim = utilDriver.maptrim(self.driver, typesmap, true);
		*/
		var qry = _buildQuery(_, self, key, wkey, undefined, lock);

		tracer.debug && tracer.debug("Read SQL " + self.abbrev + ":" + qry.sql);
		tracer.debug && tracer.debug("Constants " + self.abbrev + ":" + qry.constants);

		var rdr;
		if (tcnx) {
			rdr = self.driver.reader(_, tcnx, qry.sql, qry.constants);
		} else {
			self.driver.withConnection(_, function(_, cnx) {
				rdr = self.driver.reader(_, cnx, qry.sql, qry.constants);
			});
		}
		var cf = new DBFor(rdr, qry.tables, qry.maptrim, qry.pwhere);

		if (cf.x3GetRecord(_)) return 0;
		else return 5;
	},

	x3Write: function(_) {
		var self = this;
		var currind = 0;
		var colNames = Object.keys(self.desc.columns);
		var row = self.values;

		// Build query if necessary
		var sql = self.qinsert || (self.qinsert = "Insert into " + self.desc.name + " (" + colNames.map(function(name) {
			var col = self.desc.columns[name];
			return col.sqlNames("");
		}) + ") VALUES (" + colNames.map(function(name) {
			var s = "";
			var col = self.desc.columns[name];
			s += self.driver.param(currind++);
			for (var i = 1; i < col.data.DIME; i++) {
				s += ',';
				s += self.driver.param(currind++);
			}
			return s;
		}) + ")");


		// build values table
		var values = [];
		colNames.forEach(function(colName) {
			var val = row[colName];
			var col = self.desc.columns[colName];
			var etnaType = col.type.etnaType;

			if (col.data.DIME > 1) {
				for (var i = 0; i < col.data.DIME; i++) {
					if (val[i] !== undefined) values.push(val[i]);
					else values.push(variables.types[etnaType].def);
				}
			} else {

				if (/^(CREDATTIM|UPDDATTIM)$/.test(colName) && (val === undefined || val === null || (val.x3IsZero && val.x3IsZero()))) {
					val = tdatetime.now();
					//val.setMilliseconds(0); // bug tds ??? insertion error with milliseconds
					//val = tdate.fromJsDate(now);
				} else if (/^(CREUSR|UPDUSR)$/.test(colName) && (!val || !val.length)) {
					val = self.defaultLogin;
				} else if (val === undefined) {
					throw new X3Error(26, colName + ": bad value: " + val);
				}
				values.push(val);
			}
		});
		tracer.debug && tracer.debug("WRITE sql:" + sql);
		tracer.debug && tracer.debug("WRITE values:" + values);

		try {
			var result = self.superv.executeSql(_, sql, values);
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e))
				return 3;
			else if (self.driver.isLocked(e))
				return 1;
			else throw e;
		}
	},

	x3OpenFor: function(_, key, lvl, hint, lock, where, tcnx) {
		var self = this;

		var master = (self.master || self);
		/*		var driver = self.superv.sqlDriver;

		var utilDriver = require("etna-supervisor/lib/drivers/util");

		var ctx = {};
		var constants = [];

		// we must know tables in game
		var abbrevs = [master.abbrev];
		var tables = {};

		if (lock && (!tcnx)) throw new X3Error(26, "Lock whitout transaction");

		// From -----------------------
		var tablesSql = master.desc.name + " " + master.abbrev;
		tables[master.abbrev] = master;
		(self.joins || []).forEach(function(join) {
			abbrevs.push(join.table.abbrev);
			tables[join.table.abbrev] = join.table;
			constants = constants.concat(join.constants || []);
			tablesSql += " " + join.sql;
		});

		ctx.tables = abbrevs;

		// Where ------------------------------------
		var whereSqls = [],
			pwhere = [],
			wheres = [];

		wheres = [self.where, self.filter.where];
		if (self.master) {
			wheres.push(master.where);
			wheres.push(master.filter.where);
		}
		wheres.push(where && where(_, ctx));
		wheres.filter(identity).forEach(function(w) {
			w.sql && whereSqls.push(w.sql);
			w.func && pwhere.push(w.func);
			if (!w.tooComplex) constants = constants.concat(w.constants || []);
		});

		var currtag = 0;

		var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';
		var middleSql = (tablesSql + whereSql).replace(/@\?/g, function(val) {
			return driver.param(currtag++);
		});

		var orderBySql = " ORDER BY " + key.sql;

		// select --------------------------------------
		var typesmap = [0];
		var columnsSql = (self.columns ? self.columns.map(function(column) {
			column.sqlTypesMap(typesmap);;
			return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
		}) : abbrevs.reduce(function(result, abbrev) {
			var tab = tables[abbrev];
			Object.keys(tab.desc.columns).forEach(function(name) {
				var col = tab.desc.columns[name];
				col.sqlTypesMap(typesmap);
				result.push(col.sqlNames(abbrev + ".", abbrev));
			});
			return result;
		}, [])).join(', ');

		var maptrim = utilDriver.maptrim(driver, typesmap, true);

		// complete query ---------------------------------
		var sql = "Select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, " + columnsSql + " From " + middleSql + orderBySql;
		if (lock) sql += driver.lockClause(false);
*/


		var qry = _buildQuery(_, self, key, undefined, where, lock);

		tracer.debug && tracer.debug("FORF:" + qry.sql);
		tracer.debug && tracer.debug("Constants :" + qry.constants);

		// execution ---------------------------------------
		if (tcnx) {
			var rdr = self.driver.reader(_, tcnx, qry.sql, qry.constants);
			master.currentFor = new DBFor(rdr, qry.tables, qry.maptrim, qry.pwhere, key, lvl);
		} else {
			self.driver.withConnection(_, function(_, cnx) {
				var rdr = self.driver.reader(_, cnx, qry.sql, qry.constants);
				master.currentFor = new DBFor(rdr, qry.tables, qry.maptrim, qry.pwhere, key, lvl);
			});
		}

		return master.currentFor;
	},

	x3CloseFor: function() {
		var self = this;
		var master = (self.master || self);
		master.currentFor = undefined;
	},

	x3GetCurrentFor: function() {
		var self = this;
		var master = (self.master || self);
		return master.currentFor;
	},

	x3Delete: function(_) {
		var self = this;
	},

	x3rewrite: function(_) {
		var self = this;
	},

	// misc ----------------------------------------------------
	findIndex: function(name) {
		var self = this;
		var index = self.desc.index(name);
		if (!index) throw new X3Error(21, "bad index: " + name);
		return index;
	},

	findKey: function(name) {
		var self = this;
		if (!(name)) return self.keys[self.currkey];

		var k = self.keys.filter(function(k) {
			return ((k.name === name) && (k.hidden === false));
		});
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	},

	keyCompare: function(_, k, values) {
		var self = this;
		var cmp = 0,
			lvl = 0;

		while ((cmp === 0) && (values[lvl] !== undefined)) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	},
	getKeyValues: function(_, k, lvl) {
		var res = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	},
	setCurrentLogin: function(login) {
		var self = this;
		self.defaultLogin = login;
	}
});

exports.DBTable = DBTable;