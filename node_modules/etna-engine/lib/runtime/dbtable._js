"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var array = require('./arrays');
var dates = require('./dates');
var evaluate = require('./dbevaluate');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');
var DBFor = require('./dbfor').DBFor;
var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("etna.engine");
var activ;

var sqlCmpOps = {
	EQ: {
		op: '=',
		combine: 'and',
	},
	NE: {
		op: '<>',
		combine: 'or'
	},
	LT: {
		op: '<',
		combine: 'lexi'
	},
	LE: {
		op: '<=',
		combine: 'lexi'
	},
	GT: {
		op: '>',
		combine: 'lexi'
	},
	GE: {
		op: '>=',
		combine: 'lexi'
	},
};

function identity(x) {
	return x;
}

var DBTable = helpers.defineClass(function(driver, abbrev, superv, desc, keys, loc) {
	var self = this;
	if (driver instanceof DBTable) {
		var tbl = driver;

		self.local = tbl.local;
		self.master = tbl;
		self.superv = tbl.superv;
		self.currkey = 0;
		self.driver = tbl.driver;
		self.reader = undefined;
		self.desc = tbl.desc;
		self.abbrev = abbrev;
		self.keys = tbl.keys;
		self.types = tbl.types;
		self.values = tbl.values;

	} else {
		self.local = loc;
		self.superv = superv;
		self.currkey = 0;
		self.driver = driver;
		self.reader = undefined;
		self.desc = desc;
		self.types = {};
		self.values = {};
		self.abbrev = abbrev;
		self.keys = keys;

	}
	return self;
}, null, {
	init: function(_) {
		var self = this;
		var table = this;
		var columns = this.desc.columns;

		Object.keys(columns).forEach_(_, function(_, colName) {
			if (columns[colName].data.DIME <= 1) {
				var etnaType = columns[colName].type.etnaType;
				table.values[colName] = variables.types[etnaType].def;
			} else if (columns[colName].data.CODACT) {
				activ = activ || require("etna-supervisor/lib/meta/activ");
				var dime = activ.getActiv(_, self.superv, columns[colName].data.CODACT);
				if (dime) columns[colName].data.DIME = dime;
				table.values[colName] = [];
			} else {
				table.values[colName] = [];
			}
			table.types[colName] = ' ' + etnaType;
		});
		return this;
	},
	x3Read: function(_, key, op, vals) {
		var self = this;

		var keyExps = key.items;
		var cmpOp = sqlCmpOps[op || 'EQ'];
		var where = '(' + keyExps[0] + cmpOp.op + self.driver.param(0) + ')';
		var lexi = '(' + keyExps[0] + '=' + self.driver.param(1) + ')';

		for (var i = 1; i < vals.length; i++) {
			var clause = keyExps[i] + cmpOp.op + self.driver.param(i);
			if (cmpOp.combine === 'lexi') {
				where = where + ' or (' + lexi + ' and (' + clause + '))';
				lexi = '(' + lexi + ' and (' + keyExps[i] + '=' + self.driver.param(i) + ')';
			} else {
				where = where + ' ' + cmpOp.combine + ' (' + clause + ')';
			}
		}

		var typesmap = [0];
		var sql = "select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, " + Object.keys(self.desc.columns).map_(_, function(_, name) {
			var column = self.desc.columns[name];
			column.sqlTypesMap(typesmap);
			return column.sqlNames(self.abbrev + ".", self.abbrev);
		}).join(',') + " from " + self.desc.name + " " + self.abbrev + " where " + where;

		tracer.debug && tracer.debug("Read SQL " + self.abbrev + ":" + sql);
		tracer.debug && tracer.debug("Constants " + self.abbrev + ":" + vals);
		var row = self.superv.executeSql(_, sql, vals, typesmap, true)[0];
		tracer.debug && tracer.debug(row);

		if (row && row[self.abbrev]) {
			self.values = row[self.abbrev];
			return 0;
		} else {
			return 5;
		}
	},

	x3Write: function(_) {
		var self = this;
		var currind = 0;
		var colNames = Object.keys(self.desc.columns);
		var row = self.values;

		// Build query if necessary
		var sql = self.qinsert || (self.qinsert = "Insert into " + self.desc.name + " (" + colNames.map(function(name) {
			var col = self.desc.columns[name];
			return col.sqlNames("");
		}) + ") VALUES (" + colNames.map(function(name) {
			var s = "";
			var col = self.desc.columns[name];
			s += self.driver.param(currind++);
			for (var i = 1; i < col.data.DIME; i++) {
				s += ',';
				s += self.driver.param(currind++);
			}
			return s;
		}) + ")");


		// build values table
		var values = [];
		colNames.forEach(function(colName) {
			var val = row[colName];
			var col = self.desc.columns[colName];
			var etnaType = col.type.etnaType;

			if (col.data.DIME > 1) {
				for (var i = 0; i < col.data.DIME; i++) {
					if (val[i] !== undefined) values.push(val[i]);
					else values.push(variables.types[etnaType].def);
				}
			} else {

				if (/^(CREDATTIM|UPDDATTIM)$/.test(colName) && (val === undefined || val === null || (val.x3IsZero && val.x3IsZero()))) {
					val = tdatetime.now();
					//val.setMilliseconds(0); // bug tds ??? insertion error with milliseconds
					//val = tdate.fromJsDate(now);
				} else if (/^(CREUSR|UPDUSR)$/.test(colName) && (!val || !val.length)) {
					val = self.defaultLogin;
				} else if (val === undefined) {
					throw new X3Error(26, colName + ": bad value: " + val);
				}
				values.push(val);
			}
		});
		tracer.debug && tracer.debug("WRITE sql:" + sql);
		tracer.debug && tracer.debug("WRITE values:" + values);

		try {
			var result = self.superv.executeSql(_, sql, values);
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e))
				return 3;
			else if (self.driver.isLocked(e))
				return 1;
			else throw e;
		}
	},

	x3OpenFor: function(_, key, lvl, where) {
		var self = this;

		var master = (self.master || self);
		var driver = self.superv.sqlDriver;

		var utilDriver = require("etna-supervisor/lib/drivers/util");

		var ctx = {};
		var constants = [];

		// we must know tables in game
		var abbrevs = [master.abbrev];
		var tables = {};

		var tablesSql = master.desc.name + " " + master.abbrev;
		tables[master.abbrev] = master;
		(self.joins || []).forEach(function(join) {
			abbrevs.push(join.table.abbrev);
			tables[join.table.abbrev] = join.table;
			constants = constants.concat(join.constants || []);
			tablesSql += " " + join.sql;
		});

		ctx.tables = abbrevs;

		// generate WHERE clause
		var whereSqls = [],
			pwhere = [],
			wheres = [];

		wheres = [self.where, self.filter.where];
		if (self.master) {
			wheres.push(master.where);
			wheres.push(master.filter.where);
		}
		wheres.push(where && where(_, ctx));
		wheres.filter(identity).forEach(function(w) {
			w.sql && whereSqls.push(w.sql);
			w.func && pwhere.push(w.func);
			if (!w.tooComplex) constants = constants.concat(w.constants || []);
		});

		var currtag = 0;

		var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';
		var middleSql = (tablesSql + whereSql).replace(/@\?/g, function(val) {
			return driver.param(currtag++);
		});

		var orderBySql = " ORDER BY " + key.sql;

		var typesmap = [0];
		var columnsSql = (self.columns ? self.columns.map(function(column) {
			column.sqlTypesMap(typesmap);;
			return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
		}) : abbrevs.reduce(function(result, abbrev) {
			var tab = tables[abbrev];
			Object.keys(tab.desc.columns).forEach(function(name) {
				var col = tab.desc.columns[name];
				col.sqlTypesMap(typesmap);
				result.push(col.sqlNames(abbrev + ".", abbrev));
			});
			return result;
		}, [])).join(', ');

		var maptrim = utilDriver.maptrim(driver, typesmap, true);

		var sql = "Select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, " + columnsSql + " From " + middleSql + orderBySql;
		tracer.debug && tracer.debug("FORF:" + sql);
		/*whereExps.length > 0 && console.log(whereExps.length + " WHERE clause(s) not translated to SQL.");*/
		tracer.debug && tracer.debug("Constants :" + constants);

		driver.withConnection(_, function(_, cnx) {
			var rdr = driver.reader(_, cnx, sql, constants);
			master.currentFor = new DBFor(rdr, tables, maptrim, pwhere, key, lvl);
		});


		return master.currentFor;
	},

	x3CloseFor: function() {
		var self = this;
		var master = (self.master || self);
		master.currentFor = undefined;
	},

	x3GetCurrentFor: function() {
		var self = this;
		var master = (self.master || self);
		return master.currentFor;
	},

	x3Delete: function(_) {
		var self = this;
	},

	x3rewrite: function(_) {
		var self = this;
	},

	// misc ----------------------------------------------------
	findIndex: function(name) {
		var self = this;
		var index = self.desc.index(name);
		if (!index) throw new X3Error(21, "bad index: " + name);
		return index;
	},

	findKey: function(name) {
		var self = this;
		if (!(name)) return self.keys[self.currkey];

		var k = self.keys.filter(function(k) {
			return ((k.name === name) && (k.hidden === false));
		});
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	},

	keyCompare: function(_, k, values) {
		var self = this;
		var cmp = 0,
			lvl = 0;

		while ((cmp === 0) && (values[lvl] !== undefined)) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	},
	getKeyValues: function(_, k, lvl) {
		var res = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	},
	setCurrentLogin: function(login) {
		var self = this;
		self.defaultLogin = login;
	}
});

exports.DBTable = DBTable;