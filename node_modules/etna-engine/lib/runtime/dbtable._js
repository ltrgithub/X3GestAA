"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var array = require('./arrays');
var dates = require('./dates');
var evaluate = require('./dbevaluate');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var glob = require('streamline/lib/globals');
var helpers = require('syracuse-core/lib/helpers');

var sqlCmpOps = {
	EQ: {
		op: '=',
		combine: 'and',
	},
	NE: {
		op: '<>',
		combine: 'or'
	},
	LT: {
		op: '<',
		combine: 'lexi'
	},
	LE: {
		op: '<=',
		combine: 'lexi'
	},
	GT: {
		op: '>',
		combine: 'lexi'
	},
	GE: {
		op: '>=',
		combine: 'lexi'
	},
};


function allocateSlots(table, columns) {
	Object.keys(columns).forEach(function(colName) {
		var etnaType = columns[colName].type.etnaType;
		if (columns[colName].data.DIME <= 1)
			table.values[colName] = variables.types[etnaType].def;
		else {
			table.values[colName] = [];
			//table.values[colName][0] = variables.types[etnaType].def;
		}
		table.types[colName] = ' ' + etnaType;
	});
}

var DBTable = helpers.defineClass(function(driver, abbrev, superv, desc, keys) {
	var self = this;
	if (driver instanceof DBTable) {
		var tbl = driver;

		self.master = tbl;
		self.superv = tbl.superv;
		self.currkey = 0;
		self.driver = tbl.driver;
		self.reader = undefined;
		self.desc = tbl.desc;
		self.abbrev = abbrev;
		self.keys = tbl.keys;

	} else {
		self.superv = superv;
		self.currkey = 0;
		self.driver = driver;
		self.reader = undefined;
		self.desc = desc;
		self.types = {};
		self.values = {};
		self.abbrev = abbrev;
		self.keys = keys;


		allocateSlots(this, desc.columns);
	}
	return self;
}, null, {

	x3Read: function(_, index, op, vals) {
		var self = this;

		var indexExps = index.sqlNames(_);
		var cmpOp = sqlCmpOps[op || 'EQ'];
		var where = '(' + self.abbrev + '.' + indexExps[0] + cmpOp.op + self.driver.param(0) + ')';
		var lexi = '(' + indexExps[0] + '=:1)';;

		for (var i = 1; i < vals.length; i++) {
			var clause = self.abbrev + '.' + indexExps[i] + cmpOp.op + self.driver.param(i);
			if (cmpOp.combine === 'lexi') {
				where = where + ' or (' + lexi + ' and (' + clause + '))';
				lexi = '(' + lexi + ' and (' + self.abbrev + '.' + indexExps[i] + '=' + driver.param(i) + ')';
			} else {
				where = where + ' ' + cmpOp.combine + ' (' + clause + ')';
			}
		}

		var typesmap = [0];
		var sql = "select " + self.abbrev + ".ROWID As " + self.abbrev + "$ROWID, " + Object.keys(self.desc.columns).map_(_, function(_, name) {
			var column = self.desc.columns[name];
			column.sqlTypesMap(typesmap);
			return column.sqlNames(self.abbrev + ".", self.abbrev);
		}).join(',') + " from " + self.desc.name + " " + self.abbrev + " where " + where;

		console.log("Read SQL " + self.abbrev + ":" + sql);
		var row = self.superv.executeSql(_, sql, vals, typesmap, true)[0];
		console.log(row);

		if (row && row[self.abbrev]) {
			self.values = row[self.abbrev];
			return 0;
		} else {
			return 5;
		}
	},

	x3Write: function(_) {
		var self = this;
		var currind = 0;
		var colNames = Object.keys(self.desc.columns);
		var row = self.values;

		// Build query if necessary
		var sql = self.qinsert || (self.qinsert = "Insert into " + self.desc.name + " (" + colNames.map(function(name) {
			var col = self.desc.columns[name];
			return col.sqlNames("");
		}) + ") VALUES (" + colNames.map(function(name) {
			var s = "";
			var col = self.desc.columns[name];
			s += self.driver.param(currind++);
			for (var i = 1; i < col.data.DIME; i++) {
				s += ',';
				s += self.driver.param(currind++);
			}
			return s;
		}) + ")");


		// build values table
		var values = [];
		colNames.forEach(function(colName) {
			var val = row[colName];
			var col = self.desc.columns[colName];
			var etnaType = col.type.etnaType;

			if (col.data.DIME > 1) {
				for (var i = 0; i < col.data.DIME; i++) {
					if (val[i] !== undefined) values.push(val[i]);
					else values.push(variables.types[etnaType].def);
				}
			} else {

				if (/^(CREDATTIM|UPDDATTIM)$/.test(colName) && (val === undefined || val === null || (val.x3IsZero && val.x3IsZero()))) {
					val = tdatetime.now();
					//val.setMilliseconds(0); // bug tds ??? insertion error with milliseconds
					//val = tdate.fromJsDate(now);
				} else if (/^(CREUSR|UPDUSR)$/.test(colName) && (!val || !val.length)) {
					val = self.defaultLogin;
				} else if (val === undefined) {
					throw new X3Error(26, colName + ": bad value: " + val);
				}
				values.push(val);
			}
		});
		console.log("WRITE sql:" + sql);
		console.log("WRITE values:" + values);

		try {
			var result = self.superv.executeSql(_, sql, values);
			return 0;
		} catch (e) {
			if (self.driver.isUniqueViolated(e))
				return 3;
			else if (self.driver.isLocked(e))
				return 1;
			else throw e;
		}
	},

	x3OpenFor: function(_, key, where) {
		var self = this;

		var k = key(_);

		var master = (self.master || self);
		var driver = self.driver;

		var utilDriver = require("etna-supervisor/lib/drivers/util");
		if (!table) throw new X3Error(7, "class not found: " + k.abbrev);

		//var view = findView(frame, k.abbrev);
		var ctx = {};
		var constants = [];

		// we must know tables in game
		var abbrevs = [master.abbrev];
		var tablesSql = master.desc.name + " " + master.abbrev;
		(table.joins || []).forEach(function(join) {
			abbrevs.push(join.table.abbrev);
			constants = constants.concat(join.constants || []);
			tablesSql += (', ' + join.sql);
		});
		ctx.tables = abbrevs;

		// generate WHERE clause
		var whereSqls = [],
			pwhere = [],
			wheres = [];

		wheres = [table.where, table.filter.where];
		if (self.master) {
			wheres.push(master.where);
			wheres.push(master.filter.where);
		}
		wheres.push(where && where(_, ctx));
		wheres.filter(identity).forEach(function(w) {
			w.sql && whereSqls.push(w.sql);
			w.func && pwhere.push(w.func);
			if (!w.tooComplex) constants = constants.concat(w.constants || []);
		});

		var currtag = 0;

		var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';
		var middleSql = (tablesSql + whereSql).replace(/@\?/g, function(val) {
			return driver.param(currtag++);
		});

		var cky = 0;
		if (!k.name) cky = table.currkey;
		var thekey = table.keys[cky];
		var orderBySql = " ORDER BY " + thekey.sql;

		var typesmap = [0];
		var columnsSql = (table.columns ? table.columns.map(function(column) {
			column.sqlTypesMap(typesmap);;
			return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
		}) : abbrevs.reduce(function(result, abbrev) {
			var tab = findTable(frame, abbrev);
			Object.keys(tab.desc.columns).forEach(function(name) {
				var col = tab.desc.columns[name];
				col.sqlTypesMap(typesmap);
				result.push(col.sqlNames(abbrev + ".", abbrev));
			});
			return result;
		}, [])).join(', ');

		var maptrim = utilDriver.maptrim(driver, typesmap, true);
		var sql = "Select " + table.abbrev + ".ROWID As " + table.abbrev + "$ROWID, " + columnsSql + " From " + middleSql + orderBySql;
		console.log("FORF:" + sql);

		/*whereExps.length > 0 && console.log(whereExps.length + " WHERE clause(s) not translated to SQL.");*/
		console.log("Constants :" + constants);

		var rdr;
		driver.withConnection(_, function(_, cnx) {
			rdr = driver.reader(_, cnx, sql, constants);
		});
		var cf = {
			key: k,
			pwhere: pwhere,
			reader: rdr,
			maptrim: maptrim
		};
		if (self.master) self.master.currentFor = cf;
		else self.currentFor = cf;
		return cf;
	},

	x3GetRecord: function(_) {
		var cf = (self.master) ? self.master.currentFor : self.currentFor;
		var maptrim = cf.maptrim;
		var pwhere = cf.pwhere;
		var wok = 1;

		rec = cf.reader.read(_, 1);
		while (rec) {
			var row = maptrim(rec);
			Object.keys(row).forEach(function(abv) {
				if ((self.joins && self.joins[abv])) self.joins[abv].table.values = row[abv];
				else self.values = row[abv];
			});

			// post evaluations have to be ok
			for (var i = 0; i < pwhere.length; i++) {
				var w = pwhere[i](_);
				var r = w.reduce(function(r, c) {
					return r & c;
				}, 1);
				wok = wok & r;
			}
			if (!wok) rec = cf.reader.read(_, 1);
			else break;
		}
		return rec;
	},

	x3Delete: function(_) {
		var self = this;
	},

	x3rewrite: function(_) {
		var self = this;
	},

	// misc ----------------------------------------------------
	findIndex: function(name) {
		var self = this;
		var index = self.desc.index(name);
		if (!index) throw new X3Error(21, "bad index: " + name);
		return index;
	},

	findKey: function(name) {
		var self = this;
		var k = self.keys.find(function(k) {
			return k.name === "name";
		});
		if (!k) throw new X3Error(21, "bad key: " + name);
		return k;
	},

	keyCompare: function(_, name, values) {
		var self = this;
		var k = self.findKey(name);
		var cmp = 0,
			lvl = 0;

		while ((cmp === 0) && (values[lvl])) {
			cmp = value[idx].x3Compare(k.func(_)) * k.dir[lvl];
			lvl++;
		}
		return k;
	},

	setCurrentLogin: function(login) {
		var self = this;
		self.defaultLogin = login;
	}
});

exports.DBTable = DBTable;