"use strict";
var X3Error = require('./errors').X3Error;

var SIGN = 0; // 0 if negative, 1 if positive
var LEN = 1; // number of elements in mantissa
var POW100 = 2; // number of digit pairs (100s) in scale offset by 64.
var BASE = 3; // base index of mantissa
var MAX00 = 16;
var SIZE = BASE + MAX00;

var MAXDBL = 1e80;
var MINDBL = 1e-79;
var SPREC = 6;
var DPREC = 10;
var FLOATPREC = 1000000000.0;
var EPSILON = 0.0000000001;

var MAXESG4 = 0x7fffffff;
var MINESG4 = 0x80000000;

//var TypedArray = Uint8Array;
var TypedArray = Buffer;

function alloc(size) {
	var arr = new TypedArray(size);
	for (var i = 0; i < size; i++) arr[i] = 0xfe;
	return arr;
}

function getSign(bcd) {
	if (bcd[LEN] == 0) return 0;

	return (bcd[SIGN] == 0) ? -1 : 1;
}

function toggleSign(bcd) {
	if (bcd[LEN] != 0) bcd[SIGN] ^= 1;
}

// can bcd be coerced to int32 without loss
function isInt32(bcd, opt) {
	//	Test Overflow
	if (bcd[POW100] > 64 + 5) return false;
	if (bcd[POW100] == 64 + 5) {
		if (compare(bcd, BCD_MAX_INT32) > 0) return false;
		if (compare(bcd, BCD_MIN_INT32) < 0) return false;
	}

	//	Is it integer?
	return opt == 0 || bcd[POW100] - 64 >= bcd[LEN] || bcd[LEN] == 0;
}

function isSpace(s) {
	return /^\s$/.test(s);
}

function isDigit(s) {
	return /^\d$/.test(s);
}

var ASCII_0 = '0'.charCodeAt(0);

function fillMantissa(digits, mantissa, odd) {
	var i = 0, j = 0;
	var dgt = 0;

	while (i < digits.length || dgt !== 0) {
		if (i < digits.length) dgt += digits.charCodeAt(i++) - ASCII_0;
		if ((odd & 1) != 0) { mantissa[j++] = dgt;
			dgt = 0;
		} else dgt *= 10;
		odd++;
	}
	return odd / 2;
}

function mantissaString(mantissa, cnt) {
	var str = '';
	for (var i = 0; i < cnt; i++) {
		var d = mantissa[i];
		str += d < 10 ? '0' + d : d;
	}
	return str;
}

function memcopy(src, i, dst, j, len) {
	while (len-- > 0) dst[j++] = src[i++];
}

function memcompare(s1, i1, s2, i2, len) {
	var diff = 0;
	while (count-- > 0 && diff === 0)
		diff = s1[i1++] - s2[i2++];
	return diff;
}

function make(sign, pow100, mantissa, len) {
	//	Virer les 0 de Trop
	var i = len;
	while (len > 0 && mantissa[--i] === 0) --len;
	var beg = 0;
	while (len > 0 && mantissa[beg] === 0) --pow100, --len, ++beg;

	if (len > MAX00) {
		i = beg + MAX00;
		if (mantissa[i] >= 50) {
			// Round up
			while (++mantissa[--i] >= 100 && i >= beg) mantissa[i] = 0;
		}
		if (i < beg) ++pow100, mantissa[beg] = 1; // ??
		len = MAX00;
	}

	//	Test Overflow Numerique
	if (pow100 > 63 && len > 0) throw new X3Error(13, "");

	if (len === 0 || pow100 < -64) pow100 = 0, sign = 1, len = 0; //	 Zero

	var bcd = alloc(SIZE);
	bcd[SIGN] = sign;
	bcd[LEN] = len;
	bcd[POW100] = pow100 + 64;
	if (len > 0) memcopy(mantissa, beg, bcd, BASE, len);
	//while (len++ < 16) bcd[BASE + len] = 0;

	return bcd;
}


// Transforme une Chaine en bcd
//int fromString(s_bcd bcd[], char str[]) //	Chaine a Analyser

var fromString = exports.fromString = function(str) {
	var i = 0, beg;
	var sign = '+';

	// skip leading spaces
	while (isSpace(str[i])) i++;
	beg = i;

	// handle sign
	if (str[i] === '-' || str[i] === '+') sign = str[i++];

	// mantissa
	var buf = '', gotDot = false, pow10 = 0;
	for (; isDigit(str[i]) || str[i] === '.'; i++) {
		if (str[i] === '.') {
			if (gotDot) break;
			gotDot = true;
			continue;
		}

		//	zeros after dot matter
		if (str[i] === '0' && buf.length === 0) {
			if (gotDot) --pow10;
			continue;
		}

		//	store the digit
		if (buf.length < 2 * MAX00) buf += str[i];

		//	increment pow10
		if (!gotDot) ++pow10;

	}

	// optional exponent
	if (i != beg && (str[i] == 'e' || str[i] == 'E')) {
		++i;
		pow10 += parseInt(str.substring(i), 10);
	}

	// empty string
	if (i == beg) return BCD_ZERO;

	var mantissa = alloc(16);
	var len = fillMantissa(buf, mantissa, (pow10 & 1));

	return make(sign !== '-', ((pow10 + 1) & ~1) / 2, mantissa, len);
}

var fromDouble = exports.fromDouble = function(bcd, dbl) {
	return fromString("" + dbl);
}

function clone(bcd) {
	var cl = alloc(SIZE);
	memcopy(bcd, 0, cl, 0, SIZE);
	return cl;
}

var truncate = exports.truncate = function(bcd, scale) {
	scale = scale || 0;
	var len = Math.floor((scale + 1) / 2) + (bcd[POW100] - 64);
	if (len > bcd[LEN]) return bcd;
	bcd = clone(bcd);
	if (len > 0 && (scale & 1) !== 0) bcd[BASE + len - 1] = Math.floor(bcd[BASE + len - 1] / 10) * 10;

	// remove trailing zeros
	while (len > 0 && bcd[BASE + len - 1] === 0) len--;

	if (len <= 0) {
		bcd[POW100] = 64;
		bcd[LEN] = 0;
	}
	else bcd[LEN] = len;
	return bcd;
}

//		Comparaison de 2 bcd
// int compare(s_bcd dc1[], s_bcd dc2[])

var compare = exports.compare = function(dc1, dc2) {
	var res = 0;
	if (dc2[LEN] == 0) res = (dc1[LEN] == 0) ? 0 : 1;
	else if (dc1[SIGN] != dc2[SIGN]) res = 1;
	else if (dc1[LEN] == 0) res = -1;
	else if (dc1[POW100] < dc2[POW100]) res = -1;
	else if (dc1[POW100] > dc2[POW100]) res = 1;
	else {
		var st = dc1[LEN] - dc2[LEN];
		res = memcompare(dc1, BASE, dc2, BASE, st < 0 ? dc1[LEN] : dc2[LEN]);
		if (res === 0 && st !== 0) res = st > 0 ? 1 : -1;
	}
	return dc1[SIGN] ? res : -res;
}

var toString = exports.toString = function(bcd) {
	console.log(bcd);
	if (bcd[LEN] === 0) return '0';

	var s = bcd[SIGN] ? '' : '-';
	var len = bcd[LEN],
	pow100 = bcd[POW100] - 64;

	if (pow100 > 0) {
		s += bcd[BASE];
		for (var i = 1; i < pow100; i++) {
			if (i < len) {
				var v = bcd[BASE + i];
				s += v < 10 ? '0' + v : v;
			} else {
				s += "00";
			}
		}
	} else {
		s += '0';
	}
	if (pow100 >= len) return s;
	s += '.';
	while (pow100 < 0) {
		s += '00';
		pow100++;
	}
	for (var i = pow100; i < len - 1; i++) {
		var v = bcd[BASE + i];
		s += v < 10 ? '0' + v : v;
	}
	var v = bcd[BASE + len - 1];
	s += v % 10 === 0 ? v / 10 : v < 10 ? '0' + v : v;

	return s;
}

/*
// Conversion au Format Exponentiel
//static int bcdexp(s_bcd bcd[], char buf[], int len, int dpt, int sgn)

function bcdexp(bcd, buf, len, dpt, sgn) {
	char tmp[MAXSTR + 1];
	char * ptr;
	char * pts;
	char * ptt;
	int siz;
	int st;

	//	Espace Specifique a la Notation
	siz = sgn + 4;
	if (--dpt < 0) siz++;
	if ((dpt < -99) || (dpt > 99)) siz++;
	if (siz >= len) return err_adx(ERDOM, "");

	//	Conversion
	st = bcdcvt(tmp, bcd, len - siz, & dpt, & sgn);
	if (st < 0) return st;

	//	Effacer les Zero de Fin
	ptt = tmp + st;
	pts = ptt + (len - siz - 1);
	while ((pts > ptt) && ( * pts == '0')) * pts-- = 0;

	pts = ptt;
	ptr = buf;
	dpt--;
	if (sgn != 0) * ptr++ = '-'; * ptr++ = * pts++;
	if ( * pts != 0) * ptr++ = '.';
	while ( * pts != 0) * ptr++ = * pts++; * ptr++ = 'e';
	if (dpt < 0) { * ptr++ = '-';
		dpt = -dpt;
	}
	if (dpt >= 100) { * ptr++ = dpt / 100 + '0';
		dpt %= 100;
	}
	//	2 Chiffres au Minimum
	* ptr++ = dpt / 10 + '0'; * ptr++ = dpt % 10 + '0';

	* ptr = 0;

	return 0;
}

// Convertit un bcd en Long
//int bcdlng(s_bcd bcd[], int32 lnp[])

function bcdlng(bcd, lnp) {
	int i;
	int32 l;

	//	Differents Test d'Overflow
	if (isInt32(bcd, 0) == 0) return err_adx(ERDOM, "bcdlng");

	for (l = 0l, i = 0; i < bcd[POW100] - 64; i++) {
		l *= 100;
		if (i < bcd[LEN]) l += bcd->bcd_mn[i];
	}

	lnp[0] = (bcd[SIGN] != 0) ? l : -l;

	return 0;
}
*/

function fromInt32(bcd, val) {
	var sign = 1;

	if (val < 0) {
		val = -val;
		sign = 0;
	}

	var dgt = alloc(6);
	dgt[5] = 0
	for (var i = 4; i >= 0; --i) 
	{
		dgt[i] = val % 100;
		val = Math.floor(val / 100);
	}

	return make(sign, 5, dgt, 5);
}
/*
// Conversion d'un bcd en Double
//int bcddbl(double dbp[], s_bcd bcd[])

function bcddbl(dbp, bcd) {
	char buf[MAXSTR + 1];
	int st;

	//	On Passe par une Chaine de Caracteres
	st = toString(bcd, buf, 40);
	if (st < 0) return st;

	//	Et on Utilise strtod
	dbp[0] = strtod(buf, (char * * ) 0);
	if ((numersys == ERANGE) && ((dbp[0] == HUGE_VAL) || (dbp[0] == -HUGE_VAL))) return err_adx(ERHUGE, "");

	return 0;
}

// Addition/Soustraction de 2 bcd
//int bcd_as(s_bcd drs[], s_bcd dc1[], s_bcd dc2[], int sop)			//	Type d'Operation

function bcd_as(drs, dc1, dc2, sop) {
	int sg1;
	int sg2;
	int sgn; //	Signe du Resultat
	int cmp;
	int st;
	s_bcd * dcg; //	Gros bcd
	s_bcd * dcp; //	Petit bcd
	//	Sauvegarde du Signe
	sg1 = dc1[SIGN];
	sg2 = dc2[SIGN];

	//	Comparaison des Valeurs Absolus
	dc1[SIGN] = dc2[SIGN] = 1;
	cmp = compare(dc1, dc2);

	dc1[SIGN] = sg1;
	dc2[SIGN] = sg2;
	sg2 ^= sop;

	if (cmp < 0) sgn = sg2, dcp = dc1, dcg = dc2;
	else sgn = sg1, dcp = dc2, dcg = dc1;

	if (sg1 != sg2) st = bcdiss(drs, sgn, dcg, dcp);
	else st = bcdiad(drs, sgn, dcg, dcp);

	return st;
}

// Fonction Interne d' Addition
// dc1 et dc2 sont de meme signe, abs(dc1) > abs(dc2)
//static int bcdiad(s_bcd drs[], int sgn, s_bcd dc1[], s_bcd dc2[])

function bcdiad(drs, sgn, dc1, dc2) {
	char * mrp;
	char * msp;
	int dgt;
	int carry;
	int i;
	int dif;
	int lmn;
	int st;
	char sum[MAX00 + 2]; //	Overflow and guard
	//	Decalage Mantisse du Petit
	dif = dc1[POW100] - dc2[POW100];
	lmn = dif + dc2[LEN];
	if (lmn < dc1[LEN]) lmn = dc1[LEN];
	if (lmn > MAX00 + 1) lmn = MAX00 + 1;
	lmn++; //	Pour la Retenue Eventuelle
	clearmem(sum, lmn);
	memcpy(sum + 1, dc1->bcd_mn, dc1[LEN]);

	//	Recalcul de la Partie de dc2 interressante
	//	   (si dc2_lm > MAX00, lmn-dif < dc2_lm)
	//	Il Faudrait Arrondir dans ce Cas la
	i = lmn - dif - 1;
	if (i > dc2[LEN]) i = dc2[LEN];

	mrp = sum + (i + dif);
	msp = dc2->bcd_mn + i - 1;
	carry = 0;

	while (msp >= dc2->bcd_mn) {
		dgt = * mrp + * msp + carry;
		carry = 0;
		if (dgt >= 100)++carry, dgt -= 100;

		* mrp-- = dgt;
		msp--;

	}

	if (carry) {
		while (++( * mrp) >= 100) * mrp-- = 0;
	}

	st = make(drs, sgn, dc1[POW100] - 64 + 1, sum, lmn);

	return st;
}

// Fonction Interne de Soustraction
// dc1 et dc2 sont de meme signe, abs(dc1) > abs(dc2)
//static int bcdiss(s_bcd drs[], int sgn, s_bcd dc1[], s_bcd dc2[])

function bcdiss(drs, sgn, dc1, dc2) {
	char * mrp;
	char * msp;
	int dgt;
	int carry;
	int i;
	int dif;
	int lmn;
	int st;
	char sum[MAX00 + 2]; //	Overflow and guard
	//	Decalage Mantisse du Petit
	dif = dc1[POW100] - dc2[POW100];
	lmn = dif + dc2[LEN];
	if (lmn < dc1[LEN]) lmn = dc1[LEN];
	if (lmn > MAX00 + 1) lmn = MAX00 + 1;

	clearmem(sum, lmn);
	memcpy(sum, dc1->bcd_mn, dc1[LEN]);

	//	Recalcul de la Partie de dc2 interressante
	//	   (si dc2_lm > MAX00, lmn-dif < dc2_lm)
	//	Il Faudrait Arrondir dans ce Cas la
	i = lmn - dif;
	if (i > dc2[LEN]) i = dc2[LEN];

	mrp = sum + (i + dif - 1);
	msp = dc2->bcd_mn + i - 1;
	carry = 0;

	while (msp >= dc2->bcd_mn) {
		dgt = * mrp - * msp + carry;
		if (dgt < 0) carry = -1, dgt += 100;
		else carry = 0;

		* mrp-- = dgt;
		msp--;

	}

	if (carry != 0) {
		while (( * mrp)-- == 0) * mrp-- = 99;
	}

	st = make(drs, sgn, dc1[POW100] - 64, sum, lmn);

	return st;
}

//		Multiplication de 2 bcd
//int bcdmul(s_bcd prd[], s_bcd dc1[], s_bcd dc2[])


function bcdmul(prd, dc1, dc2) {
	char * pt;
	int dgt;
	int i;
	int j;
	int len;
	int st;
	char prod[MAX00 + MAX00];

	tblraz(prod);
	len = dc1[LEN] + dc2[LEN]; //	Longueur Maximum
	for (i = dc1[LEN] - 1; i >= 0; i--) {
		for (j = dc2[LEN] - 1; j >= 0; j--) {
			dgt = (int) dc1->bcd_mn[i] * (int) dc2->bcd_mn[j];
			for (pt = prod + i + j + 1;
			(dgt != 0); pt--) {
				dgt += * pt; * pt = dgt % 100;
				dgt /= 100; //	Stocker la Retenue dans dgt
			}
		}
	}

	st = make(prd, (dc1[SIGN] == dc2[SIGN]) ? 1 : 0, dc1[POW100] - 64 + dc2[POW100] - 64, prod, len);

	return st;
}

// Divise ddd par dds. dqt renvoie le Quotient
//int bcddiv(s_bcd dqt[], s_bcd ddd[], s_bcd dds[])


function bcddiv(dqt, ddd, dds) {
	int dgt;
	int i;
	int j;
	int st;
	int divor;
	int qdg;
	int32 ldd;
	char * pdd; //	Pointeur Dividende
	char mdd[MAX00 + MAX00 + 2]; //	Dividende
	char mqt[MAX00 + 2]; //	Quotient + Garde
	char mds[MAX00 + 2];

	//	Division par 0 ?
	if (dds[LEN] == 0) return err_adx(ERDIVZ, "");

	//	Laisser un Digit Vide en Tete
	tblraz(mdd);
	tblraz(mds);
	memcpy(mdd + 1, ddd->bcd_mn, ddd[LEN]);
	memcpy(mds + 1, dds->bcd_mn, dds[LEN]);

	//	Prendre 2 Digits pour le Diviseur de maniere a
	//	limiter l'erreur possible sur le Quotient a 1
	divor = ((int) dds->bcd_mn[0]) * 100;
	if (dds[LEN] > 1) divor += dds->bcd_mn[1];

	for (i = 0; i < MAX00 + 2; i++) {
		//	  3 Digits du Dividende sont necessaires
		//	et suffisant pour l'estimation du Quotient
		ldd = mdd[i] * 100 + mdd[i + 1];
		ldd = ldd * 100 + mdd[i + 2];
		qdg = ldd / divor;
		mqt[i] = qdg;
		if (qdg == 0) continue;

		//	Retirer du Dividende le Produit Diviseur*Quotient 
		dgt = 0;
		pdd = mdd + i + dds[LEN];
		for (j = dds[LEN]; j >= 0; j--, pdd--) {
			dgt += (10000 + * pdd) - (qdg * (int) mds[j]); * pdd = dgt % 100;
			dgt /= 100; //	Prop Retenue negat
			dgt -= 100;
		}

		//	dgt n'etait-il pas trop gros
		if (dgt < 0) {
			//	Rajouter le Diviseur
			--mqt[i];
			dgt = 0;
			pdd = mdd + i + dds[LEN];
			for (j = dds[LEN]; j >= 0; j--, pdd--) {
				dgt += * pdd + mds[j]; * pdd = dgt % 100;
				dgt /= 100;
			}
		}
	}

	st = make(dqt, (ddd[SIGN] == dds[SIGN]) ? 1 : 0, ddd[POW100] - dds[POW100] + 1, mqt, i);

	return st;
}

//		Emule ecvt/fcvt selon la valeur de flg (0/1)
//static int bcdcvt(
//	char		dbf[],			//	Buffer Resultat
//	s_bcd		*bcd,			//	bcd a Convertir
//	int			ndg,			//	Nombre de Digit
//	int			*dpt,			//	Renvoi du Point Decimal
//	int			*sgn)			//	Renvoi du Signe

function bcdcvt(dbf, bcd, ndg, dpt, sgn) {
	char * pt; //	Pointeur de Travail
	char * ep;
	int mlg; //	Num digits in decimal
	//	S'allouer la Taille
	if (ndg > 200) return err_adx(ERDOM, "");
	if (ndg < 0) ndg = 0;

	pt = dbf;

	//	Retourner l'Information sur le Signe
	sgn[0] = (bcd[SIGN] == 0);

	//	Position du Point Decimal
	if (iszbcd(bcd)) dpt[0] = 0;
	else dpt[0] = (bcd[POW100] - 64) * 2;

	//	Unpack de la valeur Decimale
	ep = mantissaString(bcd->bcd_mn, bcd[LEN], dbf);
	mlg = bcd[LEN] * 2;

	//	Reajustement des Differentes Valeurs
	if ( * pt == '0')++pt, --mlg, --(dpt[0]);

	if (ndg > mlg) memset(ep, '0', ndg - mlg); //	Pad avec des 0
	else if (ndg < mlg) {
		//	Arrondi
		ep = pt + ndg;
		for ( * ep += 5;
		( * ep > '9') && (ep > pt); ++( * (--ep))) * ep = '0';
		if ( * ep > '9') { * ep = '1';
			(dpt[0])++;
		}
	}

	pt[ndg] = 0; // terminate string
	return (int)(pt - dbf);
}
*/

var BCD_ZERO = fromString('0');
var BCD_ONE_HALF = fromString('0.5');
var BCD_ONE = fromString('1');
var BCD_MAX = fromDouble(MAXDBL * (1 - 1 / FLOATPREC));
var BCD_MIN = fromDouble(-MAXDBL * (1 - 1 / FLOATPREC))
var BCD_MAX_INT32 = fromInt32(MAXESG4);
var BCD_MIN_INT32 = fromInt32(MINESG4);
console.log("READY!!")

