"use strict";
var X3Error = require('./errors').X3Error;
var util = require('./util');

var SIGN = 0; // 0 if negative, 1 if positive
var LEN = 1; // number of elements in mantissa
var POW100 = 2; // number of digit pairs (100s) in scale offset by 64.
var BASE = 3; // base index of mantissa
var MAX00 = 16;
var SIZE = BASE + MAX00;

var MAXDBL = 1e80;
var MINDBL = 1e-79;
var SPREC = 6;
var DPREC = 10;
var FLOATPREC = 1000000000.0;
var EPSILON = 0.0000000001;

var MAXESG4 = 0x7fffffff;
var MINESG4 = -0x80000000;

var TypedArray = Uint8Array;
//var TypedArray = Buffer;

exports.isBCD = function(val) {
	return val instanceof TypedArray;
}

function alloc(size) {
	var arr = new TypedArray(size);
	//for (var i = 0; i < size; i++) arr[i] = 0xfe;
	return arr;
}

function getSign(bcd) {
	if (bcd[LEN] == 0) return 0;

	return (bcd[SIGN] == 0) ? -1 : 1;
}

function toggleSign(bcd) {
	if (bcd[LEN] != 0) bcd[SIGN] ^= 1;
}

// can bcd be coerced to int32 without loss

function isInt32(bcd, opt) {
	//	Test Overflow
	if (bcd[POW100] > 64 + 5) return false;
	if (bcd[POW100] == 64 + 5) {
		if (compare(bcd, BCD_MAX_INT32) > 0) return false;
		if (compare(bcd, BCD_MIN_INT32) < 0) return false;
	}

	//	Is it integer?
	return opt == 0 || bcd[POW100] - 64 >= bcd[LEN] || bcd[LEN] == 0;
}

function isSpace(s) {
	return /^\s$/.test(s);
}

function isDigit(s) {
	return /^\d$/.test(s);
}

var ASCII_0 = '0'.charCodeAt(0);

function fillMantissa(digits, mantissa, odd) {
	var i = 0,
		j = 0;
	var dgt = 0;

	while (i < digits.length || dgt !== 0) {
		if (i < digits.length) dgt += digits.charCodeAt(i++) - ASCII_0;
		if ((odd & 1) != 0) {
			mantissa[j++] = dgt;
			dgt = 0;
		} else dgt *= 10;
		odd++;
	}
	return Math.floor( odd / 2 ) ;
}

function mantissaString(mantissa, cnt) {
	var str = '';
	for (var i = 0; i < cnt; i++) {
		var d = mantissa[i];
		str += d < 10 ? '0' + d : d;
	}
	return str;
}

function memcopy(src, i, dst, j, len) {
	while (len-- > 0) dst[j++] = src[i++];
}

function memcompare(s1, i1, s2, i2, len) {
	var diff = 0;
	while (len-- > 0 && diff === 0) diff = s1[i1++] - s2[i2++];
	return diff;
}

function make(sign, pow100, mantissa, len) {
	//	Virer les 0 de Trop
	var i = len;
	while (len > 0 && mantissa[--i] === 0) --len;
	var beg = 0;
	while (len > 0 && mantissa[beg] === 0) --pow100, --len, ++beg;

	if (len > MAX00) {
		i = beg + MAX00;
		if (mantissa[i] >= 50) {
			// Round up
			while (++mantissa[--i] >= 100 && i >= beg) mantissa[i] = 0;
		}
		if (i < beg)++pow100, mantissa[beg] = 1; // ??
		len = MAX00;
	}

	//	Test numeric overflow
	if (pow100 > 63 && len > 0) throw new X3Error(13, "decimal overflow");

	if (len === 0 || pow100 < -64) pow100 = 0, sign = 1, len = 0; //	 Zero
	var bcd = alloc(BASE + len);
	bcd[SIGN] = sign;
	bcd[LEN] = len;
	bcd[POW100] = pow100 + 64;
	if (len > 0) memcopy(mantissa, beg, bcd, BASE, len);
	return bcd;
}


// Transforme une Chaine en bcd
//int fromString(s_bcd bcd[], char str[]) //	Chaine a Analyser
var fromString = exports.fromString = function(str) {
		var i = 0,
			beg;
		var sign = '+';

		// skip leading spaces
		while (isSpace(str[i])) i++;
		beg = i;

		// handle sign
		if (str[i] === '-' || str[i] === '+') sign = str[i++];

		// mantissa
		var buf = '',
			gotDot = false,
			pow10 = 0;
		for (; isDigit(str[i]) || str[i] === '.'; i++) {
			if (str[i] === '.') {
				if (gotDot) break;
				gotDot = true;
				continue;
			}

			//	zeros after dot matter
			if (str[i] === '0' && buf.length === 0) {
				if (gotDot)--pow10;
				continue;
			}

			//	store the digit
			if (buf.length < 2 * MAX00) buf += str[i];

			//	increment pow10
			if (!gotDot)++pow10;

		}

		// optional exponent
		if (i != beg && (str[i] == 'e' || str[i] == 'E')) {
			++i;
			pow10 += parseInt(str.substring(i), 10);
		}

		// empty string
		if (i == beg) return BCD_ZERO;

		var mantissa = alloc(16);
		var len = fillMantissa(buf, mantissa, (pow10 & 1));

		return make(sign !== '-', ((pow10 + 1) & ~1) / 2, mantissa, len);
	}

var fromDouble = exports.fromDouble = function(dbl) {
		return fromString("" + dbl);
	}

var isZero = exports.isZero = function( val ) {
		return (compare( fromInt32(0), val ) === 0)? 1 : 0 ;
	}	

function clone(bcd) {
	var cl = alloc(SIZE);
	memcopy(bcd, 0, cl, 0, SIZE);
	return cl;
}

var truncate = exports.truncate = function(bcd, scale) {
		scale = scale || 0;
		var len = Math.floor((scale + 1) / 2) + (bcd[POW100] - 64);
		if (len > bcd[LEN]) return bcd;
		bcd = clone(bcd);
		if (len > 0 && (scale & 1) !== 0) bcd[BASE + len - 1] = Math.floor(bcd[BASE + len - 1] / 10) * 10;

		// remove trailing zeros
		while (len > 0 && bcd[BASE + len - 1] === 0) len--;

		if (len <= 0) {
			bcd[POW100] = 64;
			bcd[LEN] = 0;
		} else bcd[LEN] = len;
		return bcd;
	}

	//		Comparaison de 2 bcd
	// int compare(s_bcd bcd1[], s_bcd bcd2[])
var compare = exports.compare = function(bcd1, bcd2) {
		var res = 0;
		var len1 = bcd1[LEN],
			len2 = bcd2[LEN];

		if (len2 == 0) res = (len1 == 0) ? 0 : 1;
		else if (bcd1[SIGN] != bcd2[SIGN]) res = 1;
		else if (len1 == 0) res = -1;
		else if (bcd1[POW100] < bcd2[POW100]) res = -1;
		else if (bcd1[POW100] > bcd2[POW100]) res = 1;
		else {
			var st = len1 - len2;
			res = memcompare(bcd1, BASE, bcd2, BASE, st < 0 ? len1 : len2);
			if (res === 0 && st !== 0) res = st > 0 ? 1 : -1;
		}
		return bcd1[SIGN] ? res : -res;
	}

function expString(bcd, pow100, len) {
	bcd = clone(bcd);
	var exp = 2 * (pow100 - 1);
	bcd[POW100] = 1 + 64;
	var s = toString(bcd);
	if (bcd[LEN] === 1) s += '.0';
	if (bcd[BASE] >= 10) {
		// leave only one digit before decimal point.
		s = s.replace(/^(-?\d)(\d)\.?/, function(all, s1, s2) {
			return s1 + '.' + s2;
		});
		exp++;
	}
	var l = s.length;
	while (s[l - 1] === '0' && s[l - 2] !== '.') l--;
	if (l < s.length) s = s.substring(0, l);
	return s + "e" + exp;
}

var toString = exports.toString = function(bcd) {
		if (bcd[LEN] === 0) return '0';

		var s = bcd[SIGN] ? '' : '-';
		var len = bcd[LEN],
			pow100 = bcd[POW100] - 64;

		// switch to exponential notation when abs value is >= 1e32 or < 1e-12 
		// the low bound (1e-12) may need review
		if (pow100 > 16 || pow100 <= -6) return expString(bcd, pow100, len);

		if (pow100 > 0) {
			s += bcd[BASE];
			for (var i = 1; i < pow100; i++) {
				if (i < len) {
					var v = bcd[BASE + i];
					s += v < 10 ? '0' + v : v;
				} else {
					s += "00";
				}
			}
		} else {
			s += '0';
		}
		if (pow100 >= len) return s;
		s += '.';
		while (pow100 < 0) {
			s += '00';
			pow100++;
		}
		for (var i = pow100; i < len - 1; i++) {
			var v = bcd[BASE + i];
			s += v < 10 ? '0' + v : v;
		}
		var v = bcd[BASE + len - 1];
		s += v % 10 === 0 ? v / 10 : v < 10 ? '0' + v : v;

		return s;
	}

var toInt32 = exports.toInt32 = function(bcd) {
	//	Differents Test d'Overflow
	if (!isInt32(bcd, 0)) throw new X3Error(50, "toInt32");

	var l = 0,
		pow100 = bcd[POW100] - 64,
		len = bcd[LEN];
	for (var i = 0; i < pow100; i++) {
		l *= 100;
		if (i < len) l += bcd[BASE + i];
	}

	return bcd[SIGN] !== 0 ? l : -l;
}

var fromInt32 = exports.fromInt32 = function (val) {
	var sign = 1;

	if (val < 0) {
		val = -val;
		sign = 0;
	}

	var dgt = alloc(6);
	dgt[5] = 0
	for (var i = 4; i >= 0; --i) {
		dgt[i] = val % 100;
		val = Math.floor(val / 100);
	}

	return make(sign, 5, dgt, 5);
}

var toDouble = exports.toDouble = function (bcd) {
	var str = toString(bcd, 40);
	var val = parseFloat(str);
	if (val === Infinity || val === -Infinity) throw new Error(13, "toDouble: " + val);
	return val;
}

function addOrSub(bcd1, bcd2, sub) {
	// compare absolute values
	// save and restore sign around compare op
	var sign1 = bcd1[SIGN];
	var sign2 = bcd2[SIGN];
	bcd1[SIGN] = bcd2[SIGN] = 1;
	var cmp = compare(bcd1, bcd2);
	bcd1[SIGN] = sign1;
	bcd2[SIGN] = sign2;

	sign2 ^= sub;

	var sign, big, small;
	if (cmp < 0) sign = sign2, small = bcd1, big = bcd2;
	else sign = sign1, small = bcd2, big = bcd1;

	if (sign1 != sign2) return internalSub(sign, big, small);
	else return internalAdd(sign, big, small);
}

var add = exports.add = function(bcd1, bcd2) {
		return addOrSub(bcd1, bcd2, 0);
	}

var sub = exports.sub = function(bcd1, bcd2) {
		return addOrSub(bcd1, bcd2, 1);
	}

	// bcd1 et bcd2 have same sign and abs(bcd1) > abs(bcd2)

function internalAdd(sign, bcd1, bcd2) {
	var sum = alloc(MAX00 + 2); // 2 for overflow and guard
	var len1 = bcd1[LEN],
		len2 = bcd2[LEN];

	// shift mantissa of smaller one
	var dif = bcd1[POW100] - bcd2[POW100];
	var len = dif + len2;
	if (len < len1) len = len1;
	if (len > MAX00 + 1) len = MAX00 + 1;
	len++; // for the carry
	sum[0] = 0;
	memcopy(bcd1, BASE, sum, 1, len1);
	for (var i = 1 + len1; i < sum.length; i++) sum[i] = 0;

	// recompute the relevant part of bcd2
	//	   (if len2 > MAX00, len-dif < len2) we should round
	var i = len - dif - 1;
	if (i > len2) i = len2;

	var j = i + dif; // sum index
	var k = BASE + i - 1; // bcd2 index
	var carry = 0;

	while (k >= BASE) {
		var dgt = sum[j] + bcd2[k] + carry;
		carry = 0;
		if (dgt >= 100)++carry, dgt -= 100;
		sum[j--] = dgt;
		k--;
	}

	if (carry) {
		while (++sum[j] >= 100) sum[j--] = 0;
	}

	return make(sign, bcd1[POW100] - 64 + 1, sum, len);
}

// bcd1 et bcd2 have same sign and abs(bcd1) > abs(bcd2)


function internalSub(sign, bcd1, bcd2) {
	var sum = alloc(MAX00 + 2); // 2 for overflow and guard
	var len1 = bcd1[LEN],
		len2 = bcd2[LEN];

	// shift mantissa of smaller one
	var dif = bcd1[POW100] - bcd2[POW100];
	var len = dif + len2;
	if (len < len1) len = len1;
	if (len > MAX00 + 1) len = MAX00 + 1;

	memcopy(bcd1, BASE, sum, 0, len1);
	for (var i = len1; i < sum.length; i++) sum[i] = 0;

	// recompute the relevant part of bcd2
	//	   (if len2 > MAX00, len-dif < len2) we should round
	i = len - dif;
	if (i > len2) i = len2;

	var j = i + dif - 1; // sum index
	var k = BASE + i - 1; // bcd2 index
	var carry = 0;

	while (k >= BASE) {
		var dgt = sum[j] - bcd2[k] + carry;
		if (dgt < 0) carry = -1, dgt += 100;
		else carry = 0;

		sum[j--] = dgt;
		k--;
	}

	if (carry != 0) {
		while (sum[j]-- == 0) sum[j--] = 99;
	}

	return make(sign, bcd1[POW100] - 64, sum, len);
}

var multiply = exports.multiply = function(bcd1, bcd2) {
		var prod = alloc(MAX00 + MAX00);
		for (var i = 0; i < prod.length; i++) prod[i] = 0;
		var len1 = bcd1[LEN],
			len2 = bcd2[LEN];
		var len = len1 + len2; // max length
		for (var i = len1 - 1; i >= 0; i--) {
			for (var j = len2 - 1; j >= 0; j--) {
				var dgt = bcd1[BASE + i] * bcd2[BASE + j];
				for (var k = i + j + 1; dgt != 0; k--) {
					dgt += prod[k];
					prod[k] = dgt % 100;
					dgt = Math.floor(dgt / 100); //	store carry into dgt
				}
			}
		}
		return make(bcd1[SIGN] == bcd2[SIGN] ? 1 : 0, bcd1[POW100] - 64 + bcd2[POW100] - 64, prod, len);
	}

function raz(arr) {
	for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

var divide = exports.divide = function(bcd1, bcd2) {
	var len1 = bcd1[LEN],
		len2 = bcd2[LEN];
	var numer = alloc(MAX00 + MAX00 + 2);
	var quotient = alloc(MAX00 + 2); // includes guarad
	var denom = alloc(MAX00 + 2);

	// divide by 0
	if (len2 == 0) throw new X3Error(53, "divison by zero");

	// leave one leading digit
	raz(numer);
	raz(denom);
	memcopy(bcd1, BASE, numer, 1, len1);
	memcopy(bcd2, BASE, denom, 1, len2);

	//	Take 2 numbers from denom to limit error on quotient to 1
	var divor = bcd2[BASE] * 100;
	if (len2 > 1) divor += bcd2[BASE + 1];

	for (var i = 0; i < MAX00 + 2; i++) {
		// 3 numbers from numer are necessary and sufficient to estimate quotient
		var num = numer[i] * 100 + numer[i + 1];
		num = num * 100 + numer[i + 2];
		var quo = Math.floor(num / divor);
		quotient[i] = quo;
		if (quo === 0) continue;

		//	subtract denom * quotient from numer
		var dgt = 0;
		var k = i + len2;
		for (var j = len2; j >= 0; j--, k--) {
			dgt += (10000 + numer[k]) - (quo * denom[j]);
			numer[k] = dgt % 100;
			dgt = Math.floor(dgt / 100); //	propagate negative carry
			dgt -= 100;
		}

		// wasn't dgt too big
		if (dgt < 0) {
			// add one denom
			--quotient[i];
			dgt = 0;
			k = i + len2;
			for (j = len2; j >= 0; j--, k--) {
				dgt += numer[k] + denom[j];
				numer[k] = dgt % 100;
				dgt = Math.floor(dgt / 100);
			}
		}
	}

	return make(bcd1[SIGN] == bcd2[SIGN] ? 1 : 0, bcd1[POW100] - bcd2[POW100] + 1, quotient, i);
}
/*
//		Emule ecvt/fcvt selon la valeur de flg (0/1)
//static int bcdcvt(
//	char		dbf[],			//	Buffer Resultat
//	s_bcd		*bcd,			//	bcd a Convertir
//	int			ndg,			//	Nombre de Digit
//	int			*dpt,			//	Renvoi du Point Decimal
//	int			*sign)			//	Renvoi du Signe

function bcdcvt(dbf, bcd, ndg, dpt, sign) {
	char * pt; //	Pointeur de Travail
	char * ep;
	int mlg; //	Num digits in decimal
	//	S'allouer la Taille
	if (ndg > 200) return err_adx(ERDOM, "");
	if (ndg < 0) ndg = 0;

	pt = dbf;

	//	Retourner l'Information sur le Signe
	sign[0] = (bcd[SIGN] == 0);

	//	Position du Point Decimal
	if (iszbcd(bcd)) dpt[0] = 0;
	else dpt[0] = (bcd[POW100] - 64) * 2;

	//	Unpack de la valeur Decimale
	ep = mantissaString(bcd - > bcd_mn, bcd[LEN], dbf);
	mlg = bcd[LEN] * 2;

	//	Reajustement des Differentes Valeurs
	if ( * pt == '0')++pt, --mlg, --(dpt[0]);

	if (ndg > mlg) memset(ep, '0', ndg - mlg); //	Pad avec des 0
	else if (ndg < mlg) {
		//	Arrondi
		ep = pt + ndg;
		for ( * ep += 5;
		( * ep > '9') && (ep > pt); ++( * (--ep))) * ep = '0';
		if ( * ep > '9') { * ep = '1';
			(dpt[0])++;
		}
	}

	pt[ndg] = 0; // terminate string
	return (int)(pt - dbf);
} */

var BCD_ZERO = exports.ZERO = fromString('0');
var BCD_ONE_HALF = exports.ONE_HALF = fromString('0.5');
var BCD_ONE = exports.ONE = fromString('1');
var BCD_MAX = exports.MAX = fromDouble(MAXDBL * (1 - 1 / FLOATPREC));
var BCD_MIN = exports.MIN = fromDouble(-MAXDBL * (1 - 1 / FLOATPREC))
var BCD_MAX_INT32 = exports.MAX_INT32 = fromInt32(MAXESG4);
var BCD_MIN_INT32 = exports.MIN_INT32 = fromInt32(MINESG4);

exports.instructions = {
	DECIMAL: function( v ) {
		return util.instructions.C(fromString(v)) ;
	}
};
