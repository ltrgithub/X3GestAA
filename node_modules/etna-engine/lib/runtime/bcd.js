"use strict";
var X3Error = require('./errors').X3Error;

var SIGN = 0; // 0 if negative, 1 if positive
var LEN = 1; // number of elements in mantissa
var POW100 = 2; // number of digit pairs (100s) in scale offset by 64.
var BASE = 3; // base index of mantissa
var MAX00 = 16;
var SIZE = BASE + MAX00;

var MAXDBL = 1e80;
var MINDBL = 1e-79;
var SPREC = 6;
var DPREC = 10;
var FLOATPREC = 1000000000.0;
var EPSILON = 0.0000000001;

var MAXESG4 = 0x7fffffff;
var MINESG4 = 0x80000000;

//var TypedArray = Uint8Array;
var TypedArray = Buffer;

function alloc(size) {
	var arr = new TypedArray(size);
	for (var i = 0; i < size; i++) arr[i] = 0xfe;
	return arr;
}

function getSign(bcd) {
	if (bcd[LEN] == 0) return 0;

	return (bcd[SIGN] == 0) ? -1 : 1;
}

function toggleSign(bcd) {
	if (bcd[LEN] != 0) bcd[SIGN] ^= 1;
}

// can bcd be coerced to int32 without loss

function isInt32(bcd, opt) {
	//	Test Overflow
	if (bcd[POW100] > 64 + 5) return false;
	if (bcd[POW100] == 64 + 5) {
		if (compare(bcd, BCD_MAX_INT32) > 0) return false;
		if (compare(bcd, BCD_MIN_INT32) < 0) return false;
	}

	//	Is it integer?
	return opt == 0 || bcd[POW100] - 64 >= bcd[LEN] || bcd[LEN] == 0;
}

function isSpace(s) {
	return /^\s$/.test(s);
}

function isDigit(s) {
	return /^\d$/.test(s);
}

var ASCII_0 = '0'.charCodeAt(0);

function fillMantissa(digits, mantissa, odd) {
	var i = 0,
		j = 0;
	var dgt = 0;

	while (i < digits.length || dgt !== 0) {
		if (i < digits.length) dgt += digits.charCodeAt(i++) - ASCII_0;
		if ((odd & 1) != 0) {
			mantissa[j++] = dgt;
			dgt = 0;
		} else dgt *= 10;
		odd++;
	}
	return odd / 2;
}

function mantissaString(mantissa, cnt) {
	var str = '';
	for (var i = 0; i < cnt; i++) {
		var d = mantissa[i];
		str += d < 10 ? '0' + d : d;
	}
	return str;
}

function memcopy(src, i, dst, j, len) {
	while (len-- > 0) dst[j++] = src[i++];
}

function memcompare(s1, i1, s2, i2, len) {
	var diff = 0;
	while (len-- > 0 && diff === 0)
	diff = s1[i1++] - s2[i2++];
	return diff;
}

function make(sign, pow100, mantissa, len) {
	//	Virer les 0 de Trop
	var i = len;
	while (len > 0 && mantissa[--i] === 0)--len;
	var beg = 0;
	while (len > 0 && mantissa[beg] === 0)--pow100, --len, ++beg;

	if (len > MAX00) {
		i = beg + MAX00;
		if (mantissa[i] >= 50) {
			// Round up
			while (++mantissa[--i] >= 100 && i >= beg) mantissa[i] = 0;
		}
		if (i < beg)++pow100, mantissa[beg] = 1; // ??
		len = MAX00;
	}

	//	Test Overflow Numerique
	if (pow100 > 63 && len > 0) throw new X3Error(13, "");

	if (len === 0 || pow100 < -64) pow100 = 0, sign = 1, len = 0; //	 Zero
	var bcd = alloc(BASE + len);
	bcd[SIGN] = sign;
	bcd[LEN] = len;
	bcd[POW100] = pow100 + 64;
	if (len > 0) memcopy(mantissa, beg, bcd, BASE, len);
	return bcd;
}


// Transforme une Chaine en bcd
//int fromString(s_bcd bcd[], char str[]) //	Chaine a Analyser
var fromString = exports.fromString = function(str) {
		var i = 0,
			beg;
		var sign = '+';

		// skip leading spaces
		while (isSpace(str[i])) i++;
		beg = i;

		// handle sign
		if (str[i] === '-' || str[i] === '+') sign = str[i++];

		// mantissa
		var buf = '',
			gotDot = false,
			pow10 = 0;
		for (; isDigit(str[i]) || str[i] === '.'; i++) {
			if (str[i] === '.') {
				if (gotDot) break;
				gotDot = true;
				continue;
			}

			//	zeros after dot matter
			if (str[i] === '0' && buf.length === 0) {
				if (gotDot)--pow10;
				continue;
			}

			//	store the digit
			if (buf.length < 2 * MAX00) buf += str[i];

			//	increment pow10
			if (!gotDot)++pow10;

		}

		// optional exponent
		if (i != beg && (str[i] == 'e' || str[i] == 'E')) {
			++i;
			pow10 += parseInt(str.substring(i), 10);
		}

		// empty string
		if (i == beg) return BCD_ZERO;

		var mantissa = alloc(16);
		var len = fillMantissa(buf, mantissa, (pow10 & 1));

		return make(sign !== '-', ((pow10 + 1) & ~1) / 2, mantissa, len);
	}

var fromDouble = exports.fromDouble = function(bcd, dbl) {
		return fromString("" + dbl);
	}

function clone(bcd) {
	var cl = alloc(SIZE);
	memcopy(bcd, 0, cl, 0, SIZE);
	return cl;
}

var truncate = exports.truncate = function(bcd, scale) {
		scale = scale || 0;
		var len = Math.floor((scale + 1) / 2) + (bcd[POW100] - 64);
		if (len > bcd[LEN]) return bcd;
		bcd = clone(bcd);
		if (len > 0 && (scale & 1) !== 0) bcd[BASE + len - 1] = Math.floor(bcd[BASE + len - 1] / 10) * 10;

		// remove trailing zeros
		while (len > 0 && bcd[BASE + len - 1] === 0) len--;

		if (len <= 0) {
			bcd[POW100] = 64;
			bcd[LEN] = 0;
		} else bcd[LEN] = len;
		return bcd;
	}

	//		Comparaison de 2 bcd
	// int compare(s_bcd bcd1[], s_bcd bcd2[])
var compare = exports.compare = function(bcd1, bcd2) {
		var res = 0;
		var len1 = bcd1[LEN],
			len2 = bcd2[LEN];

		if (len2 == 0) res = (len1 == 0) ? 0 : 1;
		else if (bcd1[SIGN] != bcd2[SIGN]) res = 1;
		else if (len1 == 0) res = -1;
		else if (bcd1[POW100] < bcd2[POW100]) res = -1;
		else if (bcd1[POW100] > bcd2[POW100]) res = 1;
		else {
			var st = len1 - len2;
			res = memcompare(bcd1, BASE, bcd2, BASE, st < 0 ? len1 : len2);
			if (res === 0 && st !== 0) res = st > 0 ? 1 : -1;
		}
		return bcd1[SIGN] ? res : -res;
	}

function expString(bcd, pow100, len) {
	bcd = clone(bcd);
	var exp = 2 * (pow100 - 1);
	bcd[POW100] = 1 + 64;
	var s = toString(bcd);
	if (bcd[LEN] === 1) s += '.0';
	if (bcd[BASE] >= 10) {
		// leave only one digit before decimal point.
		s = s.replace(/^(-?\d)(\d)\.?/, function(all, s1, s2) {
			return s1 + '.' + s2;
		});
		if (/\d0$/.test(s)) s = s.substring(0, s.length - 1);
		exp++;
	}
	return s + "e" + exp;
}

var toString = exports.toString = function(bcd) {
		console.log(bcd);
		if (bcd[LEN] === 0) return '0';

		var s = bcd[SIGN] ? '' : '-';
		var len = bcd[LEN],
			pow100 = bcd[POW100] - 64;

		// switch to exponential notation when abs value is >= 1e32 or < 1e-12 
		// the low bound (1e-12) may need review
		if (pow100 > 16 || pow100 <= -6) return expString(bcd, pow100, len);

		if (pow100 > 0) {
			s += bcd[BASE];
			for (var i = 1; i < pow100; i++) {
				if (i < len) {
					var v = bcd[BASE + i];
					s += v < 10 ? '0' + v : v;
				} else {
					s += "00";
				}
			}
		} else {
			s += '0';
		}
		if (pow100 >= len) return s;
		s += '.';
		while (pow100 < 0) {
			s += '00';
			pow100++;
		}
		for (var i = pow100; i < len - 1; i++) {
			var v = bcd[BASE + i];
			s += v < 10 ? '0' + v : v;
		}
		var v = bcd[BASE + len - 1];
		s += v % 10 === 0 ? v / 10 : v < 10 ? '0' + v : v;

		return s;
	}

function toInt32(bcd) {
	//	Differents Test d'Overflow
	if (!isInt32(bcd, 0)) throw new X3Error(50, "toInt32");

	var l = 0,
		pow100 = bcd[POW100] - 64,
		len = bcd[LEN];
	for (var i = 0; i < pow100; i++) {
		l *= 100;
		if (i < len) l += bcd[BASE + i];
	}

	return bcd[SIGN] !== 0 ? l : -l;
}

function fromInt32(bcd, val) {
	var sign = 1;

	if (val < 0) {
		val = -val;
		sign = 0;
	}

	var dgt = alloc(6);
	dgt[5] = 0
	for (var i = 4; i >= 0; --i) {
		dgt[i] = val % 100;
		val = Math.floor(val / 100);
	}

	return make(sign, 5, dgt, 5);
}

function toDouble(bcd) {
	var str = toString(bcd, 40);
	var val = parseFloat(str);
	if (val === Infinity || val === -Infinity) throw new Error(13, "toDouble: " + val);
	return val;
}

function addOrSub(bcd1, bcd2, sub) {
	// compare absolute values
	// save and restore sign around compare op
	var sign1 = bcd1[SIGN];
	var sign2 = bcd2[SIGN];
	bcd1[SIGN] = bcd2[SIGN] = 1;
	var cmp = compare(bcd1, bcd2);
	bcd1[SIGN] = sign1;
	bcd2[SIGN] = sign2;

	sign2 ^= sub;

	var sign, big, small;
	if (cmp < 0) sign = sign2, small = bcd1, big = bcd2;
	else sign = sign1, small = bcd2, big = bcd1;

	if (sign1 != sign2) return internalSub(sign, big, small);
	else return internalAdd(sign, big, small);
}

var add = exports.add = function(bcd1, bcd2) {
	return addOrSub(bcd1, bcd2, 0);
}

var sub = exports.sub = function(bcd1, bcd2) {
	return addOrSub(bcd1, bcd2, 1);
}

// bcd1 et bcd2 have same sign and abs(bcd1) > abs(bcd2)

function internalAdd(sign, bcd1, bcd2) {
	var sum = alloc(MAX00 + 2); // 2 for overflow and guard
	var len1 = bcd1[LEN],
		len2 = bcd2[LEN];

	// shift mantissa of smaller one
	var dif = bcd1[POW100] - bcd2[POW100];
	var len = dif + len2;
	if (len < len1) len = len1;
	if (len > MAX00 + 1) len = MAX00 + 1;
	len++; // for the carry
	sum[0] = 0;
	memcopy(bcd1, BASE, sum, 1, len1);
	for (var i = 1 + len1; i < sum.length; i++) sum[i] = 0;

	// recompute the relevant part of bcd2
	//	   (if len2 > MAX00, len-dif < len2) we should round
	var i = len - dif - 1;
	if (i > len2) i = len2;

	var j = i + dif; // sum index
	var k = BASE + i - 1; // bcd2 index
	var carry = 0;

	while (k >= BASE) {
		var dgt = sum[j] + bcd2[k] + carry;
		carry = 0;
		if (dgt >= 100)++carry, dgt -= 100;
		sum[j--] = dgt;
		k--;
	}

	if (carry) {
		while (++sum[j] >= 100) sum[j--] = 0;
	}

	return make(sign, bcd1[POW100] - 64 + 1, sum, len);
}

// bcd1 et bcd2 have same sign and abs(bcd1) > abs(bcd2)
function internalSub(sign, bcd1, bcd2) {
	var sum = alloc(MAX00 + 2); // 2 for overflow and guard
	var len1 = bcd1[LEN],
		len2 = bcd2[LEN];

	// shift mantissa of smaller one
	var dif = bcd1[POW100] - bcd2[POW100];
	var len = dif + len2;
	if (len < len1) len = len1;
	if (len > MAX00 + 1) len = MAX00 + 1;

	memcopy(bcd1 , BASE, sum, 0, len1);
	for (var i = len1; i < sum.length; i++) sum[i] = 0;

	// recompute the relevant part of bcd2
	//	   (if len2 > MAX00, len-dif < len2) we should round
	i = len - dif;
	if (i > len2) i = len2;

	var j = i + dif - 1; // sum index
	var k = BASE + i - 1; // bcd2 index
	var carry = 0;

	while (k >= BASE) {
		var dgt = sum[j] - bcd2[k] + carry;
		if (dgt < 0) carry = -1, dgt += 100;
		else carry = 0;

		sum[j--] = dgt;
		k--;
	}

	if (carry != 0) {
		while (sum[j]-- == 0) sum[j--] = 99;
	}

	return make(sign, bcd1[POW100] - 64, sum, len);
}

/*
//		Multiplication de 2 bcd
//int bcdmul(s_bcd prd[], s_bcd bcd1[], s_bcd bcd2[])

function bcdmul(prd, bcd1, bcd2) {
	char * pt;
	int dgt;
	int i;
	int j;
	int len;
	int st;
	char prod[MAX00 + MAX00];
	var len1 = bcd1[LEN],
		len2 = bcd2[LEN];

	tblraz(prod);
	len = len1 + len2; //	Longueur Maximum
	for (i = len1 - 1; i >= 0; i--) {
		for (j = len2 - 1; j >= 0; j--) {
			dgt = (int) bcd1 - > bcd_mn[i] * (int) bcd2 - > bcd_mn[j];
			for (pt = prod + i + j + 1;
			(dgt != 0); pt--) {
				dgt += * pt; * pt = dgt % 100;
				dgt /= 100; //	Stocker la Retenue dans dgt
			}
		}
	}

	st = make(prd, (bcd1[SIGN] == bcd2[SIGN]) ? 1 : 0, bcd1[POW100] - 64 + bcd2[POW100] - 64, prod, len);

	return st;
}

// Divise ddd par dds. dqt renvoie le Quotient
//int bcddiv(s_bcd dqt[], s_bcd ddd[], s_bcd dds[])

function bcddiv(dqt, ddd, dds) {
	int dgt;
	int i;
	int j;
	int st;
	int divor;
	int qdg;
	int32 ldd;
	char * pdd; //	Pointeur Dividende
	char mdd[MAX00 + MAX00 + 2]; //	Dividende
	char mqt[MAX00 + 2]; //	Quotient + Garde
	char mds[MAX00 + 2];

	//	Division par 0 ?
	if (dds[LEN] == 0) return err_adx(ERDIVZ, "");

	//	Laisser un Digit Vide en Tete
	tblraz(mdd);
	tblraz(mds);
	memcpy(mdd + 1, ddd - > bcd_mn, ddd[LEN]);
	memcpy(mds + 1, dds - > bcd_mn, dds[LEN]);

	//	Prendre 2 Digits pour le Diviseur de maniere a
	//	limiter l'erreur possible sur le Quotient a 1
	divor = ((int) dds - > bcd_mn[0]) * 100;
	if (dds[LEN] > 1) divor += dds - > bcd_mn[1];

	for (i = 0; i < MAX00 + 2; i++) {
		//	  3 Digits du Dividende sont necessaires
		//	et suffisant pour l'estimation du Quotient
		ldd = mdd[i] * 100 + mdd[i + 1];
		ldd = ldd * 100 + mdd[i + 2];
		qdg = ldd / divor;
		mqt[i] = qdg;
		if (qdg == 0) continue;

		//	Retirer du Dividende le Produit Diviseur*Quotient 
		dgt = 0;
		pdd = mdd + i + dds[LEN];
		for (j = dds[LEN]; j >= 0; j--, pdd--) {
			dgt += (10000 + * pdd) - (qdg * (int) mds[j]); * pdd = dgt % 100;
			dgt /= 100; //	Prop Retenue negat
			dgt -= 100;
		}

		//	dgt n'etait-il pas trop gros
		if (dgt < 0) {
			//	Rajouter le Diviseur
			--mqt[i];
			dgt = 0;
			pdd = mdd + i + dds[LEN];
			for (j = dds[LEN]; j >= 0; j--, pdd--) {
				dgt += * pdd + mds[j]; * pdd = dgt % 100;
				dgt /= 100;
			}
		}
	}

	st = make(dqt, (ddd[SIGN] == dds[SIGN]) ? 1 : 0, ddd[POW100] - dds[POW100] + 1, mqt, i);

	return st;
}

//		Emule ecvt/fcvt selon la valeur de flg (0/1)
//static int bcdcvt(
//	char		dbf[],			//	Buffer Resultat
//	s_bcd		*bcd,			//	bcd a Convertir
//	int			ndg,			//	Nombre de Digit
//	int			*dpt,			//	Renvoi du Point Decimal
//	int			*sign)			//	Renvoi du Signe

function bcdcvt(dbf, bcd, ndg, dpt, sign) {
	char * pt; //	Pointeur de Travail
	char * ep;
	int mlg; //	Num digits in decimal
	//	S'allouer la Taille
	if (ndg > 200) return err_adx(ERDOM, "");
	if (ndg < 0) ndg = 0;

	pt = dbf;

	//	Retourner l'Information sur le Signe
	sign[0] = (bcd[SIGN] == 0);

	//	Position du Point Decimal
	if (iszbcd(bcd)) dpt[0] = 0;
	else dpt[0] = (bcd[POW100] - 64) * 2;

	//	Unpack de la valeur Decimale
	ep = mantissaString(bcd - > bcd_mn, bcd[LEN], dbf);
	mlg = bcd[LEN] * 2;

	//	Reajustement des Differentes Valeurs
	if ( * pt == '0')++pt, --mlg, --(dpt[0]);

	if (ndg > mlg) memset(ep, '0', ndg - mlg); //	Pad avec des 0
	else if (ndg < mlg) {
		//	Arrondi
		ep = pt + ndg;
		for ( * ep += 5;
		( * ep > '9') && (ep > pt); ++( * (--ep))) * ep = '0';
		if ( * ep > '9') { * ep = '1';
			(dpt[0])++;
		}
	}

	pt[ndg] = 0; // terminate string
	return (int)(pt - dbf);
} */

var BCD_ZERO = fromString('0');
var BCD_ONE_HALF = fromString('0.5');
var BCD_ONE = fromString('1');
var BCD_MAX = fromDouble(MAXDBL * (1 - 1 /
FLOATPREC));
var BCD_MIN = fromDouble(-MAXDBL * (1 - 1 / FLOATPREC))
var BCD_MAX_INT32 = fromInt32(MAXESG4);
var BCD_MIN_INT32 = fromInt32(MINESG4);
console.log("READY!!")