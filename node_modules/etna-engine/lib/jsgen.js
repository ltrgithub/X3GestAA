"use strict";
var inspect = require('util').inspect;
var variables = require('./runtime/variables');
var db = require('./runtime/db');
var bcd = require("./runtime/bcd");
var X3Error = require("./runtime/errors").X3Error;

exports.generate = function(node, fname) {
	var used = {};
	var scopeName = ""; // for errors
	var warn = function(node, message) {
		console.error(node.line + ": " + message);
	};

	function error(node, message) {
		return new X3Error(26, message, fname, node.line, scopeName);
	}

	function unreachable(node) {
		warn(node, node.tag + " is not reachable");
		return "";
	}

	function id(node) {
		return node._id || (node._id = ++lastId);
	}

	// etna: disable main
	var result = "/*z.MAIN(e);*/e.MAIN=B(";
	var line = 1,
		lastLine = 1;
	var tail = ");";
	var lastId = 0;
	var comma = "";
	var skipping;

	function omitComma(res) {
		// check if result + res ends with an open paren followed by optional spaces
		// don't concat result and res, to be efficent.
		var i = res.length - 1;
		while (i >= 0 && (res[i] === ' ' || res[i] === '\n')) i--;
		if (i >= 0) return res[i] === '(';
		var i = result.length - 1;		
		while (i >= 0 && (result[i] === ' ' || result[i] === '\n')) i--;
		return result[i] === '(';
	}
	
	function insert(node, arg, beg, end) {
		if (node && arg && !tail) {
			if (skipping) return "";
			skipping = true;
			return unreachable(node);
		} else {
			skipping = false;
		}
		
		var res = "";
		if (node && arg && line > lastLine) {
			arg = "NL(" + (line - lastLine) + ")," + arg;
			lastLine = line;
		}

		if (tail && arg) {
			res = comma + arg;
			comma = ",";
		}

		if (beg) {
			if (omitComma(res) && tail[0] === ',') tail = tail.slice(1); // fix for empty WHEN clause
			res += tail + beg;
			tail = "";
		}

		if (end) {
			comma = "";
			tail = end + tail;
		}
		return res;
	}

	function genArray(arr) {
		used.A = true;
		return "A([" + arr.map(gen0).join(',') + "])";

	}

	function genClosing(node) {
		return insert(node, "", "p[" + id(node) + "]=B(", ");");
	}

	var types = {};
	for (var key in variables.types)
	types[variables.types[key].name] = key;

	function leaf(node) {
		return node.branch ? leaf(node.branch) : node;
	}

	var tmp;

	var generators = {
		IDENT: function(node, variant) {
			var inst = (variant || '') + "V";
			used[inst] = true;
			return inst + "('" + node.value + "')";
		},
		CLAS: function(node, variant) {
			var inst = (variant || '') + "CV";
			used[inst] = true;
			return inst + "('" + node.letter + "','" + (node.abbrev || "") + "'," + genDefNull(node.field) + ")";
		},
		
		STRING: function(node) {
			used.C = true;
			var val = node.value.replace(/\\/g, "\\\\");
			return node.value.indexOf("'") >= 0 ? 'C("' + val + '")' : "C('" + val + "')";
		},
		INTEGER: function(node) {
			used.C = true;
			return "C(" + node.value + ")";
		},
		DECIMAL: function(node) {
			used.DECIMAL = true ;			
			return('DECIMAL("' + node.value + '")') ;
		},
		DATE: function(node) {
			used.DATE = true;
			return "DATE(" + node.year + "," + node.month + "," + node.day + ")";
		},

		OP: function(node, variant) {
			if (variant && db.instructions[variant + node.op]) {
				used[variant + node.op] = true;
				return variant + node.op + "(" + node.args.map(genVariant(variant)).join(',') + ")";
			} else {
				used[node.op] = true;
				return node.op + "(" + node.args.map(gen0).join(',') + ")";
			}
		},
		DIM: tmp = function(node) {
			used[node.tag] = true;
			return node.tag + "(" + node.args.map(gen0).join(",") + ")";
		},
		CLALEV: tmp,
		FCALL: function(node, variant) {
			var inst = (variant || '') + "F";
			used[inst] = true;
			if (node.name === 'TYPE') variant = "TYPE";
			return inst + "('" + node.name + "'" + (node.args ? ",[" + node.args.map(genVariant(variant)).join(",") + "]" : "") + ")";
		},
		EVALUE: function(node) {
			used.EVALUE = true;
			return "EVALUE(r, e, " + gen(node.arg) + ")";
		},
		SIGMA: function(node) {
			used.SIGMA = true;
			return "SIGMA('" + node.field + "',[" + node.args.map(gen0).join(",") + "])";
		},
		SORTA: function(node) {
			used.SORTA = true;
			return insert(node, "SORTA(" + gen(node.rep) + ",[" + (node.vars || []).map(gen0) + "],[" + ((node.order && node.order.exps) || []).map(gen0) + "]"+ ",C(" + (node.order && node.order.direction?node.order.direction:1)  + "))");
		},
		INSA: tmp = function(node) {
			used[node.tag] = true;
			return insert(node, node.tag + "([" + node.intExps.map(gen0) + "],[" + node.vars.map(gen0) + "])");
		},
		DELA: tmp,
		INDEX: function(node) {
			used.INDEX = true;
			return "INDEX(" + gen(node.target) + ",[" + node.args.map(gen0) + "])";
		},
		DECL: function(node) {
			var fctRANGE = [ "CHAR" , "CLBFILE" , "BLBFILE" ];
			used.DECL = true;
			//console.log("DECL node0="+JSON.stringify(node));
			return node.items.map(function(decl) {
				//console.log("DECL node="+JSON.stringify(node));
				// TODO: dims, using and sized
				var key = (variables.dictClasses[node.mode] || '?') + (types[node.type] || '?');
				if (key.indexOf('?') >= 0) warn && warn(node, "unsupported decl: mode=" + node.mode + ", type=" + node.type);
				if(decl.tag === 'PARAM' ) {
					if (fctRANGE.indexOf(node.type)>=0 && decl.ranges && decl.ranges.length === 1  && !decl.ranges[0]) {
						// Value Char A()() is equivalent to Value Char A()(0..)
						decl.ranges = [{
							tag: "OP",
							line: decl.line,
							col: decl.col+3,
							op: "RANGE",
							isAssign : false,
							args : [{
								tag: "INTEGER",
								line: decl.line,
								col: decl.col+2,
								value : 0,
							}]
						}];
					}
					else if (fctRANGE.indexOf(node.type)<0  && decl.lens && !decl.lens[0] && !decl.lens[1]) {
						// Value Integer A() is equivalent to Value Integer A(0..)
						decl.lens = null;
						decl.ranges = [{
							tag: "OP",
							line: decl.line,
							col: decl.col+3,
							op: "RANGE",
							isAssign : false,
							args : [{
								tag: "INTEGER",
								line: decl.line,
								col: decl.col+2,
								value : 0,
							}]
						}];
						
					}
				}
				else if(decl.tag === 'ITEM' ) {
					if (fctRANGE.indexOf(node.type)>=0 && decl.ranges && decl.ranges.length === 1  && !decl.ranges[0].args) {
						// Local Char A(10)(6) is equivalent to Local Char A(10)(0..5)
						decl.ranges = [{
							tag: "OP",
							line: decl.ranges[0].line,
							col: decl.ranges[0].col,
							op: "RANGE",
							isAssign : false,
							args : [{
								tag: "INTEGER",
								line: decl.ranges[0].line,
								col: decl.ranges[0].col,
								value : 0,
							},
							{
								tag: "INTEGER",
								line: decl.ranges[0].line,
								col: decl.ranges[0].col,
								value : decl.ranges[0].value-1
							}]
						}];
 				    }
					else if (fctRANGE.indexOf(node.type)<0 && decl.lens && decl.lens.length === 1  && !decl.lens[0].args) {
						// Local Integer A(6) is equivalent to Local Integer A(0..5)
						
						decl.ranges = [{
							tag: "OP",
							line: decl.lens[0].line,
							col: decl.lens[0].col,
							op: "RANGE",
							isAssign : false,
							args : [{
								tag: "INTEGER",
								line: decl.lens[0].line,
								col: decl.lens[0].col,
								value : 0,
							},
							{
								tag: "INTEGER",
								line: decl.lens[0].line,
								col: decl.lens[0].col,
								value : decl.lens[0].value-1
							}]
						}];
						decl.lens = null ;
				    }
				}
				return insert(decl, "DECL('" + key + "','" + decl.name + "'" + //
					(decl.using ? "," + gen(decl.using) : ",''") + //
					(decl.lens ? "," + gen(decl.lens) : "") + //
					(decl.ranges ? "," + gen(decl.ranges) : "") + //
					")");
			}).join("");
		},
		STATEMENT: function(node) {
			used[node.op] = true;
			return insert(node, node.op + "(" + gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		ASSIGN: function(node) {
			used.ASSIGN = true;
			return insert(node,"ASSIGN(" +  gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		RAZ: function(node) {
			used.RAZ = true;
			return insert(node, "RAZ([" + node.expressions.map(gen0) + "])");
		},
		DYN: function(node) {
			return gen(node.exp);
		},

		GOSUB: tmp = function(node) {
			used.REQ = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used[node.tag] = true;
			if (!node.label && node.tag != "ONERRGO") throw error(node, "label missing");
			return insert(node, node.tag + "(" + from + (node.label ? ",'" + node.label + "'" : "") + ")");
		},
		ONERRGO: tmp,
		GOTO: tmp,
		LABEL: function(node) {
			used.GO = true;
			scopeName = node.name;
			return insert(null, "GO(e,'" + node.name + "')", "e." + node.name + "=B(", ");");
		},
		RETURN: function(node) {
			used.RET = true;
			return insert(node, "RET(" + (node.result ? gen(node.result) : "") + ")", " ", ""); // beg is space to force close
		},
		RESUME: function(node) {
			used.RESUME = true;
			return insert(node, "RESUME()", " ", ""); // beg is space to force close
		},
		SUBPROG: tmp = function(node) {
			used.PROG = true;
			scopeName = node.name;
			return insert(null, "", "PROG(e,'" + node.name + "',[" + node.items.map(quote) + "],B(", "));");
		},
		FUNPROG: tmp,
		END: function(node) {
			used.END = true;
			return insert(node, "END(" + (node.result ? gen(node.result) : "") + ")", " ", ""); // beg is space to force close
		},

		CALL: function(node) {
			used.REQ = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used.CALL = true;
			return insert(node, "CALL(" + from + "," + gen(node.name) + ",[" + (node.args || []).map(gen0) + "])");
		},
		FUNC: function(node) {
			used.REQ = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used.CALL = true;
			return "CALL(" + from + "," + gen(node.name) + ",[" + (node.args || []).map(gen0) + "])";
		},
		PROP: function(node) {
			used.PROP = true;
			return "PROP(" + gen(node.target) + ",'" + node.name + "')";
		},
		FMET: function(node) {
			used.XMET = true;
			return "XMET(" + gen(node.target) + ",'" + node.name + "',[" + node.args.map(gen0) + "])";
		},
		CALLMET: function(node) {
			used.XMET = true;
			return insert(node, "XMET(" + gen(node.target) + ",'" + node.name + "',[" + node.args.map(gen0) + "])");
		},

		IF: function(node) {
			used.IF = used.GO = true;
			return insert(node, "IF(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "", ",GO(p," + id(leaf(node)) + ")))");
		},
		ELSIF: function(node) {
			return insert(node, "", "p[" + id(node) + "]=IF(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", ",GO(p," + id(leaf(node)) + ")));");
		},
		ELSE: function(node) {
			used.GO = true;
			return insert(node, "", "p[" + id(node) + "]=B(", ",GO(p," + id(leaf(node)) + "));");
		},
		ENDIF: genClosing,

		CASE: function(node) {
			used.CASE = true;
			return insert(node, "CASE(" + gen(node.expression) + ",p," + id(node.branch) + "," + id(leaf(node)) + ")", "", "");
		},
		WHEN: function(node) {
			used.WHEN = used.GO = true;
			return insert(node, "", "p[" + id(node) + "]=WHEN([" + node.expressions.map(gen0) + "],p," + id(node.branch) + ",B(", ",GO(p," + id(leaf(node)) + ")));");
		},
		ENDCASE: genClosing,

		KEY: function(node) {
			used.KEY = true;
			return "KEY('" + (node.letter || '') + "','" + (node.abbrev || '') + "','" + (node.field || '') + "'" + (node.indices ? ",[" + node.indices.map(gen0) + "]" : "") + ")";
		},
		FOR: function(node) {
			used.GO = used.DECL = used.SET = used.WHILE = used.V = true;
			var setup;
			if (node.key) {
				used.FORF = true;
				return insert(node, "FORF(" + gen(node.key) + "," + generators.WHERE(node.where) + ",p," + id(node.branch) + ",B(", "", "))");
			} else if (node.from) {
				used.FORV = true;
				return insert(node, "FORV('" + node.varName + "'," + gen(node.from) + "," + gen(node.to) + "," + genDefNull(node.step) + ",p," + id(node.branch) + ",B(", "", "))");
			} else if (node.ins) {
				used.FORIN = true;
				return insert(node, "FORIN('" + node.varName + "',[" + node.ins.map(gen0) + "],p," + id(node.branch) + ",B(", "", "))");
			} else {
				return genNiy(node, true);
			}
		},
		NEXT: genClosing,
		WHILE: function(node) {
			used.GO = used.WHILE = true;
			//return insert(node, "GO(p," + id(node) + ")", "p[" + id(node) + "]=WHILE(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "));");
			return insert(node, "WHILE(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "", "))");
		},
		WEND: genClosing,
		REPEAT: function(node) {
			used.GO = used.WHILE = true;
			return insert(node, "WHILE(" + gen(node.branch.condition) + ",p," + id(node.branch) + ",B(", "", "),true)");
		},
		UNTIL: genClosing,
		BREAK: function(node) {
			used.BREAK = true;
			return insert(node, "BREAK(p," + (node.level ? gen(node.level) : "C(1)") + ')');
		},

		FILES: function(node) {
			// TODO: worry about node.scope
			return node.files.map(function(node) {
				var abbrev = node.clas && node.clas.abbrev;
				if (node.vars) {
					var tag = node.fromVar ? "FILEVAL" : "FILESYS";
					used[tag] = true;
					return insert(node, tag + "(" + genDefNull(node.as) + ",[" + node.vars.map(gen0) + "]," + gen(node.fromVar || node.fromSys) + ")");					throw error(node, "unsupported FILE syntax");			
				} else {
					used.FILESQL = true;
					return insert(node, "FILESQL(" + genDefNull(abbrev) + "," + gen(node.name) + "," + generators.WHERE(node.where) + "," + genDefNull(node.order) + ")");
				}
			}).join("");
		},
		FILTER: function(node) {
			used.FILTER = true;
			var abbrev = node.clas && node.clas.abbrev;
			return insert(node, "FILTER(" + genDefNull(abbrev) + "," + genDefNull(node.where) + "," + genDefNull(node.order) + ")");
		},
		WHERE: function(node) {
			if (!node) return "null";
			if (!node.exps || node.exps.length !== 1) throw error(node, "unsupported where clause: " + node.exps);
			var exp = node.exps[0];
			var ands = [];
			while (exp.tag === 'OP' && exp.op === 'AND') {
				ands.push(exp.args[0]);
				exp = exp.args[1];
			}
			ands.push(exp);
			used.WHERE = true;
			return "WHERE([" + ands.map(genVariant("SQL")) + "])";
		},
		ORDER: function(node) {
			used.ORDER = true;
			var name = node.keyName ? "'" + node.keyName + "'" : "null";
			return "ORDER(" + name + ",[" + (node.keyBy || []).map(gen0) + "]," + genDefNull(node.keyWith) + ")";
		},
		ORDERITEM: function(node) {
			return "'" + (node.dir < 0 ? '-' : '+') + node.name + "'";
		},
		COLUMN: function(node) {
			return "['" + (node.abbrev || '') + "','" + (node.field) + "']";
		},
		COLUMNS: function(node) {
			used.COLUMNS = true;
			return "COLUMNS('" + (node.clas.abbrev || '') + "'" + (node.columns ? "[" + node.columns.map(gen0) + "]" : '') + ")";
		},
		LINK: function(node) {
			used.LINK = true;
			return insert(node, "LINK('" + node.clas.abbrev + "','" + node.as.abbrev + "',[" + node.items.map(gen0) + "]," //
			+
			genDefNull(node.where) + "," + genDefNull(node.order) + ")");
		},
		LINKITEM: function(node) {
			used.LINKITEM = true;
			return "LINKITEM(" + gen(node.key, "SQL") + "," + node.outer + ",[" + node.values.map(genVariant("SQL")) + "])";
		},
		READ: function(node) {
			used.READ = true;
			var abbrev = node.clas && node.clas.abbrev;
			// todo: hint and lockWait
			return insert(node, "READ(" + gen(node.key, "SQL") + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "])");
		},
		WRITE: function(node) {
			used.WRITE = true;
			var abbrev = node.clas && node.clas.abbrev;
			return insert(node, "WRITE('" + abbrev + "')");
		},
		REWRITE: function(node) {
			used.REWRITE = true;
			return insert(node, "REWRITE(" + gen(node.key, "SQL") + ", '" + (node.op || '')+ "',[" + (node.values || []).map(gen0) + "])");
		},
		DELETE: function(node) {
			used.DELETE = true;
			if (!node.key || !node.key.abbrev) throw error("NIY: Delete not followed by [ABREV]")
			return insert(node, "DELETE('" + node.key.abbrev + "', " + generators.WHERE(node.where) + ", '" + (node.op || '')+ "',[" + (node.values || []).map(gen0) + "])");
		},
		TRBEGIN: function(node) {
			used.TRBEGIN = true;
			return insert(node, "TRBEGIN()"); //[" + node.vcs.map(gen0) + "])");
		},
		COMMIT: function(node) {
			used.COMMIT = true;
			return insert(node, "COMMIT()");
		},
		ROLLBACK: function(node) {
			used.ROLLBACK = true;
			return insert(node, "ROLLBACK()");
		},

		OPEN: function(node) {
			used.OPEN = used.CLOSE = true;
			var abbrev = node.using ? node.using.abbrev : '';
			if (node.name) return insert(node, "OPEN('" + abbrev + "'," + gen(node.name) + ",'" + node.mode + "'" + (node.seek ? "," + gen(node.seek) : "") + ")");
			else return insert(node, "CLOSE('" + abbrev + "')");
		},
		CLOSE: function(node) {
			var instr = 'CLOSE' + node.target;
			used[instr] = true;
			var abbrevs = (node.classes || []).map(function(cl) {
				return "'" + cl.abbrev + "'";
			}).join(',');
			return insert(node, instr + "('" + node.scope + "',[" + abbrevs + "])");
		},
		IOMODE: function(node) {
			used.IOMODE = true;
			var abbrev = node.using ? node.using.abbrev : '';
			return insert(node, "IOMODE('" + abbrev + "','" + node.mode + "'," + gen(node.value) + ")");
		},
		WRSEQ: function(node) {
			used.WRSEQ = true;
			var abbrev = node.using ? node.using.abbrev : '';
			return insert(node, "WRSEQ('" + abbrev + "'," + gen(node.values) + (node.sep ? "," + gen(node.sep) : "") + ")");
		},

		CALLJS: function(node) {
			used.CALLJS = true;
			return insert(node, "CALLJS(" + gen(node.mode) + "," + gen(node.from) + ",'" + node.name + "'" + (node.args ? ',' + genArray(node.args) : "") + ")");
		},
		ERRBOX: function(node) {
			used.BOX = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "BOX('error',[" + gen(node.arg) + "])");
		},
		INFBOX: function(node) {
			used.BOX = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "BOX('info',[" + node.args.map(gen0) + "])");
		},
		DBGETNA: function(node) {
			used.DBGETNA = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "DBGETNA([" + gen(node.arg) + "])") ;
		},
		NEWINSTANCE: function(node) {
			used.NEW = true;
			return "NEW(" + gen(node.clas) + ")";
		},
		FREEINSTANCE: function(node) {
			used.FREE = true;
			// we could omit it completely!
			return insert("FREE(" + gen(node.arg) + ", false)");
		},
		FREEGROUP: function(node) {
			used.FREE = true;
			// we could omit it completely!
			return insert("FREE(" + gen(node.arg) + ", true)");
		},
		NULL: function(node) {
			used.C = true;
			return "C(null)";
		},
	};

	function genNiy(node, topLevel) {
		used.NIY = true;
		var str = "NIY({";
		var comma = "";
		for (var key in node) {
			if (node.hasOwnProperty(key) && key !== 'line' && key !== 'col' && key !== 'parentLoop' && key !== 'chainType' && key !== 'branch') {
				var val = node[key];
				str += comma + key + ":" + gen0(val);
				comma = ",";
			}
		}
		str += "})";
		//console.log("skipping " + node.tag)
		return topLevel ? insert(node, str) : str;
	}

	function gen(node, variant, topLevel) {
		used.A = true;
		if (node == null) return "C(null)"; // for now
		if (Array.isArray(node)) return ("A([" + node.map(gen0).join(',') + "])");
		if (node.tag == null) return "'" + node.toString() + "'";
		var fn = generators[node.tag];
		if (fn) return fn(node, variant);
		else {
			return genNiy(node, topLevel);
		}

	}

	function genDefNull(node) {
		return node ? gen(node) : "null";
	}

	function gen0(node) { // for map, etc.
		return gen(node);
	}

	function quote(s) {
		return "'" + s + "'";
	}

	function genVariant(variant) {
		return function(node) {
			return gen(node, variant);
		};
	}
	//console.log(node);
	var statements = node.statements;
	//var returns = false;
	for (var i = 0, len = statements.length; i < len; i++) {
		var statement = statements[i];
		while (line < statement.line) {
			result += "\n";
			line++;
		}
		result += gen(statement, false, true);
		//returns = statement.returns;
	}
	result += insert(node, "", "\n", "");

	// stub for standalone evaluation
	var head = "var rt = require('etna-engine/lib/runtime'),z=rt.instructions";
	head += ",r=typeof(requireScript)==='undefined'?rt.requireScript:requireScript";
	head += ",e=exports,p=[],B=z.B,NL=z.NL";
	for (var key in used) {
		head += "," + key + "=z." + key;
	}
	return head + ";z.BEGIN(module);NL(0);" + result;
};