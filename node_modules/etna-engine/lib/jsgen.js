"use strict";
var inspect = require('util').inspect;
var variables = require('./runtime/variables');
var db = require('./runtime/db');
var bcd = require("./runtime/bcd");
var X3Error = require("./runtime/errors").X3Error;
var config = require("etna-util/lib/nodeconfig").config.etna;

exports.generate = function(node, fname) {
	var used = {};
	var scopeName = ""; // for errors
	var warn = function(node, message) {
		console.error(node.line + ": " + message);
	};

	function error(node, message) {
		return new X3Error(26, message, fname, node.line, scopeName);
	}

	function unreachable(node) {
		warn(node, node.tag + " is not reachable");
		return "";
	}

	function id(node) {
		return node._id || (node._id = ++lastId);
	}

	// etna: disable main
	var result = "/*z.MAIN(e);*/e.MAIN=B(";
	var line = 1,
		lastLine = 1;
	var tail = ");";
	var lastId = 0;
	var comma = "";
	var skipping;

	function omitComma(res) {
		// check if result + res ends with an open paren followed by optional spaces
		// don't concat result and res, to be efficent.
		var i = res.length - 1;
		while (i >= 0 && (res[i] === ' ' || res[i] === '\n')) i--;
		if (i >= 0) return res[i] === '(';
		var i = result.length - 1;
		while (i >= 0 && (result[i] === ' ' || result[i] === '\n')) i--;
		return result[i] === '(';
	}

	function insert(node, arg, beg, end) {
		if (node && arg && !tail) {
			if (skipping) return "";
			skipping = true;
			return unreachable(node);
		} else {
			skipping = false;
		}

		var res = "";
		if (node && arg && line > lastLine) {
			arg = "NL(" + (line - lastLine) + ")," + arg;
			lastLine = line;
		}

		if (tail && arg) {
			res = comma + arg;
			comma = ",";
		}

		if (beg) {
			if (omitComma(res) && tail[0] === ',') tail = tail.slice(1); // fix for empty WHEN clause
			res += tail + beg;
			tail = "";
		}

		if (end) {
			comma = "";
			tail = end + tail;
		}
		return res;
	}

	function genArray(arr) {
		used.A = true;
		return "A([" + arr.map(gen0).join(',') + "])";

	}

	function genClosing(node) {
		return insert(node, "", "p[" + id(node) + "]=B(", ");");
	}

	var types = {};
	for (var key in variables.types)
		types[variables.types[key].name] = key;

	function leaf(node) {
		return node.branch ? leaf(node.branch) : node;
	}

	var tmp;

	var generators = {
		IDENT: function(node, variant) {
			var inst = (variant || '') + "V";
			used[inst] = true;
			return inst + "('" + node.value.toUpperCase() + "')";
		},
		CLAS: function(node, variant) {
			if (node.field && node.field.length) {
				var inst = (variant || '') + "CV";
				used[inst] = true;
				return inst + "('" + node.letter + "','" + (node.abbrev || "") + "'," + genDefNull(node.field.toUpperCase()) + ")";
			}
			var inst = (variant || '') + "CLA";
			used[inst] = true;
			return inst + "('" + node.letter + "', '" + node.abbrev + "')";
		},

		STRING: function(node) {
			used.C = true;
			var val = node.value.replace(/\\/g, "\\\\");
			return node.value.indexOf("'") >= 0 ? 'C("' + val + '")' : "C('" + val + "')";
		},
		INTEGER: function(node) {
			used.C = true;
			return "C(" + node.value + ")";
		},
		DECIMAL: function(node) {
			used.DECIMAL = true;
			return ('DECIMAL("' + node.value + '")');
		},
		DATE: function(node) {
			used.DATE = true;
			return "DATE(" + node.year + "," + node.month + "," + node.day + ")";
		},

		OP: function(node, variant) {
			if (variant && db.instructions[variant + node.op]) {
				used[variant + node.op] = true;
				return variant + node.op + "(" + node.args.map(genVariant(variant)).join(',') + ")";
			} else {
				used[node.op] = true;
				return node.op + "(" + node.args.map(gen0).join(',') + ")";
			}
		},
		NBRECORD: tmp = function(node) {
			used[node.tag] = true;
			return node.tag + "('" + node.clas.abbrev + "')";
		},
		UNIQID: tmp,
		ROWCOUNT: tmp,
		DIM: tmp = function(node) {
			used[node.tag] = true;
			var args = [(node.args[0].letter || ''), (node.args[0].field || node.args[0].value)].concat(node.args.slice(1));
			return node.tag + "(" + args.map(gen0).join(",") + ")";
		},
		TYPE: function(node) {
			used.TYPE = true;
			return "TYPE('" + (node.letter || '') + "','" + node.field + "')";
		},
		FCALL: function(node, variant) {
			var inst = (variant || '') + "F";
			used[inst] = true;
			if (node.name === 'TYPE') variant = "TYPE";

			if (node.name === 'PARSE' && node.args.length == 1) {
				// Special treatment for managing parse last optional parameter
				node.args.push({
					tag: "INTEGER",
					value: 0,
					line: node.args[0].line,
					col: node.args[0].col
				});
			}
			if (node.name === "FIND" && node.args && node.args[1].tag === "PROP") {
				return inst + "('FINDOBJ',[" + gen(node.args[0]) + "," + gen(node.args[1].target.target) + ",C('" + node.args[1].name + "')," + gen(node.args[1].target.args) + "])";
			}
			return inst + "('" + node.name + "'" + (node.args ? ",[" + node.args.map(genVariant(variant)).join(",") + "]" : "") + ")";

		},
		EVALUE: function(node, variant) {
			var inst = (variant || '') + "EVALUE";
			used[inst] = true;
			return inst + "(r, e, " + gen(node.arg) + ")";
		},
		SIGMA: function(node) {
			used.SIGMA = true;
			return "SIGMA('" + node.field + "',[" + node.args.map(gen0).join(",") + "])";
		},
		SORTA: function(node) {
			used.SORTA = true;
			return insert(node, "SORTA(" + gen(node.rep) + ",[" + (node.vars || []).map(gen0) + "],[" + ((node.order && node.order.exps) || []).map(gen0) + "]" + ",C(" + (node.order && node.order.direction ? node.order.direction : 1) + "))");
		},
		INSA: tmp = function(node) {
			used[node.tag] = true;
			return insert(node, node.tag + "([" + node.intExps.map(gen0) + "],[" + node.vars.map(gen0) + "])");
		},
		DELA: tmp,
		INDEX: function(node, variant) {
			var inst = (variant || '') + "INDEX";
			used[inst] = true;
			return (variant || '') + "INDEX(" + gen(node.target, variant) + ",[" + node.args.map(gen0) + "])";
		},
		DECL: function(node) {
			var fctRANGE = ["CHAR", "CLBFILE", "BLBFILE"];
			used.DECL = true;
			var charDefaultLens = (fctRANGE.indexOf(node.type) === 0) ? 30 : 1;
			//var charDefaultLens = 30;
			//console.log("DECL node0="+JSON.stringify(node));
			return node.items.map(function(decl) {
				// console.log("DECL node="+JSON.stringify(node));
				// TODO: dims, using and sized
				var key = (variables.dictClasses[node.mode] || '?') + (types[node.type] || '?');
				if (key.indexOf('?') >= 0) warn && warn(node, "unsupported decl: mode=" + node.mode + ", type=" + node.type);
				if (decl.tag === 'PARAM') {
					if (fctRANGE.indexOf(node.type) >= 0 && decl.ranges && decl.ranges.length === 1 && !decl.ranges[0]) {
						// Value Char A()() is equivalent to Value Char A()(0..)
						decl.ranges = [{
							tag: "OP",
							line: decl.line,
							col: decl.col + 3,
							op: "RANGE",
							isAssign: false,
							args: [{
								tag: "INTEGER",
								line: decl.line,
								col: decl.col + 2,
								value: 0,
							}]
						}];
					} else if (fctRANGE.indexOf(node.type) < 0 && decl.lens && !decl.lens[0] && !decl.lens[1]) {
						// Value Integer A() is equivalent to Value Integer A(0..)
						decl.lens = null;
						decl.ranges = [{
							tag: "OP",
							line: decl.line,
							col: decl.col + 3,
							op: "RANGE",
							isAssign: false,
							args: [{
								tag: "INTEGER",
								line: decl.line,
								col: decl.col + 2,
								value: 0,
							}]
						}];

					}
				} else if (decl.tag === 'ITEM') {
					if (config.optimize && node.type == "CHAR" && decl.ranges === null) {
						//DECL('LS20','A1','') 
						//is faster than
						//DECL('LS','A1','',A([C(20)]))
						if (decl.lens === null) {
							return insert(decl, "DECL('" + key + charDefaultLens + "','" + decl.name + "'" + //
								(decl.using ? "," + gen(decl.using) : ",''") + //
								")");
						}
						if (decl.lens.length === 1 && decl.lens[0].tag === "INTEGER") {
							key += decl.lens[0].value || charDefaultLens;
							return insert(decl, "DECL('" + key + "','" + decl.name + "'" + //
								(decl.using ? "," + gen(decl.using) : ",''") + //
								")");
						}
					}

					if (fctRANGE.indexOf(node.type) >= 0 && decl.ranges && decl.ranges.length === 1 && !decl.ranges[0].args) {
						// Local Char A(10)(6) is equivalent to Local Char A(10)(0..5)
						decl.ranges = [{
							tag: "OP",
							line: decl.ranges[0].line,
							col: decl.ranges[0].col,
							op: "RANGE",
							isAssign: false,
							args: [{
								tag: "INTEGER",
								line: decl.ranges[0].line,
								col: decl.ranges[0].col,
								value: 0,
							}, {
								tag: "INTEGER",
								line: decl.ranges[0].line,
								col: decl.ranges[0].col,
								value: decl.ranges[0].value - 1
							}]
						}];
					} else if (fctRANGE.indexOf(node.type) >= 0 && !decl.ranges && (!decl.lens || decl.lens[0].value === 0)) {
						decl.lens = [{
							tag: "INTEGER",
							line: 0,
							col: 0,
							value: charDefaultLens
						}];
					} else if (fctRANGE.indexOf(node.type) < 0 && decl.lens && decl.lens.length === 1 && !decl.lens[0].args) {
						// Local Integer A(6) is equivalent to Local Integer A(0..5)
						decl.ranges = [{
							tag: "OP",
							line: decl.lens[0].line,
							col: decl.lens[0].col,
							op: "RANGE",
							isAssign: false,
							args: [{
								tag: "INTEGER",
								line: decl.lens[0].line,
								col: decl.lens[0].col,
								value: 0,
							}]
						}];
						if (typeof decl.lens[0].value == 'number') {
							decl.ranges[0].args[1] = {
								tag: "INTEGER",
								line: decl.lens[0].line,
								col: decl.lens[0].col,
								value: decl.lens[0].value - 1
							};
						} else {
							decl.ranges[0].args[1] = {
								tag: "OP",
								line: decl.ranges[0].line,
								col: decl.ranges[0].col,
								op: "SUB",
								isAssign: false,
								args: [{
									tag: "IDENT",
									line: decl.ranges[0].line,
									col: decl.ranges[0].col,
									value: decl.lens[0].value
								}, {
									tag: "INTEGER",
									line: decl.ranges[0].line,
									col: decl.ranges[0].col,
									value: 1
								}]
							};
						}
						decl.lens = null;
					}
				}
				return insert(decl, "DECL('" + key + "','" + decl.name + "'" + //
					(decl.using ? "," + gen(decl.using) : ",''") + //
					(decl.lens ? "," + gen(decl.lens) : "") + //
					(decl.ranges ? "," + gen(decl.ranges) : "") + //
					")");
			}).join("");
		},
		STATEMENT: function(node) {
			used[node.op] = true;

			if (config.optimize && node.op === "SET" && node.lhs.tag == "IDENT") {
				var val;
				if (node.rhs.tag == "INTEGER")
					val = node.rhs.value;
				else if (node.rhs.tag == "STRING") {
					var val = node.rhs.value.replace(/\\/g, "\\\\");
					val = val.indexOf("'") >= 0 ? '"' + val + '"' : "'" + val + "'";
				}
				if (val !== undefined)
					return insert(node, node.op + "(" + gen(node.lhs) + "," + val + ")");

			}

			return insert(node, node.op + "(" + gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		DEFAULT: function(node) {
			used[node.tag] = true;
			if (node.classes)
				return insert(node, "DEFAULT(" + ")");
			else
				return insert(node, "DEFAULT('" + node.scope + "', " + gen(node.file) + ")");
		},
		ASSIGN: function(node) {
			used.ASSIGN = true;
			return insert(node, "ASSIGN(" + gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		SETLOB: function(node) {
			used.SET = true;
			return insert(node, "SET(" + gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		RAZ: function(node) {
			used.RAZ = true;
			return insert(node, "RAZ([" + node.expressions.map(gen0) + "])");
		},
		KILL: function(node) {
			used.KILL = true;
			return insert(node, "KILL([" + node.expressions.map(gen0) + "])");
		},
		DYN: function(node) {
			return gen(node.exp);
		},
		GOSUB: tmp = function(node) {
			used.REQ = true;
			used.C = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used[node.tag] = true;
			if (!node.label && node.tag != "ONERRGO") throw error(node, "label missing");
			return insert(node, node.tag + "(" + from + (node.label ? ",'" + node.label + "'" : "") + ")");
		},
		ONERRGO: tmp,
		GOTO: tmp,
		LABEL: function(node) {
			used.GO = true;
			scopeName = node.name;
			return insert(null, "GO(e,'" + node.name + "')", "e." + node.name + "=B(", ");");
		},
		RETURN: function(node) {
			used.RET = true;
			return insert(node, "RET(" + (node.result ? gen(node.result) : "") + ")", " ", ""); // beg is space to force close
		},
		RESUME: function(node) {
			used.RESUME = true;
			return insert(node, "RESUME()", " ", ""); // beg is space to force close
		},
		SUBPROG: tmp = function(node) {
			used.PROG = true;
			scopeName = node.name;
			return insert(null, "", "PROG(e,'" + node.name + "',[" + node.items.map(quote) + "],B(", "));");
		},
		FUNPROG: tmp,
		END: function(node) {
			used.END = true;
			return insert(node, "END(" + (node.result ? gen(node.result) : "") + ")", " ", ""); // beg is space to force close
		},

		CALL: function(node) {
			used.REQ = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used.CALL = true;
			return insert(node, "CALL(" + from + "," + gen(node.name) + ",[" + (node.args || []).map(gen0) + "])");
		},
		FUNC: function(node) {
			used.REQ = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used.CALL = true;
			return "CALL(" + from + "," + gen(node.name) + ",[" + (node.args || []).map(gen0) + "])";
		},
		PROP: function(node) {
			if (node.name.toUpperCase() !== "SNAPSHOT") {
				used.PROP = true;
				return "PROP(" + gen(node.target) + ",'" + node.name + "')";
			} else {
				used.SNAP = true;
				return "SNAP(" + gen(node.target) + ")";
			}
		},
		ATT: function(node) {
			used.ATT = true;
			if (!node.target.target || node.target.tag === 'INDEX')
				return "ATT(" + gen(node.target) + ",null,'" + node.name + "')";

			return "ATT(" + gen(node.target.target) + "," + ("'" + node.target.name + "'") + ",'" + node.name + "')";
		},
		FMET: function(node) {
			used.XMET = true;
			if (node.name === 'AGETATTR') {
				used.AGETATTR = true;

				if (!node.target.target || node.target.tag === 'INDEX')
					return "AGETATTR(" + gen(node.target) + "," + "null" + "," + gen(node.args[0]) + ")";
				//else
				return "AGETATTR(" + gen(node.target.target) + "," + ("'" + node.target.name + "'") + "," + gen(node.args[0]) + ")";
			}
			if (node.name === 'ASETATTR') {
				used.ASETATTR = true;

				if (!node.target.target || node.target.tag === 'INDEX')
					return "ASETATTR(" + gen(node.target) + "," + "null" + "," + gen(node.args[0]) + "," + gen(node.args[1]) + ")";
				//else
				return "ASETATTR(" + gen(node.target.target) + "," + ("'" + node.target.name + "'") + "," + gen(node.args[0]) + "," + gen(node.args[1]) + ")";
			}
			if (node.name === 'AGETCOLUMNATTR') {
				used.AGETCOLUMNATTR = true;
				return "AGETCOLUMNATTR(" + gen(node.target.target) + ",'" + node.target.name + "'," + gen(node.args[0]) + "," + gen(node.args[1]) + ")";
			}
			if (node.name === 'ASETCOLUMNATTR') {
				used.ASETCOLUMNATTR = true;
				return "ASETCOLUMNATTR(" + gen(node.target.target) + ",'" + node.target.name + "'," + gen(node.args[0]) + "," + gen(node.args[1]) + "," + gen(node.args[2]) + ")";
			}
			if (['AADD', 'ADEL'].indexOf(node.name) >= 0) {
				used[node.name] = true;
				return node.name + "(" + gen(node.target) + "," + gen(node.args[0]) + ")";
			}
			return "XMET(" + gen(node.target) + ",'" + node.name + "',[" + node.args.map(gen0) + "])";
		},
		CALLMET: function(node) {
			used.XMET = true;
			if (node.name === 'ASETATTR') {
				used.ASETATTR = true;
				if (!node.target.target || node.target.tag === 'INDEX')
					return insert(node, "ASETATTR(" + gen(node.target) + "," + null + "," + gen(node.args[0]) + "," + gen(node.args[1]) + ")");
				//else
				return insert(node, "ASETATTR(" + gen(node.target.target) + "," + "'" + node.target.name + "'" + "," + gen(node.args[0]) + "," + gen(node.args[1]) + ")");

			}
			if (node.name === 'ASETCOLUMNATTR') {
				used.ASETCOLUMNATTR = true;
				return insert(node, "ASETCOLUMNATTR(" + gen(node.target.target) + ",'" + node.target.name + "'," + gen(node.args[0]) + "," + gen(node.args[1]) + "," + gen(node.args[2]) + ")");
			}
			if (['AADD', 'ADEL'].indexOf(node.name) >= 0) {
				used[node.name] = true;
				return insert(node, node.name + "(" + gen(node.target) + "," + gen(node.args[0]) + ")");
			}
			return insert(node, "XMET(" + gen(node.target) + ",'" + node.name + "',[" + node.args.map(gen0) + "])");
		},

		IF: function(node) {
			used.IF = used.GO = true;
			return insert(node, "IF(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "", ",GO(p," + id(leaf(node)) + ")))");
		},
		ELSIF: function(node) {
			return insert(node, "", "p[" + id(node) + "]=IF(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", ",GO(p," + id(leaf(node)) + ")));");
		},
		ELSE: function(node) {
			used.GO = true;
			return insert(node, "", "p[" + id(node) + "]=B(", ",GO(p," + id(leaf(node)) + "));");
		},
		ENDIF: genClosing,

		CASE: function(node) {
			used.CASE = true;
			return insert(node, "CASE(" + gen(node.expression) + ",p," + id(node.branch) + "," + id(leaf(node)) + ")", "", "");
		},
		WHEN: function(node) {
			used.WHEN = used.GO = true;
			return insert(node, "", "p[" + id(node) + "]=WHEN([" + node.expressions.map(gen0) + "],p," + id(node.branch) + ",B(", ",GO(p," + id(leaf(node)) + ")));");
		},
		ENDCASE: genClosing,

		KEY: function(node) {
			used.KEY = true;
			return "KEY('" + (node.letter || '') + "','" + (node.abbrev || '') + "','" + (node.field || '') + "'" + (node.indices ? ",[" + node.indices.map(gen0) + "]" : "") + ")";
		},
		HINT: function(node) {
			used.HINT = true;
			return "HINT(" + node.nohint + ", " + ((node.nohint) ? "null" : gen(node.key)) + ")";
		},
		WHEREKEY: function(node) {
			used.SQLKEY = true;
			return "SQLKEY('" + node.keyName + "','" + node.op + "'," + gen(node.keyIndice) + ",[" + node.keyValues.map(genVariant("SQL")) + "])";
		},
		SQLDECL: function(node) {
			used.SQLDECL = true;
			var key = ' ' + (types[node.type] || '?');
			if ((node.lens) && (node.lens.length === 1)) key += node.lens[0].value;
			return "SQLDECL('" + key + "', '" + node.name + "')";
		},
		FOR: function(node) {
			used.GO = used.DECL = used.SET = used.WHILE = used.V = true;
			var setup;
			if (node.key) {
				used.FORF = true;
				return insert(node, "FORF(" + gen(node.key) + "," + ((node.hint) ? gen(node.hint) : "null") + "," + ((node.lock) ? "true" : "false") + "," + generators.WHERE(node.where) + ", [" + (node.from || []).map(gen0) + "], [" + (node.to || []).map(gen0) + "],p," + id(node.branch) + ",B(", "", "))");
			} else if (node.from) {
				used.FORV = true;
				return insert(node, "FORV('" + node.varName + "'," + gen(node.from) + "," + gen(node.to) + "," + genDefNull(node.step) + ",p," + id(node.branch) + ",B(", "", "))");
			} else if (node.ins) {
				used.FORIN = true;
				return insert(node, "FORIN('" + node.varName + "',[" + node.ins.map(gen0) + "],p," + id(node.branch) + ",B(", "", "))");
			} else if (node.sql) {
				used.FORSQL = true;
				return insert(node, "FORSQL(" + gen(node.sql.sql) + ", '" + node.sql.as.abbrev + "', [" + node.sql.vars.map(gen0) + "] ,p," + id(node.branch) + ",B(", "", "))");
			} else {
				return genNiy(node, true);
			}
		},
		NEXT: genClosing,
		WHILE: function(node) {
			used.GO = used.WHILE = true;
			//return insert(node, "GO(p," + id(node) + ")", "p[" + id(node) + "]=WHILE(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "));");
			return insert(node, "WHILE(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "", "))");
		},
		WEND: genClosing,
		REPEAT: function(node) {
			used.GO = used.WHILE = true;
			return insert(node, "WHILE(" + gen(node.branch.condition) + ",p," + id(node.branch) + ",B(", "", "),true)");
		},
		UNTIL: genClosing,
		BREAK: function(node) {
			used.BREAK = true;
			return insert(node, "BREAK(p," + (node.level ? gen(node.level) : "C(1)") + ')');
		},
		EXECSQL: function(node) {
			used.EXECSQL = true;
			return insert(node, "EXECSQL(" + gen(node.sql) + ")");
		},
		ANASQL: function(node) {
			used.ANASQL = true;
			return insert(node, "ANASQL(" + gen(node.sql) + "," + gen(node.using) + ")");
		},
		FILES: function(node) {
			// TODO: worry about node.scope
			return node.files.map(function(node) {
				var abbrev = node.clas && node.clas.abbrev;
				if (node.vars) {
					var tag = node.fromVar ? "FILEVAL" : "FILESYS";
					used[tag] = true;
					return insert(node, tag + "(" + genDefNull(node.as) + ",[" + node.vars.map(gen0) + "]," + gen(node.fromVar || node.fromSys) + ")");
					throw error(node, "unsupported FILE syntax");
				} else {
					used.FILESQL = true;
					return insert(node, "FILESQL(" + genDefNull(abbrev) + "," + gen(node.name) + "," + generators.WHERE(node.where) + "," + genDefNull(node.order) + ")");
				}
			}).join("");
		},
		FILTER: function(node) {
			used.FILTER = true;
			var abbrev = node.clas && node.clas.abbrev;
			return insert(node, "FILTER(" + genDefNull(abbrev) + "," + genDefNull(node.where) + "," + genDefNull(node.order) + ")");
		},
		WHERE: function(node) {
			if (!node) return "null";
			if (!node.exps || node.exps.length !== 1) throw error(node, "unsupported where clause: " + node.exps);
			var exp = node.exps[0];
			var ands = [];
			while (exp.tag === 'OP' && exp.op === 'AND') {
				ands.push(exp.args[0]);
				exp = exp.args[1];
			}
			ands.push(exp);
			used.WHERE = true;
			return "WHERE([" + ands.map(genVariant("SQL")) + "])";
		},
		ORDER: function(node) {
			used.ORDER = true;
			var name = node.keyName ? "'" + node.keyName + "'" : "null";
			return "ORDER(" + name + ",[" + (node.keyBy || []).map(genVariant("SQL")) + "]," + genDefNull(node.keyWith) + ", " + (node.dir || "null") + ', ' + gen(node.keyIndices) + ")";
		},
		ORDERITEM: function(node, variant) {
			used.ORDERITEM = true;
			return "ORDERITEM(" + gen(node.exp, variant) + ',' + (node.dir < 0 ? "'-'" : "'+'") + ")";
			//return "'" + (node.dir < 0 ? '-' : '+') + node.name + "'";
		},
		COLUMN: function(node) {
			used.COLUMNSITEM = true;
			return "COLUMNSITEM( '" + (node.abbrev || '') + "'," + ((node.field) ? "'" + (node.field) + "'" : "null") + "," + ((node.nodeOpt) ? node.nodeOpt.map(gen0) : "null") + ")";
		},
		COLUMNS: function(node) {
			used.COLUMNS = true;
			var a = insert(node, "COLUMNS('" + (node.clas.abbrev || '') + "'" + (node.columns ? ", [" + node.columns.map(gen0) + "]," + ((node.isExtended) ? "true" : "false") : '') + ")");
			return a;
		},
		LINK: function(node) {
			used.LINK = true;
			return insert(node, "LINK('" + node.clas.abbrev + "','" + node.as.abbrev + "',[" + node.items.map(gen0) + "]," //
				+
				genDefNull(node.where) + "," + genDefNull(node.order) + ")");
		},
		LINKITEM: function(node) {
			used.LINKITEM = true;
			return "LINKITEM(" + gen(node.key, "SQL") + "," + node.outer + ",[" + node.values.map(genVariant("SQL")) + "])";
		},
		READLOCK: function(node) {
			used.READ = true;
			var abbrev = node.clas && node.clas.abbrev;
			// todo: hint and lockWait
			return insert(node, "READ(" + gen(node.key, "SQL") + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "], true, " + ((node.hint) ? gen(node.hint) : "null") + ")");
		},
		LOOK: function(node) {
			used.LOOK = true;
			var abbrev = node.clas && node.clas.abbrev;
			return insert(node, "LOOK(" + gen(node.key, "SQL") + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "])");
		},
		READ: function(node) {
			used.READ = true;
			var abbrev = node.clas && node.clas.abbrev;
			// todo: hint and lockWait
			return insert(node, "READ(" + gen(node.key, "SQL") + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "], false, " + ((node.hint) ? gen(node.hint) : "null") + ")");
		},
		WRITE: function(node) {
			used.WRITE = true;
			var abbrev = node.clas && node.clas.abbrev;
			return insert(node, "WRITE(" + (abbrev ? "'" + abbrev + "'" : "undefined") + ")");
		},
		REWRITE: function(node) {
			used.REWRITE = true;
			return insert(node, "REWRITE(" + gen(node.key, "SQL") + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "])");
		},
		DELETE: function(node) {
			used.DELETE = true;
			if (!node.key || !node.key.abbrev) throw error("NIY: Delete not followed by [ABREV]");
			return insert(node, "DELETE(" + gen(node.key, "SQL") + ", " + generators.WHERE(node.where) + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "])");
		},
		ASSIGNUPDATE: function(node, variant) {
			used.ASSIGNUPDATE = true;
			return "ASSIGNUPDATE(" + gen(node.lhs, variant) + ", " + gen(node.rhs, variant) + ")";
		},
		UPDATE: function(node) {
			used.UPDATE = true;
			return insert(node, "UPDATE('" + (node.clas.abbrev || "") + "', " + generators.WHERE(node.where) + ", [" + (node.assignments || []).map(genVariant("SQL")) + "])");
		},
		TRBEGIN: function(node) {
			used.TRBEGIN = true;
			return insert(node, "TRBEGIN()"); //[" + node.vcs.map(gen0) + "])");
		},
		COMMIT: function(node) {
			used.COMMIT = true;
			return insert(node, "COMMIT()");
		},
		ROLLBACK: function(node) {
			used.ROLLBACK = true;
			return insert(node, "ROLLBACK()");
		},
		LOGICCLOSE: function(node) {
			var instr = 'LOGICCLOSE';
			used[instr] = true;
			var abbrevs = (node.classes || []).map(function(cl) {
				return "'" + cl.abbrev + "'";
			}).join(',');
			return insert(node, instr + "('" + node.scope + "',[" + abbrevs + "])");
		},
		OPEN: function(node) {
			used.OPEN = used.CLOSE = true;
			var abbrev = node.using ? node.using.abbrev : '';
			if (node.name) return insert(node, "OPEN('" + abbrev + "'," + gen(node.name) + ",'" + node.mode + "'" + (node.seek ? "," + gen(node.seek) : "") + ")");
			else return insert(node, "CLOSE('" + abbrev + "')");
		},
		CLOSE: function(node) {
			var instr = 'CLOSE' + node.target;
			used[instr] = true;
			var abbrevs = (node.classes || []).map(function(cl) {
				return "'" + cl.abbrev + "'";
			}).join(',');
			if (node.scope) return insert(node, instr + "('" + node.scope + "',[" + abbrevs + "])");
			// Doesn't support Close File and Close Mask
			return genNiy(node, true);
		},
		IOMODE: function(node) {
			used.IOMODE = true;
			var abbrev = node.using ? node.using.abbrev : '';
			return insert(node, "IOMODE('" + abbrev + "','" + node.mode + "'," + gen(node.value) + ")");
		},
		WRSEQ: function(node) {
			used.WRSEQ = true;
			var abbrev = node.using ? node.using.abbrev : '';
			return insert(node, "WRSEQ('" + abbrev + "'," + gen(node.values) + (node.sep ? "," + gen(node.sep) : "") + ")");
		},
		RDSEQ: function(node) {
			used.RDSEQ = true;
			var abbrev = node.using ? node.using.abbrev : '';
			//return insert(node, "RDSEQ('" + abbrev + "'," + gen(node.exps) + ")");
			return insert(node, "RDSEQ('" + abbrev + "'," + "[" + node.exps.map(gen0).join(',') + "]" + ")");
		},
		PUTSEQ: function(node) {
			used.PUTSEQ = true;
			var abbrev = node.using ? node.using.abbrev : '';
			//var sized = node.sized ? node.using.abbrev : 0;
			//if (sized) return insert(node, "PUTSEQ('" + abbrev + "'," + gen(node.count) + ",[" + node.exps.map(gen0).join(',') + "]," + gen(node.sized) + ")");
			return insert(node, "PUTSEQ('" + abbrev + "'," + gen(node.count) + ",[" + node.exps.map(gen0).join(',') + "])");
		},
		GETSEQ: function(node) {
			used.GETSEQ = true;
			var abbrev = node.using ? node.using.abbrev : '';
			var sized = node.sized ? node.sized : 0;
			return insert(node, "GETSEQ('" + abbrev + "'," + gen(node.count) + ",[" + node.exps.map(gen0).join(',') + "]," + gen(node.sized) + ")");
		},
		SEEK: function(node) {
			used.SEEK = true;
			var abbrev = node.using ? node.using.abbrev : '';
			return insert(node, "SEEK('" + abbrev + "','" + node.mode + "'," + gen(node.direction) + "," + gen(node.value) + ")");
		},
		CALLJS: function(node) {
			used.CALLJS = true;
			return insert(node, "CALLJS(" + gen(node.mode) + "," + gen(node.from) + ",'" + node.name + "'" + (node.args ? ',' + genArray(node.args) : "") + ")");
		},
		ERRBOX: function(node) {
			used.BOX = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "BOX('error',[" + gen(node.arg) + "])");
		},
		INFBOX: function(node) {
			used.BOX = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "BOX('info',[" + node.args.map(gen0) + "])");
		},
		DBGETNA: function(node) {
			used.DBGETNA = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "DBGETNA([" + gen(node.arg) + "])");
		},
		SLEEP: function(node) {
			used.SLEEP = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "SLEEP([" + gen(node.arg) + "])");
		},
		NEWINSTANCE: function(node) {
			used.NEW = true;
			return "NEW(" + gen(node.clas) + ")";
		},
		FREEINSTANCE: function(node) {
			used.FREE = true;
			// we could omit it completely!
			return ""; //insert(node, "FREE(" + gen(node.arg) + ", false)");
		},
		FREEGROUP: function(node) {
			used.FREE = true;
			// we could omit it completely!
			return ""; //insert(node, "FREE(" + gen(node.arg) + ", true)");
		},
		APPEND: function(node) {
			used.F = true;
			return insert(node, "F('APPEND',[" + node.args.map(gen0) + "])");
		},
		NULL: function(node) {
			used.C = true;
			return "C(null)";
		},
	};

	function genNiy(node, topLevel) {
		used.NIY = true;
		var str = "NIY({";
		var comma = "";
		for (var key in node) {
			if (node.hasOwnProperty(key) && key !== 'line' && key !== 'col' && key !== 'parentLoop' && key !== 'chainType' && key !== 'branch') {
				var val = node[key];
				str += comma + key + ":" + gen0(val);
				comma = ",";
			}
		}
		str += "})";
		//console.log("skipping " + node.tag)
		return topLevel ? insert(node, str) : str;
	}

	function gen(node, variant, topLevel) {
		used.A = true;
		if (node == null) return "C(null)"; // for now
		if (Array.isArray(node)) return ("A([" + node.map(gen0).join(',') + "])");
		if (node.tag == null) return "'" + node.toString() + "'";
		var fn = generators[node.tag];
		if (fn) return fn(node, variant);
		else {
			return genNiy(node, topLevel);
		}

	}

	function genDefNull(node) {
		return node ? gen(node) : "null";
	}

	function gen0(node) { // for map, etc.
		return gen(node);
	}

	function quote(s) {
		return "'" + s + "'";
	}

	function genVariant(variant) {
		return function(node) {
			return gen(node, variant);
		};
	}
	//console.log(node);
	var statements = node.statements;
	//var returns = false;
	for (var i = 0, len = statements.length; i < len; i++) {
		var statement = statements[i];
		while (line < statement.line) {
			result += "\n";
			line++;
		}
		result += gen(statement, false, true);
		//returns = statement.returns;
	}
	result += insert(node, "", "\n", "");

	// stub for standalone evaluation
	var head = "var rt = require('etna-engine/lib/runtime'),z=rt.instructions";
	//var head = "var rt = require('"+require("path").join(__dirname, '../..').replace(/\\/g, '/')+ "/etna-engine/lib/runtime'),z=rt.instructions";
	head += ",r=typeof(requireScript)==='undefined'?rt.requireScript:requireScript";
	head += ",e=exports,p=[],B=z.B,NL=z.NL";
	for (var key in used) {
		head += "," + key + "=z." + key;
	}
	return head + ";z.BEGIN(module);NL(0);" + result;
};