"use strict";
var Parser = require("etna-engine/lib/parser").Parser;
var dates = require('etna-engine/lib/runtime/dates');
var tdate = require('etna-engine/lib/runtime/tdate');

exports.generate = function(node) {
	//console.log("jmqlgen:" + JSON.stringify(node));

	var VALUES = ["STRING"];

	var eqValue = function(ident, fct) {
		return function(filter) {
			filter = filter || {};
			filter[ident] = fct(filter);
			return filter;
		};

	};
	var opValue = function(operator, ident, fct) {
		return function(filter) {
			filter = filter || {};
			filter[ident] = filter[ident] || {};
			filter[ident][operator] = fct(filter);
			return filter;
		};

	};

	function likeValue(ident, value) {
		return function(filter) {
			filter = filter || {};
			filter[ident] = filter[ident] || {};
			filter[ident].$regex = value;
			filter[ident].$options = "i";
			return filter;
		};
	}

	var addOpValue = function(op, rop) {
		return function(node) {
			var ident;
			if (node.args[0].tag === 'IDENT') return opValue(op, node.args[0].value, gen(node.args[1]));
			else if (node.args[1].tag === 'IDENT') return opValue(rop, node.args[1].value, gen(node.args[0]));

			if (!ident) throw error("bad expression");
		};
	};

	var tmp;
	var operators = {
		EQ: function(node) {
			var ident;
			if (node.args[0].tag === 'IDENT') return eqValue(node.args[0].value, gen(node.args[1]));
			else if (node.args[1].tag === 'IDENT') return eqValue(node.args[1].value, gen(node.args[0]));

			if (node.args[0].tag === 'FCALL') {
				switch (node.args[0].name) {
					case 'LEFT$':
						return likeValue(node.args[0].args[0].value, node.args[1].value + ".*");
					case 'RIGHT$':
						return likeValue(node.args[0].args[0].value, ".*" + node.args[1].value);
				}
			}

			if (!ident) throw error("bad expression");

		},
		GE: addOpValue("$gte", "$lte"),
		LE: addOpValue("$lte", "$gte"),
		GT: addOpValue("$gt", "$lt"),
		LT: addOpValue("$lt", "$gt"),
		AND: function(node) {
			var exps = node.args.reduce(function(r, arg) {
				r.push(gen(arg));
				return r;
			}, []);
			return function(filter) {
				return exps.reduce(function(r, exp) {
					exp(r);
					return r;
				}, filter || {});
			};

		},
		OR: function(node) {
			var exps = node.args.reduce(function(r, arg) {
				r.push(gen(arg));
				return r;
			}, []);

			return function(filter) {
				filter = filter || {};
				filter.$or = [];
				return exps.reduce(function(r, exp) {
					r.$or.push(exp());
					return r;
				}, filter);
			};
		},
		SUB: function(node) {
			var lhs = gen(node.args[0]);
			var rhs = gen(node.args[1]);
			return function() {
				var l = lhs();
				var r = rhs();
				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Sub(r);
					return d.toJsDate();
				}
				return l - r;
			};

		},
		ADD: function(node) {
			var lhs = gen(node.args[0]);
			var rhs = gen(node.args[1]);
			return function() {
				var l = lhs();
				var r = rhs();
				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Add(r);
					return d.toJsDate();
				}
				return l + r;
			};

		},
		STRING: tmp = function(node) {
			return function() {
				return node.value;
			};
		},
		INTEGER: tmp,
		DATE$: function(node) {
			return function() {
				return dates.functions.DATE$.fn().toJsDate();
			};
		}
	};

	function gen(node) {
		var fn = (node.tag === 'FCALL') ? operators[node.name] : (operators[node.op] || operators[node.tag]);
		if (fn) return fn(node);
	}
	return gen(node);
};

exports.x3ToJmql = function(expression) {
	var parsed = new Parser("CONDITION=(" + expression + ")").parse();
	return exports.generate(parsed.node.statements[0].rhs);
};