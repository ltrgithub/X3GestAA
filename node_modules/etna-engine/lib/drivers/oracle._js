"use strict";

var ez = require('ez-streams');
var crypto = require('crypto');
var ezoracle = require('ez-oracle');
var oracle = require('oracledb');
var date = require("syracuse-core/lib/types/date");
var datetime = require("syracuse-core/lib/types/datetime");
var common = require("./drivers-common");

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.dbms");

//tracerJs = { debug: console.error }

var _months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

function setFetchInfo(opts) {
	if (opts && opts.decimalColumns && opts.decimalColumns.length) {
		var asString = {
			type: oracle.STRING
		};
		opts.fetchInfo = {};
		for (var i = 0; i < opts.decimalColumns.length; i++) {
			opts.fetchInfo[opts.decimalColumns[i]] = asString;
		}
	}
}

module.exports = function(config) {
	config.connectString = config.hostname + (config.port ? ':' + config.port : '') + '/' + config.database;
	var trace = config.trace;
	var connections = [];
	var counters = {
		alloc: 0,
		used: 0,
		discarded: 0,
		warned: 5,
	};

	return {
		uniqid: function(name) {
			return "Select SEQ_" + name + ".nextval As A$RESULT_0 from dual";
		},
		lockClause0: function() {
			return "";
		},
		lockClause1: function() {
			return " For Update";
		},
		hintClause0: function(hnt, def) {
			// rf : read or for
			if (hnt) {
				if ((hnt.nohint) || (hnt.name === "")) return "";

				return "/*+ INDEX" + ((hnt.revert) ? "_DESC" : "") + "(" + hnt.abbrev + " " + hnt.tname + "_" + hnt.name + ") */";
			} else if (def) return "/*+ FIRST_ROWS ( 1 ) */";
			else return "";
		},
		hintClause1: function(hnt, def) {
			return "";
		},
		lengthString: function() {
			return ("length");
		},
		subString: function(arg, deb, fin) {
			return "substr(" + arg + ", " + deb + ", " + fin + ")";
		},
		toSqlLob: function(val) {
			return val.value.toString('hex');
		},
		readBlob: function(_, val) {
			return ezoracle.lob.reader(val).readAll(_);
		},
		readClob: function(_, val) {
			return ezoracle.lob.reader(val).readAll(_);
		},
		toSqlUuid: function(val) {
			return val.x3ToSqlString();
		},
		toSqlDate: function(val) {
			var date;
			if ('string' === typeof(val))
				date = Date.parse(val);
			else {
				// Assume the val is a Date object
				date = val;
			}

			function pad(n, width) {
				n = n + '';
				return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
			}
			// return "TO_DATE('" + date.getUTCFullYear() +
			// 	'-' + pad(date.getUTCMonth() + 1, 2) +
			// 	'-' + pad(date.getUTCDate(), 2) +
			// 	' ' + pad(date.getUTCHours(), 2) +
			// 	':' + pad(date.getUTCMinutes(), 2) +
			// 	':' + pad(date.getUTCSeconds(), 2) +
			// 	"', 'YYYY-MM-DD HH24:MI:SS')";
			return date;
		},

		isNullUuid: function(val) {
			return (val === null) || (val === undefined) || (val === "00000000000000000000000000000000");
		},
		nullDate: function() {
			return new Date(Date.UTC(1599, 11, 31));
		},
		isNullDate: function(val) {
			return (val === null) || (val === undefined) || (val && (val.getFullYear() === 1599) && (val.getMonth() === 11) && (val.getDate() === 31));
		},
		escape: function(name) {
			return '"' + name + '"';
		},
		param: function(i) {
			return ':' + (i + 1);
		},
		beginTransaction: function(_, cnx) {
			cnx.executeOptions.autoCommit = false;
			cnx.commit(_);
		},
		commitTransaction: function(_, cnx) {
			cnx.commit(_);
			cnx.executeOptions.autoCommit = true;
		},
		rollbackTransaction: function(_, cnx) {
			cnx.rollback(_);
			cnx.executeOptions.autoCommit = true;
		},
		allocConnection: function(_) {
			var cnx = connections.pop();
			if (!cnx) {
				counters.alloc++;
				// temporary debugging to test code sanity
				if (counters.alloc > counters.warned) {
					counters.warned++;
					console.error('CONCURRENT CONNECTIONS', counters.alloc);
					if (counters.alloc > 100) throw new Error("Too many Oracle connections!!!");
				}
				trace && trace("connecting ...");
				cnx = oracle.getConnection(config, _);
				// driver returns values in local time so we set our session timezone to UTC to avoid offsets.
				cnx.execute("ALTER SESSION SET TIME_ZONE='00:00'", _);

				// prefetch row count should be set in execute
				//cnx.setPrefetchRowCount(config.setPrefetchRowCount || 50);
				//cnx.setPrefetchRowCount(1);
				//cnx.setNumberStringFormat("99999999999999999999.99999999999999999999");
				cnx.executeOptions = {
					autoCommit: true,
					outFormat: oracle.OBJECT,
				};
			}
			counters.used++;
			return cnx;
		},
		releaseConnection: function(cnx, err) {
			counters.used--;
			if (err) {
				console.error(err);
				// don't reuse it
				counters.discarded++;
			} else {
				connections.push(cnx);
			}
		},
		withConnection: function(_, body) {
			var cnx = this.allocConnection(_);
			try {
				return body(_, cnx);
			} finally {
				this.releaseConnection(cnx);
			}
		},
		execute: function(_, cnx, sql, args, opts) {
			if (typeof cnx === "string") {
				opts = args;
				args = sql;
				sql = cnx;
				cnx = null;
			}
			if (cnx == null) {
				var self = this;
				return self.withConnection(_, function(_, cnx) {
					return self.execute(_, cnx, sql, args, opts);
				});
			}
			tracerJs.debug && tracerJs.debug("execute " + sql + ",args=\n" + (args || []).map(function(arg, i) {
				return ":" + (i + 1) + "=" + arg;
			}).join('\n'));
			var oraOpts = {
				outFormat: cnx.executeOptions.outFormat,
				autoCommit: cnx.executeOptions.autoCommit,
			};
			opts = opts || {};
			if (opts.outputVars && opts.outputVars.length > 0) {
				// convert args array to an object
				args = (args || []).reduce(function(r, v, i) {
					r[i + 1] = v;
					return r;
				}, {});
				// add output vars to the args object.
				opts.outputVars.forEach(function(v) {
					var type = oracle[v.type];
					if (typeof type !== "number") throw new Error("invalid type: " + v.type);
					args[v.name] = {
						dir: oracle.BIND_OUT,
						type: type,
					};
				});
			}
			if (opts.decimalColumns) {
				oraOpts.decimalColumns = opts.decimalColumns;
				setFetchInfo(oraOpts);
			}

			var result = cnx.execute(sql, args || [], oraOpts, _);
			if (result.rows) return result.rows;
			else {
				return {
					updateCount: result.rowsAffected,
					outputVars: opts.outputVars && opts.outputVars.map(function(v) {
						var os = result.outBinds[v.name][0];
						return ez.devices.generic.writer(function(_, data) {
							return data === undefined ? os.end() : os.write(data, _);
						});
					}),
				};
			}
		},
		reader: common.reader(function(_, cnx, sql, args, opts) {
			setFetchInfo(opts);
			return ezoracle.reader(cnx, sql, args || [], opts);
		}),
		writer: common.writer(function(_, cnx, sql, opts) {
			return ezoracle.writer(cnx, sql);
		}),
		dropIndexSql: function(indexName, tableName) {
			return 'drop index "' + indexName + '"';
		},
		isIndexNotFound: function(ex) {
			return /ORA-01418/.test(ex.message);
		},
		isTableNotFound: function(ex) {
			return /ORA-00942/.test(ex.message);
		},
		isUniqueViolated: function(ex) {
			return /ORA-00001/.test(ex.message);
		},
		isLocked: function(ex) {
			return /ORA-00060/.test(ex.message);
		},
		isNoRecord: function(ex) {
			return /ORA-01403/.test(ex.message);
		},
		blobType: function() {
			return "BLOB";
		},
		clobType: function() {
			return "CLOB";
		},
		tinyIntType: function() {
			return "NUMBER(3)";
		},
		shortIntType: function() {
			return "NUMBER(5)";
		},
		intType: function() {
			return "NUMBER(10)";
		},
		stringType: function(len) {
			return "VARCHAR2(" + len + ")";
		},
		dateType: function() {
			return "DATE";
		},
		datetimeType: function() {
			return "DATE";
		},
		uuidType: function() {
			return "VARCHAR2(32)";
		},
		decimalType: function() { // for now handle as char to keep full precision
			return "VARCHAR2(32)";
		},
		backupDatabase: function(_, dbName, filename) {
			throw new Error("Not implemented !!!");
		},
		restoreDatabase: function(_, dbName, filename) {
			throw new Error("Not implemented !!!");
		},

		describeQuery: function(_, qry, folder) {
			var _this = this;
			var _tmpname = "TMPVIEW" + crypto.randomBytes(4).readUInt32LE(0);
			/* first create view */
			_this.execute(_, "Create view " + _tmpname + " as " + qry);

			try {
				var sql = "SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, DATA_SCALE, CHAR_LENGTH, CHAR_USED ";
				sql += "FROM ALL_TAB_COLUMNS ";
				sql += "WHERE OWNER='" + folder + "' AND TABLE_NAME = '" + _tmpname + "'";
				sql += "ORDER BY TABLE_NAME, COLUMN_ID";
				return _this.reader(_, sql).toArray(_).map(function(row) {
					var col = {};

					col.name = row.COLUMN_NAME;
					switch (row.DATA_TYPE) {
						case 'BLOB':
							col.type = 522;
							col.typtyp = 9;
							break;
						case 'CLOB':
							col.type = 523;
							col.typtyp = 10;
							break;
						case 'DATE':
							col.type = 3;
							col.typtyp = 8;
							break;
						case 'TIMESTAMP(3)':
							col.type = 526;
							col.typtyp = 12;
							break;
						case 'VARCHAR':
							col.type = 10 + parseInt(row.DATA_LENGTH);
							col.typtyp = 7;
							break;
						case 'VARCHAR2':
							col.type = "varchar";
							/*if ('B' !== row.CHAR_USED) {
									col.type = 10 + Math.floor((parseInt(row.DATA_LENGTH) / 3));
								} else {*/
							col.type = 10 + parseInt(row.CHAR_LENGTH);
							//}
							col.typtyp = 7;
							break;
						case 'RAW':
							if (row.DATA_LENGTH == 16) {
								col.type = 525;
								col.typtyp = 11;
							} else {
								throw new Error('Unsupported column type ' + row.DATA_TYPE + ' for column ' + row.COLUMN_NAME);
							}
							break;
						case 'NUMBER':
							var precision = parseInt(row.DATA_PRECISION);
							var scale = parseInt(row.DATA_SCALE);

							if (10 === precision && !scale) {
								col.typtyp = 3;
								col.type = 4;
							} else if (3 === precision && !scale) {
								col.type = 1;
								col.typtyp = 1;
							} else if (5 === precision && !scale) {
								col.typtyp = 2;
								col.type = 2;
							} else {
								col.typtyp = 4;
								col.type = 7;
							}
							break;
						default:
							throw new Error('Unsupported column type ' + row.DATA_TYPE + ' for column ' + row.COLUMN_NAME);
					}

					return col;
				});
			} catch (e) {
				//console.log(e.toString( ));
			} finally {
				/* delete view*/
				_this.execute(_, "Drop view " + _tmpname);
			}
		},

		/// Returns the list of all the tables defined in the database / schema
		readTables: function(_, schemaName) {
			var _this = this;
			var sql = "select TABLE_NAME from USER_TABLES order by TABLE_NAME";
			return _this.reader(_, sql).map(function(_, item) {
				return {
					schemaName: schemaName,
					tableName: item.TABLE_NAME,
				};
			}).toArray(_);
		},

		createPermissions: function(_, tableDef, config) {
			return common.createPermissions(_, this, tableDef, config);
		},

		/// Returns the definition of a table from its name.
		getTableDef: function(_, schemaName, tablename) {
			var tableDef = {
				schemaName: schemaName,
				tableName: tablename,
			};
			this.readTableSchema(_, tableDef);
			return tableDef;
		},

		/// Enhance a table definition with its columns, indices, ...
		/// 'tableDef' is an object that have been created by readTables() / getTableDef()
		readTableSchema: function(_, tableDef, tracker) {
			var _this = this;
			// ----------------------------------------
			// Read the columns of the table
			// ----------------------------------------
			var sqlQuery = "SELECT c.COLUMN_NAME, c.DATA_TYPE, c.DATA_LENGTH, c.CHAR_USED, c.CHAR_LENGTH, c.DATA_PRECISION, c.DATA_SCALE, c.NULLABLE," +
				" t.TYPTYP_0 TYPE_TYPE, t.OPTION_0 TYPE_OPTION, t.LNGTYP_0 TYPE_LENGTH," +
				" z.LONG_0 ZONE_LENGTH, z.OPTION_0 ZONE_OPTION" +
				" FROM user_tab_cols c" +
				" LEFT JOIN " + _this.getFullTableName(tableDef.schemaName, "ATABZON") + " z ON z.CODFIC_0 = c.TABLE_NAME AND c.COLUMN_NAME LIKE CONCAT(z.CODZONE_0, '\\_%') ESCAPE '\\'" +
				" LEFT JOIN " + _this.getFullTableName(tableDef.schemaName, "ATYPE") + " t ON z.CODTYP_0 = t.CODTYP_0" +
				" WHERE table_name = :1" +
				" ORDER BY COLUMN_NAME";

			//console.log(sqlQuery);process.exit(0);
			tableDef.columns = _this.reader(_, sqlQuery, [tableDef.tableName]).toArray(_).map(function(row) {
				var column = {
					name: row.COLUMN_NAME,
					isNullable: row.NULLABLE !== 'N',
				};
				switch (row.DATA_TYPE) {
					case 'DATE':
						column.type = "date";
						break;
					case 'TIMESTAMP(3)':
						column.type = "datetime";
						break;
					case 'NUMBER':
						var precision = parseInt(row.DATA_PRECISION);
						var scale = parseInt(row.DATA_SCALE);
						if (10 === precision && !scale) {
							column.type = "int";
						} else if (3 === precision && !scale) {
							column.type = "tinyint";
						} else if (5 === precision && !scale) {
							column.type = "smallint";
						} else {
							column.type = "decimal";
							if (row.TYPE_TYPE != 4) {
								var msg = "Inconsistent metadata for column " + tableDef.tableName + "." + column.name + " : types mismatch (expected 4 but got " + row.TYPE_TYPE + ")";
								if (tracker) {
									(tracker.$diagnoses = tracker.$diagnoses || []).push({
										severity: "warning",
										message: msg,
									});
								}
								console.log("WARNING : " + msg);
							}

							// precision/scale must not be extracted from user_tab_cols; instead we have to extract the format from ATYPE table
							var precision = row.ZONE_LENGTH;
							if (precision == 0) {
								// No format is specified in ATABZON, it's inherited from the type of the column (ATYPE)
								precision = row.TYPE_LENGTH;
							}

							column.decimalPrecision = Math.floor(precision);
							column.decimalScale = Math.round((precision - column.decimalPrecision) * 10);

							// Determine whether the column uses the floating point notation 
							// i.e. ATABZON.OPTION_0 ou ATYPE.OPTION_0 contains the character 'F'
							column.useFloatingPointFormat = (row.ZONE_OPTION && (row.ZONE_OPTION.indexOf('F') != -1)) || (row.TYPE_OPTION && (row.TYPE_OPTION.indexOf('F') != -1));

							// Note : in X3, 999.99 is described as 3.2 but for us, the precision includes the scale so 3.2 -> 5.2
							column.decimalPrecision += column.decimalScale;

						}
						break;
					case 'BLOB':
						column.type = "blob";
						break;
					case 'CLOB':
						column.type = "clob";
						break;
					case 'VARCHAR':
						column.type = "varchar";
						column.maxLength = parseInt(row.DATA_LENGTH);
						break;
					case 'VARCHAR2':
						column.type = "nvarchar";
						if ('B' === row.CHAR_USED) {
							// The size of the string is defined in 'BYTES', we have to convert it to 'CHAR'
							column.maxLength = parseInt(row.DATA_LENGTH) / 3;
						} else {
							column.maxLength = parseInt(row.CHAR_LENGTH);
						}
						break;
					case 'RAW':
						if (row.DATA_LENGTH == 16)
							column.type = "uuid";
						else {
							column.type = "binary";
							column.maxLength = row.DATA_LENGTH;
						}
						break;
					default:
						throw new Error('unknown column type ' + row.DATA_TYPE + ' for column ' + tableDef.tableName + '.' + column.name);
				}
				return column;
			});

			// ----------------------------------------
			// Read some properties of the table
			// ----------------------------------------
			sqlQuery = "SELECT SECURE_0 FROM " + _this.getFullTableName(tableDef.schemaName, "ATABLE") + " WHERE CODFIC_0 = " + _this.param(0) + " AND rownum=1";
			var row = _this.reader(_, sqlQuery, [tableDef.tableName]).toArray(_)[0];
			tableDef.isOpenAccess = !row || (row["SECURE_0"] == 2);

			// ----------------------------------------
			// Read the indices of the table
			// ----------------------------------------
			sqlQuery = "SELECT i.UNIQUENESS index_is_unique, ic.INDEX_NAME index_name, ic.COLUMN_NAME column_name, ic.DESCEND column_descending " +
				"FROM USER_IND_COLUMNS ic " +
				"LEFT JOIN USER_INDEXES i ON ic.INDEX_NAME = i.INDEX_NAME " +
				"WHERE ic.TABLE_NAME = :1 " +
				"ORDER BY ic.INDEX_NAME, ic.COLUMN_POSITION";


			var currentIndex;
			var currentIndexName;
			tableDef.indexes = [];
			_this.reader(_, sqlQuery, [tableDef.tableName]).toArray(_).forEach(function(row) {
				if (row.INDEX_NAME != currentIndexName) {
					currentIndexName = row.INDEX_NAME;
					// This is either the first index or a new index (rows are sorted by index)
					currentIndex = {
						name: row.INDEX_NAME,
						isPk: false /* row.index_is_pk*/ ,
						isUnique: (row.INDEX_IS_UNIQUE === "UNIQUE"),
						columns: [],
					};
					tableDef.indexes.push(currentIndex);
				}
				var column = {
					name: row.COLUMN_NAME,
					ascending: (row.COLUMN_DESCENDING === "ASC"),
				};
				currentIndex.columns.push(column);
			});

			// ----------------------------------------
			// Read the sequence of the table
			// ----------------------------------------
			sqlQuery = "SELECT LAST_NUMBER FROM USER_SEQUENCES WHERE SEQUENCE_NAME = :1  AND rownum < 2";
			_this.reader(_, sqlQuery, ["SEQ_" + tableDef.tableName]).toArray(_).forEach(function(row) {
				tableDef.sequence = parseInt(row.LAST_NUMBER);
			});

		},

		createTableFromTableDefinition: function(_, tableDef, options) {
			options = options || {};
			options.showCommands = true;
			options.skipCommands = false;
			if (options.onlyIndexes) {
				options.skipDrop = true;
				options.skipCreate = true;
				options.skipSequences = true;
				options.skipIndexes = false;
			}
			var _this = this;
			// -------------------------------------
			// Drop the existing table
			// -------------------------------------
			if (!options.skipDrop) {
				// Drop the existing table and its sequence
				_this.dropTable(_, tableDef);
				_this.dropSequence(_, tableDef);
			}
			// -------------------------------------
			// Create the table and its columns
			// -------------------------------------
			if (!options.skipCreate) {
				// Create the table (and the columns)
				var sql = "CREATE TABLE " + _this.getFullTableDefName(tableDef) + " (";
				tableDef.columns.forEach(function(colDef, colIdx) {
					if (colIdx > 0)
						sql += ", ";
					sql += colDef.name + " ";
					switch (colDef.type) {
						case "tinyint":
							sql += "NUMBER(3)";
							break;
						case "smallint":
							sql += "NUMBER(5)";
							break;
						case "int":
							sql += "NUMBER(10)";
							break;
						case "date":
							sql += "DATE";
							break;
						case "datetime":
							sql += "TIMESTAMP(3)";
							break;
						case "decimal":
							// STDEN : for now, always create decimal as NUMERIC, without any precision/scale
							// sql += "NUMBER(" + colDef.decimalPrecision + ", " + colDef.decimalScale + ")";
							sql += "NUMBER";
							break;
						case "blob":
							sql += "BLOB";
							break;
						case "varchar":
							sql += "VARCHAR(" + colDef.maxLength + " CHAR)";
							break;
						case "nvarchar":
							sql += "VARCHAR2(" + colDef.maxLength + " CHAR)";
							break;
						case "uuid":
							sql += "RAW(16)";
							break;
						case "binary":
							sql += "RAW(" + colDef.maxLength + ")";
							break;
						default:
							throw new Error('unknown column type ' + colDef.colType + ' for column ' + _this.getFullTableDefName(tableDef) + '.' + colDef.name);
					}
					if (!colDef.isNullable)
						sql += " NOT NULL";
					if (colDef.default)
						sql += " DEFAULT " + colDef.default.value;
				});
				sql += ")";
				options.showCommands && console.log(sql);
				!options.skipCommands && _this.execute(_, sql);
			}

			// -------------------------------------
			// Create the indexes
			// -------------------------------------
			if (!options.skipIndexes) {
				console.log("Create indexes");
				tableDef.indexes.forEach_(_, function(_, indexDef) {
					var sql = "CREATE ";
					if (indexDef.isUnique)
						sql += "UNIQUE ";
					sql += "INDEX " + indexDef.name + " ON " + _this.getFullTableDefName(tableDef) + " (";
					indexDef.columns.forEach(function(column, colIdx) {
						if (colIdx > 0)
							sql += ", ";
						sql += column.name;
						if (!column.ascending)
							sql += " DESC";
					});
					sql += ")";
					options.showCommands && console.log(sql);
					!options.skipCommands && _this.execute(_, sql);
				});
			}
			// -------------------------------------
			// Create (when needed) the sequence
			// -------------------------------------
			if (!options.skipSequences && tableDef.sequence) {
				console.log("Create sequence");

				var sql = "CREATE SEQUENCE " + _this.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName);
				sql += " START WITH " + tableDef.sequence;
				options.showCommands && console.log(sql);
				!options.skipCommands && _this.execute(_, sql);
			}
		},

		/// Returns a reader that could be used to read all the records of the table
		/// 'tableDef' is an object that have been created by getTableDef() or readTables() and updated by readTableSchema()
		createTableReader: function(_, tableDef, filters) {
			return common.createTableReader(_, this, tableDef, filters);
		},

		createTableWriter: function(_, tableDef) {

			var columnNames = [];
			var paramNames = [];
			var _this = this;
			tableDef.columns.forEach(function(column, index) {
				if (column.name == "ROWID")
					return;
				columnNames.push(column.name);
				var paramName = _this.param(index);
				paramNames.push(paramName);
			});

			var sql = "INSERT INTO " + _this.getFullTableDefName(tableDef) + " (" + columnNames.join(',') + ") VALUES (" + paramNames.join(',') + ")";
			var _this = this;
			return this.withConnection(_, function(_, cnx) {
				return _this.writer(_, cnx, sql);
			});
		},

		getFullTableDefName: function(tableDef) {
			return this.getFullTableName(tableDef.schemaName, tableDef.tableName);
		},

		getFullTableName: function(schemaName, tableName) {
			if (schemaName)
				return '"' + schemaName + '"."' + tableName + '"';
			else
				return '"' + tableName + '"';
		},

		clearTable: function(_, tableDef) {
			var _this = this;
			_this.execute(_, "DELETE FROM " + tableDef.tableName);
		},

		/// Tries to drop a table and returns whether the drop succeeded
		dropTable: function(_, tableDef) {
			return common.dropTable(_, this, tableDef);
		},

		/// Tries to drop the sequence bound to a table and returns whether the drop succeeded
		dropSequence: function(_, tableDef) {
			return common.dropSequence(_, this, tableDef);
		},
		evalueRowCount: function(_, tableName) {
			var _this = this;
			var rs = _this.reader(_, "select num_rows from user_tables where table_name =" + _this.param(0), [tableName]).toArray(_);
			//console.log("rs:"+JSON.stringify(rs));
			return parseFloat(rs[0].NUM_ROWS);
		},
		lobPlaceholder: function(type) {
			return "EMPTY_" + type + "()";
		},

	};
};