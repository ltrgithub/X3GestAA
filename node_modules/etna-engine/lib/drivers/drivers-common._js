"use strict";

var ez = require("ez-streams");

/// Returns a reader that could be used to read all the records of the table
/// 'tableDef' is an object that have been created by getTableDef() or readTables() and updated by readTableSchema()
exports.createTableReader = function(_, driver, tableDef, filters) {
	if (!tableDef.columns)
		throw new Error('Must call readTableSchema() before.');
	var columnNames = tableDef.columns.map(function(column) {
		return "T." + column.name;
	});

	var sql = "SELECT " + columnNames.join(',') + " FROM " + driver.getFullTableDefName(tableDef) + " T";
	var filterValues;


	if (filters) {
		// A list of 3-uplets {key, operator, value}
		filterValues = [];
		filters.forEach(function(filter, index) {
			if (index == 0)
				sql += " WHERE ";
			else
				sql += " AND ";
			sql += "(T." + filter.key + " " + filter.operator + " " + driver.param(index) + ")";
			filterValues.push(filter.value);
		});
	}

	// Sort the rows by the first unique index
	var firstUniqueIndex = tableDef.indexes.filter(function(indexDef) {
		return indexDef.isUnique;
	})[0];
	if (firstUniqueIndex) {
		firstUniqueIndex.columns.forEach(function(column, index) {

			if (index == 0)
				sql += " ORDER BY ";
			else
				sql += ", ";
			sql += "T." + column.name;
		});
	}

	return driver.reader(_, sql, filterValues);
};

/// Tries to drop a table and returns whether the drop succeeded
exports.dropTable = function(_, driver, tableDef) {
	try {
		// console.log("DROP TABLE " + driver.getFullTableDefName(tableDef));
		driver.execute(_, "DROP TABLE " + driver.getFullTableDefName(tableDef));
		return true;
	} catch (err) {
		// The table does not exist
		return false;
	}
};

/// Tries to drop the sequence bound to a table and returns whether the drop succeeded
exports.dropSequence = function(_, driver, tableDef) {
	try {
		// console.log("DROP SEQUENCE " + driver.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName));
		driver.execute(_, "DROP SEQUENCE " + driver.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName));
		return true;
	} catch (err) {
		// The sequence does not exist
		return false;
	}
};

exports.createPermissions = function(_, driver, tableDef, config) {
	var PERMISSION_UPDATE = "UPDATE";
	var PERMISSION_SELECT = "SELECT";
	var PERMISSION_INSERT = "INSERT";
	var PERMISSION_DELETE = "DELETE";

	function grantPermission(_, cnx, roleName, permission, fullTableName) {
		var sql = "GRANT " + permission + " ON " + fullTableName + " TO " + roleName;
		//console.log(">>>>>>>> " + sql);
		try {
			driver.execute(_, cnx, sql);
			return true;
		} catch (err) {
			return false;
		}
	}

	function grantPermissions(_, cnx, roleName, permissions) {
		var result = true;
		// By default, all the permissions are used
		permissions = permissions || [PERMISSION_UPDATE, PERMISSION_SELECT, PERMISSION_INSERT, PERMISSION_DELETE];

		// Grant permissions to the table
		permissions.forEach_(_, function(_, perm) {
			result &= grantPermission(_, cnx, roleName, perm, driver.getFullTableDefName(tableDef));
		});
		return result;
	}

	driver.withConnection(_, function(_, cnx) {
		var folderName = tableDef.schemaName;
		if (tableDef.isOpenAccess) {
			// We only have to create 1 permission for the role FolderName_ADX_SYS
			grantPermissions(_, cnx, folderName + "_ADX_SYS");
		} else {
			// A little bit tricky ...

			// - give all permissions to FolderName_ADX_H
			grantPermissions(_, cnx, folderName + "_ADX_H");

			// - give only 'select' permission to FolderName_ADX_R
			grantPermissions(_, cnx, folderName + "_ADX_R", [PERMISSION_SELECT]);

			// - give only 'select' permission to FolderName_ADX_RH
			grantPermissions(_, cnx, folderName + "_ADX_RH", [PERMISSION_SELECT]);

			// - give only 'select' permission to FolderNameH
			grantPermissions(_, cnx, folderName + "H", [PERMISSION_SELECT]);

			// - give only 'update' permission to FolderName_ADX_SYS for the sequence
			grantPermission(_, cnx, folderName + "_ADX_SYS", PERMISSION_UPDATE, driver.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName));

			// Now, we have to parse the folders chain to allow the current user to read in the tables from the parent folders
			// for instance, if a SEED folder is a child of a X3 folder, the SEED user must be able to read the tables from the X3 schema
			// (some tables such as ADOSSIER, ... only exist in the root folder)

			var loopCount = 0; // just a security to avoid endless loops (corrupted database)
			var sqlQuery = "SELECT DOSREF_0 FROM " + driver.getFullTableName(config.rootFolderName, 'ADOSSIER') + " WHERE DOSSIER_0 = " + driver.param(0);
			var schemaName = folderName;
			while (loopCount < 20) {
				// - give all permissions to FolderName_ADX
				grantPermissions(_, cnx, folderName + "_ADX");

				// - allow folderName_ADX_R to read the table in the 'parent' schema (i.e. the schema of the parent folder)
				grantPermission(_, cnx, folderName + "_ADX_R", PERMISSION_SELECT, driver.getFullTableName(schemaName, tableDef.tableName));

				var row = driver.reader(_, cnx, sqlQuery, [schemaName]).toArray(_)[0];
				if (!row)
					break;
				if (row['DOSREF_0'] == folderName) {
					// We have reach the root folder
					break;
				}
				schemaName = row['DOSREF_0'];
				loopCount++;
			}
		}
	});
};

exports.reader = function(creator) {
	return function(_, cnx, sql, args, opts) {
		if (typeof cnx === "string") {
			opts = args;
			args = sql;
			sql = cnx;
			cnx = null;
		}
		opts = opts || {};
		if (cnx != null) return creator.call(this, _, cnx, sql, args, opts);
		var self = this;
		cnx = self.allocConnection(_);
		var reader = creator.call(this, _, cnx, sql, args, opts);
		return ez.devices.generic.reader(function(_) {
			try {
				var val = reader.read(_);
				if (val === undefined && cnx) cnx = self.releaseConnection(cnx);
				return val;
			} catch (ex) {
				if (cnx) cnx = self.releaseConnection(cnx, ex);
				throw ex;
			}
		}, function(_) {
			reader.stop(_);
			if (cnx) cnx = self.releaseConnection(cnx);
		});
	};
};


exports.writer = function(creator) {
	return function(_, cnx, sql, opts) {
		if (typeof cnx === "string") {
			opts = sql;
			sql = cnx;
			cnx = null;
		}
		opts = opts || {};
		if (cnx != null) return creator.call(this, _, cnx, sql, opts);
		var self = this;
		cnx = self.allocConnection(_);
		var writer = creator.call(this, _, cnx, sql, opts);
		return ez.devices.generic.writer(function(_, val) {
			try {
				writer.write(_, val);
				if (val === undefined && cnx) cnx = self.releaseConnection(cnx);
			} catch (ex) {
				if (cnx) cnx = self.releaseConnection(cnx, ex);
				throw ex;
			}
		}, function(_) {
			writer.stop(_);
			if (cnx) cnx = self.releaseConnection(cnx);
		});
	};
};