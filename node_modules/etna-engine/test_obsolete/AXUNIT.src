Gosub $TEST_
End

#**
#* Start method to be called at the beginning of a test suite<br>
#* 
#* A test suite must fit the following code template:
#* <pre>
#* Funprog TESTSUITE()
#*   Call TESTSUITE_START("REQ-99999", "My description of the test suite") From AXUNIT
#*   Call TEST_MYCASE1  
#*   Call TEST_MYCASE2  
#*   Call TESTSUITE_END From AXUNIT
#* End func AXUNIT.SUITE_RESULT()
#* 
#* Subprog TEST_MYCASE1
#*   Call TESTCASE_START("My description of the test case") From AXUNIT
#*   ...
#*   Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
#*   ...
#*   Call CHECK_TRUE(GOT) From AXUNIT
#*   ...
#*   Call TESTCASE_END From AXUNIT
#* End
#* </pre> 
#*
#* @param SUITE_ID 
#* @param SUITE_DESCRIPTION 
#*!
Subprog TESTSUITE_START(SUITE_ID, SUITE_DESCRIPTION)
  Value Char SUITE_ID()
  Value Char SUITE_DESCRIPTION()
  
  Call INIT_UNIT
  If dim(GXUNIT_ID) < 0 : Global Char GXUNIT_ID(255) : Endif
  GXUNIT_ID = SUITE_ID
  If dim(GXUNIT_SUITE_DESCRIPTION) < 0 : Global Char GXUNIT_SUITE_DESCRIPTION(255) : Endif
  GXUNIT_SUITE_DESCRIPTION = SUITE_DESCRIPTION
  If dim(GXUNIT_CASE_ID) < 0 : Global Integer GXUNIT_CASE_ID : Endif
  GXUNIT_CASE_ID = 0  
  If dim(GXUNIT_CASE_SUCCESS) < 0 : Global Integer GXUNIT_CASE_SUCCESS : Endif
  GXUNIT_CASE_SUCCESS = 0  
  If dim(GXUNIT_CASE_FAILURE) < 0 : Global Integer GXUNIT_CASE_FAILURE : Endif
  GXUNIT_CASE_FAILURE = 0

  If dim(GXUNIT_LOG_NAME) < 0  : Global Char GXUNIT_LOG_NAME(255) : Endif
  GXUNIT_LOG_NAME = ""
 
  GXUNIT_TSTAMP = TIMESTAMP$
  Call LOG_CLEAR
  Call LOG_LINE("Start suite - " + GXUNIT_MODULE_NAME + " - " + GXUNIT_ID + " - " + GXUNIT_SUITE_DESCRIPTION)
End

Subprog INIT_UNIT()
  If dim(GXUNIT_TSTAMP) < 0 : Global Char GXUNIT_TSTAMP(20) : Endif
  If GXUNIT_TSTAMP = ""
    GXUNIT_TSTAMP = TIMESTAMP$
  Endif
  If dim(GXUNIT_MODULE_NAME) < 0 : Global Char GXUNIT_MODULE_NAME(255) : Endif
  If GXUNIT_MODULE_NAME = ""
    Local Integer NIVEAU
    While adxpno(NIVEAU) = adxpno(0)
      NIVEAU += 1
    Wend
    Local Integer POS1 
    Local Integer POS2 
    POS1 = instr(1, adxpno(NIVEAU), "/")
    POS2 = instr(POS1+1, adxpno(NIVEAU), "$")
    GXUNIT_MODULE_NAME = mid$(adxpno(NIVEAU), POS1+1, POS2-POS1-1) 
  Endif   

  If dim(GXUNIT_SUITE_RESULT) < 0 : Global Clbfile GXUNIT_SUITE_RESULT(2) : Endif  
  Raz GXUNIT_SUITE_RESULT
  If dim(GXUNIT_JSON) < 0 : Global Clbfile GXUNIT_JSON(8) : Endif  
  Raz GXUNIT_JSON

  If dim(GXUNIT_CASES) < 0 : Global Char GXUNIT_CASES(100)(1..,2) : Endif  
  If dim(GXUNIT_CASE_COUNT) < 0 : Global Integer GXUNIT_CASE_COUNT : Endif  
  If dim(GXUNIT_CURRENT_CASE) < 0 : Global Integer GXUNIT_CURRENT_CASE : Endif  
  If dim(GXUNIT_CASE_ASSERT_COUNT) < 0 : Global Integer GXUNIT_CASE_ASSERT_COUNT(1.., 2) : Endif  
End

#**
#* End method to be called at the end of a test suite 
#*!
Subprog TESTSUITE_END
#  Call LOG_LINE("End suite: " + GXUNIT_ID + " - " + GXUNIT_SUITE_DESCRIPTION)
#  Append GXUNIT_SUITE_RESULT, num$(GXUNIT_CASE_SUCCESS + GXUNIT_CASE_FAILURE)
#  Append GXUNIT_SUITE_RESULT, " test cases run - "
  If dim(GXUNIT_SUITE_ERROR) > 0
    Append GXUNIT_SUITE_RESULT, GXUNIT_SUITE_ERROR
    Raz GXUNIT_SUITE_ERROR
  Endif

  Append GXUNIT_SUITE_RESULT, GXUNIT_MODULE_NAME + " - " + GXUNIT_ID + " - " 
  Append GXUNIT_SUITE_RESULT, num$(GXUNIT_CASE_SUCCESS)
  Append GXUNIT_SUITE_RESULT, " Succeed, "
  Append GXUNIT_SUITE_RESULT, num$(GXUNIT_CASE_FAILURE)
  Append GXUNIT_SUITE_RESULT, " Failed, "
  Append GXUNIT_SUITE_RESULT, num$(val(TIMESTAMP$) - val(GXUNIT_TSTAMP))
  Append GXUNIT_SUITE_RESULT, "ms elapsed"
  Append GXUNIT_SUITE_RESULT, chr$(10)
  Append GXUNIT_SUITE_RESULT, "Result has been written to '"
  Append GXUNIT_SUITE_RESULT, func LOG_NAME()
  Append GXUNIT_SUITE_RESULT, "'"
  
  Call LOG_APPEND(chr$(10))
  Call LOG_LINE(GXUNIT_SUITE_RESULT)
  
  Call RESET_UNIT
End

#**
#* Start method to be called at the beginning of a test case
#*
#* @param DESCRIPTION 
#*!
Subprog TESTCASE_START(DESCRIPTION)
  Value Char DESCRIPTION()
  
  If dim(GXUNIT_CASESTAMP) < 0 : Global Char GXUNIT_CASESTAMP(20) : Endif
  GXUNIT_CASESTAMP = TIMESTAMP$
  If dim(GXUNIT_DESCRIPTION) < 0 : Global Char GXUNIT_DESCRIPTION(255) : Endif
  GXUNIT_DESCRIPTION = DESCRIPTION
  If dim(GXUNIT_TESTID) < 0 : Global Integer GXUNIT_TESTID : Endif
  GXUNIT_TESTID = 0
  
  Call CREATE_RESULT_CONTEXT
  GXUNIT_SUCCESS = 0  
  GXUNIT_FAILURE = 0
  Raz GXUNIT_RESULT
  
  If dim(GXUNIT_ERROR) < 0 : Global Integer GXUNIT_ERROR : Endif
  GXUNIT_ERROR = 0

  GXUNIT_CASE_ID += 1
  Call LOG_APPEND(chr$(10))
  Call LOG_LINE("Start test case - " + GXUNIT_DESCRIPTION)
End

#**
#* End method to be called at the end of a test case
#*!
Subprog TESTCASE_END()
  Append GXUNIT_RESULT, "success="
  Append GXUNIT_RESULT, num$(GXUNIT_SUCCESS) 
  Append GXUNIT_RESULT, ", failure="
  Append GXUNIT_RESULT, num$(GXUNIT_FAILURE)
  Append GXUNIT_RESULT, ", elapsed="
  Append GXUNIT_RESULT, num$(val(TIMESTAMP$) - val(GXUNIT_CASESTAMP))
  Append GXUNIT_RESULT, "ms"
  Append GXUNIT_RESULT, chr$(10)  
  If GXUNIT_FAILURE > 0
    GXUNIT_CASE_FAILURE += 1
  Else
    GXUNIT_CASE_SUCCESS += 1
  Endif
  If GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 0) > 0 & 
&    GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 0) <> GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 1) 
    Append GXUNIT_RESULT, "Mismatch number of assertions: expected "
    Append GXUNIT_RESULT, num$(GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 0))
    Append GXUNIT_RESULT, " got "
    Append GXUNIT_RESULT, num$(GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 1))
    Append GXUNIT_RESULT, chr$(10)  
  Endif
  Call LOG_APPEND(GXUNIT_RESULT)
  
#  Append GXUNIT_JSON, '{'
#    Append GXUNIT_RESULT, chr$(10)  
#    Append GXUNIT_JSON, '"module":'
#    Append GXUNIT_JSON, '"'
#    Append GXUNIT_JSON, GXUNIT_MODULE_NAME
#    Append GXUNIT_JSON, '",'
#    Append GXUNIT_RESULT, chr$(10)  
#    Append GXUNIT_JSON, '"name":'
#    Append GXUNIT_JSON, '"'
#    Append GXUNIT_JSON, GXUNIT_CASES(GXUNIT_CURRENT_CASE, 0)
#    Append GXUNIT_JSON, '",'
#    Append GXUNIT_RESULT, chr$(10)  
#    Append GXUNIT_JSON, '"message":'
#    Append GXUNIT_JSON, '"'
#    Append GXUNIT_JSON, "todo assert + result"
#    Append GXUNIT_JSON, '",'
#    Append GXUNIT_RESULT, chr$(10)  
#    Append GXUNIT_JSON, '"stackTrace":'
#    Append GXUNIT_JSON, '"'
#    Append GXUNIT_JSON, "todo stackTrace"
#    Append GXUNIT_JSON, '",'
#    Append GXUNIT_RESULT, chr$(10)  
#  Append GXUNIT_JSON, '}'

#  Call LOG_LINE("End test case: " + GXUNIT_DESCRIPTION)
End

#**
#* Gets the test suite result summary
#*!
Funprog SUITE_RESULT()
End GXUNIT_SUITE_RESULT

#**
#* Gets the test case result
#*!
Funprog CHECK_RESULT()
End GXUNIT_RESULT

#**
#* Verify if the check is valid in the current context
#* @private
#*!
Funprog VERIFY_CHECK
  If dim(GXUNIT_CURRENT_CASE) < 0 | GXUNIT_CURRENT_CASE <= 0 | (dim(GXUNIT_SUITE_RESULT) > 0 & len(GXUNIT_SUITE_RESULT) > 0)
    If dim(GXUNIT_SUITE_ERROR) < 0 : Global Clbfile GXUNIT_SUITE_ERROR(3) : Endif
    Append GXUNIT_SUITE_ERROR, "Warning: No current test case, the check has been skipped"
    Append GXUNIT_SUITE_ERROR, chr$(10)
    Local Integer STAT
    If dim(GSTACK) < 0 : Global Clbfile GSTACK(7) : Endif  
    STAT = DBGCALLSTACK(0, GSTACK)
    Call APPEND_STACK(GXUNIT_SUITE_ERROR, GSTACK)
    Append GXUNIT_SUITE_ERROR, chr$(10)
    End 0
  Endif 
End 1

#**
#* Creates the minimum context to report results
#* @private
#*!
Subprog CREATE_RESULT_CONTEXT
  If dim(GXUNIT_RESULT) < 0 : Global Clbfile GXUNIT_RESULT(10) : Endif
  If dim(GXUNIT_SUCCESS) < 0 : Global Integer GXUNIT_SUCCESS : Endif
  If dim(GXUNIT_FAILURE) < 0 : Global Integer GXUNIT_FAILURE : Endif
End

#**
#* Check if GOT equals to EXPECTED
#*
#* @param GOT 
#* @param EXPECT 
#*!
Subprog CHECK_EQUAL(GOT, EXPECT)
  Local Integer FAILED : FAILED=0
  
  If not (func VERIFY_CHECK) : End: Endif 

  Onerrgo CHECK_ERR
  
  GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 1) += 1
  GXUNIT_TESTID += 1
  Append GXUNIT_RESULT, num$(GXUNIT_CASE_ID) + "." + num$(GXUNIT_TESTID)
  Append GXUNIT_RESULT, " - CHECK_EQUAL - "
  If GOT = EXPECT Then 
    GXUNIT_SUCCESS += 1
    Append GXUNIT_RESULT, "OK: "
  Else
    FAILED = 1 
    Append GXUNIT_RESULT, "FAILED: expected "
    Case type(GOT)
      When 1, 2, 4, 5, 6, 7, 9, 525
        Append GXUNIT_RESULT, num$(EXPECT)
      When 3
        Append GXUNIT_RESULT, EXPECT
      When Default
        Append GXUNIT_RESULT, "'"
        Append GXUNIT_RESULT, EXPECT
        Append GXUNIT_RESULT, "'"
    Endcase
    Append GXUNIT_RESULT, ", got "
  Endif
  Case type(GOT)
    When 1, 2, 4, 5, 6, 7, 9, 525
      Append GXUNIT_RESULT, num$(GOT)
    When 3
      Append GXUNIT_RESULT, GOT
    When Default
      Append GXUNIT_RESULT, "'"
      Append GXUNIT_RESULT, GOT
      Append GXUNIT_RESULT, "'"
  Endcase
  Append GXUNIT_RESULT, chr$(10)
  If FAILED
    Gosub CHECK_FAILED
  Endif
End

#**
#* Check if GOT not equals to EXPECTED
#*
#* @param GOT 
#* @param EXPECT 
#*!
Subprog CHECK_NOTEQUAL(GOT, EXPECT)
  Local Integer FAILED : FAILED=0

  If not (func VERIFY_CHECK) : End: Endif 

  Onerrgo CHECK_ERR
  
  GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 1) += 1
  GXUNIT_TESTID += 1
  Append GXUNIT_RESULT, num$(GXUNIT_CASE_ID) + "." + num$(GXUNIT_TESTID)
  Append GXUNIT_RESULT, " - CHECK_NOTEQUAL - "
  If (type(GOT) <> type(EXPECT)) | (GOT <> EXPECT) Then    
    GXUNIT_SUCCESS += 1
    Append GXUNIT_RESULT, "OK: "
  Else
    FAILED = 1 
#    FAILED = 1 
#    Append GXUNIT_RESULT, "FAILED: expected "
#    Case type(GOT)
#      When 1, 2, 4, 5, 6, 7, 9
#        Append GXUNIT_RESULT, num$(EXPECT)
#      When 3
#        Append GXUNIT_RESULT, EXPECT
#      When Default
#        Append GXUNIT_RESULT, "'"
#        Append GXUNIT_RESULT, EXPECT
#        Append GXUNIT_RESULT, "'"
#    Endcase
#    Append GXUNIT_RESULT, ", got "
  Endif
  Case type(GOT)
    When 1, 2, 4, 5, 6, 7, 9, 525
      Append GXUNIT_RESULT, num$(GOT)
    When 3
      Append GXUNIT_RESULT, GOT
    When Default
      Append GXUNIT_RESULT, "'"
      Append GXUNIT_RESULT, GOT
      Append GXUNIT_RESULT, "'"
  Endcase
  Append GXUNIT_RESULT, chr$(10)
  If FAILED
    Gosub CHECK_FAILED
  Endif
End

#**
#* Check if GOT is true
#*
#* @param GOT 
#*!
Subprog CHECK_TRUE(GOT)
  If not (func VERIFY_CHECK) : End: Endif 

  Onerrgo CHECK_ERR
  
  GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 1) += 1
  GXUNIT_TESTID += 1
  Append GXUNIT_RESULT, num$(GXUNIT_CASE_ID) + "." + num$(GXUNIT_TESTID)
  Append GXUNIT_RESULT, " - CHECK_TRUE - "

  If GOT
    GXUNIT_SUCCESS += 1
    Append GXUNIT_RESULT, "OK"
    Append GXUNIT_RESULT, chr$(10)
  Else
    Append GXUNIT_RESULT, "Failed"
    Append GXUNIT_RESULT, chr$(10)
    Gosub CHECK_FAILED
  Endif
End

#**
#* Check if GOT is false
#*
#* @param GOT 
#*!
Subprog CHECK_FALSE(GOT)
  If not (func VERIFY_CHECK) : End: Endif 

  Onerrgo CHECK_ERR
  
  GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 1) += 1
  GXUNIT_TESTID += 1
  Append GXUNIT_RESULT, num$(GXUNIT_CASE_ID) + "." + num$(GXUNIT_TESTID)
  Append GXUNIT_RESULT, " - CHECK_FALSE - "

  If !GOT
    GXUNIT_SUCCESS += 1
    Append GXUNIT_RESULT, "OK"
    Append GXUNIT_RESULT, chr$(10)
  Else
    Append GXUNIT_RESULT, "Failed"
    Append GXUNIT_RESULT, chr$(10)
    Gosub CHECK_FAILED
  Endif
End

$CHECK_ERR
  Append GXUNIT_RESULT, "Error"
  If errn
    Append GXUNIT_RESULT, ": ["
    Append GXUNIT_RESULT, num$(errn)
    Append GXUNIT_RESULT, "] "
    Append GXUNIT_RESULT, errmes$(errn)
  Endif
  Append GXUNIT_RESULT, chr$(10)
  GXUNIT_ERROR = errn
  Gosub CHECK_FAILED
  Resume
  
$CHECK_FAILED
  Local Integer STAT
  If dim(GSTACK) < 0 : Global Clbfile GSTACK(7) : Endif  
  GXUNIT_FAILURE += 1
  STAT = DBGCALLSTACK(0, GSTACK)
  Call APPEND_STACK(GXUNIT_RESULT, GSTACK)
  Append GXUNIT_RESULT, chr$(10)
  Return

#**
#* Appends a formatted form of the stack trace to the given clob
#*
#* @param CLB 
#* @param STACK 
#*!
Subprog APPEND_STACK(CLB, STACK)
  Variable Clbfile CLB()
  Variable Clbfile STACK()
  
  Local Integer TOK_START
  Local Integer TOK_END
  Local Char FNAME(255)
  Local Char LINE(255)
  Local Char PROG(255)

  TOK_START = 1  
  Repeat
    TOK_START = instr(TOK_START, STACK, '<stack ')
    If TOK_START <> 0
      TOK_START += 7
      TOK_START = instr(TOK_START, STACK, 'filename="')
      TOK_START += 10
      If instr(TOK_START, STACK, 'x3://') > 0
        TOK_START += 5
      Endif
      TOK_END = instr(TOK_START, STACK, '" ')
      FNAME = mid$(STACK, TOK_START, TOK_END - TOK_START)
      TOK_START = TOK_END + 2
      TOK_START = instr(TOK_START, STACK, 'lineno="')
      TOK_START += 8
      TOK_END = instr(TOK_START, STACK, '" ')
      LINE = num$(val(mid$(STACK, TOK_START, TOK_END - TOK_START)) + 1)
      TOK_START = TOK_END + 2
      TOK_START = instr(TOK_START, STACK, 'where="')
      TOK_START += 7
      TOK_END = instr(TOK_START, STACK, '" ')
      PROG = mid$(STACK, TOK_START, TOK_END - TOK_START)
      TOK_START = TOK_END + 2
      Append CLB, "    at "
      Append CLB, PROG
      Append CLB, "("
      Append CLB, FNAME
      Append CLB, ":"
      Append CLB, LINE
      Append CLB, ")"
      Append CLB, chr$(10)
    Endif
  Until TOK_START = 0
  
#  Append CLB, STACK
End

#**
#* Run all test suites
#*!
Funprog RUN_ALL()
  Local Clbfile FILES(10)
  Local Clbfile RES(4)
  Append RES, "=== Runtime Test Set ==="
  Append RES, chr$(10)
  Append RES, func RUN_SET("RTM")
  Append RES, chr$(10)
  Append RES, chr$(10)
  Append RES, "=== Supervisor Test Set ==="
  Append RES, chr$(10)
  Append RES, func RUN_SET("SUP")  
  Append RES, chr$(10)
  Append RES, chr$(10)
  Append RES, "=== Java Bridge Test Set ==="
  Append RES, chr$(10)
  Append RES, func RUN_SET("JAV")
  Append RES, chr$(10)
  Append RES, chr$(10)
  Append RES, "=== Web Test Set ==="
  Append RES, chr$(10)
  Append RES, func RUN_SET("WEB")
End RES

#**
#* Run a set of test suites
#*
#* @param SET the set name
#* <ul>
#* <li>"RTM" for runtime</li>
#* <li>"SUP" for supervisor</li>
#* <li>"JAV" for java bridge</li>
#* <li>"WEB" for web and web services</li>
#* </ul> 
#*!
Funprog RUN_SET(SET)
  Value Char SET()

  Local Clbfile FILES(10)
  Local Clbfile RES(1)
  Local Integer I
  Local Integer STARTPOS
  FILES = func GET_QLF_LIST("", SET, ";")
  If len(FILES) > 0
    I = 1
    Repeat
      STARTPOS = I
      I = instr(I, FILES, ";")
      FNAME = mid$(FILES, STARTPOS, I - STARTPOS)
      If len(FNAME) > 0
        Append RES, func =FNAME + ".TESTSUITE" With ()
      Endif
    Until I > 0
  Endif  
End RES

Funprog GET_QLF_LIST(DOSSIER, SET, SEP)
  Value Char    DOSSIER()
  Value Char    SET()
  Value Char    SEP()
  Local Char    FILTRE(250)
  Local Clbfile FILES(10)

  FILTRE = 'left$(TRT,' + num$(len(SET)+3) + ')="QLF' + SET + '"' 
  FILES = func GET_FILES(DOSSIER, "QLF", FILTRE, 100000, "adx", "TRT", SEP)
End FILES

Funprog GET_FILES(DOSSIER, START, FILTERS, NBMAX, FILEEXT, FILEDIR, SEP)
  Value Char    DOSSIER()
  Value Char    START()
  Value Char    FILTERS()
  Value Integer NBMAX
  Value Char    FILEEXT()
  Value Char    FILEDIR()
  Value Char    SEP()
  
  Local Char    FILTRE(250), REPERT(GDIMFIC)
  Local Char    MACHINE(250), APPLI(GLONADS), ORDSYS(250)
  Local Char    CODTRT(GLONADC)
  Local Integer NB_TRT, K
  Local Integer NB_MAX
  
  Local Clbfile FILES(10)
  
  
  # Default values initialization
  If NBMAX = -1 : NB_MAX = GNBSEL : Else : NB_MAX = NBMAX : Endif
  If DOSSIER="" : DOSSIER = nomap : Endif
  
  Call MACHINE(DOSSIER, MACHINE, APPLI) From ORDSYS
  REPERT = filpath(FILEDIR, "", "", APPLI, "", MACHINE)
  
  # Insert start filter
  If START=""
    FILTRE = ""
  Else
    FILTRE = 'TRT>="'+START+'"'
  Endif
  
  # Exclude empty named files
  If FILTRE<>"" : Append FILTRE, "&" : Endif
  Append FILTRE, 'TRT<>""'
  
  # insert caller filters
  If FILTERS<>""
    If FILTRE<>"" : Append FILTRE, "&" : Endif
    Append FILTRE, FILTERS
  Endif
  
  If clalev([F:TRT_])>0 : Close Local File [TRT_] : Endif
  Case FILEEXT
   When "src"
    ORDSYS = MACHINE+"@"+'lsadx -a'-toupper(APPLI)-REPERT
    Append FILTRE, '& pat(TRT,"*.src")'
   When "stc"
    ORDSYS = MACHINE+"@"+'lsadx -a'-toupper(APPLI)-REPERT
    Append FILTRE, '& pat(TRT,"*.stc")'
   When Default
    ORDSYS = MACHINE+"@"+'archive -d '+DOSSIER-' -t "adx" -l "*" -v'
  Endcase
  Local File (TRT(30)) From System ORDSYS As [TRT_]
  
  NB_TRT =0
  For [TRT_] Where evalue(FILTRE)
   NB_TRT += 1
   K = instr(1, [F:TRT_]TRT, "." + FILEEXT)
   If K
    CODTRT = left$([F:TRT_]TRT, K-1)
   Else
    CODTRT = [F:TRT_]TRT
   Endif
   If NB_TRT > NB_MAX
     Break
   Endif
   Append FILES, CODTRT
   Append FILES, SEP
  Next TRT_
End FILES

#**
#* Adds a line to the log file
#* @internal
#*
#* @param LINE
#*!
Subprog LOG_APPEND(LINE)
  Openo func LOG_NAME, -1 Using [LOG_]
  Iomode adxium CST_UTF8 Using [LOG_]
  Iomode adxirs "" Using [LOG_]
#  Wrseq DBGT_LINE+chr$(10) Using [LOG_]
#  Wrseq DBGT_LINE Using [LOG_]
  Wrseq LINE Using [LOG_]
  Openo Using [LOG_]
End

#**
#* Adds a line to the log file
#* @internal
#*
#* @param LINE
#*!
Subprog LOG_LINE(LINE)
  Openo func LOG_NAME, -1 Using [LOG_]
#  Iomode adxium CST_ASCII Using [LOG_]
  Iomode adxium CST_UTF8 Using [LOG_]
  Iomode adxirs "" Using [LOG_]
#  Wrseq DBGT_LINE+chr$(10) Using [LOG_]
#  Wrseq DBGT_LINE Using [LOG_]
  Wrseq format$("D:YYYY[-]MM[-]DD", date$) + "T" + time$ + "." + format$("N0:3", mod(val(TIMESTAMP$), 1000)) + ": " Using [LOG_]
  Wrseq LINE Using [LOG_]
  Wrseq chr$(10) Using [LOG_]
  Openo Using [LOG_]
End

#**
#* Run a test suite
#*
#* @param SUITE_ID 
#* @param SUITE_DESCRIPTION 
#*!
Funprog RUN_TESTSUITE(SUITE_ID, SUITE_DESCRIPTION)
  Value Char SUITE_ID()
  Value Char SUITE_DESCRIPTION()
  
  Local Integer FATAL_ERR 
  Onerrgo SUITE_ERR
  Call TESTSUITE_START(SUITE_ID, SUITE_DESCRIPTION)
  If FATAL_ERR <> 0
    Goto END_SUITE
  Endif

  Local Integer I
  For I = 1 To GXUNIT_CASE_COUNT
    GXUNIT_CURRENT_CASE = I
    Call RUN_TESTCASE(GXUNIT_CASES(I, 0), GXUNIT_CASES(I, 1), GXUNIT_CASE_ASSERT_COUNT(I, 0))
    If FATAL_ERR <> 0
      Goto END_SUITE
    Endif
  Next I

  Call TESTSUITE_END
  If FATAL_ERR <> 0
    Goto END_SUITE
  Endif

$END_SUITE
  Onerrgo  
End func SUITE_RESULT()

$SUITE_ERR
  FATAL_ERR = errn
  Append GXUNIT_SUITE_RESULT, chr$(10) 
  Append GXUNIT_SUITE_RESULT, "Fatal error(" + num$(errn) + "): " + errmes$(errn) + "[" + errp + ":" + num$(errl) + "]" 

#  Append GXUNIT_SUITE_RESULT, chr$(10)   
#  Local Integer STAT
#  If dim(GSTACK) < 0 : Global Clbfile GSTACK(7) : Endif  
#  STAT = dbgCallStack(0, GSTACK)
#  Call APPEND_STACK(GXUNIT_SUITE_RESULT, GSTACK)
  
  Call RESET_UNIT
Resume

Subprog RESET_UNIT
  GXUNIT_CURRENT_CASE = 0
  GXUNIT_CASE_COUNT = 0
  GXUNIT_MODULE_NAME = ""
  GXUNIT_TSTAMP = ""
End

#**
#* Run a test case
#* @internal 
#*
#* @param SUBPRG 
#* @param DESCRIPTION
#*!
Subprog RUN_TESTCASE(SUBPRG, DESCRIPTION, ASSERT_COUNT)
  Value Char SUBPRG()
  Value Char DESCRIPTION()
  Value Integer ASSERT_COUNT
  
  Call TESTCASE_START(DESCRIPTION)
  Call =SUBPRG With From =GXUNIT_MODULE_NAME
  Call TESTCASE_END  
End

Subprog ADD_TESTCASE(SUBPRG, DESCRIPTION, ASSERT_COUNT)
  Value Char SUBPRG()
  Value Char DESCRIPTION()
  Value Integer ASSERT_COUNT
  
  Call INIT_UNIT
  
  GXUNIT_CASE_COUNT += 1
  GXUNIT_CASES(GXUNIT_CASE_COUNT, 0) = SUBPRG
  GXUNIT_CASES(GXUNIT_CASE_COUNT, 1) = DESCRIPTION
  GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CASE_COUNT, 0) = ASSERT_COUNT
  GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CASE_COUNT, 1) = 0
End

#**
#* Clears the content of the log file
#* @internal
#*!
Subprog LOG_CLEAR
  Openo func LOG_NAME,0 Using [LOG_]
  Openo Using [LOG_]
End

#**
#* Returns the trace name
#* @internal
#*!
Funprog LOG_NAME()
  If dim(GXUNIT_LOG_NAME) < 0  : Global Char GXUNIT_LOG_NAME(255) : Endif
  If [V]GXUNIT_LOG_NAME = ""
    Local Char NAME(255)
    Call INIT_UNIT    
    NAME = GXUNIT_MODULE_NAME + "_" + toupper(ctrans(adxusr,".\/|*@","______"))
#    NAME = "XUNIT_" + toupper(ctrans(GXUNIT_ID," .\/|*@","-------")) + "_" + toupper(ctrans(adxusr,".\/|*@","______"))
#    NAME += "_" + num$(GXUNIT_TESTID) 
    [V]GXUNIT_LOG_NAME = filpath("TRA", NAME, "tra", 0)
  Endif
End [V]GXUNIT_LOG_NAME

Funprog RAZ_CONTEXT()
  Onerrgo TRAP_ERROR
  If dim(GXUNIT_TSTAMP) > 0 : Kill GXUNIT_TSTAMP : Endif
  If dim(GXUNIT_ID) > 0 : Kill GXUNIT_ID : Endif
  If dim(GXUNIT_DESCRIPTION) > 0 : Kill GXUNIT_DESCRIPTION : Endif
  If dim(GXUNIT_SUCCESS) > 0 : Kill GXUNIT_SUCCESS : Endif
  If dim(GXUNIT_FAILURE) > 0 : Kill GXUNIT_FAILURE : Endif
  If dim(GXUNIT_TESTID) > 0 : Kill GXUNIT_TESTID : Endif
  If dim(GXUNIT_RESULT) > 0 : Kill GXUNIT_RESULT : Endif
  If dim(GXUNIT_ERROR) > 0 : Kill GXUNIT_ERROR : Endif
  If dim(GXUNIT_FILE) > 0 : Kill GXUNIT_FILE : Endif  
End "ok"

$TRAP_ERROR
Resume

# =========================================================== 
# == TEST 
# =========================================================== 
$TEST_
Infbox func TESTSUITE
End

Funprog TESTSUITE()
  # hack to init the module for the Unit test module itself
  If dim(GXUNIT_MODULE_NAME) < 0 : Global Char GXUNIT_MODULE_NAME(255) : Endif
  GXUNIT_MODULE_NAME = "AXUNIT"
  
  Call ADD_TESTCASE("TC_01", '"abc" <> 2', 1)
  Call ADD_TESTCASE("TC_02", '"abc" = "abc"', 1)
  Call ADD_TESTCASE("TC_03", '(1 = 1) = true', 1)
  Call ADD_TESTCASE("TC_04", '(1 = 0) = false', 1)
  Call ADD_TESTCASE("TC_05", 'callstack', 1)
End func RUN_TESTSUITE("AXUNIT", "AXUNIT self test")

Subprog TC_01
#Local Integer A : A = 2
  Local Char A(250) : A = "abc"
  
  Call CHECK_NOTEQUAL(A, 2)
End

Subprog TC_02
  Local Char A(250) : A = "abc"
  
  Call CHECK_EQUAL(A, "abc")
End

Subprog TC_03
  Call CHECK_TRUE(1=1)
End

Subprog TC_04
  Call CHECK_FALSE(1=0)
End

Subprog TC_05
  Local Clbfile ST(2)
  Local Clbfile GOT(2)
  Local Clbfile EXPECT(2)
  ST = ''
  Append ST, '<stack level="0" type="file" filename="x3://sodaix02:17000/SUPERV/ZXUNIT.src" lineno="253" where="ZXUNIT.TEST_STACK" cmdbegin="253:0" cmdend="253:-1"/>'
  Append ST, '<stack level="1" type="file" filename="x3://sodaix02:17000/SUPERV/.src" lineno="2015" where="WMAXDCOR_122.EVALUE_EXPR" cmdbegin="2015:0" cmdend="2015:-1"/>'    

  Append EXPECT, "    at ZXUNIT.TEST_STACK(sodaix02:17000/SUPERV/ZXUNIT.src:254)"
  Append EXPECT, chr$(10)
  Append EXPECT, "    at WMAXDCOR_122.EVALUE_EXPR(sodaix02:17000/SUPERV/.src:2016)"
  Append EXPECT, chr$(10)
  
  Call APPEND_STACK(GOT, ST)
  
  Call CHECK_EQUAL(GOT, EXPECT)
End

Funprog STACK()
  Local Clbfile ST(1)
  Local Clbfile ST2(1)
  ST = ''
  Append ST, '<stack level="0" type="file" filename="x3://sodaix02:17000/SUPERV/ZXUNIT.src" lineno="253" where="ZXUNIT.TEST_STACK" cmdbegin="253:0" cmdend="253:-1"/>'
  Append ST, '<stack level="1" type="file" filename="x3://sodaix02:17000/SUPERV/.src" lineno="2015" where="WMAXDCOR_122.EVALUE_EXPR" cmdbegin="2015:0" cmdend="2015:-1"/>'    
  Call APPEND_STACK(ST2, ST)
#  Local Instance STU Using ZSXUNIT
#  STU = NewInstance ZSXUNIT
#  STU.LEVEL_ = 1
#  STU.TYPE_ = "file"
#  STU.FILENAME_ = "x3://sodaix02:17000/SUPERV/ZXUNIT.src"
#  Convxml STU To ST
#  Convxml ST To STU 
#End "ok: type=" - num$(STU.LEVEL_) + ", type=" + STU.TYPE_ 
End "ok: " +chr$(10) + ST2 

Funprog TEST_STACK
End func TEST_STACK2

Funprog TEST_STACK2
  Local Integer STAT
  Local Clbfile STACK(10)
  Local Clbfile STACK2(10)
  STAT = DBGCALLSTACK(0, STACK)
  Call APPEND_STACK(STACK2, STACK)
End STACK2
