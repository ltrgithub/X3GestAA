Call INIT(trtcou, 27) From XUNIT
Call GOSUB_TEST
Call IF_TEST
Call CASE_TEST
Call LOOP_TEST
Call ERROR_TEST
Call WRSEQ_TEST
Call SCOPES_TEST

#CallJS print("starting") From "etna-engine/lib/helpers"
#Integer FOO
#FOO = func LOP(10000)
#CallJS print("done " + num$(FOO)) From "etna-engine/lib/helpers"

Call FINISH From XUNIT
Return "That's all folks"

$SUB1
	Char SUBRES
	SUBRES = "A"
	Gosub SUB2
	SUBRES += "B"
	Gosub SUB2
	SUBRES += "C"
Return

$SUB2
 	SUBRES += "D"
	Gosub SUB3
	SUBRES += "E"
Return

$SUB3
	SUBRES += "F"
Return

$SUB4
	If SUBRES = "A" Then SUBRES += "B" : Return : Endif
	SUBRES += "C"
Return

SubProg GOSUB_TEST()
    Gosub SUB1 
	Call CHECK_EQUAL("GOSUB", SUBRES, "ADFEBDFEC") From XUNIT
    Gosub SUB3
	Call CHECK_EQUAL("GOSUB", SUBRES, "ADFEBDFECF") From XUNIT
	SUBRES = "" : Gosub SUB4
	Call CHECK_EQUAL("GOSUB", SUBRES, "C") From XUNIT
	SUBRES = "A" : Gosub SUB4
	Call CHECK_EQUAL("GOSUB", SUBRES, "AB") From XUNIT
End

FunProg IF_PROG(X)
	Value Integer X
	Char GOT
	GOT=""
	If X = 10 Then GOT += "A" Endif
	If X <> 10 Then GOT += "B" Endif
	If X = 10 Then GOT += "C" Else GOT += "D" Endif
	If X <> 10 Then GOT += "E" Else GOT += "F" Endif
	If X = 10 Then GOT += "G" Elsif X=10 Then GOT += "H" Else GOT += "I" Endif
	If X <> 10 Then GOT += "J" Elsif X=10 Then GOT += "K" Else GOT += "L" Endif
	If X <> 10 Then GOT += "M" Elsif X<>10 Then GOT += "N" Else GOT += "O" Endif
End GOT

SubProg IF_TEST()
	Call CHECK_EQUAL("IF", func IF_PROG(10), "ACFGKO") From XUNIT
	Call CHECK_EQUAL("IF", func IF_PROG(5), "BDEIJM") From XUNIT
End

FunProg CASE_PROG(X)
	Value Integer X
	Char GOT
	GOT=""
	Case X Endcase
	Case X When 10 GOT += "A" Endcase
	Case X When 5,10 GOT += "B" When 20,30 GOT += "C" Endcase
End GOT

FunProg CASE_PROG2(X)
	Value Integer X
	Char GOT
	GOT=""
	Case X When 10 GOT += "A" When Default GOT += "B" Endcase
	Case X When Default GOT += "C" Endcase
End GOT

SubProg CASE_TEST()
	Call CHECK_EQUAL("CASE", func CASE_PROG(10), "AB") From XUNIT
	Call CHECK_EQUAL("CASE", func CASE_PROG(20), "C") From XUNIT
	Call CHECK_EQUAL("CASE", func CASE_PROG(25), "") From XUNIT
	Call CHECK_EQUAL("CASE", func CASE_PROG2(10), "AC") From XUNIT
	Call CHECK_EQUAL("CASE", func CASE_PROG2(25), "BC") From XUNIT
End

$ERROR_RESUME
Resume

$ERROR_END
End "Z"

$ERROR_RECURSE
	CallJS sync fail("Error during error") From "etna-engine/lib/helpers"
Resume

$ERROR_SUB
	CallJS sync fail("T5") From "etna-engine/lib/helpers" 
Return

SubProg ERROR_PROG(X)
	Value Integer X
	Char GOT
	GOT=""
	Onerrgo ERROR_RESUME
	If X = 1 Then GOT += "A": CallJS sync fail("T1") From "etna-engine/lib/helpers" : GOT += "B": Endif
	Onerrgo ERROR_END
	If X = 2 Then GOT += "C": CallJS sync fail("T2") From "etna-engine/lib/helpers" : GOT += "D": Endif
	Onerrgo
	If X = 3 Then GOT += "E": CallJS sync fail("T3") From "etna-engine/lib/helpers" : GOT += "F": Endif
	Onerrgo ERROR_RECURSE
	If X = 4 Then GOT += "G": CallJS sync fail("T4") From "etna-engine/lib/helpers" : GOT += "H": Endif
	Onerrgo
	If X = 5 Then GOT += "I": Gosub ERROR_SUB : GOT += "J": Endif
	GOT += "K"
End GOT

$ERROR_UNHANDLED
	Call CHECK_EQUAL("ERROR", ERROR_MESSAGE, "UNHANDLED ERROR") From XUNIT
Resume

SubProg ERROR_TEST()
	Char ERROR_MESSAGE
	Onerrgo ERROR_UNHANDLED
	Call CHECK_EQUAL("ERROR", func ERROR_PROG(0), "K") From XUNIT
	Call CHECK_EQUAL("ERROR", func ERROR_PROG(1), "ABK") From XUNIT
	Call CHECK_EQUAL("ERROR", func ERROR_PROG(2), "Z") From XUNIT
	ERROR_MESSAGE = "UNHANDLED ERROR" 
	Call CHECK_EQUAL("ERROR", func ERROR_PROG(3), "???") From XUNIT
	# Call CHECK_EQUAL("ERROR", func ERROR_PROG(4), "???") From XUNIT
	Call CHECK_EQUAL("ERROR", func ERROR_PROG(5), "???") From XUNIT
	ERROR_MESSAGE = ""
	Call CHECK_EQUAL("ERROR", func ERROR_PROG(6), "K") From XUNIT
End

Funprog FACT_R(N)
	Value Integer N
	If N > 1 End N * func FACT_R(N-1) 
	Else End 1 
Endif

Funprog FACT_W(N)
	Value Integer N
	Integer R
	R = 1 
	While N > 1 : R *= N : N -= 1 Wend
End R

Funprog FACT_WB0(N)
	Value Integer N
	Integer R
	R = 1 
	While N > 1 : R *= N : Break 0 : N -= 1 Wend
End R

Funprog FACT_WB1(N)
	Value Integer N
	Integer R
	R = 1 
	While 1 : R *= N : Break N <= 1 : N -= 1 Wend
End R

Funprog FACT_U(N)
	Value Integer N
	Integer R
	R = 1 
	Repeat R *= N : N -= 1 : Until N <= 1
End R

Funprog FACT_F(N)
	Value Integer N
	Integer R
	R = 1 
	For I = 1 To N : R *= I : Next
End R

Funprog FACT_L(N)
	Value Integer N
	Integer R
	R = 1 
	For I = 6,2,10 : R *= I : Next
End R

SubProg LOOP_TEST()
	Call CHECK_EQUAL("LOOP", func FACT_R(5), 120) From XUNIT
	Call CHECK_EQUAL("LOOP", func FACT_W(5), 120) From XUNIT
	Call CHECK_EQUAL("LOOP", func FACT_WB0(5), 120) From XUNIT
	Call CHECK_EQUAL("LOOP", func FACT_WB1(5), 120) From XUNIT
	Call CHECK_EQUAL("LOOP", func FACT_U(5), 120) From XUNIT
	Call CHECK_EQUAL("LOOP", func FACT_F(5), 120) From XUNIT
	Call CHECK_EQUAL("LOOP", func FACT_L(5), 120) From XUNIT
End

Funprog SCOPES_SUB(P1,P2)
    Value Char P1, P2
	Local Char LTEST
	GTEST = P1
	LTEST = P2
	Call CHECK_EQUAL("SCOPES SUB L", LTEST, "D") From XUNIT
End

Funprog SCOPES_TEST()
	Global Char GTEST
	Local Char LTEST
	GTEST = "A"
	LTEST = "B"
	Call SCOPES_SUB("C", "D")
	Call CHECK_EQUAL("SCOPES G", GTEST, "C") From XUNIT
	Call CHECK_EQUAL("SCOPES L", LTEST, "B") From XUNIT
	
End

SubProg WRSEQ_TEST()
	openo "/tmp/factorials.txt"
	Integer N
	N=1
	While N < 3 : wrseq N, func FACT_R(N) : N += 1 : Wend
	openo
End

SubProg LOP(N)
	Value Integer N
	Local Integer I
	I = N
	While I > 0
		I -= 1
	Wend
End I
