Local Clbfile RESULT
RESULT=func TESTSUITE()
Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_DATETIME_"+GUSER
Call LEC_TRACE From LECFIC
End


#**
#* The main entry point of the unit test suite for Requirement 69072
#*
#* @see
#* <a href="http://dotat.at/tmp/ISO_8601-2004_E.pdf">International standart for representation of date and time </a>
#*!
Funprog TESTSUITE()
#Call ADD_TESTCASE("TC_DECL", "Datetime declaration", 2) From AXUNIT
#Call ADD_TESTCASE("TC_GDATETIME", "Fonction gdatetime$", 9) From AXUNIT
#Call ADD_TESTCASE("TC_DATETIME", "Fonction datetime$", 3) From AXUNIT
#Call ADD_TESTCASE("TC_NUM", "Fonction num$", 1) From AXUNIT
Call ADD_TESTCASE("TC_OP_COMP", "Comparison of datetimes", 8) From AXUNIT
#Call ADD_TESTCASE("TC_OP_OPERATIONS", "Operation on datetimes", 7) From AXUNIT
#Call ADD_TESTCASE("TC_OP_LOGICAL", "Logical operations on datetimes", 4) From AXUNIT
#Call ADD_TESTCASE("TC_TRANSCLASS", "Transclass datetime<->chaîne", 2) From AXUNIT
#Call ADD_TESTCASE("TC_SADXXX", "Sauvegarde er récupération d'un champ Datetime de la BD", 8) From AXUNIT
End func AXUNIT.RUN_TESTSUITE("REQ-69072", "Datetime GMT")

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume


Subprog TC_DECL
Integer EX
Onerrgo ERROR
Local Datetime MYDATE

Call CHECK_NOTEQUAL(dim(MYDATE),-1) From AXUNIT
Call CHECK_EQUAL(type(MYDATE),526) From AXUNIT

End

Subprog TC_GDATETIME
Integer EX
Onerrgo ERROR

Local Datetime MYDATE
Local Char ONLYDATE(20)
Local Char ONLYTIME(20)
Local Char COMPLETEDATE(20)
Local Char BADDATE(20)
Local Char GOT(25)
Local Char EXPECT(25)
ONLYDATE="2011-12-05"
ONLYDATEZ="2011-12-05"+"Z"
ONLYTIME="09:30:15Z"
COMPLETEDATE="2011-12-05T09:30:15Z"


#Date nulle
MYDATE=gdatetime$("")
GOT=num$(MYDATE)
#Infbox GOT
EXPECT="0000-00-00T00:00:00Z"
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT


EXPECT=ONLYDATE+"T00:00:00"+"Z"
MYDATE=gdatetime$(ONLYDATEZ)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
#Infbox "ONLYDATE"-ONLYDATE-"GOT:"-GOT

MYDATE=gdatetime$(ONLYTIME)
GOT= num$(MYDATE)
#Infbox GOT
#Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

#seulement la partie horaire , pas sûr pour les unités , peut être que cela doit être 1111-11-11T+horaire
#EXPECT="0000-00-00T"+ONLYTIME
#MYDATE=gdatetime$(ONLYTIME)
#GOT= num$(MYDATE)
#Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

EXPECT=COMPLETEDATE
MYDATE=gdatetime$(COMPLETEDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
#Infbox GOT

BADDATE="2011-15-05T09:30:15Z"
EXPECT="0000-00-00T00:00:00Z"

MYDATE=gdatetime$(BADDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

BADDATE="15-05-2011T09:30:15Z"

MYDATE=gdatetime$(BADDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT


BADDATE="n'importequoi"

MYDATE=gdatetime$(BADDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

End


Subprog TC_DATETIME
Integer EX
Onerrgo ERROR

Local Datetime CURRENTDTM
Local Char DATETMSTR(25)

CURRENTDTM=datetime$
DATETMSTR=num$(CURRENTDTM)
Local Char TOKEN(10)

Local Integer DATETMY, DATETMM, DATETMD, DATEY, DATEM, DATED


TOKEN=left$(DATETMSTR,4)
Local Integer DATETMY
DATETMY=val(TOKEN)
TOKEN=mid$(DATETMSTR,6,2)
DATETMM=val(TOKEN)
TOKEN=mid$(DATETMSTR,9,2)
DATETMD=val(TOKEN)




Local Date TODAY
Local Char TODAYSTR(20)
TODAY=date$
TODAYSTR=num$(TODAY)

Local Integer DATEY
DATEY=year(TODAY)
Local Integer DATEM
DATEM=month(TODAY)
Local Integer DATED
DATED=day(TODAY)
Local Integer GOT
GOT=evalue("DATETMY=DATEY | DATETMY=DATEY+1 | DATETMY=DATEY-1 ")
Call CHECK_TRUE(GOT) From AXUNIT
GOT=evalue("DATETMM=DATEM | DATETMM=DATEM+1 | DATETMM=DATEM-1")
Call CHECK_TRUE (GOT) From AXUNIT
GOT=evalue("DATETMD=DATED | DATETMD=DATED+1 | DATETMD=DATED-1")
Call CHECK_TRUE (GOT) From AXUNIT
End






Subprog TC_NUM
Integer EX
Onerrgo ERROR

Local Datetime MYDATETM
Local Char DATETMSTR(25)
MYDATETM=datetime$
DATETMSTR=num$(MYDATETM)
Local Integer GOT,EXPECT
EXPECT=1 #pat retourne 1 si la chaîne est conforme au modèle
GOT=pat(DATETMSTR,"####-##-##T##:##:##Z")
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
End



Subprog TC_OP_COMP
Integer EX
Onerrgo ERROR

Local Datetime DATE1,DATE2

DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE2=gdatetime$("2012-02-01T05:07:08Z")
Call CHECK_TRUE(DATE1=DATE1) From AXUNIT
Call CHECK_TRUE(DATE2<>DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<>DATE2) From AXUNIT
Call CHECK_TRUE(DATE2>DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<DATE2) From AXUNIT
Call CHECK_TRUE(DATE2>=DATE1) From AXUNIT
Call CHECK_TRUE(DATE2>=DATE2) From AXUNIT
Call CHECK_TRUE(DATE1<=DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<=DATE2) From AXUNIT

End

Subprog TC_OP_OPERATIONS
Integer EX
Onerrgo ERROR

Local Datetime DATE1,DATE2

#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 += 1
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 -= 1
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 *= 1
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 /= 1
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 =mod(DATE1,1)
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 =DATE1^2
#Operation not allowed :
EX=10
DATE1=abs(DATE1)
End

Subprog TC_OP_LOGICAL
Integer EX
Onerrgo ERROR

Local Datetime DATE1
Local Integer RESULT

DATE1=gdatetime$("2012-01-01T05:07:08Z")
#Operation not allowed :
EX=10
RESULT = DATE1 and DATE1
#Operation not allowed :
EX=10
RESULT = DATE1 or DATE1
#Operation not allowed :
EX=10
RESULT = DATE1 xor DATE1
#Operation not allowed :
EX=10
RESULT = !DATE1

End

Subprog TC_TRANSCLASS
Integer EX
Onerrgo ERROR

Local Datetime CURRENTDTM
Local Char CURRENTDTMSTR
Local Char GOT, EXPECT

Local File AQRSTU [TEST] # déclaration du fichier TEST
Local Mask AQRSTUD [TEST] # déclaration du masque TEST
Call GENERDIFFSCREEN(nomap,"AQRSTU") From INTRUTILB

Local Mask AQRSTUD [TEST1] # déclaration du masque TEST
Call GENERDIFFSCREEN(nomap,"AQRSTU") From INTRUTILB

#Inpbox Mask [TEST] As [INP1] # déclaration de la boite
#Boxact [INP1]  # Affichage de la boite de saisie
#Boxinp [INP1] # Saisie dans la boite
CURRENTDTM=datetime$
CURRENTDTMSTR=num$(CURRENTDTM)
EXPECT=CURRENTDTMSTR

[M:TEST]MYDATETM=CURRENTDTMSTR

[F:TEST] = [M:TEST]

GOT=num$([F:TEST]MYDATETM)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

[M:TEST1] =[F:TEST]
GOT=[M:TEST1]MYDATETM
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

End

Subprog TC_SADXXX
Integer EX
Onerrgo ERROR

Local Integer UPDATESTATUS
Local Datetime MYDATETM
Local Char DATESTR(20)
Local Char EXPECT,GOT

DATESTR="2011-12-05T09:30:15Z"
EXPECT=DATESTR

MYDATETM=gdatetime$(DATESTR)
UPDATESTATUS=func UPDATE_RECORD(172,MYDATETM)

Call CHECK_TRUE(UPDATESTATUS=0) From AXUNIT

If (UPDATESTATUS=0)
 Local File AQRSTU [TEST]
 [F:TEST]STU=172
 Read [TEST]STU = 172 # on se positionne dessus
Call CHECK_EQUAL([S]fstat,0) From AXUNIT

GOT=num$([F:TEST]MYDATETM)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
Close Local File [TEST]
Endif

#Date nulle
MYDATETM=gdatetime$("")
UPDATESTATUS=func UPDATE_RECORD(172,MYDATETM)
EXPECT="0000-00-00T00:00:00Z"

Call CHECK_TRUE(UPDATESTATUS=0) From AXUNIT

If (UPDATESTATUS=0)

Local File AQRSTU [TEST]
[F:TEST]STU=172

Read [TEST]STU = [F:TEST]STU # on se positionne dessus
GOT=num$([F:TEST]MYDATETM)
Call CHECK_EQUAL([S]fstat,0) From AXUNIT
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
Endif
Close Local File [TEST]

#test clause where - serialisation grammaire pour SADXXX avec des datetimes
Local Integer EXPECT, GOT
EXPECT=172

MYDATETM=datetime$

UPDATESTATUS=func UPDATE_RECORD(172,MYDATETM)

If (UPDATESTATUS=0)
 Local File AQRSTU [TEST]
 #Infbox num$([L]MYDATETM)
 Filter [TEST] Where MYDATETM=[L]MYDATETM #172 # DATETIME$

 Read [TEST]STU First# on se positionne dessus
 Call CHECK_EQUAL([S]fstat,0) From AXUNIT

 GOT=[F:TEST]STU
 Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

 Filter [TEST] Where [TEST]STU=172 # DATETIME$
 Read [TEST]STU First

 Close Local File [TEST]
Endif
End

#Helper function for Test SADXXX
Funprog  UPDATE_RECORD(CLE,PDATM)
Value Integer CLE
Variable Datetime PDATM

Local Integer STAT

Local File AQRSTU [TEST]
[TEST]STU = CLE
[TEST]MYDATETM=PDATM

 Trbegin [TEST] # début de la transaction
Write [TEST] # écriture sur fichier
If [S]fstat # en cas de problème quelconque
    Rollback # la transaction est annulée
Else
    Commit # sinon elle est validée
Endif


 If [S]fstat=3 #cle dupliquee (l'enregistrement existe), on fait  update
  Trbegin [TEST] # début de la transaction
   Rewrite [TEST]STU = [F:TEST]STU

   If [S]fstat # en cas de problème quelconque
       Rollback # la transaction est annulée
   Else
       Commit # sinon elle est validée
   Endif
   #Infbox num$([S]fstat)
 Endif
STAT=[S]fstat
Close Local File [TEST]
End STAT
