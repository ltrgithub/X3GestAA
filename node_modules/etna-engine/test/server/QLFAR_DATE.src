Local Clbfile RESULT
RESULT=func TESTSUITE()
Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_DATE_"+GUSER
Call LEC_TRACE From LECFIC
End


#**
#* The main entry point of the unit test suite for Requirement 69072
#*
#* @see
#* <a href="http://dotat.at/tmp/ISO_8601-2004_E.pdf">International standart for representation of date and time </a>
#*!
Funprog TESTSUITE()
Call ADD_TESTCASE("TC_DECL", "Date declaration", 2) From AXUNIT
Call ADD_TESTCASE("TC_DATENULL", "Null dates", 2) From AXUNIT
Call ADD_TESTCASE("TC_DATE", "'DATE$' - Function", 6) From AXUNIT
Call ADD_TESTCASE("TC_NUM", "'NUM$' - Function", 1) From AXUNIT
Call ADD_TESTCASE("TC_NDAY", "'NDAY' - Number of days since 01/01/1600",4) From AXUNIT
Call ADD_TESTCASE("TC_NDAYDATE", "'NDAY$' - Return date based on number of days since 01/01/1600",4) From AXUNIT
Call ADD_TESTCASE("TC_BEGDATE", "BEGDATE: Beginning date",3) From AXUNIT
Call ADD_TESTCASE("TC_ENDDATE", "ENDDATE: Ending date",3) From AXUNIT
Call ADD_TESTCASE("TC_OP_COMP", "OP_COMP: Comparison of dates", 9) From AXUNIT
Call ADD_TESTCASE("TC_OP_OPERATIONS", "OP_OPERATIONS: Operation on dates", 5) From AXUNIT
Call ADD_TESTCASE("TC_OP_LOGICAL", "OP_LOGICAL: Logical operation on dates", 4) From AXUNIT
Call ADD_TESTCASE("TC_ADDMONTH", "'ADDMONTH' - Add month to date",3) From AXUNIT
Call ADD_TESTCASE("TC_EOMONTH", "'EOMONTH' - Date of last day of month ",3) From AXUNIT
Call ADD_TESTCASE("TC_DAY", "'DAY$' - Day of week",8) From AXUNIT
Call ADD_TESTCASE("TC_MONTH", "'MONTH' - Returns month number",12) From AXUNIT
Call ADD_TESTCASE("TC_MONTHNAM", "'MONTH$'- Month name",12) From AXUNIT
Call ADD_TESTCASE("TC_ADXDCS", "'ADXDCS' - Starting date for 2 digit year",3) From AXUNIT
Call ADD_TESTCASE("TC_AWEEK", "'AWEEK'-Calculate beginning day of week date based on week number",3) From AXUNIT
Call ADD_TESTCASE("TC_WEEK", "'WEEK' - Calculate week number based on date",2) From AXUNIT
Call ADD_TESTCASE("TC_YEAR", "'YEAR' - Calculate year based on date",3) From AXUNIT
Call ADD_TESTCASE("TC_DATESYST", "'DATESYST' - Return system date",2) From AXUNIT
Call ADD_TESTCASE("TC_GDAT", "'GDAT$' - Construct date from date elements", 4) From AXUNIT
Call ADD_TESTCASE("TC_MIN", "'MIN' - Find minimum date in a collection of dates", 1) From AXUNIT
Call ADD_TESTCASE("TC_MAX", "'MAX' - Find max date in a collection of dates", 1) From AXUNIT
Call ADD_TESTCASE("TC_FIND", "'FIND' - Find date in a collection of dates", 2) From AXUNIT
Call ADD_TESTCASE("TC_UNI", "'UNI' - Determine if date is a unique date in a collection of dates", 2) From AXUNIT
End func AXUNIT.RUN_TESTSUITE("REQ-69072", "DATE GMT")

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume

Subprog TC_YEAR
Integer EX
Onerrgo ERROR
Local Date MYDATE
Local Integer GOT_INT,EXP_INT

GOT_INT = year([01/01/2017])
EXP_INT = 2017
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT


GOT_INT = year([00/00/0000])
EXP_INT = 0
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

GOT_INT = year([01/01/9999])
EXP_INT = 9999
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

End

Subprog TC_DATESYST
Integer EX
Onerrgo ERROR
Local Date MYDATE,GOT_DATE,EXP_DATE

# this will work as long as we do not cross midnight during the execution
GOT_DATE = [S]datesyst
EXP_DATE = date$
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

[S]datesyst = [28/01/2016]
EXP_DATE = [28/01/2016]

Call CHECK_EQUAL([S]datesyst,EXP_DATE) From AXUNIT

[S]datesyst = date$                               # reset to correct date
End

Subprog TC_GDAT
Integer EX
Onerrgo ERROR
Local Date MYDATE,GOT_DATE,EXP_DATE

GOT_DATE=gdat$(31,1,2015)
EXP_DATE=[31/1/2015]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

GOT_DATE=gdat$(0,0,0)
EXP_DATE=[00/00/0000]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

GOT_DATE=gdat$(31,12,9999)
EXP_DATE=[31/12/9999]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

[S]adxdcs=1940
GOT_DATE=gdat$(31,1,15)
EXP_DATE=[31/1/2015]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

EX=56
GOT_DATE=gdat$(31,13,2015)

End

Subprog TC_MIN
Integer EX
Onerrgo ERROR
Local Date MYDATE(10), GOT_DATE, EXP_DATE
Local Integer I, GOT_INT, EXP_INT
Local Char SS(20)

For I=0 To 4
  MYDATE(I)=date$+I
Next

For I=5 To 9
MYDATE(I)=date$-I
Next

#GOT_DATE=min(MYDATE(0..dim(MYDATE)-1))
GOT_DATE=min(MYDATE)
EXP_DATE = date$-9
Infbox num$(GOT_DATE)
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT


End

Subprog TC_MAX
Integer EX
Onerrgo ERROR
Local Date MYDATE(10), GOT_DATE, EXP_DATE
Local Integer I, GOT_INT, EXP_INT

For I=0 To 4
  MYDATE(I)=date$+I
Next

For I=5 To 9
MYDATE(I)=date$-I
Next

GOT_DATE=max(MYDATE)
EXP_DATE=date$+4

Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

End

Subprog TC_FIND
Integer EX
Onerrgo ERROR
Local Date MYDATE(10),FIND_DATE
Local Integer I, GOT_INT, EXP_INT

For I=0 To 4
  MYDATE(I)=date$+I
Next

For I=5 To 9
MYDATE(I)=date$-I
Next

FIND_DATE=date$+3
GOT_INT=find(FIND_DATE,MYDATE)
EXP_INT=4
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

FIND_DATE=date$+20
GOT_INT=find(FIND_DATE,MYDATE)
EXP_INT=0
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

End

Subprog TC_UNI
Integer EX
Onerrgo ERROR
Local Date MYDATE(10),FIND_DATE
Local Integer I, GOT_INT, EXP_INT

For I=0 To 4
  MYDATE(I)=date$+I
Next

For I=5 To 9
MYDATE(I)=date$-I
Next

GOT_INT=uni(MYDATE)
EXP_INT=0
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

For I=5 To 9
MYDATE(I)=date$
Next

GOT_INT=uni(MYDATE)
EXP_INT=6
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

End


Subprog TC_DECL
Integer EX
Onerrgo ERROR
Local Date MYDATE
Local Integer TB(1..6)

Call CHECK_NOTEQUAL(dim(TB),-1) From AXUNIT
Call CHECK_EQUAL(type(MYDATE),3) From AXUNIT

End

Subprog TC_ADXDCS
Integer EX
Onerrgo ERROR

Local Date GOT_DATE,EXP_DATE
Local Date MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

[S]adxdcs = 1940
GOT_DATE = gdat$(31,1,05)
EXP_DATE = [31/01/2005]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

[S]adxdcs = 1940
GOT_DATE = gdat$(31,1,40)
EXP_DATE = [31/01/1940]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

[S]adxdcs = 1940
GOT_DATE = gdat$(31,1,99)
EXP_DATE = [31/01/1999]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

End

Subprog TC_DAY
Integer EX
Onerrgo ERROR

Local Date GOT_DATE,EXP_DATE
Local Date MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

For I=1 To 7
  EXPECT = mess(I,742,1)
  GOT = day$([02/01/1600]+I)
  Infbox GOT-EXPECT
  Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
Next


EX=56
GOT=day$(date$+5000000)

End

Subprog TC_WEEK
Integer EX
Onerrgo ERROR

Local Integer GOT_INT,EXP_INT
Local Date MYDATE
Local Char GOT(25)
Local Char EXPECT(25)

GOT_INT = week([30/12/2013])
EXP_INT = 53                                   # Monday of first week of 2014
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

GOT_INT = week( [29/12/2012] )
EXP_INT = 52                       # Monday of first week of 2014
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

End

Subprog TC_AWEEK
Integer EX
Onerrgo ERROR

Local Date GOT_DATE,EXP_DATE
Local Date MYDATE
Local Char GOT(25)
Local Char EXPECT(25)

GOT_DATE = aweek(1,2014)
EXP_DATE = [30/12/2013]                       # Monday of first week of 2014
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

GOT_DATE = aweek(1,2013)
EXP_DATE = [31/12/2012]                       # Monday of first week of 2014
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

EX=56
GOT_DATE=aweek(1,1599)

End

Subprog TC_MONTH
Integer EX
Onerrgo ERROR

Local Integer I,MONTH_NUM
Local Date GOT_DATE,EXP_DATE
Local Date MYDATE
Local Char GOT(25)
Local Char EXPECT(25)

For I=1 To 12
MONTH_NUM= month(gdat$(1,I,2014))
Call CHECK_EQUAL(MONTH_NUM,I) From AXUNIT
Next

End



Subprog TC_MONTHNAM
Integer EX
Onerrgo ERROR

Local Integer I
Local Date GOT_DATE,EXP_DATE
Local Date MYDATE
Local Char MONTH_NAM(25)
Local Char GOT(25)
Local Char EXPECT(25)

For I=1 To 12
MONTH_NAM= month$(gdat$(1,I,2014))
Call CHECK_EQUAL(MONTH_NAM,mess(I,9001,1)) From AXUNIT
Next



End


Subprog TC_ADDMONTH
Integer EX
Onerrgo ERROR

Local Date GOT_DATE,EXP_DATE
Local Date MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

GOT_DATE = addmonth([31/01/2014],1)
EXP_DATE = [28/02/2014]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

EX=56
GOT_DATE = addmonth([31/01/2014],-5000)

EX=56
GOT_DATE = addmonth([31/01/2014],150000)
End

Subprog TC_EOMONTH
Integer EX
Onerrgo ERROR

Local Date GOT_DATE,EXP_DATE
Local Date MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

GOT_DATE = eomonth([01/02/1900])        # Not a leap year because year ends 00 (hundred years)
EXP_DATE = [28/02/1900]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

GOT_DATE = eomonth([01/02/2000])        # Is a leap year because 400 year increment
EXP_DATE = [29/02/2000]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT


GOT_DATE = eomonth([01/02/2100])        # Not a leap year because year ends 00 (hundred years)
EXP_DATE = [28/02/2100]
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT
End

Subprog TC_BEGDATE
Integer EX
Onerrgo ERROR

Local Date MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

EXPECT= "01/01/1600"
MYDATE = [01/01/1600]
GOT=num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

MYDATE = [00/00/0000]+1
GOT=num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

MYDATE = [01/01/1600]-1
GOT=num$(MYDATE)
Call CHECK_EQUAL(GOT,"00/00/0000") From AXUNIT

End

Subprog TC_NDAY
Integer EX
Onerrgo ERROR

Local Date MYDATE
Local Integer DAYS,GOT_INT,EXPECT_INT
Local Char GOT(25)
Local Char EXPECT(25)

DAYS = nday([31/12/9999])
EXPECT_INT= 3068036
GOT_INT = DAYS
Call CHECK_EQUAL(GOT_INT,EXPECT_INT) From AXUNIT

DAYS = nday([01/01/1600])
EXPECT_INT= 0
GOT_INT = DAYS
Call CHECK_EQUAL(GOT_INT,EXPECT_INT) From AXUNIT

DAYS = nday([00/00/0000])
EXPECT_INT= -1
GOT_INT = DAYS
Call CHECK_EQUAL(GOT_INT,EXPECT_INT) From AXUNIT

EX = 56
DAYS = nday([01/01/1600]-5)
EXPECT_INT= 3068036
GOT_INT = DAYS

EX = 10
DAYS = nday("01/01/1600")

End

Subprog TC_NDAYDATE
Integer EX
Onerrgo ERROR

Local Date MYDATE,GOT_DATE,EXPECT_DATE
Local Integer DAYS,GOT_INT,EXPECT_INT
Local Char GOT(25)
Local Char EXPECT(25)

EXPECT_DATE = [31/12/9999]
GOT_DATE = nday$(3068036)
Call CHECK_EQUAL(GOT_DATE,EXPECT_DATE) From AXUNIT

EXPECT_DATE = [00/00/0000]
GOT_DATE = nday$(-1)
Call CHECK_EQUAL(GOT_DATE,EXPECT_DATE) From AXUNIT

EXPECT_DATE = [01/01/1600]
GOT_DATE = nday$(0)
Call CHECK_EQUAL(GOT_DATE,EXPECT_DATE) From AXUNIT

EXPECT_DATE = [02/01/1600]
GOT_DATE = nday$(1)
Call CHECK_EQUAL(GOT_DATE,EXPECT_DATE) From AXUNIT

EX=56
GOT_DATE = nday$(-5)
End

Subprog TC_ENDDATE
Integer EX
Onerrgo ERROR

Local Integer DAYS
Local Date MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

EXPECT= "31/12/9999"
MYDATE = [01/01/1600]+3068036
GOT=num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

EX=56
MYDATE = [01/01/1600]+4068036
GOT=num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

End

Subprog TC_DATENULL
Integer EX
Onerrgo ERROR

Local Date MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)


#Date null - dd/mm/yyyy
MYDATE=[00/00/0000]
GOT=num$(MYDATE)
EXPECT="00/00/0000"
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

MYDATE="00000000"
GOT=num$(MYDATE)
EXPECT="00/00/0000"
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

End


Subprog TC_DATE
Integer EX
Onerrgo ERROR

Local Integer DATE_YYYY, DATE_MM, DATE_DD
Local Char DATE_YYYY_STR(4), DATE_MM_STR(2), DATE_DD_STR(2)

Local Date JUNE_DATE                # Format "yyyymmdd"
Local Char JUNE_DATE_STR(10)        # Format "dd/mm/yyyy"
Local Char EXP_YYYY(4),EXP_MM(2),EXP_DD(2)
JUNE_DATE=[25/06/2014]
JUNE_DATE_STR=num$([25/06/2014])

EXP_YYYY= "2014"
EXP_MM = "06"
EXP_DD = "25"

# Year comparison
DATE_YYYY_STR=right$(JUNE_DATE_STR,7)
Call CHECK_EQUAL(num$(DATE_YYYY_STR),EXP_YYYY) From AXUNIT
DATE_YYYY=year(JUNE_DATE)
Call CHECK_EQUAL(num$(DATE_YYYY),EXP_YYYY) From AXUNIT

# Month comparison
DATE_MM_STR=mid$(JUNE_DATE_STR,4,2)
Call CHECK_EQUAL(num$(DATE_MM_STR),EXP_MM) From AXUNIT
DATE_MM=month(JUNE_DATE)
EXP_MM="6"
Call CHECK_EQUAL(num$(DATE_MM),EXP_MM) From AXUNIT

# Day comparison
DATE_DD_STR=left$(JUNE_DATE_STR,2)
Call CHECK_EQUAL(num$(DATE_DD_STR),EXP_DD) From AXUNIT
DATE_DD=day(JUNE_DATE)
Call CHECK_EQUAL(num$(DATE_DD),EXP_DD) From AXUNIT

End


Subprog TC_NUM
Integer EX
Onerrgo ERROR

Local Date MY_DATE
Local Char MY_DATE_STR(10)
MY_DATE=date$
MY_DATE_STR=num$(MY_DATE)
Local Integer GOT,EXPECT
EXPECT=1 #pat returns 1 if date string follows the pattern
GOT=pat(MY_DATE_STR,"##/##/####")
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
End



Subprog TC_OP_COMP
Integer EX
Onerrgo ERROR

Local Date DATE1,DATE2

DATE1=[01/01/2012]
DATE2=[01/02/2012]
Call CHECK_TRUE(DATE1=DATE1) From AXUNIT
Call CHECK_TRUE(DATE2<>DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<>DATE2) From AXUNIT
Call CHECK_TRUE(DATE2>DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<DATE2) From AXUNIT
Call CHECK_TRUE(DATE2>=DATE1) From AXUNIT
Call CHECK_TRUE(DATE2>=DATE2) From AXUNIT
Call CHECK_TRUE(DATE1<=DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<=DATE2) From AXUNIT

End

Subprog TC_OP_OPERATIONS
Integer EX
Onerrgo ERROR

Local Date DATE1,DATE2

#Add 1 day
DATE1=[01/01/2012]
DATE1 += 1
#Operation not allowed :
DATE1=[01/01/2012]
DATE1 -= 1
#Operation not allowed :
EX=10
DATE1=[01/01/2012]
DATE1 *= 1
#Operation not allowed :
EX=10
DATE1=[01/01/2012]
DATE1 /= 1
#Operation not allowed :
EX=10
DATE1=[01/01/2012]
DATE1 =mod(DATE1,1)
#Operation not allowed :
EX=10
DATE1=[01/01/2012]
DATE1 =DATE1^2
#Operation not allowed :
EX=10
DATE1=abs(DATE1)
End

Subprog TC_OP_LOGICAL
Integer EX
Onerrgo ERROR

Local Date DATE1
Local Integer RESULT

DATE1=[01/01/2012]
#Operation not allowed :
EX=10
RESULT = DATE1 and DATE1
#Operation not allowed :
EX=10
RESULT = DATE1 or DATE1
#Operation not allowed :
EX=10
RESULT = DATE1 xor DATE1
#Operation not allowed :
EX=10
RESULT = !DATE1

End

Subprog TC_TRANSCLASS
Integer EX
Onerrgo ERROR

Local Date CURRENT_DATE
Local Char CURRENT_DATE_STR(10)
Local Char GOT(30), EXPECT(30)

Local File AQRSTU [TEST] # déclaration du fichier TEST
Local Mask AQRSTUD [TEST] # déclaration du masque TEST
Call GENERDIFFSCREEN(nomap,"AQRSTU") From INTRUTILB

#Inpbox Mask [TEST] As [INP1] # déclaration de la boite
#Boxact [INP1]  # Affichage de la boite de saisie
#Boxinp [INP1] # Saisie dans la boite
CURRENT_DATE=date$
CURRENT_DATESTR=num$(CURRENT_DATE)
EXPECT=CURRENT_DATE_STR

[M:TEST]DATEN=CURRENT_DATE
[F:TEST] = [M:TEST]

GOT=num$([F:TEST]DATEN)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

[M:TEST1] =[F:TEST]
GOT=[M:TEST1]DATEN
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

End

Subprog TC_SADXXX
Integer EX
Onerrgo ERROR

Local Integer UPDATESTATUS
Local Date DATEN
Local Char JUNE_DATE_STR(20)
Local Char EXPECT(30),GOT(30)

JUNE_DATE_STR="05/12/2011"
EXPECT=JUNE_DATE_STR

DATEN=JUNE_DATE_STR
UPDATESTATUS=func UPDATE_RECORD(172,DATEN)

Call CHECK_TRUE(UPDATESTATUS=0) From AXUNIT

If (UPDATESTATUS=0)
 Local File AQRSTU [TEST]
 [F:TEST]STU=172
 Read [TEST]STU = 172 # on se positionne dessus
Call CHECK_EQUAL([S]fstat,0) From AXUNIT

GOT=num$([F:TEST]DATEN)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
Close Local File [TEST]
Endif

#Date nulle
DATEN=[00/00/0000]
UPDATESTATUS=func UPDATE_RECORD(172,DATEN)
EXPECT = "00/00/0000"
Call CHECK_TRUE(UPDATESTATUS=0) From AXUNIT

If (UPDATESTATUS=0)

Local File AQRSTU [TEST]
[F:TEST]STU=172

Read [TEST]STU = [F:TEST]STU # on se positionne dessus
GOT=num$([F:TEST]DATEN)
Call CHECK_EQUAL([S]fstat,0) From AXUNIT
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
Endif
Close Local File [TEST]

#test clause where - serialisation grammaire pour SADXXX avec des DATEs
Local Integer EXPECT, GOT
EXPECT=172

DATEN=date$

UPDATESTATUS=func UPDATE_RECORD(172,DATEN)

If (UPDATESTATUS=0)
 Local File AQRSTU [TEST]
 #Infbox num$([L]DATEN)
 Filter [TEST] Where DATEN=[L]DATEN #172 # DATE$

 Read [TEST]STU First# on se positionne dessus
 Call CHECK_EQUAL([S]fstat,0) From AXUNIT

 GOT=[F:TEST]STU
 Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

 Filter [TEST] Where [TEST]STU=172 # DATE$
 Read [TEST]STU First

 Close Local File [TEST]
Endif
End

#Helper function for Test SADXXX
Funprog  UPDATE_RECORD(CLE,PDATM)
Value Integer CLE
Variable Date PDATM

Local Integer STAT

Local File AQRSTU [TEST]
[TEST]STU = CLE
[TEST]DATEN=PDATM

 Trbegin [TEST] # début de la transaction
Write [TEST] # écriture sur fichier
If [S]fstat # en cas de problème quelconque
    Rollback # la transaction est annulée
Else
    Commit # sinon elle est validée
Endif


 If [S]fstat=3 #cle dupliquee (l'enregistrement existe), on fait  update
  Trbegin [TEST] # début de la transaction
   Rewrite [TEST]STU = [F:TEST]STU

   If [S]fstat # en cas de problème quelconque
       Rollback # la transaction est annulée
   Else
       Commit # sinon elle est validée
   Endif
   #Infbox num$([S]fstat)
 Endif
STAT=[S]fstat
Close Local File [TEST]
End STAT
