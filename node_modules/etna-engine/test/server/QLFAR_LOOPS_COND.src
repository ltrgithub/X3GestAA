Call OUVRE_TRACE("QLFAR_LOOPS_COND") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_LOOPS_COND_"+GUSER
Call LEC_TRACE From LECFIC

End

Funprog TESTSUITE()
Local Integer NBTEST


#For With Break
#If Elsif Endif
#Case
#While With Break
#Repeat Until
NBTEST=23
Call ADD_TESTCASE("TEST_INIT", "TEST_INIT -- initialization", NBTEST) From AXUNIT

NBTEST=33
Call ADD_TESTCASE("TEST_IF", "TEST_IF -- If instruction", NBTEST) From AXUNIT

NBTEST=87
Call ADD_TESTCASE("TEST_FOR", "TEST_FOR -- For instruction", NBTEST) From AXUNIT

NBTEST=37
Call ADD_TESTCASE("TEST_WHILE", "TEST_WHILE -- While instruction", NBTEST) From AXUNIT
Call ADD_TESTCASE("TEST_REPEAT", "TEST_REPEAT -- Repeat instruction", NBTEST) From AXUNIT

NBTEST=68
Call ADD_TESTCASE("TEST_CASE", "TEST_CASE -- Case instruction", NBTEST) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("LOOPS_COND", "LOOPS_COND")
End SUITE_RESULT


Subprog CHECK_EQUAL(GOT, EXPECT,TEXT)
Call CHECK_EQUAL(TEXT+"...", TEXT+"...") From AXUNIT
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume


$FILL
Global Char STRINGS(1)(10)
Global Integer INTS(10)
Global Char LETTERS, DIGITS, LSORT, LSORTS, DSORT, LBYD, DBYL, DBYL2,DBYL22,LSORTPART,ISORTPART
LETTERS = "DAAFBCBBAF"
DIGITS =  "5531244153"

LSORT =   "AAABBBCDFF"
LSORTD =  "FFDCBBBAAA"
DSORT =   "1123344555"
LBYD  =   "BFBAFBCAAD"
DBYL  =   "3551244513"
DBYL2 =   "3154142553"
DBYL22 =  "3154412355"
LSORTPART = "DAABBCFBAF"
ISORTPART = "5532441153"

For I = 0 To 9 : STRINGS(I) = mid$(LETTERS, I+1, 1) : INTS(I) = val(mid$(DIGITS, I+1, 1)) : Next I
Return

Funprog DUMP_S(AR,DIME_1,DIME)
 Variable Char AR()()
 Value Integer DIME_1,DIME
 Call CHECK_EQUAL("BEGIN DUMP_S", "BEGIN DUMP_S") From AXUNIT
 Call CHECK_EQUAL(dim(AR,-1), DIME_1) From AXUNIT
 Call CHECK_EQUAL(dim(AR,1), DIME) From AXUNIT
End sigma(dim(AR,-1), dim(AR,-1) + dim(AR,1) - 1, AR(indcum))

Funprog DUMP_I(AR,DIME_1,DIME)
 Variable Integer AR()
 Value Integer DIME_1,DIME
 Call CHECK_EQUAL("BEGIN DUMP_I", "BEGIN DUMP_I") From AXUNIT
 Call CHECK_EQUAL(dim(AR,-1), DIME_1) From AXUNIT
 Call CHECK_EQUAL(dim(AR,1), DIME) From AXUNIT
End sigma(dim(AR,-1), dim(AR,-1) + dim(AR,1) - 1, num$(AR(indcum)))



Subprog TEST_INIT()
 Gosub FILL
 Local Integer I,J,K
 Local Char TT
 Call CHECK_EQUAL(dim(STRINGS), 10 ) From AXUNIT
 Call CHECK_EQUAL(dim(INTS), 10 ) From AXUNIT
 Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
 Call CHECK_EQUAL(dim(INTS,-1), 0 ) From AXUNIT
 Call CHECK_EQUAL(dim(STRINGS,1), 10 ) From AXUNIT
 Call CHECK_EQUAL(dim(INTS,1), 10 ) From AXUNIT
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LETTERS) From AXUNIT
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DIGITS) From AXUNIT

    Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1)) From AXUNIT
    Call CHECK_EQUAL(num$(STRINGS(I)), mid$(LETTERS, I+1, 1)) From AXUNIT
    #Error: [10] Incompatibilité de type
    If pat(ver$(0),"etna*")>0
    Local Integer EX : EX=10
    Onerrgo ERROR
    Endif
    K=val(STRINGS(I))
    Onerrgo
    Call CHECK_EQUAL(K, 0 ) From AXUNIT
 #
    #Error: [10] Incompatibilité de type
    Local Integer EX : EX=10
    Onerrgo ERROR
    TT=INTS(I)
    Onerrgo
    Call CHECK_EQUAL(num$(INTS(I)), mid$(DIGITS, I+1, 1) ) From AXUNIT
    Call CHECK_EQUAL(num$(INTS(I)), num$(mid$(DIGITS, I+1, 1)) ) From AXUNIT
    #Error: [10] Incompatibilité de type
    Local Integer EX : EX=10
    Onerrgo ERROR
    K=val(INTS(I))
    Onerrgo
    Call CHECK_EQUAL(K, 0 ) From AXUNIT
End

Subprog TEST_FOR()
 Gosub FILL
 Local Decimal I,J,K
 Local Char TT
#
 TT="-1 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  For J=0 To 9
   K+=1
  Next J
 Next I
 Call CHECK_EQUAL(I, 10 ) From AXUNIT
 Call CHECK_EQUAL(J, 10 ) From AXUNIT
 Call CHECK_EQUAL(K, 100 ) From AXUNIT
#
 TT="-2 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  For J=0 To 9
   K+=1
   Call CHECK_EQUAL(num$(I)+'/'+num$(J)+'='+num$(K)-STRINGS(I)+num$(INTS(J)), num$(I)+'/'+num$(J)+'='+num$(K)-mid$(LETTERS, I+1, 1)+mid$(DIGITS, J+1, 1) ) From AXUNIT
   If J>=6 : Break : Endif
  Next J
  Call CHECK_EQUAL('K='+num$(K), 'K='+num$((I+1)*7) ) From AXUNIT
  If K>=32 : Break : Endif
 Next I
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
 #
 TT="-3 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  For J=0 To 9
   Call CHECK_EQUAL(STRINGS(I)+num$(INTS(J)), mid$(LETTERS, I+1, 1)+mid$(DIGITS, J+1, 1) ) From AXUNIT
   K+=1
   If K>=15 : Break 2 : Endif
  Next J
 Next I
 Call CHECK_EQUAL(I, 1 ) From AXUNIT
 Call CHECK_EQUAL(J, 4 ) From AXUNIT
 Call CHECK_EQUAL(K, 15 ) From AXUNIT

 #
 TT="-4 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 Local Char TAB(10)(1..50)
 For I=1 To 50
  TAB(I)=num$(I)
 Next
 Raz I,J,K
 For TT="1","3.5","6","8.5","11"
  I+=1
  TAB(I)=TT
 Next
 Call CHECK_EQUAL(TT, "11" ) From AXUNIT
 TT="-5 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I = 1 To 13 Step 2.5 : J+=1 : Call CHECK_EQUAL(num$(I), TAB(J) ) From AXUNIT : Next I : Call CHECK_EQUAL(num$(I), "13.5" ) From AXUNIT
   # affiche : 1 3.5 6 8.5 11 FIN=13.5
# #
 TT="-6 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I= 15 To 12 : J+=1 : Call CHECK_EQUAL(num$(I), TAB(J) ) From AXUNIT : Next I : Call CHECK_EQUAL(num$(I), "15" ) From AXUNIT
#   # affiche : FIN=15
# #
 TT="-7 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I = 15 To 11 Step -1 : J+=1 : Call CHECK_EQUAL(num$(I), TAB(I) ) From AXUNIT : Next I : Call CHECK_EQUAL(num$(I), "10" ) From AXUNIT
#   # affiche : 15 14 13 12 11 FIN=10
End

Subprog TEST_IF()
 Gosub FILL
 Local Integer I,J,K,TROUVE
 Local Char TT
 TT="-1 IF"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  If STRINGS(I)<> mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(DIGITS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(DIGITS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Endif
 Next I
#
 TT="-2 IF"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  If STRINGS(I)<> mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(DIGITS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(DIGITS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Else
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Endif
 Next I
#
 TT="-3 IF"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  If STRINGS(I)<> mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(DIGITS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(DIGITS, I+1, 1) ) From AXUNIT
  Else
   Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Endif
 Next I
End

Subprog TEST_CASE()
 Local Decimal I,J,K
 Local Char TT
#
 Raz I,J,K
 Local Char TAB(10)(1..50)
 For I=1 To 50
  TAB(I)=num$(I)
 Next
 Raz I,J,K
 For TT="1","3.5","6","8.5","11"
  I+=1
  TAB(I)=TT
 Next
 Call CHECK_EQUAL(TT, "11" ) From AXUNIT
 #
 TT="-1 CASE"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=1 To 50
  Case TAB(I)
  When "1" : Call CHECK_EQUAL('When "1" :'-num$(I), 'When "1" :'-TAB(I) ) From AXUNIT
  When "3.5" : Call CHECK_EQUAL('When "3.5" : 3.5', 'When "3.5" :'-TAB(I) ) From AXUNIT
  When "8.5" : Call CHECK_EQUAL('When "8.5" : 8.5', 'When "8.5" :'-TAB(I) ) From AXUNIT
  When "10","15","20" : Call CHECK_EQUAL('When "10","15","20" :'-num$(I), 'When "10","15","20" :'-TAB(I) ) From AXUNIT
  When "30" :
  When "40" : Call CHECK_EQUAL('When "40" :'-num$(I), 'When "40" :'-TAB(I) ) From AXUNIT
  When "45"
  When "50" : Call CHECK_EQUAL('When "50" :'-num$(I), 'When "50" :'-TAB(I) ) From AXUNIT
  When Default : Call CHECK_EQUAL('When Default :'-num$(I), 'When Default :'-num$(I) ) From AXUNIT
  Endcase
 Next
 #
 TT="-2 CASE"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=1 To 50
  Case TAB(I)
  When "1" : Call CHECK_EQUAL('When "1" :'-num$(I), 'When "1" :'-TAB(I) ) From AXUNIT
  When "3.5" : Call CHECK_EQUAL('When "3.5" : 3.5', 'When "3.5" :'-TAB(I) ) From AXUNIT
  When "8.5" : Call CHECK_EQUAL('When "8.5" : 8.5', 'When "8.5" :'-TAB(I) ) From AXUNIT
  When "10","15","20" : Call CHECK_EQUAL('When "10","15","20" :'-num$(I), 'When "10","15","20" :'-TAB(I) ) From AXUNIT
  When "30" :
  When "40" : Call CHECK_EQUAL('When "40" :'-num$(I), 'When "40" :'-TAB(I) ) From AXUNIT
  When "45"
  When "50" : Call CHECK_EQUAL('When "50" :'-num$(I), 'When "50" :'-TAB(I) ) From AXUNIT
  When Default :
  Endcase
 Next
 #
 TT="-3 CASE"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=1 To 50
  Case TAB(I)
  When "1" : Call CHECK_EQUAL('When "1" :'-num$(I), 'When "1" :'-TAB(I) ) From AXUNIT
  When "3.5" : Call CHECK_EQUAL('When "3.5" : 3.5', 'When "3.5" :'-TAB(I) ) From AXUNIT
  When "8.5" : Call CHECK_EQUAL('When "8.5" : 8.5', 'When "8.5" :'-TAB(I) ) From AXUNIT
  When "10","15","20" : Call CHECK_EQUAL('When "10","15","20" :'-num$(I), 'When "10","15","20" :'-TAB(I) ) From AXUNIT
  When "30" :
  When "40" : Call CHECK_EQUAL('When "40" :'-num$(I), 'When "40" :'-TAB(I) ) From AXUNIT
  When "45"
  When "50" : Call CHECK_EQUAL('When "50" :'-num$(I), 'When "50" :'-TAB(I) ) From AXUNIT
  Endcase
 Next
End

Subprog TEST_WHILE()
 Gosub FILL
 Local Integer I,J,K,TROUVE
 Local Char TT
#
 TT="-1 While"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  While J<=9
   K+=1
   J+=1
  Wend
  I+=1
 Wend
 Call CHECK_EQUAL(I, 10 ) From AXUNIT
 Call CHECK_EQUAL(J, 10 ) From AXUNIT
 Call CHECK_EQUAL(K, 100 ) From AXUNIT
#
 TT="-2 While"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  While J<=9
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Wend
  If K>=32 : Break : Endif
   I+=1
 Wend
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
 #
 TT="-3 While"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  While J<=9
   Call CHECK_EQUAL(STRINGS(I)+num$(INTS(J)), mid$(LETTERS, I+1, 1)+mid$(DIGITS, J+1, 1) ) From AXUNIT
   K+=1
   If K>=15 : Break 2 : Endif
   J+=1
  Wend
  I+=1
 Wend
 Call CHECK_EQUAL(I, 1 ) From AXUNIT
 Call CHECK_EQUAL(J, 4 ) From AXUNIT
 Call CHECK_EQUAL(K, 15 ) From AXUNIT
#
 TT="-4 While"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=1
 While TROUVE
  J=0
  While J<=9
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Wend
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Wend
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT

#
 TT="-5 While"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=-1
 While TROUVE
  J=0
  While J<=9
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Wend
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Wend
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT

End

Subprog TEST_REPEAT()
 Gosub FILL
 Local Integer I,J,K,TROUVE
 Local Char TT
#
 TT="-1 Repeat"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 Repeat
  J=0
  Repeat
   K+=1
   J+=1
  Until J>9
  I+=1
 Until I>9
 Call CHECK_EQUAL(I, 10 ) From AXUNIT
 Call CHECK_EQUAL(J, 10 ) From AXUNIT
 Call CHECK_EQUAL(K, 100 ) From AXUNIT
#
 TT="-2 Repeat"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 Repeat
  J=0
  Repeat
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Until J>9
  If K>=32 : Break : Endif
   I+=1
 Until I>9
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
 #
 TT="-3 Repeat"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 Repeat
  J=0
  Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Repeat
   Call CHECK_EQUAL(STRINGS(I)+num$(INTS(J)), mid$(LETTERS, I+1, 1)+mid$(DIGITS, J+1, 1) ) From AXUNIT
   K+=1
   If K>=15 : Break 2 : Endif
   J+=1
  Until J>9
  I+=1
 Until I>9
 Call CHECK_EQUAL(I, 1 ) From AXUNIT
 Call CHECK_EQUAL(J, 4 ) From AXUNIT
 Call CHECK_EQUAL(K, 15 ) From AXUNIT
#
 TT="-4 Repeat"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=1
 Repeat
  J=0
  Repeat
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Until J>9
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Until (I>9 | !TROUVE)
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
#
 TT="-5 Repeat"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=-1
 Repeat
  J=0
  Repeat
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Until J>9
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Until (I>9 | !TROUVE)
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
End
