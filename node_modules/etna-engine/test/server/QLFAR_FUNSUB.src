Local Clbfile RESULT
RESULT = func TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_FUNSUB_"+GACTX.USER
Call LEC_TRACE From LECFIC
End

Funprog TESTSUITE()
Local Integer EX

Callmet GACTX.ACTX_SET_LANISO("fr-FR")
Call TESTSUITE_START("FUN_SUB_PARAMS", "Pass parameters to funprogs and subprogs tests") From AXUNIT
Call ADD_TESTCASE("TC_RECURSION", "TC_RECURSION Test Funprog/Subprog recursion", 4) From AXUNIT
#Call ADD_TESTCASE("TC_SUBPROG", "TC_SUBPROG parameters", 10) From AXUNIT
#Call ADD_TESTCASE("TC_FUNPROG", "TC_FUNPROG parameters", 7) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("PERFORMANCE", "Performance")
End SUITE_RESULT

Subprog TC_RECURSION
Local Char TT(255)
Local Integer FACTORIAL, SUMMATION
TT="Test factorial calculation- 12 levels of recursion"
Call CHECK_EQUAL(TT,TT) From AXUNIT
Call CHECK_EQUAL(func FACT(12), 479001600) From AXUNIT

TT="Test sum calculation- 175 levels of recursion"
Call CHECK_EQUAL(TT,TT) From AXUNIT
Call CHECK_EQUAL(func SUM1(175), 15400) From AXUNIT

End


Funprog FACT(NUM)

If NUM>1
  NUM= NUM*func FACT(NUM-1)
Endif
End NUM


Funprog SUM1(NUM)

If NUM>0
  NUM= NUM+func SUM1(NUM-1)
Endif

End NUM



Subprog TC_SUBPROG
Local Char TT(255)
Local Shortint ASHORTINT
Local Date     ADATE
Local Integer  AINT
Local Double   ADOUBLE
Local Decimal  ADECIMAL
Local Char     ACHAR
Local Char     ACHAR0(0)
Local Char     ACHAR10(10)
Local Blbfile  ABLOB(2)
Local Clbfile  ACLOB(2)
Local Uuident  AUUID
Local Datetime ADATETIME
Local Tinyint  ATINYINT

[L]ASHORTINT = 1000
[L]ADATE     = [31/01/2100]
[L]AINT      = 50000
[L]ADOUBLE   = 50E22
[L]ADECIMAL  = 17000.12345
[L]ACHAR     = "ABC"
[L]ACHAR0    = "DEFG"
[L]ACHAR10   = "AAABBBCCC"
[L]ACLOB     = "AAAAAAAAAAAABBBBBBBBBBBBBBBB"
[L]AUUID     = getUuid()
[L]ADATETIME = datetime$
[L]ATINYINT  = 17

Subprog TC_TEST_SUB1(ASHORTINT,
& ADATE,
& AINT,
& ADOUBLE,
& ADECIMAL,
& ACHAR,
& ACHAR0,
& ACHAR10,
& ABLOB,
& ACLOB,
& AUUID,
& ADATETIME,
& ATINYINT)

Variable Shortint ASHORTINT
Variable Date     ADATE
Variable Integer  AINT
Variable Double   ADOUBLE
Variable Decimal  ADECIMAL
Variable Char     ACHAR
Variable Char     ACHAR0
Variable Char     ACHAR10
Variable Blbfile  ABLOB
Variable Clbfile  ACLOB
Variable Uuident  AUUID
Variable Datetime ADATETIME
Variable Tinyint  ATINYINT

Call CHECK_EQUAL([L]ASHORTINT , 1000) From AXUNIT
Call CHECK_EQUAL([L]ADATE     , [31/01/2100]) From AXUNIT
Call CHECK_EQUAL([L]AINT      , 50000  ) From AXUNIT
Call CHECK_EQUAL([L]ADOUBLE   , 50E22) From AXUNIT
Call CHECK_EQUAL([L]ADECIMAL  , 17000.12345) From AXUNIT
Call CHECK_EQUAL([L]ACHAR     , "ABC") From AXUNIT
Call CHECK_EQUAL([L]ACHAR0    , "DEFG") From AXUNIT
Call CHECK_EQUAL([L]ACHAR10   , "AAABBBCCC") From AXUNIT
Call CHECK_EQUAL([L]ACLOB     , "AAAAAAAAAAAABBBBBBBBBBBBBBBB") From AXUNIT
Call CHECK_NOTEQUAL([L]AUUID     , NullUuid) From AXUNIT
Call CHECK_EQUAL([L]ADATETIME , datetime$) From AXUNIT
Call CHECK_EQUAL([L]ATINYINT  , 17) From AXUNIT

[L]ASHORTINT = 10
[L]ADATE     = [31/12/2000]
[L]AINT      = 150000
[L]ADOUBLE   = 150E22
[L]ADECIMAL  = 117000.11111
[L]ACHAR     = "ABCDEF"
[L]ACHAR0    = "DEFGHI"
[L]ACHAR10   = "ZZZZZZZ"
[L]ACLOB     = "XXXXXXXXXXXXXXXXXXXXXXXXXZZZZZZZZZZZZZZZZZZZZZZZZZ"
[L]AUUID     = NullUuid
[L]ADATETIME = datetime$
[L]ATINYINT  = 17
End


Call CHECK_EQUAL(TT,TT) From AXUNIT

Sleep 1
TIM=num$(datetime$)
I=instr(1,TIM,".")
J=instr(1,TIM,"Z")
TIMING_MS=val(seg$(TIM,I=1,J-1))

TT=TIM-format$("K:30X",num$(TIMING_MS))-num$(I)-num$(J)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

End

Subprog TC_PERF_NUMS

Call TEST_NUMERIC
End

Subprog TC_PERF_STRINGS

Call TEST_STRING

End

Subprog TC_PERF_DATES

Call TEST_DATE

End

Subprog PERF_CLOBS

Call TEST_CLBFILE

End

# -----------------------------------------------------------------------
#**
#* TEST_NUMERIC - Dispatch Test cases - 1000k test cases per subroutine
#*!
Subprog TEST_NUMERIC
Local Char TT(255)
Local Char TITLES(25),TITLES_DES(75)
Local Decimal TIMING_MS

Local Char START_TIME(20)


TITLES = "TEST_NUM_INTADD"
TITLES_DES = "Integer Addition"
START_TIME=timestamp$
Gosub TEST_NUM_INTADD
TIMING_MS=val(timestamp$)-val(START_TIME)
[L]TT = format$("N:10#[ ms]",TIMING_MS) +"~    "+"Title "+format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_NUM_DECADD"
START_TIME=timestamp$
TITLES_DES = "Decimal Addition"
Gosub TEST_NUM_DECADD
TIMING_MS=val(timestamp$)-val(START_TIME)
TT=format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_NUM_INTMUL"
TITLES_DES = "Multiply two integers"
START_TIME=timestamp$
Gosub TEST_NUM_INTMUL
TIMING_MS=val(timestamp$)-val(START_TIME)
TT=format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT


TITLES = "TEST_NUM_DECMUL"
TITLES_DES = "Multiply two decimals"
START_TIME=timestamp$
Gosub TEST_NUM_DECMUL
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_NUM_INTDECMUL"
TITLES_DES = "Multiply integer by decimal"
START_TIME=timestamp$
Gosub TEST_NUM_INTDECMUL
TIMING_MS=val(timestamp$)-val(START_TIME)
TT=format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_NUM_VAL"
TITLES_DES = "Convert numeric to string - Convert string to numeric"
START_TIME=timestamp$
Gosub TEST_NUM_VAL
TIMING_MS=val(timestamp$)-val(START_TIME)
TT=format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

End

$TEST_NUM_INTADD
Local Integer I,J,CNT
CNT=0
For J=1 To 1000
For I=1 To 1000
CNT=I+J
Next I
Next J
Return

$TEST_NUM_DECADD
Local Decimal I,J,CNT,DEC1
CNT=0
For I=1 To 100000 Step 0.1
CNT+=I
Next I
Return

$TEST_NUM_INTMUL
Local Integer I,J,CNT
For I=1 To 1000
For J=1 To 1000
CNT=I*J
Next J
Next I
Return

$TEST_NUM_DECMUL
Local Decimal I,J,CNT
For I=0.1 To 100 Step 0.1
For J=0.1 To 100 Step 0.1
CNT=I*J
Next J
Next I
Return


$TEST_NUM_INTDECMUL
Local Integer I
Local Decimal J,CNT
Local Integer CNT1
For I=1 To 1000
For J=1 To 100 Step 0.1
CNT=I*J
Next J
Next I
Return

$TEST_NUM_VAL
Local Char TMP(10)
Local Integer I,J
Local Decimal DEC1
For I=1 To 1000000
TMP = num$(I)
DEC1 = val(TMP)
Next I
Return

# -----------------------------------------------------------------------
#**
#* TEST_STRING - Dispatch Test cases - 1000k test cases per subroutine
#*!
Subprog TEST_STRING
Local Char TITLES(25),TITLES_DES(75)
Local Decimal TIMING_MS

Local Char START_TIME(20)

TITLES = "TEST_STR_SEG_25"
TITLES_DES = "String parse 25 characters with SEG$"
START_TIME=timestamp$
Gosub TEST_STR_SEG_25
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_STR_MID_25"
TITLES_DES = "String parse 25 characters with MID$"
START_TIME=timestamp$
Gosub TEST_STR_MID_25
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_STR_XGETCHAR_1"
TITLES_DES = "String parse 1 char with XGETCHAR$"
START_TIME=timestamp$
Gosub TEST_STR_XGETCHAR_1
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_STR_SEG_1"
TITLES_DES = "String parse 1 char with SEG$"
START_TIME=timestamp$
Gosub TEST_STR_SEG_1
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_STR_MID_1"
TITLES_DES = "String parse 1 char with MID$"
START_TIME=timestamp$
Gosub TEST_STR_MID_1
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_STR_LEFT"
TITLES_DES = "String parse LEFT$$"
START_TIME=timestamp$
Gosub TEST_STR_LEFT
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_STR_RIGHT"
TITLES_DES = "String parse RIGHT$"
START_TIME=timestamp$
Gosub TEST_STR_RIGHT
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

End

#**
#* TEST_STR_LEFT
#*
$TEST_STR_LEFT

Local Char TEST_STR(255)
Local Char TEST_LEFT_STR(25)
Local Integer I,J
TEST_STR=sigma(1,255,chr$(65+int(rnd(25))))

For J=1 To 5000
For I=1 To 200
TEST_LEFT_STR = left$(TEST_STR,I+24)
Next I
Next J

Return

#**
#* TEST_STR_RIGHT
#*
$TEST_STR_RIGHT

Local Char TEST_STR(255)
Local Char TEST_RIGHT_STR(25)
Local Integer I,J
TEST_STR=sigma(1,255,chr$(65+int(rnd(25))))

For J=1 To 5000
For I=1 To 200
TEST_RIGHT_STR = right$(TEST_STR,I+24)
Next I
Next J

Return

#**
#* TEST_STR_SEG_25 - parse 25 characters
#*!

$TEST_STR_SEG_25

Local Char TEST_STR(255)
Local Char TEST_SEA_STR(25)
Local Integer I,J
TEST_STR=sigma(1,255,chr$(65+int(rnd(25))))

For J=1 To 5000
For I=1 To 200
TEST_SEA_STR = seg$(TEST_STR,I,I+24)
Next I
Next J

Return

#**
#* TEST_STR_MID_25 - parse 25 characters
#*!
$TEST_STR_MID_25

Local Char TEST_STR(255)
Local Char TEST_SEA_STR(25)
Local Integer I,J
TEST_STR=sigma(1,255,chr$(65+int(rnd(25))))

For J=1 To 5000
For I=1 To 200
TEST_SEA_STR = mid$(TEST_STR,I,25)
Next I
Next J

Return

#**
#* TEST_STR_XSEGSTR - parse 1 Character
#*!
$TEST_STR_XGETCHAR_1

Local Char TEST_STR(255)
Local Char TEST_SEA_STR(25)
Local Integer I,J
TEST_STR=sigma(1,255,chr$(65+int(rnd(25))))

For J=1 To 5000
For I=1 To 200
TEST_SEA_STR = xgetchar(TEST_STR,I)
Next I
Next J

Return

#**
#* TEST_STR_MID_1 - parse 1 characters
#*!
$TEST_STR_MID_1

Local Char TEST_STR(255)
Local Char TEST_MID_STR(25)
Local Integer I,J
TEST_STR=sigma(1,255,chr$(65+int(rnd(25))))

For J=1 To 5000
For I=1 To 200
TEST_MID_STR = mid$(TEST_STR,I,1)
Next I
Next J

Return

#**
#* TEST_STR_SEG_1 - parse 1 characters
#*!
$TEST_STR_SEG_1

Local Char TEST_STR(255)
Local Char TEST_SEG_STR(25)
Local Integer I,J
TEST_STR=sigma(1,255,chr$(65+int(rnd(25))))

For J=1 To 5000
For I=1 To 200
TEST_SEG_STR = seg$(TEST_STR,I,I)
Next I
Next J

Return

Subprog TEST_CLBFILE
Local Char TITLES(25),TITLES_DES(75)
Local Decimal TIMING_MS

Local Char START_TIME(20)
Local Clbfile TEST_CLB(4)
Setlob TEST_CLB With sigma(1,4000,chr$(65+int(rnd(25))))

TITLES = "TEST_CLB_SEG_25"
TITLES_DES = "CLOB parse 25 char with SEG$"
START_TIME=timestamp$
Gosub TEST_CLB_SEG_25
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_CLB_MID_25"
TITLES_DES = "CLOB parse 25 char with MID$"
START_TIME=timestamp$
Gosub TEST_CLB_MID_25
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_CLB_XGETCHAR_1"
TITLES_DES = "CLOB parse 1 char with XGETCHAR$"
START_TIME=timestamp$
Gosub TEST_CLB_XGETCHAR_1
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_CLB_SEG_1"
TITLES_DES = "CLOB parse 1 char with SEG$"
START_TIME=timestamp$
Gosub TEST_CLB_SEG_1
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_CLB_MID_1"
TITLES_DES = "CLOB parse 1 char with MID$"
START_TIME=timestamp$
Gosub TEST_CLB_MID_1
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_CLB_LEFT"
TITLES_DES = "CLOB parse with LEFT$"
START_TIME=timestamp$
Gosub TEST_CLB_LEFT
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_CLB_RIGHT"
TITLES_DES = "CLOB parse with RIGHT$"
START_TIME=timestamp$
Gosub TEST_CLB_RIGHT
TIMING_MS=val(timestamp$)-val(START_TIME)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_CLB_VALUE"
TITLES_DES = "CLOB passed by VALUE"
START_TIME=timestamp$
Gosub TEST_CLB_VALUE
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_CLB_CONST"
TITLES_DES = "CLOB passed by CONST"
START_TIME=timestamp$
Gosub TEST_CLB_CONST
TIMING_MS=val(timestamp$)-val(START_TIME)

TITLES = "TEST_CLB_VARIABLE"
TITLES_DES = "CLOB passed by VARIABLE"
START_TIME=timestamp$
Gosub TEST_CLB_VARIABLE
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

End

$TEST_CLB_VALUE
Local Integer I
For I=1000000
Call TEST_CLB_1(TEST_CLB)
Next I
Return


Subprog TEST_CLB_1(TEST_CLB)
Value Clbfile TEST_CLB
End

$TEST_CLB_CONST
Local Integer I
For I=1000000
Call TEST_CLB_2(TEST_CLB)
Next I
Return

Subprog TEST_CLB_2(TEST_CLB)
Const Clbfile TEST_CLB
End

$TEST_CLB_VARIABLE
Local Integer I
For I=1000000
Call TEST_CLB_3(TEST_CLB)
Next I
Return

Subprog TEST_CLB_3(TEST_CLB)
Variable Clbfile TEST_CLB
End

$TEST_CLB_SEG_25
Local Char TEST_SEG_STR(25)
Local Integer I,J

For J=1 To 250
For I=1 To 4000
TEST_SEG_STR = seg$(TEST_CLB,I,I+24)
Next I
Next J
Return

$TEST_CLB_MID_25
Local Char TEST_SEG_STR(25)
Local Integer I,J

For J=1 To 250
For I=1 To 4000
TEST_SEG_STR = mid$(TEST_CLB,I,25)
Next I
Next J
Return

$TEST_CLB_XGETCHAR_1
Local Char TEST_SEG_STR(25)
Local Integer I,J

For J=1 To 250
For I=1 To 4000
TEST_SEG_STR = xgetchar(TEST_CLB,I)
Next I
Next J
Return

$TEST_CLB_SEG_1
Local Char TEST_SEG_STR(25)
Local Integer I,J
For J=1 To 250
For I=1 To 4000
TEST_SEG_STR = seg$(TEST_CLB,I,I)
Next I
Next J
Return

$TEST_CLB_MID_1
Local Char TEST_SEG_STR(25)
Local Integer I,J

For J=1 To 250
For I=1 To 4000
TEST_SEG_STR = mid$(TEST_CLB,I,1)
Next I
Next J
Return

$TEST_CLB_LEFT
Local Char TEST_SEG_STR(25)
Local Integer I,J

For J=1 To 250
For I=1 To 4000
TEST_SEG_STR = left$(TEST_CLB,I+25)
Next I
Next J
Return

$TEST_CLB_RIGHT
Local Char TEST_SEG_STR(25)
Local Integer I,J

For J=1 To 250
For I=1 To 4000
TEST_SEG_STR = right$(TEST_CLB,I+25)
Next I
Next J
Return

# -----------------------------------------------------------------------
#**
#* TEST_DATE - Dispatch Test cases - 1000k test cases per subroutine
#*!
Subprog TEST_DATE
Local Char TT(255)
Local Char TITLES(25),TITLES_DES(75)
Local Decimal TIMING_MS

Local Char START_TIME(20)


TITLES = "TEST_DATE_ADD"
TITLES_DES = "DATE plus days addition"
START_TIME=timestamp$
Gosub TEST_DATE_ADD
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_DATE_ADDMONTH"
TITLES_DES = "DATE plus months addition-ADDMONTH"
START_TIME=timestamp$
Gosub TEST_DATE_ADDMONTH
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_DATE_NDAY"
START_TIME=timestamp$
TITLES_DES = "DATE number of days since [01/01/1600] - NDAY"
Gosub TEST_DATE_NDAY
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_DATE_NDAYSTR"
TITLES_DES = "DATE since [01/01/1600] based on number of days -NDAY$"
START_TIME=timestamp$
Gosub TEST_DATE_NDAYSTR
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

TITLES = "TEST_DATE_GDAT"
TITLES_DES = "DATE from component parts -GDAT$"
START_TIME=timestamp$
Gosub TEST_DATE_GDAT
TIMING_MS=val(timestamp$)-val(START_TIME)
TT = format$("N:10#[ ms]",TIMING_MS)+"~    "+"Title"-format$("K:69X","  "+TITLES+" "+TITLES_DES)
Call CHECK_EQUAL(TT,TT) From AXUNIT

End

$TEST_DATE_ADD

Local Date TEST_DATE_GDAT
Local Integer I,J,K

For J=1 To 5000
For I=1 To 200
TEST_DATE_GDAT = date$+I
Next I
Next J
Return

$TEST_DATE_ADDMONTH
Local Date TEST_DATE_MONTH
Local Integer I,J

For J=1 To 5000
For I=-99 To 100
TEST_DATE_MONTH = addmonth(date$,I)
Next I
Next J
Return

$TEST_DATE_NDAY
Local Integer TEST_DATE_INTEGER
Local Integer J

For J=1 To 1000000
TEST_DATE_INTEGER= nday(date$)
Next J
Return


$TEST_DATE_NDAYSTR
Local Date TEST_DATE_YEAR
Local Integer I,J

For J=1 To 1000000
TEST_DATE_YEAT= nday$(J)
Next J
Return

$TEST_DATE_GDAT
Local Date TEST_DATE_GDAT
Local Integer I,J,K

For K=1 To 10
For J=1 To 500
For I=1 To 200
TEST_DATE_GDAT = gdat$(day(date$),month(date$),year(date$))
Next I
Next J
Next K
Return


Subprog APPEND_AXUNIT(GOT)
Value Char GOT
Local Char EXPECTED(255)
EXPECTED=GOT
Call CHECK_EQUAL(GOT,EXPECTED) From AXUNIT
End

#**
#* Access by Call MEMORY_RECORD(ROUTINES, ROUTINES_MEM,"TEST_NUM_ADD", MEM_START,MEM_FIN)
#*Local Char ROUTINES(50)(0..)
#*Local Integer ROUTINES_MEM(0..,2)
#*Call TEST_NUMERIC(ROUTINES,ROUTINES_MEM) -call and pass arrays to test programs
#*
#* @param MEMTITLES -  title array (0..)
#* @param MEMFREE - memory array (0..,2)
#* @param MEMTITLE - subroutine title
#* @param MEM_START - starting memory
#* @param MEM_FIN - ending memory
#*!
Subprog MEMORY_RECORD(MEMTITLES,MEMFREE,MEMTITLE, MEM_START, MEM_FIN)
Variable Char MEMTITLES()()
Variable Integer MEMFREE(,),MEM_START,MEM_FIN
Value Char MEMTITLE
Local Integer I
I=maxtab(MEMTITLES)+1
MEMTITLES(I)=MEMTITLE
MEMFREE(I,0)=MEM_START
MEMFREE(I,1)=MEM_FIN
End

#**
#* GTRACE = "QLFAR_PERFORMANCE_"+GACTX.USER
#* Call MEMORY_TRACE(ROUTINES, ROUTINES_MEM, LOGFILE, GTRACE)
#*
#* @param ROUTINES - Title array
#* @param ROUTINES_MEM  - memory array
#* @param LOGFILE - original timing trace file
#* @param TRACE - new name of trace file
#*!
Subprog MEMORY_TRACE(ROUTINES, ROUTINES_MEM, LOGFILE, TRACE)
Variable Char ROUTINES()(),TRACE()
Variable Integer ROUTINES_MEM(,)
Value Char LOGFILE()
Local Integer ERR_CODE, I, MEM_USE
Local Char LIGNE(255)
ERR_CODE=renameFile(filpath('TRA',LOGFILE,'tra'),filpath('TRA',TRACE,'tra'))
If !ERR_CODE
  Openio filpath('TRA',GTRACE,'tra') Using [TMP]
  Seek Last Using [TMP]
  Wrseq "Memory Usage" Using [TMP]
  For I=1 To maxtab(ROUTINES)
    MEM_USE=ROUTINES_MEM(I,0)-ROUTINES_MEM(I,1)
    LIGNE=format$("K:25X",ROUTINES(I))+format$("K:25X","Mem Use:" +num$(MEM_USE))
    Wrseq LIGNE Using [TMP]
  Next
  Wrseq "End" Using [TMP]
  Openio Using [TMP]
Endif

End

Subprog TITLES_TRACE
Local Char TITLES(25),TITLES_DES(75)
Local Decimal TIMING_MS

Local Char START_TIME(20)

Local Integer ERR_CODE, I, J, IDX
Local Char LIGNE(255)
Local Integer CNT :CNT=0
#ERR_CODE = renameFile(filpath('TRA',LOGFILE,'tra'),filpath('TRA',TRACE,'tra'))
#End
ERR_CODE=Delfile(filpath('TRA',TRACE,'tra'))
Openio filpath('TRA',LOGFILE,'tra') Using [TMP1]
Seek First Using [TMP1]
Openo filpath('TRA',TRACE,'tra') Using [TMP2]
Rdseq LIGNE Using [TMP1]
While fstat=0
  I=instr(1,LIGNE,"TEST_")
  If I
    J=instr(I+1,LIGNE," ")
    If J
      TMP_STR=seg$(LIGNE,I,J-1)
      IDX = find(TMP_STR,TITLES(0..maxtab(TITLES)))
      If IDX>0
        Wrseq "Title"-format$("K:69X",TITLES(IDX-1)+" "+TITLES_DES(IDX-1))+
&        format$("N:20#[ ms]",TIMING_MS(IDX-1))+" "+format$("N:3.2#[%]",TIMING_PCT(IDX-1)) Using [TMP2]
      Endif
    Endif
  Endif
  Wrseq LIGNE Using [TMP2]
  If CNT=0
    Wrseq "Times shown for all tests cover execution of 1000K iterations unless otherwise indicated" Using [TMP2]
    Wrseq "" Using [TMP2]
  Endif
  If IDX>0
    Wrseq "" Using [TMP2]
  Endif
  Rdseq LIGNE Using [TMP1]
  CNT+=1
  If CNT>2000 : Break : Endif
Wend
Openio Using [TMP1]
Openio Using [TMP2]
End




# -----------------------------------------------------------------------
