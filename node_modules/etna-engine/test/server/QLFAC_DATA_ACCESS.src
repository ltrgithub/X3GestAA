olULocal Clbfile RESULT
RESULT=func TESTSUITE()
Call FERME_TRACE From LECFIC
GTRACE = "QLFAC_DATA_ACCESS_"+GACTX.USER
Call LEC_TRACE From LECFIC
End


#**
#* The main entry point of the unit test suite for table commands
#*
#*!
Funprog TESTSUITE()
Call ADD_TESTCASE("TC_FROM",        "For From To clause", 2) From AXUNIT
Call ADD_TESTCASE("TC_FOR",         "For clause", 62) From AXUNIT
Call ADD_TESTCASE("TC_WITH",        "With clause", 4) From AXUNIT
Call ADD_TESTCASE("TC_ORDERBY",     "Order By clause, reckey", 12) From AXUNIT
Call ADD_TESTCASE("TC_ORDERWITH",   "Order With clause", 4) From AXUNIT
Call ADD_TESTCASE("TC_READ",        "Read clause, Readlock, ", 32) From AXUNIT
Call ADD_TESTCASE("TC_LOOK",        "Look clause ", 30) From AXUNIT
Call ADD_TESTCASE("TC_G_ABV",       "KEYNAME, KEYLEN, KEYUNIQ, currind, currlen ...", 50) From AXUNIT
Call ADD_TESTCASE("TC_FSTAT",       "Fstat clause", 6) From AXUNIT
Call ADD_TESTCASE("TC_DELETE",      "Delete, DeletebyKey clause ", 12) From AXUNIT
Call ADD_TESTCASE("TC_UPDATE",      "Update clause ", 20) From AXUNIT
Call ADD_TESTCASE("TC_WRITE",       "Write clause", 14) From AXUNIT
Call ADD_TESTCASE("TC_REWRITE",     "Rewrite clause, RewritebyKey", 14) From AXUNIT
Call ADD_TESTCASE("TC_CLOSE",       "Close, Logicclose", 20) From AXUNIT
Call ADD_TESTCASE("TC_SQL",         "SQL Commands, EXECSQL, Adxsqlrec", 14) From AXUNIT
Call ADD_TESTCASE("TC_TRANSACTION", "Transaction clauses", 20) From AXUNIT
Call ADD_TESTCASE("TC_COLUMN",      "Column clause, Extended ", 12) From AXUNIT

#Call ADD_TESTCASE("TC_WRITEB",      "Write buffer clause", 13) From AXUNIT                    # writeb, adxwrb and flush
#Call ADD_TESTCASE("TC_INTERNAL",    "adxmto, filename, fileabrv", 6) From AXUNIT
#Call ADD_TESTCASE("TC_CLA",         "CLANAM, CLACMP, CLANBS ... ", 41) From AXUNIT



End func AXUNIT.RUN_TESTSUITE("US-99889 DataAccess", "")

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
Call CHECK_EQUAL(errmes$(errn)-errm, errmes$(EX)-errm) From AXUNIT
EX = 0
Resume

Subprog TC_WHERE
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub WHERE_FILE                   # Where statement on File
Gosub WHERE_FILTER                 # Where statement on Filter
Gosub WHERE_FOR                    # Where statement on For
Gosub WHERE_LINK                   # Where statement on Link
Gosub WHERE_DELETE                 # Where statement on Delete
Gosub WHERE_UPDATE                 # Where statement on Update
Gosub WHERE_KEY                    # Where statement using Key
Gosub WHERE_EVALUE                 # Evalue where clause
Gosub WHERE_ROWCOUNT               # Evalue where clause
End

Subprog TC_FOR
Integer EX
Onerrgo ERROR
Local File ABANK [ABN] Where CREUSR="AAAAA"
Local Integer CNT
Local Char MESSAGE(250)

Gosub FOR_LOOP                     # Count rows
Gosub FOR_WHERE                    # For with where clause
Gosub FOR_FROM_TABLE               # For with from clause on table
Gosub FOR_FROM_SQL                 # For with from clause on sql statement
Gosub FOR_PROPERTIES               # For properties
Gosub FOR_GROUPBY                  # Group by
Gosub FOR_LINK_LEFT_OUTER          # For on link left outer
Gosub FOR_LINK_INNER               # For on link inner - issue on inner joins in superv
# Gosub FOR_LINK_MIXED               # For on 11 tables mixed inner and left outer joins
End

Subprog TC_WITH
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

#Gosub WITH_LOCK                     # With lock on For
#Gosub WITH_LOCKWAIT                 # With lockwait on Readlock
Gosub WITH_STABILITY                # With Stability in a cursor
End

Subprog TC_ORDERBY
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub ORDERBY_KEY                   # Order by existing index by index name
Gosub ORDERBY_NEWKEY                # Create new index (key) and order by new key
Gosub ORDERBY_ASC_DESC              # Change ordering from ascending to descending
Gosub ORDERBY_COL                   # Order by a column

End

Subprog TC_ORDERWITH
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

# Order with is used to order by passing order by info in a string
Gosub ORDERWITH_NEWKEY              # Create and order with new key
Gosub ORDERWITH_COL                 # Order with a column

End

Subprog TC_READ
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub READ_FIRST                  # The first line in the index order.
Gosub READ_LAST                   # The last line in the index order.
#Gosub READ_PREV                   # The previous line, compared to the last read line, in the index order.
#Gosub READ_NEXT                   # The next line, compared to the last read line, in the index order.
Gosub READ_CURR                   # The current line (the last read line).
#Gosub READ_NEXT_ERR               # Read past end of table
#Gosub READ_PREV_ERR               # Read before beginning of table

Gosub READ_LT                     # The last line, in index order, that has a key value strictly less than the given value.
Gosub READ_LTE                    # The last line, in index order, that has a key value less than or equal to the given value.
Gosub READ_EQ                     # A line that has a key value equal to the given value.
Gosub READ_GTE                    # The first line, in index order, that has a key value greater than or equal to the given value.
Gosub READ_GT                     # The first line, in index order, that has a key value strictly greater to the given value.

End

Subprog TC_LOOK
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub LOOK_FIRST                  # The first line in the index order.
Gosub LOOK_LAST                   # The last line in the index order.
#Gosub LOOK_PREV                   # The previous line, compared to the last read line, in the index order.
#Gosub LOOK_NEXT                   # The next line, compared to the last read line, in the index order.
#Gosub LOOK_CURR                   # The current line (the last read line).
#Gosub LOOK_NEXT_ERR               # Read past end of table
#Gosub LOOK_PREV_ERR               # Read before beginning of table

Gosub LOOK_LT                     # The last line, in index order, that has a key value strictly less than the given value.
#Gosub LOOK_LTE                    # The last line, in index order, that has a key value less than or equal to the given value.
Gosub LOOK_EQ                     # A line that has a key value equal to the given value.
Gosub LOOK_GTE                    # The first line, in index order, that has a key value greater than or equal to the given value.
Gosub LOOK_GT                     # The first line, in index order, that has a key value strictly greater to the given value.

End

Subprog TC_G_ABV
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub G_ABV_KEYLEN
Gosub G_ABV_KEYNAME
Gosub G_ABV_KEYUNIQ

Gosub G_ABV_NBZON
Gosub G_ABV_NBIND
Gosub G_ABV_ADXFNAME
Gosub G_ABV_TAIREC

Gosub G_ABV_CURRIND
Gosub G_ABV_CURRLEN
Onerrgo
End

Subprog TC_CLA
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub CLA_CLACMP
Gosub CLA_CLANAM
Gosub CLA_CLANBS
Gosub CLA_CLASIZ
Gosub CLA_CLAVAR
Onerrgo
End

Subprog TC_COLUMN
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub COLUMN_NAME
Gosub COLUMN_NBZON
#Gosub COLUMN_CLOB
Gosub COLUMN_AXX
Onerrgo
End

Subprog TC_FSTAT
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub FSTAT_MESSAGE
Onerrgo
End

Subprog TC_FROM
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub FROM_GROUP

End

Subprog TC_DELETE
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)

Gosub DELETE_
Gosub DELETE_ABV
Gosub DELETE_WHERE
End

Subprog TC_UPDATE
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub UPDATE_
Gosub UPDATE_ALL
Gosub UPDATE_FAIL
Gosub UPDATE_INVALID_COLUMN
End

Subprog TC_WRITEB
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub WRITEB_
Gosub WRITEB_ABV
Gosub WRITEB_DUP_FAIL
End

Subprog TC_WRITE
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub WRITE_
Gosub WRITE_ABV
Gosub WRITE_DUP_FAIL
End

Subprog TC_REWRITE
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub REWRITE_
Gosub REWRITE_ABV
Gosub REWRITE_CURR
#Gosub REWRITE_PREV
#Gosub REWRITE_NEXT
#Gosub REWRITE_ON_LINK_FAIL
#Gosub REWRITEBYKEY_ABV_KEY
Onerrgo
End


Subprog TC_CLOSE
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub CLOSE_FILE
Gosub CLOSE_LOCAL_FILE
Gosub CLOSE_LOCAL_FILES
Gosub CLOSE_LOCAL_FILE_ERR
Gosub LOGICCLOSE_FILE
Gosub LOGICCLOSE_FILES
Gosub LOGICCLOSE_FILE_ERR
Gosub LOGICCLOSE_LIST_FILES
Onerrgo
End


Subprog TC_SQL
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub EXECSQL_
Gosub EXECSQL_ERR
Gosub ANASQL_
Onerrgo
End

Subprog TC_INTERNAL
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub INTERNAL_ADXMTO
Gosub INTERNAL_FILEABRE
#Gosub INTERNAL_FILENAME
#Gosub INTERNAL_SADMEM
#Gosub INTERNAL_DBGSTR
Onerrgo
End

Subprog TC_TRANSACTION
Integer EX
Onerrgo ERROR
Local Integer CNT
Local Char MESSAGE(250)
Gosub TRANSACTION_
Gosub TRANSACTION_ERR
Onerrgo
End
#####################################################################
$WHERE_FILE
  MESSAGE="File Where"
  Local File BPADDRESS [BPA] Where CREUSR = "AAAAA"
  Call CHECK_EQUAL(MESSAGE-'rowcount',rowcount([BPA]),22)
  Call CHECK_NOTEQUAL(MESSAGE-'nbrecord',nbrecord([BPA]),22)
  LogicClose File [BPA]
Return

$WHERE_FILTER
  MESSAGE="Filter"
  Local File BPADDRESS [BPA]
  Filter [BPA] Where CREUSR="AAAAA"
  Call CHECK_EQUAL(MESSAGE-'rowcount',rowcount([BPA]),22)
  Call CHECK_NOTEQUAL(MESSAGE-'nbrecord',nbrecord([BPA]),22)
  Raz CNT
  For [BPA]
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE-'For',CNT,22)
  Filter [BPA]
  LogicClose File [BPA]
Return

$WHERE_FOR
  MESSAGE="For"
  Local File BPADDRESS [BPA]
  Raz CNT
  For [BPA] Where CREUSR="AAAAA"
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE-'Where',CNT,22)
  LogicClose File [BPA]
Return

$WHERE_EVALUE
  MESSAGE="Evalue"
  Local File BPADDRESS [BPA]
  Raz CNT
  For [BPA] Where evalue('CREUSR="AAAAA"')
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE-'where',CNT,22)
  LogicClose File [BPA]
Return

$WHERE_LINK
  MESSAGE="Link"
  Local File BPADDRESS [BPA] Order By Key KEY1=CRY
  Local File TABCOUNTRY [TCY]
  Raz CNT
  Link [F:TCY] With [F:BPA]KEY1 ~= [F:TCY]CRY As [LNK1] Where [F:TCY]CRY="FR" Order By [F:TCY]CRY
  Raz CNT
  For [F:LNK1]
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE-'Where',(CNT>0),1)

  LogicClose File [BPA],[TCY]
Return

$WHERE_DELETE
  MESSAGE="Delete"
  Local File BPADDRESS [BPA]
  Trbegin [BPA]
  Delete [BPA] Where CREUSR="AAAAA"
  Rollback
  Call CHECK_EQUAL(MESSAGE-'Where',adxdlrec,22)
  LogicClose File [BPA]
Return

$WHERE_UPDATE
  MESSAGE="Update"
  Local File BPADDRESS [BPA]
  Trbegin [BPA]
  Update [BPA] Where CREUSR="AAAAA" With CREUSR="BBBBB"
  Rollback
  Call CHECK_EQUAL(MESSAGE-'Where',adxuprec,22)
  LogicClose File [BPA]
Return

$WHERE_ROWCOUNT
  MESSAGE="Rowcount"
  Local File BPADDRESS [BPA] Order By Key KEY1=CRY
  Local File TABCOUNTRY [TCY]
  Raz CNT
  Link [F:TCY] With [F:BPA]KEY1 ~= [F:TCY]CRY As [LNK1] Where [F:TCY]CRY="FR" Order By [F:TCY]CRY
  Raz CNT
  For [F:LNK1]
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE-'Where',CNT,rowcount([LNK1]))
  LogicClose File [BPA],[TCY]
Return

$WHERE_KEY
  MESSAGE="Where Key filter statement on 3 part key"
  Local Integer CNT
  Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
  Filter [AQCREQ3] Where Key AQCREQ32(1)>"A"
  Call CHECK_EQUAL(MESSAGE-'KEY(1)>"A"',rowcount([AQCREQ3]),1)
  Raz CNT
  For [AQCREQ3]
    CNT+=1
    Case CNT
      When 1
        Call CHECK_EQUAL(MESSAGE-'KEY(1)>"A"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"B A D")
      When Default
        Call CHECK_EQUAL(MESSAGE-'KEY(1)>"A"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"Invalid value")
    Endcase
  Next
  Filter [AQCREQ3]

  Filter [AQCREQ3] Where Key AQCREQ32(2)>"A"
  Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A"',rowcount([AQCREQ3]),1)
  Raz CNT
  For [AQCREQ3]
    CNT+=1
    Case CNT
      When 1
        Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"B A D")
      When Default
        Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"Invalid value")
    Endcase
  Next
  Filter [AQCREQ3]

  Filter [AQCREQ3] Where Key AQCREQ32(2)>"A";"B"

  Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A;B"',rowcount([AQCREQ3]),4)
  Raz CNT
  For [AQCREQ3]
    CNT+=1
    Case CNT
      When 1
        Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A C A")
      When 2
        Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A C B")
      When 3
        Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A D E")
      When 4
        Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"B A D")
      When Default
        Call CHECK_EQUAL(MESSAGE-'KEY(2)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"Invalid value")
    Endcase
  Next

  Filter [AQCREQ3]

  Filter [AQCREQ3] Where Key AQCREQ32(3)>"A";"B" Order By Key AQCREQ32
  Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B"',rowcount([AQCREQ3]),4)
  Raz CNT
  For [AQCREQ3]
    CNT+=1
    Case CNT
      When 1
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A C A")
      When 2
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A C B")
      When 3
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A D E")
      When 4
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"B A D")
      When Default
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"Invalid value")
    Endcase
  Next

  Filter [AQCREQ3]

  Filter [AQCREQ3] Where Key AQCREQ32(3)>"A";"B";"C" Order By Key AQCREQ32
  Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B";"C"',rowcount([AQCREQ3]),5)
  Raz CNT
  For [AQCREQ3]
    CNT+=1
    Case CNT
      When 1
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B";"C"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A B D")
      When 2
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B";"C"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A C A")
      When 3
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B";"C"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A C B")
      When 4
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B";"C"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"A D E")
      When 5
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B";"C"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"B A D")
      When Default
        Call CHECK_EQUAL(MESSAGE-'KEY(3)>"A";"B";"C"',[AQCREQ3]MYKEY1-[AQCREQ3]MYKEY2-[AQCREQ3]MYKEY3,"Invalid value")
    Endcase
  Next
  Filter [AQCREQ3]
Return
###############################################################################
$FOR_LOOP
  MESSAGE = "Count of banks"
  For [F:ABN] Where [F:ABN]CRY<>""
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE,CNT,4)
Return

$FOR_WHERE                    # For with where clause
  MESSAGE = "Retrieve bank where country='FR''"
  Raz CNT
  For [F:ABN] Where CRY="FR"
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE,CNT,2)
Return

$FOR_FROM_TABLE               # For with from clause
  Local File BPADDRESS [BPA2] Where CREUSR="AAAAA" Order By Key KEY1=CRY;SAT
  MESSAGE = "Retrieve BPADDRESS from country='US' and states 'NY' to 'ZZ'"
  CNT=0
  For [BPA2]KEY1 From "US";"NY" To "US";"ZZ"
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE,CNT,2)
Return


$FOR_FROM_SQL               # For with from clause
  Local Char DBTYPE(1)
  Case fmet GACTX.APARAM.AGETVALNUM([V]CST_ALEVFOLD,"","TYPDBA")
    When 1 : DBTYPE="O"
    When 2 : DBTYPE="S"
  Endcase

  Local Char SQL_STATEMENT(250)
  MESSAGE = "Retrieve BPADDRESS from country='US''"
  SQL_STATEMENT="Select  count(*) As NBR From BPADDRESS Where CREUSR_0='AAAAA' and CRY_0='US'"
  For (Integer CNT) From DBTYPE Sql SQL_STATEMENT As [BPA3]
    Call CHECK_EQUAL(MESSAGE,[BPA3]CNT,10)
  Next

Return

$FOR_PROPERTIES                # For properties
  MESSAGE = "Bank FR;30004 Property compare"
  Call CHECK_EQUAL(MESSAGE-"AUUID",num$([F:ABN]AUUID),"a8929d10-44ed-4651-b4e6-91235d0a9f0d")
  Call CHECK_EQUAL(MESSAGE-"BAN",[F:ABN]BAN,"30004")
  Call CHECK_EQUAL(MESSAGE-"BIC",[F:ABN]BIC,"1")
  Call CHECK_EQUAL(MESSAGE-"CREDAT",[F:ABN]CREDAT,[13/02/2015])
  Call CHECK_EQUAL(MESSAGE-"CREDATIM",[F:ABN]CREDATTIM,gdatetime$("2015-02-13T18:50:47Z"))
  Call CHECK_EQUAL(MESSAGE-"CREUSR",[F:ABN]CREUSR,"AAAAA")
  Call CHECK_EQUAL(MESSAGE-"UPDDAT",[F:ABN]UPDDAT,[00/00/0000])
  Call CHECK_EQUAL(MESSAGE-"UPDDATIM",[F:ABN]UPDDATTIM,gdatetime$("2015-02-13T18:50:47Z"))
  Call CHECK_EQUAL(MESSAGE-"UPDUSR",[F:ABN]UPDUSR,"AAAAA")
  Call CHECK_EQUAL(MESSAGE-"PAB",[F:ABN]PAB,"CIC Sophia Antipolis")
  Call CHECK_EQUAL(MESSAGE-"VLYEND",[F:ABN]VLYEND,[01/01/2015])
  Call CHECK_EQUAL(MESSAGE-"VLYSTR",[F:ABN]VLYSTR,[01/01/2013])
Return

$FOR_GROUPBY
  MESSAGE = "Retrieve bank by group by key(1)='FR''"
  Raz CNT
  For [F:ABN]ABN0(1)
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE,CNT,3)

  MESSAGE = "Bank FR;30004 Property compare"
  Call CHECK_EQUAL(MESSAGE-"AUUID",num$([F:ABN]AUUID),"99473fc5-8f4d-47e9-b583-8a2d92cd2624")
  Call CHECK_EQUAL(MESSAGE-"BAN",[F:ABN]BAN,"PNC")
  Call CHECK_EQUAL(MESSAGE-"BIC",[F:ABN]BIC,"011231311")
  Call CHECK_EQUAL(MESSAGE-"CREDAT",[F:ABN]CREDAT,[13/02/2015])
  Call CHECK_EQUAL(MESSAGE-"CREDATIM",[F:ABN]CREDATTIM,gdatetime$("2015-02-13T18:51:29Z"))
  Call CHECK_EQUAL(MESSAGE-"CREUSR",[F:ABN]CREUSR,"AAAAA")
  Call CHECK_EQUAL(MESSAGE-"UPDDAT",[F:ABN]UPDDAT,[00/00/0000])
  Call CHECK_EQUAL(MESSAGE-"UPDDATIM",[F:ABN]UPDDATTIM,gdatetime$("2015-02-13T19:10:22Z"))
  Call CHECK_EQUAL(MESSAGE-"UPDUSR",[F:ABN]UPDUSR,"AAAAA")
  Call CHECK_EQUAL(MESSAGE-"PAB",[F:ABN]PAB,"Cranberry")
  Call CHECK_EQUAL(MESSAGE-"VLYEND",[F:ABN]VLYEND,[1/01/2015])
  Call CHECK_EQUAL(MESSAGE-"VLYSTR",[F:ABN]VLYSTR,[31/12/2015])

  LogicClose File [ABN]
Return

$FOR_LINK_LEFT_OUTER
  Local File BPADDRESS [BPAZ] Where CREUSR="AAAAA"
  Local File TABCOUNTRY [TCYZ] Where CREUSR="AAAAA"
  MESSAGE = "Link Test - left outer join on 2 tables"
  Filter [F:BPAZ] Order By Key KEY1=[F:BPAZ]CRY
  Link [F:TCYZ] With [F:BPAZ]KEY1 = [F:TCYZ]CRY As [LNKZ] Where [F:TCYZ]CRY="FR" Order By [F:TCYZ]CRY
  Raz CNT
  For [F:LNKZ]
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE,(CNT>0),1)

  Filter [LNKZ]
  LogicClose File [BPAZ],[TCYZ],[LNKZ]
Return

$FOR_LINK_INNER
  Local File BPADDRESS [BPAZ] Where CREUSR="AAAAA"
  Local File TABCOUNTRY [TCYZ] Where CREUSR="AAAAA"
  MESSAGE = "Link Test - left inner join on 2 tables"
  Filter [F:BPAZ] Order By Key KEY1=[F:BPAZ]CRY

  Link [F:TCYZ] With [F:BPAZ]KEY1 ~= [F:TCYZ]CRY As [LNKZ] Order By [F:TCYZ]CRY

  Raz CNT
  For [F:LNKZ]
    CNT+=1
  Next
  Call CHECK_EQUAL(MESSAGE,(CNT>0),1)
  Filter [LNKZ]
  LogicClose File [BPAZ],[TCYZ],[LNKZ]
Return


#####################################################################
$WITH_LOCK
  MESSAGE="For with lock"
  Local File BPADDRESS [BPA] Where CREUSR = "AAAAA"
  Local File BPADDRESS [BPAZ] Where CREUSR = "AAAAA"

  Trbegin [BPA],[BPAZ]
  lockwait = 0
  Readlock [BPA]First
  Rewrite [BPA]

  Readlock [BPAZ]BPA0=[BPA]BPATYP;[BPA]BPANUM;[BPA]BPAADD
  Rewrite [BPAZ]

  Call CHECK_EQUAL(MESSAGE-"Locked row test",fstat,[V]CST_ALOCK)

  Rollback
  Return

  Trbegin [BPA]
  Raz CNT,lockwait
  For [BPA] With Lock
    If fstat=[V]CST_AOK
      CNT+=1
    Endif
    Readlock [BPAZ]BPA0=[BPA]BPATYP;[BPA]BPANUM;[BPA]BPAADD
    Call CHECK_EQUAL(MESSAGE-"Locked row test",fstat,[V]CST_ALOCK)
  Next
  Rollback
  Return
  Call CHECK_EQUAL(MESSAGE-"Total locked rows",CNT,rowcount([BPA]))


  Trbegin [BPAZ]
    Readlock [BPAZ]First
    Call CHECK_EQUAL(MESSAGE-"Locked row test",fstat,[V]CST_ALOCK)


    Rewrite [BPAZ]
    Rollback
    Call CHECK_EQUAL(MESSAGE-"Locked row test",fstat,[V]CST_ALOCK)

Unlock [BPA]
    Call CHECK_EQUAL(MESSAGE-"Locked row test",fstat,[V]CST_AOK)

  LogicClose File [BPA],[BPAZ]
Return


$WITH_LOCKWAIT              # With lockwait on Readlock
Return

$WITH_STABILITY             # With Stability in a cursor-sqlserver processing. Oracle defaults to with stability
MESSAGE="For with stability"
Local Integer CNT,AQCREQ3_CNT,AQCREQ3_ROWCOUNT
Local File AQCREQ3 [AQCREQ3]
Filter [AQCREQ3] Where ACV="KUS"
AQCREQ3_ROWCOUNT=rowcount([F:AQCREQ3])
Filter [AQCREQ3]

Trbegin [AQCREQ3]
  For [F:AQCREQ3] Where ACV="KUS" With Stability
  AQCREQ3_CNT+=1
  If AQCREQ3_CNT=1
    For CNT=1 To 5
      [F:AQCREQ3]COD=num$(CNT)+right$([F:AQCREQ3]COD,2)
      Write [F:AQCREQ3]
      If fstat
        Break 2
      Endif
    Next CNT
  Endif
  Next
Rollback
Call CHECK_EQUAL(MESSAGE-"test",AQCREQ3_CNT,AQCREQ3_ROWCOUNT)

# Deternube database
Local Char DBTYPE(1)
MESSAGE="For without stability"
Case fmet GACTX.APARAM.AGETVALNUM([V]CST_ALEVFOLD,"","TYPDBA")
  When 1 : DBTYPE="O"
  When 2 : DBTYPE="S"
Endcase
Raz AQCREQ3_CNT
# Oracle test - no difference between with stability and no stability cursor
Trbegin [AQCREQ3]
If DBTYPE="O"
  For [F:AQCREQ3] Where ACV="KUS"
    AQCREQ3_CNT+=1
    If AQCREQ3_CNT=1
      For CNT=1 To 5
        [F:AQCREQ3]COD=num$(CNT)+right$([F:AQCREQ3]COD,2)
        Write [F:AQCREQ3]
        If fstat
          Break 2
        Endif
      Next CNT
    Endif
  Next
  Call CHECK_EQUAL(MESSAGE-"Oracle test",AQCREQ3_CNT,AQCREQ3_ROWCOUNT)
Elsif DBTYPE="S"
  For [F:AQCREQ3] Where ACV="KUS"
    AQCREQ3_CNT+=1
    If AQCREQ3_CNT=1
      For CNT=1 To 5
        [F:AQCREQ3]COD=num$(CNT)+right$([F:AQCREQ3]COD,2)
        Write [F:AQCREQ3]
        If fstat
          Break 2
        Endif
      Next CNT
    Endif
  Next
  Call CHECK_EQUAL(MESSAGE-"SQLserver test",AQCREQ3_CNT,AQCREQ3_ROWCOUNT+5)
Endif

Rollback

Return


#########################################################################
$ORDERBY_KEY
MESSAGE="Order By"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA" Order By Key AQCREQ30
For [AQCREQ3]
Break
Next
Call CHECK_EQUAL(MESSAGE-"key",[F:AQCREQ3]COD,"0000000001")
LogicClose File [AQCREQ3]
Return

$ORDERBY_NEWKEY
MESSAGE="Order By"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA" Order By Key NEWKEY=TCU
For [AQCREQ3]
Break
Next
Call CHECK_EQUAL(MESSAGE-"new key",[F:AQCREQ3]COD,"0000000002")

For [AQCREQ3]reckey
Break
Next
Call CHECK_EQUAL(MESSAGE-"reckey order",[F:AQCREQ3]COD,"0000000001")

EX=21                                               # Cannot change the key after using manually defined key
For [AQCREQ3]AQCREQ30
Break
Next

LogicClose File [AQCREQ3]
Return

$ORDERBY_ASC_DESC
MESSAGE="Order By"

Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA" Order By Key NEWKEY=TCU Desc
For [AQCREQ3]
Break
Next
Call CHECK_EQUAL(MESSAGE-"key descending",[F:AQCREQ3]COD,"0000000001")
LogicClose File [AQCREQ3]
Return

$ORDERBY_COL
MESSAGE="Order By"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA" Order By TCU
For [AQCREQ3]
Break
Next
Call CHECK_EQUAL(MESSAGE-"column",[F:AQCREQ3]COD,"0000000002")
LogicClose File [AQCREQ3]
Return

#########################################################################
$ORDERWITH_NEWKEY
MESSAGE="Order With"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA" Order With Key NEWKEY="TCU"
For [AQCREQ3]
Break
Next
Call CHECK_EQUAL(MESSAGE-"new key",[F:AQCREQ3]COD,"0000000002")
LogicClose File [AQCREQ3]
Return

$ORDERWITH_COL
MESSAGE="Order With"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA" Order With "TCU"
For [AQCREQ3]
Break
Next
Call CHECK_EQUAL(MESSAGE-"column",[F:AQCREQ3]COD,"0000000002")
LogicClose File [AQCREQ3]
Return

###########################################################################
$READ_FIRST                  # The first line in the index order
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]First
Call CHECK_EQUAL(MESSAGE-"read first fstat",fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"read first COD value", [F:AQCREQ3]COD,"0000000001")
LogicClose File [AQCREQ3]
Return

$READ_LAST                   # The last line in the index order
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]Last
Call CHECK_EQUAL(MESSAGE-"last fstat",fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"last COD value", [F:AQCREQ3]COD,"0000000010")
LogicClose File [AQCREQ3]
Return

$READ_PREV                   # The previous line, compared to the last read line, in the index order
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]Last
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"last read failed fstat",fstat, [V]CST_AOK)
Else
  Read [F:AQCREQ3]Prev
  Call CHECK_EQUAL(MESSAGE-"previous fstat",fstat, [V]CST_AOK)
  Call CHECK_EQUAL(MESSAGE-"previous COD value", [F:AQCREQ3]COD,"0000000009")
Endif
LogicClose File [AQCREQ3]
Return

$READ_NEXT                   # The next line, compared to the last read line, in the index order
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]First
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"first read failed fstat",fstat, [V]CST_AOK)
Else
  Read [F:AQCREQ3]Next
  Call CHECK_EQUAL(MESSAGE-"next fstat",fstat, [V]CST_AOK)
  Call CHECK_EQUAL(MESSAGE-"next COD value", [F:AQCREQ3]COD,"0000000002")
Endif
LogicClose File [AQCREQ3]
Return

$READ_CURR                   # The current line (the last read line)MESSAGE="Read"
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]Last
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"read current failed fstat",fstat, [V]CST_AOK)
Else
  Raz [F:AQCREQ3]
  Read [F:AQCREQ3]Curr
  Call CHECK_EQUAL(MESSAGE-"read current fstat",fstat, [V]CST_AOK)
  Call CHECK_EQUAL(MESSAGE-"current COD value", [F:AQCREQ3]COD,"0000000010")
Endif
LogicClose File [AQCREQ3]
Return

$READ_NEXT_ERR                   # Read next past end of table
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]Last
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"last read failed fstat",fstat, [V]CST_AOK)
Else
  Read [F:AQCREQ3]Next
  Call CHECK_EQUAL(MESSAGE-"attempt to read non-existing key fstat",fstat, [V]CST_AOUTKEYS)
Endif
LogicClose File [AQCREQ3]
Return

$READ_PREV_ERR                   # Read previous prior to beginning of table
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]First
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"first read failed fstat",fstat, [V]CST_AOK)
Else
  Read [F:AQCREQ3]Prev
  Call CHECK_EQUAL(MESSAGE-"attempt to read non-existing key fstat",fstat, [V]CST_AOUTKEYS)
Endif
LogicClose File [AQCREQ3]
Return

$READ_LT                     # The last line, in index order, that has a key value strictly less than the given value.
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]AQCREQ30<"0000000004"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"less than read failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_EQUAL(MESSAGE-"less than read COD value", [F:AQCREQ3]COD,"0000000003")
Endif

Read [F:AQCREQ3]AQCREQ31(1)<"XXX"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"less than read failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_EQUAL(MESSAGE-"less than ACV<'XXX' value", [F:AQCREQ3]COD,"0000000005")
Endif
LogicClose File [AQCREQ3]
Return

$READ_LTE                    # The last line, in index order, that has a key value less than or equal to the given value.
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]AQCREQ31(1)<="XXX"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"less than or equal read succeeded but key found is different (fstat=[V]CST_AOUTSEARCH)",fstat, [V]CST_AOUTSEARCH)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"less than or equal read failed ACV<='XXX' value", fstat=[V]CST_AOUTSEARCH,[V]CST_AOUTSEARCH)
Endif
LogicClose File [AQCREQ3]
Return

$READ_EQ                     # A line that has a key value equal to the given value.
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]AQCREQ30="0000000004"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"Equal read failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_EQUAL(MESSAGE-"read equal COD value", [F:AQCREQ3]COD,"0000000004")
Endif

Read [F:AQCREQ3]AQCREQ31="KFR";"0000000002"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"equal read failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_EQUAL(MESSAGE-"read equal ACV;COD value", [F:AQCREQ3]COD,"0000000002")
Endif
LogicClose File [AQCREQ3]

Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA" Order By Key NEWKEY=ACS;ACV
Read [F:AQCREQ3]NEWKEY(1)="AQCACS3"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"equal read on temporary key failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_EQUAL(MESSAGE-"equal read on temporary key NEWKEY(1) value", [F:AQCREQ3]ACS,"AQCACS3")
Endif
LogicClose File [AQCREQ3]


Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]AQCREQ30="no_record"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"Record not found is correct",fstat, 5)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"Record not found is incorrect",fstat, 5)
Endif
LogicClose File [AQCREQ3]

Return

$READ_GTE                    # The first line, in index order, that has a key value greater than or equal to the given value.
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]AQCREQ31(1)>="AAA"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"greater than or equal read succeeded but key found is different (fstat=[V]CST_AOUTSEARCH)",fstat, [V]CST_AOUTSEARCH)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"greater than or equal read failed ACV<='XXX' value", fstat=[V]CST_AOUTSEARCH,[V]CST_AOUTSEARCH)
Endif
LogicClose File [AQCREQ3]
Return

$READ_GT                     # The first line, in index order, that has a key value strictly greater to the given value.
MESSAGE="Read"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [F:AQCREQ3]AQCREQ30>"0000000002"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"greater than read failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_EQUAL(MESSAGE-"greater than COD value", [F:AQCREQ3]COD,"0000000003")
Endif

Read [F:AQCREQ3]AQCREQ31(1)>"AAA"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"greater than read failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_EQUAL(MESSAGE-"greater than  ACV>'AAA' value", [F:AQCREQ3]COD,"0000000007")
Endif
LogicClose File [AQCREQ3]
Return

###########################################################################
$LOOK_FIRST                  # The first line in the index order
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Raz [F:AQCREQ3]
Look [F:AQCREQ3]First
Call CHECK_EQUAL(MESSAGE-"first fstat",fstat, [V]CST_AOK)
Call CHECK_NOTEQUAL(MESSAGE-"first COD value", [F:AQCREQ3]COD,"0000000001")
Read [F:AQCREQ3]Curr
Call CHECK_EQUAL(MESSAGE-"Read []Curr after look first",fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Read []Curr 'COD' value after look first",[F:AQCREQ3]COD, "0000000001")
LogicClose File [AQCREQ3]
Return

$LOOK_LAST                   # The last line in the index order
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Raz [F:AQCREQ3]
Look [F:AQCREQ3]Last
Call CHECK_EQUAL(MESSAGE-"last fstat",fstat, [V]CST_AOK)
Call CHECK_NOTEQUAL(MESSAGE-"last COD value", [F:AQCREQ3]COD,"0000000010")
LogicClose File [AQCREQ3]
Return

$LOOK_PREV                   # The previous line, compared to the last look line, in the index order
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]Last
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"last look failed fstat",fstat, [V]CST_AOK)
Else
  Look [F:AQCREQ3]Prev
  Call CHECK_EQUAL(MESSAGE-"previous fstat",fstat, [V]CST_AOK)
  Call CHECK_NOTEQUAL(MESSAGE-"previous COD value", [F:AQCREQ3]COD,"0000000009")
Endif
LogicClose File [AQCREQ3]
Return

$LOOK_NEXT                   # The next line, compared to the last look line, in the index order
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]First
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"first look failed fstat",fstat, [V]CST_AOK)
Else
  Look [F:AQCREQ3]Next
  Call CHECK_EQUAL(MESSAGE-"next fstat",fstat, [V]CST_AOK)
  Call CHECK_NOTEQUAL(MESSAGE-"next COD value", [F:AQCREQ3]COD,"0000000002")
Endif
LogicClose File [AQCREQ3]
Return

$LOOK_CURR                   # The current line (the last look line)MESSAGE="Look"
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]Last
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"look current failed fstat",fstat, [V]CST_AOK)
Else
  Raz [F:AQCREQ3]
  Look [F:AQCREQ3]Curr
  Call CHECK_EQUAL(MESSAGE-"look current fstat",fstat, [V]CST_AOK)
  Call CHECK_NOTEQUAL(MESSAGE-"current COD value", [F:AQCREQ3]COD,"0000000010")
Endif
LogicClose File [AQCREQ3]
Return

$LOOK_NEXT_ERR                   # Look next past end of table
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]Last
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"last look failed fstat",fstat, [V]CST_AOK)
Else
  Look [F:AQCREQ3]Next
  Call CHECK_EQUAL(MESSAGE-"attempt to look non-existing key fstat",fstat, [V]CST_AOUTKEYS)
Endif
LogicClose File [AQCREQ3]
Return

$LOOK_PREV_ERR                   # Look previous prior to beginning of table
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]First
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"first look failed fstat",fstat, [V]CST_AOK)
Else
  Look [F:AQCREQ3]Prev
  Call CHECK_EQUAL(MESSAGE-"attempt to look non-existing key fstat",fstat, [V]CST_AOUTKEYS)
Endif
LogicClose File [AQCREQ3]
Return

$LOOK_LT                     # The last line, in index order, that has a key value strictly less than the given value.
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]AQCREQ30<"0000000004"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"less than look failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"less than look COD value", [F:AQCREQ3]COD,"0000000003")
Endif

Look [F:AQCREQ3]AQCREQ31(1)<"XXX"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"less than look failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"less than ACV<'XXX' value", [F:AQCREQ3]COD,"0000000005")
Endif
LogicClose File [AQCREQ3]
Return

$LOOK_LTE                    # The last line, in index order, that has a key value less than or equal to the given value.
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]AQCREQ31(1)<="XXX"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"less than or equal look succeeded but key found is different (fstat=[V]CST_AOUTSEARCH)",fstat, [V]CST_AOUTSEARCH)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"less than or equal look failed ACV<='XXX' value", fstat=[V]CST_AOUTSEARCH,[V]CST_AOUTSEARCH)
Endif
LogicClose File [AQCREQ3]
Return

$LOOK_EQ                     # A line that has a key value equal to the given value.
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]AQCREQ30="0000000004"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"Equal look failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"equal COD value", [F:AQCREQ3]COD,"0000000004")
Endif

Look [F:AQCREQ3]AQCREQ31="KFR";"0000000002"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"equal look failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"equal ACV;COD value", [F:AQCREQ3]COD,"0000000002")
Endif
LogicClose File [AQCREQ3]

Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA" Order By Key NEWKEY=ACS;ACV
Look [F:AQCREQ3]NEWKEY(1)="AQCACS3"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"equal look on temporary key failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"equal look on temporary key NEWKEY(1) value", [F:AQCREQ3]ACS,"AQCACS3")
Endif
LogicClose File [AQCREQ3]


Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]AQCREQ30="no_record"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"Record not found is correct",fstat, 5)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"Record not found is incorrect",fstat, 5)
Endif
LogicClose File [AQCREQ3]

Return

$LOOK_GTE                    # The first line, in index order, that has a key value greater than or equal to the given value.
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]AQCREQ31(1)>="AAA"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"greater than or equal look succeeded but key found is different (fstat=[V]CST_AOUTSEARCH)",fstat, [V]CST_AOUTSEARCH)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"greater than or equal look failed ACV<='XXX' value", fstat=[V]CST_AOUTSEARCH,[V]CST_AOUTSEARCH)
Endif
LogicClose File [AQCREQ3]
Return

$LOOK_GT                     # The first line, in index order, that has a key value strictly greater to the given value.
MESSAGE="Look"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Look [F:AQCREQ3]AQCREQ30>"0000000002"
If fstat<>[V]CST_AOK
  Call CHECK_EQUAL(MESSAGE-"greater than look failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"greater than COD value", [F:AQCREQ3]COD,"0000000003")
Endif

Look [F:AQCREQ3]AQCREQ31(1)>"AAA"
If fstat<>[V]CST_AOK
    Call CHECK_EQUAL(MESSAGE-"greater than look failed fstat",fstat, [V]CST_AOK)
Else
  Call CHECK_NOTEQUAL(MESSAGE-"greater than  ACV>'AAA' value", [F:AQCREQ3]COD,"0000000007")
Endif
LogicClose File [AQCREQ3]
Return

#####################################################################################
$G_ABV_KEYLEN
MESSAGE="[G:ABV]Keylen"
Call CHECK_EQUAL(MESSAGE-"Deprecated", "Deprecated", "Deprecated")
Return

$G_ABV_KEYNAME
MESSAGE="[G:ABV]Keyname"
Call CHECK_EQUAL(MESSAGE-"Deprecated", "Deprecated", "Deprecated")
Return

$G_ABV_KEYUNIQ
MESSAGE="[G:ABV]Keyuniq"
Call CHECK_EQUAL(MESSAGE-"Deprecated", "Deprecated", "Deprecated")
Return


$G_ABV_NBZON
MESSAGE="[G:ABV]NBZON"

Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Call CHECK_EQUAL(MESSAGE-"Number of columns",[G:AQCREQ3]nbzon, 23)
Local Integer EX, NB_ZON
EX=7
NB_ZON=[G:ZZZZZ]nbzon

LogicClose File [AQCREQ3]
Return

$G_ABV_NBIND
MESSAGE="[G:ABV]NBind"

Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Call CHECK_EQUAL(MESSAGE-"Number of indexes",[G:AQCREQ3]nbind, 3)
Local Integer EX, NB_ZON
EX=7
NB_ZON=[G:ZZZZZ]nbind

LogicClose File [AQCREQ3]
Return

$G_ABV_ADXFNAME
Local Integer EX
Local Integer T(2..10)
MESSAGE="[G:ABV]ADXFNAME"
EX=21

# Note TTEXT is type AXX and is not stored in the AQCREQ3 table. It is stored in ATEXTRA.
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Call CHECK_EQUAL(MESSAGE-"Names of columns",1, 1)
Call CHECK_EQUAL([G:AQCREQ3]adxfname(1), "CRY" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(2), "TCU" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(3), "DAT" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(4), "UOM" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(5), "ALPHA" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(6), "DCB" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(7), "ACS" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(8), "ACV" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(9), "DES" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(10), "COD" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(11), "INTG" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(12), "UUID" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(13), "DTIME" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(14), "MENL" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(15), "CREDATTIM" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(16), "UPDDATTIM" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(17), "AUUID" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(18), "CREUSR" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(19), "UPDUSR" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(20), "MYKEY1" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(21), "MYKEY2" ) From AXUNIT
Call CHECK_EQUAL([G:AQCREQ3]adxfname(22), "MYKEY3" ) From AXUNIT

Local Char ADX_FNAME(10)
If pat(ver$(0),"etna*")<=0
 EX=21
Else
 EX=8
Endif
ADX_FNAME=[G:AQCREQ3]adxfname(100)

LogicClose File [AQCREQ3]
Return

$G_ABV_TAIREC
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
MESSAGE = "TAIREC"
Call CHECK_EQUAL(MESSAGE-"Record size",[G:AQCREQ3]tairec, 471)
LogicClose File [AQCREQ3]
Return

$G_ABV_CURRIND
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"

MESSAGE = "CURRIND"
Call CHECK_EQUAL(MESSAGE-"No read index",[G:AQCREQ3]currind, 1)
Read [AQCREQ3]AQCREQ32="A"
Call CHECK_EQUAL(MESSAGE-"index 3",[G:AQCREQ3]currind, 3)
Filter [AQCREQ3] Order By Key KEY1=MYKEY3
Read [AQCREQ3]KEY1="E"
Call CHECK_EQUAL(MESSAGE-"New index",[G:AQCREQ3]currind, 1)
LogicClose File [AQCREQ3]
Return

$G_ABV_CURRLEN
MESSAGE="CURLEN"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"

[G:AQCREQ3]currind = 3
[G:AQCREQ3]currlen = 1
Read [AQCREQ3]="B"
Call CHECK_EQUAL(MESSAGE-"New index",fstat, 0)
LogicClose File [AQCREQ3]
Return

#############################################################################
$CLA_CLACMP
MESSAGE="CLACMP"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Local File AQCREQ4 [AQCREQ4] Where CREUSR="AAAAA"
Local File AQCREQ3 [AQCREQ] Where CREUSR="AAAAA"

Read [AQCREQ3]First
Read [AQCREQ]First
Local Integer CMP
CMP = clacmp([AQCREQ3],[AQCREQ])
Call CHECK_EQUAL(MESSAGE-"Identical", CMP, [V]CST_AOK)

Read [AQCREQ3]First
Read [AQCREQ]Last
Local Integer CMP
CMP = clacmp([AQCREQ3],[AQCREQ])
Call CHECK_EQUAL(MESSAGE-"Structure identical but values different", CMP, 1)

Read [AQCREQ3]First
Read [AQCREQ4]Last
Local Integer CMP
CMP = clacmp([AQCREQ3],[AQCREQ4])
Call CHECK_EQUAL(MESSAGE-"Structure different", CMP, 2)

LogicClose File [AQCREQ3],[AQCREQ4],[AQCREQ]
Return

$CLA_CLANAM
MESSAGE="CLANAM"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Local Integer I
Local Char TABLE_NAME(50)

For I=1 To 200
If clanam(I)="[F:AQCREQ3]"
  Break
Endif
Next

TABLE_NAME = clanam([F:AQCREQ3])
Call CHECK_EQUAL(MESSAGE-"Table is open",TABLE_NAME, "[F:AQCREQ3]")

LogicClose File [AQCREQ3]
Return

$CLA_CLANBS
MESSAGE="CLANBS"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Local Integer CLA_NBS
CLA_NBS = clanbs([F:AQCREQ3],1)
Call CHECK_EQUAL(MESSAGE-"variables present",CLA_NBS, 22)
CLA_NBS = clanbs([AQCREQ3],2)
Call CHECK_EQUAL(MESSAGE-"slots allocated",CLA_NBS, 22)
EX=10
Call CHECK_EQUAL(MESSAGE-"Unopened class","", "")
CLA_NBS = clanbs([XXXXX],1)
LogicClose File [AQCREQ3]
Return

$CLA_CLASIZ
MESSAGE="CLASIZ"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Local Integer CLA_SIZ
CLA_SIZ = clasiz([AQCREQ3],1)
Call CHECK_EQUAL(MESSAGE-"variable size used",CLA_SIZ, 471)
CLA_SIZ = clasiz([AQCREQ3],2)
Call CHECK_EQUAL(MESSAGE-"variable size allocated",CLA_SIZ, 471)
EX=10
Call CHECK_EQUAL(MESSAGE-"Unopened class","", "")
CLA_SIZ = clasiz([F:XXXXX],1)
LogicClose File [AQCREQ3]
Return


$CLA_CLAVAR
MESSAGE="CLAVAR"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"

Local Integer I,J
Local Char VAR_NAME(50)

# TTEXT datatype AXX not included in count or values returned from clavar()
Call CHECK_EQUAL(MESSAGE-"number of columns",clanbs([F:AQCREQ3],1), 22)

VAR_NAME=clavar([F:AQCREQ3],1)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "ACS")

VAR_NAME=clavar([F:AQCREQ3],2)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "ACV")

VAR_NAME=clavar([F:AQCREQ3],3)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "ALPHA")

VAR_NAME=clavar([F:AQCREQ3],4)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "AUUID")

VAR_NAME=clavar([F:AQCREQ3],5)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "COD")

VAR_NAME=clavar([F:AQCREQ3],6)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "CREDATTIM")

VAR_NAME=clavar([F:AQCREQ3],7)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "CREUSR")

VAR_NAME=clavar([F:AQCREQ3],8)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "CRY")

VAR_NAME=clavar([F:AQCREQ3],9)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "DAT")

VAR_NAME=clavar([F:AQCREQ3],10)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "DCB")

VAR_NAME=clavar([F:AQCREQ3],11)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "DES")

VAR_NAME=clavar([F:AQCREQ3],12)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "DTIME")

VAR_NAME=clavar([F:AQCREQ3],13)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "INTG")

VAR_NAME=clavar([F:AQCREQ3],14)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "MENL")

VAR_NAME=clavar([F:AQCREQ3],15)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "MYKEY1")

VAR_NAME=clavar([F:AQCREQ3],16)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "MYKEY2")

VAR_NAME=clavar([F:AQCREQ3],17)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "MYKEY3")

VAR_NAME=clavar([F:AQCREQ3],18)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "TCU")

VAR_NAME=clavar([F:AQCREQ3],19)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "UOM")

VAR_NAME=clavar([F:AQCREQ3],20)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "UPDDATTIM")

VAR_NAME=clavar([F:AQCREQ3],21)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "UPDUSR")

VAR_NAME=clavar([F:AQCREQ3],22)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "UUID")

# Variable does not exist in table
VAR_NAME=clavar([F:AQCREQ3],23)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "")

# Variable DOES not EXIST IN TABLE
EX=10
VAR_NAME=clavar([F:XXXXX],23)
Call CHECK_EQUAL(MESSAGE-"Column name",VAR_NAME, "")

LogicClose File [AQCREQ3]
Return

#####################################################################################
$COLUMN_NAME
MESSAGE="COLUMN"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"

Columns [F:AQCREQ3](COD,ACV,DES)
dbgetna
Read [F:AQCREQ3]First

Call CHECK_NOTEQUAL(MESSAGE-"COD",[F:AQCREQ3]COD, "")
Call CHECK_NOTEQUAL(MESSAGE-"ACV",[F:AQCREQ3]ACV, "")
Call CHECK_NOTEQUAL(MESSAGE-"DES",[F:AQCREQ3]DES, "")

Call CHECK_EQUAL(MESSAGE-"ALPHA(1)",[F:AQCREQ3]ALPHA(1), "VIVXKXKXKXKMZM")
Call CHECK_EQUAL(MESSAGE-"ACS",[F:AQCREQ3]ACS, "AQCACS2")

LogicClose File [AQCREQ3]
Return

$COLUMN_NBZON
MESSAGE="COLUMN_NBZON"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"

Columns [F:AQCREQ3](COD,ACV,DES)
Read [F:AQCREQ3]First
Call CHECK_EQUAL(MESSAGE-"Number of columns",[G:AQCREQ3]nbzon, 23)  # Still manages 23 columns, even only 3 asked for

LogicClose File [AQCREQ3]
Return

$COLUMN_CLOB
MESSAGE="COLUMN_ACB"
Local File AQCREQ4 [AQCREQ4] Where CREUSR="AAAAA"

Columns [F:AQCREQ4](COD,CLOB,DES)
Read [F:AQCREQ4]Last
Call CHECK_EQUAL(MESSAGE-"clobs",[F:AQCREQ4]COD, "2")
Call CHECK_EQUAL(MESSAGE-"clobs",[F:AQCREQ4]CLOB, "this is a clob")
Call CHECK_EQUAL(MESSAGE-"clobs",[F:AQCREQ4]DES, "abc")

LogicClose File [AQCREQ4]
Return

$COLUMN_AXX
MESSAGE="COLUMN_AXX"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"

EX=6                  # fails with error - class does not exist.
Columns [F:AQCREQ3](COD,TTEXT)

LogicClose File [AQCREQ3]

Return

$FSTAT_MESSAGE
MESSAGE="FSTAT "

# OK
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [AQCREQ3]First
Call CHECK_EQUAL(MESSAGE-"fstat=[V]CST_AOK",fstat, [V]CST_AOK)
LogicClose File [AQCREQ3]



#Filter [AQCREQ3] Where Key AQCREQ32(1)>="A"
#For [AQCREQ3]AQCREQ32
#  If fstat<>[V]CST_AOK : Break : Endif
#Next
#Call CHECK_EQUAL(MESSAGE-"fstat=[V]CST_AOUTSEARCH",fstat, [V]CST_AOUTSEARCH)
#Filter [AQCREQ3]

# Duplicate key
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [AQCREQ3]First
Trbegin [AQCREQ3]
Write [AQCREQ3]
Rollback
Call CHECK_EQUAL(MESSAGE-"fstat=[V]CST_ADUPKEY",fstat, [V]CST_ADUPKEY)
LogicClose File [AQCREQ3]

## Read key out of range
#Filter [AQCREQ3] Where Key AQCREQ30>"2"
#Read [AQCREQ3]AQCREQ30="100000000000"
#Call CHECK_EQUAL(MESSAGE-"fstat=[V]CST_AOUTKEYS",fstat, [V]CST_AOUTKEYS)
#Filter [AQCREQ3]

Local File AQCREQ3 [AQCREQ3] Where CREUSR="AZZZA"
#Read [AQCREQ3]Last
# Note row not found
#Rewrite [AQCREQ3]Next # deprecated
#Call CHECK_EQUAL(MESSAGE-"fstat=[V]CST_AOUTKEYS",fstat, [V]CST_AOUTKEYS)
LogicClose File [AQCREQ3]

# Row not found
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [AQCREQ3]AQCREQ30="--1"
Call CHECK_EQUAL(MESSAGE-"fstat=[V]CST_ANOREC",fstat, 5)
LogicClose File [AQCREQ3]

# RewritebyKey obsolete updtick value
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Local File AQCREQ3 [AQCR3] Where CREUSR="AAAAA"

Read [AQCR3]First
Read [AQCREQ3]First

Trbegin [AQCREQ3]
#RewriteByKey [AQCREQ3]AQCREQ30=[F:AQCREQ3]COD
Commit

Trbegin [AQCR3]
#RewriteByKey [AQCR3]AQCREQ30=[F:AQCR3]COD
Commit
#Call CHECK_EQUAL(MESSAGE-"fstat=[V]CST_ARECTICKUPD",fstat, [V]CST_ARECTICKUPD)
LogicClose File [AQCREQ3],[AQCR3]

# DeleteByKey obsolete updtick value
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Local File AQCREQ3 [AQCR3] Where CREUSR="AAAAA"

Read [AQCR3]First
Read [AQCREQ3]First

Trbegin [AQCREQ3]
#RewriteByKey [AQCREQ3]AQCREQ30=[F:AQCREQ3]COD
Commit

Trbegin [AQCR3]
#DeleteByKey [AQCR3]AQCREQ30=[F:AQCR3]COD       # updtick is obsolete
Commit

#Call CHECK_EQUAL(MESSAGE-"fstat=[V]CST_ARECTICKDEL",fstat, [V]CST_ARECTICKDEL)

LogicClose File [AQCREQ3],[AQCR3]

Return


$FROM_GROUP
MESSAGE="From"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Local Integer CNT,CNT2

#For [AQCREQ3]AQCREQ32 From "A","C" To "B","A"
#  CNT+=1
#Next
Call CHECK_EQUAL('For [AQCREQ3]AQCREQ32 From "A" To "B" :  # depracated', 1, 1)
Return

############################################################################
$DELETE_
Local Char TMP_COD(50)
MESSAGE="Delete"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Onerrgo ERROR
Trbegin [AQCREQ3]
  Read [AQCREQ3]First
  TMP_COD=[AQCREQ3]COD
  Delete [AQCREQ3]
Rollback
Read [AQCREQ3]AQCREQ30=TMP_COD

Call CHECK_EQUAL(MESSAGE-"First row-fstat"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"First row-adxdlrec", [S]adxdlrec, 1)
LogicClose File [AQCREQ3]
Onerrgo
Return

$DELETE_ABV
MESSAGE="Delete"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Onerrgo ERROR
# delete all rows where CREUSR="AAAAA"
Trbegin [AQCREQ3]
  Delete [AQCREQ3] Where 1=1
Rollback
LogicClose File [AQCREQ3]
Call CHECK_EQUAL(MESSAGE-"First row with ABV-fstat", [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"First row-adxdlrec", [S]adxdlrec, 10)
Onerrgo
Return

$DELETE_WHERE
MESSAGE="Delete"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Onerrgo ERROR

Trbegin [AQCREQ3]
  Delete [AQCREQ3] Where MYKEY1="A"
Rollback
LogicClose File [AQCREQ3]
Call CHECK_EQUAL(MESSAGE-"Where clause-fstat", [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Where rows deleted-adxdlrec", [S]adxdlrec,5)
Onerrgo
Return

###################################################################################
$UPDATE_
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Update"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Onerrgo ERROR
Read [AQCREQ3]First
TMP_COD=[AQCREQ3]COD

TMP_DATETIME = num$(datetime$)

Trbegin [AQCREQ3]
  Update [AQCREQ3] Where COD=[L]TMP_COD With ALPHA(2)=TMP_DATETIME
Commit

Read [AQCREQ3]AQCREQ30=TMP_COD
Call CHECK_EQUAL(MESSAGE-"row"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"First row-adxuprec", [S]adxuprec, 1)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ3]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ3]
Onerrgo
Return

$UPDATE_ALL
MESSAGE="Update"
Local Char TMP_DATETIME(50)
TMP_DATETIME = num$(datetime$)
Infbox "toto0"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Onerrgo ERROR

Trbegin [AQCREQ3]
  Update [AQCREQ3] Where 1=1 With [F:AQCREQ3]ALPHA(3)=TMP_DATETIME
Commit

Call CHECK_EQUAL(MESSAGE-"All rows based on file statement", [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"All rows-adxuprec", [S]adxuprec, 10)
Filter [F:AQCREQ3] Where ALPHA(3)=TMP_DATETIME
Call CHECK_EQUAL(MESSAGE-"All rows updated based on filter statement", rowcount([F:AQCREQ3]), 10)
LogicClose File [AQCREQ3]
Onerrgo
Return

$UPDATE_FAIL
Local Char TMP_COD(50),TMP1_COD(50),TMP_DATETIME(50)
MESSAGE="Update"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Onerrgo ERROR
Read [AQCREQ3]First
TMP_COD=[AQCREQ3]COD
Read [AQCREQ3]Last
TMP1_COD=[AQCREQ3]COD
TMP_DATETIME = num$(datetime$)
Trbegin [AQCREQ3]
  Update [AQCREQ3] Where COD=[L]TMP1_COD With COD=TMP_COD,ALPHA(2)=TMP_DATETIME
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Call CHECK_EQUAL(MESSAGE-"Fails on duplicate index", [S]fstat, [V]CST_ADUPKEY)
Call CHECK_EQUAL(MESSAGE-"Failed rows-adxuprec", [S]adxuprec, 0)
Filter [F:AQCREQ3] Where COD=TMP_COD #ALPHA(2)=TMP_DATETIME
Call CHECK_EQUAL(MESSAGE-"Rows updated based on filter statemen"+ TMP_DATETIME, rowcount([F:AQCREQ3]), 1)
LogicClose File [AQCREQ3]
Onerrgo
Return

$UPDATE_INVALID_COLUMN
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Update"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Onerrgo ERROR
EX=6
Read [AQCREQ3]First
TMP_COD=[AQCREQ3]COD

TMP_DATETIME = num$(datetime$)
Trbegin [AQCREQ3]
  Update [AQCREQ3] Where COD=[L]TMP_COD With INVALID_COLUMN=TMP_DATETIME
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

LogicClose File [AQCREQ3]
Onerrgo
Return


###################################################################################
$WRITE_
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Write"
Local File AQCREQ3 [AQCREQ3]
Onerrgo ERROR
Read [AQCREQ3]Last
[L]TMP_COD=format$("N0:10",val([AQCREQ3]COD)+1)
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ3]COD = [L]TMP_COD
[F:AQCREQ3]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ3]
  #dbgetna
  Write
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Read [AQCREQ3]AQCREQ30=TMP_COD
Call CHECK_EQUAL(MESSAGE-"row"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Updated column COD", [F:AQCREQ3]COD,TMP_COD)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ3]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ3]
Onerrgo
Return


$WRITE_ABV
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Write"
Local File AQCREQ3 [AQCREQ3]
Onerrgo ERROR
Read [AQCREQ3]Last
[L]TMP_COD=format$("N0:10",val([AQCREQ3]COD)+1)
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ3]COD = [L]TMP_COD
[F:AQCREQ3]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ3]
  Write [F:AQCREQ3]
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Read [AQCREQ3]AQCREQ30=TMP_COD
Call CHECK_EQUAL(MESSAGE-"row"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Updated column COD", [F:AQCREQ3]COD,TMP_COD)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ3]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ3]
Onerrgo
Return

$WRITE_DUP_FAIL
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Write"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Onerrgo ERROR
Read [AQCREQ3]Last
[L]TMP_COD=[AQCREQ3]COD
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ3]COD = [L]TMP_COD
[F:AQCREQ3]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ3]
  Write [F:AQCREQ3]
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Call CHECK_EQUAL(MESSAGE-"row"-TMP_COD, [S]fstat, [V]CST_ADUPKEY)
LogicClose File [AQCREQ3]
Onerrgo
Return

###################################################################################
$WRITEB_
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="WriteB"
[S]adxwrb=1
Local File AQCREQ3 [AQCREQ3]
Onerrgo ERROR
Read [AQCREQ3]Last
[L]TMP_COD=format$("N0:10",val([AQCREQ3]COD)+1)
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ3]COD = [L]TMP_COD
[F:AQCREQ3]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ3]
  WriteB
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Call CHECK_EQUAL(MESSAGE-"fstat"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"adxwrb", [S]adxwrb, 1)

Read [AQCREQ3]AQCREQ30=TMP_COD
Call CHECK_EQUAL(MESSAGE-"Read fstat"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Updated column COD", [F:AQCREQ3]COD,TMP_COD)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ3]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ3]
Onerrgo
Return


$WRITEB_ABV
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="WriteB"
Local File AQCREQ3 [AQCREQ3]
Onerrgo ERROR
Read [AQCREQ3]Last
[L]TMP_COD=format$("N0:10",val([AQCREQ3]COD)+1)
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ3]COD = [L]TMP_COD
[F:AQCREQ3]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ3]
  WriteB
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Call CHECK_EQUAL(MESSAGE-"fstat"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"adxwrb", [S]adxwrb, 1)

Read [AQCREQ3]AQCREQ30=TMP_COD
Call CHECK_EQUAL(MESSAGE-"Read fstat"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Updated column COD", [F:AQCREQ3]COD,TMP_COD)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ3]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ3]
Onerrgo
Return

$WRITEB_DUP_FAIL
Local Char TMP_COD(50)
Local Integer I
MESSAGE="WriteB"
Local File AQCREQ3 [AQCREQ3]
Flush [AQCREQ3]
[S]adxwrb=5

# Note I=3 has duplicate index, but will not found until I=6 (adxwrb+1)
Read [AQCREQ3]Last
Trbegin [AQCREQ3]
For I=1 To 10
  If I<>3
    [F:AQCREQ3]COD = format$("N0:10",val([AQCREQ3]COD)+1)
  Endif
  WriteB [F:AQCREQ3]
  Break (fstat<>0)
Next
Rollback
Call CHECK_EQUAL(MESSAGE-"fstat"-TMP_COD, [S]fstat, [V]CST_ADUPKEY)
Call CHECK_EQUAL(MESSAGE-"adxwrb", [S]adxwrb, 5)
Call CHECK_EQUAL(MESSAGE-"Duplicate occurred on I=3 but loop should ran to adxwrb",I,adxwrb)

LogicClose File [AQCREQ3]
Return

###################################################################################
$REWRITE_
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Rewrite"
Local File AQCREQ3 [AQCREQ3]
Read [AQCREQ3]Last
[L]TMP_COD=format$("N0:10",val([AQCREQ3]COD))
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ3]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ3]
  Rewrite
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Read [AQCREQ3]AQCREQ30=TMP_COD
Call CHECK_EQUAL(MESSAGE-"row"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ3]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ3]
Return


$REWRITE_ABV
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Rewrite"
Local File AQCREQ3 [AQCREQ3]
Read [AQCREQ3]First
#Read [AQCREQ3]Next
[L]TMP_COD=format$("N0:10",val([AQCREQ3]COD))
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ3]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ3]
  Rewrite [F:AQCREQ3]
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Read [AQCREQ3]AQCREQ30=TMP_COD
Call CHECK_EQUAL(MESSAGE-"row"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ3]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ3]
Return

$REWRITE_CURR
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Rewrite"
Local File AQCREQ3 [AQCREQ3]
Read [AQCREQ3]Last
[L]TMP_COD=format$("N0:10",val([AQCREQ3]COD)+1)
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ3]COD = [L]TMP_COD
[F:AQCREQ3]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ3]
  Rewrite [F:AQCREQ3]Curr
  If fstat<>[V]CST_AOK
    Rollback
  Else
    Commit
  Endif

Read [AQCREQ3]AQCREQ30=TMP_COD
Call CHECK_EQUAL(MESSAGE-"row"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"Updated Curr column COD", [F:AQCREQ3]COD,TMP_COD)
Call CHECK_EQUAL(MESSAGE-"Updated Curr column ALPHA(2)", [F:AQCREQ3]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ3]
Return

$REWRITE_PREV
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Rewrite"
Local File AQCREQ5 [AQCREQ5] Where CREUSR="RBU"
Read [AQCREQ5]First
Read [AQCREQ5]Next
[L]TMP_COD = [F:AQCREQ5]COD             # Save 2nd COD value
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ5]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ5]
While fstat=[V]CST_AOK
  Rewrite [F:AQCREQ5]AQCREQ50 Prev
  Break
Wend
If fstat<>[V]CST_AOK
  Rollback
Else
  Commit
Endif

Read [AQCREQ5]First
Call CHECK_EQUAL(MESSAGE-"Prev row"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"First read row is now column COD", [F:AQCREQ5]COD,TMP_COD)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ5]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ5]
Return

$REWRITE_NEXT
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Rewrite"
Local File AQCREQ5 [AQCREQ5] Where CREUSR="RBU"
Read [AQCREQ5]Last
Read [AQCREQ5]Prev
[L]TMP_COD = [F:AQCREQ5]COD             # Save 2nd COD value
[L]TMP_DATETIME = num$(datetime$)
[F:AQCREQ5]ALPHA(2) = [L]TMP_DATETIME
Trbegin [AQCREQ5]
While fstat=[V]CST_AOK
  Rewrite [F:AQCREQ5]AQCREQ50 Next
  Break
Wend
If fstat<>[V]CST_AOK
  Rollback
Else
  Commit
Endif

Read [AQCREQ5]Last
Call CHECK_EQUAL(MESSAGE-"Next row"-TMP_COD, [S]fstat, [V]CST_AOK)
Call CHECK_EQUAL(MESSAGE-"First read row is next column COD", [F:AQCREQ5]COD,TMP_COD)
Call CHECK_EQUAL(MESSAGE-"Updated column ALPHA(2)", [F:AQCREQ5]ALPHA(2),TMP_DATETIME)
LogicClose File [AQCREQ5]
Return

$REWRITE_ON_LINK_FAIL
Local Char TMP_COD(50),TMP_DATETIME(50)
MESSAGE="Rewrite"
Local File AQCREQ3 [AQCREQ3]
Local File AQCREQ5 [AQCREQ5]
Link [AQCREQ3] With [AQCREQ5]AQCREQ50=[AQCREQ3]COD As [LNK_]
Trbegin [AQCREQ3]
Read [LNK_]First
If fstat=[V]CST_AOK
  Rewrite [LNK_]
Endif
Call CHECK_EQUAL(MESSAGE-"row.."-[F:AQCREQ3]COD, [S]fstat, [V]CST_AOK)
If fstat
  Rollback
Else
  Commit
Endif
EX=7
LogicClose File [AQCREQ3],[AQCREQ5],[LNK_]
Return

$REWRITEBYKEY_ABV_KEY
# RewritebyKey check updtick value
MESSAGE="RewriteByKey"
Local Integer SAV_UPDTICK
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"

Read [AQCREQ3]First
If fstat=[V]CST_AOK
  [L]SAV_UPDTICK=[AQCREQ3]updTick
Endif

Trbegin [AQCREQ3]
RewriteByKey [AQCREQ3]AQCREQ30=[F:AQCREQ3]COD
Commit
Call CHECK_NOTEQUAL(MESSAGE-"updTick correct",SAV_UPDTICK,[AQCREQ3]updTick)
LogicClose File [AQCREQ3]
Return

###########################################################################################
$CLOSE_FILE
# Close - Deprecated (Only Close Local supported in future)
EX=33
MESSAGE="Close"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [AQCREQ3]First
Close File [AQCREQ3]
Call CHECK_EQUAL(MESSAGE-"single table",clalev([AQCREQ3]),[V]CST_AFALSE)
Return

$CLOSE_LOCAL_FILE
# Close Local
MESSAGE="Close Local"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Read [AQCREQ3]First
Close Local File [AQCREQ3]

Call CHECK_EQUAL(MESSAGE-"single table",clalev([AQCREQ3]),[V]CST_AFALSE)
Return

$CLOSE_LOCAL_FILES
# Close Local
MESSAGE="Close Local"
Local File AQCREQ3 [AQCREQ3] Where CREUSR="AAAAA"
Local File AQCREQ5 [AQCREQ5] Where CREUSR="AAAAA"

Close Local File
Call CHECK_EQUAL(MESSAGE-"multiple tables",clalev([AQCREQ3]),[V]CST_AFALSE)
Call CHECK_EQUAL(MESSAGE-"multiple tables",clalev([AQCREQ5]),[V]CST_AFALSE)
Return

$CLOSE_LOCAL_FILE_ERR
# Close Local
MESSAGE="Close Local Error"
EX=20
Close Local File [ZZZZZ]
Return

$LOGICCLOSE_FILE
# Close
MESSAGE="LogicClose"
Local File AQCREQ5 [AQCREQ5]
LogicClose File [AQCREQ5]
Call CHECK_EQUAL(MESSAGE-"single table",clalev([AQCREQ5]),[V]CST_AFALSE)
Return

$LOGICCLOSE_FILES
Local File AQCREQ3 [AQCREQ3]
Local File AQCREQ5 [AQCREQ5]
LogicClose File
Call CHECK_EQUAL(MESSAGE-"multiple tables",clalev([AQCREQ3]),[V]CST_AFALSE)
Call CHECK_EQUAL(MESSAGE-"multiple tables",clalev([AQCREQ5]),[V]CST_AFALSE)
Return

$LOGICCLOSE_LIST_FILES
MESSAGE="LogicClose"
Local File AQCREQ3 [AQCREQ3]
Local File AQCREQ5 [AQCREQ5]
LogicClose File [AQCREQ3],[AQCREQ5]
Call CHECK_EQUAL(MESSAGE-"list of tables",clalev([AQCREQ3]),[V]CST_AFALSE)
Call CHECK_EQUAL(MESSAGE-"list of tables",clalev([AQCREQ5]),[V]CST_AFALSE)
Return

$LOGICCLOSE_FILE_ERR
# Close
EX=20
MESSAGE="LogicClose"
LogicClose File [ZZZZZ]
Return

###################################################################################
$EXECSQL_
# Execsql
MESSAGE="Execsql"
Local Char DATABASE_TYPE(1)
DATABASE_TYPE=num$(1+2*fmet GACTX.APARAM.AGETVALNUM([V]CST_ALEVFOLD,"","TYPDBA"))
Execsql From DATABASE_TYPE  Sql "create table ZAAAMYTABLE (t integer)"
Call CHECK_EQUAL(MESSAGE-"create table",[S]adxSqlRec,[V]CST_AOK)
Execsql From DATABASE_TYPE  Sql "insert into ZAAAMYTABLE values (1)"
Call CHECK_EQUAL(MESSAGE-"create table",[S]adxSqlRec,1)
Execsql From DATABASE_TYPE  Sql "drop table ZAAAMYTABLE"
Call CHECK_EQUAL(MESSAGE-"create table",[S]adxSqlRec,[V]CST_AOK)
Return

$EXECSQL_ERR
# Execsql
EX=106
MESSAGE="Execsql error"
Local Char DATABASE_TYPE(1)
DATABASE_TYPE=num$(1+2*fmet GACTX.APARAM.AGETVALNUM([V]CST_ALEVFOLD,"","TYPDBA"))
Execsql From DATABASE_TYPE  Sql "drop table ZAAAMYTABLE"
Return

$ANASQL_
# Anasql
MESSAGE="Anasql"
Local Char DATABASE_TYPE(1)
Local Integer RESULTS(0..)
DATABASE_TYPE=num$(1+2*fmet GACTX.APARAM.AGETVALNUM([V]CST_ALEVFOLD,"","TYPDBA"))

Execsql From DATABASE_TYPE  Sql "create table ZAAAMYTABLE (t integer, t1 varchar(50) )"

Anasql From DATABASE_TYPE Sql "select * From ZAAAMYTABLE" Using RESULTS

Call CHECK_EQUAL(MESSAGE-"results (0)",[L]RESULTS(0),2) # number of columns returned
Call CHECK_EQUAL(MESSAGE-"results (1)",[L]RESULTS(1),7) # decimal
If pat(ver$(0),"etna*")<=0
 Call CHECK_EQUAL(MESSAGE-"results (2)",[L]RESULTS(2),210)
Else
 Call CHECK_EQUAL(MESSAGE-"results (2)",[L]RESULTS(2),60)
Endif
Execsql From DATABASE_TYPE  Sql "drop table ZAAAMYTABLE"
Return

###############################################################################################
$INTERNAL_ADXMTO
MESSAGE="Internal"
Call CHECK_NOTEQUAL(MESSAGE-"adxmto max tables opened", [S]adxmto,0)
Return

$INTERNAL_FILEABRE
MESSAGE="Internal"
Local File AQCREQ3 [AQCREQ3]
Local File AQCREQ5 [AQCREQ5]
Local Integer I
I=find("AQCREQ5",[S]fileabre(1..))
Call CHECK_EQUAL(MESSAGE-"file abbreviation", [S]fileabre(I),"AQCREQ5")
LogicClose File [AQCREQ3],[AQCREQ5]
Return

$INTERNAL_FILENAME
MESSAGE="Internal"
Local File AQCREQ3 [AQCREQ3]
Local File AQCREQ5 [AQCREQ5]
Local Integer I
For I=1 To [S]adxmto
  If instr(1,[S]filename(I),"AQCREQ5")
    Break
  Endif
Next
Call CHECK_NOTEQUAL(MESSAGE-"filename-AQCREQ5", I, 0)
LogicClose File [AQCREQ3],[AQCREQ5]
Return

$INTERNAL_SADMEM
MESSAGE="Internal"
Call CHECK_NOTEQUAL(MESSAGE-"sadmem", [S]sadmem,0)
Return

$INTERNAL_DBGSTR
MESSAGE="Internal"
Local Char SAV_DBGSTR(50)
Local File AQCREQ3 [AQCREQ3], AQCREQ5 [AQCREQ5]
SAV_DBGSTR=[S]dbgstr(2)
Call CHECK_EQUAL(MESSAGE-"DBGSTR(2)", SAV_DBGSTR," [AQCREQ3],[AQCREQ5]")
SAV_DBGSTR=[S]dbgstr(0)
Call CHECK_EQUAL(MESSAGE-"DBGSTR(0)", SAV_DBGSTR," [L],[S],[V],[M],[F]")
LogicClose File [AQCREQ3],[AQCREQ5]
Return

#####################################################################################
$TRANSACTION_
MESSAGE="Transaction"
Local File AQCREQ3 [AQCREQ3], AQCREQ5 [AQCREQ5]
Call CHECK_EQUAL(MESSAGE-"Adxlog - no transaction in progress", [S]adxlog, [V]CST_AFALSE)
Trbegin [AQCREQ3], [AQCREQ5]
Call CHECK_EQUAL(MESSAGE-"Adxlog - transaction in progress", [S]adxlog, [V]CST_ATRUE)
Commit
Call CHECK_EQUAL(MESSAGE-"Adxlog - after commit", [S]adxlog, [V]CST_AFALSE)

Trbegin [AQCREQ3], [AQCREQ5]
Call CHECK_EQUAL(MESSAGE-"Adxlog - transaction in progress", [S]adxlog, [V]CST_ATRUE)
Rollback
Call CHECK_EQUAL(MESSAGE-"Adxlog - after rollback", [S]adxlog, [V]CST_AFALSE)
LogicClose File
Return


$TRANSACTION_ERR
MESSAGE="Transaction Commit Error"
Local File AQCREQ3 [AQCREQ3], AQCREQ5 [AQCREQ5]
Call CHECK_EQUAL(MESSAGE-"Adxlog - no transaction in progress", [S]adxlog, [V]CST_AFALSE)
Trbegin [AQCREQ3], [AQCREQ5]
Call CHECK_EQUAL(MESSAGE-"Adxlog - transaction in progress", [S]adxlog, [V]CST_ATRUE)
Call TRANSACTION_SUB
Rollback
Call CHECK_EQUAL(MESSAGE-"Adxlog in main- after failed commit", [S]adxlog, [V]CST_AFALSE)
LogicClose File
Return

Subprog TRANSACTION_SUB
Local Char MESSAGE(250)
Local Integer EX : EX=32
Onerrgo ERROR
Commit
Onerrgo
Call CHECK_EQUAL(MESSAGE-"Adxlog - after commit", [S]adxlog, [V]CST_ATRUE)
End

###########################################################################################################
#**
#* CHECK_EQUAL - Add message to log file
#*
#* @param MESSAGE - Text - 250 characters max
#* @param GOT     - Value actually received
#* @param EXPECTED- Expected value
#*!
Subprog CHECK_EQUAL(MESSAGE,GOT,EXPECTED)
Value Char MESSAGE

If MESSAGE<>""
  Call CHECK_EQUAL(MESSAGE,MESSAGE) From AXUNIT
  # Decrement counts to manage messages
  #GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 1) -= 1
  #GXUNIT_TESTID -= 1
  #GXUNIT_CASE_SUCCESS -= 1
  #GXUNIT_SUCCESS -= 1
Endif

Call CHECK_EQUAL(GOT,EXPECTED) From AXUNIT
End

#**
#* CHECK_NOTEQUAL - Add message to log file
#*
#* @param MESSAGE - Text - 250 characters max
#* @param GOT     - Value actually received
#* @param EXPECTED- Expected value
#*!
Subprog CHECK_NOTEQUAL(MESSAGE,GOT,EXPECTED)
Value Char MESSAGE

If MESSAGE<>""
  Call CHECK_EQUAL(MESSAGE,MESSAGE) From AXUNIT
  #GXUNIT_CASE_ASSERT_COUNT(GXUNIT_CURRENT_CASE, 1) -= 1
  #GXUNIT_TESTID -= 1
  #GXUNIT_CASE_SUCCESS -= 1
  #GXUNIT_SUCCESS -= 1
Endif

Call CHECK_NOTEQUAL(GOT,EXPECTED) From AXUNIT
End

