#<AdxTL>@(#)0.0.0.0 $Revision$

Call OUVRE_TRACE("QLFAR_TSTRING") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC

GTRACE = "QLFAR_TSTRING_"+GUSER
Call LEC_TRACE From LECFIC
End

#########################
$ERROR
Call CHECK_EQUAL(errn, EX)
EX = 0
Resume

Subprog CHECK_EQUAL(GOT, EXPECT)
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

Funprog TESTSUITE_()
Call SET_LOCALE("fr-FR") From ASYRQLF
Call TESTSUITE_START("TSTRING", "TSTRING") From AXUNIT
EX=0
Onerrgo ERROR

Local Clbfile  SUITE_RESULT

SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("TSTRING", "TSTRING")
End SUITE_RESULT
#########################

Funprog TESTSUITE()
Call SET_LOCALE("fr-FR") From ASYRQLF

Call TESTSUITE_START("TSTRING", "TSTRING") From AXUNIT
EX=0
Onerrgo ERROR 

##
Local Integer NBTEST
NBTEST = 45
Call ADD_TESTCASE("BASIC","Test sting basic",NBTEST) From AXUNIT
##
 
Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("TSTRING", "TSTRING")
End SUITE_RESULT
#################################################################

Subprog BASIC
Local Char A(20)
A="ABCD"

Local Char B(20)
B="EFGH"
Call TRACE("test"+num$(evalue("(A=A)"))) From ASYRCOM
Call CHECK_EQUAL(A="ABCD",1)
Call CHECK_EQUAL(val("2"),2)
Call CHECK_EQUAL((A>"A"), 1)
Call CHECK_EQUAL((A>="A"), 1)
Call CHECK_EQUAL((B="EFGH"), 1)
Call CHECK_EQUAL((B<"Z"), 1)
Call CHECK_EQUAL((B<="Z"), 1)
Call CHECK_EQUAL(A+B,"ABCDEFGH")
Call CHECK_EQUAL(A-B,"ABCD EFGH")
Call CHECK_EQUAL(min("B","C","A"),"A")
Call CHECK_EQUAL(max("B","C","A"),"C")
Call CHECK_EQUAL(ascii("A"),65)
Call CHECK_EQUAL(parse("date$",0),0)
Call CHECK_EQUAL(parse("date&&",0),5)
Call CHECK_EQUAL(pat("     X3   ", "*X3*"),1)
Call CHECK_EQUAL(pat("     X3   ", "*X13*"),0)
Call CHECK_EQUAL(pat("Avvv1", "!???#"),1)
Call CHECK_EQUAL(pat("Avv1", "!???#"),0)
Call CHECK_EQUAL(val("10"),10)
Call CHECK_EQUAL(val("10.10"),10.10)
Call CHECK_EQUAL(left$("ZERTY",1),"Z")
Call CHECK_EQUAL(mid$("ZERTY",2,3),"ERT")
Call CHECK_EQUAL(right$("ZERTY",1),"ZERTY")
Call CHECK_EQUAL(seg$("ZERTY",1,2),"ZE")
Call CHECK_EQUAL(ctrans("Suppression des caractères : à è î ô ù ..."),"Suppression des caracteres : a e i o u ...")
Call CHECK_EQUAL(tolower("ZERTY"),"zerty")
Call CHECK_EQUAL(toupper("zerty"),"ZERTY")
Call CHECK_EQUAL(vireblc("  zerty  ",2),"zerty")
Call CHECK_EQUAL(chr$(9),chr$(9) )
Call CHECK_EQUAL(num$("123"),"123")
Call CHECK_EQUAL(instr(1,"ABCD","B"),2 )
Call CHECK_EQUAL(chr$(9),chr$(9))
Call CHECK_EQUAL(dim(A),1)
Local Char D(10)(0..10)
Call CHECK_EQUAL(dim(D),11)
Local Char D(10)(1..10)
Call CHECK_EQUAL(dim(D),10)
Local Char R(3)
R="ABCD"
Call CHECK_EQUAL(R="ABC",1)
Local Char RR
RR="ABCD"
Call CHECK_EQUAL(RR="ABCD",1)
Call CHECK_EQUAL(dim(RR)=1,1)
Local Date D
Call CHECK_EQUAL(RR+D,"ABCD00000000")
Call CHECK_EQUAL(RR+num$(D),"ABCD00/00/0000")
Local Decimal E : E=1.1234
Local Char F(10)
F = num$(E)
Call CHECK_EQUAL(F,num$(E))
Local ClbFile CBB(1)
CBB = "dd"
Call CHECK_EQUAL(CBB = "dd",1)
Append CBB, "d"
Call CHECK_EQUAL(CBB = "ddd",1)
Local Schar SC(8)
SC = "AAA"
Call CHECK_EQUAL(SC = "AAA",1)
#dbgetna( 5000 ) 
#Call CHECK_EQUAL(type(RR),-1)
#Call CHECK_EQUAL(type(SC),-1)
Call CHECK_EQUAL(val(D),"00000000")
End
