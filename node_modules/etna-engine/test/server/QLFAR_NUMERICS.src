#<AdxTL>@(#)2.0.0.0 $Revision$
Call OUVRE_TRACE("QLFAR_NUMERICS") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_NUMERICS_"+GUSER
Call LEC_TRACE From LECFIC
End

Funprog TESTSUITE()
Callmet GACTX.ACTX_SET_LANISO("fr-FR")

Call TESTSUITE_START("NUMERICS", "NUMERICS") From AXUNIT


Call ADD_TESTCASE("TC_DOUBLE","TC_DOUBLE"-"Operations on Double", 38) From AXUNIT
Call ADD_TESTCASE("TC_NUMBERS","TC_NUMBERS"-"Operations on numbers", 81) From AXUNIT
Call ADD_TESTCASE("TC_ADD","TC_ADD"-"Addition Operation on numbers", 10) From AXUNIT


Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("FUNCTIONS", "FUNCTIONS")
End SUITE_RESULT


$ERROR
Call CHECK_EQUAL(errn, EX)
EX = 0
Resume

Subprog CHECK_EQUAL(GOT, EXPECT)
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

Subprog CHECK_EQUAL_LIB(OPERATION, RESULT, COMMENTS)
Call CHECK_EQUAL(COMMENTS-'->'-num$(OPERATION), COMMENTS-'->'-num$(RESULT)) From AXUNIT
End


Subprog TC_DOUBLE
Call CHECK_EQUAL(abs(sqr(9)), 3)
Call CHECK_EQUAL(mod(sqr(25),2), 1)
Call CHECK_EQUAL(sqr(9), 3)
Call CHECK_EQUAL(rnd(100) < 100, 1)
Call CHECK_EQUAL(arr((1/3)+(1/3)+(1/3),0.000001),1 )
Call CHECK_EQUAL(10^log(10^3), 10^3)
[S]adxmda = 1
Call CHECK_EQUAL(cos(pi/4) = sqr(2)/2, 1)
Local Decimal DIV : DIV=pi/4
Call CHECK_EQUAL(cos(DIV) , sqr(2)/2)
Call CHECK_EQUAL(cos(DIV) + sqr(2)/2 , cos(DIV)*2)
Call CHECK_EQUAL(cos(DIV) - sqr(2)/2 , 0)

Call CHECK_EQUAL(cos(DIV) - sqr(2)/2 , val("0"))

Call CHECK_EQUAL(rnd(100) < 100, 1)
Call CHECK_EQUAL(rnd(100.3) < 100.3, 1)
Call CHECK_EQUAL(ar2(-3.528), -3.53)
Call CHECK_EQUAL(ar2(-3.531), -3.53)
Call CHECK_EQUAL(fix(3.2), 3)

Local Integer NUM(1..10)
For I=1 To 10 
NUM(I) = I 
Next I
Call CHECK_EQUAL(sum(NUM),55)

Call CHECK_EQUAL(mod(2.5,4/2), 0.5)
Call CHECK_EQUAL(mod(2.5,4/2)*2, 1)
Call CHECK_EQUAL(mod(2.5,2)^2, 0.25)
Call CHECK_EQUAL(mod(2.5,2)*2, 1)

Local Integer I,J : I=1

J=3
Call CHECK_EQUAL(mod(2.5,2)*2 xor J = 2, 1)
Call CHECK_EQUAL(mod(sqr(25),2) xor J = 2, 1)
J=2
Call CHECK_EQUAL(I = 1 xor J = 2, 0)
Call CHECK_EQUAL(mod(sqr(25),2) xor J = 2, 0)

J=3
Call CHECK_EQUAL(mod(2.5,2)*2 ? J = 2, 1)
Call CHECK_EQUAL(mod(sqr(25),2) ? J = 2, 1)
J=2
Call CHECK_EQUAL(I = 1 ? J = 2, 0)
Call CHECK_EQUAL(mod(sqr(25),2) ? J = 2, 0)



J=2
Call CHECK_EQUAL(-1 xor J = 2, 0)
Call CHECK_EQUAL(mod(sqr(25)*-1,2) , -1)
Call CHECK_EQUAL(mod(sqr(25)*-1,2) xor J = 2, 0)
J=3
Call CHECK_EQUAL(-1 xor J = 2, 1)
Call CHECK_EQUAL(mod(sqr(25)*-1,2) , -1)
Call CHECK_EQUAL(mod(sqr(25)*-1,2) xor J = 2, 1)

Onerrgo ERROR
EX=10
Call CHECK_EQUAL(val(mod(2.5,2)*2), 1)

Onerrgo 
EX=0
Call CHECK_EQUAL(num$(-mod(2.5,2)*2), "-1")

Call CHECK_EQUAL(val(num$(-mod(2.5,2)*2)), -1)

End

Subprog TC_NUMBERS
Integer EX
Local Integer CMP
Onerrgo ERROR
#Basic :
Call CHECK_EQUAL(1+1, 2)
Call CHECK_EQUAL(1-1 , 0)
Call CHECK_EQUAL(1*1, 1)
Call CHECK_EQUAL(1/1 , 1)
Call CHECK_EQUAL(1>=1 , 1)
Call CHECK_EQUAL(1>1 , 0)
Call CHECK_EQUAL(1<1 , 0)
Call CHECK_EQUAL(1<=1 , 1)

#9
Call CHECK_EQUAL(arr((1/3)+(1/3)+(1/3),0.000001),1 )

Call CHECK_EQUAL(arr(3*(1/3),0.000001),1 )
Call CHECK_EQUAL(1/3-1/3 , 0)

#12
Call CHECK_EQUAL(log(10^3), 3)
Call CHECK_EQUAL(3*log(10^3), 9)

Call CHECK_EQUAL(10^log(10^3), 10^3)
Call CHECK_EQUAL(log(10^3) >=3, 1)
Call CHECK_EQUAL(log(10^3) > 3 , 0)
Call CHECK_EQUAL(log(10^3) <=3, 1)
Call CHECK_EQUAL(log(10^3) < 3 , 0)

Call CHECK_EQUAL(sqr(2^2) , 2)
Call CHECK_EQUAL(sqr(3^2) , 3)
Call CHECK_EQUAL(sqr(4^2) , 4)
Call CHECK_EQUAL(sqr(5^2) , 5)
Call CHECK_EQUAL(sqr(6^2) , 6)

#24
Call CHECK_EQUAL(ln(exp(2)) , 2)
Call CHECK_EQUAL(ln(exp(3)) , 3)
Call CHECK_EQUAL(ln(exp(4)) , 4)
Call CHECK_EQUAL(ln(exp(5)) , 5)
Call CHECK_EQUAL(ln(exp(6)) , 6)


[S]adxmda = 1
#29
Call CHECK_EQUAL(cos(pi/4) = sqr(2)/2, 1)
Call CHECK_EQUAL(sin(pi/4) = sqr(2)/2, 1)
Call CHECK_EQUAL(cos(pi/4)+sin(pi/4) = sqr(2) , 1)
Call CHECK_EQUAL(cos(pi/4)^2+sin(pi/4)^2 = 1, 1)
Call CHECK_EQUAL(cos(pi/2)+sin(pi/2) = 1 , 1)
Call CHECK_EQUAL(cos(pi/2)^2+sin(pi/2)^2 = 1, 1)
Call CHECK_EQUAL(cos(pi)+sin(pi) = -1 , 1)
Call CHECK_EQUAL(cos(pi)^2+sin(pi)^2 = 1, 1)


Local Integer I,A,B,C
A=4
B=3
C=A/B
Call CHECK_EQUAL(C, 1)
A=2
B=3
C=A/B
Call CHECK_EQUAL(C, 0)
Local Decimal D
A=2
B=3
D = A/B
Call CHECK_EQUAL(D, 2/3)
C =2*D
Call CHECK_EQUAL(C, 1)

Call CHECK_EQUAL(abs(5), 5)
Call CHECK_EQUAL(abs(-5), 5)
Call CHECK_EQUAL(abs(5.3), 5.3)
Call CHECK_EQUAL(abs(-5.3), 5.3)
Call CHECK_EQUAL(abs(sqr(5)), sqr(5))
Call CHECK_EQUAL(abs(-sqr(5)), sqr(5))

Call CHECK_EQUAL(mod(5,3), 2)
Call CHECK_EQUAL(mod(5.2,3), 2.2)
Call CHECK_EQUAL(mod(5,3.2), 1.8)
Call CHECK_EQUAL(mod(5.3,2.2), 0.9)

Call CHECK_EQUAL(mod(5/2,2), 0.5)
Call CHECK_EQUAL(mod(5/2,4/2), 0.5)

Call CHECK_EQUAL(mod(7/2,3/2), 0.5)

Call CHECK_EQUAL(mod(7,5/2), 2)

#55
Call CHECK_EQUAL(rnd(100) < 100, 1)
Call CHECK_EQUAL(rnd(100.3) < 100.3, 1)

Call CHECK_EQUAL(sgn(0), 0)
Call CHECK_EQUAL(sgn(-1), -1)
Call CHECK_EQUAL(sgn(1), 1)
Call CHECK_EQUAL(sgn(1.3), 1)
Call CHECK_EQUAL(sgn(-1.3), -1)
Call CHECK_EQUAL(sgn(cos(pi/4)), 1)
Call CHECK_EQUAL(sgn(-cos(pi/4)), -1)

Call CHECK_EQUAL(ar2(3), 3)
Call CHECK_EQUAL(ar2(3.2), 3.2)
Call CHECK_EQUAL(ar2(3.9), 3.9)
Call CHECK_EQUAL(ar2(3.92), 3.92)
Call CHECK_EQUAL(ar2(3.923), 3.92)
Call CHECK_EQUAL(ar2(3.528), 3.53)
#70
Call CHECK_EQUAL(ar2(-3.528), -3.53)
Call CHECK_EQUAL(ar2(-3.531), -3.53)

Call CHECK_EQUAL(fix(3), 3)
Call CHECK_EQUAL(fix(3.2), 3)
Call CHECK_EQUAL(fix(3.9), 3)
Call CHECK_EQUAL(fix(3.92), 3)
Call CHECK_EQUAL(fix(-3.528), -3)
Call CHECK_EQUAL(fix(-3.22), -3)

#78
Local Integer NUM(1..10)
For I=1 To 10 : NUM(I) = I : Next I
Call CHECK_EQUAL(sum(NUM),55)

Call CHECK_EQUAL(sum(NUM(2..4)),9)
For I=1 To 10 : NUM(I) = -I : Next I
Call CHECK_EQUAL(sum(NUM),-55)
Call CHECK_EQUAL(sum(NUM(2..4)),-9)

End

Subprog TC_ADD( )
Local Integer IA, IB, IR
Local Decimal DA, DB, DR
Local Date    TA, TB, TR
Local Char    SA(20), SB(20), SR(20)


IA = 53336
IB = 63125
IR = IA+IB

DA = 53336
DB = 63125
DR = IA+IB

Call CHECK_EQUAL(IA+IB, 116461)
Call CHECK_EQUAL(IR, 116461)

Call CHECK_EQUAL(DA+DB, 116461)
Call CHECK_EQUAL(DR, 116461)

DA = 53336.325
DB = 63125.6444
DR = DA+DB
Call CHECK_EQUAL(DA+DB, 116461.9694)
Call CHECK_EQUAL(DR, 116461.9694)

DA = 53336.325
DR = DA+IA
Call CHECK_EQUAL(DR, 106672.325)
Call CHECK_EQUAL(DA+IA, 106672.325)

DR = IA+DA
Call CHECK_EQUAL(DR, 106672.325)
Call CHECK_EQUAL(IA+DA, 106672.325)


End

$ERR
ERN = errn
Resume
