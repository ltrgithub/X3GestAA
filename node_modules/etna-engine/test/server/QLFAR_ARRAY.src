Call OUVRE_TRACE("QLFAR_ARRAY") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_ARRAY_"+GUSER
Call LEC_TRACE From LECFIC

End

Funprog TESTSUITE()
Local Integer NBTEST
NBTEST=54
If pat(ver$(0),"etna*")>0
 NBTEST+=42
Endif
Call ADD_TESTCASE("SIMPLE_TEST", "simple test", NBTEST) From AXUNIT

NBTEST=102
Call ADD_TESTCASE("SORT_TEST", "sort test", NBTEST) From AXUNIT

NBTEST=20
Call ADD_TESTCASE("INSERT_TEST", "insert test", NBTEST) From AXUNIT
Call ADD_TESTCASE("DELETE_TEST", "delete test", NBTEST) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("ARRAY", "ARRAY")
End SUITE_RESULT


Subprog CHECK_EQUAL(GOT, EXPECT,TEXT)
Call CHECK_EQUAL(TEXT+"...", TEXT+"...") From AXUNIT
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume


$FILL
Global Char STRINGS(1)(10)
Global Integer INTS(10)
Global Char LETTERS, DIGITS, LSORT, LSORTS, DSORT, LBYD, DBYL, DBYL2,DBYL22,LSORTPART,ISORTPART
LETTERS = "DAAFBCBBAF"
DIGITS =  "5531244153"

LSORT =   "AAABBBCDFF"
LSORTD =  "FFDCBBBAAA"
DSORT =   "1123344555"
LBYD  =   "BFBAFBCAAD"
DBYL  =   "3551244513"
DBYL2 =   "3154142553"
DBYL22 =  "3154412355"
LSORTPART = "DAABBCFBAF"
ISORTPART = "5532441153"

For I = 0 To 9 : STRINGS(I) = mid$(LETTERS, I+1, 1) : INTS(I) = val(mid$(DIGITS, I+1, 1)) : Next I
Return

Funprog DUMP_S(AR,DIME_1,DIME)
 Variable Char AR()()
 Value Integer DIME_1,DIME
 Call CHECK_EQUAL("BEGIN DUMP_S", "BEGIN DUMP_S") From AXUNIT
 Call CHECK_EQUAL(dim(AR,-1), DIME_1) From AXUNIT
 Call CHECK_EQUAL(dim(AR,1), DIME) From AXUNIT
End sigma(dim(AR,-1), dim(AR,-1) + dim(AR,1) - 1, AR(indcum))

Funprog DUMP_I(AR,DIME_1,DIME)
 Variable Integer AR()
 Value Integer DIME_1,DIME
 Call CHECK_EQUAL("BEGIN DUMP_I", "BEGIN DUMP_I") From AXUNIT
 Call CHECK_EQUAL(dim(AR,-1), DIME_1) From AXUNIT
 Call CHECK_EQUAL(dim(AR,1), DIME) From AXUNIT
End sigma(dim(AR,-1), dim(AR,-1) + dim(AR,1) - 1, num$(AR(indcum)))

Subprog SORTA_PART(S1, I1)
 Variable Char S1()()
 Variable Integer I1()
    Call CHECK_EQUAL("BEGIN SORTA_PART", "BEGIN SORTA_PART") From AXUNIT
    Sorta S1,I1
    Call CHECK_EQUAL(func DUMP_S(S1,0,5), mid$(LSORTPART,3,5), "Sorta partial S in function")
    Call CHECK_EQUAL(func DUMP_I(I1,0,5), mid$(ISORTPART,3,5), "Sorta partial I in function")
    Call CHECK_EQUAL("END SORTA_PART", "END SORTA_PART") From AXUNIT
End

Subprog SLICE_NOBASE(S1, S2, I1, I2)
 Variable Char S1()(), S2()()
 Variable Integer I1(), I2()
    Call CHECK_EQUAL("BEGIN SLICE_NOBASE", "BEGIN SLICE_NOBASE") From AXUNIT
    Call CHECK_EQUAL(func DUMP_S(S1,0,3), mid$(LETTERS, 4, 3)) From AXUNIT :# "Char slice 3..5 -> 0..") From AXUNIT
    Call CHECK_EQUAL(func DUMP_S(S2,0,7), right$(LETTERS, 4)) From AXUNIT :# "Char slice 3..9 -> 0..") From AXUNIT
    Call CHECK_EQUAL(func DUMP_I(I1,0,3), mid$(DIGITS, 4, 3)) From AXUNIT :# "Integer slice 3..5 -> 0..") From AXUNIT
    Call CHECK_EQUAL(func DUMP_I(I2,0,7), right$(DIGITS, 4)) From AXUNIT :# "Integer slice 3..9 -> 0..") From AXUNIT
    Call CHECK_EQUAL("END SLICE_NOBASE", "END SLICE_NOBASE") From AXUNIT
End

Subprog SLICE_BASE(S1, S2)
 Variable Char S1()(1..), S2()(3..)
    Call CHECK_EQUAL("BEGIN SLICE_BASE", "BEGIN SLICE_BASE") From AXUNIT
    Local Integer EX : EX=69
    Onerrgo ERROR
    Call CHECK_EQUAL(func DUMP_S(S1,0,3), mid$(LETTERS, 4, 3), "Char slice 3..5 -> 1..") From AXUNIT
    Onerrgo
    Local Integer EX : EX=69
    Onerrgo ERROR
    Call CHECK_EQUAL(func DUMP_S(S2,0,7), right$(LETTERS, 4), "Char slice 3..9 -> 3..") From AXUNIT
    Onerrgo

    Call CHECK_EQUAL(func DUMP_S(S1,0,3), mid$(LETTERS, 4, 3)) From AXUNIT :# "Char slice 3..5 -> 1..") From AXUNIT
    Call CHECK_EQUAL(func DUMP_S(S2,0,7), right$(LETTERS, 4)) From AXUNIT :# "Char slice 3..9 -> 3..") From AXUNIT
    Call CHECK_EQUAL(S1(1), mid$(LETTERS, 4, 1), "S1(1) -> F")
    Call CHECK_EQUAL(S1(3), mid$(LETTERS, 6, 1), "S1(3) -> C")
    Call CHECK_EQUAL(S2(3), mid$(LETTERS, 4, 1), "S2(3) -> F")
    Call CHECK_EQUAL(S2(9), mid$(LETTERS, 10, 1), "S2(9) -> F")
    Call CHECK_EQUAL("END SLICE_BASE", "END SLICE_BASE") From AXUNIT
End

Subprog SORT_BASE(S, I)
 Variable Char S()(4..)
 Variable Integer I(2..)
 Call CHECK_EQUAL("BEGIN SORT_BASE", "BEGIN SORT_BASE") From AXUNIT
 Call CHECK_EQUAL(S(4), 'D', "S(4) indexing")
 Call CHECK_EQUAL(S(13), 'F', "S(13) indexing")
 Call CHECK_EQUAL(I(2), 5, "I(2) indexing")
 Call CHECK_EQUAL(I(11), 3, "I(11) indexing")
    Sorta S,I
    #Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORT, "Sorta S,D")
    #Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DBYL, "Sorta S,D")
    Call CHECK_EQUAL(func DUMP_S(S,0,10), LSORT, "Sorta S,D")
    Call CHECK_EQUAL(func DUMP_I(I,0,10), DBYL, "Sorta S,D")
 Call CHECK_EQUAL(S(4), 'A', "S indexing")
 Call CHECK_EQUAL(S(13), 'F', "S indexing")
 Call CHECK_EQUAL(I(2), 3, "I indexing")
 Call CHECK_EQUAL(I(11), 3, "I indexing")
    Sorta I,S
 Call CHECK_EQUAL(I(2), 1, "I indexing")
 Call CHECK_EQUAL(I(11), 5, "I indexing")
 Call CHECK_EQUAL("END SORT_BASE", "END SORT_BASE") From AXUNIT
End

Subprog SIMPLE_TEST()
    Gosub FILL
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LETTERS) From AXUNIT

    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DIGITS) From AXUNIT

    Local Integer EX : EX=8
    Onerrgo ERROR
    Call SLICE_NOBASE(STRINGS(3..5), STRINGS(3..), INTS(3..5), INTS(3..))
    Onerrgo

    Call SLICE_NOBASE(STRINGS(3..5), STRINGS(3..9), INTS(3..5), INTS(3..9))

    Local Integer EX : EX=8
    Onerrgo ERROR
    Call SLICE_BASE(STRINGS(3..5), STRINGS(3..))
    Onerrgo

    Call SLICE_BASE(STRINGS(3..5), STRINGS(3..9))

End

Subprog SORT_TEST()
    Gosub FILL
    Sorta STRINGS,INTS
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORT, "Sorta S,D")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DBYL, "Sorta S,D")
    Sorta STRINGS, INTS Order By STRINGS(indice) Desc
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORTD, "Sorta S,D Order By S(indice) Desc")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), func DUMP_I(INTS,0,10) , "Sorta S,D Order By S(indice) Desc")
    Call CHECK_EQUAL(find(func DUMP_I(INTS,0,10),DBYL2,DBYL22)>0, 1 , "Res -> (3154142553 or 3154412355)")
    Sorta INTS,STRINGS
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DSORT, "Sorta D,S")
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LBYD, "Sorta D,S")
    Gosub FILL
    Call SORT_BASE(STRINGS, INTS)
    Gosub FILL
    Sorta STRINGS(2..6),INTS(2..6)
    If pat(ver$(0),"etna*")>0
     Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORTPART, "ETNA: Sorta partial S works in sorta")
     Call CHECK_EQUAL(func DUMP_I(INTS,0,10), ISORTPART, "ETNA: Sorta partial D works in sorta")
    Else
     Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORT, "Sorta partial S doesn't work in sorta")
     Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DBYL, "Sorta partial S doesn't work in sorta")
    Endif
    Gosub FILL
    Call SORTA_PART(STRINGS(2..6),INTS(2..6)) : #Sorta partial works through function
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORTPART, "Sorta partial S works through function")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), ISORTPART, "Sorta partial D works through function")
End

Subprog INSERT_TEST()
 Gosub FILL
 Insa 2, 3 STRINGS, INTS
 STRINGS(2) = 'X' : STRINGS(3) = 'Y' : STRINGS(4) = 'Z'
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+"XYZ"+mid$(LETTERS, 3, 5), "Insa 2, 3 S")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), left$(DIGITS, 2)+"000"+mid$(DIGITS, 3, 5), "Insa 2, 3 I")
 Gosub FILL
 Insa 2, 3, 7 STRINGS, INTS
 STRINGS(2) = 'X' : STRINGS(3) = 'Y' : STRINGS(4) = 'Z'
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+"XYZ"+mid$(LETTERS, 3, 3) +right$(LETTERS, 9), "Insa 2, 3, 7 S")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), left$(DIGITS, 2)+"000"+mid$(DIGITS, 3, 3) + right$(DIGITS, 9), "Insa 2, 3, 7 I")
End

Subprog DELETE_TEST()
 Gosub FILL
 Dela 2, 3 STRINGS, INTS
 STRINGS(7) = 'X' : STRINGS(8) = 'Y' : STRINGS(9) = 'Z'
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+right$(LETTERS, 6)+"XYZ", "Dela 2, 3 S")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), left$(DIGITS, 2)+right$(DIGITS, 6)+"000", "Dela 2, 3 I")
 Gosub FILL
 Dela 2, 3, 7 STRINGS, INTS
 STRINGS(5) = 'X' : STRINGS(6) = 'Y' : STRINGS(7) = 'Z'
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+mid$(LETTERS, 6, 3)+"XYZ"+right$(LETTERS, 9), "Dela 2, 3, 7 S")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), left$(DIGITS, 2)+mid$(DIGITS, 6, 3)+"000"+right$(DIGITS, 9), "Dela 2, 3, 7 I")
End
