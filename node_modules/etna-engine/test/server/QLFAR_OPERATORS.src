Call OUVRE_TRACE("QLFAR_OPERATORS") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_OPERATORS_"+GACTX.USER
Call LEC_TRACE From LECFIC
End

Funprog TESTSUITE()
Callmet GACTX.ACTX_SET_LANISO("fr-FR")

Call TESTSUITE_START("OPERATORS", "OPERATORS") From AXUNIT
Call ADD_TESTCASE("TC_CDECL","Variables declaration", 12) From AXUNIT
Call ADD_TESTCASE("TC_NUMBERS","Operations on numbers", 81) From AXUNIT
Call ADD_TESTCASE("TC_ADD","Addition Operation on numbers", 30) From AXUNIT
Call ADD_TESTCASE("TC_NOT","Not Operator (!)", 5) From AXUNIT
Call ADD_TESTCASE("TC_DIV","Division Operation on numbers", 27) From AXUNIT
Call ADD_TESTCASE("TC_SUB","Substract Operation on numbers", 7) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("FUNCTIONS", "FUNCTIONS")
End SUITE_RESULT


$ERROR
Call CHECK_EQUAL(errn, EX)
EX = 0
Resume

Subprog CHECK_EQUAL(GOT, EXPECT)
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

Subprog CHECK_EQUAL_LIB(OPERATION, RESULT, COMMENTS)
Call CHECK_EQUAL(COMMENTS-'->'-num$(OPERATION), COMMENTS-'->'-num$(RESULT)) From AXUNIT
End

Subprog TC_CDECL_1(A)
Value Integer A
A = 2
Call CHECK_EQUAL(A, 2)
End

Subprog TC_CDECL_2(A)
Variable Integer A
A = 2
Call CHECK_EQUAL(A, 2)
End

Subprog TC_CDECL
Integer EX
Onerrgo ERROR

Local Integer A
A=1
Call CHECK_EQUAL(A, 1)
Call TC_CDECL_1(A)
Call CHECK_EQUAL(A, 1)
Call TC_CDECL_2(A)
Call CHECK_EQUAL(A, 2)

A=1.23456789
Call CHECK_EQUAL(A, 1)

A= -(2^31-1)
Call CHECK_EQUAL(A, -(2^31-1))
A= 2^31-1
Call CHECK_EQUAL(A, 2^31-1)
#Set A with a value out of limits:
EX = 50 :# expected error
A= -(2^31)
EX = 50 :# expected error
A= 2^31

Local Decimal B
B=1
Call CHECK_EQUAL(B, 1)
B=1.23456789
Call CHECK_EQUAL(B, 1.23456789)

End

Subprog TC_NUMBERS
Integer EX
Local Integer CMP
Onerrgo ERROR
#Basic :
Call CHECK_EQUAL(1+1, 2)
Call CHECK_EQUAL(1-1 , 0)
Call CHECK_EQUAL(1*1, 1)
Call CHECK_EQUAL(1/1 , 1)
Call CHECK_EQUAL(1>=1 , 1)
Call CHECK_EQUAL(1>1 , 0)
Call CHECK_EQUAL(1<1 , 0)
Call CHECK_EQUAL(1<=1 , 1)

Call CHECK_EQUAL(arr((1/3)+(1/3)+(1/3),0.000001),1 )

Call CHECK_EQUAL(arr(3*(1/3),0.000001),1 )
Call CHECK_EQUAL(1/3-1/3 , 0)

Call CHECK_EQUAL(log(10^3), 3)
Call CHECK_EQUAL(3*log(10^3), 9)
Call CHECK_EQUAL(10^log(10^3), 10^3)
Call CHECK_EQUAL(log(10^3) >=3, 1)
Call CHECK_EQUAL(log(10^3) > 3 , 0)
Call CHECK_EQUAL(log(10^3) <=3, 1)
Call CHECK_EQUAL(log(10^3) < 3 , 0)

Call CHECK_EQUAL(sqr(2^2) , 2)
Call CHECK_EQUAL(sqr(3^2) , 3)
Call CHECK_EQUAL(sqr(4^2) , 4)
Call CHECK_EQUAL(sqr(5^2) , 5)
Call CHECK_EQUAL(sqr(6^2) , 6)

Call CHECK_EQUAL(ln(exp(2)) , 2)
Call CHECK_EQUAL(ln(exp(3)) , 3)
Call CHECK_EQUAL(ln(exp(4)) , 4)
Call CHECK_EQUAL(ln(exp(5)) , 5)
Call CHECK_EQUAL(ln(exp(6)) , 6)


[S]adxmda = 1
Call CHECK_EQUAL(cos(pi/4) = sqr(2)/2, 1)
Call CHECK_EQUAL(sin(pi/4) = sqr(2)/2, 1)
Call CHECK_EQUAL(cos(pi/4)+sin(pi/4) = sqr(2) , 1)
Call CHECK_EQUAL(cos(pi/4)^2+sin(pi/4)^2 = 1, 1)
Call CHECK_EQUAL(cos(pi/2)+sin(pi/2) = 1 , 1)
Call CHECK_EQUAL(cos(pi/2)^2+sin(pi/2)^2 = 1, 1)
Call CHECK_EQUAL(cos(pi)+sin(pi) = -1 , 1)
Call CHECK_EQUAL(cos(pi)^2+sin(pi)^2 = 1, 1)


Local Integer I,A,B,C
A=4
B=3
C=A/B
Call CHECK_EQUAL(C, 1)
A=2
B=3
C=A/B
Call CHECK_EQUAL(C, 0)
Local Decimal D
A=2
B=3
D = A/B
Call CHECK_EQUAL(D, 2/3)
C =2*D
Call CHECK_EQUAL(C, 1)

Call CHECK_EQUAL(abs(5), 5)
Call CHECK_EQUAL(abs(-5), 5)
Call CHECK_EQUAL(abs(5.3), 5.3)
Call CHECK_EQUAL(abs(-5.3), 5.3)
Call CHECK_EQUAL(abs(sqr(5)), sqr(5))
Call CHECK_EQUAL(abs(-sqr(5)), sqr(5))

Call CHECK_EQUAL(mod(5,3), 2)
Call CHECK_EQUAL(mod(5.2,3), 2.2)
Call CHECK_EQUAL(mod(5,3.2), 1.8)
Call CHECK_EQUAL(mod(5.3,2.2), 0.9)

Call CHECK_EQUAL(mod(5/2,2), 0.5)
Call CHECK_EQUAL(mod(5/2,4/2), 0.5)

Call CHECK_EQUAL(mod(7/2,3/2), 0.5)

Call CHECK_EQUAL(mod(7,5/2), 2)

Call CHECK_EQUAL(rnd(100) < 100, 1)
Call CHECK_EQUAL(rnd(100.3) < 100.3, 1)

Call CHECK_EQUAL(sgn(0), 0)
Call CHECK_EQUAL(sgn(-1), -1)
Call CHECK_EQUAL(sgn(1), 1)
Call CHECK_EQUAL(sgn(1.3), 1)
Call CHECK_EQUAL(sgn(-1.3), -1)
Call CHECK_EQUAL(sgn(cos(pi/4)), 1)
Call CHECK_EQUAL(sgn(-cos(pi/4)), -1)

Call CHECK_EQUAL(ar2(3), 3)
Call CHECK_EQUAL(ar2(3.2), 3.2)
Call CHECK_EQUAL(ar2(3.9), 3.9)
Call CHECK_EQUAL(ar2(3.92), 3.92)
Call CHECK_EQUAL(ar2(3.923), 3.92)
Call CHECK_EQUAL(ar2(3.528), 3.53)
Call CHECK_EQUAL(ar2(-3.528), -3.53)
Call CHECK_EQUAL(ar2(-3.531), -3.53)

Call CHECK_EQUAL(fix(3), 3)
Call CHECK_EQUAL(fix(3.2), 3)
Call CHECK_EQUAL(fix(3.9), 3)
Call CHECK_EQUAL(fix(3.92), 3)
Call CHECK_EQUAL(fix(-3.528), -3)
Call CHECK_EQUAL(fix(-3.22), -3)

Local Integer NUM(1..10)
For I=1 To 10 : NUM(I) = I : Next I
Call CHECK_EQUAL(sum(NUM),55)
Call CHECK_EQUAL(sum(NUM(2..4)),9)
For I=1 To 10 : NUM(I) = -I : Next I
Call CHECK_EQUAL(sum(NUM),-55)
Call CHECK_EQUAL(sum(NUM(2..4)),-9)

End

Subprog TC_ADD( )
Local Integer IA, IB, IR
Local Decimal DA, DB, DR
Local Date    TA, TB, TR
Local Char    SA(20), SB(20), SR(20)


IA = 53336
IB = 63125
IR = IA+IB

DA = 53336
DB = 63125
DR = IA+IB

Call CHECK_EQUAL(IA+IB, 116461)
Call CHECK_EQUAL(IR, 116461)

Call CHECK_EQUAL(DA+DB, 116461)
Call CHECK_EQUAL(DR, 116461)

DA = 53336.325
DB = 63125.6444
DR = DA+DB
Call CHECK_EQUAL(DA+DB, 116461.9694)
Call CHECK_EQUAL(DR, 116461.9694)

DA = 53336.325
DR = DA+IA
Call CHECK_EQUAL(DR, 106672.325)
Call CHECK_EQUAL(DA+IA, 106672.325)

DR = IA+DA
Call CHECK_EQUAL(DR, 106672.325)
Call CHECK_EQUAL(IA+DA, 106672.325)

IA = 5
TA = [01/08/2014]

TR = TA+IA
Call CHECK_EQUAL(TR, [06/08/2014])
Call CHECK_EQUAL(TA+IA, [06/08/2014])

TR = IA+TA
Call CHECK_EQUAL(TR, [06/08/2014])
Call CHECK_EQUAL(IA+TA, [06/08/2014])

DA = 5
TR = TA+DA
Call CHECK_EQUAL(TR, [06/08/2014])
Call CHECK_EQUAL(TA+DA, [06/08/2014])
TR = DA+TA
Call CHECK_EQUAL(TR, [06/08/2014])
Call CHECK_EQUAL(DA+TA, [06/08/2014])

DA = 5.6
TR = TA+DA
Call CHECK_EQUAL(TR, [06/08/2014])
Call CHECK_EQUAL(TA+DA, [06/08/2014])
TR = DA+TA
Call CHECK_EQUAL(TR, [06/08/2014])
Call CHECK_EQUAL(DA+TA, [06/08/2014])

SA = "STRING1"
SB = "STRING2"

SR = SA+SB
Call CHECK_EQUAL(SR, "STRING1STRING2")
Call CHECK_EQUAL(SA+SB, "STRING1STRING2")
SR = SB+SA
Call CHECK_EQUAL(SR, "STRING2STRING1")
Call CHECK_EQUAL(SB+SA, "STRING2STRING1")

SR = SA+TA
Call CHECK_EQUAL(SR, "STRING120140801")
Call CHECK_EQUAL(SA+TA, "STRING120140801")

SR = TA+SA
Call CHECK_EQUAL(SR, "20140801STRING1")
Call CHECK_EQUAL(TA+SA, "20140801STRING1")

End

Subprog TC_NOT( )
Local Integer A,B
Call CHECK_EQUAL(A, 0)
A = !A
Call CHECK_EQUAL(A, 1)
A = !A
Call CHECK_EQUAL(A, 0)
B = 1
Call CHECK_EQUAL(B, 1)
B = !B
Call CHECK_EQUAL(B, 0)

End

$ERR
ERN = errn
Resume

Subprog TC_DIV
Onerrgo ERR
Local Integer I , ER , ERN
I = 22/7
Call CHECK_EQUAL_LIB(I,3,"Integer divide 22/7")
Call CHECK_EQUAL_LIB(22/7,3.142857142857142857142857142857,"Integer divide 22/7")
ER = 53
ERN = 0
I = 22/0
Call CHECK_EQUAL_LIB(ERN, ER,"Integer Divide 22/0 Erreur number")
I = -22/7
Call CHECK_EQUAL_LIB(I,-3,"Integer divide -22/7")
Call CHECK_EQUAL_LIB(-22/7,-3.142857142857142857142857142857,"Integer divide -22/7")
I = 22/-7  
Call CHECK_EQUAL_LIB(I,-3,"Integer divide 22/-7")
Call CHECK_EQUAL_LIB(22/-7,-3.142857142857142857142857142857,"Integer divide 22/-7")
ER = 50
ERN = 0
I = 2147483648/1
Call CHECK_EQUAL_LIB(ERN,ER,"Integer divide 2147483648/1 Erreur number")
ER = 0
ERN = 0
I = 2147483647/1
Call CHECK_EQUAL_LIB(ERN,ER,"Integer divide 2147483647/1 Erreur number")
ER =  0
ERN = 0
I = -2147483647/1
Call CHECK_EQUAL_LIB(ERN,ER,"Integer divide -2147483647/1 Erreur number")
ER =  50
ERN = 0
I = -2147483648/1
Call CHECK_EQUAL_LIB(ERN,ER,"Integer divide -2147483648/1 Erreur number")

Local Decimal D
D = 22/7
Call CHECK_EQUAL_LIB(D,3.142857142857142857142857142857,"Decimal divide 22/7")
Call CHECK_EQUAL_LIB(22/7,3.142857142857142857142857142857,"Decimal divide 22/7")
ER = 53
ERN = 0
D = 22/0
Call CHECK_EQUAL_LIB(ERN,ER,"Decimal divide 22/0 Erreur number")
D = -22/7
Call CHECK_EQUAL_LIB(D,-3.142857142857142857142857142857,"Decimal divide -22/7")
Call CHECK_EQUAL_LIB(-22/7,-3.142857142857142857142857142857,"Decimal divide -22/7")
D = 22/-7  
Call CHECK_EQUAL_LIB(D,-3.142857142857142857142857142857,"Decimal divide 22/-7")
Call CHECK_EQUAL_LIB(22/-7,-3.142857142857142857142857142857,"Decimal divide 22/-7")
D = 3.1428571428571428571428571428579/1
Call CHECK_EQUAL_LIB(D,3.142857142857142857142857142858,"Decimal divide 3.1428571428571428571428571428579/1")

Local Shortint S
S = 36/3.3
Call CHECK_EQUAL_LIB(S,10,"Shortint divide 36/3.3")
S = 36/-3.3
Call CHECK_EQUAL_LIB(S,-10,"Shortint divide 36/-3.3")
ER = 13
ERN = 0
S = 32768/1
Call CHECK_EQUAL_LIB(ERN,ER,"Shortint divide 32768/1 Erreur number")
ER = 13
ERN = 0
S = -32769/1
Call CHECK_EQUAL_LIB(ERN,ER,"Shortint divide -32769/1 Erreur number")
ER = 0
ERN = 0
S = -32768/1
Call CHECK_EQUAL_LIB(ERN,ER,"Shortint divide -32768/1 Erreur number")

Local TINYINT T
T = 253.5/36.3
Call CHECK_EQUAL_LIB(T,6,"Tinyint divide 253.5/36.3")
ERN = 0
ER = 13
T = 256/1
Call CHECK_EQUAL_LIB(ERN,ER,"Tinyint divide 256/1 Erreur number")
ERN = 0
ER = 13
T = -2/1
Call CHECK_EQUAL_LIB(ERN,ER,"Tinyint divide -2/1 Erreur number")
End

Subprog TC_SUB
Local Integer I
Local Char C1(250) , C2(250)
C1 = "STRING1"
C2 = "STRING2"
Call CHECK_EQUAL_LIB(C1-C2,C1+" "+C2,"Substract string")
C1 = "012345"
C2 = "6789"
Call CHECK_EQUAL_LIB(C1-C2,C1+" "+C2,"Substract string with numbers")
C1 = "STRING1    "
Call CHECK_EQUAL_LIB(C1-C2,vireblc(C1,2)+" "+C2,"Substract string with blank")
C1 = string$(8,"A")
Call CHECK_EQUAL_LIB(C1,"AAAAAAAA","Substract string using string$")
Local Char CT(30)(1..10)
For I=1 To 10 : CT(I) = chr$(64+I) : Next I
C1 = sigma(1,10,string$(indcum>1," ")-CT(indcum)) : # But yes, we can :-) and not affraid
Call CHECK_EQUAL_LIB(C1,"A B C D E F G H I J","Substract string using sigma")

Local Decimal  D
Local TINYINT  T
Local Integer  I
Local Shortint S

D = 3142857142857142857142857142857 
I = 140000
S =   2800
T =     57
D -= I+S+T
Call CHECK_EQUAL_LIB(D,3142857142857142857142857000000,"Substract numbers D-=I+S+T")

D = 3142857142857142857142857142857 
I = 140000
S =   2800
T =     57
D = D-I-S-T
Call CHECK_EQUAL_LIB(D,3142857142857142857142857000000,"Substract numbers D=D-I-S-T")


End
