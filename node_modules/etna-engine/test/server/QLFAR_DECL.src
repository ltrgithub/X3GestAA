#<AdxTL>@(#)5.0.0.0 $Revision$
Call OUVRE_TRACE("QLFAR_DECL") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_DECL_"+GUSER
Call LEC_TRACE From LECFIC
End

Funprog TESTSUITE_()
Call SET_LOCALE("fr-FR") From ASYRQLF

Call TESTSUITE_START("DECL", "DECL") From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("DECL", "DECL")
End SUITE_RESULT


Funprog TESTSUITE()
Call SET_LOCALE("fr-FR") From ASYRQLF

Call TESTSUITE_START("DECL", "DECL") From AXUNIT

EX=0
Onerrgo ERROR

Local Integer NBTEST
NBTEST=6
Call ADD_TESTCASE("TC_DECL_LIBELLE","test TC_DECL_LIBELLE",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_TINYINT","test TC_DECL_TINYINT",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_SHORTINT","test TC_DECL_SHORTINT",NBTEST) From AXUNIT

NBTEST=3
Call ADD_TESTCASE("TC_DECL_FLOAT","test TC_DECL_FLOAT",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_DOUBLE","test TC_DECL_DOUBLE",NBTEST) From AXUNIT

NBTEST=9
Call ADD_TESTCASE("TC_DECL_INTEGER","test TC_DECL_INTEGER",NBTEST) From AXUNIT
NBTEST=11
Call ADD_TESTCASE("TC_DECL_DECIMAL","test TC_DECL_DECIMAL",NBTEST) From AXUNIT

NBTEST=4
Call ADD_TESTCASE("TC_DECL_SCHAR","test TC_DECL_SCHAR",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_CHAR","test TC_DECL_CHAR",NBTEST) From AXUNIT

NBTEST=3
Call ADD_TESTCASE("TC_DECL_DATE","test TC_DECL_DATE",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_BLBFILE","test TC_DECL_BLBFILE",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_CLBFILE","test TC_DECL_CLBFILE",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_UUIDENT","test TC_DECL_UUIDENT",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_DATETIME","test TC_DECL_DATETIME",NBTEST) From AXUNIT
Call ADD_TESTCASE("TC_DECL_INSTANCE","test TC_DECL_INSTANCE",NBTEST) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("DECL", "DECL")
End SUITE_RESULT

$ERROR
Call CHECK_EQUAL(errn, EX)
EX = 0
Resume

Subprog CHECK_EVAL(STR, RESULT)
Call CHECK_EQUAL(evalue(STR), RESULT)
End

Subprog CHECK_EQUAL(GOT, EXPECT)
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End


#####################################################

Subprog TC_DECL_LIBELLE
Local Integer EX
Local Libelle WTINT
Onerrgo ERROR
Call CHECK_EQUAL(type(WTINT), 1)
Call CHECK_EQUAL(dim(WTINT)>=0, 1)
WTINT=1
Call CHECK_EQUAL(WTINT, 1)
WTINT=0
Call CHECK_EQUAL(WTINT, 0)
WTINT=255
Call CHECK_EQUAL(WTINT, 255)


EX=13
WTINT=500

End

Subprog TC_DECL_TINYINT
Local Integer EX
Local Tinyint WTINT
Onerrgo ERROR
Call CHECK_EQUAL(type(WTINT), 1)
Call CHECK_EQUAL(dim(WTINT)>=0, 1)
WTINT=1
Call CHECK_EQUAL(WTINT, 1)
WTINT=0
Call CHECK_EQUAL(WTINT, 0)
WTINT=255
Call CHECK_EQUAL(WTINT, 255)


EX=13
WTINT=500

End

Subprog TC_DECL_SHORTINT
Local Integer EX
Local Shortint WSINT
Onerrgo ERROR
Call CHECK_EQUAL(type(WSINT), 2)
Call CHECK_EQUAL(dim(WSINT)>=0, 1)
WSINT=1
Call CHECK_EQUAL(WSINT, 1)
WSINT=-32768
Call CHECK_EQUAL(WSINT, -32768)
WSINT=32767
Call CHECK_EQUAL(WSINT, 32767)


EX=13
WSINT=40000

End

Subprog TC_DECL_INTEGER
Local Integer WINT
Integer EX
Onerrgo ERROR
Call CHECK_EQUAL(type(WINT), 4)
Call CHECK_EQUAL(dim(WINT)>=0, 1)
WSINT=1
Call CHECK_EQUAL(WSINT, 1)

WINT= -(2^31-1)
Call CHECK_EQUAL(WINT, -(2^31-1))
Call CHECK_EQUAL(WINT=-(2^31-1),1)

WINT= 2^31-1
Call CHECK_EQUAL(WINT, 2^31-1)
Call CHECK_EQUAL(WINT=2^31-1,1)

#Set A with a value out of limits:
EX = 50 :# expected error
WINT= -(2^31)
EX = 50 :# expected error
WINT= 2^31

End

Subprog TC_DECL_DECIMAL
Local Decimal WDEC
Integer EX
Onerrgo ERROR
Call CHECK_EQUAL(type(WDEC), 7)
Call CHECK_EQUAL(dim(WDEC)>=0, 1)
WDEC=1.3
Call CHECK_EQUAL(WDEC, 1.3)
WDEC=-(1.00E79)
Call CHECK_EQUAL(WDEC, -(1.00E79))
Call CHECK_EQUAL(WDEC=-1.00E79,1)
Call CHECK_EQUAL(WDEC=val("-1.00E79"),1)
#
WDEC= 1.00E79
Call CHECK_EQUAL(WDEC, 1.00E79)
Call CHECK_EQUAL(WDEC=1.00E79,1)
Call CHECK_EQUAL(WDEC=val("1.00E79"),1)
#
##Set A with a value out of limits:
EX = 13 :# expected error
WDEC= -(1.00E80)
If pat(ver$(0),"etna*")>0
Call CHECK_EQUAL(WDEC=-1.00E80,1)
Endif
EX = 13 :# expected error
WDEC= 1.00E80
If pat(ver$(0),"etna*")>0
Call CHECK_EQUAL(WDEC, 1.00E80)
Endif
End

Subprog TC_DECL_FLOAT
Local Float WFLOAT
If pat(ver$(0),"etna*")>0
Call CHECK_EQUAL(type(WFLOAT), 7)
Else
Call CHECK_EQUAL(type(WFLOAT), 5)
Endif
Call CHECK_EQUAL(dim(WFLOAT)>=0, 1)
WFLOAT=1.3
Call CHECK_EQUAL(WFLOAT, 1.3)
End

Subprog TC_DECL_DOUBLE
Local Double WDBL
If pat(ver$(0),"etna*")>0
Call CHECK_EQUAL(type(WDBL), 7)
Else
Call CHECK_EQUAL(type(WDBL), 6)
Endif
Call CHECK_EQUAL(dim(WDBL)>=0, 1)
WDBL=1.3
Call CHECK_EQUAL(WDBL, 1.3)
End

Subprog TC_DECL_SCHAR
Local Schar WCHAR(10)
Call CHECK_EQUAL(type(WCHAR), 20)
Local Schar WCHAR2(15)
Call CHECK_EQUAL(type(WCHAR2), 25)
Call CHECK_EQUAL(dim(WCHAR)>=0, 1)
WCHAR="1"
Call CHECK_EQUAL(WCHAR, "1")
End

Subprog TC_DECL_CHAR
Local Char WCHAR(10)
Call CHECK_EQUAL(type(WCHAR), 20)
Local Schar WCHAR2(15)
Call CHECK_EQUAL(type(WCHAR2), 25)
Call CHECK_EQUAL(dim(WCHAR)>=0, 1)
WCHAR="1"
Call CHECK_EQUAL(WCHAR, "1")
End

Subprog TC_DECL_DATE
Local Date WDATE
Call CHECK_EQUAL(type(WDATE), 3)
Call CHECK_EQUAL(dim(WDATE)>=0, 1)
WDATE=[17/06/2014]
Call CHECK_EQUAL(WDATE, [17/06/2014])
End

Subprog TC_DECL_BLBFILE
Local Blbfile WBLB(1)
Call CHECK_EQUAL(type(WBLB), 522)
Call CHECK_EQUAL(dim(WBLB)>=0, 1)
Call CHECK_EQUAL(len(WBLB), 0)
End

Subprog TC_DECL_CLBFILE
Local Clbfile WCLB(1)
Call CHECK_EQUAL(type(WCLB), 523)
Call CHECK_EQUAL(dim(WCLB)>=0, 1)
Setlob WCLB With "toto"
Call CHECK_EQUAL(WCLB, "toto")
End

Subprog TC_DECL_UUIDENT
Local Uuident WIDENT,AUUID
Call CHECK_EQUAL(type(AUUID), 525)
Call CHECK_EQUAL(dim(WIDENT)>=0, 1)
AUUID = getUuid
WIDENT=AUUID
Call CHECK_EQUAL(WIDENT,AUUID)
End

Subprog TC_DECL_DATETIME
Local Datetime WDT,WDT2
Call CHECK_EQUAL(type(WDT), 526)
Call CHECK_EQUAL(dim(WDT)>=0, 1)
WDT2=datetime$
WDT=WDT2
Call CHECK_EQUAL(num$(WDT), num$(WDT2))
End

Subprog TC_DECL_INSTANCE
Local Instance WINST Using OBJECT
Call CHECK_EQUAL(type(WINST), 524)
Call CHECK_EQUAL(dim(WINST)>=0, 1)
Call CHECK_EQUAL(WINST=null, 1)
End
