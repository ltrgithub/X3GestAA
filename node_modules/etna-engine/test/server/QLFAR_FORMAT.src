Local Clbfile RESULT
Call OUVRE_TRACE("QLFAR_FORMAT") From LECFIC
RESULT = func TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_FORMAT_"+GUSER
Call LEC_TRACE From LECFIC

End

Funprog TESTSUITE()
Local Integer EX
# There are 3 format types - String, Date and Numeric with various options in each type

Call SET_LOCALE("fr-FR") From ASYRQLF
Call TESTSUITE_START("FORMAT", "FORMAT") From AXUNIT
Call ADD_TESTCASE("STRING_TEST", "string formats", 22) From AXUNIT
Call ADD_TESTCASE("DATE_TEST", "date formats", 36) From AXUNIT
Call ADD_TESTCASE("NUM_TEST", "numeric formats", 25) From AXUNIT

# Test cases matching formatterTest.js - 29 sections
Call ADD_TESTCASE("BASIC1_TEST", "Basic formatting", 29) From AXUNIT
Call ADD_TESTCASE("DATE_BASIC", "Date basic", 5) From AXUNIT
Call ADD_TESTCASE("DATE_LOC", "Date with country format", 9) From AXUNIT
Call ADD_TESTCASE("DATE_Z", "Date Z", 2) From AXUNIT
Call ADD_TESTCASE("DATE_TEXT", "Date with text", 3) From AXUNIT
Call ADD_TESTCASE("NUM_BASIC", "Number basic", 39) From AXUNIT
Call ADD_TESTCASE("NUM_HASH_MARK", "Number Float 1", 25) From AXUNIT
Call ADD_TESTCASE("NUM_FLOAT", "Number Float 2", 72) From AXUNIT
Call ADD_TESTCASE("NUM_Z3", "Number z3 (thousands sep)", 19) From AXUNIT
Call ADD_TESTCASE("NUM5_TEST", "Number - (leading sign)", 6) From AXUNIT
Call ADD_TESTCASE("NUM6_TEST", "Number N alone", 9) From AXUNIT
Call ADD_TESTCASE("NUM7_TEST", "Number z and v with . input", 15) From AXUNIT
Call ADD_TESTCASE("NUM8_TEST", "Number z and v with 0 inputs", 20) From AXUNIT
Call ADD_TESTCASE("NUM9_TEST", "Number z and v with spaces input", 24) From AXUNIT
Call ADD_TESTCASE("NUM10_TEST", "Number z and v with empty input", 16) From AXUNIT
Call ADD_TESTCASE("NUM11_TEST", "Number z and v with lots of zeros in input", 4) From AXUNIT
Call ADD_TESTCASE("STRING2_TEST", "String padding tests", 17) From AXUNIT
Call ADD_TESTCASE("STRING3_TEST", "String case conversions", 31) From AXUNIT
Call ADD_TESTCASE("STRING4_TEST", "String L option", 4) From AXUNIT

Call ADD_TESTCASE("SERIES1_TEST", "Date series 2", 79) From AXUNIT
Call ADD_TESTCASE("SERIES2_TEST", "Number series 2", 44) From AXUNIT
Call ADD_TESTCASE("SERIES3_TEST", "String series 2", 11) From AXUNIT
Call ADD_TESTCASE("EDIT2_TEST", "X3 -> Edit -> Display Format", 10) From AXUNIT
Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("FORMAT", "FORMAT")
End SUITE_RESULT


$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume

$ERROR_END
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
End

Subprog STRING_TEST
  # Formats chaine
  Local Char FORMATS_ALPHA(30)(1..40)
  Local Char RESULTATS_ALPHA(100)(1..40)
  Local Char CHAINE(100),FORMRES(100),RESULT(100)

  CHAINE=space$(1)+"Essai"+space$(2)+num$(ar2(pi))+space$(2)+"toyable"+space$(1)

  Local Integer I,J

  I=2
  For FORMRES="25X",                "+Essai++3.14++toyable++++",
&          "K:25X",               "+Essai++3.14++toyable++++",
&          "KX:25X",              "**********************+++",
&          "Kv0:25X",             "Essai++3.14++toyable++++",
&          "Kv1:25X",             "+Essai++3.14++toyable",
&          "Kv2:25X",             "Essai++3.14++toyable",
&          "Kv3:25X",             "Essai",
&          "Kv4:25X",             "Essai3.14toyable",
&          "Kv5:25X",             "+Essai+3.14+toyable+",
&          "K:15X",               "+Essai++3.14++t",
&          "K:XXXXXXXXXX",        "+Essai++3.",
&          "K:X3A5X",             "+ESSai++3",
&          "K:X[$]3X[#]5X",       "+$Ess#ai++3",
&          "K:4X2A2X#4X",         "+EssAI++3.14+",
&          "K:15A",               "+++++++++++++++",
&          "K:X5B2XBX2B2X7B",     "+ESSAI++3.14++TOYABLE",
&          "K:X5b2XbX2b2X7B",     "+essai++3.14++TOYABLE",
&          "K:X5C2XCX2C2X7C",     "+Essai++3.14++toyable",
&          "K:15B",               "+++++++++++++++",
&          "K:15#",               "+++++++++++++++",
&          "Kv2:X[$]X[$]X[$]",    "$E$s$",
&          "K:[HEXA:]X[$]H",      "HEXA:+$E"

  If mod(I,2)=0
      FORMATS_ALPHA(I/2)=FORMRES
  Else
      RESULTATS_ALPHA((I-1)/2)=FORMRES
  Endif
  I+=1
  Next
Local Char LINE(250)
  For J=1 To (I-2)/2
    RESULT=ctrans(format$(FORMATS_ALPHA(J),CHAINE)," ","+")
    Call LOG_LINE(FORMATS_ALPHA(J)) From AXUNIT
    Call CHECK_EQUAL(RESULT, RESULTATS_ALPHA(J)) From AXUNIT
  Next J

End


Subprog DATE_TEST()
  Local Char FORMATS_DATE(100)(1..40)
  Local Char RESULTATS_DATE(100)(1..40)
  Local Date DATE_TEST
  Local Char FORMRES(100),RESULT(100)


  DATE_TEST=[29/5/1959]

  Local Integer I,J

  I=2
  For FORMRES="D:DD",               "29",
&          "D:MM",                "05",
&          "D:YY",                "59",
&          "D:MMM",               "MAY",
&          "D:5M",                "Mai  ",
&          "D:4Y",                "1959",
&          "D:2D2M2Y",            "290559",
&          "D:4Y2M2D",            "19590529",
&          "D:DD[-]MM[-]YYYY",    "29-05-1959",
&          "D:[Le ]DD[ ]15M",   "Le 29 Mai            ",
&          "D:[A Paris, le ]DD[ ]MM[ de l'an de grace ]4Y","A Paris, le 29 05 de l'an de grace 1959",
&          "D:[A Paris, le ]DD[ ]9M[ de l'an de grace ]4Y","A Paris, le 29 Mai       de l'an de grace 1959",
&          "D:[Paris, ]3M[ ]DD[, ]4Y","Paris, MAY 29, 1959",
&          "D:DD[-]MM[-]YYYY[ ]hh[:]mm[:]ss",    "29-05-1959"

  If mod(I,2)=0
      FORMATS_DATE(I/2)=FORMRES
  Else
      RESULTATS_DATE((I-1)/2)=FORMRES
  Endif
  I+=1
  Next

# date type tests
  For J=1 To (I-2)/2
    RESULT=format$(FORMATS_DATE(J),DATE_TEST)
    # Résultat non garanti, la seconde peut être passée
    RESULTATS_DATE(J)+=string$(instr(1,FORMATS_DATE(J),"[ ]hh[:]mm[:]ss")<>0," "+time$)
    Call CHECK_EQUAL(RESULT, RESULTATS_DATE(J)) From AXUNIT
  Next J

# additional date types
Call SET_LOCALE("en-US") From ASYRQLF                       # Change language

RESULT = format$("DD1",[31/1/2013])
EXPECT = "01/31"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

RESULT = format$("DD2",[31/1/2013])
EXPECT = "01/31/13"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

Local Datetime MY_DATETIME

MY_DATETIME = gdatetime$("2013-01-31T01:10:20Z")

RESULT = format$("DD3",MY_DATETIME)
EXPECT = "January   31,13 01: 10"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

RESULT = format$("DD4",MY_DATETIME)
EXPECT = "January   31,2013 01:10:20"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

Call SET_LOCALE("fr-FR") From ASYRQLF

RESULT = format$("DD1",[31/1/2013])
EXPECT = "31/01"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

RESULT = format$("DD2",[31/1/2013])
EXPECT = "31/01/13"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

Local Datetime MY_DATETIME

MY_DATETIME = gdatetime$("2013-01-31T01:10:20Z")

RESULT = format$("DD3",MY_DATETIME)
EXPECT = "31 Janvier   13 01:10"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

RESULT = format$("DD4",MY_DATETIME)
EXPECT = "31 Janvier   2013 01:10:20"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

# datetime type tests
Local Datetime DATETIME_TEST
DATETIME_TEST = gdatetime$("1959-05-29T01:10:20Z")
  For J=1 To (I-2)/2
  RESULT=format$(FORMATS_DATE(J),DATETIME_TEST)
  If instr(1,FORMATS_DATE(J),"[ ]hh[:]mm[:]ss")<>0
    RESULTATS_DATE(J)="29-05-1959 01:10:20"
  Endif
  Call CHECK_EQUAL(RESULT, RESULTATS_DATE(J)) From AXUNIT
Next J

End

Subprog NUM_TEST()
  Local Char FORMATS_NUM(100)(1..40)
  Local Char RESULTATS_NUM(100)(1..40)
  Local Decimal NUM_TEST
  Local Char FORMRES(100),RESULT(100)

  NUM_TEST=3141592653589.79300

  Local Integer I,J

  Local Char SAV_ADXSCA(10)
  SAV_ADXSCA = [S]adxsca
  # Une variable système à affecter
  # Attention, les caractères différents de "?" restent significatifs
  [S]adxsca="??"   : # Obsolète
  [S]adxsca+="."   : # séparateur groupes de 3 chiffres - digit separator
  [S]adxsca+=","   : # séparateur décimal - radix point
  [S]adxsca+="#"   : # caractère dépassement - numeric overflow character
  [S]adxsca+="*"   : # remplissage avant chiffres - padding character
  [S]adxsca+="???" : # obsolète



  I=2
  For FORMRES="N:4",                       "####",
&          "N:4#",                       "####",
&          "N:13",                       "3141592653589",
&          "N:14#",                      " 3141592653589",
&          "N:14#.2#",                   " 3141592653589,79",
&          "NZ:14#.5#",                  " 3141592653589,79300",
&          "N0:14#.3#",                  "03141592653589,793",
&          "N0:16.3",                    "0003141592653589,793",
&          "N0:6",                       "######",
&          "N*:16.3",                    "***3141592653589,793",
&          "N30*:16.8",                  "***3.141.592.653.589,79300000",
&          "N30*-D:16.3",                "***3.141.592.653.589,793+",
&          "N:[Montant:]14#.2[ Euros]",  "Montant: 3141592653589,79 Euros",
&         "NB:[Montant:]14#.2[ Euros]",  "         3141592653589,79      "

  If mod(I,2)=0
      FORMATS_NUM(I/2)=FORMRES
  Else
      RESULTATS_NUM((I-1)/2)=FORMRES
  Endif
  I+=1
  Next


  For J=1 To (I-2)/2
    RESULT=format$(FORMATS_NUM(J),NUM_TEST)
    Call CHECK_EQUAL(RESULT, RESULTATS_NUM(J)) From AXUNIT
  Next J

# additional cases
# change [S]adxsca radix and digit separator
  # Une variable système à affecter
  # Attention, les caractères différents de "?" restent significatifs
  [S]adxsca="??"   : # Obsolète
  [S]adxsca+=","   : # séparateur groupes de 3 chiffres - digit separator
  [S]adxsca+="."   : # séparateur décimal - radix point
  [S]adxsca+="#"   : # caractère dépassement - numeric overflow character
  [S]adxsca+="*"   : # remplissage avant chiffres - padding character
  [S]adxsca+="???" : # obsolète

Local Char EXPECT(250)
RESULT = format$("Nz:9.2[ Euros]",0)
EXPECT = "                  "
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("ND:5.2",-pi)
EXPECT = "    3.14-"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("ND:5.2",pi)
EXPECT = "    3.14"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("N+:5.2",1.5)
EXPECT = "    1.50"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("N+:5.2",-1.5)
EXPECT = "    0.00"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("ND-:5.2",-pi)
EXPECT = "    3.14-"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("ND-:5.2",pi)
EXPECT = "    3.14+"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("N-:5.2",-pi)
EXPECT = "   -3.14"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("N-:5.2",pi)
EXPECT = "   +3.14"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

[S]adxsca = SAV_ADXSCA

RESULT = format$("N-:5.2", "ABCDE")
EXPECT = ""
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("K:10X", 123.12)
EXPECT = "          "
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

End


Subprog BASIC1_TEST
  Local Integer I,EX
  Local Char FORMATS(100)(1..40)
  Local Char RESULTS(100)(1..40)
  Local Char VALUES(100)(1..40)
  Local Decimal NUM_TEST
  Local Char FORMRES(100),RESULT(100),EXPRES(100)
  Local Decimal VALUES_DECIMAL

Call SET_LOCALE("fr-FR") From ASYRQLF                     # Force to French
  [S]adxsca="??"   : # Obsolète
  [S]adxsca+="."   : # séparateur groupes de 3 chiffres - digit separator
  [S]adxsca+=","   : # séparateur décimal - radix point
  [S]adxsca+="#"   : # caractère dépassement - numeric overflow character
  [S]adxsca+="*"   : # remplissage avant chiffres - padding character
  [S]adxsca+="???" : # obsolète

I=3
Onerrgo ERROR
For FORMRES =      "K:5X","A", "A    ",
&                  "K:[x]5X",  "A", "xA    ",
&                  "K:[x]5#",  "1", "x1    ",
&                  "K:[x]5X[y]",  "A", "xA    y",
&                  "K:[x]5#[y]",  "22", "x22   y",
&                  "K:5B",  "ABCDEFGH", "ABCDE",
&                  "Nz:11F",  "123456789.12", "123456789,1",
&                  "Nz:11F",  "123456789.19", "123456789,1",
&                  "Nz:11F",  "0.00987654321", "0,009876543",
&                  "Nz:11F",  "12345678900", "12345678900",
&                  "Nz:11F",  "12345.123456", "12345,12345",
&                  "N:9.2#",  "123456789.12", "123456789,12",
&                  "N:1.10#",  "0.00987654321", "0,0098765432",
&                  "N:11#",  "12345678900", "12345678900",
&                  "N:5.6#",  "12345.123456", "12345,123456",
&                  "N:5#",  "3.1415", "    3",
&                  "N:5F",  "3.1415", "3,141",
&                  "K:5b",  "MAJUSCULE", "majus",
&                  "K:4X[-]4X[-]4X[-]4X[-]", "Cocodd", "Coco-dd  -    -    -",
&                  "K:4X[-]4X[-]4X[-]4X[-]", "Cocodd", "Coco-dd  -    -    -",
&                  "K:4X[-]4X[-]4X[-]4X[-]", "Coco    ", "Coco-    -    -    -",
&                  "K:#[ ]##[ ]##[ ]#B[ ]###[ ]###",  "2500613564564", "2 50 06 13 564 564",
&                  "K:#[ ]##[ ]##[ ]#B[ ]###[ ]###[ ]##",  "2500613564564", "2 50 06 13 564 564   "
If mod(I,3)=0
      FORMATS(I/3)=FORMRES
  Elsif mod(I,3)=1
      VALUES((I-1)/3)=FORMRES
  Else
      RESULTS((I-2)/3)=FORMRES
  Endif
I+=1

Next

Local Char RESULT_STR(100)
Local Date VALUES_DATE
Local Decimal VALUES_DECIMAL
For J=1 To (I-3)/3
Case left$(FORMATS(J),1)
  When "K"  :
    RESULT_STR=format$(FORMATS(J),VALUES(J))
    Call CHECK_EQUAL(RESULT_STR, RESULTS(J)) From AXUNIT
  When "D"
    VALUES_DATE = VALUES(J)
    RESULT_STR=format$(FORMATS(J),VALUES_DATE)
    Call CHECK_EQUAL(RESULT_STR, RESULTS(J)) From AXUNIT
  When "N"
    VALUES_DECIMAL = val(VALUES(J))
    RESULT_STR=format$(FORMATS(J),VALUES_DECIMAL)
    Call CHECK_EQUAL(RESULT_STR, RESULTS(J)) From AXUNIT
Endcase

# Special cases
# There is no command in X3 to unformat a string



Next

# "en-US" translation

Call SET_LOCALE("en-US") From ASYRQLF                     # Force to English-US
VALUES_DATE = "20080102"
RESULT_STR=format$("Dz:DD[ ]MMMMMMMMMM[ ]YYYY",VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, "02 January    2008") From AXUNIT
Call SET_LOCALE("fr-FR") From ASYRQLF                     # Force to French


# format and unformat

VALUES_STR = "151228"
RESULT_STR=format$("Kz:##[:]##[:]##",VALUES_STR)
Call CHECK_EQUAL(RESULT_STR, "15:12:28") From AXUNIT
# no unformat but we can use ctrans
RESULT_STR=ctrans(RESULT_STR,":","")
Call CHECK_EQUAL(RESULT_STR, "151228") From AXUNIT


VALUES_STR = "2500613564564"
RESULT_STR=format$("K:#[ ]##[ ]##[ ]#B[ ]###[ ]###[ ]##",VALUES_STR)
Call CHECK_EQUAL(RESULT_STR, "2 50 06 13 564 564   ") From AXUNIT
# no unformat but we can use ctrans
RESULT_STR=ctrans(RESULT_STR," ","")
Call CHECK_EQUAL(RESULT_STR, "2500613564564") From AXUNIT

Local Date VALUES_DATE
VALUES_DATE = [21/02/2008]
RESULT_STR=format$("Dz:YYYYMMDD",VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, "20080221") From AXUNIT

End

Subprog DATE_BASIC
Local Integer EX
Local Date VALUES_DATE
Local Char RESULT_STR(100)
Onerrgo ERROR

VALUES_DATE = [08/02/2001]
RESULT_STR=format$('D:DD[/]MM[/]YY',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '08/02/01') From AXUNIT

# YYMMDD
VALUES_DATE = [02/10/2001]
RESULT_STR=format$('D:DD[/]MM[/]YYYY',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '02/10/2001') From AXUNIT

#YYMMDD
VALUES_DATE = [06/03/2002]
RESULT_STR=format$('D:DD[/]MM[/]YYYY',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '06/03/2002') From AXUNIT

#YYMMDD
VALUES_DATE = [01/10/2008]
RESULT_STR=format$('D:DD[/]MM[/]YY',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '01/10/08') From AXUNIT

# YYYYMMDD
VALUES_DATE = [01/12/2000]
RESULT_STR=format$('D:DD[/]MM[/]YY',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '01/12/00') From AXUNIT

End

Subprog DATE_LOC
Local Integer EX
Local Date VALUES_DATE
Local Char DATE_STR(20)
Onerrgo ERROR

# France Local
Call SET_LOCALE("fr-FR") From ASYRQLF

VALUES_DATE = "20011230"
RESULT_STR=format$('DD1',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '30/12') From AXUNIT

VALUES_DATE = "20011230"
RESULT_STR=format$('DD2',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '30/12/01') From AXUNIT

VALUES_DATE = "20011230"
RESULT_STR=format$('DD3',VALUES_DATE)
Call CHECK_EQUAL(left$(RESULT_STR,15), '30 Décembre  01') From AXUNIT

VALUES_DATE = "20011230"
RESULT_STR=format$('DD4',VALUES_DATE)
Call CHECK_EQUAL(left$(RESULT_STR,17), '30 Décembre  2001') From AXUNIT

# US local
Call SET_LOCALE("en-US") From ASYRQLF

VALUES_DATE = "20011230"
RESULT_STR=format$('DD1',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '12/30') From AXUNIT

VALUES_DATE = "20011230"
RESULT_STR=format$('DD2',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '12/30/01') From AXUNIT

VALUES_DATE = "20011230"
RESULT_STR=format$('DD3',VALUES_DATE)
Call CHECK_EQUAL(left$(RESULT_STR,15), 'December  30,01') From AXUNIT

VALUES_DATE = "20011230"
RESULT_STR=format$('DD4',VALUES_DATE)
Call CHECK_EQUAL(left$(RESULT_STR,17), 'December  30,2001') From AXUNIT

VALUES_DATE="20121105"
RESULT_STR=format$('D:DD[-]MMM',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '05-NOV') From AXUNIT

End
Subprog DATE_Z
Local Date VALUES_DATE
Local Char RESULT_STR(20)

Local Integer EX
Onerrgo ERROR

VALUES_DATE=[00/00/00]
RESULT_STR=format$('DZ:DD[/]MM[/]YY',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '  /  /  ') From AXUNIT

RESULT_STR=format$('DZ:DD[/]MM[/]YYYY',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, '  /  /    ') From AXUNIT

End

#**
#* DATE_TEXT - Date with text options
#*!

Subprog DATE_TEXT
Local Date VALUES_DATE
Local Char RESULT_STR(250)

Local Integer EX
Onerrgo ERROR

VALUES_DATE=[16/03/1963]
RESULT_STR=format$('D:[debut]DD[.]MM[.]YY[fin]',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, 'debut16.03.63fin') From AXUNIT

VALUES_DATE=[06/03/2016]
RESULT_STR=format$('D:[debut]DD[.]MM[.]YY[fin]',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, 'debut06.03.16fin') From AXUNIT

Call SET_LOCALE("fr-FR") From ASYRQLF
VALUES_DATE=[14/03/2013]
RESULT_STR=format$('D:[A Grenoble, le ]DD[ ]9M[ ]YYYY',VALUES_DATE)
Call CHECK_EQUAL(RESULT_STR, 'A Grenoble, le 14 Mars      2013') From AXUNIT

End

#**
#* NUM_BASIC - number basic
#*!
Subprog NUM_BASIC
Local Char RESULTS(50)(50),FORMATS(50)(50),VALUES(50)(50),RESULT_STR(100)
Local Decimal VALUES_DECIMAL
Local Integer EX
Local Char SAV_ADXSCA(20)

Onerrgo ERROR

[L]SAV_ADXSCA = [S]adxsca
[S]adxsca  = "...,**$_"

I=3
For FORMRES= 'NPzc:9.2#','5.4', '        5,40',
&        'N:9.4#','53.1299', '       53,1299',
&        'N-:9.4#','53.1399', '      +53,1399',
&        'N-:9.4#','-53.1499', '      -53,1499',
&        'N:5#','1','    1',
&        'N-:5#','2','   +2',
&        'N-:5#','-3','   -3',
&        'N0:5#','5','00005',
&        'N0:5#','-5','-0005',
&        'N0+:5#','5','00005',
&        'N0+:5#','-5','00000',
&        'N3:12.2','123567589.25', '   123.567.589,25',
&        'NPzc:9#.2#','54.567', '       54,56',
&        'NPzc:9.2','54.567', '       54,56',
&        'NPzc:9.2','54.00', '       54,00',
&        'NPzc:9.2#','54.00', '       54,00',
&        'NPzc:9.[$]2#','54.3', '       54,$30',
&        'NPzc:9.2#','5.4', '        5,40',
&        'NPzc:9.2#','5.456789', '        5,45',
&        'NPzc:9.2#','5.4', '        5,40',
&        'NPzc:9.2#','5.4', '        5,40',
&        'NPzc:9.2#','5.456789', '        5,45',
&        'NPzc:9.2#','5.456789', '        5,45',
&        'NPzc:9.2#','4349.012945123455656560000000000000000000000000000000', '     4349,01',
&        'NPzc:9.2#','4349.250000000000000000000000000000000', '     4349,25',
&        'NPzc:9.2#','33.333333333333333333333333333333', '       33,33',
&        'NPzc:9.2#','33.33333', '       33,33',
&        'NPzc:9.2#','4.053293300806905610808782135485', '        4,05',
&        'N+z:12.5','123456789016.005', '123456789016,00500',
&        'N+z:12.5','123456789016.00565056', '123456789016,00565',
&        'NZ:11###.2#####','150.00', '          150,000000',
&        'NZ:11.2#####','150.00', '        150,000000',
&        'NZ:11.2#####','150', '        150,000000',
&        'N:11.2','150', '        150,00',
&        "N-3z:14.0#","14321", "        +14.321,",
&        "N-3zv0:14.0#","14322", "+14.322,",
&        "N3z:14.0#","14323", "         14.323,",
&        "N3zv0:14.0#","14324", "14.324,",
&        "N-3zv:14.0#" ,"14322", "+14.322,"

If mod(I,3)=0
      FORMATS(I/3)=FORMRES
  Elsif mod(I,3)=1
      VALUES((I-1)/3)=FORMRES
  Else
      RESULTS((I-2)/3)=FORMRES
  Endif

I+=1
Next
For J=1 To (I-3)/3
    VALUES_DECIMAL = val(VALUES(J))
    RESULT_STR=format$(FORMATS(J),VALUES_DECIMAL)
    Call CHECK_EQUAL(RESULT_STR, RESULTS(J)) From AXUNIT
Next

[S]adxsca=[L]SAV_ADXSCA
End

Subprog NUM_HASH_MARK

Local Integer EX:EX=0
Local Char SAV_ADXSCA(20)

Onerrgo ERROR

[L]SAV_ADXSCA = [S]adxsca
[S]adxsca  = "...,**$_"

Call CHECK_EQUAL(format$('N:9.2#',9), '        9,00') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',9.2), '        9,20') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',9.23), '        9,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',9.234), '        9,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',89.234), '       89,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',789.234), '      789,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',6789.234), '     6789,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',56789.234), '    56789,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',456789.234), '   456789,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',3456789.234), '  3456789,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',23456789.234), ' 23456789,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',123456789.234), '123456789,23') From AXUNIT
Call CHECK_EQUAL(format$('N:9.2#',1234567890.234), '*********,**') From AXUNIT

Call CHECK_EQUAL(format$('N3:9.2#',9), '        9,00') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',9.2), '        9,20') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',9.23), '        9,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',9.234), '        9,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',89.234), '       89,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',789.234), '      789,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',6789.234), '     6.789,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',56789.234), '    56.789,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',456789.234), '   456.789,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',3456789.234), '  3.456.789,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',23456789.234), ' 23.456.789,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:9.2#',123456789.234), '123.456.789,23') From AXUNIT

[S]adxsca=[L]SAV_ADXSCA
End

Subprog NUM_FLOAT

Local Integer EX
Local Char SAV_ADXSCA(20)

Onerrgo ERROR

[L]SAV_ADXSCA = [S]adxsca
[S]adxsca  = "...,**$_"

Call CHECK_EQUAL(format$('N:1F',1), '1') From AXUNIT
Call CHECK_EQUAL(format$('N:2F',12), '12') From AXUNIT
Call CHECK_EQUAL(format$('N:3F',123), '123') From AXUNIT
Call CHECK_EQUAL(format$('N:4F',1234), '1234') From AXUNIT
Call CHECK_EQUAL(format$('N:5F',12345), '12345') From AXUNIT
Call CHECK_EQUAL(format$('N:6F',123456), '123456') From AXUNIT
Call CHECK_EQUAL(format$('N:7F',1234567), '1234567') From AXUNIT
Call CHECK_EQUAL(format$('N:8F',12345678), '12345678') From AXUNIT
Call CHECK_EQUAL(format$('N:9F',123456789), '123456789') From AXUNIT
Call CHECK_EQUAL(format$('N:10F',1234567890), '1234567890') From AXUNIT
Call CHECK_EQUAL(format$('N:11F',12345678901), '12345678901') From AXUNIT

Call CHECK_EQUAL(format$('N:3F',0.1), '0,1') From AXUNIT
Call CHECK_EQUAL(format$('N:4F',0.12), '0,12') From AXUNIT
Call CHECK_EQUAL(format$('N:5F',0.123), '0,123') From AXUNIT
Call CHECK_EQUAL(format$('N:6F',0.1234), '0,1234') From AXUNIT
Call CHECK_EQUAL(format$('N:7F',0.12345), '0,12345') From AXUNIT
Call CHECK_EQUAL(format$('N:8F',0.123456), '0,123456') From AXUNIT
Call CHECK_EQUAL(format$('N:9F',0.1234567), '0,1234567') From AXUNIT
Call CHECK_EQUAL(format$('N:10F',0.12345678), '0,12345678') From AXUNIT
Call CHECK_EQUAL(format$('N:11F',0.123456789), '0,123456789') From AXUNIT
Call CHECK_EQUAL(format$('N:12F',0.1234567891), '0,1234567891') From AXUNIT
Call CHECK_EQUAL(format$('N:13F',0.12345678912), '0,12345678912') From AXUNIT
Call CHECK_EQUAL(format$('N3:13F',0.12345678912), '0,12345678912') From AXUNIT

Call CHECK_EQUAL(format$('N:11F',12345.54321), '12345,54321') From AXUNIT

Call CHECK_EQUAL(format$('N:5F',0.123456789), '0,123') From AXUNIT
Call CHECK_EQUAL(format$('N:5F',123.456789), '123,4') From AXUNIT
Call CHECK_EQUAL(format$('N:5F',1234.56789), '1234,') From AXUNIT
Call CHECK_EQUAL(format$('N:5F',12345.6789), '12345') From AXUNIT
Call CHECK_EQUAL(format$('N:5F',123456.789), '*****') From AXUNIT
Call CHECK_EQUAL(format$('N:5F',123456789), '*****') From AXUNIT

Call CHECK_EQUAL(format$('N:11F',1), '          1') From AXUNIT
Call CHECK_EQUAL(format$('N:11F',1.000000000), '          1') From AXUNIT
Call CHECK_EQUAL(format$('N:11F',1.23), '       1,23') From AXUNIT
Call CHECK_EQUAL(format$('N:11F',12345678.005), '12345678,00') From AXUNIT

Call CHECK_EQUAL(format$('N*:11F',1.000000000), '**********1') From AXUNIT
Call CHECK_EQUAL(format$('N*:11F',1.23), '*******1,23') From AXUNIT
Call CHECK_EQUAL(format$('N*:11F',1234.23), '****1234,23') From AXUNIT

Call CHECK_EQUAL(format$('N*3:11F',1.000000000), '**********1') From AXUNIT
Call CHECK_EQUAL(format$('N*3:11F',1.23), '*******1,23') From AXUNIT
Call CHECK_EQUAL(format$('N*3:11F',1234.23), '****1.234,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:11F',1234.23), '    1.234,23') From AXUNIT
Call CHECK_EQUAL(format$('N3:11F',1234), '       1234') From AXUNIT
Call CHECK_EQUAL(format$('N-3:11F',1234), '      +1234') From AXUNIT


Call CHECK_EQUAL(format$('N-:2F',1), '+1') From AXUNIT
Call CHECK_EQUAL(format$('N-:3F',12), '+12') From AXUNIT
Call CHECK_EQUAL(format$('N-:4F',123), '+123') From AXUNIT
Call CHECK_EQUAL(format$('N-:5F',1234), '+1234') From AXUNIT
Call CHECK_EQUAL(format$('N-:6F',12345), '+12345') From AXUNIT
Call CHECK_EQUAL(format$('N-:7F',123456), '+123456') From AXUNIT
Call CHECK_EQUAL(format$('N-:8F',1234567), '+1234567') From AXUNIT
Call CHECK_EQUAL(format$('N-:9F',12345678), '+12345678') From AXUNIT
Call CHECK_EQUAL(format$('N-:10F',123456789), '+123456789') From AXUNIT
Call CHECK_EQUAL(format$('N-:11F',1234567890), '+1234567890') From AXUNIT
Call CHECK_EQUAL(format$('N-:12F',12345678901), '+12345678901') From AXUNIT
Call CHECK_EQUAL(format$('N-3:12F',12345678901), '+12345678901') From AXUNIT

Call CHECK_EQUAL(format$('N-:2F',0), '+0') From AXUNIT
Call CHECK_EQUAL(format$('N-:2F',-1), '-1') From AXUNIT
Call CHECK_EQUAL(format$('N-:3F',-12), '-12') From AXUNIT
Call CHECK_EQUAL(format$('N-:4F',-123), '-123') From AXUNIT
Call CHECK_EQUAL(format$('N-:5F',-1234), '-1234') From AXUNIT
Call CHECK_EQUAL(format$('N-:6F',-12345), '-12345') From AXUNIT
Call CHECK_EQUAL(format$('N-:7F',-123456), '-123456') From AXUNIT
Call CHECK_EQUAL(format$('N-:8F',-1234567), '-1234567') From AXUNIT
Call CHECK_EQUAL(format$('N-:9F',-12345678), '-12345678') From AXUNIT
Call CHECK_EQUAL(format$('N-:10F',-123456789), '-123456789') From AXUNIT
Call CHECK_EQUAL(format$('N-:11F',-1234567890), '-1234567890') From AXUNIT
Call CHECK_EQUAL(format$('N-:12F',-12345678901), '-12345678901') From AXUNIT
Call CHECK_EQUAL(format$('N-3:12F',-12345678901), '-12345678901') From AXUNIT

Call CHECK_EQUAL(format$('N+:11F',-1), '          0') From AXUNIT
Call CHECK_EQUAL(format$('N+:11F',-1.2), '          0') From AXUNIT
Call CHECK_EQUAL(format$('N-+:11F',-1), '         +0') From AXUNIT
Call CHECK_EQUAL(format$('N-+:11F',-1.2), '         +0') From AXUNIT

[S]adxsca=[L]SAV_ADXSCA
End

Subprog NUM_Z3
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1
Local Char SAV_ADXSCA(30) : SAV_ADXSCA=[S]adxsca
[S]adxsca = ".. ,**$_"

Call TESTOPTIONS('N:5.2#', FALSE, '13', '   13,00', 0)
Call TESTOPTIONS('N+:5.2#', FALSE, '13', '   13,00', 0)
Call TESTOPTIONS('N+z:5.2#', FALSE, '13', '   13,00', 0)
Call TESTOPTIONS('N+z3:5.2#', FALSE, '13', '   13,00', 0)
Call TESTOPTIONS('Nv0+z3:5.2#', FALSE, '13.00', '13,00', 0)
Call TESTOPTIONS('Nv+z3:5.2#', FALSE, '13.00', '13,00', 0)
Call TESTOPTIONS('N+z3:15.5#', FALSE, '12345678911.03205', '    12 345 678 911,03205', 0)
Call TESTOPTIONS('N+z3:11.2#', FALSE, '345678911.88', '  345 678 911,88', 0)
Call TESTOPTIONS('N+z3:11.2#', FALSE, '1234567911.88', ' 1 234 567 911,88', 0)
Call TESTOPTIONS('N3:9.2#', FALSE, '+1234567.30', '  1 234 567,30', 0)
Call TESTOPTIONS('N+z3:11.2#', FALSE, '1234567911.88', ' 1 234 567 911,88', 0)
Call TESTOPTIONS('N-z3:11.2#', FALSE, '1234567911.88', '+1 234 567 911,88', 0)
Call TESTOPTIONS('N:9.2#'   , FALSE, '1234567911.81', '*********,**', 0)
Call TESTOPTIONS('Nz:9.2#'  , FALSE, '1234567911.82', '            ', 0)
Call TESTOPTIONS('Nz3:9.2#' , FALSE, '1234567911.83', '            ', 0)
Call TESTOPTIONS('N-z3:9.2#', FALSE, '1234567911.84', '            ', 0)
Call TESTOPTIONS('N:9.6#'   , FALSE, '123456789.012345768', '123456789,012345'  , 0)
Call TESTOPTIONS('Nz:9.6#'  , FALSE, '123456789.012345768', '123456789,012345'  , 0)
Call TESTOPTIONS('Nz3:9.6#' , FALSE, '123456789.012345768', '123 456 789,012345', 0)
[S]adxsca=SAV_ADXSCA
End

Subprog NUM5_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1
[S]adxsca = ".. ,**$_"
Call TESTOPTIONS('N:5.2#', FALSE, '10.5', '   10,50', 0)
Call TESTOPTIONS('N-D0:3#', FALSE, '+150', '150+', 0)
Call TESTOPTIONS('N-D0:3#', TRUE, '+150', '150+', 0)
Call TESTOPTIONS('N-:4.1#', FALSE, '+150.3', '+150,3', 0)
Call TESTOPTIONS('N-:4#', FALSE, '+150', '+150', 0)
Call TESTOPTIONS('N-:4#', TRUE, '+150', '+150', 0)

End

Subprog NUM6_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1
Local Char SAV_ADXSCA(30) : SAV_ADXSCA=[S]adxsca
[S]adxsca = ".. ,**$_"
Call TESTOPTIONS('ND*3:5.2', TRUE, '150.23', '**150,23', 0)
Call TESTOPTIONS('ND03:5.2', TRUE, '150.23', '00150,23', 0)
Call TESTOPTIONS("N3zv*:14.#", TRUE, "14322.34", "*********14 322,3", 0)
Call TESTOPTIONS("N3zv0:14.#", TRUE, "14322.34", "14 322,3", 0)
Call TESTOPTIONS("N-3zv*:14.#", TRUE, "14322.34", "********+14 322,3", 0)
Call TESTOPTIONS("N-3zv0:14.#", TRUE, "14322.34", "+14 322,3", 0)
Call TESTOPTIONS("N-3zv0:10.6", TRUE, "14322.234", "+14 322,234000", 0)
Call TESTOPTIONS("N-3zv*:##########.###", TRUE, "14322.234", "****+14 322,234", 0)
Call TESTOPTIONS("N-3zv0:##########.###", TRUE, "14322.234", "+14 322,234", 0)
#TODO? Call TESTOPTIONS('N+D*:####2.##3#', FALSE, '+150.23', '***150,23000', 0)
#TODO? Call TESTOPTIONS('N+D0:####2.##3#', FALSE, '+150.23', '000150,23000', 0)
#TODO? Call TESTOPTIONS('N+D*:####2.##3#', TRUE, '+150.23', '***150,23000', 0)
#TODO? Call TESTOPTIONS('N+D0:####2.##3#', TRUE, '+150.23', '000150,23000', 0)
#TODO? Call TESTOPTIONS('N-D*3:####2.##3#', TRUE, '+150.23', '***150,23000+', 0)
#TODO? Call TESTOPTIONS('N-D03:####2.##3#', TRUE, '+150.23', '000150,23000+', 0)
[S]adxsca=SAV_ADXSCA
End

#**
#* NUM7_TEST-Number z and v with . input
#*!

Subprog NUM7_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1
Local Char SAV_ADXSCA(30) : SAV_ADXSCA=[S]adxsca
[S]adxsca = ".. ,**$_"
Call TESTOPTIONS('Nz:7.6#', FALSE, '.', '              ', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '.', '              ', 0)
Call TESTOPTIONS('Nz0:7.6#', TRUE, '.0000000', '              ', 0)
Call TESTOPTIONS('Nz0:7.6#', FALSE, '.', '              ', 0)
Call TESTOPTIONS('Nz0:7.6#', TRUE, '.', '              ', 0)
Call TESTOPTIONS('Nzv:7.6#', FALSE, '.', '', 0)
Call TESTOPTIONS('Nzv:7.6#', TRUE, '.', '', 0)
Call TESTOPTIONS('Nz0v:7.6#', FALSE, '.', '', 0)
Call TESTOPTIONS('Nz0v:7.6#', TRUE, '.', '', 0)
Call TESTOPTIONS('Nzv1:7.6#', FALSE, '.', '', 0)
Call TESTOPTIONS('Nzv1:7.6#', TRUE, '.', '', 0)
Call TESTOPTIONS('Nzv2:7.6#', FALSE, '.', '', 0)
Call TESTOPTIONS('Nzv2:7.6#', TRUE, '.', '', 0)
Call TESTOPTIONS('N:7.6#', FALSE, '.', '      0,000000', 0)
Call TESTOPTIONS('N:7.6#', TRUE, '.', '      0,000000', 0)
[S]adxsca=SAV_ADXSCA
End

#**
#* "NUM8_TEST", "Number z and v with 0 inputs"
#*!

Subprog NUM8_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1

Local Char SAV_ADXSCA(30) : SAV_ADXSCA=[S]adxsca
[S]adxsca = ".. ,**$_"
Call TESTOPTIONS('Nz:7.6#', FALSE, '+0', '              ', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '+0', '              ', 0)
Call TESTOPTIONS('N:7.6#', FALSE, '+0', '      0,000000', 0)
Call TESTOPTIONS('N:7.6#', TRUE, '+0', '      0,000000', 0)
Call TESTOPTIONS('Nz:7.6#', FALSE, '0.0', '              ', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '0.0', '              ', 0)
Call TESTOPTIONS('N:7.6#', FALSE, '0.0', '      0,000000', 0)
Call TESTOPTIONS('N:7.6#', TRUE, '0.0', '      0,000000', 0)
Call TESTOPTIONS('Nz:7.6#', FALSE, '0', '              ', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '0', '              ', 0)
Call TESTOPTIONS('N:7.6#', FALSE, '0', '      0,000000', 0)
Call TESTOPTIONS('N:7.6#', TRUE, '0', '      0,000000', 0)
Call TESTOPTIONS('Nv2z:7.6#', FALSE, '0', '', 0)
Call TESTOPTIONS('Nv2z:7.6#', TRUE, '0', '', 0)
Call TESTOPTIONS('Nv2:7.6#', FALSE, '0', '0,000000', 0)
Call TESTOPTIONS('Nv2:7.6#', TRUE, '0', '0,000000', 0)
Call TESTOPTIONS('Nz:7F', FALSE, '0', '       ', 0)
Call TESTOPTIONS('Nz:7F', TRUE, '0', '       ', 0)
Call TESTOPTIONS('N:7F', FALSE, '0', '      0', 0)
Call TESTOPTIONS('N:7F', TRUE, '0', '      0', 0)
[S]adxsca=SAV_ADXSCA

End

#**
#* "NUM9_TEST", "Number z and v with spaces input"
#*!

Subprog NUM9_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1

Call TESTOPTIONS('N0v2z:7.6#', FALSE, '              ', '', 0)
Call TESTOPTIONS('N0v2z:7.6#', TRUE, '              ', '', 0)
Call TESTOPTIONS('N0v2:7.6#', FALSE, '              ', '0000000,000000', 0)
Call TESTOPTIONS('N0v2:7.6#', TRUE, '              ', '0000000,000000', 0)
Call TESTOPTIONS('Nv2z:7.6#', FALSE, '              ', '', 0)
Call TESTOPTIONS('Nv2z:7.6#', TRUE, '              ', '', 0)
Call TESTOPTIONS('Nv2:7.6#', FALSE, '              ', '0,000000', 0)
Call TESTOPTIONS('Nv2:7.6#', TRUE, '              ', '0,000000', 0)
Call TESTOPTIONS('Nz0:7.6#', FALSE, '              ', '              ', 0)
Call TESTOPTIONS('Nz0:7.6#', TRUE, '              ', '              ', 0)
Call TESTOPTIONS('N0:7.6#', FALSE, '              ', '0000000,000000', 0)
Call TESTOPTIONS('N0:7.6#', TRUE, '              ', '0000000,000000', 0)
Call TESTOPTIONS('Nz:7.6#', FALSE, '              ', '              ', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '              ', '              ', 0)
Call TESTOPTIONS('N:7.6#', FALSE, '              ', '      0,000000', 0)
Call TESTOPTIONS('N:7.6#', TRUE, '              ', '      0,000000', 0)
Call TESTOPTIONS('Nv2z:7.6#', FALSE, '  ', '', 0)
Call TESTOPTIONS('Nv2z:7.6#', TRUE, '  ', '', 0)
Call TESTOPTIONS('Nv2:7.6#', FALSE, '  ', '0,000000', 0)
Call TESTOPTIONS('Nv2:7.6#', TRUE, '  ', '0,000000', 0)
Call TESTOPTIONS('Nz:7.6#', FALSE, '  ', '              ', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '  ', '              ', 0)
Call TESTOPTIONS('N:7.6#', FALSE, '  ', '      0,000000', 0)
Call TESTOPTIONS('N:7.6#', TRUE, '  ', '      0,000000', 0)

End

#**
#* "NUM10_TEST", "Number z and v with empty input"
#*!

Subprog NUM10_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1

Call TESTOPTIONS('Nv2z:7.6#', FALSE, '', '', 0)
Call TESTOPTIONS('Nv2z:7.6#', TRUE, '', '', 0)
Call TESTOPTIONS('Nv2:7.6#', FALSE, '', '0,000000', 0)
Call TESTOPTIONS('Nv2:7.6#', TRUE, '', '0,000000', 0)
Call TESTOPTIONS('Nz:7.6#', FALSE, '', '              ', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '', '              ', 0)
Call TESTOPTIONS('N:7.6#', FALSE, '', '      0,000000', 0)
Call TESTOPTIONS('N:7.6#', TRUE, '', '      0,000000', 0)
Call TESTOPTIONS('Nv2z:7F', FALSE, '', '', 0)
Call TESTOPTIONS('Nv2z:7F', TRUE, '', '', 0)
Call TESTOPTIONS('Nv2:7F', FALSE, '', '0', 0)
Call TESTOPTIONS('Nv2:7F', TRUE, '', '0', 0)
#Call TESTOPTIONS('N:7.6#', FALSE, '', '0,000000', {
#    ZON: TRUE
#  })
#Call TESTOPTIONS('N:7.6#', TRUE, '', '0,000000', {
#    ZON: TRUE
#  })
#Call TESTOPTIONS('Nz:7.6#', FALSE, '', '', {
#    ZON: TRUE
#  })
#Call TESTOPTIONS('Nz:7.6#', TRUE, '', '', {
#    ZON: TRUE
#  })
Call TESTOPTIONS('N:7.6#', FALSE, '', '      0,000000', 0)
Call TESTOPTIONS('N:7.6#', TRUE, '', '      0,000000', 0)
Call TESTOPTIONS('Nz:7.6#', FALSE, '', '              ', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '', '              ', 0)

End

#**
#* "NUM11_TEST", "Number z and v with lots of zeros in input"
#*!

Subprog NUM11_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1

Call TESTOPTIONS('Nv2z0:7.6#', FALSE, '0000000.000000', '', 0)
Call TESTOPTIONS('Nv2z0:7.6#', TRUE, '0000000.000000', '', 0)
Call TESTOPTIONS('N0v2:7.6#', FALSE, '0000000.000000', '0000000,000000', 0)
Call TESTOPTIONS('N0v2:7.6#', TRUE, '0000000.000000', '0000000,000000', 0)

End

#**
#* "STRING2_TEST", "String padding tests"
#*!

Subprog STRING2_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1
Call TESTOPTIONS('K:2#[.az]2#[.zeaaz]2#[.zae]2#[.eaz]2#[ zaez]', FALSE, '115566', '11.az55.zeaaz66.zae  .eaz   zaez', 0)
Call TESTOPTIONS('K:2#[.az]2#[.zeaaz]2#[.zae]2#[.eaz]2#[ zaez]', TRUE, '115566', '11.az55.zeaaz66.zae  .eaz   zaez', 0)
Call TESTOPTIONS('K:11X', FALSE, ' A ', ' A         ', 0)
Call TESTOPTIONS('K:11X', TRUE, ' A ', ' A         ', 0)
Call TESTOPTIONS('Kv1:11X', FALSE, ' A ', ' A', 0)
Call TESTOPTIONS('Kv1:11X', TRUE, ' A ', ' A', 0)
Call TESTOPTIONS('K:2#[.]2#[.]2#[.]2#[.]2#[ ]', FALSE, '115566', '11.55.66.  .   ', 0)
Call TESTOPTIONS('K:2#[.]2#[.]2#[.]2#[.]2#[ ]', TRUE, '115566', '11.55.66.  .   ', 0)
Call TESTOPTIONS('Kv2:10X', FALSE, '', '', 0)
#Call TESTOPTIONS('K:10X', FALSE, '', '          ', {
#    VON: FALSE
#  })
Call TESTOPTIONS('K:10X', FALSE, 'abcde', 'abcde     ', 0)
Call TESTOPTIONS('K:10X', FALSE, ' abcde ', ' abcde    ', 0)
Call TESTOPTIONS('Kv2:10X', FALSE, 'abcde', 'abcde', 0)
Call TESTOPTIONS('Kv2:10X', FALSE, ' rr rr  ', 'rr rr', 0)
Call TESTOPTIONS('Kv2:10X', FALSE, '          ', '', 0)
Call TESTOPTIONS('Kv2:10X', FALSE, ' abcde ', 'abcde', 0)
Call TESTOPTIONS('Kv2:[    ]10X[    ]', FALSE, ' abcde ', 'abcde', 0)
Call TESTOPTIONS('K:[    ]10X[    ]', FALSE, ' abcde ', '     abcde        ', 0)

End


#**
#* "STRING3_TEST", "string case conversions"
#*!
Subprog STRING3_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1

#Call TESTOPTIONS('K:3A', FALSE, 'ABC', 'ABC', {
#    VON: FALSE
#  })
Call TESTOPTIONS('K:3A', FALSE, 'ABC', 'ABC', 0)
Call TESTOPTIONS('K:3A', FALSE, 'ABz', 'ABZ', 0)
Call TESTOPTIONS('KTD:20X', FALSE, 'if0 if1 if2 if3', 'if0 if1 if2 if3     ', 0)
Call TESTOPTIONS('K:10X', FALSE, '', '          ', 0)
Call TESTOPTIONS('Kz:10X', FALSE, '', '          ', 0)
Call TESTOPTIONS('K:10A', FALSE, '', '          ', 0)
Call TESTOPTIONS('Kz:10A', FALSE, '', '          ', 0)
Call TESTOPTIONS('K:10A', FALSE, '  ', '          ', 0)
Call TESTOPTIONS('Kz:10A', FALSE, '  ', '          ', 0)
Call TESTOPTIONS('K:2B', FALSE, 'abc', 'AB', 0)
Call TESTOPTIONS('K:2B', TRUE, 'abc', 'AB', 0)
Call TESTOPTIONS('K:2B', FALSE, 'aB', 'AB', 0)
Call TESTOPTIONS('K:2B', TRUE, 'aB', 'AB', 0)
Call TESTOPTIONS('K:2B', FALSE, 'AB', 'AB', 0)
Call TESTOPTIONS('K:2B', TRUE, 'AB', 'AB', 0)
Call TESTOPTIONS('KA:2B', FALSE, 'AB', 'AB', 0)
Call TESTOPTIONS('KA:2B', TRUE, 'AB', 'AB', 0)
Call TESTOPTIONS('KAv2:10X', FALSE, '   a  ', 'a', 0)
Call TESTOPTIONS('KAv2:10X', TRUE, '   a  ', 'a', 0)
Call TESTOPTIONS('KAv2:10X', FALSE, '     ', '', 0)
Call TESTOPTIONS('KAv2:10X', TRUE, '     ', '', 0)
Call TESTOPTIONS('KA:10X', FALSE, 'A', 'A         ', 0)
Call TESTOPTIONS('KA:10X', TRUE, 'A', 'A         ', 0)
Call TESTOPTIONS('K:2B', FALSE, 'abc', 'AB', 0)
Call TESTOPTIONS('K:2B', TRUE, 'abc', 'AB', 0)
Call TESTOPTIONS('K:5X', FALSE, 'abcdefghijk', 'abcde', 0)
Call TESTOPTIONS('K:5X', TRUE, 'abcdefghijk', 'abcde', 0)
Call TESTOPTIONS('KTD:7A', TRUE, 'BONJOUR', 'BONJOUR', 0)
Call TESTOPTIONS('KTD:11A', TRUE, 'BONJOUR', 'BONJOUR    ', 0)
Call TESTOPTIONS('KTD:11A', TRUE, 'BONJOUR', 'BONJOUR    ', 0)
Call TESTOPTIONS('KTD:11AB', TRUE, 'BONJOUR', 'BONJOUR     ', 0)
End


#**
#* "STRING4_TEST", "String L option"
#*!
Subprog STRING4_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1
Local Integer SAV_ADXDCS : SAV_ADXDCS=[S]adxdcs
#
#  var OPT = {
#    DYNFORMATS: {
#      A: {
#        SUBTYPE: "b",
#        COMPLEMENT: ""
#      },
#      D: {
#        SUBTYPE: "",
#        COMPLEMENT: "/$"
#      }
#    }
#  };
Call TESTOPTIONS('KL:[debut]2B[.]2#[.]3A[.]3#[.]4a[fin]', FALSE, 'a612bCd345eFgH', 'debutA6.12.BCD.345.efghfin', 0)
Call TESTOPTIONS('KL:[debut]2B[.]2#[.]3A[.]3#[.]4a[fin]', TRUE, 'a612bCd345eFgH', 'debutA6.12.BCD.345.efghfin', 0)
#  OPT.DATESEP = '_';
#  OPT.DATEPIVOT = 1950;

[S]adxdcs = 1950
Call TESTOPTIONS('KL:[debut]2B[.]2#[.]3A[.]3#[.]4a[fin]', FALSE, 'a612bCd345eFgH', 'debutA6.12.BCD.345.efghfin', 0)
Call TESTOPTIONS('KL:[debut]2B[.]2#[.]3A[.]3#[.]4a[fin]', TRUE, 'a612bCd345eFgH', 'debutA6.12.BCD.345.efghfin', 0 )
#Call TESTOPTIONS('KL:[debut]2B[.]2#[.]3A[.]3#[.]4a[.\'D\']2d[fin]', FALSE, 'a612bCd345eFgH/$', 'debutA6.12.BCD.345.efgh.\'D\'/$fin', OPT)
#Call TESTOPTIONS('KL:[debut]2B[.]2#[.]3A[.]3#[.]4a[.\'D\']2d[fin]', TRUE, 'a612bCd345eFgH/$', 'debutA6.12.BCD.345.efgh.\'D\'/$fin', OPT)

End

#**
#* "SERIES1_TEST", "Date series 2"
#*!
Subprog SERIES1_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1
Call TESTOPTIONS("D:DD[/]MM", FALSE, "20311230", "30/12", 0)
Call TESTOPTIONS("D:DD[/]MM", FALSE, "311230", "30/12", 0)
Call TESTOPTIONS('Dz:DD[ ]MMMMMMMMMM[ ]YYYY', FALSE, '20080102', "02 Janvier    2008", 0)
Call TESTOPTIONS('D:[debut]DD[.]MMMMMMMMM[.]YYYY[fin]', TRUE, '20060509', 'debut09.Mai      .2006fin', 0)
Call TESTOPTIONS('DZ:DD[/]MM[/]YY', TRUE, '', '  /  /  ', 10)
Call TESTOPTIONS('DZ:DD[/]MM[/]YY', TRUE, '15991231', '  /  /  ', 10)
Call TESTOPTIONS('D:DD[/]MM[/]YY', FALSE, '281000', '  /  /  ', 56)
Call TESTOPTIONS('D:[debut]DD[.]MMMMMMMMM[.]YYYY[fin]', FALSE, '20062009', 'debut  .         .    fin', 56)
Call TESTOPTIONS('D:[debut]DD[.]MM[.]YY[fin]', FALSE, '16/03/2014', "debut  .  .  fin", 10)
Call TESTOPTIONS('D:[debut]DD[.]MM[.]YY[fin]', FALSE, '16/03/63', "debut  .  .  fin", 10)
Call TESTOPTIONS('D:[debut]DD[.]MM[.]YYYY[fin]', FALSE, '16/03/63', "debut  .  .  fin", 10)
Call TESTOPTIONS('D:DD[/]MMMMMMMMMM[/]YY', TRUE, '19620517', '17/Mai       /62', 0)
Call TESTOPTIONS('D:[debut]DD[.]MMMMMMMMM[.]YYYY[fin]', TRUE, '20060509', 'debut09.Mai      .2006fin', 56)
Call TESTOPTIONS('D:DD[/]MMMMMMMMMM[/]YY', TRUE, '19620517', '17/Mai       /62', 0)

Call CHECK_EQUAL("OPTION Z and z","OPTION Z and z") From AXUNIT

#OPTION Z and z
Call TESTOPTIONS('DZz:DD[/]MM[/]YY', FALSE , '', '        ', 10)
Call TESTOPTIONS('DZz:DD[/]MM[/]YY', TRUE  , '', '        ', 10)
Call TESTOPTIONS('DZz:DD[/]MMMMM[/]YYYY', FALSE, '', '             ',10)
Call TESTOPTIONS('DZz:DD[/]MMMMM[/]YYYY', TRUE, '', '             ', 10)
Call TESTOPTIONS('DZz:DD[/]MM', FALSE, '', '     ', 10)
Call TESTOPTIONS('DZz:DD[/]MM', TRUE, '', '     ', 10)
Call TESTOPTIONS('DZz:DD[/]MM[/]YY' , TRUE, '15991231', '        ', 0)
#30
Call CHECK_EQUAL("->30","->30") From AXUNIT

Call TESTOPTIONS('DZz:DD[/]MM', TRUE, '15991231', '     ', 0) : Call SET_LOCALE("fr-FR") From ASYRQLF
Call TESTOPTIONS('DZ:MM[-]DD[-]YYYY', FALSE, '17/05/2006', '  -  -    ', 10)
Call TESTOPTIONS('DZ:MMM[-]YYYY[-]DD', FALSE, '17/05/2006', '   -    -  ', 10)
Call TESTOPTIONS('DZ:MMM', FALSE, '17/05/2006', '   ', 10)
Call TESTOPTIONS('DZ:MMM', FALSE, '05', '   ', 10)
Call TESTOPTIONS('DZ:MMM', FALSE, '5', '   ', 10)
Call TESTOPTIONS('DZ:YYYY', FALSE, '2006', '    ', 10)
Call TESTOPTIONS('DZ:YYYY', FALSE, '6', '    ', 10)
Call TESTOPTIONS('DZ:YY[-]MM', FALSE, '052006', '  -  ', 56)
#40
Call CHECK_EQUAL("->40","->40") From AXUNIT
Call TESTOPTIONS('DZ:YY[-]MM', FALSE, '0506', '05-06', 10)
Call TESTOPTIONS('DZz:YY[-]MM[-]DD', FALSE, '', '        ', 10)
Call TESTOPTIONS('DZz:YY[-]MM[-]DD', TRUE, '', '        ', 10)
Call TESTOPTIONS('DZz:YY[-]MM', FALSE, '', '     ', 10)
Call TESTOPTIONS('DZz:YY[-]MM', TRUE, '', '     ', 10)
Call TESTOPTIONS('DZz:MM[-]DD', FALSE, '', '     ', 10)
Call TESTOPTIONS('DZz:YY[-]MM[-]DD', TRUE, '15991231', '        ', 0)
#50
Call CHECK_EQUAL("->50","->50") From AXUNIT
Call TESTOPTIONS('DZ:MMM[-]YYYY[-]DD', FALSE, '2006/05/17', '   -    -  ', 10)
Call TESTOPTIONS('DZ:MMM', FALSE, '2006/05/17', '   ', 10)
Call TESTOPTIONS('DZ:MMM', FALSE, '05', '   ', 10)
Call TESTOPTIONS('DZ:MMM', FALSE, '5', '   ', 10)
Call TESTOPTIONS('DZ:YYYY', FALSE, '2006', '    ', 10)
Call TESTOPTIONS('DZ:YYYY', FALSE, '6', '    ', 10)
Call TESTOPTIONS('DZ:YY[-]MM', FALSE, '200605', '20-06', 0)
Call TESTOPTIONS('DZ:MMM[-]YYYY', FALSE, '200605', 'JUN-2020', 0)
Call TESTOPTIONS('DZ:MMM[-]YYYY', FALSE, '0605', '', 10)
Call TESTOPTIONS('DZz:DD[_]MM[_]YY', FALSE, '', '        ', 10)
#60
Call CHECK_EQUAL("->60","->60") From AXUNIT
Call TESTOPTIONS('DZz:DD[_]MM[_]YY', TRUE, '', '        ', 10)
Call TESTOPTIONS('DZ:DD[_]MM', FALSE, '1705', '', 10)
Call TESTOPTIONS('DZ:DD[_]MM', TRUE, '1705', '', 10)
Call TESTOPTIONS('DZ:DD[_]MM', FALSE, '0517', '', 10)
Call TESTOPTIONS('DZ:DD[_]MM', TRUE, '0517', '  _  ', 10)
Call TESTOPTIONS('DZ:DD[_]MM', FALSE, '06/13/11', '11_03', 10)
Call TESTOPTIONS('DZ:DD[_]MM', TRUE, '06/13/11', '11_03', 10)
Call TESTOPTIONS('DZ:DD[_]MM[_]YYYY', FALSE, '06/13/11', '11_03_2006', 10)
Call TESTOPTIONS('DZ:DD[_]MM[_]YYYY', TRUE, '06/13/11', '11_03_2006', 10)
#70
Call CHECK_EQUAL("->70","->70") From AXUNIT
Call TESTOPTIONS('DZz:MM[_]DD[_]YY', TRUE, '15991231', '        ', 0)
Call TESTOPTIONS('DZ:MMM[-]YYYY[-]DD', FALSE, '05/17/2006', 'MAY-2006-17', 10)
Call TESTOPTIONS('DZ:MMM', FALSE, '05', 'MAY', 10)
Call TESTOPTIONS('DZ:MMM', FALSE, '5', 'MAY', 10)
Call TESTOPTIONS('DZ:YYYY', FALSE, '2006', '2006', 10)
Call TESTOPTIONS('DZ:YYYY', FALSE, '6', '2006', 10)
Call TESTOPTIONS('DZ:YY[-]MM', FALSE, '20060501', '06-05', 0)
#80
Call CHECK_EQUAL("->80","->80") From AXUNIT
Call TESTOPTIONS('DZ:MMM[-]YYYY', FALSE, '20060501', 'MAY-2006', 0)
Call TESTOPTIONS('DZ:YY[-]MM', FALSE, '0506', '06-05', 10)
Call TESTOPTIONS('DZ:DD[-]MM[-]YYYY', FALSE, '490506', '06-05-1949', 0)
Call TESTOPTIONS('DZ:DD[-]MM[-]YYYY', FALSE, '500506', '06-05-1950', 0)
Call TESTOPTIONS('DZ:DD[-]MM[-]YYYY', FALSE, '510506', '06-05-1951', 0)
Call TESTOPTIONS('DZ:DD[-]MM[-]YYYY', FALSE, '490506', '06-05-1949', 0)
[S]adxdcs=1950
Call TESTOPTIONS('DZ:DD[-]MM[-]YYYY', FALSE, '500506', '06-05-1950', 0)
Call TESTOPTIONS('DZ:DD[-]MM[-]YYYY', FALSE, '510506', '06-05-1951', 0)
Call TESTOPTIONS('DZ:DD[-]MM[-]YYYY', FALSE, '490506', '06-05-1949', 0)

End

#**
#* "SERIES2_TEST", "Number series 2", 25) From AXUNIT
#*!

Subprog SERIES2_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1

[S]adxsca = "...,**$_"
Call TESTOPTIONS('N:9.4#', TRUE, '53.1336', '       53,1336', 0)
Call TESTOPTIONS('NPzc:9.2#', TRUE, '5.4', '        5,40', 0)
Call TESTOPTIONS('NPzc:9.2#', TRUE, '5.456789', '        5,45', 0)
Call TESTOPTIONS('NPzc:9.2#', TRUE, '4349.012945123455656560000000000000000000000000000000', '     4349,01', 0)
Call TESTOPTIONS('NPzc:9.2#', TRUE, '4349.250000000000000000000000000000000', '     4349,25', 0)
Call TESTOPTIONS('NPzc:9.2#', TRUE, '4.053293300806905610808782135485', '        4,05', 0)
Call TESTOPTIONS('N3*:7.3#', FALSE, '5.4', '******5,400', 0)
Call TESTOPTIONS('N3*:7.3#', TRUE, '5.4', '******5,400', 0)
Call TESTOPTIONS('N+z:11F', FALSE, '00012345678.005', '12345678,00', 0)
Call TESTOPTIONS('N+z:11F', TRUE, '00012345678.005', '12345678,00', 0)
#10
Call TESTOPTIONS('N+z:12.5', TRUE, '123456789016.005', '123456789016,00500', 0)
Call TESTOPTIONS('N+z:12.5', TRUE, '123456789016.00565056', '123456789016,00565', 0)
Call TESTOPTIONS('N:[Debut]3[abc].2#[Fin]', FALSE, '150', 'Debut150abc,00Fin', 0)
Call TESTOPTIONS('N:[Debut]3[abc].2#[Fin]', TRUE, '150', 'Debut150abc,00Fin', 0)
Call TESTOPTIONS('N+z3:11F', TRUE, '0.7', '        0,7', 0)
Call TESTOPTIONS('Nv+z3:11F', TRUE, '0.7', '0,7', 0)
Call TESTOPTIONS('N+z3:11F', TRUE, '0.256', '      0,256', 0)
Call TESTOPTIONS('Nv+z3:11F', TRUE, '0.256', '0,256', 0)
Call TESTOPTIONS('Nv+z3:5.2#', TRUE, '13.00', '13,00', 0)
Call TESTOPTIONS('N3z:14#', FALSE, '14 322', '            14', 0)
#20
[S]adxsca=".. ,**$_"

Call TESTOPTIONS('N3z:14#', TRUE, '         15.322', '            15', 0)
Call TESTOPTIONS('N+3zv*:14.0#', FALSE, '14322', '*********14 322,', 0)
Call TESTOPTIONS('N-3z:14.0#', FALSE, '14322', '        +14 322,', 0)
Call TESTOPTIONS('N-3zv0:14.0#', FALSE, '14322', '+14 322,', 0)
Call TESTOPTIONS('N3z:14.0#', FALSE, '14322', '         14 322,', 0)
Call TESTOPTIONS('N3zv0:14.0#', FALSE, '14322', '14 322,', 0)
Call TESTOPTIONS('N+z3:11.2#', FALSE, '345678911.88', '  345 678 911,88', 0)

Call TESTOPTIONS('N-D0:3.0#', FALSE, '+150', '150,+', 0)
Call TESTOPTIONS('N-D0:0.6#', FALSE, '0.123', ',******+', 0)
#30
Call TESTOPTIONS('N-0:0.6#', FALSE, '0.123', ',******', 0)
Call TESTOPTIONS('N-:4.1#', TRUE, '+150.3', '+150,3', 0)
Call TESTOPTIONS('N-:4.0#', FALSE, '+150', '+150,', 0)
Call TESTOPTIONS('N3:9.2#', TRUE, '+1234567.30', '  1 234 567,30', 0)
Call TESTOPTIONS('N:6.2#', TRUE, '+23345.3', ' 23345,30', 0)
Call TESTOPTIONS('N+z3:11.2#', TRUE, '1234567911.88', ' 1 234 567 911,88', 0)
Call TESTOPTIONS('N+z3*:11.2#', FALSE, '150.88', '********150,88', 0)
Call TESTOPTIONS('N+z3*:11.2#', TRUE, '150.88', '********150,88', 0)
Call TESTOPTIONS('N+z3*:4.2#', FALSE, '150.88', '*150,88', 0)
#40
Call TESTOPTIONS('N+z30:11.2#', FALSE, '150.88', '00000000150,88', 0)
Call TESTOPTIONS('N+z30:4.2#', FALSE, '150.88', '0150,88', 0)
Call TESTOPTIONS('Nz:7.6#', TRUE, '  -3.2', '     -3,200000', 0)
Call TESTOPTIONS('N+z3:11.2#', TRUE, '1234567911.88', ' 1 234 567 911,88', 0)
Call TESTOPTIONS('N+z3*:11.2#', FALSE, '150.88', '********150,88', 0)
#50
Call TESTOPTIONS('N+z3*:4.2#', FALSE, '150.88', '*150,88', 0)

End

#**
#* "SERIES3_TEST", "String series 2"
#*!
Subprog SERIES3_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1

Call TESTOPTIONS('K:3A', FALSE, 'AB ', 'AB ', 0)
Call TESTOPTIONS('K:3A', FALSE, 'AB2', '   ', 0)
Call TESTOPTIONS('K:3A', FALSE, 'AB ', 'AB ', 0)
Call TESTOPTIONS('K:3A', FALSE, 'AB2', '   ', 0)
Call TESTOPTIONS('KTD:20X', FALSE, 'if if1 if2 if3', 'if if1 if2 if3      ', 0)
Call TESTOPTIONS('KTD:20X', FALSE, 'if if1 if2 if3      ', 'if if1 if2 if3      ', 0)
#Call TESTOPTIONS('KT:[if minuscule]15X[IF majuscule]20X[if minuscule]', FALSE, 'if if if if',
#& 'if minusculeIf If If If    IF majuscule                    if minuscule', 0)
Call TESTOPTIONS('KA:2B', FALSE, 'abc', '  ', 0)
Call TESTOPTIONS('KA:2B', FALSE, 'abc', '  ', 0)
Call TESTOPTIONS('KA:2B', FALSE, 'aB', '  ', 0)
Call TESTOPTIONS('KA:10a', FALSE, 'A', '          ', 0)
Call TESTOPTIONS('KL:[debut]2B[.]2#[.]3A[.]3#[.]4a[fin]', FALSE, 'a612bCd345eFgH', 'debutA6.12.BCD.345.efghfin', 0)
End


#**
#* "EDIT2_TEST", "X3 -> Edit -> Display Format
#*!
Subprog EDIT2_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1

[S]adxsca = ".. ,**$_"
Call TESTOPTIONS("K:##[.]##[.]##[.]##[.]##", TRUE, "0123456789", "01.23.45.67.89", 0)
Call TESTOPTIONS( 'N+z3:15.5#', TRUE, '12345678911.03205', '    12 345 678 911,03205',  0)
Call TESTOPTIONS( "D:[debut]DD[.]MM[.]YY[fin]", TRUE, '20090301', 'debut01.03.09fin',  0)
Call TESTOPTIONS( "D:DD[-]MM[-]YY", TRUE, "20090301",  "01-03-09", 0)
Call TESTOPTIONS( "D:DD[-]MM[-]YY", TRUE, "20090301",  "01-03-09",  0)
Call TESTOPTIONS( "N-3zv*:10.3", TRUE, "1254.256", "*****+1 254,256",  0)
#// TODO FORMATTER.UNFORMAT MUST PRESERVE THE year 2009 - WE HAVE To PASS DATEREF (20090301) As PARAMETER IN FORMAT/UNFORMAT
#// If year/month ARE MISSING WE MUST Choose THE year/month OF DATEREF
Call TESTOPTIONS( "D:DD[-]MM", TRUE, "20090301", "01-03", 0)
Call TESTOPTIONS("D:DD[-]MM", TRUE, "20090301", "01-03", 0)
#// THESE CASES ARE WORKING BECAUSE year=2013 (CURRENT year)
Call TESTOPTIONS( "D:DD[-]MM", TRUE, num$(year(date$)) + "0301", "01-03", 0)
Call TESTOPTIONS( "D:DD[-]MM", TRUE, num$(year(date$)) + "0301", "01-03", 0)
End

#**
#* "PARSE_TEST", "Parse user input value"
#*!
Subprog PARSE_TEST
Local Integer FALSE : FALSE = 0
Local Integer TRUE : TRUE = 1
Local Integer EX
#// FULL Date INPUT With OUT SEPARATORS
Call TESTEDITTODISPLAY('fr', "D:DD[/]MM[/]YY", "281112", "12/11/28", 0)
Call TESTEDITTODISPLAY('en', "D:MM[/]DD[/]YY", "112812", "11/28/12", 56)
End
Call TESTEDITTODISPLAY('fr', "D:DD[/]MM[/]YY", "28112012", "28/11/12", 56)
Call TESTEDITTODISPLAY('en', "D:MM[/]DD[/]YY", "11282012", "11/28/12", 56)
Call TESTEDITTODISPLAY('fr', "D:DD[/]MM[/]YY", "021112", "12/11/02", 0)
Call TESTEDITTODISPLAY('en', "D:MM[/]DD[/]YY", "11282012", "11/28/12", 56)
Call TESTEDITTODISPLAY('fr', "D:DD[/]MM[/]YYYY", "111103", "03/11/2011", 0)
Call TESTEDITTODISPLAY('fr', "D:DD[/]MM[/]YYYY", "111103", "03/11/2011", 0)
#// this ONE DOESN't seem to work for input - need to check
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YYYY", "111103", "03/11/2011", 0)
#// TEST 4 DIGIT Date INPUT With 2 DIGITS IN FORMAT
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "2011113", "03/11/11", 10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YYYY", "02213", "21/02/2003", 10)

#  // FULL Date INPUT With SEPARATORS
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "28/11/12", "12/01/28", 10)
Call TESTEDITTODISPLAY('EN', "D:MM[/]DD[/]YY", "11/28/12", "08/12/11", 10)

Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "28/11/2012", "28/11/12", 10)
Call TESTEDITTODISPLAY('EN', "D:MM[/]DD[/]YY", "11/28/2012", "11/28/12", 10)
#// Date With UNDEFINED VALUES - TAKE INTO ACCOUNT SERVERVALUE To FILL UDEFINED VALUES (year) INSTEAD OF CURRENT year
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "2811", "28/11/99",  10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "28/11", "28/11/99", 10)
Call TESTEDITTODISPLAY('EN', "D:MM[/]DD[/]YY", "1128", "11/28/99", 10)
Call TESTEDITTODISPLAY('EN', "D:MM[/]DD[/]YY", "11/28", "11/28/99", 10)
#// DATES
Call TESTEDITTODISPLAY('FR', "D:MM[/]YYYY", "1205", "12/2005", 10)
 Call TESTEDITTODISPLAY('EN', "D:MM[/]YYYY", "1205", "12/2005", 10)
Call TESTEDITTODISPLAY('FR', "D:MM[/]YY", "125", "12/05", 10)
Call TESTEDITTODISPLAY('EN', "D:MM[/]YY", "125", "12/05", 10)
Call TESTEDITTODISPLAY('FR', "D:MM[/]DD[/]YYYY", "13/02/2012", "02/13/2012", 10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM", "0211122574", "02/11", 10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "1/2/3", "01/02/03", 10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "1\\2\\3", "01/02/03", 10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "1 2 3", "01/02/03", 10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "1  2  3", "01/02/03",10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "1 - 2 - 3", "01/02/03", 10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM", "1 - 2 - 3 -", "01/02", 10)
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM", "1 . 2 . 5", "01/02", 10)

#  // USE Case With DISPLAYED DATEORDER DIFFERENT From EDIT DATEORDER (COUNTRY FORMAT)
#  // Date DISPLAYED IN ENGLISH/FRENCH BUT INPUT With FRENCH/ENGLISH DATEORDER
Call TESTEDITTODISPLAY('FR', "D:MM[/]DD[/]YYYY", "31/12/05", "02/05/2031", 10)
Call TESTEDITTODISPLAY('EN', "D:DD[/]MM[/]YYYY", "12/31/05", "05/01/2012", 10)

Call TESTEDITTODISPLAY('FR', "D:MM[/]DD", "311205", "12/05", 0)
Call TESTEDITTODISPLAY('EN', "D:DD[/]MM", "123105", "31/12", 56)
#// HOURS
Call TESTEDITTODISPLAY('FR', "K:##[:]##", "12:15", "     ", 0)
Call TESTEDITTODISPLAY('FR', "K:##[:]##", "1215", "12:15", 0)
#// PHONE NUMBERS
Call TESTEDITTODISPLAY('FR', "K:##[.]##[.]##[.]##[.]##", "0123456789", "01.23.45.67.89", 0)
#  // BAD Date Value
#  // YY ACEPTS 2005
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YY", "1/2/2005", "01/02/05", 10)
#  // YYYY ACEPTS 5
Call TESTEDITTODISPLAY('FR', "D:DD[/]MM[/]YYYY", "1/2/5", "01/02/2005", 10)
#  // NUMERIC
Call TESTOPTIONS("N+-03z:8.2#", FALSE, "+12", "00000+12.00", 0)
Call TESTOPTIONS("N:3#", FALSE, "+123", "123", 0)
Call TESTEDITTODISPLAY('fr', 'N:3#', '123', '123', 0)
Call TESTEDITTODISPLAY('fr', 'N:3#', '-123', '-**', 0)
Call TESTEDITTODISPLAY('fr', 'N:3#', '+123', '123', 0)
Call TESTEDITTODISPLAY('fr', 'N:3.1#', '123.4', '123.4', 0)
Call TESTEDITTODISPLAY('fr', 'N:3.1#', '-123.4', '-**.*', 0)
Call TESTEDITTODISPLAY('fr', 'N:3.1#', '+123.4', '123.4', 0)
End

Subprog TESTOPTIONS(FORMATS,RAW,VALUES,RESULTS,ERR)
Value Char FORMATS, VALUES, RESULTS
Value Integer RAW,ERR

#Call APPEND_VALUE(format$("K:50X","Test: "+FORMATS-VALUES)+chr$(10)) From AXUNIT
Local Char RESULTS_STR(50)
Local Decimal VALUES_DECIMAL
Local Double VALUES_DOUBLE
Local Date VALUES_DATE
Local Integer EX
Local Char SAV_ADXSCA(20)
Local Integer EX : EX=ERR

Onerrgo ERROR_END

Case left$(FORMATS,1)
  When "K"  :
    RESULT_STR=format$(FORMATS,VALUES)
    Call CHECK_EQUAL(RESULT_STR,RESULTS) From AXUNIT
  When "D"
    VALUES_DATE = VALUES
    RESULT_STR=format$(FORMATS,VALUES_DATE)
    Call CHECK_EQUAL(RESULT_STR,RESULTS) From AXUNIT
  When "N"
    VALUES_DECIMAL = val(VALUES)
    RESULT_STR=format$(FORMATS,VALUES_DECIMAL)
    Call CHECK_EQUAL(RESULT_STR,RESULTS) From AXUNIT
  When "L"
    VALUES_INTEGER = val(VALUES)
    RESULT_STR=format$(FORMATS,VALUES_INTEGER)
    Call CHECK_EQUAL(RESULT_STR,RESULTS) From AXUNIT
Endcase

Onerrgo
End

Subprog TESTEDITTODISPLAY(LANG,FORMATS,VALUES,RESULTS,ERR)
Value Char LANG,FORMATS,VALUES,RESULTS
Value Integer ERR
Local Integer TRUE : TRUE=1

Call SET_LOCALE(LANG) From ASYRQLF
Call TESTOPTIONS(FORMATS,TRUE,VALUES,RESULTS,ERR)

End

