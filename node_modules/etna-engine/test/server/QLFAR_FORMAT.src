#<AdxTL>@(#)0.0.0.0 $Revision$
Call OUVRE_TRACE("QLFAR_FORMAT") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_FORMAT_"+GUSER
Call LEC_TRACE From LECFIC

End

Funprog TESTSUITE()
#Call SET_LOCALE("fr-FR") From TEST_HELPER
Call TESTSUITE_START("FORMAT", "FORMAT") From AXUNIT
Call ADD_TESTCASE("STRING_TEST", "string formats", 22) From AXUNIT
Call ADD_TESTCASE("DATE_TEST", "date formats", 14) From AXUNIT
Call ADD_TESTCASE("NUM_TEST", "numeric formats", 12) From AXUNIT
Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("FORMAT", "FORMAT")
End SUITE_RESULT

Subprog STRING_TEST
  # Formats chaine
  Local Char FORMATS_ALPHA(30)(1..40)
  Local Char RESULTATS_ALPHA(100)(1..40)
  Local Char CHAINE(100),FORMRES(100),RESULT(100)

  CHAINE=space$(1)+"Essai"+space$(2)+num$(ar2(pi))+space$(2)+"toyable"+space$(1)

  Local Integer I,J

  I=2
  For FORMRES="25X",                "+Essai++3.14++toyable++++",
&          "K:25X",               "+Essai++3.14++toyable++++",
&          "KX:25X",              "**********************+++",
&          "Kv0:25X",             "Essai++3.14++toyable++++",
&          "Kv1:25X",             "+Essai++3.14++toyable",
&          "Kv2:25X",             "Essai++3.14++toyable",
&          "Kv3:25X",             "Essai",
&          "Kv4:25X",             "Essai3.14toyable",
&          "Kv5:25X",             "+Essai+3.14+toyable+",
&          "K:15X",               "+Essai++3.14++t",
&          "K:XXXXXXXXXX",        "+Essai++3.",
&          "K:X3A5X",             "+ESSai++3",
&          "K:X[$]3X[#]5X",       "+$Ess#ai++3",
&          "K:4X2A2X#4X",         "+EssAI++3.14+",
&          "K:15A",               "+++++++++++++++",
&          "K:X5B2XBX2B2X7B",     "+ESSAI++3.14++TOYABLE",
&          "K:X5b2XbX2b2X7B",     "+essai++3.14++TOYABLE",
&          "K:X5C2XCX2C2X7C",     "+Essai++3.14++toyable",
&          "K:15B",               "+++++++++++++++",
&          "K:15#",               "+++++++++++++++",
&          "Kv2:X[$]X[$]X[$]",    "$E$s$",
&          "K:[HEXA:]X[$]H",      "HEXA:+$E"

  If mod(I,2)=0
      FORMATS_ALPHA(I/2)=FORMRES
  Else
      RESULTATS_ALPHA((I-1)/2)=FORMRES
  Endif
  I+=1
  Next

  For J=1 To (I-2)/2
    RESULT=ctrans(format$(FORMATS_ALPHA(J),CHAINE)," ","+")
    #Call CHECK_EQUAL(RESULT, RESULTATS_ALPHA(J), FORMATS_ALPHA(J)) From AXUNIT
    Call CHECK_EQUAL(RESULT, RESULTATS_ALPHA(J)) From AXUNIT
  Next J
End

Subprog DATE_TEST()
  Local Char FORMATS_DATE(100)(1..40)
  Local Char RESULTATS_DATE(100)(1..40)
  Local Date DATE_TEST
  Local Char FORMRES(100),RESULT(100)

  DATE_TEST=[29/5/1959]

  Local Integer I,J

  I=2
  For FORMRES="D:DD",               "29",
&          "D:MM",                "05",
&          "D:YY",                "59",
&          "D:MMM",               "MAY",
&          "D:5M",                "Mai  ",
&          "D:4Y",                "1959",
&          "D:2D2M2Y",            "290559",
&          "D:4Y2M2D",            "19590529",
&          "D:DD[-]MM[-]YYYY",    "29-05-1959",
&          "D:[Le ]DD[ ]15M",   "Le 29 Mai            ",
&          "D:[A Paris, le ]DD[ ]MM[ de l'an de grace ]4Y","A Paris, le 29 05 de l'an de grace 1959",
&          "D:[A Paris, le ]DD[ ]9M[ de l'an de grace ]4Y","A Paris, le 29 Mai       de l'an de grace 1959",
&          "D:[Paris, ]3M[ ]DD[, ]4Y","Paris, MAY 29, 1959",
&          "D:DD[-]MM[-]YYYY[ ]hh[:]mm[:]ss",    "29-05-1959"

  If mod(I,2)=0
      FORMATS_DATE(I/2)=FORMRES
  Else
      RESULTATS_DATE((I-1)/2)=FORMRES
  Endif
  I+=1
  Next


  For J=1 To (I-2)/2
    RESULT=format$(FORMATS_DATE(J),DATE_TEST)
    # Résultat non garanti, la seconde peut être passée
    RESULTATS_DATE(J)+=string$(instr(1,FORMATS_DATE(J),"[ ]hh[:]mm[:]ss")<>0," "+time$)
    #Call CHECK_EQUAL(RESULT, RESULTATS_DATE(J), FORMATS_DATE(J)) From AXUNIT
    Call CHECK_EQUAL(RESULT, RESULTATS_DATE(J)) From AXUNIT
  Next J
End

Subprog NUM_TEST()
  Local Char FORMATS_NUM(100)(1..40)
  Local Char RESULTATS_NUM(100)(1..40)
  Local Decimal NUM_TEST
  Local Char FORMRES(100),RESULT(100)

  NUM_TEST=arr(pi*10^12,10^-5)

  Local Integer I,J

  # Une variable système à affecter
  # Attention, les caractères différents de "?" restent significatifs
  adxsca="??"   : # Obsolète
  adxsca+="."   : # séparateur groupes de 3 chiffres
  adxsca+=","   : # séparateur décimal
  adxsca+="#"   : # caractère dépassement
  adxsca+="*"   : # remplissage avant chiffres
  adxsca+="???" : # obsolète



  I=2
  For FORMRES="N:4",                       "####",
&          "N:4#",                       "####",
&          "N:13",                       "3141592653589",
&          "N:14#",                      " 3141592653589",
&          "N:14#.2#",                   " 3141592653589,79",
&          "NZ:14#.5#",                  " 3141592653589,79324",
&          "N0:14#.3#",                  "03141592653589,793",
&          "N0:16.3",                    "0003141592653589,793",
&          "N*:16.3",                    "***3141592653589,793",
&          "N30*:16.8",                  "***3.141.592.653.589,79324000",
&          "N30*-D:16.3",                "***3.141.592.653.589,793+",
&          "N:[Montant:]14#.2[ Euros]",  "Montant: 3141592653589,79 Euros"

  If mod(I,2)=0
      FORMATS_NUM(I/2)=FORMRES
  Else
      RESULTATS_NUM((I-1)/2)=FORMRES
  Endif
  I+=1
  Next


  For J=1 To (I-2)/2
    RESULT=format$(FORMATS_NUM(J),NUM_TEST)
    #Call CHECK_EQUAL(RESULT, RESULTATS_NUM(J), FORMATS_NUM(J)) From AXUNIT
    Call CHECK_EQUAL(RESULT, RESULTATS_NUM(J)) From AXUNIT
  Next J
End
