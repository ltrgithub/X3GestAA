#<AdxTL>@(#)0.0.0.0 $Revision$
Call OUVRE_TRACE("QLFAR_FORMAT") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_FORMAT_"+GUSER
Call LEC_TRACE From LECFIC

End

Funprog TESTSUITE()
# There are 3 format types - String, Date and Numeric with various options in each type
Call SET_LOCALE("fr-FR") From ASYRQLF
Call TESTSUITE_START("FORMAT", "FORMAT") From AXUNIT
Call ADD_TESTCASE("STRING_TEST", "string formats", 22) From AXUNIT
Call ADD_TESTCASE("DATE_TEST", "date formats", 28) From AXUNIT
Call ADD_TESTCASE("NUM_TEST", "numeric formats", 25) From AXUNIT
Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("FORMAT", "FORMAT")
End SUITE_RESULT

Subprog STRING_TEST
  # Formats chaine
  Local Char FORMATS_ALPHA(30)(1..40)
  Local Char RESULTATS_ALPHA(100)(1..40)
  Local Char CHAINE(100),FORMRES(100),RESULT(100)

  CHAINE=space$(1)+"Essai"+space$(2)+num$(ar2(pi))+space$(2)+"toyable"+space$(1)

  Local Integer I,J

  I=2
  For FORMRES="25X",                "+Essai++3.14++toyable++++",
&          "K:25X",               "+Essai++3.14++toyable++++",
&          "KX:25X",              "**********************+++",
&          "Kv0:25X",             "Essai++3.14++toyable++++",
&          "Kv1:25X",             "+Essai++3.14++toyable",
&          "Kv2:25X",             "Essai++3.14++toyable",
&          "Kv3:25X",             "Essai",
&          "Kv4:25X",             "Essai3.14toyable",
&          "Kv5:25X",             "+Essai+3.14+toyable+",
&          "K:15X",               "+Essai++3.14++t",
&          "K:XXXXXXXXXX",        "+Essai++3.",
&          "K:X3A5X",             "+ESSai++3",
&          "K:X[$]3X[#]5X",       "+$Ess#ai++3",
&          "K:4X2A2X#4X",         "+EssAI++3.14+",
&          "K:15A",               "+++++++++++++++",
&          "K:X5B2XBX2B2X7B",     "+ESSAI++3.14++TOYABLE",
&          "K:X5b2XbX2b2X7B",     "+essai++3.14++TOYABLE",
&          "K:X5C2XCX2C2X7C",     "+Essai++3.14++toyable",
&          "K:15B",               "+++++++++++++++",
&          "K:15#",               "+++++++++++++++",
&          "Kv2:X[$]X[$]X[$]",    "$E$s$",
&          "K:[HEXA:]X[$]H",      "HEXA:+$E"

  If mod(I,2)=0
      FORMATS_ALPHA(I/2)=FORMRES
  Else
      RESULTATS_ALPHA((I-1)/2)=FORMRES
  Endif
  I+=1
  Next
Local Char LINE(250)
  For J=1 To (I-2)/2
    RESULT=ctrans(format$(FORMATS_ALPHA(J),CHAINE)," ","+")
    #Call CHECK_EQUAL(RESULT, RESULTATS_ALPHA(J), FORMATS_ALPHA(J)) From AXUNIT
    Call LOG_LINE(FORMATS_ALPHA(J)) From AXUNIT
    Call CHECK_EQUAL(RESULT, RESULTATS_ALPHA(J)) From AXUNIT
  Next J
End


Subprog DATE_TEST()
  Local Char FORMATS_DATE(100)(1..40)
  Local Char RESULTATS_DATE(100)(1..40)
  Local Date DATE_TEST
  Local Char FORMRES(100),RESULT(100)


  DATE_TEST=[29/5/1959]

  Local Integer I,J

  I=2
  For FORMRES="D:DD",               "29",
&          "D:MM",                "05",
&          "D:YY",                "59",
&          "D:MMM",               "MAY",
&          "D:5M",                "Mai  ",
&          "D:4Y",                "1959",
&          "D:2D2M2Y",            "290559",
&          "D:4Y2M2D",            "19590529",
&          "D:DD[-]MM[-]YYYY",    "29-05-1959",
&          "D:[Le ]DD[ ]15M",   "Le 29 Mai            ",
&          "D:[A Paris, le ]DD[ ]MM[ de l'an de grace ]4Y","A Paris, le 29 05 de l'an de grace 1959",
&          "D:[A Paris, le ]DD[ ]9M[ de l'an de grace ]4Y","A Paris, le 29 Mai       de l'an de grace 1959",
&          "D:[Paris, ]3M[ ]DD[, ]4Y","Paris, MAY 29, 1959",
&          "D:DD[-]MM[-]YYYY[ ]hh[:]mm[:]ss",    "29-05-1959"

  If mod(I,2)=0
      FORMATS_DATE(I/2)=FORMRES
  Else
      RESULTATS_DATE((I-1)/2)=FORMRES
  Endif
  I+=1
  Next

# date type tests
  For J=1 To (I-2)/2
    RESULT=format$(FORMATS_DATE(J),DATE_TEST)
    # Résultat non garanti, la seconde peut être passée
    RESULTATS_DATE(J)+=string$(instr(1,FORMATS_DATE(J),"[ ]hh[:]mm[:]ss")<>0," "+time$)
    #Call CHECK_EQUAL(RESULT, RESULTATS_DATE(J), FORMATS_DATE(J)) From AXUNIT
    Call CHECK_EQUAL(RESULT, RESULTATS_DATE(J)) From AXUNIT
  Next J

# additional date types
Call SET_LOCALE("en-US") From ASYRQLF                       # Change language

RESULT = format$("DD1",[1/1/2013])
EXPECT = "01/01"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

RESULT = format$("DD2",[1/1/2013])
EXPECT = "01/01/13"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

Local Datetime MY_DATETIME

MY_DATETIME = gdatetime$("2013-01-01T01:10:20Z")

RESULT = format$("DD3",MY_DATETIME)
EXPECT = "01 January 2013"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

RESULT = format$("DD4",MY_DATETIME)
EXPECT = "01 January 2013 01:10:20"
Call CHECK_EQUAL(RESULT, EXPECT) From AXUNIT

Call SET_LOCALE("fr-FR") From ASYRQLF
# datetime type tests
  Local Datetime DATETIME_TEST
  DATETIME_TEST = gdatetime$("1959-05-29T01:10:20Z")
    For J=1 To (I-2)/2
    RESULT=format$(FORMATS_DATE(J),DATETIME_TEST)
    If instr(1,FORMATS_DATE(J),"[ ]hh[:]mm[:]ss")<>0
      RESULTATS_DATE(J)="29-05-1959 01:10:20"
    Endif
    Call CHECK_EQUAL(RESULT, RESULTATS_DATE(J)) From AXUNIT
  Next J

End

Subprog NUM_TEST()
  Local Char FORMATS_NUM(100)(1..40)
  Local Char RESULTATS_NUM(100)(1..40)
  Local Decimal NUM_TEST
  Local Char FORMRES(100),RESULT(100)

  NUM_TEST=arr(pi*10^12,10^-3)

  Local Integer I,J

  Local Char SAV_ADXSCA(10)
  SAV_ADXSCA = adxsca
  # Une variable système à affecter
  # Attention, les caractères différents de "?" restent significatifs
  adxsca="??"   : # Obsolète
  adxsca+="."   : # séparateur groupes de 3 chiffres - digit separator
  adxsca+=","   : # séparateur décimal - radix point
  adxsca+="#"   : # caractère dépassement - numeric overflow character
  adxsca+="*"   : # remplissage avant chiffres - padding character
  adxsca+="???" : # obsolète



  I=2
  For FORMRES="N:4",                       "####",
&          "N:4#",                       "####",
&          "N:13",                       "3141592653589",
&          "N:14#",                      " 3141592653589",
&          "N:14#.2#",                   " 3141592653589,79",
&          "NZ:14#.5#",                  " 3141592653589,79300",
&          "N0:14#.3#",                  "03141592653589,793",
&          "N0:16.3",                    "0003141592653589,793",
&          "N0:6",                       "######",
&          "N*:16.3",                    "***3141592653589,793",
&          "N30*:16.8",                  "***3.141.592.653.589,79300000",
&          "N30*-D:16.3",                "***3.141.592.653.589,793+",
&          "N:[Montant:]14#.2[ Euros]",  "Montant: 3141592653589,79 Euros",
&         "NB:[Montant:]14#.2[ Euros]",  "         3141592653589 79      "

  If mod(I,2)=0
      FORMATS_NUM(I/2)=FORMRES
  Else
      RESULTATS_NUM((I-1)/2)=FORMRES
  Endif
  I+=1
  Next


  For J=1 To (I-2)/2
    RESULT=format$(FORMATS_NUM(J),NUM_TEST)
    #Call CHECK_EQUAL(RESULT, RESULTATS_NUM(J), FORMATS_NUM(J)) From AXUNIT
    Call CHECK_EQUAL(RESULT, RESULTATS_NUM(J)) From AXUNIT
  Next J

# additional cases
# change adxsca radix and digit separator
  # Une variable système à affecter
  # Attention, les caractères différents de "?" restent significatifs
  adxsca="??"   : # Obsolète
  adxsca+=","   : # séparateur groupes de 3 chiffres - digit separator
  adxsca+="."   : # séparateur décimal - radix point
  adxsca+="#"   : # caractère dépassement - numeric overflow character
  adxsca+="*"   : # remplissage avant chiffres - padding character
  adxsca+="???" : # obsolète

Local Char EXPECT(250)
RESULT = format$("Nz:9.2[ Euros]",0)
EXPECT = "                  "
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("ND:5.2",-pi)
EXPECT = "    3.14-"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("ND:5.2",pi)
EXPECT = "    3.14"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("N+:5.2",1.5)
EXPECT = "    1.50"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("N+:5.2",-1.5)
EXPECT = "    0.00"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("ND-:5.2",-pi)
EXPECT = "    3.14-"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("ND-:5.2",pi)
EXPECT = "    3.14+"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("N-:5.2",-pi)
EXPECT = "   -3.14"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("N-:5.2",pi)
EXPECT = "   +3.14"
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

adxsca = SAV_ADXSCA

RESULT = format$("N-:5.2)", "ABCDE")
EXPECT = ""
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT

RESULT = format$("K:10X", 123.12)
EXPECT = "          "
Call CHECK_EQUAL(RESULT,EXPECT) From AXUNIT
End
