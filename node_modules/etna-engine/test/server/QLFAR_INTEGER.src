Local Clbfile TOTO
TOTO =  func TESTSUITE()
Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_INTEGER_"+GACTX.USER
Call LEC_TRACE From LECFIC

End

# ---------- TC_SUITE uni function       -------------------------
# ------------------------------------------------------------------

Funprog TESTSUITE()

    Call ADD_TESTCASE("TC_LOCAL_INTEGER", "Test local integer base ", 39) From AXUNIT
    Call ADD_TESTCASE("TC_GLOBAL_INTEGER", "Test global integer base ", 39) From AXUNIT
    Call ADD_TESTCASE("TC_CROSS", "Test cross base", 39) From AXUNIT
    Call ADD_TESTCASE("TC_FUNCTIONS", "Test integer/function", 69) From AXUNIT
    Call ADD_TESTCASE("TC_OVERFLOW", "Test overflow", 12) From AXUNIT

End func AXUNIT.RUN_TESTSUITE("Types", "Common")

# -----------------------TC_LOCALL_INTEGER ---------------------------------
# #####################################################################

Subprog TC_GLOBAL_INTEGER( )
Global Integer A, B, C

A=9
[V]B=12
Call CHECK_EQUAL( [V]A, 9 ) From AXUNIT
Call CHECK_EQUAL( B, 12 ) From AXUNIT

C = A+B
Call CHECK_EQUAL( [V]C, 21 ) From AXUNIT
C = A-B
Call CHECK_EQUAL( [V]C, -3 ) From AXUNIT
C = A*B
Call CHECK_EQUAL( [V]C, 108 ) From AXUNIT
Call CHECK_EQUAL( [V]A/B,9/12 ) From AXUNIT

A = 5.2
Call CHECK_EQUAL( [V]A, 5 ) From AXUNIT
[V]A = 5.6
Call CHECK_EQUAL( A, 5 ) From AXUNIT

A = -5.2
Call CHECK_EQUAL( [V]A, -5 ) From AXUNIT
[V]A = -5.6
Call CHECK_EQUAL( A, -5 ) From AXUNIT

A = 1
B = 1
Call CHECK_EQUAL( A and [V]B, 1 ) From AXUNIT
B = 0
Call CHECK_EQUAL( [V]A and B, 0 ) From AXUNIT
A = 0
Call CHECK_EQUAL( A and [V]B, 0 ) From AXUNIT

A = 1
B = 1
Call CHECK_EQUAL( [V]A or [V]B, 1 ) From AXUNIT
B = 0
Call CHECK_EQUAL( [V]A or B, 1 ) From AXUNIT
A = 0
Call CHECK_EQUAL( A or [V]B, 0 ) From AXUNIT

A = 1
B = 1
Call CHECK_EQUAL( A xor [V]B, 0 ) From AXUNIT
B = 0
Call CHECK_EQUAL( [V]A xor B, 1 ) From AXUNIT
A = 0
Call CHECK_EQUAL( [V]A xor B, 0 ) From AXUNIT


A = 16
B = 7
C = mod(A, [V]B)
Call CHECK_EQUAL( C, 2 ) From AXUNIT
A = 16
B = 7
C = mod(B, A)
Call CHECK_EQUAL( C,[V]B ) From AXUNIT
C = mod(B, 0)
Call CHECK_EQUAL( [V]C, B ) From AXUNIT


A = 4
B = 3
[V]C = A^B
Call CHECK_EQUAL( C, 64 ) From AXUNIT

A = 0
B = 3
C = A^B
Call CHECK_EQUAL([V] C, 0 ) From AXUNIT

A = 4
B = 0
[V]C = A^B
Call CHECK_EQUAL( C, 1 ) From AXUNIT

[V]A=6
[V]B=5

Call CHECK_EQUAL( [V]A > [V]B, 1 ) From AXUNIT
Call CHECK_EQUAL( [V]B > [V]A, 0 ) From AXUNIT
Call CHECK_EQUAL( [V]A >= [V]B, 1 ) From AXUNIT
Call CHECK_EQUAL( [V]B >= [V]B, 1 ) From AXUNIT
Call CHECK_EQUAL( [V]B >= [V]A, 0 ) From AXUNIT

Call CHECK_EQUAL( [V]A < [V]B, 0 ) From AXUNIT
Call CHECK_EQUAL( [V]B < [V]A, 1 ) From AXUNIT
Call CHECK_EQUAL( [V]A <= [V]B, 0 ) From AXUNIT
Call CHECK_EQUAL( [V]B <= [V]B, 1 ) From AXUNIT
Call CHECK_EQUAL( [V]B <= [V]A, 1 ) From AXUNIT

Call CHECK_EQUAL( [V]B = [V]A, 0 ) From AXUNIT
Call CHECK_EQUAL( [V]B = [V]B, 1 ) From AXUNIT
Call CHECK_EQUAL( [V]B <> [V]A, 1 ) From AXUNIT
Call CHECK_EQUAL( [V]B <> [V]B, 0 ) From AXUNIT
End

Subprog TC_LOCAL_INTEGER( )
Local Integer A, B, C

A = 5
B = 3
Call CHECK_EQUAL( A, 5 ) From AXUNIT
Call CHECK_EQUAL( B, 3 ) From AXUNIT

C = A+B
Call CHECK_EQUAL( C, 8 ) From AXUNIT
C = A-B
Call CHECK_EQUAL( C, 2 ) From AXUNIT
C = A*B
Call CHECK_EQUAL( C, 15 ) From AXUNIT
Call CHECK_EQUAL( A/B, 5/3 ) From AXUNIT

A = 5.2
Call CHECK_EQUAL( A, 5 ) From AXUNIT
A = 5.6
Call CHECK_EQUAL( A, 5 ) From AXUNIT

A = -5.2
Call CHECK_EQUAL( A, -5 ) From AXUNIT
A = -5.6
Call CHECK_EQUAL( A, -5 ) From AXUNIT

A = 1
B = 1
Call CHECK_EQUAL( A and B, 1 ) From AXUNIT
B = 0
Call CHECK_EQUAL( A and B, 0 ) From AXUNIT
A = 0
Call CHECK_EQUAL( A and B, 0 ) From AXUNIT

A = 1
B = 1
Call CHECK_EQUAL( A or B, 1 ) From AXUNIT
B = 0
Call CHECK_EQUAL( A or B, 1 ) From AXUNIT
A = 0
Call CHECK_EQUAL( A or B, 0 ) From AXUNIT

A = 1
B = 1
Call CHECK_EQUAL( A xor B, 0 ) From AXUNIT
B = 0
Call CHECK_EQUAL( A xor B, 1 ) From AXUNIT
A = 0
Call CHECK_EQUAL( A xor B, 0 ) From AXUNIT


A = 16
B = 7
C = mod(A, B)
Call CHECK_EQUAL( C, 2 ) From AXUNIT
A = 16
B = 7
C = mod(B, A)
Call CHECK_EQUAL( C, B ) From AXUNIT
C = mod(B, 0)
Call CHECK_EQUAL( C, B ) From AXUNIT


A = 4
B = 3
C = A^B
Call CHECK_EQUAL( C, 64 ) From AXUNIT

A = 0
B = 3
C = A^B
Call CHECK_EQUAL( C, 0 ) From AXUNIT

A = 4
B = 0
C = A^B
Call CHECK_EQUAL( C, 1 ) From AXUNIT



Call CHECK_EQUAL( 6 > 5, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 > 6, 0 ) From AXUNIT
Call CHECK_EQUAL( 6 >= 5, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 >= 5, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 >= 6, 0 ) From AXUNIT

Call CHECK_EQUAL( 6 < 5, 0 ) From AXUNIT
Call CHECK_EQUAL( 5 < 6, 1 ) From AXUNIT
Call CHECK_EQUAL( 6 <= 5, 0 ) From AXUNIT
Call CHECK_EQUAL( 5 <= 5, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 <= 6, 1 ) From AXUNIT

Call CHECK_EQUAL( 5 = 6, 0 ) From AXUNIT
Call CHECK_EQUAL( 5 = 5, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 <> 6, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 <> 5, 0 ) From AXUNIT

End

Subprog TC_CROSS( )
Local Integer A,B,C
Local Decimal B, C

A = 5
B = 3.2
Call CHECK_EQUAL( A, 5 ) From AXUNIT
Call CHECK_EQUAL( B, 3.2 ) From AXUNIT

C = A+B
Call CHECK_EQUAL( C, 8.2 ) From AXUNIT
C = A-B
Call CHECK_EQUAL( C, 1.8 ) From AXUNIT
C = A*B
Call CHECK_EQUAL( C, 16 ) From AXUNIT
Call CHECK_EQUAL( A/B, 50/32 ) From AXUNIT

A = 5.2
Call CHECK_EQUAL( A, 5 ) From AXUNIT
A = 5.6
Call CHECK_EQUAL( A, 5 ) From AXUNIT

A = -5.2
Call CHECK_EQUAL( A, -5 ) From AXUNIT
A = -5.6
Call CHECK_EQUAL( A, -5 ) From AXUNIT

A = 1
B = 1.4
Call CHECK_EQUAL( A and B, 1 ) From AXUNIT
B = 0
Call CHECK_EQUAL( A and B, 0 ) From AXUNIT
A = 0
Call CHECK_EQUAL( A and B, 0 ) From AXUNIT

A = 1
B = 1.4
Call CHECK_EQUAL( A or B, 1 ) From AXUNIT
B = 0
Call CHECK_EQUAL( A or B, 1 ) From AXUNIT
A = 0
Call CHECK_EQUAL( A or B, 0 ) From AXUNIT

A = 1
B = 1.4
Call CHECK_EQUAL( A xor B, 0 ) From AXUNIT
B = 0
Call CHECK_EQUAL( A xor B, 1 ) From AXUNIT
A = 0
Call CHECK_EQUAL( A xor B, 0 ) From AXUNIT


A = 16
B = 7.3
C = mod(A, B)
Call CHECK_EQUAL( C, 1.4 ) From AXUNIT
A = 16
B = 7.3
C = mod(B, A)
Call CHECK_EQUAL( C, B ) From AXUNIT
C = mod(B, 0)
Call CHECK_EQUAL( C, B ) From AXUNIT


A = 4
B = 3
C = A^B
Call CHECK_EQUAL( C, 64 ) From AXUNIT

A = 0
B = 3
C = A^B
Call CHECK_EQUAL( C, 0 ) From AXUNIT

A = 4
B = 0
C = A^B
Call CHECK_EQUAL( C, 1 ) From AXUNIT



Call CHECK_EQUAL( 6 > 5.1, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 > 6.3, 0 ) From AXUNIT
Call CHECK_EQUAL( 6 >= 5.3, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 >= 5, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 >= 6.3, 0 ) From AXUNIT

Call CHECK_EQUAL( 6 < 5.3, 0 ) From AXUNIT
Call CHECK_EQUAL( 5 < 6.3, 1 ) From AXUNIT
Call CHECK_EQUAL( 6 <= 5.3, 0 ) From AXUNIT
Call CHECK_EQUAL( 5 <= 5, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 <= 6.3, 1 ) From AXUNIT

Call CHECK_EQUAL( 5 = 6.3, 0 ) From AXUNIT
Call CHECK_EQUAL( 5 = 5, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 <> 6.3, 1 ) From AXUNIT
Call CHECK_EQUAL( 5 <> 5, 0 ) From AXUNIT

End

Subprog CHECK_EVAL(STR, RESULT)
Call CHECK_EQUAL(evalue(STR), RESULT)
End

Subprog CHECK_EQUAL(GOT, EXPECT)
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume


Subprog TC_FUNCTIONS
Integer EX
Local Integer V0,V1
Local Integer AI(1..)
Local Integer I
V0 = 5 : Call CHECK_EQUAL(abs(V0), V0)
V0 = -5 : Call CHECK_EQUAL(abs(V0), -V0)
V0 = 0 : Call CHECK_EQUAL(abs(V0), V0)

V0 = 100
V7 = 7
Call CHECK_EQUAL(mod(100,7)  ,2)
V0 = -100
V7 = 7
Call CHECK_EQUAL(mod(V0,7) ,-2)

Call CHECK_EQUAL(sgn(0), 0)
Call CHECK_EQUAL(sgn(3), 1)
Call CHECK_EQUAL(sgn(-3), -1)

Call CHECK_EQUAL(sqr(9), 3)
Call CHECK_EQUAL(sqr(49), 7)

Call CHECK_EQUAL(ar2(5), 5)

Call CHECK_EQUAL(arr(5, 1), 5)

Call CHECK_EQUAL(fix(3), 3)
Call CHECK_EQUAL(fix(-3), -3)

Call CHECK_EQUAL(val("3"), 3)
Call CHECK_EQUAL(val("-3"), -3)

Call CHECK_EVAL("1 and 1", 1)
Call CHECK_EVAL("1 and 0", 0)
Call CHECK_EVAL("0 and 1", 0)
Call CHECK_EVAL("0 and 0", 0)

Call CHECK_EVAL("not(1=1)", 0)
Call CHECK_EVAL("not(1=0)", 1)

Call CHECK_EVAL("1 or 1", 1)
Call CHECK_EVAL("1 or 0", 1)
Call CHECK_EVAL("0 or 1", 1)
Call CHECK_EVAL("0 or 0", 0)

Call CHECK_EVAL("1 xor 1", 0)
Call CHECK_EVAL("1 xor 0", 1)
Call CHECK_EVAL("0 xor 1", 1)
Call CHECK_EVAL("0 xor 0", 0)


Call CHECK_EQUAL(anp(7,3), 210)

Call CHECK_EQUAL(cnp(7,3), 35)

Call CHECK_EQUAL(fac(6), 720)

Call CHECK_EQUAL(ar2(avg(3,5,2,7,9,8)), 5.67)
Call CHECK_EQUAL(ar2(avg(2,3,4,5,6,7)), 4.50)
I+= 1 : AI(I) =  2
I+= 1 : AI(I) =  3
I+= 1 : AI(I) =  4
I+= 1 : AI(I) =  5
I+= 1 : AI(I) =  6
I+= 1 : AI(I) =  7
Call CHECK_EQUAL(ar2(avg(AI)), 4.50)

Call CHECK_EQUAL(find(2,3,5,2,7,9,8), 3)
Call CHECK_EQUAL(find(1,3,5,2,7,9,8), 0)
Call CHECK_EQUAL(find(8,3,5,2,7,9,8), 6)

Local Integer AD(1..6),I
I+= 1 : AD(I) =  3
I+= 1 : AD(I) =  5
I+= 1 : AD(I) =  2
I+= 1 : AD(I) =  7
I+= 1 : AD(I) =  9
I+= 1 : AD(I) =  8
Call CHECK_EQUAL(find(2,AD), 3)
Call CHECK_EQUAL(find(1,AD), 0)
Call CHECK_EQUAL(find(8,AD), 6)

Local Integer BI(1..)
I=  1 : BI(I) =  3
I+= 1 : BI(I) =  5
I+= 1 : BI(I) =  2
I+= 1 : BI(I) =  7
I+= 1 : BI(I) =  9
I+= 1 : BI(I) =  8
Call CHECK_EQUAL(find(2,BI), 3)
Call CHECK_EQUAL(find(1,BI), 0)
Call CHECK_EQUAL(find(8,BI), 6)

Local Integer CI(0..5)
I = 0 : CI(I) =  3
I+= 1 : CI(I) =  5
I+= 1 : CI(I) =  2
I+= 1 : CI(I) =  7
I+= 1 : CI(I) =  9
I+= 1 : CI(I) =  8
Call CHECK_EQUAL(find(2,CI), 3)
Call CHECK_EQUAL(find(1,CI), 0)
Call CHECK_EQUAL(find(8,CI), 6)

Local Integer DI(0..)
I = 0 : DI(I) =  3
I+= 1 : DI(I) =  5
I+= 1 : DI(I) =  2
I+= 1 : DI(I) =  7
I+= 1 : DI(I) =  9
I+= 1 : DI(I) =  8
Call CHECK_EQUAL(find(2,DI), 3)
Call CHECK_EQUAL(find(1,DI), 0)
Call CHECK_EQUAL(find(8,DI), 6)


Call CHECK_EQUAL(max(3,5,2,7,9,8), 9)

I+= 1 : AI(I) =  3
I+= 1 : AI(I) =  5
I+= 1 : AI(I) =  2
I+= 1 : AI(I) =  7
I+= 1 : AI(I) =  9
I+= 1 : AI(I) =  8
Call CHECK_EQUAL(max(AI), 9)

Call CHECK_EQUAL(min(3,5,2,7,9,8), 2)
Local Integer AI(1..),I :
I+= 1 : AI(I) =  3
I+= 1 : AI(I) =  5
I+= 1 : AI(I) =  2
I+= 1 : AI(I) =  7
I+= 1 : AI(I) =  9
I+= 1 : AI(I) =  8
Call CHECK_EQUAL(min(AI), 2)

Call CHECK_EQUAL(prd(1,2,3,4,5), fac(5))
Local Integer AD5(1..5),I :
I+= 1 : AD5(I) =  I
I+= 1 : AD5(I) =  I
I+= 1 : AD5(I) =  I
I+= 1 : AD5(I) =  I
I+= 1 : AD5(I) =  I
Call CHECK_EQUAL(prd(AD5), fac(5))

Call CHECK_EQUAL(sum(1,2,3,4,5,6,7), 28)
Local Integer AI(1..),I :
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I

Call CHECK_EQUAL("AI(1)","AI(1)")
Call CHECK_EQUAL(AI(1),1)
Call CHECK_EQUAL("AI(2)","AI(2)")
Call CHECK_EQUAL(AI(2),2)


Call CHECK_EQUAL(sum(AI), 28)
Call CHECK_EQUAL(sum('TC','_','SUM'), "TC_SUM")

Local Integer AI(1..),I :
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
Call CHECK_EQUAL(uni(AI), 0)
AI(4) = 1
Call CHECK_EQUAL(uni(AI), 4)

Local Integer AI(1..),I :
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
Call CHECK_EQUAL(var(AI), 4)
Call CHECK_EQUAL(var(1,2,3,4,5,6,7), 4)
Call CHECK_EQUAL(var(5,10,15,20,25,30,35), 100)

End

Subprog TC_OVERFLOW( )
Local Integer I
Local Shortint S
Local Tinyint T

I = 2^31-1
Call CHECK_EQUAL(I, 2^31-1)
I = -2^31+1
Call CHECK_EQUAL(I, -2^31+1)

EX = 50
Onerrgo ERROR
I = 2^31
EX = 50
I = -2^31
Onerrgo

S = 2^15-1
Call CHECK_EQUAL(S, 2^15-1)
S = -2^15+1
Call CHECK_EQUAL(S, -2^15+1)

EX = 13
Onerrgo ERROR
S = 2^15
EX = 13
S = -2^15-1
Onerrgo

T = 0
Call CHECK_EQUAL(T, 0)
T = 255
Call CHECK_EQUAL(T, 255)

EX = 13
Onerrgo ERROR
T = 256
EX = 13
T = -1
Onerrgo

End









End
