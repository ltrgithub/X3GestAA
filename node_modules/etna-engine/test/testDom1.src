# Test Syracuse Dom 1
# Un petit test sur diverses fonctions de chaînes : vireblc, string$, sigma, right$, mid$, len
# au passage on utilise aussi rnd
# Utilisation de For, Case, func, variables globales et locales, variables passées en valeur dans
# des sous-programmes
# Quelques déclarations (toutes ne sont pas faites à dessein)
Local Char CHAINE(255)
Global Char PONCTUATION(100)
Global Integer OPTION_TRACE
Global Char FICHIER_TRACE(200)
Local Integer J
Local Integer TIME_START

 
  [V]PONCTUATION=",.;:!?/*-+='"+'"'+"{([<|>])}"
  [V]OPTION_TRACE=1
  [V]FICHIER_TRACE=filpath("TRA",trtcou,"tra")
for PASS=1 to 1
  TIME_START=time
 
for REPETONS=1 to 100000 # increase to bench!
#If mod(REPETONS, 100) = 0 Then CallJS sync printMemory() From "etna-engine/lib/helpers" : Endif

CHAINE=""
For I=0 To 10
 
    Case I
        When 0 : CHAINE+=func PONCTUONS(5)
        When 1 : CHAINE+="hun"+func PONCTUONS(I)
        When 2 : CHAINE+="d'eux"+func PONCTUONS(I)
        When 3 : CHAINE+="Troie"+func PONCTUONS(I)
        When 4 : CHAINE+="carte"+func PONCTUONS(I)
        When 5 : CHAINE+="sync"+func PONCTUONS(I)
        When 6 : CHAINE+="size"+func PONCTUONS(I)
        When 7 : CHAINE+="cette"+func PONCTUONS(I)
        When 8 : CHAINE+="huitre"+func PONCTUONS(I)
        When 9 : CHAINE+="neuve"+func PONCTUONS(I)
        When 10 : CHAINE+="dise"+func PONCTUONS(I)
    Endcase
    J=func COMPTE_MOTS(CHAINE)
    K=func DECOMPTE_MOTS(CHAINE)
    L=func RECOMPTE_MOTS(CHAINE)
 
    If REPETONS=1
    Call TRACE_ERRBOX (CHAINE+"  ==>"+num$(J)-"mot"+string$(J>1,"s"))
    Endif
 
    If J<>I+(I>=2)
        Call TRACE_ERRBOX ("Erreur : la longueur calculée par COMPTE_MOTS n'est pas bonne"-num$(J))
    Endif
    If J<>K
        Call TRACE_ERRBOX ("Erreur : la longueur calculée par DECOMPTE_MOTS n'est pas bonne"-num$(K))
    Endif
 
    If J<>L
        Call TRACE_ERRBOX ("Erreur : la longueur calculée par RECOMPTE_MOTS n'est pas bonne"-num$(K))
    Endif
 
    Next I
Next REPETONS
    Call TRACE_ERRBOX ("Time : "-num$(time-TIME_START))
Next PASS
End
 
 
 
# Décompte du nombre de mots dans une chaine
Funprog COMPTE_MOTS(CHAINE)
Value Char CHAINE
 
# un peu de nettoyage d'abord
CHAINE=vireblc(vireblc(ctrans(CHAINE,[V]PONCTUATION, space$(len([V]PONCTUATION))),5),2)
#ErrBox("cleaned: " + CHAINE)
# Et voilà !
End len(CHAINE)-len(vireblc(CHAINE,4))+(len(CHAINE)<>0)
 
# Décompte du nombre de mots dans une chaine, second algorithme
Funprog DECOMPTE_MOTS(CHAINE)
Value Char CHAINE
Local Integer K
 
# un peu de nettoyage d'abord
CHAINE=vireblc(vireblc(ctrans(CHAINE,[V]PONCTUATION, space$(len([V]PONCTUATION))),5),2)
 
K=0
While CHAINE<>""
    K+=1
    CHAINE=vireblc(right$(CHAINE,1+len(vireblc(CHAINE,3))),2)
Wend

# Et voilà !
End K
 
# Décompte du nombre de mots dans une chaine, troisième algorithme
Funprog RECOMPTE_MOTS(CHAINE)
Value Char CHAINE
Local Integer K,L
 
# un peu de nettoyage d'abord
CHAINE=vireblc(vireblc(ctrans(CHAINE,[V]PONCTUATION, space$(len([V]PONCTUATION))),5),2)
 
K=0
If CHAINE<>""
    Repeat
        L=instr(L+1,CHAINE," ")
        K+=1
        Break (L=0)
    Until 1<>1
Endif
 
# Et voilà !
End K
 
 
# Une ponctuation au hasard
Funprog PONCTUONS(I)
Value Integer I
End " "+sigma(1,max(I,1),mid$([V]PONCTUATION,int(1+rnd(len([V]PONCTUATION))),1))+" "
 
 
 
# Trace à l'écran ou en fichier
Subprog TRACE_ERRBOX(CHAINE)
Value Char CHAINE
 
If [V]OPTION_TRACE=1
    Errbox CHAINE
Else
    # Append, je sais que ce n'est pas optimisé, mais c'est fait exprès, na !!!
    Openo [V]FICHIER_TRACE, -1
    adxifs=chr$(13)+chr$(10) : adxirs=""
    Wrseq CHAINE
    Openo
Endif
End
